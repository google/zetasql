//
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql.resolvedast";
option java_multiple_files = true;
option java_outer_classname = "ZetaSQLResolvedASTEnums";

// These are enums that are used in the Resolved AST nodes.
// Enum type and values under <cpp_class_name>Enums will be "imported" to the
// corresponding C++ class as typedefs and static consts, so that they can be
// referred to under the class name.
// E.g. ResolvedSubqueryExprEnums::SubqueryType::SCALAR can be referred to with
// ResolvedSubqueryExpr::SCALAR.

message ResolvedSubqueryExprEnums {
  enum SubqueryType {
    SCALAR = 0;
    ARRAY = 1;
    EXISTS = 2;
    IN = 3;
  }
}

message ResolvedJoinScanEnums {
  enum JoinType {
    INNER = 0;
    LEFT = 1;
    RIGHT = 2;
    FULL = 3;
  }
}

message ResolvedSetOperationScanEnums {
  enum SetOperationType {
    UNION_ALL = 0;
    UNION_DISTINCT = 1;
    INTERSECT_ALL = 2;
    INTERSECT_DISTINCT = 3;
    EXCEPT_ALL = 4;
    EXCEPT_DISTINCT = 5;
  }
}

message ResolvedRecursiveScanEnums {
  enum RecursiveSetOperationType {
    UNION_ALL = 0;
    UNION_DISTINCT = 1;
  }
}

message ResolvedSampleScanEnums {
  enum SampleUnit {
    ROWS = 0;
    PERCENT = 1;
  }
}

message ResolvedOrderByItemEnums {
  enum NullOrderMode {
    ORDER_UNSPECIFIED = 0;
    NULLS_FIRST = 1;
    NULLS_LAST = 2;
  }
}

message ResolvedCreateStatementEnums {
  enum CreateScope {
    CREATE_DEFAULT_SCOPE = 0;
    CREATE_PRIVATE = 1;
    CREATE_PUBLIC = 2;
    CREATE_TEMP = 3;
  }
  enum CreateMode {
    CREATE_DEFAULT = 0;
    CREATE_OR_REPLACE = 1;
    CREATE_IF_NOT_EXISTS = 2;
  }
  enum SqlSecurity {
    SQL_SECURITY_UNSPECIFIED = 0;
    SQL_SECURITY_DEFINER = 1;
    SQL_SECURITY_INVOKER = 2;
  }
  enum DeterminismLevel {
    DETERMINISM_UNSPECIFIED = 0;
    DETERMINISM_DETERMINISTIC = 1;
    DETERMINISM_NOT_DETERMINISTIC = 2;
    DETERMINISM_IMMUTABLE = 3;
    DETERMINISM_STABLE = 4;
    DETERMINISM_VOLATILE = 5;
  }
}

message ResolvedDropStmtEnums {
  enum DropMode {
    DROP_MODE_UNSPECIFIED = 0;
    RESTRICT = 1;
    CASCADE = 2;
  }
}

message ResolvedBeginStmtEnums {
  enum ReadWriteMode {
    MODE_UNSPECIFIED = 0;
    MODE_READ_ONLY = 1;
    MODE_READ_WRITE = 2;
  }
}

message ResolvedWindowFrameEnums {
  enum FrameUnit {
    ROWS = 0;
    RANGE = 1;
  }
}

message ResolvedWindowFrameExprEnums {
  enum BoundaryType {
    UNBOUNDED_PRECEDING = 0;
    OFFSET_PRECEDING = 1;
    CURRENT_ROW = 2;
    OFFSET_FOLLOWING = 3;
    UNBOUNDED_FOLLOWING = 4;
  }
}

message ResolvedInsertStmtEnums {
  // This defines the behavior of INSERT when there are duplicate rows.
  // "Duplicate" generally mean rows with identical primary keys.
  enum InsertMode {
    OR_ERROR = 0;    // Give an error.
    OR_IGNORE = 1;   // Skip the duplicate row.
    OR_REPLACE = 2;  // Replace the row.
    OR_UPDATE = 3;   // Merge inserted columns into the existing row.
                     // Preseve existing values of unreferenced columns.
  }
}

message ResolvedMergeWhenEnums {
  enum MatchType {
    MATCHED = 0;                // WHEN MATCHED ... THEN clause.
    NOT_MATCHED_BY_SOURCE = 1;  // WHEN NOT MATCHED BY SOURCE ... THEN clause.
    NOT_MATCHED_BY_TARGET = 2;  // WHEN NOT MATCHED BY TARGET ... THEN clause.
  }

  enum ActionType {
    INSERT = 0;
    UPDATE = 1;
    DELETE = 2;
  }
}

// Note: These enums are imported in both ResolvedArgument{Def,Ref}, using a
// hack in gen_resolved_ast.py.
message ResolvedArgumentDefEnums {
  // This describes the type of argument in a CREATE FUNCTION signature.
  enum ArgumentKind {
    SCALAR = 0;         // An argument to a scalar (non-aggregate) function.
    AGGREGATE = 1;      // An aggregate argument to an aggregate function.
    NOT_AGGREGATE = 2;  // A non-aggregate argument to an aggregate function.
  }
}

message ResolvedFunctionCallBaseEnums {
  enum ErrorMode {
    DEFAULT_ERROR_MODE = 0;  // Return errors as usual.
    SAFE_ERROR_MODE = 1;     // If this function call returns a semantic error
                             // (based on input data, not transient server
                             // problems), return NULL instead of an error.
  }
}

message ResolvedNonScalarFunctionCallBaseEnums {
  enum NullHandlingModifier {
    DEFAULT_NULL_HANDLING = 0;  // Let each function decide how to handle nulls.
    IGNORE_NULLS = 1;
    RESPECT_NULLS = 2;
  }
}

message ResolvedAggregateHavingModifierEnums {
  enum HavingModifierKind {
    INVALID = 0;
    MAX = 1;
    MIN = 2;
  }
}

message ResolvedStatementEnums {
  // This describes the set of operations performed on objects.
  // It is currently only used for ResolvedColumns.
  // It can be READ, WRITE or both. This enum is a bitmap and values are
  // intended to be bitwise OR'd together to produce the full set of operations.
  enum ObjectAccess {
    NONE = 0;        // b0000
    READ = 1;        // b0001
    WRITE = 2;       // b0010
    READ_WRITE = 3;  // b0011
  }
}

// LINT: LEGACY_NAMES
message ResolvedImportStmtEnums {
  // This describes the type of object imported in an IMPORT statement.
  enum ImportKind {
    MODULE = 0;
    PROTO = 1;

    // User code that switches on this enum must have a default case so
    // builds won't break if new enums get added.  The user default code
    // must also throw an error, since new import types will be implicitly
    // unsupported.
    __ImportKind__switch_must_have_a_default__ = -1;
  }
}

// Enumerations for some of the foreign key column and table constraint
// attributes.
message ResolvedForeignKeyEnums {
  // FOREIGN KEY (a) REFERENCES t (r) MATCH <MatchMode>.
  enum MatchMode {
    SIMPLE = 0;
    FULL = 1;
    NOT_DISTINCT = 2;
  }

  // FOREIGN KEY (a) REFERENCES t (r) ON UPDATE|DELETE <ActionOperation>.
  enum ActionOperation {
    NO_ACTION = 0;
    RESTRICT = 1;
    CASCADE = 2;
    SET_NULL = 3;
  }
}
