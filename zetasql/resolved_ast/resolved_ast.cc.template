//
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// resolved_ast.cc GENERATED FROM resolved_ast.cc.template
#include "zetasql/resolved_ast/resolved_ast.h"

#include <type_traits>

#include "google/protobuf/descriptor.h"
#include "zetasql/common/errors.h"
#include "zetasql/public/catalog.h"
#include "zetasql/public/constant.h"
#include "zetasql/public/property_graph.h"
#include "zetasql/public/strings.h"
#include "zetasql/public/type.h"
#include "zetasql/public/types/type_parameters.h"
#include "zetasql/resolved_ast/resolved_ast_visitor.h"
#include "zetasql/common/thread_stack.h"
#include "absl/memory/memory.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_join.h"
#include "absl/strings/str_split.h"
#include "zetasql/base/source_location.h"
#include "absl/types/span.h"
#include "zetasql/base/status.h"

namespace zetasql {

namespace {

// Helper for IsDefaultValue to allow template partial specialization,
// which we can do with a class but not with a function.
template <class T>
struct TestIsDefaultValue {
  static bool IsDefaultValue(const T& value) {
    static_assert(std::is_pod<T>::value,
                  "Customize IsDefaultValue for non-POD types");
    return value == T();
  }
};
template <class T>
struct TestIsDefaultValue<std::unique_ptr<T>> {
  static bool IsDefaultValue(const std::unique_ptr<T>& value) {
    return value == nullptr;
  }
};
template <class T>
struct TestIsDefaultValue<std::shared_ptr<T>> {
  static bool IsDefaultValue(const std::shared_ptr<T>& value) {
    return value == nullptr;
  }
};
template <class T>
struct TestIsDefaultValue<std::vector<T>> {
  static bool IsDefaultValue(const std::vector<T>& value) {
    return value.empty();
  }
};
template <>
struct TestIsDefaultValue<std::string> {
  static bool IsDefaultValue(const std::string& value) {
    return value.empty();
  }
};
template <>
struct TestIsDefaultValue<Value> {
  static bool IsDefaultValue(const Value& value) {
    return !value.is_valid();
  }
};
template <>
struct TestIsDefaultValue<absl::optional<FunctionSignature>> {
  static bool IsDefaultValue(const absl::optional<FunctionSignature>& signature) {
    return !signature.has_value() ||
        (signature->NumOptionalArguments() == -1 &&
           signature->NumRepeatedArguments() == -1);
  }
};
template <>
struct TestIsDefaultValue<std::shared_ptr<ResolvedFunctionCallInfo>> {
  static bool IsDefaultValue(
      const std::shared_ptr<ResolvedFunctionCallInfo>& info) {
    return info == nullptr || info->Is<ResolvedFunctionCallInfo>();
  }
};
template <>
struct TestIsDefaultValue<ResolvedColumn> {
  static bool IsDefaultValue(const ResolvedColumn& column) {
    return !column.IsInitialized();
  }
};
template <>
struct TestIsDefaultValue<TypeParameters> {
  static bool IsDefaultValue(const TypeParameters& type_parameters) {
    return type_parameters.IsEmpty();
  }
};

template <>
struct TestIsDefaultValue<ResolvedCollation> {
  static bool IsDefaultValue(const ResolvedCollation& resolved_collation) {
    return resolved_collation.Empty();
  }
};

template <>
struct TestIsDefaultValue<TypeModifiers> {
  static bool IsDefaultValue(const TypeModifiers& type_modifiers) {
    return type_modifiers.IsEmpty();
  }
};

template <>
struct TestIsDefaultValue<ResolvedSetOperationScan::SetOperationColumnMatchMode> {
  static bool IsDefaultValue(ResolvedSetOperationScan::SetOperationColumnMatchMode mode) {
    return mode == ResolvedSetOperationScan::BY_POSITION;
  }
};

template <>
struct TestIsDefaultValue<ResolvedSetOperationScan::SetOperationColumnPropagationMode> {
  static bool IsDefaultValue(ResolvedSetOperationScan::SetOperationColumnPropagationMode mode) {
    return mode == ResolvedSetOperationScan::STRICT;
  }
};

template <>
struct TestIsDefaultValue<ResolvedOption::AssignmentOp> {
  static bool IsDefaultValue(ResolvedOption::AssignmentOp assignment_op) {
    return assignment_op == ResolvedOption::DEFAULT_ASSIGN;
  }
};

// Return true if <value> is equal to the default value for its type.
// e.g. for pointers, return true if <value> is nullptr.
// TODO This provides no way to distinguish an unset value from a
// value explicitly set to its default.  Replace this with something
// smarter and more explicit.
template <class T>
static bool IsDefaultValue(const T& value) {
  return TestIsDefaultValue<T>::IsDefaultValue(value);
}

static std::string ToStringImpl(const std::string& s) {
  return ToStringLiteral(s);
}
static std::string ToStringImpl(bool b) {
  return b ? "TRUE" : "FALSE";
}
static std::string ToStringImpl(int i) {
  return absl::StrCat(i);
}
static std::string ToStringCommaSeparated(const std::vector<int>& value_vector) {
  return absl::StrCat("[", absl::StrJoin(value_vector, ", "), "]");
}
static std::string ToStringImpl(
    const std::vector<ResolvedStatement::ObjectAccess>& value_vector) {
  std::string ret;
  for (const ResolvedStatement::ObjectAccess& value : value_vector) {
    std::string name = ResolvedStatementEnums::ObjectAccess_Name(value);
    if (name.empty()) {
      ABSL_LOG(ERROR) << "Invalid ObjectAccess: " << value;
      name = absl::StrCat("INVALID_OBJECT_ACCESS(", value, ")");
    }
    if (!ret.empty()) ret += ",";
    ret += name;
  }
  return ret;
}
static std::string ToStringImpl(ResolvedJoinScan::JoinType join_type) {
  std::string name = ResolvedJoinScanEnums::JoinType_Name(join_type);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid JoinType: " << join_type;
  return absl::StrCat("INVALID_JOIN_TYPE(", join_type, ")");
}
static std::string ToStringImpl(ResolvedSubqueryExpr::SubqueryType type) {
  std::string name = ResolvedSubqueryExprEnums::SubqueryType_Name(type);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid SubqueryType: " << type;
  return absl::StrCat("INVALID_SUBQUERY_TYPE(", type, ")");
}
static std::string ToStringImpl(ResolvedSetOperationScan::SetOperationType type) {
  std::string name = ResolvedSetOperationScanEnums::SetOperationType_Name(type);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid SetType: " << type;
  return absl::StrCat("INVALID_SET_TYPE(", type, ")");
}
static std::string ToStringImpl(ResolvedSetOperationScan::SetOperationColumnMatchMode mode) {
  std::string name = ResolvedSetOperationScanEnums::SetOperationColumnMatchMode_Name(mode);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid SetOperationColumnMatchMode: " << mode;
  return absl::StrCat("INVALID_SET_COLUMN_MATCH_MODE(", mode, ")");
}
static std::string ToStringImpl(ResolvedSetOperationScan::SetOperationColumnPropagationMode mode) {
  std::string name = ResolvedSetOperationScanEnums::SetOperationColumnPropagationMode_Name(mode);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid SetOperationColumnPropagationMode: " << mode;
  return absl::StrCat("INVALID_SET_COLUMN_PROPAGATION_MODE(", mode, ")");
}
static std::string ToStringImpl(ResolvedRecursiveScan::RecursiveSetOperationType type) {
  std::string name = ResolvedRecursiveScanEnums::RecursiveSetOperationType_Name(type);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid RecursiveSetType: " << type;
  return absl::StrCat("INVALID_SET_TYPE(", type, ")");
}
static std::string ToStringImpl(ResolvedCreateStatement::CreateScope scope) {
  std::string name = ResolvedCreateStatementEnums::CreateScope_Name(scope);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid CreateScope: " << scope;
  return absl::StrCat("INVALID_CREATE_SCOPE(", scope, ")");
}
static std::string ToStringImpl(ResolvedCreateStatement::CreateMode mode) {
  std::string name = ResolvedCreateStatementEnums::CreateMode_Name(mode);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid CreateMode: " << mode;
  return absl::StrCat("INVALID_CREATE_MODE(", mode, ")");
}

static std::string ToStringImpl(ResolvedDropStmtEnums::DropMode mode) {
  std::string name = ResolvedDropStmtEnums::DropMode_Name(mode);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid DropMode: " << mode;
  return absl::StrCat("INVALID_DROP_MODE(", mode, ")");
}
static std::string ToStringImpl(ResolvedBeginStmt::ReadWriteMode mode) {
  std::string name = ResolvedBeginStmtEnums::ReadWriteMode_Name(mode);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid ReadWriteMode: " << mode;
  return absl::StrCat("INVALID_READ_WRITE_MODE(", mode, ")");
}
static std::string ToStringImpl(ResolvedSampleScan::SampleUnit unit) {
  std::string name = ResolvedSampleScanEnums::SampleUnit_Name(unit);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid SampleUnit: " << unit;
  return absl::StrCat("INVALID_SAMPLE_UNIT(", unit, ")");
}
static std::string ToStringImpl(ResolvedMatchRecognizePatternOperation::MatchRecognizePatternOperationType op_type) {
  std::string name = ResolvedMatchRecognizePatternOperationEnums::MatchRecognizePatternOperationType_Name(op_type);
  if (!name.empty()) {
    return name;
  }
  ABSL_LOG(ERROR) << "Invalid SubqueryType: " << op_type;
  return absl::StrCat("INVALID_SUBQUERY_TYPE(", op_type, ")");
}
static std::string ToStringImpl(FieldFormat::Format format) {
  const std::string& str = FieldFormat_Format_Name(format);
  return !str.empty() ? str : absl::StrCat("INVALID_FORMAT(", format, ")");
}
static std::string ToStringImpl(ResolvedInsertStmt::InsertMode insert_mode) {
  return ResolvedInsertStmt::InsertModeToString(insert_mode);
}
static std::string ToStringImpl(
  ResolvedOnConflictClause::ConflictAction conflict_action) {
  return ResolvedOnConflictClause::ConflictActionToString(conflict_action);
}
static std::string ToStringImpl(
    ResolvedAggregateHavingModifier::HavingModifierKind kind) {
  return ResolvedAggregateHavingModifier::HavingModifierKindToString(kind);
}
static const std::string& ToStringImpl(
    ResolvedNonScalarFunctionCallBaseEnums::NullHandlingModifier kind) {
  return ResolvedNonScalarFunctionCallBaseEnums::NullHandlingModifier_Name(
      kind);
}
static std::string ToStringImpl(ResolvedArgumentDef::ArgumentKind kind) {
  const std::string& str = ResolvedArgumentDefEnums::ArgumentKind_Name(kind);
  return !str.empty() ? str : absl::StrCat("INVALID_ARGUMENT_KIND(", kind, ")");
}
static std::string ToStringImpl(ResolvedImportStmt::ImportKind kind) {
  return ResolvedImportStmt::ImportKindToString(kind);
}
static std::string ToStringImpl(ResolvedAuxLoadDataStmt::InsertionMode mode) {
  std::string name = ResolvedAuxLoadDataStmtEnums::InsertionMode_Name(mode);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid InsertionMode: " << mode;
  return absl::StrCat("INVALID_INSERTION_MODE(", mode, ")");
}
static std::string ToStringImpl(const absl::optional<FunctionSignature>& signature) {
  return signature->DebugString();
}
static std::string ToStringImpl(const std::shared_ptr<FunctionSignature>& signature) {
  return signature->DebugString();
}
static std::string ToStringImpl(
    const std::shared_ptr<ResolvedFunctionCallInfo>& function_call_info) {
  if (function_call_info == nullptr) return "<null>";
  return function_call_info->DebugString();
}
static std::string ToStringImpl(ResolvedDropIndexStmt::IndexType index_type) {
  return ResolvedDropIndexStmt::IndexTypeToString(index_type);
}
static std::string ToStringImpl(ResolvedAlterIndexStmt::AlterIndexType index_type) {
  return ResolvedAlterIndexStmt::AlterIndexTypeToString(index_type);
}
static std::string ToStringVerbose(const absl::optional<FunctionSignature>& signature) {
  return signature->DebugString("" /* function_name */, true /* verbose */);
}
static std::string ToStringVerbose(const std::shared_ptr<FunctionSignature>& signature) {
  return signature->DebugString("" /* function_name */, true /* verbose */);
}
static std::string ToStringImpl(const Table* table) {
  return table == nullptr ? "<null>" : table->FullName();
}
static std::string ToStringImpl(const Sequence* sequence) {
  return sequence->FullName();
}
static std::string ToStringImpl(const Model* model) {
  return model->FullName();
}
static std::string ToStringImpl(const Connection* connection) {
  return connection->FullName();
}
static std::string ToStringImpl(const TableValuedFunction* tvf) {
  return tvf == nullptr
    ? "<null>"
    : absl::StrCat(tvf->FullName(/*include_group=*/true), "(",
                   FunctionSignature::SignaturesToString(
                       tvf->signatures(), /*verbose=*/true, /*prefix=*/"",
                       /*separator=*/"; "),
                   ")");
}
static std::string ToStringImpl(const Procedure* procedure) {
  return procedure->FullName();
}
static std::string ToStringImpl(const Column* column) {
  return column->FullName();
}
static std::string ToStringImpl(const std::shared_ptr<TVFSignature>& tvf_signature) {
  return tvf_signature->DebugString();
}
static std::string ToStringImpl(const Type* type) {
  return type->DebugString();
}
static std::string ToStringImpl(const google::protobuf::FieldDescriptor* field) {
  return field->is_extension() ?
      absl::StrCat("[", field->full_name(), "]"): std::string(field->name());
}
static std::string ToStringVectorFieldDescriptor(const std::vector<const google::protobuf::FieldDescriptor*>& field_vector) {
  std::string output;
  for (const google::protobuf::FieldDescriptor* field : field_vector) {
    if (!output.empty()) {
      absl::StrAppend(&output, ".");
    }
    absl::StrAppend(&output, ToStringImpl(field));
  }
  return output;
}

static std::string ToStringImpl(const google::protobuf::OneofDescriptor* oneof) {
  return std::string(oneof->name());
}

static std::string ToStringImpl(const ResolvedColumn& column) {
  return column.DebugString();
}
static std::string ToStringImpl(const ResolvedColumnList& column_list) {
  return ResolvedColumnListToString(column_list);
}
static std::string ToStringImpl(const Value& value) {
  return value.ShortDebugString();
}
static std::string ToStringImpl(const std::vector<std::string>& value_vector,
                           const std::string& separator) {
  std::string ret;
  for (const std::string& value : value_vector) {
    if (!ret.empty()) ret += separator;
    ret += ToIdentifierLiteral(value);
  }
  return ret;
}
static std::string ToStringImpl(const ResolvedMergeWhen::MatchType match_type) {
  std::string name = ResolvedMergeWhenEnums::MatchType_Name(match_type);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid MatchType: " << match_type;
  return absl::StrCat("INVALID_MATCH_TYPE(", match_type, ")");
}
static std::string ToStringImpl(const ResolvedMergeWhen::ActionType action_type) {
  std::string name = ResolvedMergeWhenEnums::ActionType_Name(action_type);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid ActionType: " << action_type;
  return absl::StrCat("INVALID_ACTION_TYPE(", action_type, ")");
}
static std::string ToStringImpl(ResolvedForeignKeyEnums::MatchMode match_mode) {
  std::string name = ResolvedForeignKeyEnums::MatchMode_Name(match_mode);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid MatchMode: " << match_mode;
  return absl::StrCat("INVALID_MATCH_MODE(", match_mode, ")");
}
static std::string ToStringImpl(
    ResolvedForeignKeyEnums::ActionOperation action_operation) {
  std::string name = ResolvedForeignKeyEnums::ActionOperation_Name(action_operation);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid ActionOperation: " << action_operation;
  return absl::StrCat("INVALID_ACTION_OPERATION(", action_operation, ")");
}
static std::string ToStringImpl(
    ResolvedCreateStatementEnums::SqlSecurity sql_security) {
  std::string name = ResolvedCreateStatementEnums::SqlSecurity_Name(sql_security);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid SqlSecurity: " << sql_security;
  return absl::StrCat("INVALID_SQL_SECURITY(", sql_security, ")");
}
static std::string ToStringImpl(
    ResolvedOrderByItemEnums::NullOrderMode null_order) {
  std::string name = ResolvedOrderByItemEnums::NullOrderMode_Name(null_order);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid NullOrderMode: " << null_order;
  return absl::StrCat("INVALID_NULL_ORDER(", null_order, ")");
}
static std::string ToStringImpl(
    ResolvedCreateStatementEnums::DeterminismLevel level) {
  std::string name = ResolvedCreateStatementEnums::DeterminismLevel_Name(level);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid DeterminismLevel: " << level;
  return absl::StrCat("INVALID_DETERMINISM_LEVEL(", level, ")");
}
static std::string ToStringImpl(
    ResolvedGeneratedColumnInfoEnums::StoredMode mode) {
  switch (mode) {
    case ResolvedGeneratedColumnInfoEnums::STORED:
      return "STORED";
    case ResolvedGeneratedColumnInfoEnums::STORED_VOLATILE:
      return "STORED_VOLATILE";
    default:
      ABSL_LOG(ERROR) << "Invalid StoredMode: " << mode;
      return absl::StrCat("INVALID_STORED_MODE(", mode, ")");
  }
}
static std::string ToStringImpl(
    ResolvedGeneratedColumnInfoEnums::GeneratedMode mode) {
  switch (mode) {
    case ResolvedGeneratedColumnInfoEnums::ALWAYS:
      return "ALWAYS";
    case ResolvedGeneratedColumnInfoEnums::BY_DEFAULT:
      return "BY_DEFAULT";
    default:
      ABSL_LOG(ERROR) << "Invalid GeneratedMode: " << mode;
      return absl::StrCat("INVALID_GENERATED_MODE(", mode, ")");
  }
}
static std::string ToStringImpl(ResolvedMatchRecognizeScanEnums::AfterMatchSkipMode mode) {
  std::string name =
      ResolvedMatchRecognizeScanEnums::AfterMatchSkipMode_Name(mode);
  if (!name.empty()) {
    return name;
  }
  ABSL_LOG(ERROR) << "Invalid AfterMatchSkipMode: " << mode;
  return absl::StrCat("INVALID_AFTER_MATCH_SKIP_MODE(", mode, ")");
}
static std::string ToStringImpl(ResolvedMatchRecognizePatternAnchorEnums::Mode mode) {
  std::string name =
      ResolvedMatchRecognizePatternAnchorEnums::Mode_Name(mode);
  if (!name.empty()) {
    return name;
  }
  ABSL_LOG(ERROR) << "Invalid Mode: " << mode;
  return absl::StrCat("INVALID_MODE(", mode, ")");
}
static std::string ToStringImpl(ResolvedOption::AssignmentOp assignment_op) {
  switch (assignment_op) {
    case ResolvedOptionEnums::ADD_ASSIGN:
      return "+=";
    case ResolvedOptionEnums::SUB_ASSIGN:
      return "-=";
    default:
      return "=";
  }
}

static std::string ToStringImpl(
  ResolvedLockMode::LockStrengthType lock_strength_type) {
  std::string name =
      ResolvedLockModeEnums::LockStrengthType_Name(lock_strength_type);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid LockStrengthType: " << lock_strength_type;
  return absl::StrCat("INVALID_LOCK_STRENGTH_TYPE(", lock_strength_type, ")");
}

// Most vector<std::string> fields are identifier paths so we format
// the value that way by default.
// For other vector<std::string> fields, we can override this with to_string_method.
static std::string ToStringImpl(const std::vector<std::string>& value_vector) {
  return ToStringImpl(value_vector, ".");
}
// This formats a list of identifiers (quoting if needed).
static std::string ToStringCommaSeparated(const std::vector<std::string>& value_vector) {
  return absl::StrCat("[", ToStringImpl(value_vector, ", "), "]");
}

// This formats a list of objects as "[obj, obj, ...]", using ToStringImpl
// on each object.  The template works for anything that doesn't have
// its own overload of this method.
template<class T>
static std::string ToStringCommaSeparated(const std::vector<T>& value_vector) {
  return absl::StrCat(
      "[",
      absl::StrJoin(value_vector, ",", [](std::string* out, const T& t) {
        absl::StrAppend(out, ToStringImpl(t));
      }),
      "]");
}

// Use template functions to allow functions with the same argument list but
// different return types.
template <class R, class P>
absl::StatusOr<R> RestoreFromImpl(const P& proto, const ResolvedNode::RestoreParams& params);

// The SaveToImpl(ScalarType, FileDescriptorSetMap*, ScalarProtoType*) functions
// implement the serialization logic for scalar types. The FileDescriptorSetMap
// argument is used for serialization of zetasql::Type and data structures
// that contain zetasql::Types. For detailed usage, see comments above
// Type::SerializeToProtoAndDistinctFileDescriptors().
static absl::Status SaveToImpl(
    const Table* table,
    FileDescriptorSetMap* file_descriptor_set_map,
    TableRefProto* proto) {
  if (table != nullptr) {
    proto->set_name(table->Name());
    proto->set_serialization_id(table->GetSerializationId());
    proto->set_full_name(table->FullName());
  }
  return absl::OkStatus();
}

// The RestoreFrom functions reverse the effect of the SaveTo functions.
template<>
absl::StatusOr<const Table*> RestoreFromImpl(
    const TableRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const Table* table;
  const std::vector<std::string> path = absl::StrSplit(proto.full_name(), '.');
  if (proto.has_serialization_id()) {
    ZETASQL_RETURN_IF_ERROR(params.catalog->FindTable(path, &table));
  } else {
    // The original table was a nullptr.
    table = nullptr;
  }
  return table;
}

static absl::Status SaveToImpl(
    const Model* model,
    FileDescriptorSetMap* file_descriptor_set_map,
    ModelRefProto* proto) {
  proto->set_name(model->Name());
  proto->set_serialization_id(model->GetSerializationId());
  proto->set_full_name(model->FullName());
  return absl::OkStatus();
}

// The RestoreFrom functions reverse the effect of the SaveTo functions.
template<>
absl::StatusOr<const Model*> RestoreFromImpl(
    const ModelRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const Model* model;
  const std::vector<std::string> path = absl::StrSplit(proto.full_name(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindModel(path, &model));
  return model;
}

static absl::Status SaveToImpl(
   const Connection* connection,
   FileDescriptorSetMap* file_descriptor_set_map,
   ConnectionRefProto* proto) {
  proto->set_name(connection->Name());
  proto->set_full_name(connection->FullName());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const Connection*> RestoreFromImpl(
    const ConnectionRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const Connection* connection;
  const std::vector<std::string> path = absl::StrSplit(proto.full_name(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindConnection(path, &connection,
                                                 Catalog::FindOptions()));
  return connection;
}

static absl::Status SaveToImpl(
    const Sequence* sequence,
    FileDescriptorSetMap* file_descriptor_set_map,
    SequenceRefProto* proto) {
  proto->set_name(sequence->Name());
  proto->set_full_name(sequence->FullName());
  return absl::OkStatus();
}

// The RestoreFrom functions reverse the effect of the SaveTo functions.
template<>
absl::StatusOr<const Sequence*> RestoreFromImpl(
    const SequenceRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const Sequence* sequence;
  const std::vector<std::string> path = absl::StrSplit(proto.full_name(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindSequence(path, &sequence,
                                               Catalog::FindOptions()));
  return sequence;
}

static absl::Status SaveToImpl(
    const Constant* constant,
    FileDescriptorSetMap* file_descriptor_set_map,
    ConstantRefProto* proto) {
  proto->set_name(constant->FullName());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const Constant*> RestoreFromImpl(
    const ConstantRefProto& proto, const ResolvedNode::RestoreParams& params) {
  if (proto.name().empty()) {
    return zetasql_base::InvalidArgumentErrorBuilder(zetasql_base::SourceLocation::current())
           << "Tried to parse function with blank name: "
           << absl::StrCat(proto);
  }

  const Constant* constant;
  const std::vector<std::string> path = absl::StrSplit(proto.name(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindConstant(path, &constant));
  return constant;
}

static absl::Status SaveToImpl(
    const Function* func,
    FileDescriptorSetMap* file_descriptor_set_map,
    FunctionRefProto* proto) {
  proto->set_name(func->FullName(true  /* include_group */));
  return absl::OkStatus();
}

template<>
absl::StatusOr<const Function*> RestoreFromImpl(
    const FunctionRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  // Serialized function names include the group. We do not need this to look
  // up a function in the catalog.
  const std::vector<absl::string_view> group_and_name =
      absl::StrSplit(proto.name(), ":");
  if (group_and_name.empty()) {
    return zetasql_base::InvalidArgumentErrorBuilder(zetasql_base::SourceLocation::current())
        << "Tried to parse function with blank name: " << absl::StrCat(proto);
  }

  const Function* func;
  const std::vector<std::string> path = absl::StrSplit(group_and_name.back(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindFunction(path, &func));
  return func;
}

static absl::Status SaveToImpl(
    const TableValuedFunction* func,
    FileDescriptorSetMap* file_descriptor_set_map,
    TableValuedFunctionRefProto* proto) {
  proto->set_name(func->FullName(/*include_group=*/true));
  return absl::OkStatus();
}

template<>
absl::StatusOr<const TableValuedFunction*> RestoreFromImpl(
    const TableValuedFunctionRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  // Serialized table valued function names include the group. We do not need
  // this to look up a table valued function in the catalog.
  const std::vector<absl::string_view> group_and_name =
      absl::StrSplit(proto.name(), ":");
  if (group_and_name.empty()) {
    return zetasql_base::InvalidArgumentErrorBuilder(zetasql_base::SourceLocation::current())
        << "Tried to parse table valued function with blank name: "
        << absl::StrCat(proto);
  }
  const TableValuedFunction* func;
  const std::vector<std::string> path = absl::StrSplit(group_and_name.back(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindTableValuedFunction(path, &func));
  return func;
}

static absl::Status SaveToImpl(
    const Procedure* procedure,
    FileDescriptorSetMap* file_descriptor_set_map,
    ProcedureRefProto* proto) {
  proto->set_name(procedure->FullName());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const Procedure*> RestoreFromImpl(
    const ProcedureRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const Procedure* procedure;
  const std::vector<std::string> path = absl::StrSplit(proto.name(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindProcedure(path, &procedure));
  return procedure;
}

static absl::Status SaveToImpl(
    const Column* column,
    FileDescriptorSetMap* file_descriptor_set_map,
    ColumnRefProto* proto) {

  std::string col_full_name = column->FullName();
  auto pos = col_full_name.find_last_of('.');
  ZETASQL_RET_CHECK(pos != std::string::npos);
  std::string full_table_name = col_full_name.substr(0, pos);
  const std::vector<std::string> path = absl::StrSplit(full_table_name, '.');

  TableRefProto* table = proto->mutable_table_ref();
  table->set_name(path.back());
  table->set_full_name(std::move(full_table_name));
  proto->set_name(column->Name());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const Column*> RestoreFromImpl(
    const ColumnRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const std::vector<std::string> path =
      absl::StrSplit(proto.table_ref().full_name(), '.');
  const Table* table;
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindTable(path, &table));
  return table->FindColumnByName(proto.name());
}

static absl::Status SaveToImpl(
    const absl::optional<FunctionSignature>& sig,
    FileDescriptorSetMap* file_descriptor_set_map,
    FunctionSignatureProto* proto) {
  return sig.value().Serialize(file_descriptor_set_map, proto);
}

template<>
absl::StatusOr<FunctionSignature> RestoreFromImpl(
    const FunctionSignatureProto& proto,
    const ResolvedNode::RestoreParams& params) {
  // Some fields demand being set as FunctionSignature, not
  // std::unique_ptr<FunctionSignature>. It's fine if we just copy the returned
  // one though.
  std::unique_ptr<FunctionSignature> sig;
  ZETASQL_ASSIGN_OR_RETURN(sig,
    FunctionSignature::Deserialize(
      proto, TypeDeserializer(params.type_factory, params.pools)));
  return *sig;
}

static absl::Status SaveToImpl(
    const std::shared_ptr<FunctionSignature>& sig,
    FileDescriptorSetMap* file_descriptor_set_map,
    FunctionSignatureProto* proto) {
  if (sig != nullptr) {
    return sig->Serialize(file_descriptor_set_map, proto);
  }
  return absl::OkStatus();
}

template<>
absl::StatusOr<std::shared_ptr<FunctionSignature>> RestoreFromImpl(
    const FunctionSignatureProto& proto,
    const ResolvedNode::RestoreParams& params) {
  // Some fields demand being set as FunctionSignature, not
  // std::unique_ptr<FunctionSignature>. It's fine if we just copy the returned
  // one though.
  std::unique_ptr<FunctionSignature> sig;
  ZETASQL_ASSIGN_OR_RETURN(sig,
    FunctionSignature::Deserialize(
      proto, TypeDeserializer(params.type_factory, params.pools)));
  return sig;
}

static absl::Status SaveToImpl(
    const Type* type,
    FileDescriptorSetMap* file_descriptor_set_map,
    TypeProto* proto) {
  return type->SerializeToProtoAndDistinctFileDescriptors(
      proto, file_descriptor_set_map);
}

template<>
absl::StatusOr<const Type*> RestoreFromImpl(
    const TypeProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const Type* type;
  ZETASQL_RETURN_IF_ERROR(params.type_factory->DeserializeFromProtoUsingExistingPools(
      proto, params.pools, &type));
  return type;
}

static absl::Status SaveToImpl(
    const google::protobuf::FieldDescriptor* desc,
    FileDescriptorSetMap* file_descriptor_set_map,
    FieldDescriptorRefProto* proto) {
  TypeFactory factory;
  const ProtoType* proto_type;
  ZETASQL_RETURN_IF_ERROR(factory.MakeProtoType(desc->containing_type(), &proto_type));
  TypeProto type_proto;
  ZETASQL_RETURN_IF_ERROR(proto_type->SerializeToProtoAndDistinctFileDescriptors(
      &type_proto, file_descriptor_set_map));
  *proto->mutable_containing_proto() = type_proto.proto_type();
  proto->set_number(desc->number());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const google::protobuf::FieldDescriptor*> RestoreFromImpl(
    const FieldDescriptorRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  TypeProto type_proto;
  type_proto.set_type_kind(TypeKind::TYPE_PROTO);
  *type_proto.mutable_proto_type() = proto.containing_proto();
  const Type* containing_type;
  ZETASQL_RETURN_IF_ERROR(params.type_factory->DeserializeFromProtoUsingExistingPools(
      type_proto, params.pools, &containing_type));
  const ProtoType* proto_type = containing_type->AsProto();
  if (!proto_type) {
    return zetasql_base::InvalidArgumentErrorBuilder(zetasql_base::SourceLocation::current())
        << "Expected ProtoType, got: " << containing_type->DebugString();
  }
  const google::protobuf::FieldDescriptor* field_descriptor =
      proto_type->descriptor()->FindFieldByNumber(proto.number());
  if (field_descriptor) return field_descriptor;

  // Otherwise, let's look through the extensions and see if one of those match.
  for (const auto* pool : params.pools) {
    field_descriptor = pool->FindExtensionByNumber(proto_type->descriptor(),
                                                   proto.number());
    if (field_descriptor) return field_descriptor;
  }

  return zetasql_base::InvalidArgumentErrorBuilder(zetasql_base::SourceLocation::current())
      << "Field number " << proto.number() << " is neither a field or a known "
      << "extension of " << proto_type->DebugString();
}

static absl::Status SaveToImpl(const google::protobuf::OneofDescriptor* oneof_desc,
                               FileDescriptorSetMap* file_descriptor_set_map,
                               OneofDescriptorRefProto* oneof_proto) {
  TypeFactory factory;
  const ProtoType* containing_proto_type;
  ZETASQL_RETURN_IF_ERROR(factory.MakeProtoType(oneof_desc->containing_type(),
                                        &containing_proto_type));
  TypeProto containing_proto;
  ZETASQL_RETURN_IF_ERROR(
      containing_proto_type->SerializeToProtoAndDistinctFileDescriptors(
          &containing_proto, file_descriptor_set_map));
  *oneof_proto->mutable_containing_proto() = containing_proto.proto_type();
  oneof_proto->set_index(oneof_desc->index());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const google::protobuf::OneofDescriptor*> RestoreFromImpl(
    const OneofDescriptorRefProto& oneof_proto,
    const ResolvedNode::RestoreParams& params) {
  TypeProto containing_proto;
  containing_proto.set_type_kind(TypeKind::TYPE_PROTO);
  *containing_proto.mutable_proto_type() = oneof_proto.containing_proto();
  const Type* containing_type;
  ZETASQL_RETURN_IF_ERROR(params.type_factory->DeserializeFromProtoUsingExistingPools(
      containing_proto, params.pools, &containing_type));
  ZETASQL_RET_CHECK(containing_type != nullptr);
  const ProtoType* containing_proto_type = containing_type->AsProto();
  ZETASQL_RET_CHECK(containing_proto_type != nullptr);
  if (oneof_proto.index() < 0 ||
      oneof_proto.index() >=
          containing_proto_type->descriptor()->oneof_decl_count()) {
    return zetasql_base::InvalidArgumentErrorBuilder(zetasql_base::SourceLocation::current())
           << "Invalid Oneof index " << oneof_proto.index() << " in message "
           << containing_proto_type->DebugString();
  }
  return containing_proto_type->descriptor()->oneof_decl(oneof_proto.index());
}

static absl::Status SaveToImpl(
    const ResolvedColumn& column,
    FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedColumnProto* proto) {
  return column.SaveTo(file_descriptor_set_map, proto);
}

template<>
absl::StatusOr<ResolvedColumn> RestoreFromImpl(
    const ResolvedColumnProto& proto,
    const ResolvedNode::RestoreParams& params) {
  return ResolvedColumn::RestoreFrom(proto, params);
}

static absl::Status SaveToImpl(
    const Value& value,
    FileDescriptorSetMap* file_descriptor_set_map,
    ValueWithTypeProto* proto) {
  if (!value.is_valid()) {
    return absl::OkStatus();
  }
  ZETASQL_RETURN_IF_ERROR(value.Serialize(proto->mutable_value()));
  return SaveToImpl(
      value.type(), file_descriptor_set_map, proto->mutable_type());
}

template<>
absl::StatusOr<Value> RestoreFromImpl(
    const ValueWithTypeProto& proto,
    const ResolvedNode::RestoreParams& params) {
  if (!proto.has_value()) {
    // The only way you get a blank value field is by serializing an invalid
    // value. So that's what we return if we see !has_value.
    return Value();
  }
  ZETASQL_ASSIGN_OR_RETURN(const Type* type, RestoreFromImpl<const Type*>(proto.type(), params));
  return Value::Deserialize(proto.value(), type);
}

static absl::Status SaveToImpl(
    const std::shared_ptr<TVFSignature>& tvf_signature,
    FileDescriptorSetMap* file_descriptor_set_map,
    TVFSignatureProto* proto) {
  for (const TVFInputArgumentType& arg : tvf_signature->input_arguments()) {
    TVFArgumentProto* arg_proto = proto->add_argument();
    if (arg.is_relation()) {
      ZETASQL_RETURN_IF_ERROR(arg.relation().Serialize(
          file_descriptor_set_map, arg_proto->mutable_relation_argument()));
    } else if (arg.is_model()) {
      TVFModelProto* model_proto = arg_proto->mutable_model_argument();
      model_proto->set_name(arg.model().model()->Name());
      model_proto->set_full_name(arg.model().model()->FullName());
    } else if (arg.is_connection()) {
      TVFConnectionProto* connection_proto =
          arg_proto->mutable_connection_argument();
      connection_proto->set_name(arg.connection().connection()->Name());
      connection_proto->set_full_name(
          arg.connection().connection()->FullName());
    } else if (arg.is_descriptor()) {
      TVFDescriptorProto* descriptor_proto =
          arg_proto->mutable_descriptor_argument();
      for (const auto& name : arg.descriptor_argument().column_names()) {
        *(descriptor_proto->add_column_name()) = name;
      }
    } else if (arg.is_graph()) {
      TVFGraphProto* graph_proto = arg_proto->mutable_graph_argument();
      graph_proto->set_name(arg.graph().graph()->Name());
      graph_proto->set_full_name(arg.graph().graph()->FullName());
    } else {
      ZETASQL_ASSIGN_OR_RETURN(const InputArgumentType& arg_type,
                       arg.GetScalarArgType());
      ZETASQL_RETURN_IF_ERROR(SaveToImpl(
          arg_type.type(), file_descriptor_set_map,
          arg_proto->mutable_scalar_argument()->mutable_type()));
      if (arg_type.literal_value() != nullptr) {
        ZETASQL_RETURN_IF_ERROR(SaveToImpl(
            *arg_type.literal_value(), file_descriptor_set_map,
            arg_proto->mutable_scalar_argument()));
      }
    }
  }
  ZETASQL_RETURN_IF_ERROR(tvf_signature->result_schema().Serialize(
      file_descriptor_set_map, proto->mutable_output_schema()));

  for (const FreestandingDeprecationWarning& warning :
           tvf_signature->options().additional_deprecation_warnings) {
    *proto->mutable_options()->add_additional_deprecation_warning() =
        warning;
  }

  return absl::OkStatus();
}

template<>
absl::StatusOr<std::shared_ptr<TVFSignature>> RestoreFromImpl(
    const TVFSignatureProto& proto,
    const ResolvedNode::RestoreParams& params) {
  std::vector<TVFInputArgumentType> input_args;
  input_args.reserve(proto.argument_size());
  for (const TVFArgumentProto& argument : proto.argument()) {
    if (argument.has_relation_argument()) {
      ZETASQL_ASSIGN_OR_RETURN(TVFRelation r, TVFRelation::Deserialize(
          argument.relation_argument(),
          TypeDeserializer(params.type_factory, params.pools)));
      input_args.push_back(TVFInputArgumentType(r));
    } else if (argument.has_model_argument()) {
      const Model* model;
      const std::vector<std::string> path = absl::StrSplit(
        argument.model_argument().full_name(), '.');
      ZETASQL_RETURN_IF_ERROR(params.catalog->FindModel(path, &model));
      input_args.push_back(TVFInputArgumentType(TVFModelArgument(
        model)));
    } else if (argument.has_connection_argument()) {
      const Connection* connection;
      const std::vector<std::string> path = absl::StrSplit(
        argument.connection_argument().full_name(), '.');
      ZETASQL_RETURN_IF_ERROR(params.catalog->FindConnection(path, &connection,
                                                     Catalog::FindOptions()));
      input_args.push_back(TVFInputArgumentType(TVFConnectionArgument(
        connection)));
    } else if (argument.has_descriptor_argument()) {
      std::vector<std::string> names;
      const TVFDescriptorProto& descriptor_arg = argument.descriptor_argument();
      for (const auto& name : descriptor_arg.column_name()) {
        names.push_back(name);
      }
      input_args.push_back(TVFInputArgumentType(TVFDescriptorArgument(names)));
    } else if (argument.has_graph_argument()) {
      const PropertyGraph* graph;
      const std::vector<std::string> path = absl::StrSplit(
        argument.graph_argument().full_name(), '.');
      ZETASQL_RETURN_IF_ERROR(params.catalog->FindPropertyGraph(path, graph));
      input_args.push_back(TVFInputArgumentType(TVFGraphArgument(graph)));
    } else {
      const ValueWithTypeProto& scalar_arg = argument.scalar_argument();
      if (scalar_arg.has_value()) {
        ZETASQL_ASSIGN_OR_RETURN(const Value value,
                         RestoreFromImpl<Value>(scalar_arg, params));
        input_args.push_back(TVFInputArgumentType(InputArgumentType(value)));
      } else {
        ZETASQL_ASSIGN_OR_RETURN(
            const Type* type,
            RestoreFromImpl<const Type*>(scalar_arg.type(), params));
        input_args.push_back(TVFInputArgumentType(InputArgumentType(type)));
      }
    }
  }
  ZETASQL_ASSIGN_OR_RETURN(TVFRelation table_schema, TVFRelation::Deserialize(
      proto.output_schema(),
      TypeDeserializer(params.type_factory, params.pools)));

  TVFSignatureOptions options;
  for (const FreestandingDeprecationWarning& warning :
           proto.options().additional_deprecation_warning()) {
    options.additional_deprecation_warnings.push_back(warning);
  }

  return std::shared_ptr<TVFSignature>(
      new TVFSignature(input_args, std::move(table_schema), options));
}

static absl::Status SaveToImpl(
    const std::shared_ptr<ResolvedFunctionCallInfo>& context,
    FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedFunctionCallInfoProto* proto) {
  // TODO: Implement this for ResolvedFunctionCallInfo subclasses.
  return absl::OkStatus();
}

template<>
absl::StatusOr<std::shared_ptr<ResolvedFunctionCallInfo>>
    RestoreFromImpl(
        const ResolvedFunctionCallInfoProto& proto,
        const ResolvedNode::RestoreParams& params) {
  // TODO: Implement this for ResolvedFunctionCallInfo subclasses.
  return std::shared_ptr<ResolvedFunctionCallInfo>(
      new ResolvedFunctionCallInfo());
}

static std::string ToStringImpl(const ResolvedCollation& resolved_collation) {
  return resolved_collation.DebugString();
}

static std::string ToStringImpl(
    const std::vector<ResolvedCollation>& resolved_collation_list) {
  return ResolvedCollation::ToString(resolved_collation_list);
}

static absl::Status SaveToImpl(
    const ResolvedCollation& resolved_collation,
    FileDescriptorSetMap* file_descriptor_set_map,
    ResolvedCollationProto* proto) {
  return resolved_collation.Serialize(proto);
}

template<>
absl::StatusOr<ResolvedCollation>
    RestoreFromImpl(
        const ResolvedCollationProto& proto,
        const ResolvedNode::RestoreParams& params) {
  return ResolvedCollation::Deserialize(proto);
}

static std::string ToStringImpl(const AnnotationMap* annotation_map) {
  return annotation_map->DebugString();
}

static absl::Status SaveToImpl(
    const AnnotationMap* annotation_map,
    FileDescriptorSetMap* file_descriptor_set_map,
    AnnotationMapProto* proto) {
  if (annotation_map != nullptr && !annotation_map->Empty()) {
    ZETASQL_RETURN_IF_ERROR(annotation_map->Serialize(proto));
  }
  return absl::OkStatus();
}

template<>
absl::StatusOr<const AnnotationMap*>
    RestoreFromImpl(
        const AnnotationMapProto& proto,
        const ResolvedNode::RestoreParams& params) {
  const AnnotationMap* annotation_map = nullptr;
  if (proto.annotations_size() > 0
      || proto.has_array_element()
      || proto.struct_fields_size() > 0) {
    ZETASQL_RETURN_IF_ERROR(
        params.type_factory->DeserializeAnnotationMap(proto,
                                                      &annotation_map));
  }
  return annotation_map;
}

static std::string ToStringImpl(const TypeParameters& type_parameters) {
  return type_parameters.DebugString();
}

static absl::Status SaveToImpl(
    const TypeParameters& type_parameters,
    FileDescriptorSetMap* file_descriptor_set_map,
    TypeParametersProto* proto) {
  if (!type_parameters.IsEmpty()) {
    ZETASQL_RETURN_IF_ERROR(type_parameters.Serialize(proto));
  }
  return absl::OkStatus();
}

template<>
absl::StatusOr<TypeParameters>
    RestoreFromImpl(
        const TypeParametersProto& proto,
        const ResolvedNode::RestoreParams& params) {
  return TypeParameters::Deserialize(proto);
}

static std::string ToStringImpl(const TypeModifiers& type_modifiers) {
  return type_modifiers.DebugString();
}

static absl::Status SaveToImpl(
    const TypeModifiers& type_modifiers,
    FileDescriptorSetMap* file_descriptor_set_map,
    TypeModifiersProto* proto) {
  if (!type_modifiers.IsEmpty()) {
    ZETASQL_RETURN_IF_ERROR(type_modifiers.Serialize(proto));
  }
  return absl::OkStatus();
}

template<>
absl::StatusOr<TypeModifiers>
    RestoreFromImpl(
        const TypeModifiersProto& proto,
        const ResolvedNode::RestoreParams& params) {
  return TypeModifiers::Deserialize(proto);
}

static std::string ToStringImpl(const PropertyGraph* property_graph) {
  return property_graph == nullptr ? "<null>" : property_graph->FullName();
}


static absl::Status SaveToImpl(
    const PropertyGraph* property_graph,
    FileDescriptorSetMap* file_descriptor_set_map,
    PropertyGraphRefProto* proto) {
  proto->set_full_name(property_graph->FullName());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const PropertyGraph*> RestoreFromImpl(
    const PropertyGraphRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  const PropertyGraph* propery_graph;
  const std::vector<std::string> path = absl::StrSplit(proto.full_name(), '.');
  ZETASQL_RETURN_IF_ERROR(params.catalog->FindPropertyGraph(
      absl::MakeSpan(path), propery_graph));
  return propery_graph;
}

static std::string ToStringImpl(const GraphPropertyDeclaration* property) {
  return property == nullptr ? "<null>" :
      absl::StrCat(property->Name(), "(", property->Type()->DebugString(),")");
}

static absl::Status SaveToImpl(
    const GraphPropertyDeclaration* propery_declaration,
    FileDescriptorSetMap* file_descriptor_set_map,
    GraphPropertyDeclarationRefProto* proto) {
  const std::string property_full_name = propery_declaration->FullName();
  const auto pos = property_full_name.find_last_of('.');
  ZETASQL_RET_CHECK(pos != std::string::npos);
  const auto full_graph_name = property_full_name.substr(0, pos);
  proto->mutable_property_graph()->set_full_name(full_graph_name);
  proto->set_name(propery_declaration->Name());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const GraphPropertyDeclaration*> RestoreFromImpl(
    const GraphPropertyDeclarationRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(const PropertyGraph* property_graph,
    RestoreFromImpl<const PropertyGraph*>(proto.property_graph(), params));
  const GraphPropertyDeclaration* propery_declaration;
  ZETASQL_RETURN_IF_ERROR(property_graph->FindPropertyDeclarationByName(
        proto.name(), propery_declaration));
  return propery_declaration;
}

static std::string ToStringImpl(
    const std::vector<const GraphElementTable*>& table_list) {
  if (table_list.empty()) {
    return "[]";
  } else {
    return absl::StrCat(
        "[",
        absl::StrJoin(table_list, ",",
                      [](std::string* out, const GraphElementTable* table) {
                        absl::StrAppend(out, table->FullName());
                      }),
        "]");
  }
}

// TODO: Migrate helper functions to dedicated .cc file.
static std::string ToStringImpl(const GraphElementLabel* graph_element_label) {
  return graph_element_label == nullptr ? "<null>"
                                        : graph_element_label->FullName();
}


static absl::Status SaveToImpl(const GraphElementLabel* graph_element_label,
                               FileDescriptorSetMap* file_descriptor_set_map,
                               GraphElementLabelRefProto* proto) {
  const std::string property_full_name = graph_element_label->FullName();
  const auto pos = property_full_name.find_last_of('.');
  ZETASQL_RET_CHECK(pos != std::string::npos);
  const auto full_graph_name = property_full_name.substr(0, pos);
  proto->mutable_property_graph()->set_full_name(full_graph_name);
  proto->set_name(graph_element_label->Name());
  return absl::OkStatus();
}

template <>
absl::StatusOr<const GraphElementLabel*> RestoreFromImpl(
    const GraphElementLabelRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(const PropertyGraph* property_graph,
    RestoreFromImpl<const PropertyGraph*>(proto.property_graph(), params));
  const GraphElementLabel* graph_element_label;
  ZETASQL_RETURN_IF_ERROR(
      property_graph->FindLabelByName(proto.name(), graph_element_label));
  return graph_element_label;
}

static std::string ToStringImpl(
    ResolvedGraphEdgeScan::EdgeOrientation edge_orientation) {
  std::string name =
      ResolvedGraphEdgeScanEnums::EdgeOrientation_Name(edge_orientation);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid EdgeOrientation: " << edge_orientation;
  return absl::StrCat("INVALID_EDGE_ORIENTATION(", edge_orientation, ")");
}

static std::string ToStringImpl(
    const std::vector<const GraphElementLabel*>& label_list) {
  return absl::StrCat(
      "[",
      absl::StrJoin(label_list, ", ",
                    [](std::string* out, const GraphElementLabel* label) {
                      absl::StrAppend(out, ToStringImpl(label));
                    }),
      "]");
}

static std::string ToStringImpl(const GraphElementTable* graph_element_table) {
  return graph_element_table == nullptr ? "<null>"
                                        : graph_element_table->Name();
}

static absl::Status SaveToImpl(
    const GraphElementTable* element_table,
    FileDescriptorSetMap* file_descriptor_set_map,
    GraphElementTableRefProto* proto) {
  const std::string element_table_full_name = element_table->FullName();
  const auto pos = element_table_full_name.find_last_of('.');
  ZETASQL_RET_CHECK(pos != std::string::npos);
  const auto full_graph_name = element_table_full_name.substr(0, pos);
  proto->mutable_property_graph()->set_full_name(full_graph_name);
  proto->set_name(element_table->Name());
  return absl::OkStatus();
}

template<>
absl::StatusOr<const GraphElementTable*> RestoreFromImpl(
    const GraphElementTableRefProto& proto,
    const ResolvedNode::RestoreParams& params) {
  ZETASQL_ASSIGN_OR_RETURN(const PropertyGraph* property_graph,
    RestoreFromImpl<const PropertyGraph*>(proto.property_graph(), params));
  const GraphElementTable* element_table;
  ZETASQL_RETURN_IF_ERROR(property_graph->FindElementTableByName(proto.name(),
                                                         element_table));
  return element_table;
}

static std::string ToStringImpl(
    ResolvedGraphPathMode::PathMode path_mode) {
  std::string name = ResolvedGraphPathModeEnums::PathMode_Name(path_mode);
  if (!name.empty()) {
    return name;
  }
  ABSL_LOG(ERROR) << "Invalid PathMode: " << path_mode;
  return absl::StrCat("INVALID_PATH_MODE(", path_mode, ")");
}

static std::string ToStringImpl(
    ResolvedGraphPathSearchPrefix::PathSearchPrefixType prefix_type) {
  std::string name =
      ResolvedGraphPathSearchPrefixEnums::PathSearchPrefixType_Name(prefix_type);
  if (!name.empty()) {
    return name;
  }
  ABSL_LOG(ERROR) << "Invalid PathSearchPrefixType: " << prefix_type;
  return absl::StrCat("INVALID_PATH_SEARCH_PREFIX_TYPE(", prefix_type, ")");
}

static std::string ToStringImpl(ResolvedUpdateFieldItemEnums::Operation operation) {
  std::string name = ResolvedUpdateFieldItemEnums::Operation_Name(operation);
  if (!name.empty()) return name;
  ABSL_LOG(ERROR) << "Invalid operation: " << operation;
  return absl::StrCat("INVALID_OPERATION(", operation, ")");
}

}  // anonymous namespace

{#
   This is used in RestoreFrom nodes to access fields that are defined in
   parent protos of the proto being deserialized.
#}
{% macro path_to_serialized(from_node, field) -%}
  {{- ".parent()" * (from_node.depth - defining_node(field).depth) }}.
  {{- field.name }}
{%- endmacro -%}
{% macro path_to_serialized_has(from_node, field) -%}
  {{- ".parent()" * (from_node.depth - defining_node(field).depth) }}.
  has_{{- field.name }}
{%- endmacro -%}

// This is defined separately from the rest of the RestoreFrom implementations
// because the root node does not have a proper entry in the tree generated in
// gen_resolved_ast.py, so we have to iterate the nodes in a different way.
absl::StatusOr<std::unique_ptr<ResolvedNode>> ResolvedNode::RestoreFrom(
    const AnyResolvedNodeProto& proto, const RestoreParams& params) {
  switch (proto.node_case()) {
# for node in root_child_nodes|sort_by_tag
    case AnyResolvedNodeProto::k{{node.member_name|upper_camel_case}}Node:
      return {{node.name}}::RestoreFrom(
          proto.{{node.member_name}}_node(), params);
# endfor
    case AnyResolvedNodeProto::NODE_NOT_SET:
      return ::zetasql_base::InvalidArgumentErrorBuilder(zetasql_base::SourceLocation::current())
          << "No subnode types set in AnyResolvedNodeProto";
  }
}


std::string ResolvedNodeKindToString(ResolvedNodeKind kind) {
  switch (kind) {
# for node in nodes
 # if not node.is_abstract
    case {{node.enum_name}}: return "{{node.node_kind_name}}";
 # endif
# endfor
    default:
      return absl::StrCat("INVALID_RESOLVED_NODE_KIND(", kind, ")");
  }
}

# for node in nodes
# if not node.is_abstract
const ResolvedNodeKind {{node.name}}::TYPE;

# endif
{{node.extra_enum_defs}}

{{node.name}}::~{{node.name}}() {
  {% set ns = namespace(has_vector_or_ptr=
      (node.fields | selectattr('is_node_vector') | list | length > 0) or
      (node.fields | selectattr('is_node_ptr') | list | length > 0)
  ) %}
  {% if ns.has_vector_or_ptr %}
  {% endif %}
}

absl::Status {{node.name}}::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    {{node.parent_proto_container_type}}* proto) const {
  return SaveTo(
      file_descriptor_set_map, proto->mutable_{{node.member_name}}_node());
}

absl::Status {{node.name}}::SaveTo(
    Type::FileDescriptorSetMap* file_descriptor_set_map,
    {{node.proto_type}}* proto) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::SaveTo(
      file_descriptor_set_map, proto->mutable_parent()));
  if (proto->parent().ByteSizeLong() == 0) {
    proto->clear_parent();
  }
# for field in node.fields
 # if field.is_node_ptr
  if ({{field.member_name}} != nullptr) {
    ZETASQL_RETURN_IF_ERROR({{field.member_name}}->SaveTo(
        file_descriptor_set_map, proto->mutable_{{field.name}}()));
  }
 # elif field.is_node_vector
  for (const auto& elem : {{field.member_name}}) {
    ZETASQL_RETURN_IF_ERROR(elem->SaveTo(
      file_descriptor_set_map, proto->add_{{field.name}}()));
  }
 # elif field.is_vector
  for (const auto& elem : {{field.member_name}}) {
   # if field.has_proto_setter
    proto->add_{{field.name}}(elem);
   # else
    ZETASQL_RETURN_IF_ERROR(SaveToImpl(
        elem, file_descriptor_set_map, proto->add_{{field.name}}()));
   # endif
  }
 # else
  # if field.not_serialize_if_default
    if (!IsDefaultValue({{field.member_name}})) {
  # endif
  # if field.has_proto_setter
  proto->set_{{field.name}}({{field.member_name}});
  # else
  ZETASQL_RETURN_IF_ERROR(SaveToImpl(
      {{field.member_name}}, file_descriptor_set_map,
      proto->mutable_{{field.name}}()));
  # endif
  # if field.not_serialize_if_default
    }
  # endif
 # endif
# endfor
  return absl::OkStatus();
}


# if node.is_abstract

{#
  When restoring abstract nodes, we just iterate through the different
  subclasses, checking if the proto contains one of those. If it does, we
  delegate to the subclass' RestoreFrom method.
-#}
absl::StatusOr<std::unique_ptr<{{node.name}}>> {{node.name}}::RestoreFrom(
    const {{node.proto_field_type}}& proto,
    const ResolvedNode::RestoreParams& params) {
  switch (proto.node_case()) {
 # for subnode in node.subclasses|sort_by_tag
    case {{node.proto_field_type}}::k{{subnode.member_name|upper_camel_case}}Node:
      return {{subnode.name}}::RestoreFrom(
          proto.{{subnode.member_name}}_node(), params);
 # endfor
  case {{node.proto_field_type}}::NODE_NOT_SET:
    return ::zetasql_base::InvalidArgumentErrorBuilder(zetasql_base::SourceLocation::current())
        << "No subnode types set in {{node.proto_type}}";
  }
}

# else

absl::StatusOr<std::unique_ptr<{{node.name}}>> {{node.name}}::RestoreFrom(
    const {{node.proto_type}}& proto,
    const ResolvedNode::RestoreParams& params) {
 # for field in node.fields + node.inherited_fields
  {#
    Deserialize child nodes into locals. This allows us to have the
    deserialization code just once for each child node, but to use the child
    node either in the constructor or in setters as needed.
  #}
  # if field.is_node_ptr
  std::unique_ptr<const {{field.ctype}}> {{field.name}};
  if (proto{{path_to_serialized_has(node, field)}}()) {
    ZETASQL_ASSIGN_OR_RETURN({{field.name}},
                     {{field.ctype}}::RestoreFrom(
                         proto{{path_to_serialized(node, field)}}(), params));
  }
  # elif field.is_node_vector
  std::vector<std::unique_ptr<const {{field.ctype}}>> {{field.name}};
  for (const auto& elem : proto{{path_to_serialized(node, field)}}()) {
    ZETASQL_ASSIGN_OR_RETURN(std::unique_ptr<const {{field.ctype}}> elem_restored,
                     {{field.ctype}}::RestoreFrom(elem, params));
    {{field.name}}.push_back(std::move(elem_restored));
  }
  # elif field.is_enum_vector
  {{field.member_type}} {{field.name}};
  for (const auto& elem : proto{{path_to_serialized(node, field)}}()) {
    // We need a static cast because the proto getter returns a
    // RepeatedField<int>, not RepeatedField<enum>.
    {{field.name}}.push_back(static_cast<{{field.element_arg_type}}>(elem));
  }
  # elif field.is_vector
  {{field.member_type}} {{field.name}};
  for (const auto& elem : proto{{path_to_serialized(node, field)}}()) {
    # if field.has_proto_setter
    {{field.name}}.push_back(elem);
    # else
    ZETASQL_ASSIGN_OR_RETURN(
        auto elem_restored,
        RestoreFromImpl<{{field.member_type}}::value_type>(elem, params));
    {{field.name}}.push_back(std::move(elem_restored));
    # endif
  }
  # else
   # if field.not_serialize_if_default
  {{field.member_type}} {{field.name}};
  if (!proto{{path_to_serialized_has(node, field)}}()) {
    {{field.name}} = {{field.cpp_default}};
  } else {
   # if field.has_proto_setter
    {{field.name}} = proto{{path_to_serialized(node, field)}}();
   # else
    ZETASQL_ASSIGN_OR_RETURN({{field.name}},
                     RestoreFromImpl<{{field.member_type}}>(
                         proto{{path_to_serialized(node, field)}}(),
                         params));
   # endif
  }
   # else
     # if field.has_proto_setter
  {{field.member_type}} {{field.name}} =
      proto{{path_to_serialized(node, field)}}();
     # else
  ZETASQL_ASSIGN_OR_RETURN(auto {{field.name}},
                   RestoreFromImpl<{{field.member_type}}>(
                       proto{{path_to_serialized(node, field)}}(),
                       params));
     # endif
   # endif
  # endif
 # endfor

  auto node = Make{{node.name}}(
 {% for field in (node.inherited_fields + node.fields) | is_constructor_arg %}
      std::move({{field.name}})
  {%- if not loop.last %},
  {% endif %}
 {% endfor %});

 # for field in (node.inherited_fields + node.fields)|rejectattr('is_constructor_arg')
  node->set_{{field.name}}(std::move({{field.name}}));
 # endfor

  return node;
}

# endif

# if node.fields
void {{node.name}}::GetChildNodes(
    std::vector<const ResolvedNode*>* child_nodes) const {
  SUPER::GetChildNodes(child_nodes);
 # for field in node.fields
  # if field.is_node_ptr
  if ({{field.member_name}} != nullptr) {
    child_nodes->emplace_back({{field.member_accessor}});
  }
  # elif field.is_node_vector
  for (const auto& elem : {{field.member_name}}) {
    child_nodes->emplace_back(elem.get());
  }
  # endif
 # endfor
}

void {{node.name}}::AddMutableChildNodePointers(
    std::vector<std::unique_ptr<const ResolvedNode>*>*
        mutable_child_node_ptrs) {
  SUPER::AddMutableChildNodePointers(mutable_child_node_ptrs);
 # for field in node.fields
  # if field.is_node_ptr
  if ({{field.member_name}} != nullptr) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(
            &{{field.member_name}}));
    static_assert(sizeof({{field.member_name}}) ==
                  sizeof(*(mutable_child_node_ptrs->back())),
                  "Incorrect casting of mutable child node");
  }
  # elif field.is_node_vector
  for (auto& elem : {{field.member_name}}) {
    mutable_child_node_ptrs->emplace_back(
        reinterpret_cast<std::unique_ptr<const ResolvedNode>*>(&elem));
  }
  # endif
 # endfor
}
# endif
{{ blank_line }}
absl::Status {{node.name}}::Accept(ResolvedASTVisitor* visitor) const {
  return visitor->Visit{{node.name}}(this);
}

absl::Status {{node.name}}::ChildrenAccept(ResolvedASTVisitor* visitor) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::ChildrenAccept(visitor));
 # for field in node.fields
  # if field.is_node_ptr
  if ({{field.member_name}} != nullptr) {
    ZETASQL_RETURN_IF_ERROR({{field.member_accessor}}->Accept(visitor));
  }
  # elif field.is_node_vector
  for (const auto& elem : {{field.member_name}}) {
    ZETASQL_RETURN_IF_ERROR(elem.get()->Accept(visitor));
  }
  # endif
 # endfor
  return absl::OkStatus();
}

# if node.fields and not node.use_custom_debug_string
void {{node.name}}::CollectDebugStringFields(
    std::vector<DebugStringField>* fields) const {
  SUPER::CollectDebugStringFields(fields);
 # for field in node.fields
  # if field.is_node_ptr
  if ({{field.member_name}} != nullptr) {
    fields->emplace_back("{{field.name}}", {{field.member_name}}.get(), {{field.member_name}}accessed());
  }
  # elif field.is_node_vector
  if (!{{field.member_name}}.empty()) {
    fields->emplace_back("{{field.name}}", {{field.member_name}}, {{field.member_name}}accessed());
  }
  # else
   # if field.is_not_ignorable
  {
   # else
  if (!IsDefaultValue({{field.member_name}})) {
   # endif
    fields->emplace_back("{{field.name}}", {{field.to_string_method}}({{field.member_name}}), {{field.member_name}}accessed());
   {#
   For ResolvedColumnList and ResolvedColumn (and ResolvedColumnHolder), we have
   a config option `print_created_columns` that annotates created columns with
   `{c}` if the column is created in this node.

   For determining columns that are created, we have two cases:
   (a) The `column_list` field itself represents created columns (e.g. in
   TableScans). This is indicated by `ColumnListIsCreatedColumns()` being true.
   (b) The field contains a ResolvedColumn (or vector of ResolvedColumn) that
   is created in this node. This is indicated by `column_is_created` being
   true.
   #}
    # if node.name == 'ResolvedScan' and field.name == 'column_list'
    fields->back().column_created = ColumnListIsCreatedColumns();
    # elif field.column_is_created
    fields->back().column_created = true;
    # endif
  }
  # endif
 # endfor
}

# endif
# if node.fields
absl::Status {{node.name}}::CheckFieldsAccessedImpl(
    const ResolvedNode* root) const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckFieldsAccessedImpl(root));

  # if node.is_not_ignorable_bitmap != '0x0' or node.is_ignorable_default_bitmap != '0x0':
  uint32_t accessed_local = accessed_.load();
  # endif
  # if node.is_not_ignorable_bitmap != '0x0':
  constexpr static uint32_t kIsNotIgnorableBitmap = {{node.is_not_ignorable_bitmap}};
  if ((accessed_local & kIsNotIgnorableBitmap) != kIsNotIgnorableBitmap) {
  # for field in node.fields
    # if field.is_not_ignorable
    if ((accessed_local & {{field.bitmap}}) == 0) {
      NodeAnnotation annotation = {
        .node = this,
        .annotation = "(*** This node has unaccessed field ***)"
      };
      return ::zetasql_base::UnimplementedErrorBuilder(zetasql_base::SourceLocation::current()).LogError()
          << "Unimplemented feature "
            "({{node.name}}::{{field.name}} not accessed)\n"
          << root->DebugString(DebugStringConfig{ {annotation}, /*print_accessed=*/true});
    }
    # endif
  # endfor
  }
  # endif

  # if node.is_ignorable_default_bitmap != '0x0':
  constexpr static uint32_t kIsIgnorableDefaultBitmap = {{node.is_ignorable_default_bitmap}};
  if ((accessed_local & kIsIgnorableDefaultBitmap) != kIsIgnorableDefaultBitmap) {
  # for field in node.fields
    # if field.is_ignorable_default
    if ((accessed_local & {{field.bitmap}}) == 0 &&
        !IsDefaultValue({{field.member_name}})) {
      NodeAnnotation annotation = {
        .node = this,
        .annotation = "(*** This node has unaccessed field ***)"
      };
      return ::zetasql_base::UnimplementedErrorBuilder(zetasql_base::SourceLocation::current()).LogError()
          << "Unimplemented feature "
            "({{node.name}}::{{field.name}} not accessed "
            "and has non-default value)\n"
          << root->DebugString(DebugStringConfig{ {annotation}, /*print_accessed=*/true});
    }
    # endif
  # endfor
  }
  # endif

 # for field in node.fields
  # if field.is_node_vector or field.is_node_ptr
  if ((accessed_ & {{field.bitmap}}) != 0) {
    # if field.is_node_vector
    for (const auto& it : {{field.member_name}}) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(it.get(), root));
    }
   # elif field.is_node_ptr
    if ({{field.member_name}} != nullptr) {
      ZETASQL_RETURN_IF_ERROR(CheckFieldsAccessedInternal(
          {{field.member_name}}.get(), root));
    }
   # endif
  }
  # endif
 # endfor
  return absl::OkStatus();
}

absl::Status {{node.name}}::CheckNoFieldsAccessed() const {
  ZETASQL_RETURN_IF_ERROR(SUPER::CheckNoFieldsAccessed());

 # for field in node.fields
  # if field.is_not_ignorable or field.is_ignorable_default
  if ((accessed_ & {{field.bitmap}}) != 0) {
    return ::zetasql_base::InternalErrorBuilder(zetasql_base::SourceLocation::current()).LogError()
        << "({{node.name}}::{{field.name}} is accessed, but shouldn't be)";
  }
  # endif
 # endfor

 # for field in node.fields
  # if field.is_node_vector or field.is_node_ptr
  if ((accessed_ & {{field.bitmap}}) != 0) {
    # if field.is_node_vector
    for (const auto& it : {{field.member_name}}) {
      ZETASQL_RETURN_IF_ERROR(it->CheckNoFieldsAccessed());
    }
   # elif field.is_node_ptr
    if ({{field.member_name}} != nullptr) {
      ZETASQL_RETURN_IF_ERROR({{field.member_name}}->CheckNoFieldsAccessed());
    }
   # endif
  }
  # endif
 # endfor
  return absl::OkStatus();
}

void {{node.name}}::ClearFieldsAccessed() const {
  SUPER::ClearFieldsAccessed();

  accessed_ = 0;
 # for field in node.fields
  # if field.is_node_vector
  for (const auto& it : {{field.member_name}}) it->ClearFieldsAccessed();
  # elif field.is_node_ptr
  if ({{field.member_name}} != nullptr) {{field.member_name}}->ClearFieldsAccessed();
  # endif
 # endfor
}

void {{node.name}}::MarkFieldsAccessed() const {
  SUPER::MarkFieldsAccessed();
  accessed_ = 0xFFFFFFFF;
 # for field in node.fields
  # if field.is_node_vector
  for (const auto& it : {{field.member_name}}) it->MarkFieldsAccessed();
  # elif field.is_node_ptr
  if ({{field.member_name}} != nullptr) {{field.member_name}}->MarkFieldsAccessed();
  # endif
 # endfor
}
{{ blank_line }}
# endif
# if node.fields and not node.use_custom_columns_created

std::vector<ResolvedColumn> {{node.name}}::GetColumnsCreated() const {
  std::vector<ResolvedColumn> columns = SUPER::GetColumnsCreated();
  # for field in node.fields
   # if node.name == 'ResolvedColumnHolder'
   # elif node.name == 'ResolvedScan' and field.name == 'column_list'
  if (ColumnListIsCreatedColumns()) {
    columns.insert(columns.end(),
                   {{field.member_name}}.begin(), {{field.member_name}}.end());
  }
   # elif field.column_is_created
    # if field.ctype == 'ResolvedColumnHolder'
  if({{field.member_name}} != nullptr) {
    columns.push_back({{field.member_name}}->column());
  }
    # elif field.member_type == 'ResolvedColumn'
  columns.push_back({{field.member_name}});
    # elif field.member_type == 'std::vector<ResolvedColumn>'
  columns.insert(columns.end(),
                 {{field.member_name}}.begin(), {{field.member_name}}.end());
    # endif
   # endif
  # endfor
  return columns;
}

std::vector<ResolvedColumn> {{node.name}}::GetColumnsReferenced() const {
  std::vector<ResolvedColumn> columns = SUPER::GetColumnsCreated();
  # for field in node.fields
   # if node.name == 'ResolvedColumnHolder'
   # elif node.name == 'ResolvedScan' and field.name == 'column_list'
  if (!ColumnListIsCreatedColumns()) {
    columns.insert(columns.end(),
                   {{field.member_name}}.begin(), {{field.member_name}}.end());
  }
   # elif not field.column_is_created
    # if field.ctype == 'ResolvedColumnHolder'
  if({{field.member_name}} != nullptr) {
    columns.push_back({{field.member_name}}->column());
  }
    # elif field.member_type == 'ResolvedColumn'
  columns.push_back({{field.member_name}});
    # elif field.member_type == 'std::vector<ResolvedColumn>'
  columns.insert(columns.end(),
                 {{field.member_name}}.begin(), {{field.member_name}}.end());
    # endif
   # endif
  # endfor
  return columns;
}
# endif
# endfor

}  // namespace zetasql
