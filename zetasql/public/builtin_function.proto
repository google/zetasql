//
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// LINT: LEGACY_NAMES

syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql";
option java_outer_classname = "ZetaSQLFunction";

// A unique ID for ZetaSQL function signatures.  Resolved ZetaSQL functions
// will provide one of these enums, and ZetaSQL implementations should map
// them to something they can evaluate.
enum FunctionSignatureId {
  // User code that switches on this enum must have a default case so
  // builds won't break if new enums get added.
  __FunctionSignatureId__switch_must_have_a_default__ = -1;

  FN_INVALID_FUNCTION_ID = 1;

  // The first set of functions do not use standard function call syntax,
  // reflecting operators, functions with infix notation (LIKE), and
  // other special functions (CASE).  FunctionSignatureIds are assigned
  // in ranges:
  //
  // 0002-0999 Non-standard function calls    (NextId: 291)
  // 1000-1099 String functions               (NextId: 1082)
  // 1100-1199 Control flow functions         (NextId: 1104)
  // 1200-1299 Time functions                 (Fully used)
  // 1300-1399 Math functions                 (Fully used)
  // 1400-1499 Aggregate functions            (NextId: 1490)
  // 1500-1599 Analytic functions             (NextId: 1513)
  // 1600-1699 Misc functions                 (NextId: 1699)
  // 1700-1799 Net functions                  (NextId: 1716)
  // 1800-1899 More time functions            (NextId: 1861)
  // 1900-1999 Hashing/encryption functions   (NextId: 1928)
  // 2000-2199 Geography functions            (NextId: 2078)
  // 2200-2299 Anonymization functions        (NextId: 2208)
  // 2300-2499 Numeric & more math functions  (NextId: 2316)
  // 2500-2599 Array and proto map functions  (NextId: 2510)

  // enum value                       // Related function name
  // ----------                       // ---------------------
  FN_ADD_DOUBLE = 2;                       // $add
  FN_ADD_INT64 = 4;                        // $add
  FN_ADD_UINT64 = 119;                     // $add
  FN_ADD_NUMERIC = 248;                    // $add
  FN_ADD_BIGNUMERIC = 261;                 // $add
  FN_ADD_DATE_INT64 = 266;                 // $add
  FN_ADD_INT64_DATE = 267;                 // $add
  FN_ADD_TIMESTAMP_INTERVAL = 280;         // $add
  FN_ADD_INTERVAL_TIMESTAMP = 281;         // $add
  FN_ADD_DATE_INTERVAL = 282;              // $add
  FN_ADD_INTERVAL_DATE = 283;              // $add
  FN_ADD_DATETIME_INTERVAL = 284;          // $add
  FN_ADD_INTERVAL_DATETIME = 285;          // $add
  FN_ADD_INTERVAL_INTERVAL = 289;          // $add
  FN_AND = 5;                              // $and
  FN_CASE_NO_VALUE = 6;                    // $case_no_value
  FN_CASE_WITH_VALUE = 7;                  // $case_with_value
  FN_DIVIDE_DOUBLE = 40;                   // $divide
  FN_DIVIDE_NUMERIC = 250;                 // $divide
  FN_DIVIDE_BIGNUMERIC = 263;              // $divide
  FN_GREATER = 107;                        // $greater
  FN_GREATER_INT64_UINT64 = 222;           // $greater
  FN_GREATER_UINT64_INT64 = 223;           // $greater
  FN_GREATER_OR_EQUAL = 108;               // $greater_or_equal
  FN_GREATER_OR_EQUAL_INT64_UINT64 = 224;  // $greater_or_equal
  FN_GREATER_OR_EQUAL_UINT64_INT64 = 225;  // $greater_or_equal
  FN_LESS = 105;                           // $less
  FN_LESS_INT64_UINT64 = 226;              // $less
  FN_LESS_UINT64_INT64 = 227;              // $less
  FN_LESS_OR_EQUAL = 106;                  // $less_or_equal
  FN_LESS_OR_EQUAL_INT64_UINT64 = 228;     // $less_or_equal
  FN_LESS_OR_EQUAL_UINT64_INT64 = 229;     // $less_or_equal
  FN_EQUAL = 42;                           // $equal
  FN_EQUAL_INT64_UINT64 = 230;             // $equal
  FN_EQUAL_UINT64_INT64 = 231;             // $equal
  FN_STRING_LIKE = 97;                     // $like
  FN_BYTE_LIKE = 98;                       // $like
  FN_IN = 100;                             // $in
  FN_IN_ARRAY = 219;                       // $in_array
  FN_BETWEEN = 110;                        // $between
  FN_BETWEEN_INT64_UINT64_UINT64 = 254;    // $between
  FN_BETWEEN_INT64_UINT64_INT64 = 255;     // $between
  FN_BETWEEN_INT64_INT64_UINT64 = 256;     // $between
  FN_BETWEEN_UINT64_INT64_INT64 = 257;     // $between
  FN_BETWEEN_UINT64_UINT64_INT64 = 258;    // $between
  FN_BETWEEN_UINT64_INT64_UINT64 = 259;    // $between
  FN_IS_NULL = 101;                        // $is_null
  FN_IS_TRUE = 102;                        // $is_true
  FN_IS_FALSE = 103;                       // $is_false
  FN_MULTIPLY_DOUBLE = 41;                 // $multiply
  FN_MULTIPLY_INT64 = 44;                  // $multiply
  FN_MULTIPLY_UINT64 = 114;                // $multiply
  FN_MULTIPLY_NUMERIC = 251;               // $multiply
  FN_MULTIPLY_BIGNUMERIC = 264;            // $multiply
  FN_NOT = 45;                             // $not
  FN_NOT_EQUAL = 109;                      // $not_equal
  FN_NOT_EQUAL_INT64_UINT64 = 232;         // $not_equal
  FN_NOT_EQUAL_UINT64_INT64 = 233;         // $not_equal
  FN_OR = 46;                              // $or
  FN_SUBTRACT_DOUBLE = 115;                // $subtract
  FN_SUBTRACT_INT64 = 48;                  // $subtract
  FN_SUBTRACT_UINT64 = 117;                // $subtract
  FN_SUBTRACT_NUMERIC = 249;               // $subtract
  FN_SUBTRACT_BIGNUMERIC = 262;            // $subtract
  FN_SUBTRACT_DATE_INT64 = 268;            // $subtract
  FN_SUBTRACT_DATE = 276;                  // $subtract
  FN_SUBTRACT_TIMESTAMP = 277;             // $subtract
  FN_SUBTRACT_DATETIME = 278;              // $subtract
  FN_SUBTRACT_TIME = 279;                  // $subtract
  FN_SUBTRACT_TIMESTAMP_INTERVAL = 286;    // $subtract
  FN_SUBTRACT_DATE_INTERVAL = 287;         // $subtract
  FN_SUBTRACT_DATETIME_INTERVAL = 288;     // $subtract
  FN_SUBTRACT_INTERVAL_INTERVAL = 290;     // $subtract

  FN_UNARY_MINUS_INT32 = 83;        // $unary_minus
  FN_UNARY_MINUS_INT64 = 84;        // $unary_minus
  FN_UNARY_MINUS_FLOAT = 87;        // $unary_minus
  FN_UNARY_MINUS_DOUBLE = 88;       // $unary_minus
  FN_UNARY_MINUS_NUMERIC = 252;     // $unary_minus
  FN_UNARY_MINUS_BIGNUMERIC = 265;  // $unary_minus
  FN_UNARY_MINUS_INTERVAL = 275;    // $unary_minus

  FN_DISTINCT = 269;                   // $is_distinct
  FN_DISTINCT_INT64_UINT64 = 270;      // $is_distinct
  FN_DISTINCT_UINT64_INT64 = 271;      // $is_distinct
  FN_NOT_DISTINCT = 272;               // $is_not_distinct
  FN_NOT_DISTINCT_INT64_UINT64 = 273;  // $is_not_distinct
  FN_NOT_DISTINCT_UINT64_INT64 = 274;  // $is_not_distinct

  // Bitwise unary operators.
  FN_BITWISE_NOT_INT32 = 120;   // $bitwise_not
  FN_BITWISE_NOT_INT64 = 121;   // $bitwise_not
  FN_BITWISE_NOT_UINT32 = 122;  // $bitwise_not
  FN_BITWISE_NOT_UINT64 = 123;  // $bitwise_not
  FN_BITWISE_NOT_BYTES = 241;   // $bitwise_not
  // Bitwise binary operators.
  FN_BITWISE_OR_INT32 = 124;    // $bitwise_or
  FN_BITWISE_OR_INT64 = 125;    // $bitwise_or
  FN_BITWISE_OR_UINT32 = 126;   // $bitwise_or
  FN_BITWISE_OR_UINT64 = 127;   // $bitwise_or
  FN_BITWISE_OR_BYTES = 242;    // $bitwise_or
  FN_BITWISE_XOR_INT32 = 128;   // $bitwise_xor
  FN_BITWISE_XOR_INT64 = 129;   // $bitwise_xor
  FN_BITWISE_XOR_UINT32 = 130;  // $bitwise_xor
  FN_BITWISE_XOR_UINT64 = 131;  // $bitwise_xor
  FN_BITWISE_XOR_BYTES = 243;   // $bitwise_xor
  FN_BITWISE_AND_INT32 = 132;   // $bitwise_and
  FN_BITWISE_AND_INT64 = 133;   // $bitwise_and
  FN_BITWISE_AND_UINT32 = 134;  // $bitwise_and
  FN_BITWISE_AND_UINT64 = 135;  // $bitwise_and
  FN_BITWISE_AND_BYTES = 244;   // $bitwise_and
  // For all bitwise shift operators, the second argument has int64 type.
  // Expected behavior of bitwise shift operations:
  // * Shifting by a negative offset is an error.
  // * Shifting by >= 64 for uint64/int64 and >= 32 for int32/uint32 gives 0.
  // * Shifting right on signed values does not do sign extension.
  FN_BITWISE_LEFT_SHIFT_INT32 = 136;    // $bitwise_left_shift
  FN_BITWISE_LEFT_SHIFT_INT64 = 137;    // $bitwise_left_shift
  FN_BITWISE_LEFT_SHIFT_UINT32 = 138;   // $bitwise_left_shift
  FN_BITWISE_LEFT_SHIFT_UINT64 = 139;   // $bitwise_left_shift
  FN_BITWISE_LEFT_SHIFT_BYTES = 245;    // $bitwise_left_shift
  FN_BITWISE_RIGHT_SHIFT_INT32 = 140;   // $bitwise_right_shift
  FN_BITWISE_RIGHT_SHIFT_INT64 = 141;   // $bitwise_right_shift
  FN_BITWISE_RIGHT_SHIFT_UINT32 = 142;  // $bitwise_right_shift
  FN_BITWISE_RIGHT_SHIFT_UINT64 = 143;  // $bitwise_right_shift
  FN_BITWISE_RIGHT_SHIFT_BYTES = 246;   // $bitwise_right_shift

  // BIT_COUNT functions.
  FN_BIT_COUNT_INT32 = 144;   // bit_count(int32) -> int64
  FN_BIT_COUNT_INT64 = 145;   // bit_count(int64) -> int64
  FN_BIT_COUNT_UINT64 = 146;  // bit_count(uint64) -> int64
  FN_BIT_COUNT_BYTES = 247;   // bit_count(bytes) -> int64

  FN_ERROR = 253;  // error(string) -> {unused result, coercible to any type}

  FN_COUNT_STAR = 57;  // $count_star

  // The following functions use standard function call syntax.
  // TODO: We may want to move all of these into another ID space
  // separating them from true built-in functions declared above.

  // String functions
  FN_CONCAT_STRING = 1000;     // concat(repeated string) -> string
  FN_CONCAT_BYTES = 1001;      // concat(repeated bytes) -> bytes
  FN_CONCAT_OP_STRING = 1063;  // concat(string, string) -> string
  FN_CONCAT_OP_BYTES = 1064;   // concat(bytes, bytes) -> bytes
  FN_STRPOS_STRING = 1002;     // strpos(string, string) -> int64
  FN_STRPOS_BYTES = 1003;      // strpos(bytes, bytes) -> int64
  // instr(string, string[, int64[, int64]]) -> int64
  FN_INSTR_STRING = 1070;
  // instr(bytes, bytes[, int64[, int64]]) -> int64
  FN_INSTR_BYTES = 1071;
  FN_LOWER_STRING = 1006;           // lower(string) -> string
  FN_LOWER_BYTES = 1007;            // lower(bytes) -> bytes
  FN_UPPER_STRING = 1008;           // upper(string) -> string
  FN_UPPER_BYTES = 1009;            // upper(bytes) -> bytes
  FN_LENGTH_STRING = 1010;          // length(string) -> int64
  FN_LENGTH_BYTES = 1011;           // length(bytes) -> int64
  FN_STARTS_WITH_STRING = 1012;     // starts_with(string, string) -> string
  FN_STARTS_WITH_BYTES = 1013;      // starts_with(bytes, bytes) -> bytes
  FN_ENDS_WITH_STRING = 1014;       // ends_with(string, string) -> string
  FN_ENDS_WITH_BYTES = 1015;        // ends_with(bytes, bytes) -> bytes
  FN_SUBSTR_STRING = 1016;          // substr(string, int64[, int64]) -> string
  FN_SUBSTR_BYTES = 1017;           // substr(bytes, int64[, int64]) -> bytes
  FN_TRIM_STRING = 1018;            // trim(string[, string]) -> string
  FN_TRIM_BYTES = 1019;             // trim(bytes, bytes) -> bytes
  FN_LTRIM_STRING = 1020;           // ltrim(string[, string]) -> string
  FN_LTRIM_BYTES = 1021;            // ltrim(bytes, bytes) -> bytes
  FN_RTRIM_STRING = 1022;           // rtrim(string[, string]) -> string
  FN_RTRIM_BYTES = 1023;            // rtrim(bytes, bytes) -> bytes
  FN_REPLACE_STRING = 1024;         // replace(string, string, string) -> string
  FN_REPLACE_BYTES = 1025;          // replace(bytes, bytes, bytes) -> bytes
  FN_REGEXP_MATCH_STRING = 1026;    // regexp_match(string, string) -> bool
  FN_REGEXP_MATCH_BYTES = 1027;     // regexp_match(bytes, bytes) -> bool
  FN_REGEXP_EXTRACT_STRING = 1028;  // regexp_extract(string, string) -> string
  FN_REGEXP_EXTRACT_BYTES = 1029;   // regexp_extract(bytes, bytes) -> bytes
  FN_REGEXP_REPLACE_STRING = 1030;
  // regexp_replace(string, string, string) -> string
  FN_REGEXP_REPLACE_BYTES = 1031;
  // regexp_replace(bytes, bytes, bytes) -> bytes
  FN_REGEXP_EXTRACT_ALL_STRING = 1032;
  // regexp_extract_all(string, string) -> array of string
  FN_REGEXP_EXTRACT_ALL_BYTES = 1033;
  // regexp_extract_all(bytes, bytes) -> array of bytes
  FN_BYTE_LENGTH_STRING = 1034;  // byte_length(string) -> int64
  FN_BYTE_LENGTH_BYTES = 1035;   // byte_length(bytes) -> int64
                                 // semantically identical to FN_LENGTH_BYTES
  FN_CHAR_LENGTH_STRING = 1036;  // char_length(string) -> int64
                                 // semantically identical to FN_LENGTH_STRING
  FN_FORMAT_STRING = 1037;       // format(string, ...) -> string
  FN_SPLIT_STRING = 1038;        // split(string, string) -> array of string
  FN_SPLIT_BYTES = 1039;         // split(bytes, bytes) -> array of bytes
  FN_REGEXP_CONTAINS_STRING = 1040;  // regexp_contains(string, string) -> bool
  FN_REGEXP_CONTAINS_BYTES = 1041;   // regexp_contains(bytes, bytes) -> bool
  // Converts bytes to string by replacing invalid UTF-8 characters with
  // replacement char U+FFFD.
  FN_SAFE_CONVERT_BYTES_TO_STRING = 1042;
  // Unicode normalization and casefolding functions.
  FN_NORMALIZE_STRING = 1043;  // normalize(string [, mode]) -> string
  // normalize_and_casefold(string [, mode]) -> string
  FN_NORMALIZE_AND_CASEFOLD_STRING = 1044;
  FN_TO_BASE64 = 1045;    // to_base64(bytes) -> string
  FN_FROM_BASE64 = 1046;  // from_base64(string) -> bytes
  FN_TO_HEX = 1059;       // to_hex(bytes) -> string
  FN_FROM_HEX = 1060;     // from_hex(string) -> bytes
  FN_TO_BASE32 = 1061;    // to_base32(bytes) -> string
  FN_FROM_BASE32 = 1062;  // from_base32(string) -> bytes
  // to_code_points(string) -> array<int64>
  FN_TO_CODE_POINTS_STRING = 1047;
  // to_code_points(bytes) -> array<int64>
  FN_TO_CODE_POINTS_BYTES = 1048;
  // code_points_to_string(array<int64>) -> string
  FN_CODE_POINTS_TO_STRING = 1049;
  // code_points_to_bytes(array<int64>) -> bytes
  FN_CODE_POINTS_TO_BYTES = 1050;
  FN_LPAD_BYTES = 1051;        // lpad(bytes, int64[, bytes]) -> bytes
  FN_LPAD_STRING = 1052;       // lpad(string, int64[, string]) -> string
  FN_RPAD_BYTES = 1053;        // rpad(bytes, int64[, bytes]) -> bytes
  FN_RPAD_STRING = 1054;       // rpad(string, int64[, string]) -> string
  FN_LEFT_STRING = 1065;       // left(string, int64) -> string
  FN_LEFT_BYTES = 1066;        // left(bytes, int64) -> bytes
  FN_RIGHT_STRING = 1067;      // right(string, int64) -> string
  FN_RIGHT_BYTES = 1068;       // right(bytes, int64) -> bytes
  FN_REPEAT_BYTES = 1055;      // repeat(bytes, int64) -> bytes
  FN_REPEAT_STRING = 1056;     // repeat(string, int64) -> string
  FN_REVERSE_STRING = 1057;    // reverse(string) -> string
  FN_REVERSE_BYTES = 1058;     // reverse(bytes) -> bytes
  FN_SOUNDEX_STRING = 1069;    // soundex(string) -> string
  FN_ASCII_STRING = 1072;      // ASCII(string) -> int64
  FN_ASCII_BYTES = 1073;       // ASCII(bytes) -> int64
  FN_TRANSLATE_STRING = 1074;  // translate(string, string, string) -> string
  FN_TRANSLATE_BYTES = 1075;   // soundex(bytes, bytes, bytes) -> bytes
  FN_INITCAP_STRING = 1076;    // initcap(string[, string]) -> string
  FN_UNICODE_STRING = 1077;    // unicode(string) -> int64
  FN_CHR_STRING = 1078;        // chr(int64) -> string
  FN_REGEXP_INSTR_STRING =
      1079;  // regex_instr(string, string[, int64[, int64[, int64]]])
  FN_REGEXP_INSTR_BYTES =
      1080;  // regex_instr(bytes, bytes[, int64[, int64[, int64]]])
  FN_CONTAINS_SUBSTR = 1081;  // contains_substr(any, string) -> bool

  // Control flow functions
  FN_IF = 1100;  // if
  // Coalesce is used to express the output join column in FULL JOIN.
  FN_COALESCE = 1101;  // coalesce
  FN_IFNULL = 1102;    // ifnull
  FN_NULLIF = 1103;    // nullif

  // Time functions
  FN_CURRENT_DATE = 1200;       // current_date
  FN_CURRENT_DATETIME = 1804;   // current_datetime
  FN_CURRENT_TIME = 1805;       // current_time
  FN_CURRENT_TIMESTAMP = 1260;  // current_timestamp
  FN_DATE_ADD_DATE = 1205;  // date_add
  FN_DATETIME_ADD = 1812;   // datetime_add
  FN_TIME_ADD = 1813;       // time_add
  FN_TIMESTAMP_ADD = 1261;  // timestamp_add
  FN_DATE_DIFF_DATE = 1210;  // date_diff
  FN_DATETIME_DIFF = 1816;   // datetime_diff
  FN_TIME_DIFF = 1817;       // time_diff
  FN_TIMESTAMP_DIFF = 1262;  // timestamp_diff
  FN_DATE_SUB_DATE = 1215;  // date_sub
  FN_DATETIME_SUB = 1814;   // datetime_sub
  FN_TIME_SUB = 1815;       // time_sub
  FN_TIMESTAMP_SUB = 1263;  // timestamp_sub
  FN_DATE_TRUNC_DATE = 1220;  // date_trunc
  FN_DATETIME_TRUNC = 1818;   // datetime_trunc
  FN_TIME_TRUNC = 1819;       // time_trunc
  FN_TIMESTAMP_TRUNC = 1264;  // timestamp_trunc

  FN_DATE_FROM_UNIX_DATE = 1225;  // date_from_unix_date
  FN_TIMESTAMP_FROM_INT64_SECONDS = 1289;  // timestamp_seconds
  FN_TIMESTAMP_FROM_INT64_MILLIS = 1290;   // timestamp_millis
  FN_TIMESTAMP_FROM_INT64_MICROS = 1291;   // timestamp_micros
  FN_TIMESTAMP_FROM_UNIX_SECONDS_INT64 = 1827;  // timestamp_from_unix_seconds
  FN_TIMESTAMP_FROM_UNIX_SECONDS_TIMESTAMP =
      1828;                                    // timestamp_from_unix_seconds
  FN_TIMESTAMP_FROM_UNIX_MILLIS_INT64 = 1829;  // timestamp_from_unix_millis
  FN_TIMESTAMP_FROM_UNIX_MILLIS_TIMESTAMP = 1830;  // timestamp_from_unix_millis
  FN_TIMESTAMP_FROM_UNIX_MICROS_INT64 = 1831;      // timestamp_from_unix_micros
  FN_TIMESTAMP_FROM_UNIX_MICROS_TIMESTAMP = 1832;  // timestamp_from_unix_micros
  FN_UNIX_DATE = 1230;                             // unix_date
  FN_UNIX_SECONDS_FROM_TIMESTAMP = 1268;
  FN_UNIX_MILLIS_FROM_TIMESTAMP = 1269;
  FN_UNIX_MICROS_FROM_TIMESTAMP = 1270;
  FN_DATE_FROM_TIMESTAMP = 1271;  // date
  FN_DATE_FROM_DATETIME = 1826;   // date
  FN_DATE_FROM_DATE = 1833;       // date
  FN_DATE_FROM_STRING = 1837;     // date
  FN_DATE_FROM_YEAR_MONTH_DAY = 1297;  // date
  FN_TIMESTAMP_FROM_STRING = 1272;     // timestamp
  FN_TIMESTAMP_FROM_DATE = 1273;       // timestamp
  FN_TIMESTAMP_FROM_DATETIME = 1801;   // timestamp
  FN_TIMESTAMP_FROM_TIMESTAMP = 1834;  // timestamp
  FN_TIME_FROM_HOUR_MINUTE_SECOND = 1298;                     // time
  FN_TIME_FROM_TIMESTAMP = 1802;                              // time
  FN_TIME_FROM_DATETIME = 1825;                               // time
  FN_TIME_FROM_TIME = 1836;                                   // time
  FN_TIME_FROM_STRING = 1838;                                 // time
  FN_DATETIME_FROM_DATE_AND_TIME = 1299;                      // datetime
  FN_DATETIME_FROM_YEAR_MONTH_DAY_HOUR_MINUTE_SECOND = 1800;  // datetime
  FN_DATETIME_FROM_TIMESTAMP = 1803;                          // datetime
  FN_DATETIME_FROM_DATE = 1824;                               // datetime
  FN_DATETIME_FROM_DATETIME = 1835;                           // datetime
  FN_DATETIME_FROM_STRING = 1839;                             // datetime

  FN_STRING_FROM_DATE = 1840;       // string
  FN_STRING_FROM_TIMESTAMP = 1274;  // string
  FN_STRING_FROM_DATETIME = 1841;   // string
  FN_STRING_FROM_TIME = 1842;       // string

  // Signatures for extracting date parts, taking a date/timestamp
  // and the target date part as arguments.
  FN_EXTRACT_FROM_DATE = 1251;       // $extract
  FN_EXTRACT_FROM_DATETIME = 1806;   // $extract
  FN_EXTRACT_FROM_TIME = 1807;       // $extract
  FN_EXTRACT_FROM_TIMESTAMP = 1275;  // $extract
  FN_EXTRACT_FROM_INTERVAL = 1857;   // $extract

  // Signatures specific to extracting the DATE date part from a DATETIME or a
  // TIMESTAMP.
  FN_EXTRACT_DATE_FROM_DATETIME = 1808;   // $extract_date
  FN_EXTRACT_DATE_FROM_TIMESTAMP = 1276;  // $extract_date

  // Signatures specific to extracting the TIME date part from a DATETIME or a
  // TIMESTAMP.
  FN_EXTRACT_TIME_FROM_DATETIME = 1809;   // $extract_time
  FN_EXTRACT_TIME_FROM_TIMESTAMP = 1810;  // $extract_time

  // Signature specific to extracting the DATETIME date part from a TIMESTAMP.
  FN_EXTRACT_DATETIME_FROM_TIMESTAMP = 1811;  // $extract_datetime

  FN_FORMAT_DATE = 1293;       // format_date
  FN_FORMAT_DATETIME = 1820;   // format_datetime
  FN_FORMAT_TIME = 1821;       // format_time
  FN_FORMAT_TIMESTAMP = 1294;  // format_timestamp
  FN_PARSE_DATE = 1295;        // parse_date
  FN_PARSE_DATETIME = 1822;    // parse_datetime
  FN_PARSE_TIME = 1823;        // parse_time
  FN_PARSE_TIMESTAMP = 1296;   // parse_timestamp

  FN_LAST_DAY_DATE = 1843;      // last_day date
  FN_LAST_DAY_DATETIME = 1844;  // last_day datetime

  FN_INTERVAL_CONSTRUCTOR = 1855;  // $interval
  FN_MAKE_INTERVAL = 1856;         // make_interval
  FN_JUSTIFY_HOURS = 1858;         // justify_hours
  FN_JUSTIFY_DAYS = 1859;          // justify_days
  FN_JUSTIFY_INTERVAL = 1860;      // justify_interval

  // Math functions
  FN_ABS_INT32 = 1300;        // abs
  FN_ABS_INT64 = 1301;        // abs
  FN_ABS_UINT32 = 1346;       // abs
  FN_ABS_UINT64 = 1347;       // abs
  FN_ABS_FLOAT = 1302;        // abs
  FN_ABS_DOUBLE = 1303;       // abs
  FN_ABS_NUMERIC = 1359;      // abs
  FN_ABS_BIGNUMERIC = 1395;   // abs
  FN_SIGN_INT32 = 1341;       // sign
  FN_SIGN_INT64 = 1342;       // sign
  FN_SIGN_UINT32 = 1356;      // sign
  FN_SIGN_UINT64 = 1357;      // sign
  FN_SIGN_FLOAT = 1343;       // sign
  FN_SIGN_DOUBLE = 1344;      // sign
  FN_SIGN_NUMERIC = 1360;     // sign
  FN_SIGN_BIGNUMERIC = 1396;  // sign

  FN_ROUND_DOUBLE = 1305;               // round(double) -> double
  FN_ROUND_FLOAT = 1306;                // round(float) -> float
  FN_ROUND_NUMERIC = 1363;              // round(numeric) -> numeric
  FN_ROUND_BIGNUMERIC = 1397;           // round(bignumeric) -> bignumeric
  FN_ROUND_WITH_DIGITS_DOUBLE = 1307;   // round(double, int64) -> double
  FN_ROUND_WITH_DIGITS_FLOAT = 1308;    // round(float, int64) -> float
  FN_ROUND_WITH_DIGITS_NUMERIC = 1364;  // round(numeric, int64) -> numeric
  FN_ROUND_WITH_DIGITS_BIGNUMERIC =
      1398;                            // round(bignumeric, int64) -> bignumeric
  FN_TRUNC_DOUBLE = 1309;              // trunc(double) -> double
  FN_TRUNC_FLOAT = 1310;               // trunc(float) -> float
  FN_TRUNC_NUMERIC = 1365;             // trunc(numeric) -> numeric
  FN_TRUNC_BIGNUMERIC = 1399;          // trunc(bignumeric) -> bignumeric
  FN_TRUNC_WITH_DIGITS_DOUBLE = 1311;  // trunc(double, int64) -> double
  FN_TRUNC_WITH_DIGITS_FLOAT = 1312;   // trunc(float, int64) -> float
  FN_TRUNC_WITH_DIGITS_NUMERIC = 1366;  // trunc(numeric, int64) -> numeric
  FN_TRUNC_WITH_DIGITS_BIGNUMERIC =
      2300;                    // trunc(bignumeric, int64) -> bignumeric
  FN_CEIL_DOUBLE = 1313;       // ceil(double) -> double
  FN_CEIL_FLOAT = 1314;        // ceil(float) -> float
  FN_CEIL_NUMERIC = 1368;      // ceil(numeric) -> numeric
  FN_CEIL_BIGNUMERIC = 1393;   // ceil(bignumeric) -> bignumeric
  FN_FLOOR_DOUBLE = 1315;      // floor(double) -> double
  FN_FLOOR_FLOAT = 1316;       // floor(float) -> float
  FN_FLOOR_NUMERIC = 1369;     // floor(numeric) -> numeric
  FN_FLOOR_BIGNUMERIC = 1394;  // floor(bignumeric) -> bignumeric

  FN_MOD_INT64 = 1349;       // mod(int64, int64) -> int64
  FN_MOD_UINT64 = 1351;      // mod(uint64, uint64) -> uint64
  FN_MOD_NUMERIC = 1367;     // mod(numeric, numeric) -> numeric
  FN_MOD_BIGNUMERIC = 2301;  // mod(bignumeric, bignumeric) -> bignumeric
  FN_DIV_INT64 = 1353;       // div(int64, int64) -> int64
  FN_DIV_UINT64 = 1355;      // div(uint64, uint64) -> uint64
  FN_DIV_NUMERIC = 1362;     // div(numeric, numeric) -> numeric
  FN_DIV_BIGNUMERIC = 2302;  // div(bignumeric, bignumeric) -> bignumeric

  FN_IS_INF = 1317;                       // is_inf
  FN_IS_NAN = 1318;                       // is_nan
  FN_IEEE_DIVIDE_DOUBLE = 1319;           // ieee_divide
  FN_IEEE_DIVIDE_FLOAT = 1320;            // ieee_divide
  FN_SAFE_DIVIDE_DOUBLE = 1358;           // safe_divide
  FN_SAFE_DIVIDE_NUMERIC = 1361;          // safe_divide
  FN_SAFE_DIVIDE_BIGNUMERIC = 1388;       // safe_divide
  FN_SAFE_ADD_INT64 = 1371;               // safe_add
  FN_SAFE_ADD_UINT64 = 1372;              // safe_add
  FN_SAFE_ADD_DOUBLE = 1373;              // safe_add
  FN_SAFE_ADD_NUMERIC = 1374;             // safe_add
  FN_SAFE_ADD_BIGNUMERIC = 1389;          // safe_add
  FN_SAFE_SUBTRACT_INT64 = 1375;          // safe_subtract
  FN_SAFE_SUBTRACT_UINT64 = 1376;         // safe_subtract
  FN_SAFE_SUBTRACT_DOUBLE = 1377;         // safe_subtract
  FN_SAFE_SUBTRACT_NUMERIC = 1378;        // safe_subtract
  FN_SAFE_SUBTRACT_BIGNUMERIC = 1390;     // safe_subtract
  FN_SAFE_MULTIPLY_INT64 = 1379;          // safe_multiply
  FN_SAFE_MULTIPLY_UINT64 = 1380;         // safe_multiply
  FN_SAFE_MULTIPLY_DOUBLE = 1381;         // safe_multiply
  FN_SAFE_MULTIPLY_NUMERIC = 1382;        // safe_multiply
  FN_SAFE_MULTIPLY_BIGNUMERIC = 1391;     // safe_multiply
  FN_SAFE_UNARY_MINUS_INT32 = 1383;       // safe_negate
  FN_SAFE_UNARY_MINUS_INT64 = 1384;       // safe_negate
  FN_SAFE_UNARY_MINUS_FLOAT = 1385;       // safe_negate
  FN_SAFE_UNARY_MINUS_DOUBLE = 1386;      // safe_negate
  FN_SAFE_UNARY_MINUS_NUMERIC = 1387;     // safe_negate
  FN_SAFE_UNARY_MINUS_BIGNUMERIC = 1392;  // safe_negate

  FN_GREATEST = 1321;  // greatest
  FN_LEAST = 1322;     // least

  FN_SQRT_DOUBLE = 1323;      // sqrt
  FN_SQRT_NUMERIC = 2308;     // sqrt(numeric) -> numeric
  FN_SQRT_BIGNUMERIC = 2309;  // sqrt(bignumeric) -> bignumeric
  FN_POW_DOUBLE = 1324;       // pow
  FN_POW_NUMERIC = 1370;      // pow(numeric, numeric) -> numeric
  FN_POW_BIGNUMERIC = 2303;   // pow(bignumeric, bignumeric) -> bignumeric
  FN_EXP_DOUBLE = 1325;       // exp
  FN_EXP_NUMERIC = 2304;      // exp(numeric) -> numeric
  FN_EXP_BIGNUMERIC = 2305;   // exp(bignumeric) -> bignumeric
  FN_NATURAL_LOGARITHM_DOUBLE = 1326;  // ln and log
  // ln(numeric) -> numeric and log(numeric) -> numeric
  FN_NATURAL_LOGARITHM_NUMERIC = 2306;
  // ln(bignumeric) -> bignumeric and log(bignumeric) -> bignumeric
  FN_NATURAL_LOGARITHM_BIGNUMERIC = 2307;
  FN_DECIMAL_LOGARITHM_DOUBLE = 1345;      // log10
  FN_DECIMAL_LOGARITHM_NUMERIC = 2310;     // log10(numeric) -> numeric
  FN_DECIMAL_LOGARITHM_BIGNUMERIC = 2311;  // log10(bignumeric) -> bignumeric
  FN_LOGARITHM_DOUBLE = 1327;              // log
  FN_LOGARITHM_NUMERIC = 2312;             // log(numeric, numeric) -> numeric
  FN_LOGARITHM_BIGNUMERIC = 2313;  // log(bignumeric, bignumeric) -> bignumeric
  FN_PARSE_NUMERIC = 2314;         // parse_numeric(string) -> numeric
  FN_PARSE_BIGNUMERIC = 2315;      // parse_bignumeric(string) -> bignumeric

  FN_COS_DOUBLE = 1328;    // cos
  FN_COSH_DOUBLE = 1329;   // cosh
  FN_ACOS_DOUBLE = 1330;   // acos
  FN_ACOSH_DOUBLE = 1331;  // acosh
  FN_SIN_DOUBLE = 1332;    // sin
  FN_SINH_DOUBLE = 1333;   // sinh
  FN_ASIN_DOUBLE = 1334;   // asin
  FN_ASINH_DOUBLE = 1335;  // asinh
  FN_TAN_DOUBLE = 1336;    // tan
  FN_TANH_DOUBLE = 1337;   // tanh
  FN_ATAN_DOUBLE = 1338;   // atan
  FN_ATANH_DOUBLE = 1339;  // atanh
  FN_ATAN2_DOUBLE = 1340;  // atan2

  // Aggregate functions.
  // TODO: Add missing type signatures.
  FN_ANY_VALUE = 1400;                // any_value
  FN_ARRAY_AGG = 1401;                // array_agg
  FN_ARRAY_CONCAT_AGG = 1442;         // array_concat_agg
  FN_AVG_INT64 = 1402;                // avg
  FN_AVG_UINT64 = 1403;               // avg
  FN_AVG_DOUBLE = 1404;               // avg
  FN_AVG_NUMERIC = 1468;              // avg
  FN_AVG_BIGNUMERIC = 1479;           // avg
  FN_COUNT = 1405;                    // count
  FN_MAX = 1406;                      // max
  FN_MIN = 1407;                      // min
  FN_STRING_AGG_STRING = 1408;        // string_agg(s)
  FN_STRING_AGG_DELIM_STRING = 1409;  // string_agg(s, delim_s)
  FN_STRING_AGG_BYTES = 1413;         // string_agg(b)
  FN_STRING_AGG_DELIM_BYTES = 1414;   // string_agg(b, delim_b)
  FN_SUM_INT64 = 1410;                // sum
  FN_SUM_UINT64 = 1411;               // sum
  FN_SUM_DOUBLE = 1412;               // sum
  FN_SUM_NUMERIC = 1467;              // sum
  FN_SUM_BIGNUMERIC = 1478;           // sum
  FN_SUM_INTERVAL = 1489;             // sum
  FN_BIT_AND_INT32 = 1415;            // bit_and
  FN_BIT_AND_INT64 = 1416;            // bit_and
  FN_BIT_AND_UINT32 = 1417;           // bit_and
  FN_BIT_AND_UINT64 = 1418;           // bit_and
  FN_BIT_OR_INT32 = 1419;             // bit_or
  FN_BIT_OR_INT64 = 1420;             // bit_or
  FN_BIT_OR_UINT32 = 1421;            // bit_or
  FN_BIT_OR_UINT64 = 1422;            // bit_or
  FN_BIT_XOR_INT32 = 1423;            // bit_xor
  FN_BIT_XOR_INT64 = 1424;            // bit_xor
  FN_BIT_XOR_UINT32 = 1425;           // bit_xor
  FN_BIT_XOR_UINT64 = 1426;           // bit_xor
  FN_LOGICAL_AND = 1427;              // logical_and
  FN_LOGICAL_OR = 1428;               // logical_or
  // Approximate aggregate functions.
  FN_APPROX_COUNT_DISTINCT = 1429;      // approx_count_distinct
  FN_APPROX_QUANTILES = 1430;           // approx_quantiles
  FN_APPROX_TOP_COUNT = 1431;           // approx_top_count
  FN_APPROX_TOP_SUM_INT64 = 1432;       // approx_top_sum
  FN_APPROX_TOP_SUM_UINT64 = 1433;      // approx_top_sum
  FN_APPROX_TOP_SUM_DOUBLE = 1434;      // approx_top_sum
  FN_APPROX_TOP_SUM_NUMERIC = 1469;     // approx_top_sum
  FN_APPROX_TOP_SUM_BIGNUMERIC = 1480;  // approx_top_sum

  // Approximate count functions that expose the intermediate sketch.
  // These are all found in the "hll_count.*" namespace.
  //
  FN_HLL_COUNT_MERGE = 1444;            // hll_count.merge(bytes)
  FN_HLL_COUNT_EXTRACT = 1445;          // hll_count.extract(bytes), scalar
  FN_HLL_COUNT_INIT_INT64 = 1446;       // hll_count.init(int64)
  FN_HLL_COUNT_INIT_UINT64 = 1447;      // hll_count.init(uint64)
  FN_HLL_COUNT_INIT_NUMERIC = 1470;     // hll_count.init(numeric)
  FN_HLL_COUNT_INIT_BIGNUMERIC = 1481;  // hll_count.init(bignumeric)
  FN_HLL_COUNT_INIT_STRING = 1448;      // hll_count.init(string)
  FN_HLL_COUNT_INIT_BYTES = 1449;       // hll_count.init(bytes)
  FN_HLL_COUNT_MERGE_PARTIAL = 1450;    // hll_count.merge_partial(bytes)

  // Statistical aggregate functions.
  FN_CORR = 1435;                    // corr
  FN_CORR_NUMERIC = 1471;            // corr
  FN_CORR_BIGNUMERIC = 1488;         // corr
  FN_COVAR_POP = 1436;               // covar_pop
  FN_COVAR_POP_NUMERIC = 1472;       // covar_pop
  FN_COVAR_POP_BIGNUMERIC = 1486;    // covar_pop
  FN_COVAR_SAMP = 1437;              // covar_samp
  FN_COVAR_SAMP_NUMERIC = 1473;      // covar_samp
  FN_COVAR_SAMP_BIGNUMERIC = 1487;   // covar_samp
  FN_STDDEV_POP = 1438;              // stddev_pop
  FN_STDDEV_POP_NUMERIC = 1474;      // stddev_pop
  FN_STDDEV_POP_BIGNUMERIC = 1482;   // stddev_pop
  FN_STDDEV_SAMP = 1439;             // stddev_samp
  FN_STDDEV_SAMP_NUMERIC = 1475;     // stddev_samp
  FN_STDDEV_SAMP_BIGNUMERIC = 1483;  // stddev_samp
  FN_VAR_POP = 1440;                 // var_pop
  FN_VAR_POP_NUMERIC = 1476;         // var_pop
  FN_VAR_POP_BIGNUMERIC = 1484;      // var_pop
  FN_VAR_SAMP = 1441;                // var_samp
  FN_VAR_SAMP_NUMERIC = 1477;        // var_samp
  FN_VAR_SAMP_BIGNUMERIC = 1485;     // var_samp

  FN_COUNTIF = 1443;  // countif

  // Approximate quantiles functions that produce or consume intermediate
  // sketches. All found in the "kll_quantiles.*" namespace.
  //
  FN_KLL_QUANTILES_INIT_INT64 = 1451;
  FN_KLL_QUANTILES_INIT_UINT64 = 1452;
  FN_KLL_QUANTILES_INIT_DOUBLE = 1453;
  FN_KLL_QUANTILES_MERGE_PARTIAL = 1454;
  FN_KLL_QUANTILES_MERGE_INT64 = 1455;
  FN_KLL_QUANTILES_MERGE_UINT64 = 1456;
  FN_KLL_QUANTILES_MERGE_DOUBLE = 1457;
  FN_KLL_QUANTILES_EXTRACT_INT64 = 1458;   // scalar
  FN_KLL_QUANTILES_EXTRACT_UINT64 = 1459;  // scalar
  FN_KLL_QUANTILES_EXTRACT_DOUBLE = 1460;  // scalar
  FN_KLL_QUANTILES_MERGE_POINT_INT64 = 1461;
  FN_KLL_QUANTILES_MERGE_POINT_UINT64 = 1462;
  FN_KLL_QUANTILES_MERGE_POINT_DOUBLE = 1463;
  FN_KLL_QUANTILES_EXTRACT_POINT_INT64 = 1464;   // scalar
  FN_KLL_QUANTILES_EXTRACT_POINT_UINT64 = 1465;  // scalar
  FN_KLL_QUANTILES_EXTRACT_POINT_DOUBLE = 1466;  // scalar

  // Analytic functions.
  FN_DENSE_RANK = 1500;                  // dense_rank
  FN_RANK = 1501;                        // rank
  FN_ROW_NUMBER = 1502;                  // row_number
  FN_PERCENT_RANK = 1503;                // percent_rank
  FN_CUME_DIST = 1504;                   // cume_dist
  FN_NTILE = 1505;                       // ntile
  FN_LEAD = 1506;                        // lead
  FN_LAG = 1507;                         // lag
  FN_FIRST_VALUE = 1508;                 // first_value
  FN_LAST_VALUE = 1509;                  // last_value
  FN_NTH_VALUE = 1510;                   // nth_value
  FN_PERCENTILE_CONT = 1511;             // percentile_cont
  FN_PERCENTILE_CONT_NUMERIC = 1513;     // percentile_cont
  FN_PERCENTILE_CONT_BIGNUMERIC = 1515;  // percentile_cont
  FN_PERCENTILE_DISC = 1512;             // percentile_disc
  FN_PERCENTILE_DISC_NUMERIC = 1514;     // percentile_disc
  FN_PERCENTILE_DISC_BIGNUMERIC = 1516;  // percentile_disc

  //
  // Misc functions.

  FN_BIT_CAST_INT32_TO_INT32 = 1604;    // bit_cast_to_int32(int32)
  FN_BIT_CAST_UINT32_TO_INT32 = 1605;   // bit_cast_to_int32(uint32)
  FN_BIT_CAST_INT64_TO_INT64 = 1606;    // bit_cast_to_int64(int64)
  FN_BIT_CAST_UINT64_TO_INT64 = 1607;   // bit_cast_to_int64(uint64)
  FN_BIT_CAST_UINT32_TO_UINT32 = 1608;  // bit_cast_to_uint32(uint32)
  FN_BIT_CAST_INT32_TO_UINT32 = 1609;   // bit_cast_to_uint32(int32)
  FN_BIT_CAST_UINT64_TO_UINT64 = 1610;  // bit_cast_to_uint64(uint64)
  FN_BIT_CAST_INT64_TO_UINT64 = 1611;   // bit_cast_to_uint64(int64)

  FN_SESSION_USER = 1612;  // session_user

  FN_GENERATE_ARRAY_INT64 = 1613;       // generate_array(int64)
  FN_GENERATE_ARRAY_UINT64 = 1614;      // generate_array(uint64)
  FN_GENERATE_ARRAY_NUMERIC = 1625;     // generate_array(numeric)
  FN_GENERATE_ARRAY_BIGNUMERIC = 1683;  // generate_array(bignumeric)
  FN_GENERATE_ARRAY_DOUBLE = 1615;      // generate_array(double)
  FN_GENERATE_DATE_ARRAY = 1616;        // generate_date_array(date)
  FN_GENERATE_TIMESTAMP_ARRAY = 1617;   // generate_timestamp_array(timestamp)

  FN_ARRAY_REVERSE = 1621;  // array_reverse(array) -> array

  FN_RANGE_BUCKET = 1680;  //  range_bucket(T, array<T>) -> int64

  FN_RAND = 1618;           // rand() -> double
  FN_GENERATE_UUID = 1679;  // generate_uuid() -> string

  FN_JSON_EXTRACT = 1619;       // json_extract(string, string) -> string
  FN_JSON_EXTRACT_JSON = 1684;  // json_extract(json, string) -> json
  FN_JSON_EXTRACT_SCALAR =
      1620;  // json_extract_scalar(string, string) -> string
  FN_JSON_EXTRACT_SCALAR_JSON =
      1685;  // json_extract_scalar(json, string) -> string
  FN_JSON_EXTRACT_ARRAY =
      1681;  // json_extract_array(string[, string]) -> array(string)
  FN_JSON_EXTRACT_ARRAY_JSON =
      1691;  // json_extract_array(json[, string]) -> array(json)
  FN_JSON_EXTRACT_STRING_ARRAY =
      1688;  // json_extract_string_array(string[, string]) -> array(string)
  FN_JSON_EXTRACT_STRING_ARRAY_JSON =
      1692;  // json_extract_string_array(json[, string]) -> array(string)
  FN_JSON_QUERY_ARRAY =
      1693;  // json_query_array(string[, string]) -> array(string)
  FN_JSON_QUERY_ARRAY_JSON =
      1694;  // json_query_array(json[, string]) -> array(json)
  FN_JSON_VALUE_ARRAY =
      1695;  // json_value_array(string[, string]) -> array(string)
  FN_JSON_VALUE_ARRAY_JSON =
      1696;  // json_value_array(json[, string]) -> array(string)
  FN_JSON_SUBSCRIPT_INT64 = 1689;   // $subscript(json,int64)-> json
  FN_JSON_SUBSCRIPT_STRING = 1690;  // $subscript(json,string)-> json
  FN_TO_JSON_STRING = 1622;         // to_json_string(any[, bool]) -> string
  FN_TO_JSON = 1697;                // to_json(any[, bool]) -> json
  FN_JSON_QUERY = 1623;             // json_query(string, string) -> string
  FN_JSON_QUERY_JSON = 1686;        // json_query(json, string) -> json
  FN_JSON_VALUE = 1624;             // json_value(string[, string]) -> string
  FN_JSON_VALUE_JSON = 1687;        // json_value(json[, string]) -> string
  FN_PARSE_JSON = 1698;             // parse_json(string) -> json
  FN_FROM_PROTO_TIMESTAMP =
      1626;  // from_proto(google.protobuf.Timestamp) -> timestamp
  FN_FROM_PROTO_DATE = 1627;  // from_proto(google.type.Date) -> date
  FN_FROM_PROTO_TIME_OF_DAY =
      1628;  // from_proto(google.type.TimeOfDay) -> time
  FN_FROM_PROTO_DOUBLE =
      1630;  // from_proto(google.protobuf.DoubleValue) -> double
  FN_FROM_PROTO_FLOAT =
      1631;  // from_proto(google.protobuf.FloatValue) -> float
  FN_FROM_PROTO_INT64 =
      1632;  // from_proto(google.protobuf.Int64Value) -> int64
  FN_FROM_PROTO_UINT64 =
      1633;  // from_proto(google.protobuf.UInt64Value) -> uint64
  FN_FROM_PROTO_INT32 =
      1634;  // from_proto(google.protobuf.Int32Value) -> int32
  FN_FROM_PROTO_UINT32 =
      1635;  // from_proto(google.protobuf.UInt32Value) -> uint32
  FN_FROM_PROTO_BOOL = 1636;  // from_proto(google.protobuf.BoolValue) -> bool
  FN_FROM_PROTO_BYTES =
      1637;  // from_proto(google.protobuf.BytesValue) -> bytes
  FN_FROM_PROTO_STRING =
      1638;  // from_proto(google.protobuf.StringValue) -> string

  // The idempotent signatures of from_proto just return the input value
  FN_FROM_PROTO_IDEMPOTENT_TIMESTAMP =
      1639;                              // from_proto(timestamp) -> timestamp
  FN_FROM_PROTO_IDEMPOTENT_DATE = 1640;  // from_proto(date) -> date
  FN_FROM_PROTO_IDEMPOTENT_TIME = 1641;  // from_proto(time) -> time
  FN_FROM_PROTO_IDEMPOTENT_DOUBLE = 1643;  // from_proto(double) -> double
  FN_FROM_PROTO_IDEMPOTENT_FLOAT = 1644;   // from_proto(float) -> float
  FN_FROM_PROTO_IDEMPOTENT_INT64 = 1645;   // from_proto(int64) -> int64
  FN_FROM_PROTO_IDEMPOTENT_UINT64 = 1646;  // from_proto(uint64) -> uint64
  FN_FROM_PROTO_IDEMPOTENT_INT32 = 1647;   // from_proto(int32) -> int32
  FN_FROM_PROTO_IDEMPOTENT_UINT32 = 1648;  // from_proto(uint32) -> uint32
  FN_FROM_PROTO_IDEMPOTENT_BOOL = 1649;    // from_proto(bool) -> bool
  FN_FROM_PROTO_IDEMPOTENT_BYTES = 1650;   // from_proto(bytes) -> bytes
  FN_FROM_PROTO_IDEMPOTENT_STRING = 1651;  // from_proto(string) -> string

  FN_TO_PROTO_TIMESTAMP =
      1652;                 // to_proto(timestamp) -> google.protobuf.Timestamp
  FN_TO_PROTO_DATE = 1653;  // to_proto(date) -> google.type.Date
  FN_TO_PROTO_TIME = 1654;  // to_proto(time) -> google.type.TimeOfDay
  FN_TO_PROTO_DOUBLE = 1656;  // to_proto(double) -> google.protobuf.DoubleValue
  FN_TO_PROTO_FLOAT = 1657;   // to_proto(float) -> google.protobuf.FloatValue
  FN_TO_PROTO_INT64 = 1658;   // to_proto(int64) -> google.protobuf.Int64Value
  FN_TO_PROTO_UINT64 = 1659;  // to_proto(uint64) -> google.protobuf.UInt64Value
  FN_TO_PROTO_INT32 = 1660;   // to_proto(int32) -> google.protobuf.Int32Value
  FN_TO_PROTO_UINT32 = 1661;  // to_proto(uint32) -> google.protobuf.UInt32Value
  FN_TO_PROTO_BOOL = 1662;    // to_proto(bool) -> google.protobuf.BoolValue
  FN_TO_PROTO_BYTES = 1663;   // to_proto(bytes) -> google.protobuf.BytesValue
  FN_TO_PROTO_STRING = 1664;  // to_proto(string) -> google.protobuf.StringValue

  // The idempotent signatures of to_proto just return the input value
  FN_TO_PROTO_IDEMPOTENT_TIMESTAMP =
      1665;  // to_proto(google.protobuf.Timestamp) -> google.protobuf.Timestamp
  FN_TO_PROTO_IDEMPOTENT_DATE =
      1666;  // to_proto(google.type.Date) -> google.type.Date
  FN_TO_PROTO_IDEMPOTENT_TIME_OF_DAY =
      1667;  // to_proto(google.type.TimeOfDay) -> google.type.TimeOfDay
  FN_TO_PROTO_IDEMPOTENT_DOUBLE =
      1669;                             // to_proto(google.protobuf.DoubleValue)
                                        // -> google.protobuf.DoubleValue
  FN_TO_PROTO_IDEMPOTENT_FLOAT = 1670;  // to_proto(google.protobuf.FloatValue)
                                        // -> google.protobuf.FloatValue
  FN_TO_PROTO_IDEMPOTENT_INT64 = 1671;  // to_proto(google.protobuf.Int64Value)
                                        // -> google.protobuf.Int64Value
  FN_TO_PROTO_IDEMPOTENT_UINT64 =
      1672;                             // to_proto(google.protobuf.UInt64Value)
                                        // -> google.protobuf.UInt64Value
  FN_TO_PROTO_IDEMPOTENT_INT32 = 1673;  // to_proto(google.protobuf.Int32Value)
                                        // -> google.protobuf.Int32Value
  FN_TO_PROTO_IDEMPOTENT_UINT32 =
      1674;  // to_proto(google.protobuf.UInt32Value)
             // -> google.protobuf.UInt32Value
  FN_TO_PROTO_IDEMPOTENT_BOOL =
      1675;  // to_proto(google.protobuf.BoolValue) -> google.protobuf.BoolValue
  FN_TO_PROTO_IDEMPOTENT_BYTES = 1676;  // to_proto(google.protobuf.BytesValue)
                                        // -> google.protobuf.BytesValue
  FN_TO_PROTO_IDEMPOTENT_STRING =
      1677;  // to_proto(google.protobuf.StringValue)
             // -> google.protobuf.StringValue

  FN_PROTO_DEFAULT_IF_NULL =
      1678;  // proto_default_if_null(<non-message optional field access>)

  FN_ENUM_VALUE_DESCRIPTOR_PROTO =
      1682;  // enum_value_descriptor_proto(<enum expression>) ->
             // google.protobuf.EnumValueDescriptorProto

  // Net functions. These are all found in the "net.*" namespace.
  FN_NET_FORMAT_IP = 1700;
  FN_NET_PARSE_IP = 1701;
  FN_NET_FORMAT_PACKED_IP = 1702;
  FN_NET_PARSE_PACKED_IP = 1703;
  FN_NET_IP_IN_NET = 1704;
  FN_NET_MAKE_NET = 1705;
  FN_NET_HOST = 1706;                 // net.host(string)
  FN_NET_REG_DOMAIN = 1707;           // net.reg_domain(string)
  FN_NET_PUBLIC_SUFFIX = 1708;        // net.public_suffix(string)
  FN_NET_IP_FROM_STRING = 1709;       // net.ip_from_string(string)
  FN_NET_SAFE_IP_FROM_STRING = 1710;  // net.safe_ip_from_string(string)
  FN_NET_IP_TO_STRING = 1711;         // net.ip_to_string(bytes)
  FN_NET_IP_NET_MASK = 1712;          // net.ip_net_mask(int64, int64)
  FN_NET_IP_TRUNC = 1713;             // net.ip_net_mask(bytes, int64)
  FN_NET_IPV4_FROM_INT64 = 1714;      // net.ipv4_from_int64(int64)
  FN_NET_IPV4_TO_INT64 = 1715;        // net.ipv4_to_int64(bytes)

  // Hashing functions.
  FN_MD5_BYTES = 1900;      // md5(bytes)
  FN_MD5_STRING = 1901;     // md5(string)
  FN_SHA1_BYTES = 1902;     // sha1(bytes)
  FN_SHA1_STRING = 1903;    // sha1(string)
  FN_SHA256_BYTES = 1904;   // sha256(bytes)
  FN_SHA256_STRING = 1905;  // sha256(string)
  FN_SHA512_BYTES = 1906;   // sha512(bytes)
  FN_SHA512_STRING = 1907;  // sha512(string)

  // Fingerprinting functions
  FN_FARM_FINGERPRINT_BYTES = 1908;   // farm_fingerprint(bytes) -> int64
  FN_FARM_FINGERPRINT_STRING = 1909;  // farm_fingerprint(string) -> int64

  // Keyset management, encryption, and decryption functions
  // ((broken link)). Requires that FEATURE_ENCRYPTION is enabled.
  FN_KEYS_NEW_KEYSET = 1910;  // keys.new_keyset(string)
  // keys.add_key_from_raw_bytes(bytes, string, bytes)
  FN_KEYS_ADD_KEY_FROM_RAW_BYTES = 1911;
  FN_KEYS_ROTATE_KEYSET = 1912;     // keys.rotate_keyset(bytes, string)
  FN_KEYS_KEYSET_LENGTH = 1913;     // keys.keyset_length(bytes)
  FN_KEYS_KEYSET_TO_JSON = 1914;    // keys.keyset_to_json(bytes)
  FN_KEYS_KEYSET_FROM_JSON = 1915;  // keys.keyset_from_json(string)
  FN_AEAD_ENCRYPT_STRING = 1916;    // aead.encrypt(bytes, string, string)
  FN_AEAD_ENCRYPT_BYTES = 1917;     // aead.encrypt(bytes, bytes, bytes)
  FN_AEAD_DECRYPT_STRING = 1918;    // aead.decrypt_string(bytes, bytes, string)
  FN_AEAD_DECRYPT_BYTES = 1919;     // aead.decrypt_bytes(bytes, bytes, bytes)
  FN_KMS_ENCRYPT_STRING = 1920;     // kms.encrypt(string, string)
  FN_KMS_ENCRYPT_BYTES = 1921;      // kms.encrypt(string, bytes)
  FN_KMS_DECRYPT_STRING = 1922;     // kms.decrypt_string(string, bytes)
  FN_KMS_DECRYPT_BYTES = 1923;      // kms.decrypt_bytes(string, bytes)
  // aead.envelope_encrypt(string, bytes, string, string)
  FN_AEAD_ENVELOPE_ENCRYPT_STRING = 1924;
  // aead.envelope_encrypt(string, bytes, bytes, bytes)
  FN_AEAD_ENVELOPE_ENCRYPT_BYTES = 1925;
  // aead.envelope_decrypt_string(string, bytes, bytes, string)
  FN_AEAD_ENVELOPE_DECRYPT_STRING = 1926;
  // aead.envelope_decrypt_bytes(string, bytes, bytes, bytes)
  FN_AEAD_ENVELOPE_DECRYPT_BYTES = 1927;

  // ST_ family of functions (Geography related - (broken link))
  // Constructors
  FN_ST_GEOG_POINT = 2000;
  FN_ST_MAKE_LINE = 2001;
  FN_ST_MAKE_LINE_ARRAY = 2002;
  FN_ST_MAKE_POLYGON = 2003;
  FN_ST_MAKE_POLYGON_ORIENTED = 2004;

  // Transformations
  FN_ST_INTERSECTION = 2007;
  FN_ST_UNION = 2008;
  FN_ST_UNION_ARRAY = 2009;
  FN_ST_DIFFERENCE = 2010;
  FN_ST_UNARY_UNION = 2011;
  FN_ST_CENTROID = 2012;
  FN_ST_BUFFER = 2013;
  FN_ST_BUFFER_WITH_TOLERANCE = 2014;
  FN_ST_SIMPLIFY = 2015;
  FN_ST_SNAP_TO_GRID = 2016;
  FN_ST_CLOSEST_POINT = 2017;
  FN_ST_BOUNDARY = 2018;
  FN_ST_CONVEXHULL = 2065;

  // Predicates
  FN_ST_EQUALS = 2020;
  FN_ST_INTERSECTS = 2021;
  FN_ST_CONTAINS = 2022;
  FN_ST_COVERS = 2023;
  FN_ST_DISJOINT = 2024;
  FN_ST_INTERSECTS_BOX = 2025;
  FN_ST_DWITHIN = 2026;
  FN_ST_WITHIN = 2027;
  FN_ST_COVEREDBY = 2028;
  FN_ST_TOUCHES = 2029;

  // Accessors
  FN_ST_IS_EMPTY = 2030;
  FN_ST_IS_COLLECTION = 2031;
  FN_ST_DIMENSION = 2032;
  FN_ST_NUM_POINTS = 2033;
  FN_ST_DUMP = 2064;
  FN_ST_POINT_N = 2075;
  FN_ST_START_POINT = 2076;
  FN_ST_END_POINT = 2077;

  // Measures
  FN_ST_LENGTH = 2040;
  FN_ST_PERIMETER = 2041;
  FN_ST_AREA = 2042;
  FN_ST_DISTANCE = 2043;
  FN_ST_MAX_DISTANCE = 2044;

  // Parsers/formatters
  FN_ST_GEOG_FROM_TEXT = 2050;
  FN_ST_GEOG_FROM_TEXT_EXT = 2060;
  FN_ST_GEOG_FROM_KML = 2051;
  FN_ST_GEOG_FROM_GEO_JSON = 2052;
  FN_ST_GEOG_FROM_GEO_JSON_EXT = 2068;
  FN_ST_GEOG_FROM_WKB = 2056;
  FN_ST_GEOG_FROM_WKB_HEX = 2072;
  FN_ST_GEOG_FROM_STRING = 2073;
  FN_ST_GEOG_FROM_BYTES = 2074;
  FN_ST_AS_TEXT = 2053;
  FN_ST_AS_KML = 2054;
  FN_ST_AS_GEO_JSON = 2055;
  FN_ST_AS_BINARY = 2057;
  FN_ST_GEOHASH = 2058;
  FN_ST_GEOG_POINT_FROM_GEOHASH = 2059;

  // Aggregate functions
  FN_ST_UNION_AGG = 2061;
  FN_ST_ACCUM = 2062;
  FN_ST_CENTROID_AGG = 2063;
  FN_ST_NEAREST_NEIGHBORS = 2067;

  // Other geography functions
  FN_ST_X = 2070;
  FN_ST_Y = 2071;

  FN_ST_CLUSTERDBSCAN = 2066;

  // Differentially private anonymization functions
  // ((broken link)).
  FN_ANON_COUNT = 2200;
  FN_ANON_COUNT_STAR = 2201;
  FN_ANON_SUM_INT64 = 2202;
  FN_ANON_SUM_UINT64 = 2203;
  FN_ANON_SUM_DOUBLE = 2204;
  FN_ANON_SUM_NUMERIC = 2205;
  FN_ANON_AVG_DOUBLE = 2206;
  FN_ANON_AVG_NUMERIC = 2207;

  // Array and proto map functions.
  FN_FLATTEN = 2500;  // flatten(array path) -> array
  // TODO: Move these to the array function section (2500-2599).
  FN_ARRAY_AT_OFFSET = 234;   // $array_at_offset
  FN_ARRAY_AT_ORDINAL = 235;  // $array_at_ordinal
  FN_ARRAY_CONCAT = 236;      // array_concat(repeated array) -> array
  FN_ARRAY_CONCAT_OP = 260;   // array_concat(array, array) -> array
  FN_ARRAY_LENGTH = 220;      // array_length(array) -> int64
  // array_to_string(array, bytes[, bytes]) -> bytes
  FN_ARRAY_TO_BYTES = 238;
  // array_to_string(array, string[, string]) -> string
  FN_ARRAY_TO_STRING = 237;
  FN_MAKE_ARRAY = 218;              // $make_array
  FN_SAFE_ARRAY_AT_OFFSET = 239;    // $safe_array_at_offset
  FN_SAFE_ARRAY_AT_ORDINAL = 240;   // $safe_array_at_ordinal
  FN_ARRAY_IS_DISTINCT = 2501;      // array_is_distinct(array) -> bool
  FN_PROTO_MAP_AT_KEY = 2502;       // $proto_map_at_key
  FN_SAFE_PROTO_MAP_AT_KEY = 2503;  // $safe_proto_map_at_key
  FN_MODIFY_MAP = 2510;             // modify_map(map [, key, value]+) -> map

  FN_ARRAY_FILTER = 2504;             // ARRAY_FILTER(array, lambda) -> array
  FN_ARRAY_FILTER_WITH_INDEX = 2505;  // ARRAY_FILTER(array, lambda) -> array
  FN_ARRAY_TRANSFORM = 2506;          // ARRAY_TRANSFORM(array, lambda) -> array
  FN_ARRAY_TRANSFORM_WITH_INDEX =
      2507;                // ARRAY_TRANSFORM(array, lambda) -> array
  FN_CONTAINS_KEY = 2508;  // contains_key(map, key) -> bool
}
