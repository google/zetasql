# CORRESPONDING
[default enabled_ast_rewrites=DEFAULTS]
[language_features={{|V_1_4_CORRESPONDING|V_1_4_CORRESPONDING_FULL}}]
SELECT 1
UNION ALL CORRESPONDING
SELECT 2
--
ALTERNATION GROUP: <empty>
--
ERROR: CORRESPONDING for set operations is not supported [at 2:11]
UNION ALL CORRESPONDING
          ^
--
ALTERNATION GROUPS:
    V_1_4_CORRESPONDING
    V_1_4_CORRESPONDING_FULL
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT 1
^
==

# CORRESPONDING in multiple operations.
[language_features={{|V_1_4_CORRESPONDING|V_1_4_CORRESPONDING_FULL}}]
SELECT 1
UNION ALL
SELECT 2
UNION ALL CORRESPONDING
SELECT 3
--
ALTERNATION GROUP: <empty>
--
ERROR: CORRESPONDING for set operations is not supported [at 4:11]
UNION ALL CORRESPONDING
          ^
--
ALTERNATION GROUPS:
    V_1_4_CORRESPONDING
    V_1_4_CORRESPONDING_FULL
--
ERROR: Different column match modes cannot be used in the same query without using parentheses for grouping [at 4:11]
UNION ALL CORRESPONDING
          ^
==

# CORRESPONDING BY
[language_features={{|V_1_4_CORRESPONDING|V_1_4_CORRESPONDING_FULL}}]
SELECT 1
UNION ALL CORRESPONDING BY (a, b, c)
SELECT 2
--
ALTERNATION GROUPS:
    <empty>
    V_1_4_CORRESPONDING
--
ERROR: CORRESPONDING BY for set operations is not supported [at 2:11]
UNION ALL CORRESPONDING BY (a, b, c)
          ^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING_FULL
--
ERROR: The identifier a from the CORRESPONDING BY list does not appear in the input query 1. All columns in the BY list must appear in each input query unless FULL CORRESPONDING or LEFT CORRESPONDING is specified [at 2:29]
UNION ALL CORRESPONDING BY (a, b, c)
                            ^
==

# CORRESPONDING BY in multiple operations
[language_features={{|V_1_4_CORRESPONDING|V_1_4_CORRESPONDING_FULL}}]
SELECT 1
UNION ALL
SELECT 2
UNION ALL CORRESPONDING BY (a, b, c)
SELECT 3
--
ALTERNATION GROUPS:
    <empty>
    V_1_4_CORRESPONDING
--
ERROR: CORRESPONDING BY for set operations is not supported [at 4:11]
UNION ALL CORRESPONDING BY (a, b, c)
          ^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING_FULL
--
ERROR: Different column match modes cannot be used in the same query without using parentheses for grouping [at 4:11]
UNION ALL CORRESPONDING BY (a, b, c)
          ^
==

# STRICT without CORRESPONDING
[language_features={{|V_1_4_CORRESPONDING|V_1_4_CORRESPONDING_FULL}}]
SELECT 1
UNION DISTINCT STRICT
SELECT 2
--
ALTERNATION GROUPS:
    <empty>
    V_1_4_CORRESPONDING
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 2:16]
UNION DISTINCT STRICT
               ^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING_FULL
--
ERROR: STRICT in set operations cannot be used without CORRESPONDING [at 2:16]
UNION DISTINCT STRICT
               ^
==

# STRICT without CORRESPONDING in multiple set operations
[language_features={{|V_1_4_CORRESPONDING|V_1_4_CORRESPONDING_FULL}}]
SELECT 1
UNION DISTINCT
SELECT 2
UNION DISTINCT STRICT
SELECT 3
--
ALTERNATION GROUPS:
    <empty>
    V_1_4_CORRESPONDING
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 4:16]
UNION DISTINCT STRICT
               ^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING_FULL
--
ERROR: STRICT in set operations cannot be used without CORRESPONDING [at 4:16]
UNION DISTINCT STRICT
               ^
==

# FULL without CORRESPONDING
[language_features={{|V_1_4_CORRESPONDING|V_1_4_CORRESPONDING_FULL}}]
SELECT 1
FULL EXCEPT ALL
SELECT 2
--
ALTERNATION GROUPS:
    <empty>
    V_1_4_CORRESPONDING
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 2:1]
FULL EXCEPT ALL
^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING_FULL
--
ERROR: FULL in set operations cannot be used without CORRESPONDING [at 2:1]
FULL EXCEPT ALL
^
==

# FULL without CORRESPONDING in multiple operations
[language_features={{|V_1_4_CORRESPONDING|V_1_4_CORRESPONDING_FULL}}]
SELECT 1
EXCEPT ALL
SELECT 2
FULL EXCEPT ALL
SELECT 3
--
ALTERNATION GROUPS:
    <empty>
    V_1_4_CORRESPONDING
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 4:1]
FULL EXCEPT ALL
^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING_FULL
--
ERROR: FULL in set operations cannot be used without CORRESPONDING [at 4:1]
FULL EXCEPT ALL
^
==

# LEFT without CORRESPONDING
[language_features={{|V_1_4_CORRESPONDING|V_1_4_CORRESPONDING_FULL}}]
SELECT 1
LEFT EXCEPT ALL
SELECT 2
--
ALTERNATION GROUPS:
    <empty>
    V_1_4_CORRESPONDING
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 2:1]
LEFT EXCEPT ALL
^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING_FULL
--
ERROR: LEFT in set operations cannot be used without CORRESPONDING [at 2:1]
LEFT EXCEPT ALL
^
==

# LEFT without CORRESPONDING in multiple set operations
[language_features={{|V_1_4_CORRESPONDING|V_1_4_CORRESPONDING_FULL}}]
SELECT 1
EXCEPT ALL
SELECT 2
LEFT EXCEPT ALL
SELECT 3
--
ALTERNATION GROUPS:
    <empty>
    V_1_4_CORRESPONDING
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 4:1]
LEFT EXCEPT ALL
^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING_FULL
--
ERROR: LEFT in set operations cannot be used without CORRESPONDING [at 4:1]
LEFT EXCEPT ALL
^
==

[language_features={{V_1_4_CORRESPONDING|V_1_4_CORRESPONDING_FULL}}]
SELECT 1
{{FULL|LEFT}} UNION ALL CORRESPONDING
SELECT 2
--
ALTERNATION GROUP: V_1_4_CORRESPONDING,FULL
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 2:1]
FULL UNION ALL CORRESPONDING
^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING,LEFT
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 2:1]
LEFT UNION ALL CORRESPONDING
^
--
ALTERNATION GROUPS:
    V_1_4_CORRESPONDING_FULL,FULL
    V_1_4_CORRESPONDING_FULL,LEFT
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT 1
^
==

[language_features={{V_1_4_CORRESPONDING|V_1_4_CORRESPONDING_FULL}}]
SELECT 1
UNION ALL STRICT CORRESPONDING
SELECT 2
--
ALTERNATION GROUP: V_1_4_CORRESPONDING
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 2:11]
UNION ALL STRICT CORRESPONDING
          ^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING_FULL
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT 1
^
==

[default language_features={{V_1_4_CORRESPONDING|V_1_4_CORRESPONDING_FULL}}]
# CORRESPONDING: same columns at same index.
SELECT 1 AS col1, 2 AS col2
EXCEPT DISTINCT CORRESPONDING
SELECT 3 AS col1, 4 AS col2
--
QueryStmt
+-output_column_list=
| +-$except_distinct.col1#5 AS col1 [INT64]
| +-$except_distinct.col2#6 AS col2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$except_distinct.[col1#5, col2#6]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$except_distinct1.[col1#1, col2#2]
    | | |   +-expr_list=
    | | |   | +-col1#1 := Literal(type=INT64, value=1)
    | | |   | +-col2#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$except_distinct1.[col1#1, col2#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$except_distinct2.[col1#3, col2#4]
    |   |   +-expr_list=
    |   |   | +-col1#3 := Literal(type=INT64, value=3)
    |   |   | +-col2#4 := Literal(type=INT64, value=4)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$except_distinct2.[col1#3, col2#4]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: same columns at different index, the output column order is
# determined by the first query.
SELECT 1 AS col1, 2 AS col2
INTERSECT ALL CORRESPONDING
SELECT 3 AS col2, 4 AS col1
--
QueryStmt
+-output_column_list=
| +-$intersect_all.col1#5 AS col1 [INT64]
| +-$intersect_all.col2#6 AS col2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[col1#5, col2#6]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1.[col1#1, col2#2]
    | | |   +-expr_list=
    | | |   | +-col1#1 := Literal(type=INT64, value=1)
    | | |   | +-col2#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$intersect_all1.[col1#1, col2#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_all2.[col1#4, col2#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$intersect_all2.[col2#3, col1#4]
    |   |       +-expr_list=
    |   |       | +-col2#3 := Literal(type=INT64, value=3)
    |   |       | +-col1#4 := Literal(type=INT64, value=4)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$intersect_all2.[col1#4, col2#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: extra columns are ignored.
SELECT 1 AS col, 2 AS extra_col_1
UNION ALL CORRESPONDING
SELECT 3 AS extra_col_2, 4 AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#5 AS col [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#1]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all1.[col#1, extra_col_1#2]
    | | |       +-expr_list=
    | | |       | +-col#1 := Literal(type=INT64, value=1)
    | | |       | +-extra_col_1#2 := Literal(type=INT64, value=2)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#4]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[extra_col_2#3, col#4]
    |   |       +-expr_list=
    |   |       | +-extra_col_2#3 := Literal(type=INT64, value=3)
    |   |       | +-col#4 := Literal(type=INT64, value=4)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#4]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: column name comparison is case-insensitive.
SELECT 1 AS cOl1, 2 AS CoL2
INTERSECT ALL CORRESPONDING
SELECT 3 AS Col2, 4 AS cOL1
--
QueryStmt
+-output_column_list=
| +-$intersect_all.cOl1#5 AS cOl1 [INT64]
| +-$intersect_all.CoL2#6 AS CoL2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[cOl1#5, CoL2#6]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1.[cOl1#1, CoL2#2]
    | | |   +-expr_list=
    | | |   | +-cOl1#1 := Literal(type=INT64, value=1)
    | | |   | +-CoL2#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$intersect_all1.[cOl1#1, CoL2#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_all2.[cOL1#4, Col2#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$intersect_all2.[Col2#3, cOL1#4]
    |   |       +-expr_list=
    |   |       | +-Col2#3 := Literal(type=INT64, value=3)
    |   |       | +-cOL1#4 := Literal(type=INT64, value=4)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$intersect_all2.[cOL1#4, Col2#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: duplicate columns are not allowed.
SELECT 1 AS col1, 2 AS col2
EXCEPT DISTINCT CORRESPONDING
SELECT 3 AS col2, 4 AS col2
--
ERROR: Duplicate columns found when using CORRESPONDING in set operations: col2 in query 2 [at 3:1]
SELECT 3 AS col2, 4 AS col2
^
==

# CORRESPONDING: duplicate columns are not allowed (case-insensitive).
SELECT 1 AS col1, 2 AS COL1
EXCEPT DISTINCT CORRESPONDING
SELECT 3 AS col2, 4 AS col3
--
ERROR: Duplicate columns found when using CORRESPONDING in set operations: COL1 in query 1 [at 1:1]
SELECT 1 AS col1, 2 AS COL1
^
==

# CORRESPONDING: duplicate columns in SELECT *.
SELECT *, 1 AS c
FROM (
  SELECT 1 AS a, 1 AS a
)
UNION ALL CORRESPONDING
SELECT 1 AS c
--
ERROR: Duplicate columns found when using CORRESPONDING in set operations: a in query 1 [at 1:1]
SELECT *, 1 AS c
^
==

# CORRESPONDING: duplicate columns with SELECT *: '*' expands to multiple
# columns, one of which has the same name as a column outside '*'. Error
# location should be the start of the query.
SELECT *, 1 AS a
FROM (
  SELECT 1 AS a, 2 AS b
)
UNION ALL CORRESPONDING
SELECT 1 AS a
--
ERROR: Duplicate columns found when using CORRESPONDING in set operations: a in query 1 [at 1:1]
SELECT *, 1 AS a
^
==

# CORRESPONDING: no common columns.
SELECT 1 AS col1, 2 AS col2
UNION DISTINCT CORRESPONDING
SELECT 3 AS col3, 4 AS col4
--
ERROR: Queries of the set operation using CORRESPONDING do not have any columns in common [at 2:1]
UNION DISTINCT CORRESPONDING
^
==

# CORRESPONDING: value table not allowed.
SELECT AS STRUCT 1 a, 2 b
UNION ALL CORRESPONDING
SELECT AS STRUCT 3 c, 4 d
--
ERROR: Value table type not allowed in set operations when CORRESPONDING is used: query 1 [at 2:1]
UNION ALL CORRESPONDING
^
==

# CORRESPONDING: anonymous columns are not allowed.
SELECT 1, 2
UNION ALL CORRESPONDING
SELECT 4, 5
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT 1, 2
^
==

# CORRESPONDING: SELECT * with anonymous columns. Error is reported at the start
# of the query because we cannot always find the ast location of a resolved
# column.
SELECT 1, *
FROM (
  SELECT 1 AS a, 2 AS b
)
UNION ALL CORRESPONDING
SELECT 1 AS a
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT 1, *
^
==

# CORRESPONDING: SELECT * with anonymous columns.
SELECT *, 1
FROM (
  SELECT 1 AS a
)
UNION ALL CORRESPONDING
SELECT 1 AS a
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 2 [at 1:1]
SELECT *, 1
^
==

# CORRESPONDING: SELECT * expands to containing anonymous columns.
# Error is reported at the start of the query.
SELECT *, 1 AS a
FROM (
  SELECT 1, 2 AS c
)
UNION ALL CORRESPONDING
SELECT 1 AS a
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT *, 1 AS a
^
==

# CORRESPONDING: same column with different alias within a query is allowed.
SELECT `int32` AS col1, `int32` AS col2
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `float` AS col2, `float` AS col1
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#39 AS col1 [DOUBLE]
| +-$union_all.col2#40 AS col2 [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col1#39, col2#40]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1_cast.[int32#41, int32#42]
    | | |   +-expr_list=
    | | |   | +-int32#41 :=
    | | |   | | +-Cast(INT32 -> DOUBLE)
    | | |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   | +-int32#42 :=
    | | |   |   +-Cast(INT32 -> DOUBLE)
    | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int32#1, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    | | +-output_column_list=$union_all1_cast.[int32#41, int32#42]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2_cast.[float#44, float#43]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2_cast.[float#43, float#44]
    |   |       +-expr_list=
    |   |       | +-float#43 :=
    |   |       | | +-Cast(FLOAT -> DOUBLE)
    |   |       | |   +-ColumnRef(type=FLOAT, column=SimpleTypes.float#27)
    |   |       | +-float#44 :=
    |   |       |   +-Cast(FLOAT -> DOUBLE)
    |   |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#27)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[float#27, float#27]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[SimpleTypes.float#27], table=SimpleTypes, column_index_list=[7])
    |   +-output_column_list=$union_all2_cast.[float#44, float#43]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: same column with and without alias.
SELECT `int32` AS col, `int32` FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `float`, `float` AS col FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.col#39 AS col [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#39]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.int32#40]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1_cast.int32#40, SimpleTypes.int32#1]
    | | |       +-expr_list=
    | | |       | +-int32#40 :=
    | | |       |   +-Cast(INT32 -> DOUBLE)
    | | |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=SimpleTypes.[int32#1, int32#1]
    | | |           +-input_scan=
    | | |             +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    | | +-output_column_list=[$union_all1_cast.int32#40]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.float#41]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[SimpleTypes.float#27, $union_all2_cast.float#41]
    |   |       +-expr_list=
    |   |       | +-float#41 :=
    |   |       |   +-Cast(FLOAT -> DOUBLE)
    |   |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#27)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[float#27, float#27]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[SimpleTypes.float#27], table=SimpleTypes, column_index_list=[7])
    |   +-output_column_list=[$union_all2_cast.float#41]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Nested operations.
SELECT * FROM
(
  SELECT 'abc' AS col, 'bcd' AS extra_col
  UNION ALL CORRESPONDING
  SELECT 'def' AS col
)
--
QueryStmt
+-output_column_list=
| +-$union_all.col#4 AS col [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$union_all.col#4]
    +-input_scan=
      +-SetOperationScan
        +-column_list=[$union_all.col#4]
        +-op_type=UNION_ALL
        +-input_item_list=
        | +-SetOperationItem
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$union_all1.col#1]
        | | |   +-node_source="resolver_set_operation_corresponding"
        | | |   +-input_scan=
        | | |     +-ProjectScan
        | | |       +-column_list=$union_all1.[col#1, extra_col#2]
        | | |       +-expr_list=
        | | |       | +-col#1 := Literal(type=STRING, value="abc")
        | | |       | +-extra_col#2 := Literal(type=STRING, value="bcd")
        | | |       +-input_scan=
        | | |         +-SingleRowScan
        | | +-output_column_list=[$union_all1.col#1]
        | +-SetOperationItem
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$union_all2.col#3]
        |   |   +-expr_list=
        |   |   | +-col#3 := Literal(type=STRING, value="def")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-output_column_list=[$union_all2.col#3]
        +-column_match_mode=CORRESPONDING
        +-column_propagation_mode=INNER
==

# CORRESPONDING: no common supertype.
select 1 AS col
union all CORRESPONDING
select 'abc' AS col
--
ERROR: Column col in UNION ALL has incompatible types: INT64, STRING [at 3:1]
select 'abc' AS col
^
==

# CORRESPONDING: different (non-literal) types coerce to a common supertype.
# We wrap an extra ProjectScan around the first query to coerce it to double.
SELECT 'a' a, 1 + 1 v1
UNION ALL CORRESPONDING
SELECT 'a' b, 1.0 + 1.0 v1
--
QueryStmt
+-output_column_list=
| +-$union_all.v1#5 AS v1 [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.v1#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.v1#6]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1.a#1, $union_all1_cast.v1#6]
    | | |       +-expr_list=
    | | |       | +-v1#6 :=
    | | |       |   +-Cast(INT64 -> DOUBLE)
    | | |       |     +-ColumnRef(type=INT64, column=$union_all1.v1#2)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=$union_all1.[a#1, v1#2]
    | | |           +-expr_list=
    | | |           | +-a#1 := Literal(type=STRING, value="a")
    | | |           | +-v1#2 :=
    | | |           |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | | |           |     +-Literal(type=INT64, value=1)
    | | |           |     +-Literal(type=INT64, value=1)
    | | |           +-input_scan=
    | | |             +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.v1#6]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.v1#4]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[b#3, v1#4]
    |   |       +-expr_list=
    |   |       | +-b#3 := Literal(type=STRING, value="a")
    |   |       | +-v1#4 :=
    |   |       |   +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
    |   |       |     +-Literal(type=DOUBLE, value=1)
    |   |       |     +-Literal(type=DOUBLE, value=1)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2.v1#4]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Extra columns are omitted from table scan.
SELECT `uint32`, `float`
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `uint32`, `json`
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `json`, `uint32`
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.uint32#58 AS uint32 [UINT32]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.uint32#58]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.uint32#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[uint32#3, float#8]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[uint32#3, float#8], table=SimpleTypes, column_index_list=[2, 7])
    | | +-output_column_list=[SimpleTypes.uint32#3]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.uint32#22]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[uint32#22, json#37]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[uint32#22, json#37], table=SimpleTypes, column_index_list=[2, 17])
    | | +-output_column_list=[SimpleTypes.uint32#22]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[SimpleTypes.uint32#41]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[json#56, uint32#41]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[uint32#41, json#56], table=SimpleTypes, column_index_list=[2, 17])
    |   +-output_column_list=[SimpleTypes.uint32#41]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Set operation with CORRESPONDING as an input item for another
# set operation: CORREPSPONDING in BY_POSITION.
(
  SELECT int32, int64, float FROM SimpleTypes
  UNION ALL CORRESPONDING
  SELECT int64, int32 FROM SimpleTypes
)
UNION ALL
SELECT int32, int32 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int32#60 AS int32 [INT32]
| +-$union_all.int64#61 AS int64 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int32#60, int64#61]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-SetOperationScan
      | |   +-column_list=$union_all.[int32#39, int64#40]
      | |   +-op_type=UNION_ALL
      | |   +-input_item_list=
      | |   | +-SetOperationItem
      | |   | | +-scan=
      | |   | | | +-ProjectScan
      | |   | | |   +-column_list=SimpleTypes.[int32#1, int64#2]
      | |   | | |   +-node_source="resolver_set_operation_corresponding"
      | |   | | |   +-input_scan=
      | |   | | |     +-ProjectScan
      | |   | | |       +-column_list=SimpleTypes.[int32#1, int64#2, float#8]
      | |   | | |       +-input_scan=
      | |   | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, float#8], table=SimpleTypes, column_index_list=[0, 1, 7])
      | |   | | +-output_column_list=SimpleTypes.[int32#1, int64#2]
      | |   | +-SetOperationItem
      | |   |   +-scan=
      | |   |   | +-ProjectScan
      | |   |   |   +-column_list=SimpleTypes.[int32#20, int64#21]
      | |   |   |   +-node_source="resolver_set_operation_corresponding"
      | |   |   |   +-input_scan=
      | |   |   |     +-ProjectScan
      | |   |   |       +-column_list=SimpleTypes.[int64#21, int32#20]
      | |   |   |       +-input_scan=
      | |   |   |         +-TableScan(column_list=SimpleTypes.[int32#20, int64#21], table=SimpleTypes, column_index_list=[0, 1])
      | |   |   +-output_column_list=SimpleTypes.[int32#20, int64#21]
      | |   +-column_match_mode=CORRESPONDING
      | |   +-column_propagation_mode=INNER
      | +-output_column_list=$union_all.[int32#39, int64#40]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[SimpleTypes.int32#41, $union_all2_cast.int32#62]
        |   +-expr_list=
        |   | +-int32#62 :=
        |   |   +-Cast(INT32 -> INT64)
        |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#41)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=SimpleTypes.[int32#41, int32#41]
        |       +-input_scan=
        |         +-TableScan(column_list=[SimpleTypes.int32#41], table=SimpleTypes, column_index_list=[0])
        +-output_column_list=[SimpleTypes.int32#41, $union_all2_cast.int32#62]
==

# CORRESPONDING: Set operation with CORRESPONDING as an input item for another
# set operation: CORREPSPONDING in CORRESPONDING.
(
  SELECT int32, int64, float FROM SimpleTypes
  UNION ALL CORRESPONDING
  SELECT int64, int32 FROM SimpleTypes
)
UNION ALL CORRESPONDING
SELECT int32, float FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int32#60 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.int32#60]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all.int32#39]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-SetOperationScan
    | | |       +-column_list=$union_all.[int32#39, int64#40]
    | | |       +-op_type=UNION_ALL
    | | |       +-input_item_list=
    | | |       | +-SetOperationItem
    | | |       | | +-scan=
    | | |       | | | +-ProjectScan
    | | |       | | |   +-column_list=SimpleTypes.[int32#1, int64#2]
    | | |       | | |   +-node_source="resolver_set_operation_corresponding"
    | | |       | | |   +-input_scan=
    | | |       | | |     +-ProjectScan
    | | |       | | |       +-column_list=SimpleTypes.[int32#1, int64#2, float#8]
    | | |       | | |       +-input_scan=
    | | |       | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, float#8], table=SimpleTypes, column_index_list=[0, 1, 7])
    | | |       | | +-output_column_list=SimpleTypes.[int32#1, int64#2]
    | | |       | +-SetOperationItem
    | | |       |   +-scan=
    | | |       |   | +-ProjectScan
    | | |       |   |   +-column_list=SimpleTypes.[int32#20, int64#21]
    | | |       |   |   +-node_source="resolver_set_operation_corresponding"
    | | |       |   |   +-input_scan=
    | | |       |   |     +-ProjectScan
    | | |       |   |       +-column_list=SimpleTypes.[int64#21, int32#20]
    | | |       |   |       +-input_scan=
    | | |       |   |         +-TableScan(column_list=SimpleTypes.[int32#20, int64#21], table=SimpleTypes, column_index_list=[0, 1])
    | | |       |   +-output_column_list=SimpleTypes.[int32#20, int64#21]
    | | |       +-column_match_mode=CORRESPONDING
    | | |       +-column_propagation_mode=INNER
    | | +-output_column_list=[$union_all.int32#39]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[SimpleTypes.int32#41]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#41, float#48]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#41, float#48], table=SimpleTypes, column_index_list=[0, 7])
    |   +-output_column_list=[SimpleTypes.int32#41]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Set operation as an input item for another set operation:
# BY_POSITION in CORRESPONDING.
(
  SELECT int32, int64, float FROM SimpleTypes
  UNION ALL
  SELECT int64, int32, int64 FROM SimpleTypes
)
UNION ALL CORRESPONDING
SELECT int32, float FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int32#65 AS int32 [INT64]
| +-$union_all.float#66 AS float [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int32#65, float#66]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all.[int32#39, float#41]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-SetOperationScan
    | | |       +-column_list=$union_all.[int32#39, int64#40, float#41]
    | | |       +-op_type=UNION_ALL
    | | |       +-input_item_list=
    | | |         +-SetOperationItem
    | | |         | +-scan=
    | | |         | | +-ProjectScan
    | | |         | |   +-column_list=[$union_all1_cast.int32#42, SimpleTypes.int64#2, $union_all1_cast.float#43]
    | | |         | |   +-expr_list=
    | | |         | |   | +-int32#42 :=
    | | |         | |   | | +-Cast(INT32 -> INT64)
    | | |         | |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |         | |   | +-float#43 :=
    | | |         | |   |   +-Cast(FLOAT -> DOUBLE)
    | | |         | |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
    | | |         | |   +-input_scan=
    | | |         | |     +-ProjectScan
    | | |         | |       +-column_list=SimpleTypes.[int32#1, int64#2, float#8]
    | | |         | |       +-input_scan=
    | | |         | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, float#8], table=SimpleTypes, column_index_list=[0, 1, 7])
    | | |         | +-output_column_list=[$union_all1_cast.int32#42, SimpleTypes.int64#2, $union_all1_cast.float#43]
    | | |         +-SetOperationItem
    | | |           +-scan=
    | | |           | +-ProjectScan
    | | |           |   +-column_list=[SimpleTypes.int64#21, $union_all2_cast.int32#44, $union_all2_cast.int64#45]
    | | |           |   +-expr_list=
    | | |           |   | +-int32#44 :=
    | | |           |   | | +-Cast(INT32 -> INT64)
    | | |           |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    | | |           |   | +-int64#45 :=
    | | |           |   |   +-Cast(INT64 -> DOUBLE)
    | | |           |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#21)
    | | |           |   +-input_scan=
    | | |           |     +-ProjectScan
    | | |           |       +-column_list=SimpleTypes.[int64#21, int32#20, int64#21]
    | | |           |       +-input_scan=
    | | |           |         +-TableScan(column_list=SimpleTypes.[int32#20, int64#21], table=SimpleTypes, column_index_list=[0, 1])
    | | |           +-output_column_list=[SimpleTypes.int64#21, $union_all2_cast.int32#44, $union_all2_cast.int64#45]
    | | +-output_column_list=$union_all.[int32#39, float#41]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2_cast.[int32#67, float#68]
    |   |   +-expr_list=
    |   |   | +-int32#67 :=
    |   |   | | +-Cast(INT32 -> INT64)
    |   |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#46)
    |   |   | +-float#68 :=
    |   |   |   +-Cast(FLOAT -> DOUBLE)
    |   |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#53)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#46, float#53]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#46, float#53], table=SimpleTypes, column_index_list=[0, 7])
    |   +-output_column_list=$union_all2_cast.[int32#67, float#68]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: The edge case of SELECT DISTINCT is handled correctly despite
# the missing ProjectScan issue mentioned in b/36095506.
SELECT DISTINCT a AS col1, b AS col2, a AS col3
FROM (
  SELECT 1 AS a, 2 AS b
)
UNION ALL CORRESPONDING
SELECT 1 AS col3, 1 AS col1, 2 AS col2
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#8 AS col1 [INT64]
| +-$union_all.col2#9 AS col2 [INT64]
| +-$union_all.col3#10 AS col3 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col1#8, col2#9, col3#10]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$distinct.[a#3, b#4, a#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-AggregateScan
    | | |       +-column_list=$distinct.[a#3, b#4]
    | | |       +-input_scan=
    | | |       | +-ProjectScan
    | | |       |   +-column_list=$subquery1.[a#1, b#2]
    | | |       |   +-expr_list=
    | | |       |   | +-a#1 := Literal(type=INT64, value=1)
    | | |       |   | +-b#2 := Literal(type=INT64, value=2)
    | | |       |   +-input_scan=
    | | |       |     +-SingleRowScan
    | | |       +-group_by_list=
    | | |         +-a#3 := ColumnRef(type=INT64, column=$subquery1.a#1)
    | | |         +-b#4 := ColumnRef(type=INT64, column=$subquery1.b#2)
    | | +-output_column_list=$distinct.[a#3, b#4, a#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[col1#6, col2#7, col3#5]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[col3#5, col1#6, col2#7]
    |   |       +-expr_list=
    |   |       | +-col3#5 := Literal(type=INT64, value=1)
    |   |       | +-col1#6 := Literal(type=INT64, value=1)
    |   |       | +-col2#7 := Literal(type=INT64, value=2)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$union_all2.[col1#6, col2#7, col3#5]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union two of the same proto and proto + string literal.
select KitchenSink AS col, KitchenSink from TestTable
union all CORRESPONDING
select KitchenSink, "int64_key_1: 1, int64_key_2: 2" AS col from TestTable
--
QueryStmt
+-output_column_list=
| +-$union_all.col#8 AS col [PROTO<zetasql_test__.KitchenSinkPB>]
| +-$union_all.KitchenSink#9 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col#8, KitchenSink#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=TestTable.[KitchenSink#3, KitchenSink#3]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
    | | +-output_column_list=TestTable.[KitchenSink#3, KitchenSink#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.col#10, TestTable.KitchenSink#6]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[TestTable.KitchenSink#6, $union_all2_cast.col#10]
    |   |       +-expr_list=
    |   |       | +-col#10 := Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={int64_key_1: 1 int64_key_2: 2})
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=[TestTable.KitchenSink#6, $union_all2.col#7]
    |   |           +-expr_list=
    |   |           | +-col#7 := Literal(type=STRING, value="int64_key_1: 1, int64_key_2: 2")
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[TestTable.KitchenSink#6], table=TestTable, column_index_list=[2])
    |   +-output_column_list=[$union_all2_cast.col#10, TestTable.KitchenSink#6]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union two different protos.
select 1 AS extra_1, KitchenSink.message_with_nulls AS col from TestTable
union all CORRESPONDING
select KitchenSink.nested_value AS col, 2 AS extra_2 from TestTable
--
ERROR: Column col in UNION ALL has incompatible types: zetasql_test__.MessageWithNulls, zetasql_test__.KitchenSinkPB.Nested [at 3:1]
select KitchenSink.nested_value AS col, 2 AS extra_2 from TestTable
^
==

# CORRESPONDING: Incompatible types in multiple operations.
select key from KeyValue union all CORRESPONDING
select key from KeyValue union all CORRESPONDING
select key from KeyValue union all CORRESPONDING
select key from KeyValue union all CORRESPONDING
select cast(5 as int64) AS key union all CORRESPONDING
select cast(5 as int32) AS key union all CORRESPONDING
select 5 AS key union all CORRESPONDING
select value AS key from KeyValue union all CORRESPONDING
select key from KeyValue
--
ERROR: Column key in UNION ALL has incompatible types: INT64, INT64, INT64, INT64, INT64, INT32, INT64, STRING, INT64 [at 2:1]
select key from KeyValue union all CORRESPONDING
^
==

# CORRESPONDING: Multiple columns, some of which have to get widened in either direction.
select `int32` AS col1, `uint32` AS col2, `string` AS col3 from SimpleTypes s1
union all CORRESPONDING
select `string` AS col3, `int32` AS col2, `int64` AS col1, from SimpleTypes s2
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#39 AS col1 [INT64]
| +-$union_all.col2#40 AS col2 [INT64]
| +-$union_all.col3#41 AS col3 [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col1#39, col2#40, col3#41]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.int32#42, $union_all1_cast.uint32#43, SimpleTypes.string#5]
    | | |   +-expr_list=
    | | |   | +-int32#42 :=
    | | |   | | +-Cast(INT32 -> INT64)
    | | |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   | +-uint32#43 :=
    | | |   |   +-Cast(UINT32 -> INT64)
    | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int32#1, uint32#3, string#5]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, uint32#3, string#5], table=SimpleTypes, column_index_list=[0, 2, 4], alias="s1")
    | | +-output_column_list=[$union_all1_cast.int32#42, $union_all1_cast.uint32#43, SimpleTypes.string#5]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[SimpleTypes.int64#21, $union_all2_cast.int32#44, SimpleTypes.string#24]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[SimpleTypes.string#24, $union_all2_cast.int32#44, SimpleTypes.int64#21]
    |   |       +-expr_list=
    |   |       | +-int32#44 :=
    |   |       |   +-Cast(INT32 -> INT64)
    |   |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[string#24, int32#20, int64#21]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=SimpleTypes.[int32#20, int64#21, string#24], table=SimpleTypes, column_index_list=[0, 1, 4], alias="s2")
    |   +-output_column_list=[SimpleTypes.int64#21, $union_all2_cast.int32#44, SimpleTypes.string#24]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Nested operations output column names are ordered according to the first query.
SELECT *
FROM (
  SELECT 1 AS col1, 2 AS col2
  UNION ALL CORRESPONDING
  SELECT 1 AS col2, 2 AS col1
)
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#5 AS col1 [INT64]
| +-$union_all.col2#6 AS col2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=$union_all.[col1#5, col2#6]
    +-input_scan=
      +-SetOperationScan
        +-column_list=$union_all.[col1#5, col2#6]
        +-op_type=UNION_ALL
        +-input_item_list=
        | +-SetOperationItem
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$union_all1.[col1#1, col2#2]
        | | |   +-expr_list=
        | | |   | +-col1#1 := Literal(type=INT64, value=1)
        | | |   | +-col2#2 := Literal(type=INT64, value=2)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-output_column_list=$union_all1.[col1#1, col2#2]
        | +-SetOperationItem
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$union_all2.[col1#4, col2#3]
        |   |   +-node_source="resolver_set_operation_corresponding"
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=$union_all2.[col2#3, col1#4]
        |   |       +-expr_list=
        |   |       | +-col2#3 := Literal(type=INT64, value=1)
        |   |       | +-col1#4 := Literal(type=INT64, value=2)
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-output_column_list=$union_all2.[col1#4, col2#3]
        +-column_match_mode=CORRESPONDING
        +-column_propagation_mode=INNER
==

# CORRESPONDING: coercion with NULL.
SELECT NULL AS timestamp FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT timestamp FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.timestamp#40 AS timestamp [TIMESTAMP]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.timestamp#40]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.timestamp#41]
    | | |   +-expr_list=
    | | |   | +-timestamp#41 := Literal(type=TIMESTAMP, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1.timestamp#20]
    | | |       +-expr_list=
    | | |       | +-timestamp#20 := Literal(type=INT64, value=NULL)
    | | |       +-input_scan=
    | | |         +-TableScan(table=SimpleTypes)
    | | +-output_column_list=[$union_all1_cast.timestamp#41]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[SimpleTypes.timestamp#35]
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[SimpleTypes.timestamp#35], table=SimpleTypes, column_index_list=[14])
    |   +-output_column_list=[SimpleTypes.timestamp#35]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union of two identical structs works.
# Field names are determined from the first leg of the union.
select (select AS STRUCT 1 a, 2 bbB) AS col
union all CORRESPONDING
select (select AS STRUCT 3 a, 4 Bbb) AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#9 AS col [STRUCT<a INT64, bbB INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#4]
    | | |   +-expr_list=
    | | |   | +-col#4 :=
    | | |   |   +-SubqueryExpr
    | | |   |     +-type=STRUCT<a INT64, bbB INT64>
    | | |   |     +-subquery_type=SCALAR
    | | |   |     +-subquery=
    | | |   |       +-ProjectScan
    | | |   |         +-column_list=[$make_struct.$struct#3]
    | | |   |         +-expr_list=
    | | |   |         | +-$struct#3 :=
    | | |   |         |   +-MakeStruct
    | | |   |         |     +-type=STRUCT<a INT64, bbB INT64>
    | | |   |         |     +-field_list=
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#1)
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.bbB#2)
    | | |   |         +-input_scan=
    | | |   |           +-ProjectScan
    | | |   |             +-column_list=$expr_subquery.[a#1, bbB#2]
    | | |   |             +-expr_list=
    | | |   |             | +-a#1 := Literal(type=INT64, value=1)
    | | |   |             | +-bbB#2 := Literal(type=INT64, value=2)
    | | |   |             +-input_scan=
    | | |   |               +-SingleRowScan
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#8]
    |   |   +-expr_list=
    |   |   | +-col#8 :=
    |   |   |   +-SubqueryExpr
    |   |   |     +-type=STRUCT<a INT64, Bbb INT64>
    |   |   |     +-subquery_type=SCALAR
    |   |   |     +-subquery=
    |   |   |       +-ProjectScan
    |   |   |         +-column_list=[$make_struct.$struct#7]
    |   |   |         +-expr_list=
    |   |   |         | +-$struct#7 :=
    |   |   |         |   +-MakeStruct
    |   |   |         |     +-type=STRUCT<a INT64, Bbb INT64>
    |   |   |         |     +-field_list=
    |   |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#5)
    |   |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.Bbb#6)
    |   |   |         +-input_scan=
    |   |   |           +-ProjectScan
    |   |   |             +-column_list=$expr_subquery.[a#5, Bbb#6]
    |   |   |             +-expr_list=
    |   |   |             | +-a#5 := Literal(type=INT64, value=3)
    |   |   |             | +-Bbb#6 := Literal(type=INT64, value=4)
    |   |   |             +-input_scan=
    |   |   |               +-SingleRowScan
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#8]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union of two STRUCTs with different column/field names.
# Note that the second input to the union has the STRUCT field casted to a STRUCT
# with the same field names as the STRUCT from the first input to the union.
select (select AS STRUCT 1 a, 2 b) AS foo
union all CORRESPONDING
select (select AS STRUCT 3 b, 4 c) as foo
--
QueryStmt
+-output_column_list=
| +-$union_all.foo#9 AS foo [STRUCT<a INT64, b INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.foo#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.foo#4]
    | | |   +-expr_list=
    | | |   | +-foo#4 :=
    | | |   |   +-SubqueryExpr
    | | |   |     +-type=STRUCT<a INT64, b INT64>
    | | |   |     +-subquery_type=SCALAR
    | | |   |     +-subquery=
    | | |   |       +-ProjectScan
    | | |   |         +-column_list=[$make_struct.$struct#3]
    | | |   |         +-expr_list=
    | | |   |         | +-$struct#3 :=
    | | |   |         |   +-MakeStruct
    | | |   |         |     +-type=STRUCT<a INT64, b INT64>
    | | |   |         |     +-field_list=
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#1)
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.b#2)
    | | |   |         +-input_scan=
    | | |   |           +-ProjectScan
    | | |   |             +-column_list=$expr_subquery.[a#1, b#2]
    | | |   |             +-expr_list=
    | | |   |             | +-a#1 := Literal(type=INT64, value=1)
    | | |   |             | +-b#2 := Literal(type=INT64, value=2)
    | | |   |             +-input_scan=
    | | |   |               +-SingleRowScan
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.foo#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.foo#10]
    |   |   +-expr_list=
    |   |   | +-foo#10 :=
    |   |   |   +-Cast(STRUCT<b INT64, c INT64> -> STRUCT<a INT64, b INT64>)
    |   |   |     +-ColumnRef(type=STRUCT<b INT64, c INT64>, column=$union_all2.foo#8)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.foo#8]
    |   |       +-expr_list=
    |   |       | +-foo#8 :=
    |   |       |   +-SubqueryExpr
    |   |       |     +-type=STRUCT<b INT64, c INT64>
    |   |       |     +-subquery_type=SCALAR
    |   |       |     +-subquery=
    |   |       |       +-ProjectScan
    |   |       |         +-column_list=[$make_struct.$struct#7]
    |   |       |         +-expr_list=
    |   |       |         | +-$struct#7 :=
    |   |       |         |   +-MakeStruct
    |   |       |         |     +-type=STRUCT<b INT64, c INT64>
    |   |       |         |     +-field_list=
    |   |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.b#5)
    |   |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.c#6)
    |   |       |         +-input_scan=
    |   |       |           +-ProjectScan
    |   |       |             +-column_list=$expr_subquery.[b#5, c#6]
    |   |       |             +-expr_list=
    |   |       |             | +-b#5 := Literal(type=INT64, value=3)
    |   |       |             | +-c#6 := Literal(type=INT64, value=4)
    |   |       |             +-input_scan=
    |   |       |               +-SingleRowScan
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2_cast.foo#10]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: UNION of a STRUCT value table and non-value table not allowed.
select AS STRUCT 1 a, 2 b
union all CORRESPONDING
select STRUCT<c int64, d int64>(3, 4) as e
--
ERROR: Value table type not allowed in set operations when CORRESPONDING is used: query 1 [at 2:1]
union all CORRESPONDING
^
==

# CORRESPONDING: UNION of a non-value table and STRUCT value table not allowed.
select STRUCT<c int64, d int64>(3, 4) as e
union all CORRESPONDING
select AS STRUCT 1 a, 2 b
--
ERROR: Value table type not allowed in set operations when CORRESPONDING is used: query 2 [at 2:1]
union all CORRESPONDING
^
==

# CORRESPONDING: Union of two coercible structs types.
select (select AS STRUCT 1 a, 2 b) AS col
union all CORRESPONDING
select (select AS STRUCT 3 a, 4.5 b) AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#9 AS col [STRUCT<a INT64, b DOUBLE>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.col#10]
    | | |   +-expr_list=
    | | |   | +-col#10 :=
    | | |   |   +-Cast(STRUCT<a INT64, b INT64> -> STRUCT<a INT64, b DOUBLE>)
    | | |   |     +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$union_all1.col#4)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1.col#4]
    | | |       +-expr_list=
    | | |       | +-col#4 :=
    | | |       |   +-SubqueryExpr
    | | |       |     +-type=STRUCT<a INT64, b INT64>
    | | |       |     +-subquery_type=SCALAR
    | | |       |     +-subquery=
    | | |       |       +-ProjectScan
    | | |       |         +-column_list=[$make_struct.$struct#3]
    | | |       |         +-expr_list=
    | | |       |         | +-$struct#3 :=
    | | |       |         |   +-MakeStruct
    | | |       |         |     +-type=STRUCT<a INT64, b INT64>
    | | |       |         |     +-field_list=
    | | |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#1)
    | | |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.b#2)
    | | |       |         +-input_scan=
    | | |       |           +-ProjectScan
    | | |       |             +-column_list=$expr_subquery.[a#1, b#2]
    | | |       |             +-expr_list=
    | | |       |             | +-a#1 := Literal(type=INT64, value=1)
    | | |       |             | +-b#2 := Literal(type=INT64, value=2)
    | | |       |             +-input_scan=
    | | |       |               +-SingleRowScan
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.col#10]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#8]
    |   |   +-expr_list=
    |   |   | +-col#8 :=
    |   |   |   +-SubqueryExpr
    |   |   |     +-type=STRUCT<a INT64, b DOUBLE>
    |   |   |     +-subquery_type=SCALAR
    |   |   |     +-subquery=
    |   |   |       +-ProjectScan
    |   |   |         +-column_list=[$make_struct.$struct#7]
    |   |   |         +-expr_list=
    |   |   |         | +-$struct#7 :=
    |   |   |         |   +-MakeStruct
    |   |   |         |     +-type=STRUCT<a INT64, b DOUBLE>
    |   |   |         |     +-field_list=
    |   |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#5)
    |   |   |         |       +-ColumnRef(type=DOUBLE, column=$expr_subquery.b#6)
    |   |   |         +-input_scan=
    |   |   |           +-ProjectScan
    |   |   |             +-column_list=$expr_subquery.[a#5, b#6]
    |   |   |             +-expr_list=
    |   |   |             | +-a#5 := Literal(type=INT64, value=3)
    |   |   |             | +-b#6 := Literal(type=DOUBLE, value=4.5)
    |   |   |             +-input_scan=
    |   |   |               +-SingleRowScan
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#8]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union of two non-coercible struct types.
select (select AS STRUCT cast(1 as uint64) a, 2 b) AS col
union all CORRESPONDING
select (select AS STRUCT cast(1 as int32) a, 2 b) AS col
--
ERROR: Column col in UNION ALL has incompatible types: STRUCT<a UINT64, b INT64>, STRUCT<a INT32, b INT64> [at 3:1]
select (select AS STRUCT cast(1 as int32) a, 2 b) AS col
^
==

# CORRESPONDING: Only field names of the first struct will determine the field names of
# supertyped struct.
select (select AS STRUCT 1, 2) AS col
union all CORRESPONDING
select (select AS STRUCT 3 a, 4 b) AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#9 AS col [STRUCT<INT64, INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#4]
    | | |   +-expr_list=
    | | |   | +-col#4 :=
    | | |   |   +-SubqueryExpr
    | | |   |     +-type=STRUCT<INT64, INT64>
    | | |   |     +-subquery_type=SCALAR
    | | |   |     +-subquery=
    | | |   |       +-ProjectScan
    | | |   |         +-column_list=[$make_struct.$struct#3]
    | | |   |         +-expr_list=
    | | |   |         | +-$struct#3 :=
    | | |   |         |   +-MakeStruct
    | | |   |         |     +-type=STRUCT<INT64, INT64>
    | | |   |         |     +-field_list=
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.$col1#1)
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.$col2#2)
    | | |   |         +-input_scan=
    | | |   |           +-ProjectScan
    | | |   |             +-column_list=$expr_subquery.[$col1#1, $col2#2]
    | | |   |             +-expr_list=
    | | |   |             | +-$col1#1 := Literal(type=INT64, value=1)
    | | |   |             | +-$col2#2 := Literal(type=INT64, value=2)
    | | |   |             +-input_scan=
    | | |   |               +-SingleRowScan
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.col#10]
    |   |   +-expr_list=
    |   |   | +-col#10 :=
    |   |   |   +-Cast(STRUCT<a INT64, b INT64> -> STRUCT<INT64, INT64>)
    |   |   |     +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$union_all2.col#8)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.col#8]
    |   |       +-expr_list=
    |   |       | +-col#8 :=
    |   |       |   +-SubqueryExpr
    |   |       |     +-type=STRUCT<a INT64, b INT64>
    |   |       |     +-subquery_type=SCALAR
    |   |       |     +-subquery=
    |   |       |       +-ProjectScan
    |   |       |         +-column_list=[$make_struct.$struct#7]
    |   |       |         +-expr_list=
    |   |       |         | +-$struct#7 :=
    |   |       |         |   +-MakeStruct
    |   |       |         |     +-type=STRUCT<a INT64, b INT64>
    |   |       |         |     +-field_list=
    |   |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#5)
    |   |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.b#6)
    |   |       |         +-input_scan=
    |   |       |           +-ProjectScan
    |   |       |             +-column_list=$expr_subquery.[a#5, b#6]
    |   |       |             +-expr_list=
    |   |       |             | +-a#5 := Literal(type=INT64, value=3)
    |   |       |             | +-b#6 := Literal(type=INT64, value=4)
    |   |       |             +-input_scan=
    |   |       |               +-SingleRowScan
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2_cast.col#10]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: UNION of struct parameters.
(select struct(1, "abc") AS col)
union all CORRESPONDING
(select @test_param_struct AS col limit 1)
--
QueryStmt
+-output_column_list=
| +-$union_all.col#3 AS col [STRUCT<INT32, STRING>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#3]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.col#4]
    | | |   +-expr_list=
    | | |   | +-col#4 := Literal(type=STRUCT<INT32, STRING>, value={1, "abc"})
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1.col#1]
    | | |       +-expr_list=
    | | |       | +-col#1 := Literal(type=STRUCT<INT64, STRING>, value={1, "abc"})
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.col#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.col#5]
    |   |   +-expr_list=
    |   |   | +-col#5 :=
    |   |   |   +-Cast(STRUCT<a INT32, b STRING> -> STRUCT<INT32, STRING>)
    |   |   |     +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$union_all2.col#2)
    |   |   +-input_scan=
    |   |     +-LimitOffsetScan
    |   |       +-column_list=[$union_all2.col#2]
    |   |       +-input_scan=
    |   |       | +-ProjectScan
    |   |       |   +-column_list=[$union_all2.col#2]
    |   |       |   +-expr_list=
    |   |       |   | +-col#2 := Parameter(type=STRUCT<a INT32, b STRING>, name="test_param_struct")
    |   |       |   +-input_scan=
    |   |       |     +-SingleRowScan
    |   |       +-limit=
    |   |         +-Literal(type=INT64, value=1)
    |   +-output_column_list=[$union_all2_cast.col#5]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: with a group by.
select `uint64` from SimpleTypes
union all CORRESPONDING
select CAST(1 AS UINT64) as `uint64` from SimpleTypes
group by `uint64`
--
QueryStmt
+-output_column_list=
| +-$union_all.uint64#40 AS uint64 [UINT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.uint64#40]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.uint64#4]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=[SimpleTypes.uint64#4], table=SimpleTypes, column_index_list=[3])
    | | +-output_column_list=[SimpleTypes.uint64#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$groupby.uint64#39]
    |   |   +-input_scan=
    |   |     +-AggregateScan
    |   |       +-column_list=[$groupby.uint64#39]
    |   |       +-input_scan=
    |   |       | +-TableScan(table=SimpleTypes)
    |   |       +-group_by_list=
    |   |         +-uint64#39 := Literal(type=UINT64, value=1, has_explicit_type=TRUE)
    |   +-output_column_list=[$groupby.uint64#39]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Type coercing in multiple operations of columns from table scans.
SELECT `uint32` AS col
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `int32` AS col
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `float` AS col
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.col#58 AS col [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#58]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.uint32#59]
    | | |   +-expr_list=
    | | |   | +-uint32#59 :=
    | | |   |   +-Cast(UINT32 -> DOUBLE)
    | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[SimpleTypes.uint32#3]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.uint32#3], table=SimpleTypes, column_index_list=[2])
    | | +-output_column_list=[$union_all1_cast.uint32#59]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all2_cast.int32#60]
    | | |   +-expr_list=
    | | |   | +-int32#60 :=
    | | |   |   +-Cast(INT32 -> DOUBLE)
    | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[SimpleTypes.int32#20]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    | | +-output_column_list=[$union_all2_cast.int32#60]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all3_cast.float#61]
    |   |   +-expr_list=
    |   |   | +-float#61 :=
    |   |   |   +-Cast(FLOAT -> DOUBLE)
    |   |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#46)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[SimpleTypes.float#46]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=[SimpleTypes.float#46], table=SimpleTypes, column_index_list=[7])
    |   +-output_column_list=[$union_all3_cast.float#61]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: nested set operations with type coercing.
select `uint32` AS col from SimpleTypes s1
UNION ALL CORRESPONDING
(select `int32` AS col from SimpleTypes s2
 INTERSECT ALL CORRESPONDING
 (select `float` AS col from SimpleTypes s3 EXCEPT ALL CORRESPONDING select 1 AS col));
--
QueryStmt
+-output_column_list=
| +-$union_all.col#64 AS col [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#64]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.uint32#65]
    | | |   +-expr_list=
    | | |   | +-uint32#65 :=
    | | |   |   +-Cast(UINT32 -> DOUBLE)
    | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[SimpleTypes.uint32#3]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.uint32#3], table=SimpleTypes, column_index_list=[2], alias="s1")
    | | +-output_column_list=[$union_all1_cast.uint32#65]
    | +-SetOperationItem
    |   +-scan=
    |   | +-SetOperationScan
    |   |   +-column_list=[$intersect_all.col#61]
    |   |   +-op_type=INTERSECT_ALL
    |   |   +-input_item_list=
    |   |   | +-SetOperationItem
    |   |   | | +-scan=
    |   |   | | | +-ProjectScan
    |   |   | | |   +-column_list=[$intersect_all1_cast.int32#62]
    |   |   | | |   +-expr_list=
    |   |   | | |   | +-int32#62 :=
    |   |   | | |   |   +-Cast(INT32 -> DOUBLE)
    |   |   | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |   | | |   +-input_scan=
    |   |   | | |     +-ProjectScan
    |   |   | | |       +-column_list=[SimpleTypes.int32#20]
    |   |   | | |       +-input_scan=
    |   |   | | |         +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0], alias="s2")
    |   |   | | +-output_column_list=[$intersect_all1_cast.int32#62]
    |   |   | +-SetOperationItem
    |   |   |   +-scan=
    |   |   |   | +-ProjectScan
    |   |   |   |   +-column_list=[$intersect_all2_cast.col#63]
    |   |   |   |   +-expr_list=
    |   |   |   |   | +-col#63 :=
    |   |   |   |   |   +-Cast(FLOAT -> DOUBLE)
    |   |   |   |   |     +-ColumnRef(type=FLOAT, column=$except_all.col#59)
    |   |   |   |   +-input_scan=
    |   |   |   |     +-SetOperationScan
    |   |   |   |       +-column_list=[$except_all.col#59]
    |   |   |   |       +-op_type=EXCEPT_ALL
    |   |   |   |       +-input_item_list=
    |   |   |   |       | +-SetOperationItem
    |   |   |   |       | | +-scan=
    |   |   |   |       | | | +-ProjectScan
    |   |   |   |       | | |   +-column_list=[SimpleTypes.float#46]
    |   |   |   |       | | |   +-input_scan=
    |   |   |   |       | | |     +-TableScan(column_list=[SimpleTypes.float#46], table=SimpleTypes, column_index_list=[7], alias="s3")
    |   |   |   |       | | +-output_column_list=[SimpleTypes.float#46]
    |   |   |   |       | +-SetOperationItem
    |   |   |   |       |   +-scan=
    |   |   |   |       |   | +-ProjectScan
    |   |   |   |       |   |   +-column_list=[$except_all2_cast.col#60]
    |   |   |   |       |   |   +-expr_list=
    |   |   |   |       |   |   | +-col#60 := Literal(type=FLOAT, value=1)
    |   |   |   |       |   |   +-input_scan=
    |   |   |   |       |   |     +-ProjectScan
    |   |   |   |       |   |       +-column_list=[$except_all2.col#58]
    |   |   |   |       |   |       +-expr_list=
    |   |   |   |       |   |       | +-col#58 := Literal(type=INT64, value=1)
    |   |   |   |       |   |       +-input_scan=
    |   |   |   |       |   |         +-SingleRowScan
    |   |   |   |       |   +-output_column_list=[$except_all2_cast.col#60]
    |   |   |   |       +-column_match_mode=CORRESPONDING
    |   |   |   |       +-column_propagation_mode=INNER
    |   |   |   +-output_column_list=[$intersect_all2_cast.col#63]
    |   |   +-column_match_mode=CORRESPONDING
    |   |   +-column_propagation_mode=INNER
    |   +-output_column_list=[$intersect_all.col#61]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: UNION ALL CORRESPONDING with anonymous STRUCT.
select (1, 1) AS col union all CORRESPONDING select (1, 1) AS col;
--
QueryStmt
+-output_column_list=
| +-$union_all.col#3 AS col [STRUCT<INT64, INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#3]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#1]
    | | |   +-expr_list=
    | | |   | +-col#1 := Literal(type=STRUCT<INT64, INT64>, value={1, 1})
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#2]
    |   |   +-expr_list=
    |   |   | +-col#2 := Literal(type=STRUCT<INT64, INT64>, value={1, 1})
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#2]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: UNION of arrays.
select [1, 1] AS col union all CORRESPONDING select [2, 3, 4] AS col;
--
QueryStmt
+-output_column_list=
| +-$union_all.col#3 AS col [ARRAY<INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#3]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#1]
    | | |   +-expr_list=
    | | |   | +-col#1 := Literal(type=ARRAY<INT64>, value=[1, 1])
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#2]
    |   |   +-expr_list=
    |   |   | +-col#2 := Literal(type=ARRAY<INT64>, value=[2, 3, 4])
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#2]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Subqueries with SELECT *.
select "abc" c1, cast(1 as int64) c2
union all CORRESPONDING
select * from (
  select "def" c1, cast(1 as int32) c2
)
--
QueryStmt
+-output_column_list=
| +-$union_all.c1#5 AS c1 [STRING]
| +-$union_all.c2#6 AS c2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[c1#5, c2#6]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[c1#1, c2#2]
    | | |   +-expr_list=
    | | |   | +-c1#1 := Literal(type=STRING, value="abc")
    | | |   | +-c2#2 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[c1#1, c2#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$subquery1.c1#3, $union_all2_cast.c2#7]
    |   |   +-expr_list=
    |   |   | +-c2#7 :=
    |   |   |   +-Cast(INT32 -> INT64)
    |   |   |     +-ColumnRef(type=INT32, column=$subquery1.c2#4)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$subquery1.[c1#3, c2#4]
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=$subquery1.[c1#3, c2#4]
    |   |           +-expr_list=
    |   |           | +-c1#3 := Literal(type=STRING, value="def")
    |   |           | +-c2#4 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-output_column_list=[$subquery1.c1#3, $union_all2_cast.c2#7]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Set operation with hint.
select 1 AS col
UNION @{ key = 5 } ALL CORRESPONDING
select 2 AS col
UNION ALL CORRESPONDING
select 3 AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#4 AS col [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#4]
    +-hint_list=
    | +-key := Literal(type=INT64, value=5)
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#1]
    | | |   +-expr_list=
    | | |   | +-col#1 := Literal(type=INT64, value=1)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#1]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all2.col#2]
    | | |   +-expr_list=
    | | |   | +-col#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all2.col#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all3.col#3]
    |   |   +-expr_list=
    |   |   | +-col#3 := Literal(type=INT64, value=3)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all3.col#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

[default language_features=V_1_4_CORRESPONDING_FULL]
# CORRESPONDING: Basic FULL mode: no common columns.
SELECT 1 AS a
FULL UNION ALL CORRESPONDING
SELECT 1 AS b
--
QueryStmt
+-output_column_list=
| +-$union_all.a#3 AS a [INT64]
| +-$union_all.b#4 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#3, b#4]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.a#1, $null_column_for_outer_set_op.b#5]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-b#5 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1.a#1]
    | | |       +-expr_list=
    | | |       | +-a#1 := Literal(type=INT64, value=1)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1.a#1, $null_column_for_outer_set_op.b#5]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#6, $union_all2.b#2]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#6 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.b#2]
    |   |       +-expr_list=
    |   |       | +-b#2 := Literal(type=INT64, value=1)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.a#6, $union_all2.b#2]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: Baisc FULL mode: first query misses columns.
SELECT int64 FROM SimpleTypes
FULL UNION ALL CORRESPONDING
SELECT int32, int64 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int64#39 AS int64 [INT64]
| +-$union_all.int32#40 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int64#39, int32#40]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.int64#2, $null_column_for_outer_set_op.int32#41]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-int32#41 := Literal(type=INT32, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[SimpleTypes.int64#2]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
    | | +-output_column_list=[SimpleTypes.int64#2, $null_column_for_outer_set_op.int32#41]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=SimpleTypes.[int64#21, int32#20]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#20, int64#21]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#20, int64#21], table=SimpleTypes, column_index_list=[0, 1])
    |   +-output_column_list=SimpleTypes.[int64#21, int32#20]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: Basic FULL mode: second query misses columns.
SELECT int64, int32 FROM SimpleTypes
FULL UNION ALL CORRESPONDING
SELECT int32 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int64#39 AS int64 [INT64]
| +-$union_all.int32#40 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int64#39, int32#40]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=SimpleTypes.[int64#2, int32#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.int64#41, SimpleTypes.int32#20]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-int64#41 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[SimpleTypes.int32#20]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    |   +-output_column_list=[$null_column_for_outer_set_op.int64#41, SimpleTypes.int32#20]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: Basic FULL mode: both queries miss columns.
SELECT 3 AS c, 1 AS a
FULL UNION ALL CORRESPONDING
SELECT 1 AS a, 2 AS b
--
QueryStmt
+-output_column_list=
| +-$union_all.c#5 AS c [INT64]
| +-$union_all.a#6 AS a [INT64]
| +-$union_all.b#7 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[c#5, a#6, b#7]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.c#1, $union_all1.a#2, $null_column_for_outer_set_op.b#8]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-b#8 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all1.[c#1, a#2]
    | | |       +-expr_list=
    | | |       | +-c#1 := Literal(type=INT64, value=3)
    | | |       | +-a#2 := Literal(type=INT64, value=1)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1.c#1, $union_all1.a#2, $null_column_for_outer_set_op.b#8]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.c#9, $union_all2.a#3, $union_all2.b#4]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-c#9 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[a#3, b#4]
    |   |       +-expr_list=
    |   |       | +-a#3 := Literal(type=INT64, value=1)
    |   |       | +-b#4 := Literal(type=INT64, value=2)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.c#9, $union_all2.a#3, $union_all2.b#4]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: Basic FULL no queries miss columns.
SELECT int64, int32 FROM SimpleTypes
FULL UNION DISTINCT CORRESPONDING
SELECT int32, int64 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_distinct.int64#39 AS int64 [INT64]
| +-$union_distinct.int32#40 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_distinct.[int64#39, int32#40]
    +-op_type=UNION_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=SimpleTypes.[int64#2, int32#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=SimpleTypes.[int64#21, int32#20]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#20, int64#21]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#20, int64#21], table=SimpleTypes, column_index_list=[0, 1])
    |   +-output_column_list=SimpleTypes.[int64#21, int32#20]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: A column has incompatible types.
SELECT 1 AS a, 2 AS b
FULL UNION ALL CORRESPONDING
SELECT 1 as a
FULL UNION ALL CORRESPONDING
SELECT FALSE AS b
--
ERROR: Column b in UNION ALL has incompatible types: INT64, NULL, BOOL [at 3:1]
SELECT 1 as a
^
==

# CORRESPONDING: FULL mode multiple expressions.
SELECT int64, int32 FROM SimpleTypes
FULL UNION ALL CORRESPONDING
SELECT int32, uint64 FROM SimpleTypes
FULL UNION ALL CORRESPONDING
SELECT int32, uint64 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int64#58 AS int64 [INT64]
| +-$union_all.int32#59 AS int32 [INT32]
| +-$union_all.uint64#60 AS uint64 [UINT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int64#58, int32#59, uint64#60]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.int64#2, SimpleTypes.int32#1, $null_column_for_outer_set_op.uint64#61]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-uint64#61 := Literal(type=UINT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=[SimpleTypes.int64#2, SimpleTypes.int32#1, $null_column_for_outer_set_op.uint64#61]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.int64#62, SimpleTypes.int32#20, SimpleTypes.uint64#23]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-int64#62 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int32#20, uint64#23]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#20, uint64#23], table=SimpleTypes, column_index_list=[0, 3])
    | | +-output_column_list=[$null_column_for_outer_set_op.int64#62, SimpleTypes.int32#20, SimpleTypes.uint64#23]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.int64#63, SimpleTypes.int32#39, SimpleTypes.uint64#42]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-int64#63 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#39, uint64#42]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#39, uint64#42], table=SimpleTypes, column_index_list=[0, 3])
    |   +-output_column_list=[$null_column_for_outer_set_op.int64#63, SimpleTypes.int32#39, SimpleTypes.uint64#42]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: FULL mode multiple expressions: every query has a unique
# column.
SELECT int64, int32 FROM SimpleTypes
FULL INTERSECT ALL CORRESPONDING
SELECT int32, uint64 FROM SimpleTypes
FULL INTERSECT ALL CORRESPONDING
SELECT int32, float FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$intersect_all.int64#58 AS int64 [INT64]
| +-$intersect_all.int32#59 AS int32 [INT32]
| +-$intersect_all.uint64#60 AS uint64 [UINT64]
| +-$intersect_all.float#61 AS float [FLOAT]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[int64#58, int32#59, uint64#60, float#61]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.int64#2, SimpleTypes.int32#1, $null_column_for_outer_set_op.uint64#62, $null_column_for_outer_set_op.float#63]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-uint64#62 := Literal(type=UINT64, value=NULL)
    | | |   | +-float#63 := Literal(type=FLOAT, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=[SimpleTypes.int64#2, SimpleTypes.int32#1, $null_column_for_outer_set_op.uint64#62, $null_column_for_outer_set_op.float#63]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.int64#64, SimpleTypes.int32#20, SimpleTypes.uint64#23, $null_column_for_outer_set_op.float#65]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-int64#64 := Literal(type=INT64, value=NULL)
    | | |   | +-float#65 := Literal(type=FLOAT, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int32#20, uint64#23]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#20, uint64#23], table=SimpleTypes, column_index_list=[0, 3])
    | | +-output_column_list=[$null_column_for_outer_set_op.int64#64, SimpleTypes.int32#20, SimpleTypes.uint64#23, $null_column_for_outer_set_op.float#65]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.int64#66, SimpleTypes.int32#39, $null_column_for_outer_set_op.uint64#67, SimpleTypes.float#46]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-int64#66 := Literal(type=INT64, value=NULL)
    |   |   | +-uint64#67 := Literal(type=UINT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#39, float#46]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#39, float#46], table=SimpleTypes, column_index_list=[0, 7])
    |   +-output_column_list=[$null_column_for_outer_set_op.int64#66, SimpleTypes.int32#39, $null_column_for_outer_set_op.uint64#67, SimpleTypes.float#46]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: FULL mode with multiple expressions: Type coercion for NULL
# columns.
SELECT int64 AS a, int32 AS b FROM SimpleTypes
FULL INTERSECT ALL CORRESPONDING
SELECT int32 AS b FROM SimpleTypes
FULL INTERSECT ALL CORRESPONDING
SELECT uint32 AS b, float AS a FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$intersect_all.a#58 AS a [DOUBLE]
| +-$intersect_all.b#59 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[a#58, b#59]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1_cast.[int64#60, int32#61]
    | | |   +-expr_list=
    | | |   | +-int64#60 :=
    | | |   | | +-Cast(INT64 -> DOUBLE)
    | | |   | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | | |   | +-int32#61 :=
    | | |   |   +-Cast(INT32 -> INT64)
    | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=$intersect_all1_cast.[int64#60, int32#61]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.a#65, $intersect_all2_cast.int32#62]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-a#65 := Literal(type=DOUBLE, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$intersect_all2_cast.int32#62]
    | | |       +-expr_list=
    | | |       | +-int32#62 :=
    | | |       |   +-Cast(INT32 -> INT64)
    | | |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=[SimpleTypes.int32#20]
    | | |           +-input_scan=
    | | |             +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    | | +-output_column_list=[$null_column_for_outer_set_op.a#65, $intersect_all2_cast.int32#62]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_all3_cast.[float#64, uint32#63]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$intersect_all3_cast.[uint32#63, float#64]
    |   |       +-expr_list=
    |   |       | +-uint32#63 :=
    |   |       | | +-Cast(UINT32 -> INT64)
    |   |       | |   +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#41)
    |   |       | +-float#64 :=
    |   |       |   +-Cast(FLOAT -> DOUBLE)
    |   |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#46)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[uint32#41, float#46]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=SimpleTypes.[uint32#41, float#46], table=SimpleTypes, column_index_list=[2, 7])
    |   +-output_column_list=$intersect_all3_cast.[float#64, uint32#63]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: FULL mode with duplicate columns of different names.
SELECT int64 AS a, int64 AS b FROM SimpleTypes
FULL UNION ALL CORRESPONDING
SELECT int32 AS b, int32 AS c FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.a#39 AS a [INT64]
| +-$union_all.b#40 AS b [INT64]
| +-$union_all.c#41 AS c [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#39, b#40, c#41]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.int64#2, SimpleTypes.int64#2, $null_column_for_outer_set_op.c#43]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-c#43 := Literal(type=INT32, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int64#2]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
    | | +-output_column_list=[SimpleTypes.int64#2, SimpleTypes.int64#2, $null_column_for_outer_set_op.c#43]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#44, $union_all2_cast.int32#42, SimpleTypes.int32#20]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#44 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2_cast.int32#42, SimpleTypes.int32#20]
    |   |       +-expr_list=
    |   |       | +-int32#42 :=
    |   |       |   +-Cast(INT32 -> INT64)
    |   |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[int32#20, int32#20]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    |   +-output_column_list=[$null_column_for_outer_set_op.a#44, $union_all2_cast.int32#42, SimpleTypes.int32#20]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: FULL mode with duplicate columns of different names.
SELECT int64 AS a, int64 AS b, int32 AS c, int64 AS d FROM SimpleTypes
FULL UNION ALL CORRESPONDING
SELECT int32 AS b, int32 AS d, int32 AS e FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.a#39 AS a [INT64]
| +-$union_all.b#40 AS b [INT64]
| +-$union_all.c#41 AS c [INT32]
| +-$union_all.d#42 AS d [INT64]
| +-$union_all.e#43 AS e [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#39, b#40, c#41, d#42, e#43]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.int64#2, SimpleTypes.int64#2, SimpleTypes.int32#1, SimpleTypes.int64#2, $null_column_for_outer_set_op.e#46]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-e#46 := Literal(type=INT32, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int64#2, int32#1, int64#2]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=[SimpleTypes.int64#2, SimpleTypes.int64#2, SimpleTypes.int32#1, SimpleTypes.int64#2, $null_column_for_outer_set_op.e#46]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#47, $union_all2_cast.int32#44, $null_column_for_outer_set_op.c#48, $union_all2_cast.int32#45, SimpleTypes.int32#20]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#47 := Literal(type=INT64, value=NULL)
    |   |   | +-c#48 := Literal(type=INT32, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2_cast.int32#44, $union_all2_cast.int32#45, SimpleTypes.int32#20]
    |   |       +-expr_list=
    |   |       | +-int32#44 :=
    |   |       | | +-Cast(INT32 -> INT64)
    |   |       | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       | +-int32#45 :=
    |   |       |   +-Cast(INT32 -> INT64)
    |   |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[int32#20, int32#20, int32#20]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    |   +-output_column_list=[$null_column_for_outer_set_op.a#47, $union_all2_cast.int32#44, $null_column_for_outer_set_op.c#48, $union_all2_cast.int32#45, SimpleTypes.int32#20]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: nested queries.
SELECT int64, int32 FROM SimpleTypes
FULL UNION ALL CORRESPONDING (
  SELECT float, double, int64 FROM SimpleTypes
  FULL INTERSECT ALL CORRESPONDING
  SELECT bool, double AS float FROM SimpleTypes
)
--
QueryStmt
+-output_column_list=
| +-$union_all.int64#66 AS int64 [INT64]
| +-$union_all.int32#67 AS int32 [INT32]
| +-$union_all.float#68 AS float [DOUBLE]
| +-$union_all.double#69 AS double [DOUBLE]
| +-$union_all.bool#70 AS bool [BOOL]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int64#66, int32#67, float#68, double#69, bool#70]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.int64#2, SimpleTypes.int32#1, $null_column_for_outer_set_op.float#71, $null_column_for_outer_set_op.double#72, $null_column_for_outer_set_op.bool#73]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-float#71 := Literal(type=DOUBLE, value=NULL)
    | | |   | +-double#72 := Literal(type=DOUBLE, value=NULL)
    | | |   | +-bool#73 := Literal(type=BOOL, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=[SimpleTypes.int64#2, SimpleTypes.int32#1, $null_column_for_outer_set_op.float#71, $null_column_for_outer_set_op.double#72, $null_column_for_outer_set_op.bool#73]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$intersect_all.int64#60, $null_column_for_outer_set_op.int32#74, $intersect_all.float#58, $intersect_all.double#59, $intersect_all.bool#61]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-int32#74 := Literal(type=INT32, value=NULL)
    |   |   +-input_scan=
    |   |     +-SetOperationScan
    |   |       +-column_list=$intersect_all.[float#58, double#59, int64#60, bool#61]
    |   |       +-op_type=INTERSECT_ALL
    |   |       +-input_item_list=
    |   |       | +-SetOperationItem
    |   |       | | +-scan=
    |   |       | | | +-ProjectScan
    |   |       | | |   +-column_list=[$intersect_all1_cast.float#62, SimpleTypes.double#28, SimpleTypes.int64#21, $null_column_for_outer_set_op.bool#63]
    |   |       | | |   +-node_source="resolver_set_operation_corresponding"
    |   |       | | |   +-expr_list=
    |   |       | | |   | +-bool#63 := Literal(type=BOOL, value=NULL)
    |   |       | | |   +-input_scan=
    |   |       | | |     +-ProjectScan
    |   |       | | |       +-column_list=[$intersect_all1_cast.float#62, SimpleTypes.double#28, SimpleTypes.int64#21]
    |   |       | | |       +-expr_list=
    |   |       | | |       | +-float#62 :=
    |   |       | | |       |   +-Cast(FLOAT -> DOUBLE)
    |   |       | | |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#27)
    |   |       | | |       +-input_scan=
    |   |       | | |         +-ProjectScan
    |   |       | | |           +-column_list=SimpleTypes.[float#27, double#28, int64#21]
    |   |       | | |           +-input_scan=
    |   |       | | |             +-TableScan(column_list=SimpleTypes.[int64#21, float#27, double#28], table=SimpleTypes, column_index_list=[1, 7, 8])
    |   |       | | +-output_column_list=[$intersect_all1_cast.float#62, SimpleTypes.double#28, SimpleTypes.int64#21, $null_column_for_outer_set_op.bool#63]
    |   |       | +-SetOperationItem
    |   |       |   +-scan=
    |   |       |   | +-ProjectScan
    |   |       |   |   +-column_list=[SimpleTypes.double#47, $null_column_for_outer_set_op.double#64, $null_column_for_outer_set_op.int64#65, SimpleTypes.bool#45]
    |   |       |   |   +-node_source="resolver_set_operation_corresponding"
    |   |       |   |   +-expr_list=
    |   |       |   |   | +-double#64 := Literal(type=DOUBLE, value=NULL)
    |   |       |   |   | +-int64#65 := Literal(type=INT64, value=NULL)
    |   |       |   |   +-input_scan=
    |   |       |   |     +-ProjectScan
    |   |       |   |       +-column_list=SimpleTypes.[bool#45, double#47]
    |   |       |   |       +-input_scan=
    |   |       |   |         +-TableScan(column_list=SimpleTypes.[bool#45, double#47], table=SimpleTypes, column_index_list=[6, 8])
    |   |       |   +-output_column_list=[SimpleTypes.double#47, $null_column_for_outer_set_op.double#64, $null_column_for_outer_set_op.int64#65, SimpleTypes.bool#45]
    |   |       +-column_match_mode=CORRESPONDING
    |   |       +-column_propagation_mode=FULL
    |   +-output_column_list=[$intersect_all.int64#60, $null_column_for_outer_set_op.int32#74, $intersect_all.float#58, $intersect_all.double#59, $intersect_all.bool#61]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: nested queries.
(
  SELECT float, double, int64 FROM SimpleTypes
  FULL INTERSECT ALL CORRESPONDING
  SELECT bool, double AS float FROM SimpleTypes
)
FULL UNION ALL CORRESPONDING
SELECT int64, int32 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.float#66 AS float [DOUBLE]
| +-$union_all.double#67 AS double [DOUBLE]
| +-$union_all.int64#68 AS int64 [INT64]
| +-$union_all.bool#69 AS bool [BOOL]
| +-$union_all.int32#70 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[float#66, double#67, int64#68, bool#69, int32#70]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$intersect_all.float#39, $intersect_all.double#40, $intersect_all.int64#41, $intersect_all.bool#42, $null_column_for_outer_set_op.int32#71]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-int32#71 := Literal(type=INT32, value=NULL)
    | | |   +-input_scan=
    | | |     +-SetOperationScan
    | | |       +-column_list=$intersect_all.[float#39, double#40, int64#41, bool#42]
    | | |       +-op_type=INTERSECT_ALL
    | | |       +-input_item_list=
    | | |       | +-SetOperationItem
    | | |       | | +-scan=
    | | |       | | | +-ProjectScan
    | | |       | | |   +-column_list=[$intersect_all1_cast.float#43, SimpleTypes.double#9, SimpleTypes.int64#2, $null_column_for_outer_set_op.bool#44]
    | | |       | | |   +-node_source="resolver_set_operation_corresponding"
    | | |       | | |   +-expr_list=
    | | |       | | |   | +-bool#44 := Literal(type=BOOL, value=NULL)
    | | |       | | |   +-input_scan=
    | | |       | | |     +-ProjectScan
    | | |       | | |       +-column_list=[$intersect_all1_cast.float#43, SimpleTypes.double#9, SimpleTypes.int64#2]
    | | |       | | |       +-expr_list=
    | | |       | | |       | +-float#43 :=
    | | |       | | |       |   +-Cast(FLOAT -> DOUBLE)
    | | |       | | |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
    | | |       | | |       +-input_scan=
    | | |       | | |         +-ProjectScan
    | | |       | | |           +-column_list=SimpleTypes.[float#8, double#9, int64#2]
    | | |       | | |           +-input_scan=
    | | |       | | |             +-TableScan(column_list=SimpleTypes.[int64#2, float#8, double#9], table=SimpleTypes, column_index_list=[1, 7, 8])
    | | |       | | +-output_column_list=[$intersect_all1_cast.float#43, SimpleTypes.double#9, SimpleTypes.int64#2, $null_column_for_outer_set_op.bool#44]
    | | |       | +-SetOperationItem
    | | |       |   +-scan=
    | | |       |   | +-ProjectScan
    | | |       |   |   +-column_list=[SimpleTypes.double#28, $null_column_for_outer_set_op.double#45, $null_column_for_outer_set_op.int64#46, SimpleTypes.bool#26]
    | | |       |   |   +-node_source="resolver_set_operation_corresponding"
    | | |       |   |   +-expr_list=
    | | |       |   |   | +-double#45 := Literal(type=DOUBLE, value=NULL)
    | | |       |   |   | +-int64#46 := Literal(type=INT64, value=NULL)
    | | |       |   |   +-input_scan=
    | | |       |   |     +-ProjectScan
    | | |       |   |       +-column_list=SimpleTypes.[bool#26, double#28]
    | | |       |   |       +-input_scan=
    | | |       |   |         +-TableScan(column_list=SimpleTypes.[bool#26, double#28], table=SimpleTypes, column_index_list=[6, 8])
    | | |       |   +-output_column_list=[SimpleTypes.double#28, $null_column_for_outer_set_op.double#45, $null_column_for_outer_set_op.int64#46, SimpleTypes.bool#26]
    | | |       +-column_match_mode=CORRESPONDING
    | | |       +-column_propagation_mode=FULL
    | | +-output_column_list=[$intersect_all.float#39, $intersect_all.double#40, $intersect_all.int64#41, $intersect_all.bool#42, $null_column_for_outer_set_op.int32#71]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.float#72, $null_column_for_outer_set_op.double#73, SimpleTypes.int64#48, $null_column_for_outer_set_op.bool#74, SimpleTypes.int32#47]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-float#72 := Literal(type=DOUBLE, value=NULL)
    |   |   | +-double#73 := Literal(type=DOUBLE, value=NULL)
    |   |   | +-bool#74 := Literal(type=BOOL, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int64#48, int32#47]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#47, int64#48], table=SimpleTypes, column_index_list=[0, 1])
    |   +-output_column_list=[$null_column_for_outer_set_op.float#72, $null_column_for_outer_set_op.double#73, SimpleTypes.int64#48, $null_column_for_outer_set_op.bool#74, SimpleTypes.int32#47]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: Basic LEFT mode: no common columns.
SELECT 1 AS a
LEFT UNION ALL CORRESPONDING
SELECT 1 AS b
--
ERROR: Query 2 of the set operation with LEFT mode does not share common columns with the first query [at 2:6]
LEFT UNION ALL CORRESPONDING
     ^
==

# CORRESPONDING: Basic LEFT mode: first query misses columns.
SELECT 1 AS a
LEFT UNION ALL CORRESPONDING
SELECT 1 AS a, 2 AS b
--
QueryStmt
+-output_column_list=
| +-$union_all.a#4 AS a [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.a#4]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.a#1]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.a#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.a#2]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[a#2, b#3]
    |   |       +-expr_list=
    |   |       | +-a#2 := Literal(type=INT64, value=1)
    |   |       | +-b#3 := Literal(type=INT64, value=2)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2.a#2]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: Basic LEFT mode: second query misses columns.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL CORRESPONDING
SELECT 1 AS a
--
QueryStmt
+-output_column_list=
| +-$union_all.a#4 AS a [INT64]
| +-$union_all.b#5 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#4, b#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.a#3, $null_column_for_outer_set_op.b#6]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-b#6 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.a#3]
    |   |       +-expr_list=
    |   |       | +-a#3 := Literal(type=INT64, value=1)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2.a#3, $null_column_for_outer_set_op.b#6]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: Basic LEFT mode: second query misses columns.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL CORRESPONDING
SELECT 2 AS b
--
QueryStmt
+-output_column_list=
| +-$union_all.a#4 AS a [INT64]
| +-$union_all.b#5 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#4, b#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#6, $union_all2.b#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#6 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.b#3]
    |   |       +-expr_list=
    |   |       | +-b#3 := Literal(type=INT64, value=2)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.a#6, $union_all2.b#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: Basic LEFT mode: both queries miss columns
SELECT 1 AS a, 2 AS b
LEFT UNION ALL CORRESPONDING
SELECT 2 AS b, 3 AS c
--
QueryStmt
+-output_column_list=
| +-$union_all.a#5 AS a [INT64]
| +-$union_all.b#6 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#5, b#6]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#7, $union_all2.b#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#7 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[b#3, c#4]
    |   |       +-expr_list=
    |   |       | +-b#3 := Literal(type=INT64, value=2)
    |   |       | +-c#4 := Literal(type=INT64, value=3)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.a#7, $union_all2.b#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: Basic LEFT mode: no queries miss columns.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL CORRESPONDING
SELECT 2 AS b, 3 AS a
--
QueryStmt
+-output_column_list=
| +-$union_all.a#5 AS a [INT64]
| +-$union_all.b#6 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#5, b#6]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[a#4, b#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[b#3, a#4]
    |   |       +-expr_list=
    |   |       | +-b#3 := Literal(type=INT64, value=2)
    |   |       | +-a#4 := Literal(type=INT64, value=3)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$union_all2.[a#4, b#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode multiple expressions.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL CORRESPONDING
SELECT 2 AS b, 3 AS c
LEFT UNION ALL CORRESPONDING
SELECT 2 AS c, 1 AS a
--
QueryStmt
+-output_column_list=
| +-$union_all.a#7 AS a [INT64]
| +-$union_all.b#8 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#7, b#8]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.a#9, $union_all2.b#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-a#9 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all2.[b#3, c#4]
    | | |       +-expr_list=
    | | |       | +-b#3 := Literal(type=INT64, value=2)
    | | |       | +-c#4 := Literal(type=INT64, value=3)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$null_column_for_outer_set_op.a#9, $union_all2.b#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all3.a#6, $null_column_for_outer_set_op.b#10]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-b#10 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all3.[c#5, a#6]
    |   |       +-expr_list=
    |   |       | +-c#5 := Literal(type=INT64, value=2)
    |   |       | +-a#6 := Literal(type=INT64, value=1)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all3.a#6, $null_column_for_outer_set_op.b#10]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode multiple expressions no common columns.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL CORRESPONDING
SELECT 2 AS c, 3 AS d
LEFT UNION ALL CORRESPONDING
SELECT 2 AS d, 1 AS c
--
ERROR: Query 2 of the set operation with LEFT mode does not share common columns with the first query [at 2:6]
LEFT UNION ALL CORRESPONDING
     ^
==

# CORRESPONDING: LEFT: A column has incompatible types.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL CORRESPONDING
SELECT 1 as a
LEFT UNION ALL CORRESPONDING
SELECT FALSE AS b
--
ERROR: Column b in UNION ALL has incompatible types: INT64, NULL, BOOL [at 3:1]
SELECT 1 as a
^
==

# CORRESPONDING: LEFT: Not selected columns allowed to have incompatible types.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL CORRESPONDING
SELECT 1 as b, FALSE AS c
LEFT UNION ALL CORRESPONDING
SELECT 100 AS c, 1 AS b
--
QueryStmt
+-output_column_list=
| +-$union_all.a#7 AS a [INT64]
| +-$union_all.b#8 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#7, b#8]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.a#9, $union_all2.b#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-a#9 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all2.[b#3, c#4]
    | | |       +-expr_list=
    | | |       | +-b#3 := Literal(type=INT64, value=1)
    | | |       | +-c#4 := Literal(type=BOOL, value=false)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$null_column_for_outer_set_op.a#9, $union_all2.b#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#10, $union_all3.b#6]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#10 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all3.[c#5, b#6]
    |   |       +-expr_list=
    |   |       | +-c#5 := Literal(type=INT64, value=100)
    |   |       | +-b#6 := Literal(type=INT64, value=1)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.a#10, $union_all3.b#6]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode multiple expressions.
SELECT int64, int32 FROM SimpleTypes
LEFT INTERSECT ALL CORRESPONDING
SELECT int32, uint64 FROM SimpleTypes
LEFT INTERSECT ALL CORRESPONDING
SELECT int32, float FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$intersect_all.int64#58 AS int64 [INT64]
| +-$intersect_all.int32#59 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[int64#58, int32#59]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=SimpleTypes.[int64#2, int32#1]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.int64#60, SimpleTypes.int32#20]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-int64#60 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int32#20, uint64#23]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#20, uint64#23], table=SimpleTypes, column_index_list=[0, 3])
    | | +-output_column_list=[$null_column_for_outer_set_op.int64#60, SimpleTypes.int32#20]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.int64#61, SimpleTypes.int32#39]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-int64#61 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#39, float#46]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#39, float#46], table=SimpleTypes, column_index_list=[0, 7])
    |   +-output_column_list=[$null_column_for_outer_set_op.int64#61, SimpleTypes.int32#39]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode with multiple expressions: Type coercion for NULL
# columns.
SELECT int64 AS a, int32 AS b FROM SimpleTypes
LEFT INTERSECT ALL CORRESPONDING
SELECT int32 AS b FROM SimpleTypes
LEFT INTERSECT ALL CORRESPONDING
SELECT uint32 AS b, float AS a FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$intersect_all.a#58 AS a [DOUBLE]
| +-$intersect_all.b#59 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[a#58, b#59]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1_cast.[int64#60, int32#61]
    | | |   +-expr_list=
    | | |   | +-int64#60 :=
    | | |   | | +-Cast(INT64 -> DOUBLE)
    | | |   | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | | |   | +-int32#61 :=
    | | |   |   +-Cast(INT32 -> INT64)
    | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=$intersect_all1_cast.[int64#60, int32#61]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.a#65, $intersect_all2_cast.int32#62]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-a#65 := Literal(type=DOUBLE, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$intersect_all2_cast.int32#62]
    | | |       +-expr_list=
    | | |       | +-int32#62 :=
    | | |       |   +-Cast(INT32 -> INT64)
    | | |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=[SimpleTypes.int32#20]
    | | |           +-input_scan=
    | | |             +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    | | +-output_column_list=[$null_column_for_outer_set_op.a#65, $intersect_all2_cast.int32#62]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_all3_cast.[float#64, uint32#63]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$intersect_all3_cast.[uint32#63, float#64]
    |   |       +-expr_list=
    |   |       | +-uint32#63 :=
    |   |       | | +-Cast(UINT32 -> INT64)
    |   |       | |   +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#41)
    |   |       | +-float#64 :=
    |   |       |   +-Cast(FLOAT -> DOUBLE)
    |   |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#46)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[uint32#41, float#46]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=SimpleTypes.[uint32#41, float#46], table=SimpleTypes, column_index_list=[2, 7])
    |   +-output_column_list=$intersect_all3_cast.[float#64, uint32#63]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode with multiple expressions: Type coercion does not
# happen for non-selected columns.
SELECT int64 AS a, int32 AS b FROM SimpleTypes
LEFT INTERSECT ALL CORRESPONDING
SELECT uint32 AS b, int32 AS c FROM SimpleTypes
LEFT INTERSECT ALL CORRESPONDING
SELECT uint32 AS c, float AS a FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$intersect_all.a#58 AS a [DOUBLE]
| +-$intersect_all.b#59 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[a#58, b#59]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1_cast.[int64#60, int32#61]
    | | |   +-expr_list=
    | | |   | +-int64#60 :=
    | | |   | | +-Cast(INT64 -> DOUBLE)
    | | |   | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | | |   | +-int32#61 :=
    | | |   |   +-Cast(INT32 -> INT64)
    | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=$intersect_all1_cast.[int64#60, int32#61]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.a#64, $intersect_all2_cast.uint32#62]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-a#64 := Literal(type=DOUBLE, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$intersect_all2_cast.uint32#62, SimpleTypes.int32#20]
    | | |       +-expr_list=
    | | |       | +-uint32#62 :=
    | | |       |   +-Cast(UINT32 -> INT64)
    | | |       |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#22)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=SimpleTypes.[uint32#22, int32#20]
    | | |           +-input_scan=
    | | |             +-TableScan(column_list=SimpleTypes.[int32#20, uint32#22], table=SimpleTypes, column_index_list=[0, 2])
    | | +-output_column_list=[$null_column_for_outer_set_op.a#64, $intersect_all2_cast.uint32#62]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$intersect_all3_cast.float#63, $null_column_for_outer_set_op.b#65]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-b#65 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[SimpleTypes.uint32#41, $intersect_all3_cast.float#63]
    |   |       +-expr_list=
    |   |       | +-float#63 :=
    |   |       |   +-Cast(FLOAT -> DOUBLE)
    |   |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#46)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[uint32#41, float#46]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=SimpleTypes.[uint32#41, float#46], table=SimpleTypes, column_index_list=[2, 7])
    |   +-output_column_list=[$intersect_all3_cast.float#63, $null_column_for_outer_set_op.b#65]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode with duplicate columns of different names.
SELECT int64 AS a, int64 AS b FROM SimpleTypes
LEFT UNION ALL CORRESPONDING
SELECT int32 AS b, int32 AS c FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.a#39 AS a [INT64]
| +-$union_all.b#40 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#39, b#40]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[int64#2, int64#2]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
    | | +-output_column_list=SimpleTypes.[int64#2, int64#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#42, $union_all2_cast.int32#41]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#42 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2_cast.int32#41, SimpleTypes.int32#20]
    |   |       +-expr_list=
    |   |       | +-int32#41 :=
    |   |       |   +-Cast(INT32 -> INT64)
    |   |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[int32#20, int32#20]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    |   +-output_column_list=[$null_column_for_outer_set_op.a#42, $union_all2_cast.int32#41]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode with duplicate columns of different names.
SELECT int64 AS a, int64 AS b, int32 AS c, int64 AS d FROM SimpleTypes
LEFT UNION ALL CORRESPONDING
SELECT int32 AS b, int32 AS d, int32 AS e FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.a#39 AS a [INT64]
| +-$union_all.b#40 AS b [INT64]
| +-$union_all.c#41 AS c [INT32]
| +-$union_all.d#42 AS d [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#39, b#40, c#41, d#42]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[int64#2, int64#2, int32#1, int64#2]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=SimpleTypes.[int64#2, int64#2, int32#1, int64#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#45, $union_all2_cast.int32#43, $null_column_for_outer_set_op.c#46, $union_all2_cast.int32#44]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#45 := Literal(type=INT64, value=NULL)
    |   |   | +-c#46 := Literal(type=INT32, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2_cast.int32#43, $union_all2_cast.int32#44, SimpleTypes.int32#20]
    |   |       +-expr_list=
    |   |       | +-int32#43 :=
    |   |       | | +-Cast(INT32 -> INT64)
    |   |       | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       | +-int32#44 :=
    |   |       |   +-Cast(INT32 -> INT64)
    |   |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[int32#20, int32#20, int32#20]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    |   +-output_column_list=[$null_column_for_outer_set_op.a#45, $union_all2_cast.int32#43, $null_column_for_outer_set_op.c#46, $union_all2_cast.int32#44]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT nested queries.
SELECT int64, int32 FROM SimpleTypes
LEFT UNION ALL CORRESPONDING (
  SELECT float, double, int64 FROM SimpleTypes
  LEFT INTERSECT ALL CORRESPONDING
  SELECT bool, double AS float FROM SimpleTypes
)
--
QueryStmt
+-output_column_list=
| +-$union_all.int64#64 AS int64 [INT64]
| +-$union_all.int32#65 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int64#64, int32#65]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=SimpleTypes.[int64#2, int32#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$intersect_all.int64#60, $null_column_for_outer_set_op.int32#66]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-int32#66 := Literal(type=INT32, value=NULL)
    |   |   +-input_scan=
    |   |     +-SetOperationScan
    |   |       +-column_list=$intersect_all.[float#58, double#59, int64#60]
    |   |       +-op_type=INTERSECT_ALL
    |   |       +-input_item_list=
    |   |       | +-SetOperationItem
    |   |       | | +-scan=
    |   |       | | | +-ProjectScan
    |   |       | | |   +-column_list=[$intersect_all1_cast.float#61, SimpleTypes.double#28, SimpleTypes.int64#21]
    |   |       | | |   +-expr_list=
    |   |       | | |   | +-float#61 :=
    |   |       | | |   |   +-Cast(FLOAT -> DOUBLE)
    |   |       | | |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#27)
    |   |       | | |   +-input_scan=
    |   |       | | |     +-ProjectScan
    |   |       | | |       +-column_list=SimpleTypes.[float#27, double#28, int64#21]
    |   |       | | |       +-input_scan=
    |   |       | | |         +-TableScan(column_list=SimpleTypes.[int64#21, float#27, double#28], table=SimpleTypes, column_index_list=[1, 7, 8])
    |   |       | | +-output_column_list=[$intersect_all1_cast.float#61, SimpleTypes.double#28, SimpleTypes.int64#21]
    |   |       | +-SetOperationItem
    |   |       |   +-scan=
    |   |       |   | +-ProjectScan
    |   |       |   |   +-column_list=[SimpleTypes.double#47, $null_column_for_outer_set_op.double#62, $null_column_for_outer_set_op.int64#63]
    |   |       |   |   +-node_source="resolver_set_operation_corresponding"
    |   |       |   |   +-expr_list=
    |   |       |   |   | +-double#62 := Literal(type=DOUBLE, value=NULL)
    |   |       |   |   | +-int64#63 := Literal(type=INT64, value=NULL)
    |   |       |   |   +-input_scan=
    |   |       |   |     +-ProjectScan
    |   |       |   |       +-column_list=SimpleTypes.[bool#45, double#47]
    |   |       |   |       +-input_scan=
    |   |       |   |         +-TableScan(column_list=SimpleTypes.[bool#45, double#47], table=SimpleTypes, column_index_list=[6, 8])
    |   |       |   +-output_column_list=[SimpleTypes.double#47, $null_column_for_outer_set_op.double#62, $null_column_for_outer_set_op.int64#63]
    |   |       +-column_match_mode=CORRESPONDING
    |   |       +-column_propagation_mode=LEFT
    |   +-output_column_list=[$intersect_all.int64#60, $null_column_for_outer_set_op.int32#66]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT nested queries.
(
  SELECT float, double, int64 FROM SimpleTypes
  LEFT INTERSECT ALL CORRESPONDING
  SELECT bool, double AS float FROM SimpleTypes
)
LEFT UNION ALL CORRESPONDING
SELECT int64, int32 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.float#64 AS float [DOUBLE]
| +-$union_all.double#65 AS double [DOUBLE]
| +-$union_all.int64#66 AS int64 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[float#64, double#65, int64#66]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-SetOperationScan
    | | |   +-column_list=$intersect_all.[float#39, double#40, int64#41]
    | | |   +-op_type=INTERSECT_ALL
    | | |   +-input_item_list=
    | | |   | +-SetOperationItem
    | | |   | | +-scan=
    | | |   | | | +-ProjectScan
    | | |   | | |   +-column_list=[$intersect_all1_cast.float#42, SimpleTypes.double#9, SimpleTypes.int64#2]
    | | |   | | |   +-expr_list=
    | | |   | | |   | +-float#42 :=
    | | |   | | |   |   +-Cast(FLOAT -> DOUBLE)
    | | |   | | |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
    | | |   | | |   +-input_scan=
    | | |   | | |     +-ProjectScan
    | | |   | | |       +-column_list=SimpleTypes.[float#8, double#9, int64#2]
    | | |   | | |       +-input_scan=
    | | |   | | |         +-TableScan(column_list=SimpleTypes.[int64#2, float#8, double#9], table=SimpleTypes, column_index_list=[1, 7, 8])
    | | |   | | +-output_column_list=[$intersect_all1_cast.float#42, SimpleTypes.double#9, SimpleTypes.int64#2]
    | | |   | +-SetOperationItem
    | | |   |   +-scan=
    | | |   |   | +-ProjectScan
    | | |   |   |   +-column_list=[SimpleTypes.double#28, $null_column_for_outer_set_op.double#43, $null_column_for_outer_set_op.int64#44]
    | | |   |   |   +-node_source="resolver_set_operation_corresponding"
    | | |   |   |   +-expr_list=
    | | |   |   |   | +-double#43 := Literal(type=DOUBLE, value=NULL)
    | | |   |   |   | +-int64#44 := Literal(type=INT64, value=NULL)
    | | |   |   |   +-input_scan=
    | | |   |   |     +-ProjectScan
    | | |   |   |       +-column_list=SimpleTypes.[bool#26, double#28]
    | | |   |   |       +-input_scan=
    | | |   |   |         +-TableScan(column_list=SimpleTypes.[bool#26, double#28], table=SimpleTypes, column_index_list=[6, 8])
    | | |   |   +-output_column_list=[SimpleTypes.double#28, $null_column_for_outer_set_op.double#43, $null_column_for_outer_set_op.int64#44]
    | | |   +-column_match_mode=CORRESPONDING
    | | |   +-column_propagation_mode=LEFT
    | | +-output_column_list=$intersect_all.[float#39, double#40, int64#41]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.float#67, $null_column_for_outer_set_op.double#68, SimpleTypes.int64#46]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-float#67 := Literal(type=DOUBLE, value=NULL)
    |   |   | +-double#68 := Literal(type=DOUBLE, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int64#46, int32#45]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#45, int64#46], table=SimpleTypes, column_index_list=[0, 1])
    |   +-output_column_list=[$null_column_for_outer_set_op.float#67, $null_column_for_outer_set_op.double#68, SimpleTypes.int64#46]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT nested queries: no common columns.
(
  SELECT float, double, int64 FROM SimpleTypes
  LEFT INTERSECT ALL CORRESPONDING
  SELECT bool, double AS float FROM SimpleTypes
)
LEFT UNION ALL CORRESPONDING
SELECT int32 FROM SimpleTypes
--
ERROR: Query 2 of the set operation with LEFT mode does not share common columns with the first query [at 6:6]
LEFT UNION ALL CORRESPONDING
     ^
==

# CORRESPONDING: LEFT first query is select distinct with duplicate columns.
SELECT DISTINCT a AS col1, a AS col2
FROM (
  SELECT 1 AS a
)
LEFT UNION ALL CORRESPONDING
SELECT 1 AS col1, 2 AS col2
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#5 AS col1 [INT64]
| +-$union_all.col2#6 AS col2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col1#5, col2#6]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$distinct.[a#2, a#2]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-AggregateScan
    | | |       +-column_list=[$distinct.a#2]
    | | |       +-input_scan=
    | | |       | +-ProjectScan
    | | |       |   +-column_list=[$subquery1.a#1]
    | | |       |   +-expr_list=
    | | |       |   | +-a#1 := Literal(type=INT64, value=1)
    | | |       |   +-input_scan=
    | | |       |     +-SingleRowScan
    | | |       +-group_by_list=
    | | |         +-a#2 := ColumnRef(type=INT64, column=$subquery1.a#1)
    | | +-output_column_list=$distinct.[a#2, a#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[col1#3, col2#4]
    |   |   +-expr_list=
    |   |   | +-col1#3 := Literal(type=INT64, value=1)
    |   |   | +-col2#4 := Literal(type=INT64, value=2)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$union_all2.[col1#3, col2#4]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# Literal coercion is correctly handled: INNER mode.
SELECT CAST(1 AS INT32) AS A, NULL AS B
INTERSECT ALL CORRESPONDING
SELECT CAST("STRING_VAL" AS STRING) AS B, 100 AS A
--
QueryStmt
+-output_column_list=
| +-$intersect_all.A#5 AS A [INT32]
| +-$intersect_all.B#6 AS B [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[A#5, B#6]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$intersect_all1.A#1, $intersect_all1_cast.B#7]
    | | |   +-expr_list=
    | | |   | +-B#7 := Literal(type=STRING, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$intersect_all1.[A#1, B#2]
    | | |       +-expr_list=
    | | |       | +-A#1 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    | | |       | +-B#2 := Literal(type=INT64, value=NULL)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$intersect_all1.A#1, $intersect_all1_cast.B#7]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$intersect_all2_cast.A#8, $intersect_all2.B#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$intersect_all2.B#3, $intersect_all2_cast.A#8]
    |   |       +-expr_list=
    |   |       | +-A#8 := Literal(type=INT32, value=100)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=$intersect_all2.[B#3, A#4]
    |   |           +-expr_list=
    |   |           | +-B#3 := Literal(type=STRING, value="STRING_VAL", has_explicit_type=TRUE)
    |   |           | +-A#4 := Literal(type=INT64, value=100)
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-output_column_list=[$intersect_all2_cast.A#8, $intersect_all2.B#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# Literal cocercion is correctly handled when NULL columns are padded for FULL
# mode.
SELECT NULL AS A
FULL UNION ALL CORRESPONDING
SELECT 1 AS B, CAST(NULL AS ARRAY<STRUCT<STRING, STRING>>) AS A
--
QueryStmt
+-output_column_list=
| +-$union_all.A#4 AS A [ARRAY<STRUCT<STRING, STRING>>]
| +-$union_all.B#5 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#4, B#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.A#6, $null_column_for_outer_set_op.B#7]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-B#7 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1_cast.A#6]
    | | |       +-expr_list=
    | | |       | +-A#6 := Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=NULL)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=[$union_all1.A#1]
    | | |           +-expr_list=
    | | |           | +-A#1 := Literal(type=INT64, value=NULL)
    | | |           +-input_scan=
    | | |             +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.A#6, $null_column_for_outer_set_op.B#7]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[A#3, B#2]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[B#2, A#3]
    |   |       +-expr_list=
    |   |       | +-B#2 := Literal(type=INT64, value=1)
    |   |       | +-A#3 := Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=NULL, has_explicit_type=TRUE)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$union_all2.[A#3, B#2]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# Literal cocercion is correctly handled when NULL columns are padded for FULL
# mode.
SELECT NULL AS A, 1 AS B, 3 AS C
FULL UNION ALL CORRESPONDING
SELECT 1 AS B, CAST(NULL AS ARRAY<STRUCT<STRING, STRING>>) AS A
--
QueryStmt
+-output_column_list=
| +-$union_all.A#6 AS A [ARRAY<STRUCT<STRING, STRING>>]
| +-$union_all.B#7 AS B [INT64]
| +-$union_all.C#8 AS C [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#6, B#7, C#8]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.A#9, $union_all1.B#2, $union_all1.C#3]
    | | |   +-expr_list=
    | | |   | +-A#9 := Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all1.[A#1, B#2, C#3]
    | | |       +-expr_list=
    | | |       | +-A#1 := Literal(type=INT64, value=NULL)
    | | |       | +-B#2 := Literal(type=INT64, value=1)
    | | |       | +-C#3 := Literal(type=INT64, value=3)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.A#9, $union_all1.B#2, $union_all1.C#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.A#5, $union_all2.B#4, $null_column_for_outer_set_op.C#10]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-C#10 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[B#4, A#5]
    |   |       +-expr_list=
    |   |       | +-B#4 := Literal(type=INT64, value=1)
    |   |       | +-A#5 := Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=NULL, has_explicit_type=TRUE)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2.A#5, $union_all2.B#4, $null_column_for_outer_set_op.C#10]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# Literal coercion is correctly handled when NULL columns are padded for FULL
# mode.
SELECT CAST(1 AS INT32) AS A, "STRING_VAL" AS B
FULL UNION DISTINCT CORRESPONDING
SELECT NULL AS B
--
QueryStmt
+-output_column_list=
| +-$union_distinct.A#4 AS A [INT32]
| +-$union_distinct.B#5 AS B [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_distinct.[A#4, B#5]
    +-op_type=UNION_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_distinct1.[A#1, B#2]
    | | |   +-expr_list=
    | | |   | +-A#1 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    | | |   | +-B#2 := Literal(type=STRING, value="STRING_VAL")
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_distinct1.[A#1, B#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.A#7, $union_distinct2_cast.B#6]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-A#7 := Literal(type=INT32, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_distinct2_cast.B#6]
    |   |       +-expr_list=
    |   |       | +-B#6 := Literal(type=STRING, value=NULL)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=[$union_distinct2.B#3]
    |   |           +-expr_list=
    |   |           | +-B#3 := Literal(type=INT64, value=NULL)
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.A#7, $union_distinct2_cast.B#6]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# Literal coercion is correctly handled when NULL columns are padded for FULL
# mode.
SELECT CAST(1 AS INT32) AS A, "STRING_VAL" AS B
FULL UNION DISTINCT CORRESPONDING
SELECT NULL AS B, 1 AS A, "NO_MATCHING" AS C
--
QueryStmt
+-output_column_list=
| +-$union_distinct.A#6 AS A [INT32]
| +-$union_distinct.B#7 AS B [STRING]
| +-$union_distinct.C#8 AS C [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_distinct.[A#6, B#7, C#8]
    +-op_type=UNION_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_distinct1.A#1, $union_distinct1.B#2, $null_column_for_outer_set_op.C#11]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-C#11 := Literal(type=STRING, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_distinct1.[A#1, B#2]
    | | |       +-expr_list=
    | | |       | +-A#1 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    | | |       | +-B#2 := Literal(type=STRING, value="STRING_VAL")
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_distinct1.A#1, $union_distinct1.B#2, $null_column_for_outer_set_op.C#11]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_distinct2_cast.A#10, $union_distinct2_cast.B#9, $union_distinct2.C#5]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_distinct2_cast.B#9, $union_distinct2_cast.A#10, $union_distinct2.C#5]
    |   |       +-expr_list=
    |   |       | +-B#9 := Literal(type=STRING, value=NULL)
    |   |       | +-A#10 := Literal(type=INT32, value=1)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=$union_distinct2.[B#3, A#4, C#5]
    |   |           +-expr_list=
    |   |           | +-B#3 := Literal(type=INT64, value=NULL)
    |   |           | +-A#4 := Literal(type=INT64, value=1)
    |   |           | +-C#5 := Literal(type=STRING, value="NO_MATCHING")
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-output_column_list=[$union_distinct2_cast.A#10, $union_distinct2_cast.B#9, $union_distinct2.C#5]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# Literal coercion is correctly handled when NULL columns are padded for LEFT
# mode.
SELECT NULL AS A, 2 AS B
LEFT UNION ALL CORRESPONDING
SELECT CAST(1 AS INT32) AS A
--
QueryStmt
+-output_column_list=
| +-$union_all.A#4 AS A [INT32]
| +-$union_all.B#5 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#4, B#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.A#6, $union_all1.B#2]
    | | |   +-expr_list=
    | | |   | +-A#6 := Literal(type=INT32, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all1.[A#1, B#2]
    | | |       +-expr_list=
    | | |       | +-A#1 := Literal(type=INT64, value=NULL)
    | | |       | +-B#2 := Literal(type=INT64, value=2)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.A#6, $union_all1.B#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.A#3, $null_column_for_outer_set_op.B#7]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-B#7 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.A#3]
    |   |       +-expr_list=
    |   |       | +-A#3 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2.A#3, $null_column_for_outer_set_op.B#7]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# Literal coercion is correctly handled when NULL columns are padded for LEFT
# mode.
SELECT CAST(1 AS INT32) AS A, 2 AS B
LEFT UNION ALL CORRESPONDING
SELECT NULL AS A
--
QueryStmt
+-output_column_list=
| +-$union_all.A#4 AS A [INT32]
| +-$union_all.B#5 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#4, B#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[A#1, B#2]
    | | |   +-expr_list=
    | | |   | +-A#1 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    | | |   | +-B#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[A#1, B#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.A#6, $null_column_for_outer_set_op.B#7]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-B#7 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2_cast.A#6]
    |   |       +-expr_list=
    |   |       | +-A#6 := Literal(type=INT32, value=NULL)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=[$union_all2.A#3]
    |   |           +-expr_list=
    |   |           | +-A#3 := Literal(type=INT64, value=NULL)
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-output_column_list=[$union_all2_cast.A#6, $null_column_for_outer_set_op.B#7]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: Basic STRICT.
SELECT 1 AS a, 2 AS b
UNION ALL STRICT CORRESPONDING
SELECT 2 AS b, 1 AS a
--
QueryStmt
+-output_column_list=
| +-$union_all.a#5 AS a [INT64]
| +-$union_all.b#6 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#5, b#6]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[a#4, b#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[b#3, a#4]
    |   |       +-expr_list=
    |   |       | +-b#3 := Literal(type=INT64, value=2)
    |   |       | +-a#4 := Literal(type=INT64, value=1)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$union_all2.[a#4, b#3]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: Basic STRICT: column names must be identical.
SELECT 1 AS a, 2 AS b
UNION ALL STRICT CORRESPONDING
SELECT 2 AS b
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but the first query has [a, b] and query 2 has [b] [at 2:1]
UNION ALL STRICT CORRESPONDING
^
==

# CORRESPONDING: Basic STRICT: column names must be identical.
SELECT 1 AS a
UNION ALL STRICT CORRESPONDING
SELECT 2 AS b, 3 AS c, 2 AS a
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but the first query has [a] and query 2 has [b, c, a] [at 2:1]
UNION ALL STRICT CORRESPONDING
^
==

# CORRESPONDING: Basic STRICT: column names must be identical.
SELECT 1 AS a, 2 AS b
UNION ALL STRICT CORRESPONDING
SELECT 2 AS b, 3 AS c
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but the first query has [a, b] and query 2 has [b, c] [at 2:1]
UNION ALL STRICT CORRESPONDING
^
==

# CORRESPONDING: STRICT mode with multiple queries.
SELECT 1 AS a, 2 AS b
UNION ALL STRICT CORRESPONDING
SELECT 2 AS B, 3 AS a
UNION ALL STRICT CORRESPONDING
SELECT 3 AS A, 1 AS B
--
QueryStmt
+-output_column_list=
| +-$union_all.a#7 AS a [INT64]
| +-$union_all.b#8 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#7, b#8]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all2.[a#4, B#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all2.[B#3, a#4]
    | | |       +-expr_list=
    | | |       | +-B#3 := Literal(type=INT64, value=2)
    | | |       | +-a#4 := Literal(type=INT64, value=3)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=$union_all2.[a#4, B#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all3.[A#5, B#6]
    |   |   +-expr_list=
    |   |   | +-A#5 := Literal(type=INT64, value=3)
    |   |   | +-B#6 := Literal(type=INT64, value=1)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$union_all3.[A#5, B#6]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: STRICT mode with multiple queries: column lists are not the same.
SELECT 1 AS a, 2 AS b
UNION ALL STRICT CORRESPONDING
SELECT 2 AS B, 3 AS a
UNION ALL STRICT CORRESPONDING
SELECT 3 AS A, 1 AS B, 3 AS c
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but the first query has [a, b] and query 3 has [A, B, c] [at 2:1]
UNION ALL STRICT CORRESPONDING
^
==

# CORRESPONDING: nested set operations.
(
  SELECT 1 AS a, 2 AS b, 3 AS c
  UNION ALL CORRESPONDING
  SELECT 2 AS c, 3 AS b
)
EXCEPT DISTINCT STRICT CORRESPONDING
SELECT 1 AS B, 3 AS c
--
QueryStmt
+-output_column_list=
| +-$except_distinct.b#10 AS b [INT64]
| +-$except_distinct.c#11 AS c [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$except_distinct.[b#10, c#11]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-SetOperationScan
    | | |   +-column_list=$union_all.[b#6, c#7]
    | | |   +-op_type=UNION_ALL
    | | |   +-input_item_list=
    | | |   | +-SetOperationItem
    | | |   | | +-scan=
    | | |   | | | +-ProjectScan
    | | |   | | |   +-column_list=$union_all1.[b#2, c#3]
    | | |   | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   | | |   +-input_scan=
    | | |   | | |     +-ProjectScan
    | | |   | | |       +-column_list=$union_all1.[a#1, b#2, c#3]
    | | |   | | |       +-expr_list=
    | | |   | | |       | +-a#1 := Literal(type=INT64, value=1)
    | | |   | | |       | +-b#2 := Literal(type=INT64, value=2)
    | | |   | | |       | +-c#3 := Literal(type=INT64, value=3)
    | | |   | | |       +-input_scan=
    | | |   | | |         +-SingleRowScan
    | | |   | | +-output_column_list=$union_all1.[b#2, c#3]
    | | |   | +-SetOperationItem
    | | |   |   +-scan=
    | | |   |   | +-ProjectScan
    | | |   |   |   +-column_list=$union_all2.[b#5, c#4]
    | | |   |   |   +-node_source="resolver_set_operation_corresponding"
    | | |   |   |   +-input_scan=
    | | |   |   |     +-ProjectScan
    | | |   |   |       +-column_list=$union_all2.[c#4, b#5]
    | | |   |   |       +-expr_list=
    | | |   |   |       | +-c#4 := Literal(type=INT64, value=2)
    | | |   |   |       | +-b#5 := Literal(type=INT64, value=3)
    | | |   |   |       +-input_scan=
    | | |   |   |         +-SingleRowScan
    | | |   |   +-output_column_list=$union_all2.[b#5, c#4]
    | | |   +-column_match_mode=CORRESPONDING
    | | |   +-column_propagation_mode=INNER
    | | +-output_column_list=$union_all.[b#6, c#7]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$except_distinct2.[B#8, c#9]
    |   |   +-expr_list=
    |   |   | +-B#8 := Literal(type=INT64, value=1)
    |   |   | +-c#9 := Literal(type=INT64, value=3)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$except_distinct2.[B#8, c#9]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: nested set operations.
SELECT 1 AS B, 3 AS c
EXCEPT DISTINCT STRICT CORRESPONDING
(
  SELECT 1 AS a, 2 AS b, 3 AS c
  UNION ALL CORRESPONDING
  SELECT 2 AS c, 3 AS b
)
--
QueryStmt
+-output_column_list=
| +-$except_distinct.B#10 AS B [INT64]
| +-$except_distinct.c#11 AS c [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$except_distinct.[B#10, c#11]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$except_distinct1.[B#1, c#2]
    | | |   +-expr_list=
    | | |   | +-B#1 := Literal(type=INT64, value=1)
    | | |   | +-c#2 := Literal(type=INT64, value=3)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$except_distinct1.[B#1, c#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-SetOperationScan
    |   |   +-column_list=$union_all.[b#8, c#9]
    |   |   +-op_type=UNION_ALL
    |   |   +-input_item_list=
    |   |   | +-SetOperationItem
    |   |   | | +-scan=
    |   |   | | | +-ProjectScan
    |   |   | | |   +-column_list=$union_all1.[b#4, c#5]
    |   |   | | |   +-node_source="resolver_set_operation_corresponding"
    |   |   | | |   +-input_scan=
    |   |   | | |     +-ProjectScan
    |   |   | | |       +-column_list=$union_all1.[a#3, b#4, c#5]
    |   |   | | |       +-expr_list=
    |   |   | | |       | +-a#3 := Literal(type=INT64, value=1)
    |   |   | | |       | +-b#4 := Literal(type=INT64, value=2)
    |   |   | | |       | +-c#5 := Literal(type=INT64, value=3)
    |   |   | | |       +-input_scan=
    |   |   | | |         +-SingleRowScan
    |   |   | | +-output_column_list=$union_all1.[b#4, c#5]
    |   |   | +-SetOperationItem
    |   |   |   +-scan=
    |   |   |   | +-ProjectScan
    |   |   |   |   +-column_list=$union_all2.[b#7, c#6]
    |   |   |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   |   |   +-input_scan=
    |   |   |   |     +-ProjectScan
    |   |   |   |       +-column_list=$union_all2.[c#6, b#7]
    |   |   |   |       +-expr_list=
    |   |   |   |       | +-c#6 := Literal(type=INT64, value=2)
    |   |   |   |       | +-b#7 := Literal(type=INT64, value=3)
    |   |   |   |       +-input_scan=
    |   |   |   |         +-SingleRowScan
    |   |   |   +-output_column_list=$union_all2.[b#7, c#6]
    |   |   +-column_match_mode=CORRESPONDING
    |   |   +-column_propagation_mode=INNER
    |   +-output_column_list=$union_all.[b#8, c#9]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: nested set operations: column lists are not the same.
(
  SELECT 1 AS a, 2 AS b, 3 AS c
  UNION ALL CORRESPONDING
  SELECT 2 AS c, 3 AS b
)
EXCEPT DISTINCT STRICT CORRESPONDING
SELECT 1 AS a, 3 AS C
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but the first query has [b, c] and query 2 has [a, C] [at 6:1]
EXCEPT DISTINCT STRICT CORRESPONDING
^
==

# CORRESPONDING: nested set operations: column lists are not the same.
SELECT 1 AS a, 3 AS C
EXCEPT DISTINCT STRICT CORRESPONDING
(
  SELECT 1 AS a, 2 AS b, 3 AS c
  UNION ALL CORRESPONDING
  SELECT 2 AS c, 3 AS b
)
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but the first query has [a, C] and query 2 has [b, c] [at 2:1]
EXCEPT DISTINCT STRICT CORRESPONDING
^
==

# CORRESPONDING: INNER + STRICT
(
  SELECT 1 AS A, 2 AS B, 3 AS C
  INTERSECT ALL CORRESPONDING
  SELECT 2 AS B, 1 AS A
)
UNION ALL STRICT CORRESPONDING
SELECT 1 AS A, 2 AS B
--
QueryStmt
+-output_column_list=
| +-$union_all.A#10 AS A [INT64]
| +-$union_all.B#11 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#10, B#11]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-SetOperationScan
    | | |   +-column_list=$intersect_all.[A#6, B#7]
    | | |   +-op_type=INTERSECT_ALL
    | | |   +-input_item_list=
    | | |   | +-SetOperationItem
    | | |   | | +-scan=
    | | |   | | | +-ProjectScan
    | | |   | | |   +-column_list=$intersect_all1.[A#1, B#2]
    | | |   | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   | | |   +-input_scan=
    | | |   | | |     +-ProjectScan
    | | |   | | |       +-column_list=$intersect_all1.[A#1, B#2, C#3]
    | | |   | | |       +-expr_list=
    | | |   | | |       | +-A#1 := Literal(type=INT64, value=1)
    | | |   | | |       | +-B#2 := Literal(type=INT64, value=2)
    | | |   | | |       | +-C#3 := Literal(type=INT64, value=3)
    | | |   | | |       +-input_scan=
    | | |   | | |         +-SingleRowScan
    | | |   | | +-output_column_list=$intersect_all1.[A#1, B#2]
    | | |   | +-SetOperationItem
    | | |   |   +-scan=
    | | |   |   | +-ProjectScan
    | | |   |   |   +-column_list=$intersect_all2.[A#5, B#4]
    | | |   |   |   +-node_source="resolver_set_operation_corresponding"
    | | |   |   |   +-input_scan=
    | | |   |   |     +-ProjectScan
    | | |   |   |       +-column_list=$intersect_all2.[B#4, A#5]
    | | |   |   |       +-expr_list=
    | | |   |   |       | +-B#4 := Literal(type=INT64, value=2)
    | | |   |   |       | +-A#5 := Literal(type=INT64, value=1)
    | | |   |   |       +-input_scan=
    | | |   |   |         +-SingleRowScan
    | | |   |   +-output_column_list=$intersect_all2.[A#5, B#4]
    | | |   +-column_match_mode=CORRESPONDING
    | | |   +-column_propagation_mode=INNER
    | | +-output_column_list=$intersect_all.[A#6, B#7]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[A#8, B#9]
    |   |   +-expr_list=
    |   |   | +-A#8 := Literal(type=INT64, value=1)
    |   |   | +-B#9 := Literal(type=INT64, value=2)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$union_all2.[A#8, B#9]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: INNER + STRICT
SELECT 1 AS A, 2 AS B
UNION ALL STRICT CORRESPONDING
(
  SELECT 1 AS A, 2 AS B, 3 AS C
  INTERSECT ALL CORRESPONDING
  SELECT 2 AS B, 1 AS A
)
--
QueryStmt
+-output_column_list=
| +-$union_all.A#10 AS A [INT64]
| +-$union_all.B#11 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#10, B#11]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[A#1, B#2]
    | | |   +-expr_list=
    | | |   | +-A#1 := Literal(type=INT64, value=1)
    | | |   | +-B#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[A#1, B#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-SetOperationScan
    |   |   +-column_list=$intersect_all.[A#8, B#9]
    |   |   +-op_type=INTERSECT_ALL
    |   |   +-input_item_list=
    |   |   | +-SetOperationItem
    |   |   | | +-scan=
    |   |   | | | +-ProjectScan
    |   |   | | |   +-column_list=$intersect_all1.[A#3, B#4]
    |   |   | | |   +-node_source="resolver_set_operation_corresponding"
    |   |   | | |   +-input_scan=
    |   |   | | |     +-ProjectScan
    |   |   | | |       +-column_list=$intersect_all1.[A#3, B#4, C#5]
    |   |   | | |       +-expr_list=
    |   |   | | |       | +-A#3 := Literal(type=INT64, value=1)
    |   |   | | |       | +-B#4 := Literal(type=INT64, value=2)
    |   |   | | |       | +-C#5 := Literal(type=INT64, value=3)
    |   |   | | |       +-input_scan=
    |   |   | | |         +-SingleRowScan
    |   |   | | +-output_column_list=$intersect_all1.[A#3, B#4]
    |   |   | +-SetOperationItem
    |   |   |   +-scan=
    |   |   |   | +-ProjectScan
    |   |   |   |   +-column_list=$intersect_all2.[A#7, B#6]
    |   |   |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   |   |   +-input_scan=
    |   |   |   |     +-ProjectScan
    |   |   |   |       +-column_list=$intersect_all2.[B#6, A#7]
    |   |   |   |       +-expr_list=
    |   |   |   |       | +-B#6 := Literal(type=INT64, value=2)
    |   |   |   |       | +-A#7 := Literal(type=INT64, value=1)
    |   |   |   |       +-input_scan=
    |   |   |   |         +-SingleRowScan
    |   |   |   +-output_column_list=$intersect_all2.[A#7, B#6]
    |   |   +-column_match_mode=CORRESPONDING
    |   |   +-column_propagation_mode=INNER
    |   +-output_column_list=$intersect_all.[A#8, B#9]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: FULL + STRICT
(
  SELECT 1 AS A, 3 AS C
  FULL INTERSECT DISTINCT CORRESPONDING
  SELECT 2 AS B
)
UNION ALL STRICT CORRESPONDING
SELECT 3 AS C, 1 AS B, 2 AS A
--
QueryStmt
+-output_column_list=
| +-$union_all.A#13 AS A [INT64]
| +-$union_all.C#14 AS C [INT64]
| +-$union_all.B#15 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#13, C#14, B#15]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-SetOperationScan
    | | |   +-column_list=$intersect_distinct.[A#4, C#5, B#6]
    | | |   +-op_type=INTERSECT_DISTINCT
    | | |   +-input_item_list=
    | | |   | +-SetOperationItem
    | | |   | | +-scan=
    | | |   | | | +-ProjectScan
    | | |   | | |   +-column_list=[$intersect_distinct1.A#1, $intersect_distinct1.C#2, $null_column_for_outer_set_op.B#7]
    | | |   | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   | | |   +-expr_list=
    | | |   | | |   | +-B#7 := Literal(type=INT64, value=NULL)
    | | |   | | |   +-input_scan=
    | | |   | | |     +-ProjectScan
    | | |   | | |       +-column_list=$intersect_distinct1.[A#1, C#2]
    | | |   | | |       +-expr_list=
    | | |   | | |       | +-A#1 := Literal(type=INT64, value=1)
    | | |   | | |       | +-C#2 := Literal(type=INT64, value=3)
    | | |   | | |       +-input_scan=
    | | |   | | |         +-SingleRowScan
    | | |   | | +-output_column_list=[$intersect_distinct1.A#1, $intersect_distinct1.C#2, $null_column_for_outer_set_op.B#7]
    | | |   | +-SetOperationItem
    | | |   |   +-scan=
    | | |   |   | +-ProjectScan
    | | |   |   |   +-column_list=[$null_column_for_outer_set_op.A#8, $null_column_for_outer_set_op.C#9, $intersect_distinct2.B#3]
    | | |   |   |   +-node_source="resolver_set_operation_corresponding"
    | | |   |   |   +-expr_list=
    | | |   |   |   | +-A#8 := Literal(type=INT64, value=NULL)
    | | |   |   |   | +-C#9 := Literal(type=INT64, value=NULL)
    | | |   |   |   +-input_scan=
    | | |   |   |     +-ProjectScan
    | | |   |   |       +-column_list=[$intersect_distinct2.B#3]
    | | |   |   |       +-expr_list=
    | | |   |   |       | +-B#3 := Literal(type=INT64, value=2)
    | | |   |   |       +-input_scan=
    | | |   |   |         +-SingleRowScan
    | | |   |   +-output_column_list=[$null_column_for_outer_set_op.A#8, $null_column_for_outer_set_op.C#9, $intersect_distinct2.B#3]
    | | |   +-column_match_mode=CORRESPONDING
    | | |   +-column_propagation_mode=FULL
    | | +-output_column_list=$intersect_distinct.[A#4, C#5, B#6]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[A#12, C#10, B#11]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[C#10, B#11, A#12]
    |   |       +-expr_list=
    |   |       | +-C#10 := Literal(type=INT64, value=3)
    |   |       | +-B#11 := Literal(type=INT64, value=1)
    |   |       | +-A#12 := Literal(type=INT64, value=2)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$union_all2.[A#12, C#10, B#11]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: INNER + STRICT columns not identical.
SELECT 1 AS B, 2 AS A
UNION ALL STRICT CORRESPONDING
(
  SELECT 1 AS A, 3 AS C
  INTERSECT DISTINCT CORRESPONDING
  SELECT 2 AS B, 3 AS A
)
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but the first query has [B, A] and query 2 has [A] [at 2:1]
UNION ALL STRICT CORRESPONDING
^
==

# CORRESPONDING: FULL + STRICT
SELECT 3 AS C, 1 AS B, 2 AS A
UNION ALL STRICT CORRESPONDING
(
  SELECT 1 AS A, 3 AS C
  FULL INTERSECT DISTINCT CORRESPONDING
  SELECT 2 AS B
)
--
QueryStmt
+-output_column_list=
| +-$union_all.C#13 AS C [INT64]
| +-$union_all.B#14 AS B [INT64]
| +-$union_all.A#15 AS A [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[C#13, B#14, A#15]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[C#1, B#2, A#3]
    | | |   +-expr_list=
    | | |   | +-C#1 := Literal(type=INT64, value=3)
    | | |   | +-B#2 := Literal(type=INT64, value=1)
    | | |   | +-A#3 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[C#1, B#2, A#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_distinct.[C#8, B#9, A#7]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-SetOperationScan
    |   |       +-column_list=$intersect_distinct.[A#7, C#8, B#9]
    |   |       +-op_type=INTERSECT_DISTINCT
    |   |       +-input_item_list=
    |   |       | +-SetOperationItem
    |   |       | | +-scan=
    |   |       | | | +-ProjectScan
    |   |       | | |   +-column_list=[$intersect_distinct1.A#4, $intersect_distinct1.C#5, $null_column_for_outer_set_op.B#10]
    |   |       | | |   +-node_source="resolver_set_operation_corresponding"
    |   |       | | |   +-expr_list=
    |   |       | | |   | +-B#10 := Literal(type=INT64, value=NULL)
    |   |       | | |   +-input_scan=
    |   |       | | |     +-ProjectScan
    |   |       | | |       +-column_list=$intersect_distinct1.[A#4, C#5]
    |   |       | | |       +-expr_list=
    |   |       | | |       | +-A#4 := Literal(type=INT64, value=1)
    |   |       | | |       | +-C#5 := Literal(type=INT64, value=3)
    |   |       | | |       +-input_scan=
    |   |       | | |         +-SingleRowScan
    |   |       | | +-output_column_list=[$intersect_distinct1.A#4, $intersect_distinct1.C#5, $null_column_for_outer_set_op.B#10]
    |   |       | +-SetOperationItem
    |   |       |   +-scan=
    |   |       |   | +-ProjectScan
    |   |       |   |   +-column_list=[$null_column_for_outer_set_op.A#11, $null_column_for_outer_set_op.C#12, $intersect_distinct2.B#6]
    |   |       |   |   +-node_source="resolver_set_operation_corresponding"
    |   |       |   |   +-expr_list=
    |   |       |   |   | +-A#11 := Literal(type=INT64, value=NULL)
    |   |       |   |   | +-C#12 := Literal(type=INT64, value=NULL)
    |   |       |   |   +-input_scan=
    |   |       |   |     +-ProjectScan
    |   |       |   |       +-column_list=[$intersect_distinct2.B#6]
    |   |       |   |       +-expr_list=
    |   |       |   |       | +-B#6 := Literal(type=INT64, value=2)
    |   |       |   |       +-input_scan=
    |   |       |   |         +-SingleRowScan
    |   |       |   +-output_column_list=[$null_column_for_outer_set_op.A#11, $null_column_for_outer_set_op.C#12, $intersect_distinct2.B#6]
    |   |       +-column_match_mode=CORRESPONDING
    |   |       +-column_propagation_mode=FULL
    |   +-output_column_list=$intersect_distinct.[C#8, B#9, A#7]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: FULL + STRICT, not identical columns.
SELECT 3 AS C, 2 AS A
UNION ALL STRICT CORRESPONDING
(
  SELECT 1 AS A, 3 AS C
  FULL INTERSECT DISTINCT CORRESPONDING
  SELECT 2 AS B
)
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but the first query has [C, A] and query 2 has [A, C, B] [at 2:1]
UNION ALL STRICT CORRESPONDING
^
==

# CORRESPONDING: LEFT + STRICT
(
  SELECT 1 AS A, 2 AS B
  LEFT EXCEPT ALL CORRESPONDING
  SELECT 2 AS A, 3 AS C
)
INTERSECT DISTINCT STRICT CORRESPONDING
SELECT 2 AS B, 3 AS A
--
QueryStmt
+-output_column_list=
| +-$intersect_distinct.A#10 AS A [INT64]
| +-$intersect_distinct.B#11 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_distinct.[A#10, B#11]
    +-op_type=INTERSECT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-SetOperationScan
    | | |   +-column_list=$except_all.[A#5, B#6]
    | | |   +-op_type=EXCEPT_ALL
    | | |   +-input_item_list=
    | | |   | +-SetOperationItem
    | | |   | | +-scan=
    | | |   | | | +-ProjectScan
    | | |   | | |   +-column_list=$except_all1.[A#1, B#2]
    | | |   | | |   +-expr_list=
    | | |   | | |   | +-A#1 := Literal(type=INT64, value=1)
    | | |   | | |   | +-B#2 := Literal(type=INT64, value=2)
    | | |   | | |   +-input_scan=
    | | |   | | |     +-SingleRowScan
    | | |   | | +-output_column_list=$except_all1.[A#1, B#2]
    | | |   | +-SetOperationItem
    | | |   |   +-scan=
    | | |   |   | +-ProjectScan
    | | |   |   |   +-column_list=[$except_all2.A#3, $null_column_for_outer_set_op.B#7]
    | | |   |   |   +-node_source="resolver_set_operation_corresponding"
    | | |   |   |   +-expr_list=
    | | |   |   |   | +-B#7 := Literal(type=INT64, value=NULL)
    | | |   |   |   +-input_scan=
    | | |   |   |     +-ProjectScan
    | | |   |   |       +-column_list=$except_all2.[A#3, C#4]
    | | |   |   |       +-expr_list=
    | | |   |   |       | +-A#3 := Literal(type=INT64, value=2)
    | | |   |   |       | +-C#4 := Literal(type=INT64, value=3)
    | | |   |   |       +-input_scan=
    | | |   |   |         +-SingleRowScan
    | | |   |   +-output_column_list=[$except_all2.A#3, $null_column_for_outer_set_op.B#7]
    | | |   +-column_match_mode=CORRESPONDING
    | | |   +-column_propagation_mode=LEFT
    | | +-output_column_list=$except_all.[A#5, B#6]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_distinct2.[A#9, B#8]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$intersect_distinct2.[B#8, A#9]
    |   |       +-expr_list=
    |   |       | +-B#8 := Literal(type=INT64, value=2)
    |   |       | +-A#9 := Literal(type=INT64, value=3)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$intersect_distinct2.[A#9, B#8]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: LEFT + STRICT
SELECT 2 AS B, 3 AS A
INTERSECT ALL STRICT CORRESPONDING
(
  SELECT 1 AS A, 2 AS B
  LEFT EXCEPT ALL CORRESPONDING
  SELECT 2 AS A, 3 AS C
)
--
QueryStmt
+-output_column_list=
| +-$intersect_all.B#10 AS B [INT64]
| +-$intersect_all.A#11 AS A [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[B#10, A#11]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1.[B#1, A#2]
    | | |   +-expr_list=
    | | |   | +-B#1 := Literal(type=INT64, value=2)
    | | |   | +-A#2 := Literal(type=INT64, value=3)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$intersect_all1.[B#1, A#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$except_all.[B#8, A#7]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-SetOperationScan
    |   |       +-column_list=$except_all.[A#7, B#8]
    |   |       +-op_type=EXCEPT_ALL
    |   |       +-input_item_list=
    |   |       | +-SetOperationItem
    |   |       | | +-scan=
    |   |       | | | +-ProjectScan
    |   |       | | |   +-column_list=$except_all1.[A#3, B#4]
    |   |       | | |   +-expr_list=
    |   |       | | |   | +-A#3 := Literal(type=INT64, value=1)
    |   |       | | |   | +-B#4 := Literal(type=INT64, value=2)
    |   |       | | |   +-input_scan=
    |   |       | | |     +-SingleRowScan
    |   |       | | +-output_column_list=$except_all1.[A#3, B#4]
    |   |       | +-SetOperationItem
    |   |       |   +-scan=
    |   |       |   | +-ProjectScan
    |   |       |   |   +-column_list=[$except_all2.A#5, $null_column_for_outer_set_op.B#9]
    |   |       |   |   +-node_source="resolver_set_operation_corresponding"
    |   |       |   |   +-expr_list=
    |   |       |   |   | +-B#9 := Literal(type=INT64, value=NULL)
    |   |       |   |   +-input_scan=
    |   |       |   |     +-ProjectScan
    |   |       |   |       +-column_list=$except_all2.[A#5, C#6]
    |   |       |   |       +-expr_list=
    |   |       |   |       | +-A#5 := Literal(type=INT64, value=2)
    |   |       |   |       | +-C#6 := Literal(type=INT64, value=3)
    |   |       |   |       +-input_scan=
    |   |       |   |         +-SingleRowScan
    |   |       |   +-output_column_list=[$except_all2.A#5, $null_column_for_outer_set_op.B#9]
    |   |       +-column_match_mode=CORRESPONDING
    |   |       +-column_propagation_mode=LEFT
    |   +-output_column_list=$except_all.[B#8, A#7]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: LEFT + STRICT, not identical columns
(
  SELECT 1 AS A, 2 AS B, 3 AS C
  LEFT EXCEPT ALL CORRESPONDING
  SELECT 2 AS A, 3 AS C
)
INTERSECT DISTINCT STRICT CORRESPONDING
SELECT 2 AS B, 3 AS A
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but the first query has [A, B, C] and query 2 has [B, A] [at 6:1]
INTERSECT DISTINCT STRICT CORRESPONDING
^
