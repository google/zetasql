# The tests for analytic functions are split into four files.
#
# 1) analytic_functions.test contains tests for OVER clause support, DISTINCT,
#    IGNORE/RESPECT NULLS, analytic function locations, and combined tests with
#    aggregate functions, subqueries and query parameters.
# 2) analytic_function_frame.test contains specific tests for the window frame
#    clause.
# 3) analytic_function_partitionby_orderby.test contains specific tests for
#    window PARTITION BY and window ORDER BY, including the types of
#    partitioning/ordering expressions and alias references.
# 4) analytic_function_named_window.test contains specific tests for named
#    window and analytic functions grouping for window sharing.
#
# This test file uses these test analytic functions: afn_agg, afn_order,
# afn_no_order_no_frame, and afn_null_handling:
# ---------------------------------------------------------------------------
#                           Mode      ORDER BY    Window Frame  Null Handling
#                                                                 Modifier
#                         --------   -----------  ---------------------------
#  afn_order              ANALYTIC    Required    Unsupported   Unsupported
#  afn_no_order_no_frame  ANALYTIC   Unsupported  Unsupported   Unsupported
#  afn_null_handling      AGGREGATE   Optional    Unsupported    Supported
#  afn_agg                AGGREGATE   Optional     Supported    Unsupported
#  --------------------------------------------------------------------------

# By default, analytic functions are disabled.
select afn_agg(key) over ()
from KeyValue;
--
ERROR: Analytic functions not supported [at 1:8]
select afn_agg(key) over ()
       ^
==

# Enable analytic functions.
[language_features=ANALYTIC_FUNCTIONS]
select afn_agg(key) over ()
from KeyValue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(sample_functions:afn_agg(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)

==

[language_features=ANALYTIC_FUNCTIONS,ANALYTIC_FUNCTIONS,ANALYTIC_FUNCTIONS]
select afn_agg(key) over ()
from KeyValue;
--
[SAME AS PREVIOUS]
==

#
# OVER clause support validations.
#

# Scalar function with OVER
[default language_features=ANALYTIC_FUNCTIONS]
select sqrt(123) over () from keyvalue;
--
ERROR: Function SQRT does not support an OVER clause [at 1:8]
select sqrt(123) over () from keyvalue;
       ^
==

# afn_agg is treated as a regular aggregate function call if OVER does not
# follow it.
select afn_agg(key)
from keyvalue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(sample_functions:afn_agg(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# afn_order has mode ANALYTIC, so it cannot be called without an OVER clause.
select afn_order()
from keyvalue
--
ERROR: Analytic function SAMPLE_FUNCTIONS:AFN_ORDER cannot be called without an OVER clause [at 1:8]
select afn_order()
       ^
==

# unknown_fn is not defined in the catalog.
select unknown_fn() over ()
from KeyValue;
--
ERROR: Function not found: unknown_fn [at 1:8]
select unknown_fn() over ()
       ^
==

select int32(key) over () from keyvalue
--
ERROR: Function not found: int32 [at 1:8]
select int32(key) over () from keyvalue
       ^
==

# CAST functions
select CAST(key as int32) over () from keyvalue
--
ERROR: Syntax error: OVER keyword must follow a function call [at 1:27]
select CAST(key as int32) over () from keyvalue
                          ^
==

select 1 WINDOW w as ()
--
ERROR: Query without FROM clause cannot have a WINDOW clause [at 1:10]
select 1 WINDOW w as ()
         ^
==

# Window ORDER BY is required for the test function afn_order
select afn_order(key) over ()
from keyvalue
--
ERROR: Window ORDER BY is required for analytic function afn_order [at 1:28]
select afn_order(key) over ()
                           ^
==

# Window ORDER BY is not allowed for the test function afn_no_order_no_frame.
select afn_no_order_no_frame() over (order by key)
from keyvalue
--
ERROR: Window ORDER BY is not allowed for analytic function afn_no_order_no_frame [at 1:38]
select afn_no_order_no_frame() over (order by key)
                                     ^
==

# Window frame is not supported for the test function afn_order.
select afn_order(key) over (order by key rows 2 preceding)
from keyvalue
--
ERROR: Window framing clause is not allowed for analytic function afn_order [at 1:42]
select afn_order(key) over (order by key rows 2 preceding)
                                         ^
==

#
# Analytic functions can only appear in the SELECT list or ORDER BY.
#

# Analytic function cannot appear in where.
select key
from keyvalue
where key > (afn_agg() over ())
--
ERROR: Analytic function not allowed in WHERE clause [at 3:14]
where key > (afn_agg() over ())
             ^
==

# Analytic function cannot appear in group by.
select key
from keyvalue
group by (afn_agg() over ())
--
ERROR: Analytic function not allowed in GROUP BY [at 3:11]
group by (afn_agg() over ())
          ^
==

# Grouping by an analytic function call by an ordinal reference.
select afn_agg() over ()
from keyvalue
group by 1
--
ERROR: Column 1 contains an analytic function, which is not allowed in GROUP BY [at 3:10]
group by 1
         ^
==

select key + (afn_agg(key) over ())
from keyvalue
group by 1
--
ERROR: Column 1 contains an analytic function, which is not allowed in GROUP BY [at 3:10]
group by 1
         ^
==

select key + (afn_agg(key) over ()) as analytic_col
from keyvalue
group by analytic_col
--
ERROR: Column analytic_col contains an analytic function, which is not allowed in GROUP BY [at 3:10]
group by analytic_col
         ^
==

# Analytic function cannot appear in having.
select key
from keyvalue
group by key
having (afn_agg(key) over ()) > 1
--
ERROR: Analytic function not allowed in HAVING clause [at 4:9]
having (afn_agg(key) over ()) > 1
        ^
==

# Analytic function cannot appear in the argument list of an analytic function.
select count(afn_agg(key) over ()) over ()
from keyvalue
--
ERROR: Analytic function cannot be an argument of another analytic function [at 1:8]
select count(afn_agg(key) over ()) over ()
       ^
==

# Analytic function cannot appear in the argument list of an aggregate function.
select count(afn_agg(key) over ()) from keyvalue
--
ERROR: Analytic functions cannot be arguments to aggregate functions [at 1:8]
select count(afn_agg(key) over ()) from keyvalue
       ^
==

# Analytic function cannot appear in PARTITION BY.
select afn_agg() over (partition by afn_agg(key) over ()) from keyvalue
--
ERROR: Analytic function not allowed in PARTITION BY [at 1:37]
select afn_agg() over (partition by afn_agg(key) over ()) from keyvalue
                                    ^
==

select afn_agg() over () as analytic_col from keyvalue
order by afn_agg() over (partition by analytic_col)
--
ERROR: Column analytic_col contains an analytic function, which is not allowed in PARTITION BY [at 2:39]
order by afn_agg() over (partition by analytic_col)
                                      ^
==

# Analytic function cannot appear in ORDER BY.
select afn_agg() over (order by afn_agg(key) over ()) from keyvalue
--
ERROR: Analytic function not allowed in Window ORDER BY [at 1:33]
select afn_agg() over (order by afn_agg(key) over ()) from keyvalue
                                ^
==

select afn_agg() over () as analytic_col from keyvalue
order by afn_agg() over (order by analytic_col)
--
ERROR: Column analytic_col contains an analytic function, which is not allowed in Window ORDER BY [at 2:35]
order by afn_agg() over (order by analytic_col)
                                  ^
==

# Analytic function cannot appear in window frame.
select afn_agg() over (rows afn_agg(key) over () preceding) from keyvalue
--
ERROR: Analytic function not allowed in window frame [at 1:29]
select afn_agg() over (rows afn_agg(key) over () preceding) from keyvalue
                            ^
==

# SELECT without FROM cannot have analytic functions.
select afn_agg() over ()
--
ERROR: SELECT without FROM clause cannot use analytic functions [at 1:1]
select afn_agg() over ()
^
==

# Since we need to resolve the function name first to know whether the OVER
# clause is supported, if there is any error in general function resolution,
# no error in the OVER clause will be reported.
select undefined_function() over (partition by undefined_column) from keyvalue
--
ERROR: Function not found: undefined_function [at 1:8]
select undefined_function() over (partition by undefined_column) from keyvalue
       ^
==

select afn_agg() over (partition by undefined_column) from keyvalue
--
ERROR: Unrecognized name: undefined_column [at 1:37]
select afn_agg() over (partition by undefined_column) from keyvalue
                                    ^
==

select afn_agg() over (order by undefined_column) from keyvalue
--
ERROR: Unrecognized name: undefined_column [at 1:33]
select afn_agg() over (order by undefined_column) from keyvalue
                                ^
==

# Aggregate analytic function with DISTINCT.
select afn_agg(distinct key, value) over ()
from keyvalue
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(sample_functions:afn_agg(INT64, STRING) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-distinct=TRUE
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

select afn_agg(distinct KitchenSink) over () from ComplexTypes
--
ERROR: Analytic aggregate functions with DISTINCT cannot be used with arguments of type PROTO [at 1:8]
select afn_agg(distinct KitchenSink) over () from ComplexTypes
       ^
==

select afn_agg(distinct Int32Array) over () from ComplexTypes
--
ERROR: Analytic aggregate functions with DISTINCT cannot be used with arguments of type ARRAY [at 1:8]
select afn_agg(distinct Int32Array) over () from ComplexTypes
       ^
==

[language_features={{ANALYTIC_FUNCTIONS|ANALYTIC_FUNCTIONS,V_1_2_GROUP_BY_STRUCT}}]
select afn_agg(distinct TestStruct) over () from ComplexTypes
--
ALTERNATION GROUP: ANALYTIC_FUNCTIONS
--
ERROR: Analytic aggregate functions with DISTINCT cannot be used with arguments of type STRUCT [at 1:8]
select afn_agg(distinct TestStruct) over () from ComplexTypes
       ^
--
ALTERNATION GROUP: ANALYTIC_FUNCTIONS,V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#8 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#8]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[ComplexTypes.TestStruct#5, $analytic.$analytic1#8]
        +-input_scan=
        | +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#8 :=
                +-AnalyticFunctionCall(sample_functions:afn_agg(STRUCT<c INT32, d STRUCT<a INT32, b STRING>>) -> INT64)
                  +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
                  +-distinct=TRUE
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

[language_features=ANALYTIC_FUNCTIONS{{,DISALLOW_GROUP_BY_FLOAT|}}]
select afn_agg(distinct double) over () from SimpleTypes
--
ALTERNATION GROUP: ,DISALLOW_GROUP_BY_FLOAT
--
ERROR: Analytic aggregate functions with DISTINCT cannot be used with arguments of type DOUBLE [at 1:8]
select afn_agg(distinct double) over () from SimpleTypes
       ^
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#20 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#20]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.double#9, $analytic.$analytic1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.double#9], table=SimpleTypes, column_index_list=[8])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#20 :=
                +-AnalyticFunctionCall(sample_functions:afn_agg(DOUBLE) -> INT64)
                  +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
                  +-distinct=TRUE
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

# Non-aggregate analytic function cannot have DISTINCT.
select afn_no_order_no_frame(distinct key) over ()
from keyvalue
--
ERROR: DISTINCT is not allowed for analytic function afn_no_order_no_frame [at 1:8]
select afn_no_order_no_frame(distinct key) over ()
       ^
==

# ORDER BY is not allowed if DISTINCT is present.
select afn_agg(distinct key) over (order by value)
from keyvalue
--
ERROR: Window ORDER BY is not allowed if DISTINCT is specified [at 1:36]
select afn_agg(distinct key) over (order by value)
                                   ^
==

# Frame clause is not allowed if DISTINCT is present.
select afn_agg(distinct key) over (rows 2 preceding)
from keyvalue
--
ERROR: Window framing clause is not allowed if DISTINCT is specified [at 1:36]
select afn_agg(distinct key) over (rows 2 preceding)
                                   ^
==

# DISTINCT without arguments.
select afn_agg(distinct) over()
from keyvalue
--
ERROR: DISTINCT function call with no arguments not possible [at 1:8]
select afn_agg(distinct) over()
       ^
==

select afn_no_order_no_frame(distinct) over ()
from keyvalue
--
ERROR: DISTINCT function call with no arguments not possible [at 1:8]
select afn_no_order_no_frame(distinct) over ()
       ^
==

select row_number(distinct) over ()
from keyvalue
--
ERROR: DISTINCT function call with no arguments not possible [at 1:8]
select row_number(distinct) over ()
       ^
==

# Analytic function mixed with aggregate function.
select count(value)+1,
       afn_order(min(key)) over (partition by sum(key) order by max(key)+1)
from keyvalue
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS `$col1` [INT64]
| +-$analytic.$analytic1#9 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8, $analytic.$analytic1#9]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$aggregate.$agg1#3, $aggregate.$agg2#4, $aggregate.$agg3#5, $aggregate.$agg4#6, $query.$col1#8, $analytic.$analytic1#9]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#3, $aggregate.$agg2#4, $aggregate.$agg3#5, $aggregate.$agg4#6, $query.$col1#8, $orderby.$orderbycol1#10]
        |   +-expr_list=
        |   | +-$orderbycol1#10 :=
        |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |     +-ColumnRef(type=INT64, column=$aggregate.$agg4#6)
        |   |     +-Literal(type=INT64, value=1)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$aggregate.$agg1#3, $aggregate.$agg2#4, $aggregate.$agg3#5, $aggregate.$agg4#6, $query.$col1#8]
        |       +-expr_list=
        |       | +-$col1#8 :=
        |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#3)
        |       |     +-Literal(type=INT64, value=1)
        |       +-input_scan=
        |         +-AggregateScan
        |           +-column_list=$aggregate.[$agg1#3, $agg2#4, $agg3#5, $agg4#6]
        |           +-input_scan=
        |           | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |           +-aggregate_list=
        |             +-$agg1#3 :=
        |             | +-AggregateFunctionCall(ZetaSQL:count(STRING) -> INT64)
        |             |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |             +-$agg2#4 :=
        |             | +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
        |             |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |             +-$agg3#5 :=
        |             | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |             |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |             +-$agg4#6 :=
        |               +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
        |                 +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=$aggregate.$agg3#5)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#10)
            +-analytic_function_list=
              +-$analytic1#9 :=
                +-AnalyticFunctionCall(sample_functions:afn_order(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=$aggregate.$agg2#4)
==

# Aggregations in analytic functions in ORDER BY.
select 1 from keyvalue
group by value
order by afn_agg(sum(key)) over (partition by count(value) order by max(key)+1)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$query.$col1#4]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AnalyticScan
    |   +-column_list=[$query.$col1#4, $aggregate.$agg1#5, $aggregate.$agg2#6, $aggregate.$agg3#7, $analytic.$analytic1#8]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$query.$col1#4, $aggregate.$agg1#5, $aggregate.$agg2#6, $aggregate.$agg3#7, $orderby.$orderbycol1#9]
    |   |   +-expr_list=
    |   |   | +-$orderbycol1#9 :=
    |   |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |   |     +-ColumnRef(type=INT64, column=$aggregate.$agg3#7)
    |   |   |     +-Literal(type=INT64, value=1)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$query.$col1#4, $aggregate.$agg1#5, $aggregate.$agg2#6, $aggregate.$agg3#7]
    |   |       +-expr_list=
    |   |       | +-$col1#4 := Literal(type=INT64, value=1)
    |   |       +-input_scan=
    |   |         +-AggregateScan
    |   |           +-column_list=$aggregate.[$agg1#5, $agg2#6, $agg3#7]
    |   |           +-input_scan=
    |   |           | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |           +-group_by_list=
    |   |           | +-value#3 := ColumnRef(type=STRING, column=KeyValue.Value#2)
    |   |           +-aggregate_list=
    |   |             +-$agg1#5 :=
    |   |             | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |   |             |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |             +-$agg2#6 :=
    |   |             | +-AggregateFunctionCall(ZetaSQL:count(STRING) -> INT64)
    |   |             |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |   |             +-$agg3#7 :=
    |   |               +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |   |                 +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-function_group_list=
    |     +-AnalyticFunctionGroup
    |       +-partition_by=
    |       | +-WindowPartitioning
    |       |   +-partition_by_list=
    |       |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#6)
    |       +-order_by=
    |       | +-WindowOrdering
    |       |   +-order_by_item_list=
    |       |     +-OrderByItem
    |       |       +-column_ref=
    |       |         +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#9)
    |       +-analytic_function_list=
    |         +-$analytic1#8 :=
    |           +-AnalyticFunctionCall(sample_functions:afn_agg(INT64) -> INT64)
    |             +-ColumnRef(type=INT64, column=$aggregate.$agg1#5)
    |             +-window_frame=
    |               +-WindowFrame(frame_unit=RANGE)
    |                 +-start_expr=
    |                 | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
    |                 +-end_expr=
    |                   +-WindowFrameExpr(boundary_type=CURRENT ROW)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$analytic.$analytic1#8)
==

select countif(key > 100) OVER (PARTITION BY key) FROM KeyValue
--

QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:countif(BOOL) -> INT64)
                  +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
                    +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                    +-Literal(type=INT64, value=100)
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

select 1 from keyvalue
group by value
order by afn_agg(countif(key > 100))
    over (partition by countif(value = "") order by max(key)+1)
--

QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$query.$col1#4]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AnalyticScan
    |   +-column_list=[$query.$col1#4, $aggregate.$agg1#5, $aggregate.$agg2#6, $aggregate.$agg3#7, $analytic.$analytic1#8]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$query.$col1#4, $aggregate.$agg1#5, $aggregate.$agg2#6, $aggregate.$agg3#7, $orderby.$orderbycol1#9]
    |   |   +-expr_list=
    |   |   | +-$orderbycol1#9 :=
    |   |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |   |     +-ColumnRef(type=INT64, column=$aggregate.$agg3#7)
    |   |   |     +-Literal(type=INT64, value=1)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$query.$col1#4, $aggregate.$agg1#5, $aggregate.$agg2#6, $aggregate.$agg3#7]
    |   |       +-expr_list=
    |   |       | +-$col1#4 := Literal(type=INT64, value=1)
    |   |       +-input_scan=
    |   |         +-AggregateScan
    |   |           +-column_list=$aggregate.[$agg1#5, $agg2#6, $agg3#7]
    |   |           +-input_scan=
    |   |           | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |           +-group_by_list=
    |   |           | +-value#3 := ColumnRef(type=STRING, column=KeyValue.Value#2)
    |   |           +-aggregate_list=
    |   |             +-$agg1#5 :=
    |   |             | +-AggregateFunctionCall(ZetaSQL:countif(BOOL) -> INT64)
    |   |             |   +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |   |             |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |             |     +-Literal(type=INT64, value=100)
    |   |             +-$agg2#6 :=
    |   |             | +-AggregateFunctionCall(ZetaSQL:countif(BOOL) -> INT64)
    |   |             |   +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |   |             |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |   |             |     +-Literal(type=STRING, value="")
    |   |             +-$agg3#7 :=
    |   |               +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |   |                 +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-function_group_list=
    |     +-AnalyticFunctionGroup
    |       +-partition_by=
    |       | +-WindowPartitioning
    |       |   +-partition_by_list=
    |       |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#6)
    |       +-order_by=
    |       | +-WindowOrdering
    |       |   +-order_by_item_list=
    |       |     +-OrderByItem
    |       |       +-column_ref=
    |       |         +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#9)
    |       +-analytic_function_list=
    |         +-$analytic1#8 :=
    |           +-AnalyticFunctionCall(sample_functions:afn_agg(INT64) -> INT64)
    |             +-ColumnRef(type=INT64, column=$aggregate.$agg1#5)
    |             +-window_frame=
    |               +-WindowFrame(frame_unit=RANGE)
    |                 +-start_expr=
    |                 | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
    |                 +-end_expr=
    |                   +-WindowFrameExpr(boundary_type=CURRENT ROW)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$analytic.$analytic1#8)
==

# Aggregations are not allowed in the ORDER BY if there is not GROUP BY
# nor aggregations in the SELECT list.
select 1 from keyvalue
order by afn_agg(sum(key)) over (partition by count(value) order by max(key)+1)
--
ERROR: The ORDER BY clause only allows aggregation if GROUP BY or SELECT list aggregation is present [at 2:1]
order by afn_agg(sum(key)) over (partition by count(value) order by max(key)+1)
^
==

select afn_agg(key+1, value) over ()
from keyvalue
group by key
--
ERROR: SELECT list expression references column value which is neither grouped nor aggregated [at 1:23]
select afn_agg(key+1, value) over ()
                      ^
==

select afn_agg() over (partition by key+1)
from keyvalue
group by value
--
ERROR: PARTITION BY expression references column key which is neither grouped nor aggregated [at 1:37]
select afn_agg() over (partition by key+1)
                                    ^
==

select afn_agg() over (order by key+1)
from keyvalue
group by value
--
ERROR: Window ORDER BY expression references column key which is neither grouped nor aggregated [at 1:33]
select afn_agg() over (order by key+1)
                                ^
==

select value from keyvalue
group by value
order by afn_agg() over (partition by key+1)
--
ERROR: PARTITION BY expression references column key which is neither grouped nor aggregated [at 3:39]
order by afn_agg() over (partition by key+1)
                                      ^
==

# Correlated column reference in analytic function call.
# This works because the correlated references are treated as non-const.
select (select afn_agg() over (partition by outer_key order by outer_key)
        from keyvalue)
from (select key as outer_key from keyvalue)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$analytic.$analytic1#6]
    |         +-input_scan=
    |           +-AnalyticScan
    |             +-column_list=[$analytic.$analytic1#6]
    |             +-input_scan=
    |             | +-TableScan(table=KeyValue)
    |             +-function_group_list=
    |               +-AnalyticFunctionGroup
    |                 +-partition_by=
    |                 | +-WindowPartitioning
    |                 |   +-partition_by_list=
    |                 |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |                 +-order_by=
    |                 | +-WindowOrdering
    |                 |   +-order_by_item_list=
    |                 |     +-OrderByItem
    |                 |       +-column_ref=
    |                 |         +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |                 +-analytic_function_list=
    |                   +-$analytic1#6 :=
    |                     +-AnalyticFunctionCall(sample_functions:afn_agg() -> INT64)
    |                       +-window_frame=
    |                         +-WindowFrame(frame_unit=RANGE)
    |                           +-start_expr=
    |                           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
    |                           +-end_expr=
    |                             +-WindowFrameExpr(boundary_type=CURRENT ROW)
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1]
        +-input_scan=
          +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
==

select (select afn_agg() over (rows outer_key preceding))
from (select key as outer_key from keyvalue)
--
ERROR: Window framing expression must be a literal or parameter [at 1:37]
select (select afn_agg() over (rows outer_key preceding))
                                    ^
==

# Analytic function in table subquery.
select afn_value
from (select afn_agg() over () as afn_value from keyvalue)
--
QueryStmt
+-output_column_list=
| +-$analytic.afn_value#4 AS afn_value [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.afn_value#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$analytic.afn_value#4]
        +-input_scan=
          +-AnalyticScan
            +-column_list=[$analytic.afn_value#4]
            +-input_scan=
            | +-TableScan(table=KeyValue)
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-analytic_function_list=
                  +-afn_value#4 :=
                    +-AnalyticFunctionCall(sample_functions:afn_agg() -> INT64)
                      +-window_frame=
                        +-WindowFrame(frame_unit=ROWS)
                          +-start_expr=
                          | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                          +-end_expr=
                            +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

# Query parameters.
select afn_agg() over (rows @test_param_int32 preceding)
from keyvalue
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(sample_functions:afn_agg() -> INT64)
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=OFFSET PRECEDING)
                      |   +-Cast(INT32 -> INT64)
                      |     +-Parameter(type=INT32, name="test_param_int32")
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

select {{(afn_agg() over w)+2 | afn_agg() over (w)+2 | afn_agg() over w+2 }}
from keyvalue
window w  as ()
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-ColumnRef(type=INT64, column=$analytic.$analytic1#4)
    |     +-Literal(type=INT64, value=2)
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(sample_functions:afn_agg() -> INT64)
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

# Analytic function in ORDER BY after union all.
select key, value from keyvalue
union all
select key, value from keyvalue
order by afn_agg(key) over (partition by key order by key+1 rows 2 preceding),
         afn_agg(key, value) over (partition by value) DESC,
         afn_agg(value) over (order by key range 2 preceding)+1 ASC
--
QueryStmt
+-output_column_list=
| +-$union_all.key#5 AS key [INT64]
| +-$union_all.value#6 AS value [STRING]
+-query=
  +-OrderByScan
    +-column_list=[$union_all.key#5, $union_all.value#6, $analytic.$analytic1#7, $analytic.$analytic2#8, $analytic.$analytic3#9]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$union_all.key#5, $union_all.value#6, $analytic.$analytic1#7, $analytic.$analytic2#8, $analytic.$analytic3#9, $orderby.$orderbycol3#11]
    |   +-expr_list=
    |   | +-$orderbycol3#11 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=$analytic.$analytic3#9)
    |   |     +-Literal(type=INT64, value=1)
    |   +-input_scan=
    |     +-AnalyticScan
    |       +-column_list=[$union_all.key#5, $union_all.value#6, $analytic.$analytic1#7, $analytic.$analytic2#8, $analytic.$analytic3#9]
    |       +-input_scan=
    |       | +-ProjectScan
    |       |   +-column_list=[$union_all.key#5, $union_all.value#6, $orderby.$orderbycol1#10]
    |       |   +-expr_list=
    |       |   | +-$orderbycol1#10 :=
    |       |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       |   |     +-ColumnRef(type=INT64, column=$union_all.key#5)
    |       |   |     +-Literal(type=INT64, value=1)
    |       |   +-input_scan=
    |       |     +-SetOperationScan
    |       |       +-column_list=$union_all.[key#5, value#6]
    |       |       +-op_type=UNION_ALL
    |       |       +-input_item_list=
    |       |         +-SetOperationItem
    |       |         | +-scan=
    |       |         | | +-ProjectScan
    |       |         | |   +-column_list=KeyValue.[Key#1, Value#2]
    |       |         | |   +-input_scan=
    |       |         | |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |       |         | +-output_column_list=KeyValue.[Key#1, Value#2]
    |       |         +-SetOperationItem
    |       |           +-scan=
    |       |           | +-ProjectScan
    |       |           |   +-column_list=KeyValue.[Key#3, Value#4]
    |       |           |   +-input_scan=
    |       |           |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    |       |           +-output_column_list=KeyValue.[Key#3, Value#4]
    |       +-function_group_list=
    |         +-AnalyticFunctionGroup
    |         | +-partition_by=
    |         | | +-WindowPartitioning
    |         | |   +-partition_by_list=
    |         | |     +-ColumnRef(type=INT64, column=$union_all.key#5)
    |         | +-order_by=
    |         | | +-WindowOrdering
    |         | |   +-order_by_item_list=
    |         | |     +-OrderByItem
    |         | |       +-column_ref=
    |         | |         +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#10)
    |         | +-analytic_function_list=
    |         |   +-$analytic1#7 :=
    |         |     +-AnalyticFunctionCall(sample_functions:afn_agg(INT64) -> INT64)
    |         |       +-ColumnRef(type=INT64, column=$union_all.key#5)
    |         |       +-window_frame=
    |         |         +-WindowFrame(frame_unit=ROWS)
    |         |           +-start_expr=
    |         |           | +-WindowFrameExpr(boundary_type=OFFSET PRECEDING)
    |         |           |   +-Literal(type=INT64, value=2)
    |         |           +-end_expr=
    |         |             +-WindowFrameExpr(boundary_type=CURRENT ROW)
    |         +-AnalyticFunctionGroup
    |         | +-partition_by=
    |         | | +-WindowPartitioning
    |         | |   +-partition_by_list=
    |         | |     +-ColumnRef(type=STRING, column=$union_all.value#6)
    |         | +-analytic_function_list=
    |         |   +-$analytic2#8 :=
    |         |     +-AnalyticFunctionCall(sample_functions:afn_agg(INT64, STRING) -> INT64)
    |         |       +-ColumnRef(type=INT64, column=$union_all.key#5)
    |         |       +-ColumnRef(type=STRING, column=$union_all.value#6)
    |         |       +-window_frame=
    |         |         +-WindowFrame(frame_unit=ROWS)
    |         |           +-start_expr=
    |         |           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
    |         |           +-end_expr=
    |         |             +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
    |         +-AnalyticFunctionGroup
    |           +-order_by=
    |           | +-WindowOrdering
    |           |   +-order_by_item_list=
    |           |     +-OrderByItem
    |           |       +-column_ref=
    |           |         +-ColumnRef(type=INT64, column=$union_all.key#5)
    |           +-analytic_function_list=
    |             +-$analytic3#9 :=
    |               +-AnalyticFunctionCall(sample_functions:afn_agg(STRING) -> INT64)
    |                 +-ColumnRef(type=STRING, column=$union_all.value#6)
    |                 +-window_frame=
    |                   +-WindowFrame(frame_unit=RANGE)
    |                     +-start_expr=
    |                     | +-WindowFrameExpr(boundary_type=OFFSET PRECEDING)
    |                     |   +-Literal(type=INT64, value=2)
    |                     +-end_expr=
    |                       +-WindowFrameExpr(boundary_type=CURRENT ROW)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$analytic.$analytic1#7)
      +-OrderByItem
      | +-column_ref=
      | | +-ColumnRef(type=INT64, column=$analytic.$analytic2#8)
      | +-is_descending=TRUE
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol3#11)
==

select key as col from keyvalue
union all
select key from keyvalue
order by afn_agg(col) over (partition by col+1 order by col+1) ASC
--
QueryStmt
+-output_column_list=
| +-$union_all.col#5 AS col [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$union_all.col#5, $analytic.$analytic1#6]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AnalyticScan
    |   +-column_list=[$union_all.col#5, $analytic.$analytic1#6]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all.col#5, $partitionby.$partitionbycol1#7, $orderby.$orderbycol1#8]
    |   |   +-expr_list=
    |   |   | +-$partitionbycol1#7 :=
    |   |   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |   | |   +-ColumnRef(type=INT64, column=$union_all.col#5)
    |   |   | |   +-Literal(type=INT64, value=1)
    |   |   | +-$orderbycol1#8 :=
    |   |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |   |     +-ColumnRef(type=INT64, column=$union_all.col#5)
    |   |   |     +-Literal(type=INT64, value=1)
    |   |   +-input_scan=
    |   |     +-SetOperationScan
    |   |       +-column_list=[$union_all.col#5]
    |   |       +-op_type=UNION_ALL
    |   |       +-input_item_list=
    |   |         +-SetOperationItem
    |   |         | +-scan=
    |   |         | | +-ProjectScan
    |   |         | |   +-column_list=[KeyValue.Key#1]
    |   |         | |   +-input_scan=
    |   |         | |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   |         | +-output_column_list=[KeyValue.Key#1]
    |   |         +-SetOperationItem
    |   |           +-scan=
    |   |           | +-ProjectScan
    |   |           |   +-column_list=[KeyValue.Key#3]
    |   |           |   +-input_scan=
    |   |           |     +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0])
    |   |           +-output_column_list=[KeyValue.Key#3]
    |   +-function_group_list=
    |     +-AnalyticFunctionGroup
    |       +-partition_by=
    |       | +-WindowPartitioning
    |       |   +-partition_by_list=
    |       |     +-ColumnRef(type=INT64, column=$partitionby.$partitionbycol1#7)
    |       +-order_by=
    |       | +-WindowOrdering
    |       |   +-order_by_item_list=
    |       |     +-OrderByItem
    |       |       +-column_ref=
    |       |         +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#8)
    |       +-analytic_function_list=
    |         +-$analytic1#6 :=
    |           +-AnalyticFunctionCall(sample_functions:afn_agg(INT64) -> INT64)
    |             +-ColumnRef(type=INT64, column=$union_all.col#5)
    |             +-window_frame=
    |               +-WindowFrame(frame_unit=RANGE)
    |                 +-start_expr=
    |                 | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
    |                 +-end_expr=
    |                   +-WindowFrameExpr(boundary_type=CURRENT ROW)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
==

select distinct key as col, afn_agg(key) over () as analyticcol
from keyvalue
order by analyticcol
--
QueryStmt
+-output_column_list=
| +-$distinct.Key#5 AS col [INT64]
| +-$distinct.analyticcol#6 AS analyticcol [INT64]
+-query=
  +-OrderByScan
    +-column_list=$distinct.[Key#5, analyticcol#6]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=$distinct.[Key#5, analyticcol#6]
    |   +-input_scan=
    |   | +-AnalyticScan
    |   |   +-column_list=[KeyValue.Key#1, $analytic.analyticcol#4]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   |   +-function_group_list=
    |   |     +-AnalyticFunctionGroup
    |   |       +-analytic_function_list=
    |   |         +-analyticcol#4 :=
    |   |           +-AnalyticFunctionCall(sample_functions:afn_agg(INT64) -> INT64)
    |   |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |             +-window_frame=
    |   |               +-WindowFrame(frame_unit=ROWS)
    |   |                 +-start_expr=
    |   |                 | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
    |   |                 +-end_expr=
    |   |                   +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
    |   +-group_by_list=
    |     +-Key#5 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-analyticcol#6 := ColumnRef(type=INT64, column=$analytic.analyticcol#4)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$distinct.analyticcol#6)
==

select distinct key as col, afn_agg(key) over () as analyticcol
from keyvalue
order by 1, 2
--
QueryStmt
+-output_column_list=
| +-$distinct.Key#5 AS col [INT64]
| +-$distinct.analyticcol#6 AS analyticcol [INT64]
+-query=
  +-OrderByScan
    +-column_list=$distinct.[Key#5, analyticcol#6]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=$distinct.[Key#5, analyticcol#6]
    |   +-input_scan=
    |   | +-AnalyticScan
    |   |   +-column_list=[KeyValue.Key#1, $analytic.analyticcol#4]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   |   +-function_group_list=
    |   |     +-AnalyticFunctionGroup
    |   |       +-analytic_function_list=
    |   |         +-analyticcol#4 :=
    |   |           +-AnalyticFunctionCall(sample_functions:afn_agg(INT64) -> INT64)
    |   |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |             +-window_frame=
    |   |               +-WindowFrame(frame_unit=ROWS)
    |   |                 +-start_expr=
    |   |                 | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
    |   |                 +-end_expr=
    |   |                   +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
    |   +-group_by_list=
    |     +-Key#5 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-analyticcol#6 := ColumnRef(type=INT64, column=$analytic.analyticcol#4)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$distinct.Key#5)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$distinct.analyticcol#6)
==

select distinct key as col, afn_agg(key) over () as analyticcol
from keyvalue
order by 1, 2, afn_agg(key) over (), afn_agg(col) over()
--
ERROR: Analytic function not allowed in ORDER BY clause after SELECT DISTINCT [at 3:16]
order by 1, 2, afn_agg(key) over (), afn_agg(col) over()
               ^
==

select key as col, value as col from keyvalue
union all
select key, value from keyvalue
order by afn_agg() over (partition by col)
--
ERROR: Column name col is ambiguous [at 4:39]
order by afn_agg() over (partition by col)
                                      ^
==

select key as col from keyvalue
union all
select key from keyvalue
order by afn_agg() over (partition by key)
--
ERROR: Unrecognized name: key [at 4:39]
order by afn_agg() over (partition by key)
                                      ^
==

select key from keyvalue
union all
select key as col from keyvalue
order by afn_agg() over (partition by col)
--
ERROR: Unrecognized name: col [at 4:39]
order by afn_agg() over (partition by col)
                                      ^
==

# Named window references are disallowed in analytic functions in ORDER BY
# after set operation.
select 1 from keyvalue
union all
select 1 from keyvalue
window w as ()
order by afn_agg() over w
--
ERROR: Cannot reference a named window in ORDER BY clause after set operation [at 5:25]
order by afn_agg() over w
                        ^
==

select 1 from keyvalue
window w as ()
union all
select 1 from keyvalue
order by afn_agg() over w
--
ERROR: Cannot reference a named window in ORDER BY clause after set operation [at 5:25]
order by afn_agg() over w
                        ^
==

# Aggregations are not allowed in ORDER BY after set operation.
select key from keyvalue
union all
select key from keyvalue
order by afn_agg(sum(key)) over ()
--
ERROR: Aggregate function SUM not allowed in ORDER BY clause after set operation [at 4:18]
order by afn_agg(sum(key)) over ()
                 ^
==

select key from keyvalue
union all
select key from keyvalue
order by afn_agg() over (partition by sum(key))
--
ERROR: Aggregate function SUM not allowed in PARTITION BY [at 4:39]
order by afn_agg() over (partition by sum(key))
                                      ^
==

select key from keyvalue
union all
select key from keyvalue
order by afn_agg() over (order by sum(key))
--
ERROR: Aggregate function SUM not allowed in Window ORDER BY [at 4:35]
order by afn_agg() over (order by sum(key))
                                  ^
==

# Some Tenzing GSQLizer tests that previously failed.
SELECT int32 AS foo,
       cast(rank() OVER (PARTITION BY int32 ORDER BY int32) AS int64)
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-SimpleTypes.int32#1 AS foo [INT32]
| +-$analytic.$analytic1#20 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[SimpleTypes.int32#1, $analytic.$analytic1#20]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int32#1, $analytic.$analytic1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            +-analytic_function_list=
              +-$analytic1#20 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
==

SELECT any_value(a) OVER (PARTITION BY b ORDER BY a) AS a,
       any_value(b) OVER (PARTITION BY b ORDER BY a)
FROM (SELECT 1 AS a, 2 AS b)
--
QueryStmt
+-output_column_list=
| +-$analytic.a#5 AS a [INT64]
| +-$analytic.$analytic2#6 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[a#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$subquery1.a#1, $subquery1.b#2, $analytic.a#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$subquery1.[a#1, b#2]
        |   +-expr_list=
        |   | +-a#1 := Literal(type=INT64, value=1)
        |   | +-b#2 := Literal(type=INT64, value=2)
        |   +-input_scan=
        |     +-SingleRowScan
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-partition_by=
          | | +-WindowPartitioning
          | |   +-partition_by_list=
          | |     +-ColumnRef(type=INT64, column=$subquery1.b#2)
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=INT64, column=$subquery1.a#1)
          | +-analytic_function_list=
          |   +-a#5 :=
          |     +-AnalyticFunctionCall(ZetaSQL:any_value(INT64) -> INT64)
          |       +-ColumnRef(type=INT64, column=$subquery1.a#1)
          |       +-window_frame=
          |         +-WindowFrame(frame_unit=RANGE)
          |           +-start_expr=
          |           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
          |           +-end_expr=
          |             +-WindowFrameExpr(boundary_type=CURRENT ROW)
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=$subquery1.b#2)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=$subquery1.a#1)
            +-analytic_function_list=
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:any_value(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=$subquery1.b#2)
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

# Test case similar to b/36140904.
# No ProjectScan in between AggregateScan and FilterScan for HAVING, since
# the only project expression contains an analytic function and must be computed
# after AnalyticScan.
SELECT MIN(a) OVER (PARTITION BY b ORDER BY a) > 1
FROM (SELECT 1 AS a, 2 AS b)
GROUP BY a, b
HAVING a > 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |     +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$groupby.a#4, $groupby.b#5, $analytic.$analytic1#6]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=$groupby.[a#4, b#5]
        |   +-input_scan=
        |   | +-AggregateScan
        |   |   +-column_list=$groupby.[a#4, b#5]
        |   |   +-input_scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=$subquery1.[a#1, b#2]
        |   |   |   +-expr_list=
        |   |   |   | +-a#1 := Literal(type=INT64, value=1)
        |   |   |   | +-b#2 := Literal(type=INT64, value=2)
        |   |   |   +-input_scan=
        |   |   |     +-SingleRowScan
        |   |   +-group_by_list=
        |   |     +-a#4 := ColumnRef(type=INT64, column=$subquery1.a#1)
        |   |     +-b#5 := ColumnRef(type=INT64, column=$subquery1.b#2)
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$groupby.a#4)
        |       +-Literal(type=INT64, value=1)
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=$groupby.b#5)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=$groupby.a#4)
            +-analytic_function_list=
              +-$analytic1#6 :=
                +-AnalyticFunctionCall(ZetaSQL:min(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=$groupby.a#4)
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

# Test case similar to b/29214548.
# A ProjectScan in between AggregateScan and FilterScan for HAVING is necessary
# to compute 'min_c_plus_1'. We include two computed columns in the ProjectScan
# that do not contain analytic functions.
SELECT MIN(c) + 1 min_c_plus_1,
       MAX(c) + 1,
       MIN(a) OVER (PARTITION BY b ORDER BY a) > 1,
       MIN(MAX(c)) OVER (PARTITION BY b ORDER BY a) + 1
FROM (SELECT 1 AS a, 2 AS b, 3 AS c)
GROUP BY a, b
HAVING min_c_plus_1 > 1
--
QueryStmt
+-output_column_list=
| +-$query.min_c_plus_1#11 AS min_c_plus_1 [INT64]
| +-$query.$col2#12 AS `$col2` [INT64]
| +-$query.$col3#14 AS `$col3` [BOOL]
| +-$query.$col4#16 AS `$col4` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[min_c_plus_1#11, $col2#12, $col3#14, $col4#16]
    +-expr_list=
    | +-$col3#14 :=
    | | +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    | |   +-ColumnRef(type=INT64, column=$analytic.$analytic1#13)
    | |   +-Literal(type=INT64, value=1)
    | +-$col4#16 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-ColumnRef(type=INT64, column=$analytic.$analytic2#15)
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$aggregate.$agg1#4, $aggregate.$agg2#5, $aggregate.$agg3#7, $groupby.a#9, $groupby.b#10, $query.min_c_plus_1#11, $query.$col2#12, $analytic.$analytic1#13, $analytic.$analytic2#15]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[$aggregate.$agg1#4, $aggregate.$agg2#5, $aggregate.$agg3#7, $groupby.a#9, $groupby.b#10, $query.min_c_plus_1#11, $query.$col2#12]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#4, $aggregate.$agg2#5, $aggregate.$agg3#7, $groupby.a#9, $groupby.b#10, $query.min_c_plus_1#11, $query.$col2#12]
        |   |   +-expr_list=
        |   |   | +-min_c_plus_1#11 :=
        |   |   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |   | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1#4)
        |   |   | |   +-Literal(type=INT64, value=1)
        |   |   | +-$col2#12 :=
        |   |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |   |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#5)
        |   |   |     +-Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-AggregateScan
        |   |       +-column_list=[$groupby.a#9, $groupby.b#10, $aggregate.$agg1#4, $aggregate.$agg2#5, $aggregate.$agg3#7]
        |   |       +-input_scan=
        |   |       | +-ProjectScan
        |   |       |   +-column_list=$subquery1.[a#1, b#2, c#3]
        |   |       |   +-expr_list=
        |   |       |   | +-a#1 := Literal(type=INT64, value=1)
        |   |       |   | +-b#2 := Literal(type=INT64, value=2)
        |   |       |   | +-c#3 := Literal(type=INT64, value=3)
        |   |       |   +-input_scan=
        |   |       |     +-SingleRowScan
        |   |       +-group_by_list=
        |   |       | +-a#9 := ColumnRef(type=INT64, column=$subquery1.a#1)
        |   |       | +-b#10 := ColumnRef(type=INT64, column=$subquery1.b#2)
        |   |       +-aggregate_list=
        |   |         +-$agg1#4 :=
        |   |         | +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
        |   |         |   +-ColumnRef(type=INT64, column=$subquery1.c#3)
        |   |         +-$agg2#5 :=
        |   |         | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
        |   |         |   +-ColumnRef(type=INT64, column=$subquery1.c#3)
        |   |         +-$agg3#7 :=
        |   |           +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
        |   |             +-ColumnRef(type=INT64, column=$subquery1.c#3)
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$query.min_c_plus_1#11)
        |       +-Literal(type=INT64, value=1)
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-partition_by=
          | | +-WindowPartitioning
          | |   +-partition_by_list=
          | |     +-ColumnRef(type=INT64, column=$groupby.b#10)
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=INT64, column=$groupby.a#9)
          | +-analytic_function_list=
          |   +-$analytic1#13 :=
          |     +-AnalyticFunctionCall(ZetaSQL:min(INT64) -> INT64)
          |       +-ColumnRef(type=INT64, column=$groupby.a#9)
          |       +-window_frame=
          |         +-WindowFrame(frame_unit=RANGE)
          |           +-start_expr=
          |           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
          |           +-end_expr=
          |             +-WindowFrameExpr(boundary_type=CURRENT ROW)
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=$groupby.b#10)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=$groupby.a#9)
            +-analytic_function_list=
              +-$analytic2#15 :=
                +-AnalyticFunctionCall(ZetaSQL:min(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=$aggregate.$agg3#7)
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

SELECT 'a' AS foo,
       cast(rank() OVER (PARTITION BY a, b ORDER BY a) AS int64)
FROM (SELECT 1 AS a, 2 AS b)
--
QueryStmt
+-output_column_list=
| +-$query.foo#4 AS foo [STRING]
| +-$analytic.$analytic1#5 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.foo#4, $analytic.$analytic1#5]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$subquery1.a#1, $subquery1.b#2, $query.foo#4, $analytic.$analytic1#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$subquery1.a#1, $subquery1.b#2, $query.foo#4]
        |   +-expr_list=
        |   | +-foo#4 := Literal(type=STRING, value="a")
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=$subquery1.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=INT64, value=2)
        |       +-input_scan=
        |         +-SingleRowScan
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=$subquery1.a#1)
            |     +-ColumnRef(type=INT64, column=$subquery1.b#2)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=$subquery1.a#1)
            +-analytic_function_list=
              +-$analytic1#5 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
==

SELECT 'a' AS foo,
       cast(rank() OVER (ORDER BY a) AS int64)
FROM (SELECT 1 AS a, 2 AS b)
--
QueryStmt
+-output_column_list=
| +-$query.foo#4 AS foo [STRING]
| +-$analytic.$analytic1#5 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.foo#4, $analytic.$analytic1#5]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$subquery1.a#1, $subquery1.b#2, $query.foo#4, $analytic.$analytic1#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$subquery1.a#1, $subquery1.b#2, $query.foo#4]
        |   +-expr_list=
        |   | +-foo#4 := Literal(type=STRING, value="a")
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=$subquery1.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=INT64, value=2)
        |       +-input_scan=
        |         +-SingleRowScan
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=$subquery1.a#1)
            +-analytic_function_list=
              +-$analytic1#5 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
==

# Test analytic functions with SELECT list aliases.
# They are only available when the analytic function is in the ORDER BY.

select int32 as foo, rank() over (order by foo)
from SimpleTypes
--
ERROR: Unrecognized name: foo [at 1:44]
select int32 as foo, rank() over (order by foo)
                                           ^
==

select int32 as foo, rank() over (partition by foo order by int64)
from SimpleTypes
--
ERROR: Unrecognized name: foo [at 1:48]
select int32 as foo, rank() over (partition by foo order by int64)
                                               ^
==

select int32 as foo, any_value(foo) over ()
from SimpleTypes
--
ERROR: Unrecognized name: foo [at 1:32]
select int32 as foo, any_value(foo) over ()
                               ^
==

select int32 as foo
from SimpleTypes
order by rank() over (order by foo),
         rank() over (partition by foo order by int32),
         any_value(foo) over ()
--
QueryStmt
+-output_column_list=
| +-SimpleTypes.int32#1 AS foo [INT32]
+-query=
  +-OrderByScan
    +-column_list=[SimpleTypes.int32#1]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AnalyticScan
    |   +-column_list=[SimpleTypes.int32#1, $analytic.$analytic1#19, $analytic.$analytic2#20, $analytic.$analytic3#21]
    |   +-input_scan=
    |   | +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    |   +-function_group_list=
    |     +-AnalyticFunctionGroup
    |     | +-order_by=
    |     | | +-WindowOrdering
    |     | |   +-order_by_item_list=
    |     | |     +-OrderByItem
    |     | |       +-column_ref=
    |     | |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    |     | +-analytic_function_list=
    |     |   +-$analytic1#19 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
    |     +-AnalyticFunctionGroup
    |     | +-partition_by=
    |     | | +-WindowPartitioning
    |     | |   +-partition_by_list=
    |     | |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    |     | +-order_by=
    |     | | +-WindowOrdering
    |     | |   +-order_by_item_list=
    |     | |     +-OrderByItem
    |     | |       +-column_ref=
    |     | |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    |     | +-analytic_function_list=
    |     |   +-$analytic2#20 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
    |     +-AnalyticFunctionGroup
    |       +-analytic_function_list=
    |         +-$analytic3#21 :=
    |           +-AnalyticFunctionCall(ZetaSQL:any_value(INT32) -> INT32)
    |             +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    |             +-window_frame=
    |               +-WindowFrame(frame_unit=ROWS)
    |                 +-start_expr=
    |                 | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
    |                 +-end_expr=
    |                   +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$analytic.$analytic1#19)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$analytic.$analytic2#20)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$analytic.$analytic3#21)
==

select DISTINCT int32 as foo
from SimpleTypes
order by rank() over (order by foo)
--
ERROR: Analytic function not allowed in ORDER BY clause after SELECT DISTINCT [at 3:10]
order by rank() over (order by foo)
         ^
==

select int32 as foo, sum(int64) as sum_int64
from SimpleTypes
group by foo, 1, int32
order by rank() over (order by foo);
--
QueryStmt
+-output_column_list=
| +-$groupby.foo#20 AS foo [INT32]
| +-$aggregate.sum_int64#19 AS sum_int64 [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.foo#20, $aggregate.sum_int64#19]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AnalyticScan
    |   +-column_list=[$groupby.foo#20, $aggregate.sum_int64#19, $analytic.$analytic1#21]
    |   +-input_scan=
    |   | +-AggregateScan
    |   |   +-column_list=[$groupby.foo#20, $aggregate.sum_int64#19]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    |   |   +-group_by_list=
    |   |   | +-foo#20 := ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    |   |   +-aggregate_list=
    |   |     +-sum_int64#19 :=
    |   |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |   |         +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    |   +-function_group_list=
    |     +-AnalyticFunctionGroup
    |       +-order_by=
    |       | +-WindowOrdering
    |       |   +-order_by_item_list=
    |       |     +-OrderByItem
    |       |       +-column_ref=
    |       |         +-ColumnRef(type=INT32, column=$groupby.foo#20)
    |       +-analytic_function_list=
    |         +-$analytic1#21 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$analytic.$analytic1#21)
==

select int32 as foo
from SimpleTypes
group by foo, 1, int32
order by rank() over (order by int32);
--
QueryStmt
+-output_column_list=
| +-$groupby.foo#19 AS foo [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.foo#19]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AnalyticScan
    |   +-column_list=[$groupby.foo#19, $analytic.$analytic1#20]
    |   +-input_scan=
    |   | +-AggregateScan
    |   |   +-column_list=[$groupby.foo#19]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    |   |   +-group_by_list=
    |   |     +-foo#19 := ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    |   +-function_group_list=
    |     +-AnalyticFunctionGroup
    |       +-order_by=
    |       | +-WindowOrdering
    |       |   +-order_by_item_list=
    |       |     +-OrderByItem
    |       |       +-column_ref=
    |       |         +-ColumnRef(type=INT32, column=$groupby.foo#19)
    |       +-analytic_function_list=
    |         +-$analytic1#20 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$analytic.$analytic1#20)
==

[language_features=ANALYTIC_FUNCTIONS,V_1_1_ORDER_BY_IN_AGGREGATE]
select afn_agg(key order by value) over ()
from KeyValue;
--
ERROR: ORDER BY in arguments is not supported on analytic functions [at 1:8]
select afn_agg(key order by value) over ()
       ^
==

[language_features=ANALYTIC_FUNCTIONS,V_1_1_LIMIT_IN_AGGREGATE]
select afn_agg(key limit 3) over ()
from KeyValue;
--
ERROR: LIMIT in arguments is not supported on analytic functions [at 1:8]
select afn_agg(key limit 3) over ()
       ^
==

[language_features=ANALYTIC_FUNCTIONS,V_1_1_HAVING_IN_AGGREGATE]
select afn_agg(key having max value) over ()
from KeyValue;
--
ERROR: HAVING modifier is not supported on analytic functions [at 1:8]
select afn_agg(key having max value) over ()
       ^
==

# Analytic function with IGNORE NULLS.
[language_features=ANALYTIC_FUNCTIONS{{,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC|}}]
select afn_null_handling(key ignore nulls) over ()
from KeyValue;
--
ALTERNATION GROUP: ,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(sample_functions:afn_null_handling(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-null_handling_modifier=IGNORE_NULLS
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 1:8]
select afn_null_handling(key ignore nulls) over ()
       ^
==

# Analytic function with RESPECT NULLS.
[language_features=ANALYTIC_FUNCTIONS{{,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC|}}]

select afn_null_handling(key respect nulls) over ()
from KeyValue;
--
ALTERNATION GROUP: ,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(sample_functions:afn_null_handling(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-null_handling_modifier=RESPECT_NULLS
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 1:8]
select afn_null_handling(key respect nulls) over ()
       ^
==

# Analytic function with DISTINCT and IGNORE NULLS.
[language_features=ANALYTIC_FUNCTIONS,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC]
select afn_null_handling(distinct key ignore nulls) over ()
from KeyValue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(sample_functions:afn_null_handling(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-distinct=TRUE
                  +-null_handling_modifier=IGNORE_NULLS
==

# Analytic function with DISTINCT, multiple arguments and RESPECT NULLS.
[language_features=ANALYTIC_FUNCTIONS,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC]
select afn_null_handling(distinct key, value respect nulls) over ()
from KeyValue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(sample_functions:afn_null_handling(INT64, STRING) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-distinct=TRUE
                  +-null_handling_modifier=RESPECT_NULLS
==

# Analytic function with IGNORE NULLS and window ORDER BY.
[language_features=ANALYTIC_FUNCTIONS,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC]
select afn_null_handling(key ignore nulls) over (order by value)
from KeyValue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(sample_functions:afn_null_handling(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-null_handling_modifier=IGNORE_NULLS
==

# Analytic function with multiple arguments RESPECT NULLS and window ORDER BY.
[language_features=ANALYTIC_FUNCTIONS,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC]
select afn_null_handling(key, value respect nulls) over (order by value)
from KeyValue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(sample_functions:afn_null_handling(INT64, STRING) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-null_handling_modifier=RESPECT_NULLS
==

# Unsupported analytic function with IGNORE NULLS.
[language_features=ANALYTIC_FUNCTIONS{{,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC|}}]
select afn_agg(key ignore nulls) over ()
from KeyValue;
--
ALTERNATION GROUP: ,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC
--
ERROR: IGNORE NULLS and RESPECT NULLS are not allowed for analytic function SAMPLE_FUNCTIONS:AFN_AGG [at 1:8]
select afn_agg(key ignore nulls) over ()
       ^
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 1:8]
select afn_agg(key ignore nulls) over ()
       ^
==

# Analytic function with RESPECT NULLS.
[language_features=ANALYTIC_FUNCTIONS{{,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC|}}]

select afn_agg(key respect nulls) over ()
from KeyValue;
--
ALTERNATION GROUP: ,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC
--
ERROR: IGNORE NULLS and RESPECT NULLS are not allowed for analytic function SAMPLE_FUNCTIONS:AFN_AGG [at 1:8]
select afn_agg(key respect nulls) over ()
       ^
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 1:8]
select afn_agg(key respect nulls) over ()
       ^

==

# Invalid function name errors should be reported before analyzer argument errors.
[language_features=ANALYTIC_FUNCTIONS]
select garbage(*) over ()
--
ERROR: Function not found: garbage [at 1:8]
select garbage(*) over ()
       ^
==

# IGNORE/RESPECT NULLS not allowed in analytic COUNT(*)
[language_features=ANALYTIC_FUNCTIONS,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC]
select
  {{count|anon_count}}(* {{ignore|respect}} nulls) over ()
from KeyValue;
--
ALTERNATION GROUP: count,ignore
--
ERROR: IGNORE NULLS and RESPECT NULLS are not allowed for analytic function COUNT(*) [at 2:3]
  count(* ignore nulls) over ()
  ^
--
ALTERNATION GROUP: count,respect
--
ERROR: IGNORE NULLS and RESPECT NULLS are not allowed for analytic function COUNT(*) [at 2:3]
  count(* respect nulls) over ()
  ^
--
ALTERNATION GROUP: anon_count,ignore
--
ERROR: Function not found: anon_count; Did you mean anon_test? [at 2:3]
  anon_count(* ignore nulls) over ()
  ^
--
ALTERNATION GROUP: anon_count,respect
--
ERROR: Function not found: anon_count; Did you mean anon_test? [at 2:3]
  anon_count(* respect nulls) over ()
  ^
==

select DATE_ADD(MAX(snapshot_date), INTERVAL 1 DAY)
OVER (PARTITION BY person_id ORDER BY snapshot_date DESC)
AS most_recent_date_opted_in
FROM (SELECT 1 person_id, CURRENT_DATE() snapshot_date UNION ALL
      SELECT 2, CURRENT_DATE() UNION ALL
      SELECT 3, CURRENT_DATE())
--
ERROR: Function DATE_ADD does not support an OVER clause [at 1:8]
select DATE_ADD(MAX(snapshot_date), INTERVAL 1 DAY)
       ^
==

select DATE_ADD(snapshot_date, INTERVAL 1 DAY)
OVER (PARTITION BY person_id ORDER BY snapshot_date DESC)
AS most_recent_date_opted_in
FROM (SELECT 1 person_id, CURRENT_DATE() snapshot_date UNION ALL
      SELECT 2, CURRENT_DATE() UNION ALL
      SELECT 3, CURRENT_DATE())
--
ERROR: Function DATE_ADD does not support an OVER clause [at 1:8]
select DATE_ADD(snapshot_date, INTERVAL 1 DAY)
       ^
==

select PARSE_DATE(snapshot_date)
OVER (PARTITION BY person_id ORDER BY snapshot_date DESC)
AS most_recent_date_opted_in
FROM (SELECT 1 person_id, CURRENT_DATE() snapshot_date UNION ALL
      SELECT 2, CURRENT_DATE() UNION ALL
      SELECT 3, CURRENT_DATE())
--
ERROR: Function PARSE_DATE does not support an OVER clause [at 1:8]
select PARSE_DATE(snapshot_date)
       ^
