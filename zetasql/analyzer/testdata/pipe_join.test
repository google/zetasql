[default language_features=PIPES,TABLE_VALUED_FUNCTIONS,TABLESAMPLE,TABLESAMPLE_FROM_TABLE_VALUED_FUNCTIONS]
# At least one of these needs an alias, same as in a regular join, since we get
# a range variable for each.
from KeyValue
|> JOIN KeyValue USING (key)
--
ERROR: Duplicate table alias KeyValue in the same FROM clause [at 4:18]
|> JOIN KeyValue USING (key)
                 ^
==

from KeyValue
|> JOIN KeyValue k2
--
ERROR: INNER JOIN must have an immediately following ON or USING clause [at 2:4]
|> JOIN KeyValue k2
   ^
==

# The table from the pipe input is not visible as a table name in the rhs.
from KeyValue kv
|> CROSS JOIN (SELECT * FROM kv)
--
ERROR: Table not found: kv [at 2:30]
|> CROSS JOIN (SELECT * FROM kv)
                             ^
==

# We have a range variable for both lhs and rhs inputs in the output.
from KeyValue
|> JOIN KeyValue kv2 USING (key)
|> WHERE KeyValue.key = kv2.key
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Value#4 AS Value [STRING]
+-query=
  +-FilterScan
    +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    +-input_scan=
    | +-JoinScan
    |   +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    |   +-left_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-right_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
    |   +-join_expr=
    |   | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
    |   +-has_using=TRUE
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-ColumnRef(type=INT64, column=KeyValue.Key#3)
==

from KeyValue
|> JOIN KeyValue USING (KeyValue)
--
ERROR: Name KeyValue in USING clause is a table alias, not a column name, on left side of join [at 2:25]
|> JOIN KeyValue USING (KeyValue)
                        ^
==

# With successive joins, we still propagate all the the range variables from
# earlier lhs inputs.
# SELECT * produces the columns as expected from JOIN USING.
from KeyValue kv1
|> JOIN KeyValue kv2 USING (key)
|> JOIN KeyValue kv3 USING (key)
|> WHERE kv1.key + kv2.key = kv3.key
|> SELECT *
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Value#4 AS Value [STRING]
| +-KeyValue.Value#6 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=KeyValue.[Key#1, Value#2, Value#4, Value#6]
    +-input_scan=
      +-FilterScan
        +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4, Key#5, Value#6]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4, Key#5, Value#6]
        |   +-left_scan=
        |   | +-JoinScan
        |   |   +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
        |   |   +-left_scan=
        |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv1")
        |   |   +-right_scan=
        |   |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
        |   |   +-join_expr=
        |   |   | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        |   |   +-has_using=TRUE
        |   +-right_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#5, Value#6], table=KeyValue, column_index_list=[0, 1], alias="kv3")
        |   +-join_expr=
        |   | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#5)
        |   +-has_using=TRUE
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            | +-ColumnRef(type=INT64, column=KeyValue.Key#3)
            +-ColumnRef(type=INT64, column=KeyValue.Key#5)
==

from KeyValue kv1
|> JOIN KeyValue kv2 ON kv1.key = kv2.key
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Key#3 AS Key [INT64]
| +-KeyValue.Value#4 AS Value [STRING]
+-query=
  +-JoinScan
    +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    +-left_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv1")
    +-right_scan=
    | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
    +-join_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-ColumnRef(type=INT64, column=KeyValue.Key#3)
==

# JOIN with two anonymous input tables works with JOIN USING.
(select 1 x, 2 y)
|> JOIN (select 3 x, 4 z) USING (x)
--
QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [INT64]
| +-$query.y#2 AS y [INT64]
| +-$subquery1.z#4 AS z [INT64]
+-query=
  +-JoinScan
    +-column_list=[$query.x#1, $query.y#2, $subquery1.x#3, $subquery1.z#4]
    +-left_scan=
    | +-ProjectScan
    |   +-column_list=$query.[x#1, y#2]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-SingleRowScan
    +-right_scan=
    | +-ProjectScan
    |   +-column_list=$subquery1.[x#3, z#4]
    |   +-expr_list=
    |   | +-x#3 := Literal(type=INT64, value=3)
    |   | +-z#4 := Literal(type=INT64, value=4)
    |   +-input_scan=
    |     +-SingleRowScan
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=$query.x#1)
    |   +-ColumnRef(type=INT64, column=$subquery1.x#3)
    +-has_using=TRUE
==

# With an anonymous lhs table, we can't write JOIN ON since referencing an lhs
# column would be ambiguous. So we should give an alias to the lhs table, see
# the next case below.
(select 1 x, 2 y)
|> JOIN (select 3 x, 4 z) t2 ON t2.x=x
--
ERROR: Column name x is ambiguous [at 2:38]
|> JOIN (select 3 x, 4 z) t2 ON t2.x=x
                                     ^
==

(select 1 x, 2 y)
|> AS t1
|> JOIN (select 3 x, 4 z) t2 ON t2.x=t1.x;
--
QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [INT64]
| +-$query.y#2 AS y [INT64]
| +-t2.x#3 AS x [INT64]
| +-t2.z#4 AS z [INT64]
+-query=
  +-JoinScan
    +-column_list=[$query.x#1, $query.y#2, t2.x#3, t2.z#4]
    +-left_scan=
    | +-ProjectScan
    |   +-column_list=$query.[x#1, y#2]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-SingleRowScan
    +-right_scan=
    | +-ProjectScan
    |   +-column_list=t2.[x#3, z#4]
    |   +-expr_list=
    |   | +-x#3 := Literal(type=INT64, value=3)
    |   | +-z#4 := Literal(type=INT64, value=4)
    |   +-input_scan=
    |     +-SingleRowScan
    +-join_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=t2.x#3)
        +-ColumnRef(type=INT64, column=$query.x#1)
==

# This error comes from regular JOIN.
from TestTable
|> join KitchenSink.repeated_int32_val
--
ERROR: Aliases referenced in the from clause must refer to preceding scans, and cannot refer to columns on those scans. KitchenSink refers to a column and must be qualified with a table name. [at 2:9]
|> join KitchenSink.repeated_int32_val
        ^
==

# Join to unnest an array, with various forms.
from TestTable tt
|> join tt.KitchenSink.repeated_int32_val
|> left join tt.KitchenSink.repeated_bytes_val WITH OFFSET off
|> join UNNEST(KitchenSink.repeated_string_val) WITH OFFSET
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
| +-$array.repeated_int32_val#4 AS repeated_int32_val [INT32]
| +-$array.repeated_bytes_val#5 AS repeated_bytes_val [BYTES]
| +-$array_offset.off#6 AS off [INT64]
| +-$array.$unnest1#7 AS `$unnest1` [STRING]
| +-$array_offset.offset#8 AS offset [INT64]
+-query=
  +-ArrayScan
    +-column_list=[TestTable.key#1, TestTable.TestEnum#2, TestTable.KitchenSink#3, $array.repeated_int32_val#4, $array.repeated_bytes_val#5, $array_offset.off#6, $array.$unnest1#7, $array_offset.offset#8]
    +-input_scan=
    | +-ArrayScan
    |   +-column_list=[TestTable.key#1, TestTable.TestEnum#2, TestTable.KitchenSink#3, $array.repeated_int32_val#4, $array.repeated_bytes_val#5, $array_offset.off#6]
    |   +-input_scan=
    |   | +-ArrayScan
    |   |   +-column_list=[TestTable.key#1, TestTable.TestEnum#2, TestTable.KitchenSink#3, $array.repeated_int32_val#4]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2], alias="tt")
    |   |   +-array_expr_list=
    |   |   | +-GetProtoField
    |   |   |   +-type=ARRAY<INT32>
    |   |   |   +-expr=
    |   |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   |   |   +-field_descriptor=repeated_int32_val
    |   |   |   +-default_value=[]
    |   |   +-element_column_list=[$array.repeated_int32_val#4]
    |   +-array_expr_list=
    |   | +-GetProtoField
    |   |   +-type=ARRAY<BYTES>
    |   |   +-expr=
    |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   |   +-field_descriptor=repeated_bytes_val
    |   |   +-default_value=[]
    |   +-element_column_list=[$array.repeated_bytes_val#5]
    |   +-array_offset_column=
    |   | +-ColumnHolder(column=$array_offset.off#6)
    |   +-is_outer=TRUE
    +-array_expr_list=
    | +-GetProtoField
    |   +-type=ARRAY<STRING>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=repeated_string_val
    |   +-default_value=[]
    +-element_column_list=[$array.$unnest1#7]
    +-array_offset_column=
      +-ColumnHolder(column=$array_offset.offset#8)
==

# Multiple layers, unnesting protos.
from TestTable
|> join TestTable.KitchenSink.nested_repeated_value
|> join nested_repeated_value.value
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
| +-$array.nested_repeated_value#4 AS nested_repeated_value [PROTO<zetasql_test__.KitchenSinkPB.Nested>]
| +-$array.value#5 AS value [INT32]
+-query=
  +-ArrayScan
    +-column_list=[TestTable.key#1, TestTable.TestEnum#2, TestTable.KitchenSink#3, $array.nested_repeated_value#4, $array.value#5]
    +-input_scan=
    | +-ArrayScan
    |   +-column_list=[TestTable.key#1, TestTable.TestEnum#2, TestTable.KitchenSink#3, $array.nested_repeated_value#4]
    |   +-input_scan=
    |   | +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
    |   +-array_expr_list=
    |   | +-GetProtoField
    |   |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
    |   |   +-expr=
    |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   |   +-field_descriptor=nested_repeated_value
    |   |   +-default_value=[]
    |   +-element_column_list=[$array.nested_repeated_value#4]
    +-array_expr_list=
    | +-GetProtoField
    |   +-type=ARRAY<INT32>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nested_repeated_value#4)
    |   +-field_descriptor=value
    |   +-default_value=[]
    +-element_column_list=[$array.value#5]
==

# Unnesting multiple layers of a proto in one step, with implicit flattening.
from TestTable
|> join TestTable.KitchenSink.nested_repeated_value.value
--
ERROR: Cannot access field value on a value with type ARRAY<zetasql_test__.KitchenSinkPB.Nested> [at 2:53]
|> join TestTable.KitchenSink.nested_repeated_value.value
                                                    ^
==

[language_features=PIPES,UNNEST_AND_FLATTEN_ARRAYS]
from TestTable
|> join TestTable.KitchenSink.nested_repeated_value.value
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
| +-$array.value#4 AS value [INT32]
+-query=
  +-ArrayScan
    +-column_list=[TestTable.key#1, TestTable.TestEnum#2, TestTable.KitchenSink#3, $array.value#4]
    +-input_scan=
    | +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
    +-array_expr_list=
    | +-Flatten
    |   +-type=ARRAY<INT32>
    |   +-expr=
    |   | +-GetProtoField
    |   |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
    |   |   +-expr=
    |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   |   +-field_descriptor=nested_repeated_value
    |   |   +-default_value=[]
    |   +-get_field_list=
    |     +-GetProtoField
    |       +-type=ARRAY<INT32>
    |       +-expr=
    |       | +-FlattenedArg(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>)
    |       +-field_descriptor=value
    |       +-default_value=[]
    +-element_column_list=[$array.value#4]
==

# Test various join type modifiers.
from KeyValue
|> {{LEFT|RIGHT|INNER|HASH|LOOKUP|CROSS|NATURAL}} JOIN
   (from KeyValue kv2) USING (key)
--
ALTERNATION GROUP: LEFT
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Value#4 AS Value [STRING]
+-query=
  +-JoinScan
    +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    +-join_type=LEFT
    +-left_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-right_scan=
    | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
    +-has_using=TRUE
--
ALTERNATION GROUP: RIGHT
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#3 AS key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Value#4 AS Value [STRING]
+-query=
  +-JoinScan
    +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    +-join_type=RIGHT
    +-left_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-right_scan=
    | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
    +-has_using=TRUE
--
ALTERNATION GROUP: INNER
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Value#4 AS Value [STRING]
+-query=
  +-JoinScan
    +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    +-left_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-right_scan=
    | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
    +-has_using=TRUE
--
ALTERNATION GROUP: HASH
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Value#4 AS Value [STRING]
+-query=
  +-JoinScan
    +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    +-hint_list=
    | +-join_type := Literal(type=STRING, value="HASH_JOIN")
    +-left_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-right_scan=
    | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
    +-has_using=TRUE
--
ALTERNATION GROUP: LOOKUP
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Value#4 AS Value [STRING]
+-query=
  +-JoinScan
    +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    +-hint_list=
    | +-join_type := Literal(type=STRING, value="LOOKUP_JOIN")
    +-left_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-right_scan=
    | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
    +-has_using=TRUE
--
ALTERNATION GROUP: CROSS
--
ERROR: USING clause cannot be used with CROSS JOIN [at 3:24]
   (from KeyValue kv2) USING (key)
                       ^
--
ALTERNATION GROUP: NATURAL
--
ERROR: Natural join not supported [at 2:4]
|> NATURAL JOIN
   ^
==

from KeyValue
|> CROSS JOIN KeyValue kv2
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Key#3 AS Key [INT64]
| +-KeyValue.Value#4 AS Value [STRING]
+-query=
  +-JoinScan
    +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    +-left_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-right_scan=
      +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
==

# Special COALESCE column for FULL JOIN USING works.
# Stars expand to expected columns.
FROM KeyValue kv1
|> FULL OUTER JOIN KeyValue kv2 USING (key)
|> SELECT kv1.key, kv2.key, key, 'xx', *, 'yy', kv1.*
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Key#3 AS key [INT64]
| +-$full_join.key#5 AS key [INT64]
| +-$pipe_select.$col4#6 AS `$col4` [STRING]
| +-$full_join.key#5 AS key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Value#4 AS Value [STRING]
| +-$pipe_select.$col6#7 AS `$col6` [STRING]
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1, KeyValue.Key#3, $full_join.key#5, $pipe_select.$col4#6, $full_join.key#5, KeyValue.Value#2, KeyValue.Value#4, $pipe_select.$col6#7, KeyValue.Key#1, KeyValue.Value#2]
    +-expr_list=
    | +-$col4#6 := Literal(type=STRING, value="xx")
    | +-$col6#7 := Literal(type=STRING, value="yy")
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, KeyValue.Key#3, KeyValue.Value#4, $full_join.key#5]
        +-expr_list=
        | +-key#5 :=
        |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        +-input_scan=
          +-JoinScan
            +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
            +-join_type=FULL
            +-left_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv1")
            +-right_scan=
            | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
            +-join_expr=
            | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
            +-has_using=TRUE
==

# Join with a hint.
from KeyValue
|> join @{hint=1} KeyValue kv2 using(value)
--
QueryStmt
+-output_column_list=
| +-KeyValue.Value#2 AS value [STRING]
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Key#3 AS Key [INT64]
+-query=
  +-JoinScan
    +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    +-hint_list=
    | +-hint := Literal(type=INT64, value=1)
    +-left_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-right_scan=
    | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |   +-ColumnRef(type=STRING, column=KeyValue.Value#4)
    +-has_using=TRUE
==

# JOIN USING with value tables.
# The second join lhs is the extracted join column from the first join,
# not another GetField.
FROM TestExtraValueTable t1
|> JOIN TestExtraValueTable t2 USING (int32_val1, int32_val2)
|> JOIN TestExtraValueTable t3 USING (int32_val1)
--
QueryStmt
+-output_column_list=
| +-$join_left.int32_val1#7 AS int32_val1 [INT32]
| +-$join_left.int32_val2#9 AS int32_val2 [INT32]
| +-TestExtraValueTable.value#1 AS t1 [PROTO<zetasql_test__.TestExtraPB>]
| +-TestExtraValueTable.value#4 AS t2 [PROTO<zetasql_test__.TestExtraPB>]
| +-TestExtraValueTable.value#11 AS t3 [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-JoinScan
    +-column_list=[TestExtraValueTable.value#1, $join_left.int32_val1#7, $join_left.int32_val2#9, TestExtraValueTable.value#4, $join_right.int32_val1#8, $join_right.int32_val2#10, TestExtraValueTable.value#11, $join_right.int32_val1#14]
    +-left_scan=
    | +-JoinScan
    |   +-column_list=[TestExtraValueTable.value#1, $join_left.int32_val1#7, $join_left.int32_val2#9, TestExtraValueTable.value#4, $join_right.int32_val1#8, $join_right.int32_val2#10]
    |   +-left_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[TestExtraValueTable.value#1, $join_left.int32_val1#7, $join_left.int32_val2#9]
    |   |   +-expr_list=
    |   |   | +-int32_val1#7 :=
    |   |   | | +-GetProtoField
    |   |   | |   +-type=INT32
    |   |   | |   +-expr=
    |   |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |   |   | |   +-field_descriptor=int32_val1
    |   |   | |   +-default_value=0
    |   |   | +-int32_val2#9 :=
    |   |   |   +-GetProtoField
    |   |   |     +-type=INT32
    |   |   |     +-expr=
    |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |   |   |     +-field_descriptor=int32_val2
    |   |   |     +-default_value=0
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias="t1")
    |   +-right_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[TestExtraValueTable.value#4, $join_right.int32_val1#8, $join_right.int32_val2#10]
    |   |   +-expr_list=
    |   |   | +-int32_val1#8 :=
    |   |   | | +-GetProtoField
    |   |   | |   +-type=INT32
    |   |   | |   +-expr=
    |   |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#4)
    |   |   | |   +-field_descriptor=int32_val1
    |   |   | |   +-default_value=0
    |   |   | +-int32_val2#10 :=
    |   |   |   +-GetProtoField
    |   |   |     +-type=INT32
    |   |   |     +-expr=
    |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#4)
    |   |   |     +-field_descriptor=int32_val2
    |   |   |     +-default_value=0
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[TestExtraValueTable.value#4], table=TestExtraValueTable, column_index_list=[0], alias="t2")
    |   +-join_expr=
    |   | +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
    |   |   +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    |   |   | +-ColumnRef(type=INT32, column=$join_left.int32_val1#7)
    |   |   | +-ColumnRef(type=INT32, column=$join_right.int32_val1#8)
    |   |   +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    |   |     +-ColumnRef(type=INT32, column=$join_left.int32_val2#9)
    |   |     +-ColumnRef(type=INT32, column=$join_right.int32_val2#10)
    |   +-has_using=TRUE
    +-right_scan=
    | +-ProjectScan
    |   +-column_list=[TestExtraValueTable.value#11, $join_right.int32_val1#14]
    |   +-expr_list=
    |   | +-int32_val1#14 :=
    |   |   +-GetProtoField
    |   |     +-type=INT32
    |   |     +-expr=
    |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#11)
    |   |     +-field_descriptor=int32_val1
    |   |     +-default_value=0
    |   +-input_scan=
    |     +-TableScan(column_list=[TestExtraValueTable.value#11], table=TestExtraValueTable, column_index_list=[0], alias="t3")
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    |   +-ColumnRef(type=INT32, column=$join_left.int32_val1#7)
    |   +-ColumnRef(type=INT32, column=$join_right.int32_val1#14)
    +-has_using=TRUE
==

# FULL JOIN USING between two struct value tables.  This is interesting because
# it adds extra ProjectScans both before and after the join.
FROM TestExtraValueTable t1
|> FULL JOIN TestExtraValueTable t2 USING (int32_val1)
--
QueryStmt
+-output_column_list=
| +-$full_join.int32_val1#9 AS int32_val1 [INT32]
| +-TestExtraValueTable.value#1 AS t1 [PROTO<zetasql_test__.TestExtraPB>]
| +-TestExtraValueTable.value#4 AS t2 [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[TestExtraValueTable.value#1, $join_left.int32_val1#7, TestExtraValueTable.value#4, $join_right.int32_val1#8, $full_join.int32_val1#9]
    +-expr_list=
    | +-int32_val1#9 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) INT32) -> INT32)
    |     +-ColumnRef(type=INT32, column=$join_left.int32_val1#7)
    |     +-ColumnRef(type=INT32, column=$join_right.int32_val1#8)
    +-input_scan=
      +-JoinScan
        +-column_list=[TestExtraValueTable.value#1, $join_left.int32_val1#7, TestExtraValueTable.value#4, $join_right.int32_val1#8]
        +-join_type=FULL
        +-left_scan=
        | +-ProjectScan
        |   +-column_list=[TestExtraValueTable.value#1, $join_left.int32_val1#7]
        |   +-expr_list=
        |   | +-int32_val1#7 :=
        |   |   +-GetProtoField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
        |   |     +-field_descriptor=int32_val1
        |   |     +-default_value=0
        |   +-input_scan=
        |     +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias="t1")
        +-right_scan=
        | +-ProjectScan
        |   +-column_list=[TestExtraValueTable.value#4, $join_right.int32_val1#8]
        |   +-expr_list=
        |   | +-int32_val1#8 :=
        |   |   +-GetProtoField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#4)
        |   |     +-field_descriptor=int32_val1
        |   |     +-default_value=0
        |   +-input_scan=
        |     +-TableScan(column_list=[TestExtraValueTable.value#4], table=TestExtraValueTable, column_index_list=[0], alias="t2")
        +-join_expr=
        | +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
        |   +-ColumnRef(type=INT32, column=$join_left.int32_val1#7)
        |   +-ColumnRef(type=INT32, column=$join_right.int32_val1#8)
        +-has_using=TRUE
==

# JOIN USING with a scalar value table.
# We don't need to realias here because there's only one merged column,
# no other collisions.
from Int32ValueTable
|> join Int32ValueTable using (Int32ValueTable)
|> where Int32ValueTable = 1
--
QueryStmt
+-output_column_list=
| +-Int32ValueTable.value#1 AS Int32ValueTable [INT32]
+-query=
  +-FilterScan
    +-column_list=Int32ValueTable.[value#1, value#2]
    +-input_scan=
    | +-JoinScan
    |   +-column_list=Int32ValueTable.[value#1, value#2]
    |   +-left_scan=
    |   | +-TableScan(column_list=[Int32ValueTable.value#1], table=Int32ValueTable, column_index_list=[0])
    |   +-right_scan=
    |   | +-TableScan(column_list=[Int32ValueTable.value#2], table=Int32ValueTable, column_index_list=[0])
    |   +-join_expr=
    |   | +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    |   |   +-ColumnRef(type=INT32, column=Int32ValueTable.value#1)
    |   |   +-ColumnRef(type=INT32, column=Int32ValueTable.value#2)
    |   +-has_using=TRUE
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
        +-ColumnRef(type=INT32, column=Int32ValueTable.value#1)
        +-Literal(type=INT32, value=1)
==

# JOIN USING between UNNESTS (value tables) with int32/uint32 supertyping.
# Output column from USING is the (original) lhs input column.
from unnest([cast(1 as int32)]) val
|> join unnest([cast(2 as uint32)]) val using (val)
|> select val, *
--
QueryStmt
+-output_column_list=
| +-$array.val#1 AS val [INT32]
| +-$array.val#1 AS val [INT32]
+-query=
  +-ProjectScan
    +-column_list=$array.[val#1, val#1]
    +-input_scan=
      +-ArrayScan
        +-column_list=$array.[val#1, val#2]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[$array.val#1]
        |   +-array_expr_list=
        |   | +-Literal(type=ARRAY<INT32>, value=[1], has_explicit_type=TRUE)
        |   +-element_column_list=[$array.val#1]
        +-array_expr_list=
        | +-Literal(type=ARRAY<UINT32>, value=[2], has_explicit_type=TRUE)
        +-element_column_list=[$array.val#2]
        +-join_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, UINT64) -> BOOL)
            +-Cast(INT32 -> INT64)
            | +-ColumnRef(type=INT32, column=$array.val#1)
            +-Cast(UINT32 -> UINT64)
              +-ColumnRef(type=UINT32, column=$array.val#2)
==

# Parenthesized join on the rhs.  Range variables are visible.
from KeyValue kv1
|> join (KeyValue kv2 join KeyValue kv3 using (key)) using (key)
|> select key, kv1.key, kv2.key, kv3.key
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Key#3 AS key [INT64]
| +-KeyValue.Key#5 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=KeyValue.[Key#1, Key#1, Key#3, Key#5]
    +-input_scan=
      +-JoinScan
        +-column_list=KeyValue.[Key#1, Key#3, Key#5]
        +-left_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv1")
        +-right_scan=
        | +-JoinScan
        |   +-column_list=KeyValue.[Key#3, Key#5]
        |   +-left_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0], alias="kv2")
        |   +-right_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0], alias="kv3")
        |   +-join_expr=
        |   | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#5)
        |   +-has_using=TRUE
        +-join_expr=
        | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        +-has_using=TRUE
==

# But range variables would not be visible if we gave a name to the
# parenthesized join.  We don't let this parse though.
from KeyValue k1
|> join (KeyValue kv2 join KeyValue kv3 using (key)) AS j using (key)
|> select key, kv1.key, kv2.key, kv3.key
--
ERROR: Syntax error: Expected end of input but got keyword AS [at 2:54]
|> join (KeyValue kv2 join KeyValue kv3 using (key)) AS j using (key)
                                                     ^
==

# Multiple layers of nested parenthesized joins.
from KeyValue kv1
|> join (KeyValue kv2 join
            (KeyValue kv3 join KeyValue kv4 using (key))
        on kv2.key=kv4.key)
    on kv1.key = kv3.key
|> select kv1.key, kv2.key, kv3.key, kv4.key
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Key#3 AS key [INT64]
| +-KeyValue.Key#5 AS key [INT64]
| +-KeyValue.Key#7 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=KeyValue.[Key#1, Key#3, Key#5, Key#7]
    +-input_scan=
      +-JoinScan
        +-column_list=KeyValue.[Key#1, Key#3, Key#5, Key#7]
        +-left_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv1")
        +-right_scan=
        | +-JoinScan
        |   +-column_list=KeyValue.[Key#3, Key#5, Key#7]
        |   +-left_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0], alias="kv2")
        |   +-right_scan=
        |   | +-JoinScan
        |   |   +-column_list=KeyValue.[Key#5, Key#7]
        |   |   +-left_scan=
        |   |   | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0], alias="kv3")
        |   |   +-right_scan=
        |   |   | +-TableScan(column_list=[KeyValue.Key#7], table=KeyValue, column_index_list=[0], alias="kv4")
        |   |   +-join_expr=
        |   |   | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#5)
        |   |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#7)
        |   |   +-has_using=TRUE
        |   +-join_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        |       +-ColumnRef(type=INT64, column=KeyValue.Key#7)
        +-join_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-ColumnRef(type=INT64, column=KeyValue.Key#5)
==

# Alias from input not visible inside parenthesized join.
from KeyValue k1
|> cross join (KeyValue k2 JOIN KeyValue k3 ON k2.key=k1.key)
--
ERROR: Unrecognized name: k1 [at 2:55]
|> cross join (KeyValue k2 JOIN KeyValue k3 ON k2.key=k1.key)
                                                      ^
==

# Join two arrays coming from correlated references to an outer query
# using UNNEST.
# We get an ArrayScan of an ArrayScan, rather than a join of two ArrayScans.
# Either plan would work here because the arrays are uncorrelated to each
# other, but the resolver always builds joins to arrays this way.
# (Copied from array_join.test, and pipefied.)
from TestTable t
|> extend ARRAY(
             from UNNEST(t.KitchenSink.repeated_date) d1
             |> join UNNEST(t.KitchenSink.repeated_date) d2 on d1=d2
             |> select d1)
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
| +-$pipe_extend.$col1#6 AS `$col1` [ARRAY<DATE>]
+-query=
  +-ProjectScan
    +-column_list=[TestTable.key#1, TestTable.TestEnum#2, TestTable.KitchenSink#3, $pipe_extend.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<DATE>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$array.d1#4]
    |         +-input_scan=
    |           +-ArrayScan
    |             +-column_list=$array.[d1#4, d2#5]
    |             +-input_scan=
    |             | +-ArrayScan
    |             |   +-column_list=[$array.d1#4]
    |             |   +-array_expr_list=
    |             |   | +-GetProtoField
    |             |   |   +-type=ARRAY<DATE>
    |             |   |   +-expr=
    |             |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |             |   |   +-field_descriptor=repeated_date
    |             |   |   +-default_value=[]
    |             |   |   +-format=DATE
    |             |   +-element_column_list=[$array.d1#4]
    |             +-array_expr_list=
    |             | +-GetProtoField
    |             |   +-type=ARRAY<DATE>
    |             |   +-expr=
    |             |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |             |   +-field_descriptor=repeated_date
    |             |   +-default_value=[]
    |             |   +-format=DATE
    |             +-element_column_list=[$array.d2#5]
    |             +-join_expr=
    |               +-FunctionCall(ZetaSQL:$equal(DATE, DATE) -> BOOL)
    |                 +-ColumnRef(type=DATE, column=$array.d1#4)
    |                 +-ColumnRef(type=DATE, column=$array.d2#5)
    +-input_scan=
      +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2], alias="t")
==

# TVF in a join.
from KeyValue k
|> join tvf_one_relation_arg_with_fixed_output(table TestTable)
        on key = length(column_bytes)
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-tvf_one_relation_arg_with_fixed_output.column_bool#6 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#7 AS column_bytes [BYTES]
+-query=
  +-JoinScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, tvf_one_relation_arg_with_fixed_output.column_bool#6, tvf_one_relation_arg_with_fixed_output.column_bytes#7]
    +-left_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="k")
    +-right_scan=
    | +-TVFScan
    |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#6, column_bytes#7]
    |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    |   +-signature=(TABLE<key INT32, TestEnum ENUM<zetasql_test__.TestEnum>, KitchenSink PROTO<zetasql_test__.KitchenSinkPB>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    |   +-argument_list=
    |   | +-FunctionArgument
    |   |   +-scan=
    |   |   | +-TableScan(column_list=TestTable.[key#3, TestEnum#4, KitchenSink#5], table=TestTable, column_index_list=[0, 1, 2])
    |   |   +-argument_column_list=TestTable.[key#3, TestEnum#4, KitchenSink#5]
    |   +-column_index_list=[0, 1]
    |   +-function_call_signature=(ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-join_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-FunctionCall(ZetaSQL:length(BYTES) -> INT64)
          +-ColumnRef(type=BYTES, column=tvf_one_relation_arg_with_fixed_output.column_bytes#7)
==

# The TVF attempts to use the table from the lhs input as its input.
from KeyValue k
|> join tvf_one_relation_arg_with_fixed_output(table k)
        on key = length(column_bytes)
--
ERROR: Table not found: k [at 2:54]
|> join tvf_one_relation_arg_with_fixed_output(table k)
                                                     ^
==

# The TVF tries to pass correlated references from lhs input as its input args.
from KeyValue k
|> cross join tvf_one_relation_arg_one_int64_arg((select value), key)
--
ERROR: Unrecognized name: value [at 2:58]
|> cross join tvf_one_relation_arg_one_int64_arg((select value), key)
                                                         ^
==

# For comparsion with previous, the same failure with normal syntax.
select *
from KeyValue k
    cross join tvf_one_relation_arg_one_int64_arg((select value), key)
--
ERROR: Unrecognized name: value [at 3:59]
    cross join tvf_one_relation_arg_one_int64_arg((select value), key)
                                                          ^
==

from KeyValue k
|> cross join tvf_one_relation_arg_one_int64_arg(table k, key)
--
ERROR: Table not found: k [at 2:56]
|> cross join tvf_one_relation_arg_one_int64_arg(table k, key)
                                                       ^
==

# TABLESAMPLE is allowed on tables in join.
from KeyValue k
|> join KeyValue k2 TABLESAMPLE bernoulli(5 percent) using (key)
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Value#4 AS Value [STRING]
+-query=
  +-JoinScan
    +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    +-left_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="k")
    +-right_scan=
    | +-SampleScan
    |   +-column_list=KeyValue.[Key#3, Value#4]
    |   +-input_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="k2")
    |   +-method="bernoulli"
    |   +-size=
    |   | +-Literal(type=INT64, value=5)
    |   +-unit=PERCENT
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
    +-has_using=TRUE
==

# TABLESAMPLE is allowed on subqueries in join.
from KeyValue k
|> join (select 5 key) TABLESAMPLE bernoulli(5 percent) using (key)
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-JoinScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $subquery1.key#3]
    +-left_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="k")
    +-right_scan=
    | +-SampleScan
    |   +-column_list=[$subquery1.key#3]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$subquery1.key#3]
    |   |   +-expr_list=
    |   |   | +-key#3 := Literal(type=INT64, value=5)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-method="bernoulli"
    |   +-size=
    |   | +-Literal(type=INT64, value=5)
    |   +-unit=PERCENT
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-ColumnRef(type=INT64, column=$subquery1.key#3)
    +-has_using=TRUE
==

# TABLESAMPLE is allowed on TVFs in join.
from KeyValue k
|> cross join tvf_no_args() TABLESAMPLE bernoulli(5 percent)--
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-tvf_no_args.column_bool#3 AS column_bool [BOOL]
| +-tvf_no_args.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-JoinScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, tvf_no_args.column_bool#3, tvf_no_args.column_bytes#4]
    +-left_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="k")
    +-right_scan=
      +-SampleScan
        +-column_list=tvf_no_args.[column_bool#3, column_bytes#4]
        +-input_scan=
        | +-TVFScan(column_list=tvf_no_args.[column_bool#3, column_bytes#4], tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1], function_call_signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-method="bernoulli"
        +-size=
        | +-Literal(type=INT64, value=5)
        +-unit=PERCENT
==

# TABLESAMPLE is allowed on parenthesized joins in join.
from KeyValue k
|> join (KeyValue k2 join KeyValue k3 using (key))
     TABLESAMPLE bernoulli(5 percent) using (key)
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Value#4 AS Value [STRING]
| +-KeyValue.Value#6 AS Value [STRING]
+-query=
  +-JoinScan
    +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4, Key#5, Value#6]
    +-left_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="k")
    +-right_scan=
    | +-SampleScan
    |   +-column_list=KeyValue.[Key#3, Value#4, Key#5, Value#6]
    |   +-input_scan=
    |   | +-JoinScan
    |   |   +-column_list=KeyValue.[Key#3, Value#4, Key#5, Value#6]
    |   |   +-left_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="k2")
    |   |   +-right_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#5, Value#6], table=KeyValue, column_index_list=[0, 1], alias="k3")
    |   |   +-join_expr=
    |   |   | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
    |   |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#5)
    |   |   +-has_using=TRUE
    |   +-method="bernoulli"
    |   +-size=
    |   | +-Literal(type=INT64, value=5)
    |   +-unit=PERCENT
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
    +-has_using=TRUE
