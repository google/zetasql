[default language_features=MAXIMUM,+ANALYTIC_FUNCTIONS,+AGGREGATE_FILTERING,+MULTILEVEL_AGGREGATION,+GROUPING_BUILTIN,+QUALIFY,+GROUP_BY_STRUCT,+ORDER_BY_IN_AGGREGATE,+ANONYMIZATION,+DIFFERENTIAL_PRIVACY,+AGGREGATION_THRESHOLD]
[default show_sqlbuilder_output]
[default enabled_ast_rewrites=ALL,-WITH_EXPR]

# Error if WHERE contains an aggregate or analytic function.
SELECT
  SUM(int64 WHERE SUM(int64) {{ OVER ()|}} > 0){{ OVER ()|}}
FROM SimpleTypes;
--
ALTERNATION GROUP:  OVER (), OVER ()
--
ERROR: Analytic function not allowed in WHERE modifier [at 3:19]
  SUM(int64 WHERE SUM(int64)  OVER () > 0) OVER ()
                  ^
--
ALTERNATION GROUP:  OVER (),
--
ERROR: Analytic function not allowed in WHERE modifier [at 3:19]
  SUM(int64 WHERE SUM(int64)  OVER () > 0)
                  ^
--
ALTERNATION GROUP:  OVER ()
--
ERROR: Aggregate function SUM not allowed in WHERE modifier [at 3:19]
  SUM(int64 WHERE SUM(int64)  > 0) OVER ()
                  ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Aggregate function SUM not allowed in WHERE modifier [at 3:19]
  SUM(int64 WHERE SUM(int64)  > 0)
                  ^
==

# Error if WHERE is in scalar function calls.
SELECT
  {{CONCAT('a', 'b' WHERE bool IS NOT NULL)|POWER(int64, 2 WHERE bool IS NOT NULL)}}
FROM SimpleTypes;
--

ALTERNATION GROUP: CONCAT('a', 'b' WHERE bool IS NOT NULL)
--
ERROR: WHERE in arguments is not supported on scalar functions [at 2:19]
  CONCAT('a', 'b' WHERE bool IS NOT NULL)
                  ^
--
ALTERNATION GROUP: POWER(int64, 2 WHERE bool IS NOT NULL)
--
ERROR: WHERE in arguments is not supported on scalar functions [at 2:18]
  POWER(int64, 2 WHERE bool IS NOT NULL)
                 ^
==

# Error if WHERE is not a boolean expression.
SELECT
  SUM(int64 WHERE {{int64 + 1|CONCAT('a', 'b')}}){{ OVER ()|}}
FROM SimpleTypes;
--

ALTERNATION GROUP: int64 + 1, OVER ()
--
ERROR: WHERE modifier should return type BOOL, but returns INT64 [at 2:19]
  SUM(int64 WHERE int64 + 1) OVER ()
                  ^
--
ALTERNATION GROUP: int64 + 1,
--
ERROR: WHERE modifier should return type BOOL, but returns INT64 [at 2:19]
  SUM(int64 WHERE int64 + 1)
                  ^
--
ALTERNATION GROUP: CONCAT('a', 'b'), OVER ()
--
ERROR: WHERE modifier should return type BOOL, but returns STRING [at 2:19]
  SUM(int64 WHERE CONCAT('a', 'b')) OVER ()
                  ^
--
ALTERNATION GROUP: CONCAT('a', 'b'),
--
ERROR: WHERE modifier should return type BOOL, but returns STRING [at 2:19]
  SUM(int64 WHERE CONCAT('a', 'b'))
                  ^
==

# Error if WHERE modifier in an analytic function references a column that is
# not grouped.
SELECT
  SUM(doubly_nested_struct.f.c
      WHERE doubly_nested_struct.e = 1) OVER ()
FROM DoublyNestedStructTable
GROUP BY doubly_nested_struct.f;
--
ERROR: WHERE modifier expression references doubly_nested_struct.e which is neither grouped nor aggregated [at 3:13]
      WHERE doubly_nested_struct.e = 1) OVER ()
            ^
==

# Similar to the above, but testing the QUALIFY clause.
SELECT
  SUM(doubly_nested_struct.e)
FROM DoublyNestedStructTable
GROUP BY doubly_nested_struct.f
QUALIFY COUNT(doubly_nested_struct.f WHERE doubly_nested_struct.e = 1) OVER() > 100;
--
ERROR: WHERE modifier expression references doubly_nested_struct.e which is neither grouped nor aggregated [at 5:44]
QUALIFY COUNT(doubly_nested_struct.f WHERE doubly_nested_struct.e = 1) OVER()...
                                           ^
==

# Error without AGGREGATE_FILTERING language feature.
[language_features=NONE,+ANALYTIC_FUNCTIONS]
SELECT
  SUM(int64 WHERE bool IS NOT NULL){{ OVER ()|}}
FROM SimpleTypes;
--

ALTERNATION GROUP:  OVER ()
--
ERROR: WHERE modifier is not supported in function calls [at 2:13]
  SUM(int64 WHERE bool IS NOT NULL) OVER ()
            ^
--
ALTERNATION GROUP: <empty>
--
ERROR: WHERE modifier is not supported in function calls [at 2:13]
  SUM(int64 WHERE bool IS NOT NULL)
            ^
==

# Error with HAVING without AGGREGATE_FILTERING language feature.
[language_features=NONE,+MULTILEVEL_AGGREGATION]
SELECT
  SUM(ANY_VALUE(int64) GROUP BY int32 HAVING bool is not null)
FROM SimpleTypes;
--

ERROR: HAVING modifier is not supported in function calls [at 2:39]
  SUM(ANY_VALUE(int64) GROUP BY int32 HAVING bool is not null)
                                      ^
==

# Error if HAVING is in scalar function calls. Should fail on GROUP BY.
SELECT
  {{CONCAT('a', 'b' GROUP BY int64 HAVING COUNT(*) > 1)|POWER(int64, 2 GROUP BY int64 HAVING SUM(int64)) > 1}}
FROM SimpleTypes;
--

ALTERNATION GROUP: CONCAT('a', 'b' GROUP BY int64 HAVING COUNT(*) > 1)
--
ERROR: GROUP BY in arguments is not supported on scalar functions [at 2:19]
  CONCAT('a', 'b' GROUP BY int64 HAVING COUNT(*) > 1)
                  ^
--
ALTERNATION GROUP: POWER(int64, 2 GROUP BY int64 HAVING SUM(int64)) > 1
--
ERROR: GROUP BY in arguments is not supported on scalar functions [at 2:18]
  POWER(int64, 2 GROUP BY int64 HAVING SUM(int64)) > 1
                 ^
==

# Error if HAVING is used without GROUP BY.
SELECT
  SUM(int64 HAVING bool is not null)
FROM SimpleTypes;
--

ERROR: Syntax error: Expected keyword MAX or keyword MIN but got identifier "bool" [at 2:20]
  SUM(int64 HAVING bool is not null)
                   ^
==

# Error if HAVING is not a boolean expression.
SELECT
  SUM(ANY_VALUE(int64) GROUP BY int32 HAVING ANY_VALUE(int64) + 1)
FROM SimpleTypes;
--

ERROR: HAVING modifier should return type BOOL, but returns INT64 [at 2:46]
  SUM(ANY_VALUE(int64) GROUP BY int32 HAVING ANY_VALUE(int64) + 1)
                                             ^
==

# Error if HAVING references a column that is not aggregated or grouped.
SELECT
  SUM(ANY_VALUE(double) GROUP BY int32 HAVING bool IS NOT NULL)
FROM SimpleTypes
GROUP BY int64;
--


ERROR: multi-level aggregate expression references column bool which is neither grouped nor aggregated [at 2:47]
  SUM(ANY_VALUE(double) GROUP BY int32 HAVING bool IS NOT NULL)
                                              ^
==

# Error if HAVING modifier references a nested column that is not grouped.
SELECT
  SUM(doubly_nested_struct.f.c GROUP BY doubly_nested_struct.f.d.b HAVING doubly_nested_struct.e > 1)
FROM DoublyNestedStructTable
GROUP BY doubly_nested_struct.f;
--
ERROR: multi-level aggregate expression references doubly_nested_struct.e which is neither grouped nor aggregated [at 2:75]
...f.c GROUP BY doubly_nested_struct.f.d.b HAVING doubly_nested_struct.e > 1)
                                                  ^
==

# GROUPING function disallowed in HAVING modifier.
SELECT
  ARRAY_AGG(DISTINCT string GROUP BY string HAVING GROUPING(int64) = 1{{ ORDER BY string|}})
FROM SimpleTypes
GROUP BY int64
--

ALTERNATION GROUP:  ORDER BY string
--
ERROR: GROUPING function not allowed in HAVING modifier of a multi-level aggregate. [at 2:52]
  ARRAY_AGG(DISTINCT string GROUP BY string HAVING GROUPING(int64) = 1 ORDER ...
                                                   ^
--
ALTERNATION GROUP: <empty>
--
ERROR: GROUPING function not allowed in HAVING modifier of a multi-level aggregate. [at 2:52]
  ARRAY_AGG(DISTINCT string GROUP BY string HAVING GROUPING(int64) = 1)
                                                   ^
==

# GROUPING function disallowed in ORDER BY modifier.
SELECT
  ARRAY_AGG(DISTINCT string GROUP BY string HAVING COUNT(*) > 1 ORDER BY GROUPING(string))
FROM SimpleTypes
GROUP BY int64
--

ERROR: GROUPING function not allowed in ORDER BY modifier of a multi-level aggregate. [at 2:65]
...DISTINCT string GROUP BY string HAVING COUNT(*) > 1 ORDER BY GROUPING(stri...
                                                       ^
==


# Both the HAVING filter modifier and GROUP BY modifiers are disallowed on
# analytic functions (even aggregate analytic functions). Since GROUP BY
# modifiers are checked first, the error message mentions GROUP BY.
SELECT
  SUM(MAX(int64) GROUP BY string HAVING COUNT(bool) > 1) OVER()
FROM SimpleTypes
--
ERROR: GROUP BY modifiers not supported on analytic function calls. [at 2:3]
  SUM(MAX(int64) GROUP BY string HAVING COUNT(bool) > 1) OVER()
  ^
==

# PIVOT rewriter does not support WHERE in aggregate functions.
SELECT *
FROM MultipleColumns
PIVOT(COUNT(* WHERE int_b > 5) FOR int_a IN (0 AS zero, 1 AS one));
--
ERROR: PIVOT expression cannot use aggregate filtering WHERE clause [at 3:7]
PIVOT(COUNT(* WHERE int_b > 5) FOR int_a IN (0 AS zero, 1 AS one));
      ^
==

# PIVOT rewriter does not support HAVING in aggregate functions. The error
# mentions GROUP BY because it checks for GROUP BY first, which is also not
# supported in the PIVOT rewriter.
SELECT *
FROM MultipleColumns
PIVOT(COUNT(* GROUP BY int_b HAVING int_b > 5) FOR int_a IN (0 AS zero, 1 AS one));
--
ERROR: PIVOT expression cannot be a multi-level aggregate function call [at 3:7]
PIVOT(COUNT(* GROUP BY int_b HAVING int_b > 5) FOR int_a IN (0 AS zero, 1 AS ...
      ^
==

# WHERE aggregate filtering is not supported with anonymization.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_expect_error_location]
SELECT
  ANON_SUM(int64 WHERE bool)
FROM SimpleTypes;
--
ERROR: ANON_SUM Anonymization / Differential Privacy Function does not support WHERE modifier [at 2:18]
  ANON_SUM(int64 WHERE bool)
                 ^
==

# HAVING aggregate filtering is not supported with anonymization. Since GROUP BY
# is checked first, the error message mentions GROUP BY.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_expect_error_location]
SELECT
  ANON_SUM(int64 GROUP BY int64 HAVING int64 > 1)
FROM SimpleTypes;
--
ERROR: ANON_SUM Anonymization / Differential Privacy Function does not support GROUP BY modifiers [at 2:3]
  ANON_SUM(int64 GROUP BY int64 HAVING int64 > 1)
  ^
==

# WHERE aggregate filtering does not work with differential privacy.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY
  COUNT(int64 WHERE bool)
from SimpleTypesWithAnonymizationUid;
--
ERROR: COUNT Anonymization / Differential Privacy Function does not support WHERE modifier [at 2:15]
  COUNT(int64 WHERE bool)
              ^
==

# HAVING aggregate filtering does not work with differential privacy. Since
# GROUP BY is checked first, the error message mentions GROUP BY.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY
  COUNT(int64 GROUP BY int64 HAVING int64 > 1)
from SimpleTypesWithAnonymizationUid;
--
ERROR: COUNT Anonymization / Differential Privacy Function does not support GROUP BY modifiers [at 2:3]
  COUNT(int64 GROUP BY int64 HAVING int64 > 1)
  ^
==

# WHERE aggregate filtering does not work with aggregation threshold.
[enabled_ast_rewrites=DEFAULTS,+AGGREGATION_THRESHOLD]
SELECT WITH AGGREGATION_THRESHOLD
OPTIONS (threshold = 50, privacy_unit_column = int64)
  COUNT(int64 WHERE bool)
from SimpleTypes;
--
ERROR: Aggregation Threshold Aggregation does not support aggregate functions with WHERE filter modifiers [at 3:3]
  COUNT(int64 WHERE bool)
  ^
==

# HAVING aggregate filtering does not work with aggregation threshold. Since
# GROUP BY is checked first, the error message mentions GROUP BY.
[enabled_ast_rewrites=DEFAULTS,+AGGREGATION_THRESHOLD]
SELECT WITH AGGREGATION_THRESHOLD
OPTIONS (threshold = 50, privacy_unit_column = int64)
  COUNT(int64 GROUP BY int64 HAVING int64 > 1)
from SimpleTypes;
--
ERROR: Aggregation Threshold Aggregation does not support aggregate functions with GROUP BY modifiers [at 3:3]
  COUNT(int64 GROUP BY int64 HAVING int64 > 1)
  ^
==

# ORDER_BY_AND_LIMIT_IN_AGGREGATE rewriter does not support WHERE in aggregate
# functions.
SELECT
  ARRAY_AGG(int64 WHERE bool ORDER BY int64)
FROM SimpleTypes
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, bool#7], table=SimpleTypes, column_index_list=[1, 6])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-where_expr=
              | +-ColumnRef(type=BOOL, column=SimpleTypes.bool#7)
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT
  ARRAY_AGG(simpletypes_3.a_1
    WHERE
      simpletypes_3.a_2
    ORDER BY simpletypes_3.a_1) AS a_4
FROM
  (
    SELECT
      SimpleTypes.int64 AS a_1,
      SimpleTypes.bool AS a_2
    FROM
      SimpleTypes
  ) AS simpletypes_3;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
FROM
  SimpleTypes
|> SELECT
     SimpleTypes.int64 AS a_1,
     SimpleTypes.bool AS a_2
|> AS simpletypes_3
|> AGGREGATE
     ARRAY_AGG(simpletypes_3.a_1
       WHERE
         simpletypes_3.a_2
       ORDER BY simpletypes_3.a_1) AS a_4;

Rewrite ERROR: generic::unimplemented: Aggregate functions with a WHERE filter modifier are not supported in ORDER_BY_AND_LIMIT_IN_AGGREGATE rewriter
==

# ORDER_BY_AND_LIMIT_IN_AGGREGATE rewriter does not support WHERE in aggregate
# functions.
SELECT
  ARRAY_AGG(int64 WHERE bool LIMIT 1)
FROM SimpleTypes
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, bool#7], table=SimpleTypes, column_index_list=[1, 6])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-where_expr=
              | +-ColumnRef(type=BOOL, column=SimpleTypes.bool#7)
              +-limit=
                +-Literal(type=INT64, value=1)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT
  ARRAY_AGG(simpletypes_3.a_1
    WHERE
      simpletypes_3.a_2
    LIMIT 1) AS a_4
FROM
  (
    SELECT
      SimpleTypes.int64 AS a_1,
      SimpleTypes.bool AS a_2
    FROM
      SimpleTypes
  ) AS simpletypes_3;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
FROM
  SimpleTypes
|> SELECT
     SimpleTypes.int64 AS a_1,
     SimpleTypes.bool AS a_2
|> AS simpletypes_3
|> AGGREGATE
     ARRAY_AGG(simpletypes_3.a_1
       WHERE
         simpletypes_3.a_2
       LIMIT 1) AS a_4;

Rewrite ERROR: generic::unimplemented: Aggregate functions with a WHERE filter modifier are not supported in ORDER_BY_AND_LIMIT_IN_AGGREGATE rewriter
==

# ORDER_BY_AND_LIMIT_IN_AGGREGATE rewriter does not support HAVING in aggregate
# functions. Since GROUP BY is checked first, the error message mentions
# GROUP BY.
SELECT
  ARRAY_AGG(int64 GROUP BY int64 HAVING int64 > 1 ORDER BY int64)
FROM SimpleTypes
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#21 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#21]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#21]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#21 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#20)
              +-order_by_item_list=
              | +-OrderByItem
              |   +-column_ref=
              |     +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#20)
              +-group_by_list=
              | +-$groupbymod#20 := ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-having_expr=
                +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
                  +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#20)
                  +-Literal(type=INT64, value=1)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT
  ARRAY_AGG(simpletypes_2.a_1
    GROUP BY simpletypes_2.a_1
    HAVING(simpletypes_2.a_1) > 1
    ORDER BY simpletypes_2.a_1) AS a_3
FROM
  (
    SELECT
      SimpleTypes.int64 AS a_1
    FROM
      SimpleTypes
  ) AS simpletypes_2;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
FROM
  SimpleTypes
|> SELECT
     SimpleTypes.int64 AS a_1
|> AS simpletypes_2
|> AGGREGATE
     ARRAY_AGG(simpletypes_2.a_1
       GROUP BY simpletypes_2.a_1
       HAVING(simpletypes_2.a_1) > 1
       ORDER BY simpletypes_2.a_1) AS a_3;

Rewrite ERROR: generic::unimplemented: Aggregate functions with GROUP BY modifiers are not supported in ORDER_BY_AND_LIMIT_IN_AGGREGATE rewriter
==

# ORDER_BY_AND_LIMIT_IN_AGGREGATE rewriter does not support HAVING in aggregate
# functions. Since GROUP BY is checked first, the error message mentions
# GROUP BY.
SELECT
  ARRAY_AGG(int64 GROUP BY int64 HAVING int64 > 1 LIMIT 1)
FROM SimpleTypes
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#21 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#21]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#21]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#21 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#20)
              +-limit=
              | +-Literal(type=INT64, value=1)
              +-group_by_list=
              | +-$groupbymod#20 := ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-having_expr=
                +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
                  +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#20)
                  +-Literal(type=INT64, value=1)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT
  ARRAY_AGG(simpletypes_2.a_1
    GROUP BY simpletypes_2.a_1
    HAVING(simpletypes_2.a_1) > 1
    LIMIT 1) AS a_3
FROM
  (
    SELECT
      SimpleTypes.int64 AS a_1
    FROM
      SimpleTypes
  ) AS simpletypes_2;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
FROM
  SimpleTypes
|> SELECT
     SimpleTypes.int64 AS a_1
|> AS simpletypes_2
|> AGGREGATE
     ARRAY_AGG(simpletypes_2.a_1
       GROUP BY simpletypes_2.a_1
       HAVING(simpletypes_2.a_1) > 1
       LIMIT 1) AS a_3;

Rewrite ERROR: generic::unimplemented: Aggregate functions with GROUP BY modifiers are not supported in ORDER_BY_AND_LIMIT_IN_AGGREGATE rewriter
