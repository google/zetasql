[language_features={{|V_1_4_BARE_ARRAY_ACCESS}}]
select KitchenSink.repeated_double_val[123]
from TestTable
--
ALTERNATION GROUP: <empty>
--
ERROR: Array element access with array[position] is not supported. Use array[OFFSET(zero_based_offset)] or array[ORDINAL(one_based_ordinal)] [at 1:40]
select KitchenSink.repeated_double_val[123]
                                       ^
--
ALTERNATION GROUP: V_1_4_BARE_ARRAY_ACCESS
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<DOUBLE>, INT64) -> DOUBLE)
    |     +-GetProtoField
    |     | +-type=ARRAY<DOUBLE>
    |     | +-expr=
    |     | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     | +-field_descriptor=repeated_double_val
    |     | +-default_value=[]
    |     +-Literal(type=INT64, value=123)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# We should get the error for the bad name before getting the error for
# the invalid array operator.
select xxx[5]
--
ERROR: Unrecognized name: xxx [at 1:8]
select xxx[5]
       ^
==

select KitchenSink[5] from TestTable
--
ERROR: Subscript access using [INT64] is not supported on values of type zetasql_test__.KitchenSinkPB [at 1:20]
select KitchenSink[5] from TestTable
                   ^
==

# AT_OFFSET and AT_ORDINAL are no longer supported.
select {{at_offset|at_ordinal}}(KitchenSink.repeated_double_val, 1)
from TestTable
--
ALTERNATION GROUP: at_offset
--
ERROR: Function not found: at_offset [at 1:8]
select at_offset(KitchenSink.repeated_double_val, 1)
       ^
--
ALTERNATION GROUP: at_ordinal
--
ERROR: Function not found: at_ordinal [at 1:8]
select at_ordinal(KitchenSink.repeated_double_val, 1)
       ^
==

# Distinct is not allowed.
select KitchenSink.repeated_double_val[offset(distinct 0)]
from TestTable
--
ERROR: Array element access with array[position] is not supported. Use array[OFFSET(zero_based_offset)] or array[ORDINAL(one_based_ordinal)] [at 1:40]
select KitchenSink.repeated_double_val[offset(distinct 0)]
                                       ^
==

# Modifiers are not allowed.
select KitchenSink.repeated_double_val[offset(
    0 {{having max 1|ignore nulls|limit 1|order by 1}})]
from TestTable
--
ERROR: Array element access with array[position] is not supported. Use array[OFFSET(zero_based_offset)] or array[ORDINAL(one_based_ordinal)] [at 1:40]
select KitchenSink.repeated_double_val[offset(
                                       ^
==

# offset is 0-based.  ordinal is 1-based.
select KitchenSink.repeated_double_val[offset(0)],
       KitchenSink.repeated_double_val[ordinal(1)]
from TestTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [DOUBLE]
| +-$query.$col2#5 AS `$col2` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#4, $col2#5]
    +-expr_list=
    | +-$col1#4 :=
    | | +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<DOUBLE>, INT64) -> DOUBLE)
    | |   +-GetProtoField
    | |   | +-type=ARRAY<DOUBLE>
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=repeated_double_val
    | |   | +-default_value=[]
    | |   +-Literal(type=INT64, value=0)
    | +-$col2#5 :=
    |   +-FunctionCall(ZetaSQL:$array_at_ordinal(ARRAY<DOUBLE>, INT64) -> DOUBLE)
    |     +-GetProtoField
    |     | +-type=ARRAY<DOUBLE>
    |     | +-expr=
    |     | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     | +-field_descriptor=repeated_double_val
    |     | +-default_value=[]
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# safe variants of offset and ordinal
select KitchenSink.repeated_double_val[safe_offset(0)],
       KitchenSink.repeated_double_val[safe_ordinal(1)]
from TestTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [DOUBLE]
| +-$query.$col2#5 AS `$col2` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#4, $col2#5]
    +-expr_list=
    | +-$col1#4 :=
    | | +-FunctionCall(ZetaSQL:$safe_array_at_offset(ARRAY<DOUBLE>, INT64) -> DOUBLE)
    | |   +-GetProtoField
    | |   | +-type=ARRAY<DOUBLE>
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=repeated_double_val
    | |   | +-default_value=[]
    | |   +-Literal(type=INT64, value=0)
    | +-$col2#5 :=
    |   +-FunctionCall(ZetaSQL:$safe_array_at_ordinal(ARRAY<DOUBLE>, INT64) -> DOUBLE)
    |     +-GetProtoField
    |     | +-type=ARRAY<DOUBLE>
    |     | +-expr=
    |     | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     | +-field_descriptor=repeated_double_val
    |     | +-default_value=[]
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

select 2 + 5,
       KitchenSink.repeated_double_val[OFFSET(1 + 2 * cast(4 / 3 as int64))]
from TestTable;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [INT64]
| +-$query.$col2#5 AS `$col2` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#4, $col2#5]
    +-expr_list=
    | +-$col1#4 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-Literal(type=INT64, value=2)
    | |   +-Literal(type=INT64, value=5)
    | +-$col2#5 :=
    |   +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<DOUBLE>, INT64) -> DOUBLE)
    |     +-GetProtoField
    |     | +-type=ARRAY<DOUBLE>
    |     | +-expr=
    |     | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     | +-field_descriptor=repeated_double_val
    |     | +-default_value=[]
    |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       +-Literal(type=INT64, value=1)
    |       +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |         +-Literal(type=INT64, value=2)
    |         +-Cast(DOUBLE -> INT64)
    |           +-FunctionCall(ZetaSQL:$divide(DOUBLE, DOUBLE) -> DOUBLE)
    |             +-Literal(type=DOUBLE, value=4)
    |             +-Literal(type=DOUBLE, value=3)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# Accessing array element -1 should give an error at runtime.
select KitchenSink.repeated_double_val[OFFSET(0)],
       KitchenSink.repeated_double_val[OFFSET(-1)]
from TestTable;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [DOUBLE]
| +-$query.$col2#5 AS `$col2` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#4, $col2#5]
    +-expr_list=
    | +-$col1#4 :=
    | | +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<DOUBLE>, INT64) -> DOUBLE)
    | |   +-GetProtoField
    | |   | +-type=ARRAY<DOUBLE>
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=repeated_double_val
    | |   | +-default_value=[]
    | |   +-Literal(type=INT64, value=0)
    | +-$col2#5 :=
    |   +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<DOUBLE>, INT64) -> DOUBLE)
    |     +-GetProtoField
    |     | +-type=ARRAY<DOUBLE>
    |     | +-expr=
    |     | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     | +-field_descriptor=repeated_double_val
    |     | +-default_value=[]
    |     +-Literal(type=INT64, value=-1)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

select KitchenSink.repeated_double_val[OFFSET(NULL)] from TestTable;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<DOUBLE>, INT64) -> DOUBLE)
    |     +-GetProtoField
    |     | +-type=ARRAY<DOUBLE>
    |     | +-expr=
    |     | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     | +-field_descriptor=repeated_double_val
    |     | +-default_value=[]
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

select keys[OFFSET(2)] from (select array_agg(key) as keys from KeyValue);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<INT64>, INT64) -> INT64)
    |     +-ColumnRef(type=ARRAY<INT64>, column=$aggregate.keys#3)
    |     +-Literal(type=INT64, value=2)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$aggregate.keys#3]
        +-input_scan=
          +-AggregateScan
            +-column_list=[$aggregate.keys#3]
            +-input_scan=
            | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
            +-aggregate_list=
              +-keys#3 :=
                +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
==

select keys[OFFSET(2)] + keys[OFFSET(3)]
from (select array_agg(key) as keys from KeyValue);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<INT64>, INT64) -> INT64)
    |     | +-ColumnRef(type=ARRAY<INT64>, column=$aggregate.keys#3)
    |     | +-Literal(type=INT64, value=2)
    |     +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<INT64>, INT64) -> INT64)
    |       +-ColumnRef(type=ARRAY<INT64>, column=$aggregate.keys#3)
    |       +-Literal(type=INT64, value=3)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$aggregate.keys#3]
        +-input_scan=
          +-AggregateScan
            +-column_list=[$aggregate.keys#3]
            +-input_scan=
            | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
            +-aggregate_list=
              +-keys#3 :=
                +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
==

select KitchenSink.repeated_double_val[1][2] from TestTable;
--
ERROR: Array element access with array[position] is not supported. Use array[OFFSET(zero_based_offset)] or array[ORDINAL(one_based_ordinal)] [at 1:40]
select KitchenSink.repeated_double_val[1][2] from TestTable;
                                       ^
==

select 1 from TestTable
where KitchenSink.nested_repeated_group[OFFSET(2)].nestedrepeatedgroupnested[OFFSET(1)].id = 1;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-GetProtoField
            | +-type=INT64
            | +-expr=
            | | +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup.NestedRepeatedGroupNested>>, INT64) -> PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup.NestedRepeatedGroupNested>)
            | |   +-GetProtoField
            | |   | +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup.NestedRepeatedGroupNested>>
            | |   | +-expr=
            | |   | | +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup>>, INT64) -> PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup>)
            | |   | |   +-GetProtoField
            | |   | |   | +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup>>
            | |   | |   | +-expr=
            | |   | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | |   | |   | +-field_descriptor=nested_repeated_group
            | |   | |   | +-default_value=[]
            | |   | |   +-Literal(type=INT64, value=2)
            | |   | +-field_descriptor=nestedrepeatedgroupnested
            | |   | +-default_value=[]
            | |   +-Literal(type=INT64, value=1)
            | +-field_descriptor=id
            +-Literal(type=INT64, value=1)
==

select 5[OFFSET(6)];
--
ERROR: Subscript access using [OFFSET(INT64)] is not supported on values of type INT64 [at 1:10]
select 5[OFFSET(6)];
         ^
==

select NULL[ORDINAL(2)];
--
ERROR: Subscript access using [ORDINAL(INT64)] is not supported on values of type NULL [at 1:13]
select NULL[ORDINAL(2)];
            ^
==

select 1 from TestTable
where KitchenSink.nested_repeated_group[OFFSET(
   KitchenSink.nested_repeated_group[OFFSET(KitchenSink.int64_val)].id)].id = 1;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-GetProtoField
            | +-type=INT64
            | +-expr=
            | | +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup>>, INT64) -> PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup>)
            | |   +-GetProtoField
            | |   | +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup>>
            | |   | +-expr=
            | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | |   | +-field_descriptor=nested_repeated_group
            | |   | +-default_value=[]
            | |   +-GetProtoField
            | |     +-type=INT64
            | |     +-expr=
            | |     | +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup>>, INT64) -> PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup>)
            | |     |   +-GetProtoField
            | |     |   | +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup>>
            | |     |   | +-expr=
            | |     |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | |     |   | +-field_descriptor=nested_repeated_group
            | |     |   | +-default_value=[]
            | |     |   +-GetProtoField
            | |     |     +-type=INT64
            | |     |     +-expr=
            | |     |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | |     |     +-field_descriptor=int64_val
            | |     |     +-default_value=0
            | |     +-field_descriptor=id
            | +-field_descriptor=id
            +-Literal(type=INT64, value=1)
==

select 1 + 2 * KitchenSink.repeated_int64_val[OFFSET(2)] + 3 * 4 from TestTable;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     | +-Literal(type=INT64, value=1)
    |     | +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |     |   +-Literal(type=INT64, value=2)
    |     |   +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<INT64>, INT64) -> INT64)
    |     |     +-GetProtoField
    |     |     | +-type=ARRAY<INT64>
    |     |     | +-expr=
    |     |     | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     |     | +-field_descriptor=repeated_int64_val
    |     |     | +-default_value=[]
    |     |     +-Literal(type=INT64, value=2)
    |     +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |       +-Literal(type=INT64, value=3)
    |       +-Literal(type=INT64, value=4)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

select KitchenSink[OFFSET(1)] from TestTable;
--
ERROR: Subscript access using [OFFSET(INT64)] is not supported on values of type zetasql_test__.KitchenSinkPB [at 1:20]
select KitchenSink[OFFSET(1)] from TestTable;
                   ^
==

select KitchenSink.repeated_int64_val[OFFSET(3)],
       KitchenSink.repeated_int64_val[ORDINAL(3)]
from TestTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [INT64]
| +-$query.$col2#5 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#4, $col2#5]
    +-expr_list=
    | +-$col1#4 :=
    | | +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<INT64>, INT64) -> INT64)
    | |   +-GetProtoField
    | |   | +-type=ARRAY<INT64>
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=repeated_int64_val
    | |   | +-default_value=[]
    | |   +-Literal(type=INT64, value=3)
    | +-$col2#5 :=
    |   +-FunctionCall(ZetaSQL:$array_at_ordinal(ARRAY<INT64>, INT64) -> INT64)
    |     +-GetProtoField
    |     | +-type=ARRAY<INT64>
    |     | +-expr=
    |     | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     | +-field_descriptor=repeated_int64_val
    |     | +-default_value=[]
    |     +-Literal(type=INT64, value=3)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# Coercion of array offset to int64.
select [1,2,3][OFFSET(cast(1+2 as uint32))]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<INT64>, INT64) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-Cast(UINT32 -> INT64)
    |       +-Cast(INT64 -> UINT32)
    |         +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           +-Literal(type=INT64, value=1)
    |           +-Literal(type=INT64, value=2)
    +-input_scan=
      +-SingleRowScan
==

select [1,2,3][OFFSET("abc")]
--
ERROR: Array position in [] must be coercible to INT64 type, but has type STRING [at 1:23]
select [1,2,3][OFFSET("abc")]
                      ^
==

select 1.5[OFFSET(5)]
--
ERROR: Subscript access using [OFFSET(INT64)] is not supported on values of type DOUBLE [at 1:12]
select 1.5[OFFSET(5)]
           ^
==

# No analysis-time errors for out of range values.
select ["a","b"][OFFSET(-1)],
       array<bool>[][ORDINAL(0)],
       cast(null as array<double>)[ORDINAL(NULL)]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRING]
| +-$query.$col2#2 AS `$col2` [BOOL]
| +-$query.$col3#3 AS `$col3` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<STRING>, INT64) -> STRING)
    | |   +-Literal(type=ARRAY<STRING>, value=["a", "b"])
    | |   +-Literal(type=INT64, value=-1)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:$array_at_ordinal(ARRAY<BOOL>, INT64) -> BOOL)
    | |   +-Literal(type=ARRAY<BOOL>, value=[], has_explicit_type=TRUE)
    | |   +-Literal(type=INT64, value=0)
    | +-$col3#3 :=
    |   +-FunctionCall(ZetaSQL:$array_at_ordinal(ARRAY<DOUBLE>, INT64) -> DOUBLE)
    |     +-Literal(type=ARRAY<DOUBLE>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

select [1,2,3][offset(count(*))]
from TestTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<INT64>, INT64) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#4)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-aggregate_list=
          +-$agg1#4 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

# Using OFFSET or ORDINAL functions elsewhere gives an error.
select offset(5) from TestTable
--
ERROR: OFFSET is not a function. It can only be used for array element access using array[OFFSET(position)] [at 1:8]
select offset(5) from TestTable
       ^
==

# Using OFFSET or ORDINAL functions elsewhere gives an error.
select safe_offset(5) from TestTable
--
ERROR: SAFE_OFFSET is not a function. It can only be used for array element access using array[SAFE_OFFSET(position)] [at 1:8]
select safe_offset(5) from TestTable
       ^
==

select 1+ordINAL(5,6,7) from TestTable
--
ERROR: ORDINAL is not a function. It can only be used for array element access using array[ORDINAL(position)] [at 1:10]
select 1+ordINAL(5,6,7) from TestTable
         ^
==

select [1,2,3][offset(ordinal(1))]
--
ERROR: ORDINAL is not a function. It can only be used for array element access using array[ORDINAL(position)] [at 1:23]
select [1,2,3][offset(ordinal(1))]
                      ^
==

# Invalid offset wrapper - 0 args.
select [1,2,3][offset()]
--
ERROR: Array element access with array[position] is not supported. Use array[OFFSET(zero_based_offset)] or array[ORDINAL(one_based_ordinal)] [at 1:16]
select [1,2,3][offset()]
               ^
==

# Invalid offset wrapper - 2 args.
select [1,2,3][offset(5, 6)]
--
ERROR: Array element access with array[position] is not supported. Use array[OFFSET(zero_based_offset)] or array[ORDINAL(one_based_ordinal)] [at 1:16]
select [1,2,3][offset(5, 6)]
               ^
==

# Invalid offset wrapper - distinct.
select [1,2,3][offset(distinct 5)]
--
ERROR: Array element access with array[position] is not supported. Use array[OFFSET(zero_based_offset)] or array[ORDINAL(one_based_ordinal)] [at 1:16]
select [1,2,3][offset(distinct 5)]
               ^
==

# Error occurs inside the offset wrapper.
select [1,2,3][offset(1+x+2)]
--
ERROR: Unrecognized name: x [at 1:25]
select [1,2,3][offset(1+x+2)]
                        ^
==

# The following would be equivalent to an ELT() function, though
# without any short circuit semantics:
# ELT(key, "str1", value, "str2")
select ["str1", value, "str2"][ordinal(key)]
from KeyValue;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:$array_at_ordinal(ARRAY<STRING>, INT64) -> STRING)
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(3) STRING) -> ARRAY<STRING>)
    |     | +-Literal(type=STRING, value="str1")
    |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     | +-Literal(type=STRING, value="str2")
    |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
==

select [][OFFSET(0)]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<INT64>, INT64) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    |     +-Literal(type=INT64, value=0)
    +-input_scan=
      +-SingleRowScan

==

[language_features=V_1_3_PROTO_MAPS]
select SAFE_KEY("FOO")
--
ERROR: SAFE_KEY is not a function. It can only be used for map element access using map[SAFE_KEY(key)] [at 1:8]
select SAFE_KEY("FOO")
       ^
==

[language_features=V_1_3_PROTO_MAPS]
select KEY("FOO")
--
ERROR: KEY is not a function. It can only be used for map element access using map[KEY(key)] [at 1:8]
select KEY("FOO")
       ^
==

[language_features=V_1_3_PROTO_MAPS]
select [][KEY("FOO")]
--
ERROR: Only proto maps can be accessed using KEY or SAFE_KEY; tried to use map accessor on ARRAY<INT64> [at 1:11]
select [][KEY("FOO")]
          ^
==

[language_features=V_1_3_PROTO_MAPS]
select MessageWithMapField.string_int32_map[KEY("foo")]
from MapFieldTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:$proto_map_at_key(ARRAY<PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>>, STRING) -> INT32)
    |     +-GetProtoField
    |     | +-type=ARRAY<PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>>
    |     | +-expr=
    |     | | +-ColumnRef(type=PROTO<zetasql_test__.MessageWithMapField>, column=MapFieldTable.MessageWithMapField#2)
    |     | +-field_descriptor=string_int32_map
    |     | +-default_value=[]
    |     +-Literal(type=STRING, value="foo")
    +-input_scan=
      +-TableScan(column_list=[MapFieldTable.MessageWithMapField#2], table=MapFieldTable, column_index_list=[1])
==

select MessageWithMapField.string_int32_map[{{SAFE_|}}KEY("foo")]
from MapFieldTable
--
ALTERNATION GROUP: SAFE_
--
ERROR: Element access using [SAFE_KEY()] is not supported on values of type ARRAY<zetasql_test__.MessageWithMapField.StringInt32MapEntry> [at 1:44]
select MessageWithMapField.string_int32_map[SAFE_KEY("foo")]
                                           ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Element access using [KEY()] is not supported on values of type ARRAY<zetasql_test__.MessageWithMapField.StringInt32MapEntry> [at 1:44]
select MessageWithMapField.string_int32_map[KEY("foo")]
                                           ^
==

[enabled_ast_rewrites=DEFAULTS]
[language_features=V_1_3_PROTO_MAPS]
select MessageWithMapField.string_int32_map[SAFE_KEY("foo")]
from MapFieldTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:$safe_proto_map_at_key(ARRAY<PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>>, STRING) -> INT32)
    |     +-GetProtoField
    |     | +-type=ARRAY<PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>>
    |     | +-expr=
    |     | | +-ColumnRef(type=PROTO<zetasql_test__.MessageWithMapField>, column=MapFieldTable.MessageWithMapField#2)
    |     | +-field_descriptor=string_int32_map
    |     | +-default_value=[]
    |     +-Literal(type=STRING, value="foo")
    +-input_scan=
      +-TableScan(column_list=[MapFieldTable.MessageWithMapField#2], table=MapFieldTable, column_index_list=[1])

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-SubqueryExpr
    |     +-type=INT32
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.MessageWithMapField>, column=MapFieldTable.MessageWithMapField#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#9]
    |         +-expr_list=
    |         | +-$col1#9 :=
    |         |   +-FunctionCall(ZetaSQL:$case_no_value(repeated(2) BOOL, repeated(2) INT32, INT32) -> INT32)
    |         |     +-FunctionCall(ZetaSQL:$is_null(ARRAY<PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>>) -> BOOL)
    |         |     | +-ColumnRef(type=ARRAY<PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>>, column=$subquery1.m#5)
    |         |     +-Literal(type=INT32, value=NULL)
    |         |     +-FunctionCall(ZetaSQL:$is_null(STRING) -> BOOL)
    |         |     | +-ColumnRef(type=STRING, column=$subquery1.k#4)
    |         |     +-Literal(type=INT32, value=NULL)
    |         |     +-SubqueryExpr
    |         |       +-type=INT32
    |         |       +-subquery_type=SCALAR
    |         |       +-parameter_list=
    |         |       | +-ColumnRef(type=STRING, column=$subquery1.k#4)
    |         |       | +-ColumnRef(type=ARRAY<PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>>, column=$subquery1.m#5)
    |         |       +-subquery=
    |         |         +-LimitOffsetScan
    |         |           +-column_list=[$expr_subquery.value#8]
    |         |           +-input_scan=
    |         |           | +-OrderByScan
    |         |           |   +-column_list=[$expr_subquery.value#8]
    |         |           |   +-is_ordered=TRUE
    |         |           |   +-input_scan=
    |         |           |   | +-ProjectScan
    |         |           |   |   +-column_list=[$array.elem#6, $array_offset.offset#7, $expr_subquery.value#8]
    |         |           |   |   +-expr_list=
    |         |           |   |   | +-value#8 :=
    |         |           |   |   |   +-GetProtoField
    |         |           |   |   |     +-type=INT32
    |         |           |   |   |     +-expr=
    |         |           |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>, column=$array.elem#6)
    |         |           |   |   |     +-field_descriptor=value
    |         |           |   |   |     +-default_value=0
    |         |           |   |   +-input_scan=
    |         |           |   |     +-FilterScan
    |         |           |   |       +-column_list=[$array.elem#6, $array_offset.offset#7]
    |         |           |   |       +-input_scan=
    |         |           |   |       | +-ArrayScan
    |         |           |   |       |   +-column_list=[$array.elem#6, $array_offset.offset#7]
    |         |           |   |       |   +-array_expr=
    |         |           |   |       |   | +-ColumnRef(type=ARRAY<PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>>, column=$subquery1.m#5, is_correlated=TRUE)
    |         |           |   |       |   +-element_column=$array.elem#6
    |         |           |   |       |   +-array_offset_column=
    |         |           |   |       |     +-ColumnHolder(column=$array_offset.offset#7)
    |         |           |   |       +-filter_expr=
    |         |           |   |         +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |         |           |   |           +-GetProtoField
    |         |           |   |           | +-type=STRING
    |         |           |   |           | +-expr=
    |         |           |   |           | | +-ColumnRef(type=PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>, column=$array.elem#6)
    |         |           |   |           | +-field_descriptor=key
    |         |           |   |           | +-default_value=""
    |         |           |   |           +-ColumnRef(type=STRING, column=$subquery1.k#4, is_correlated=TRUE)
    |         |           |   +-order_by_item_list=
    |         |           |     +-OrderByItem
    |         |           |       +-column_ref=
    |         |           |       | +-ColumnRef(type=INT64, column=$array_offset.offset#7)
    |         |           |       +-is_descending=TRUE
    |         |           +-limit=
    |         |             +-Literal(type=INT64, value=1)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=$subquery1.[k#4, m#5]
    |             +-expr_list=
    |             | +-k#4 := Literal(type=STRING, value="foo")
    |             | +-m#5 :=
    |             |   +-GetProtoField
    |             |     +-type=ARRAY<PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>>
    |             |     +-expr=
    |             |     | +-ColumnRef(type=PROTO<zetasql_test__.MessageWithMapField>, column=MapFieldTable.MessageWithMapField#2, is_correlated=TRUE)
    |             |     +-field_descriptor=string_int32_map
    |             |     +-default_value=[]
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-TableScan(column_list=[MapFieldTable.MessageWithMapField#2], table=MapFieldTable, column_index_list=[1])
==

[enabled_ast_rewrites=DEFAULTS]
[language_features=V_1_3_PROTO_MAPS]
select MessageWithMapField.int64_uint64_map[KEY(table.key)]
from MapFieldTable table
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [UINT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:$proto_map_at_key(ARRAY<PROTO<zetasql_test__.MessageWithMapField.Int64Uint64MapEntry>>, INT64) -> UINT64)
    |     +-GetProtoField
    |     | +-type=ARRAY<PROTO<zetasql_test__.MessageWithMapField.Int64Uint64MapEntry>>
    |     | +-expr=
    |     | | +-ColumnRef(type=PROTO<zetasql_test__.MessageWithMapField>, column=MapFieldTable.MessageWithMapField#2)
    |     | +-field_descriptor=int64_uint64_map
    |     | +-default_value=[]
    |     +-Cast(INT32 -> INT64)
    |       +-ColumnRef(type=INT32, column=MapFieldTable.key#1)
    +-input_scan=
      +-TableScan(column_list=MapFieldTable.[key#1, MessageWithMapField#2], table=MapFieldTable, column_index_list=[0, 1], alias="table")

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [UINT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-SubqueryExpr
    |     +-type=UINT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT32, column=MapFieldTable.key#1)
    |     | +-ColumnRef(type=PROTO<zetasql_test__.MessageWithMapField>, column=MapFieldTable.MessageWithMapField#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#9]
    |         +-expr_list=
    |         | +-$col1#9 :=
    |         |   +-FunctionCall(ZetaSQL:$case_no_value(repeated(2) BOOL, repeated(2) UINT64, UINT64) -> UINT64)
    |         |     +-FunctionCall(ZetaSQL:$is_null(ARRAY<PROTO<zetasql_test__.MessageWithMapField.Int64Uint64MapEntry>>) -> BOOL)
    |         |     | +-ColumnRef(type=ARRAY<PROTO<zetasql_test__.MessageWithMapField.Int64Uint64MapEntry>>, column=$subquery1.m#5)
    |         |     +-Literal(type=UINT64, value=NULL)
    |         |     +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
    |         |     | +-ColumnRef(type=INT64, column=$subquery1.k#4)
    |         |     +-Literal(type=UINT64, value=NULL)
    |         |     +-FunctionCall(ZetaSQL:ifnull(UINT64, UINT64) -> UINT64)
    |         |       +-SubqueryExpr
    |         |       | +-type=UINT64
    |         |       | +-subquery_type=SCALAR
    |         |       | +-parameter_list=
    |         |       | | +-ColumnRef(type=INT64, column=$subquery1.k#4)
    |         |       | | +-ColumnRef(type=ARRAY<PROTO<zetasql_test__.MessageWithMapField.Int64Uint64MapEntry>>, column=$subquery1.m#5)
    |         |       | +-subquery=
    |         |       |   +-LimitOffsetScan
    |         |       |     +-column_list=[$expr_subquery.value#8]
    |         |       |     +-input_scan=
    |         |       |     | +-OrderByScan
    |         |       |     |   +-column_list=[$expr_subquery.value#8]
    |         |       |     |   +-is_ordered=TRUE
    |         |       |     |   +-input_scan=
    |         |       |     |   | +-ProjectScan
    |         |       |     |   |   +-column_list=[$array.elem#6, $array_offset.offset#7, $expr_subquery.value#8]
    |         |       |     |   |   +-expr_list=
    |         |       |     |   |   | +-value#8 :=
    |         |       |     |   |   |   +-GetProtoField
    |         |       |     |   |   |     +-type=UINT64
    |         |       |     |   |   |     +-expr=
    |         |       |     |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.MessageWithMapField.Int64Uint64MapEntry>, column=$array.elem#6)
    |         |       |     |   |   |     +-field_descriptor=value
    |         |       |     |   |   |     +-default_value=0
    |         |       |     |   |   +-input_scan=
    |         |       |     |   |     +-FilterScan
    |         |       |     |   |       +-column_list=[$array.elem#6, $array_offset.offset#7]
    |         |       |     |   |       +-input_scan=
    |         |       |     |   |       | +-ArrayScan
    |         |       |     |   |       |   +-column_list=[$array.elem#6, $array_offset.offset#7]
    |         |       |     |   |       |   +-array_expr=
    |         |       |     |   |       |   | +-ColumnRef(type=ARRAY<PROTO<zetasql_test__.MessageWithMapField.Int64Uint64MapEntry>>, column=$subquery1.m#5, is_correlated=TRUE)
    |         |       |     |   |       |   +-element_column=$array.elem#6
    |         |       |     |   |       |   +-array_offset_column=
    |         |       |     |   |       |     +-ColumnHolder(column=$array_offset.offset#7)
    |         |       |     |   |       +-filter_expr=
    |         |       |     |   |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |         |       |     |   |           +-GetProtoField
    |         |       |     |   |           | +-type=INT64
    |         |       |     |   |           | +-expr=
    |         |       |     |   |           | | +-ColumnRef(type=PROTO<zetasql_test__.MessageWithMapField.Int64Uint64MapEntry>, column=$array.elem#6)
    |         |       |     |   |           | +-field_descriptor=key
    |         |       |     |   |           | +-default_value=0
    |         |       |     |   |           +-ColumnRef(type=INT64, column=$subquery1.k#4, is_correlated=TRUE)
    |         |       |     |   +-order_by_item_list=
    |         |       |     |     +-OrderByItem
    |         |       |     |       +-column_ref=
    |         |       |     |       | +-ColumnRef(type=INT64, column=$array_offset.offset#7)
    |         |       |     |       +-is_descending=TRUE
    |         |       |     +-limit=
    |         |       |       +-Literal(type=INT64, value=1)
    |         |       +-Cast(UINT64 -> UINT64)
    |         |         +-FunctionCall(ZetaSQL:error(STRING) -> UINT64)
    |         |           +-FunctionCall(ZetaSQL:format(STRING, repeated(1) INT64) -> STRING)
    |         |             +-Literal(type=STRING, value="Key not found in map: %T")
    |         |             +-ColumnRef(type=INT64, column=$subquery1.k#4)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=$subquery1.[k#4, m#5]
    |             +-expr_list=
    |             | +-k#4 :=
    |             | | +-Cast(INT32 -> INT64)
    |             | |   +-ColumnRef(type=INT32, column=MapFieldTable.key#1, is_correlated=TRUE)
    |             | +-m#5 :=
    |             |   +-GetProtoField
    |             |     +-type=ARRAY<PROTO<zetasql_test__.MessageWithMapField.Int64Uint64MapEntry>>
    |             |     +-expr=
    |             |     | +-ColumnRef(type=PROTO<zetasql_test__.MessageWithMapField>, column=MapFieldTable.MessageWithMapField#2, is_correlated=TRUE)
    |             |     +-field_descriptor=int64_uint64_map
    |             |     +-default_value=[]
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-TableScan(column_list=MapFieldTable.[key#1, MessageWithMapField#2], table=MapFieldTable, column_index_list=[0, 1], alias="table")
==

[language_features=V_1_3_PROTO_MAPS]
select MessageWithMapField.int32_int32_map[SAFE_KEY(key + 1)]
from MapFieldTable
--
ERROR: Map key in [] must be coercible to type INT32, but has type INT64 [at 1:53]
select MessageWithMapField.int32_int32_map[SAFE_KEY(key + 1)]
                                                    ^
==

[language_features=V_1_3_PROTO_MAPS]
select MODIFY_MAP(MessageWithMapField.int32_int32_map, key + 1, key + 2)
from MapFieldTable
--
ERROR: No matching signature for function MODIFY_MAP(ARRAY<zetasql_test__.MessageWithMapField.Int32Int32MapEntry>, INT64, INT64); some key or value did not match the map's key or value type. Supported signature: MODIFY_MAP(PROTO_MAP, [PROTO_MAP_KEY, ...], [PROTO_MAP_VALUE, ...]) [at 1:8]
select MODIFY_MAP(MessageWithMapField.int32_int32_map, key + 1, key + 2)
       ^
==

[enabled_ast_rewrites=NONE]
[language_features=V_1_3_PROTO_MAPS]
select MODIFY_MAP(MessageWithMapField.int32_int32_map, CAST(key + 1 AS INT32), CAST(key + 2 AS INT32))
from MapFieldTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<PROTO<zetasql_test__.MessageWithMapField.Int32Int32MapEntry>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:modify_map(ARRAY<PROTO<zetasql_test__.MessageWithMapField.Int32Int32MapEntry>>, repeated(1) INT32, repeated(1) INT32) -> ARRAY<PROTO<zetasql_test__.MessageWithMapField.Int32Int32MapEntry>>)
    |     +-GetProtoField
    |     | +-type=ARRAY<PROTO<zetasql_test__.MessageWithMapField.Int32Int32MapEntry>>
    |     | +-expr=
    |     | | +-ColumnRef(type=PROTO<zetasql_test__.MessageWithMapField>, column=MapFieldTable.MessageWithMapField#2)
    |     | +-field_descriptor=int32_int32_map
    |     | +-default_value=[]
    |     +-Cast(INT64 -> INT32)
    |     | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     |   +-Cast(INT32 -> INT64)
    |     |   | +-ColumnRef(type=INT32, column=MapFieldTable.key#1)
    |     |   +-Literal(type=INT64, value=1)
    |     +-Cast(INT64 -> INT32)
    |       +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |         +-Cast(INT32 -> INT64)
    |         | +-ColumnRef(type=INT32, column=MapFieldTable.key#1)
    |         +-Literal(type=INT64, value=2)
    +-input_scan=
      +-TableScan(column_list=MapFieldTable.[key#1, MessageWithMapField#2], table=MapFieldTable, column_index_list=[0, 1])
