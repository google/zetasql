# out-of-order WITH entries without actual recursion
[default language_features=V_1_3_WITH_RECURSIVE,ANALYTIC_FUNCTIONS,TABLE_VALUED_FUNCTIONS,TABLESAMPLE,V_1_1_WITH_ON_SUBQUERY,NUMERIC_TYPE]
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (SELECT * FROM t3 CROSS JOIN t4),
  t3 AS (SELECT * FROM UNNEST([1,2,3,4])),
  t4 AS (SELECT * FROM UNNEST([5,6,7,8]))
SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.$unnest2#7 AS `$unnest2` [INT64]
| +-t1.$unnest1#8 AS `$unnest1` [INT64]
+-query=
  +-WithScan
    +-column_list=t1.[$unnest2#7, $unnest1#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t4"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.$unnest1#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.$unnest1#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[5, 6, 7, 8])
    | |         +-element_column=$array.$unnest1#1
    | +-WithEntry
    | | +-with_query_name="t3"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.$unnest2#2]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.$unnest2#2]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.$unnest2#2
    | +-WithEntry
    | | +-with_query_name="t2"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[t3.$unnest2#3, t4.$unnest1#4]
    | |     +-input_scan=
    | |       +-JoinScan
    | |         +-column_list=[t3.$unnest2#3, t4.$unnest1#4]
    | |         +-left_scan=
    | |         | +-WithRefScan(column_list=[t3.$unnest2#3], with_query_name="t3")
    | |         +-right_scan=
    | |           +-WithRefScan(column_list=[t4.$unnest1#4], with_query_name="t4")
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t2.[$unnest2#5, $unnest1#6]
    |       +-input_scan=
    |         +-WithRefScan(column_list=t2.[$unnest2#5, $unnest1#6], with_query_name="t2")
    +-query=
    | +-ProjectScan
    |   +-column_list=t1.[$unnest2#7, $unnest1#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=t1.[$unnest2#7, $unnest1#8], with_query_name="t1")
    +-recursive=TRUE
==

# Simple recursive query
WITH RECURSIVE
  t1 AS (SELECT 1 AS n UNION {{ALL|DISTINCT}} SELECT n + 1 FROM t1 WHERE n < 20)
SELECT * FROM t1;
--
ALTERNATION GROUP: ALL
--
QueryStmt
+-output_column_list=
| +-t1.n#5 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.n#5]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#4]
    |           |   +-expr_list=
    |           |   | +-$col1#4 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=t1.n#3)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=[t1.n#3]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=[t1.n#3])
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t1.n#3)
    |           |           +-Literal(type=INT64, value=20)
    |           +-output_column_list=[$union_all2.$col1#4]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.n#5]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.n#5], with_query_name="t1")
    +-recursive=TRUE
--
ALTERNATION GROUP: DISTINCT
--
QueryStmt
+-output_column_list=
| +-t1.n#5 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.n#5]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_distinct.n#2]
    |       +-op_type=UNION_DISTINCT
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_distinct1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_distinct1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_distinct2.$col1#4]
    |           |   +-expr_list=
    |           |   | +-$col1#4 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=t1.n#3)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=[t1.n#3]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=[t1.n#3])
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t1.n#3)
    |           |           +-Literal(type=INT64, value=20)
    |           +-output_column_list=[$union_distinct2.$col1#4]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.n#5]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.n#5], with_query_name="t1")
    +-recursive=TRUE
==

# Under WITH RECURSIVE, a forward reference masks a table in the catalog of the
# same name.
WITH RECURSIVE
  t1 AS (SELECT * FROM KeyValue),
  KeyValue AS (SELECT * FROM UNNEST([1,2,3,4]))
SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.$unnest1#3 AS `$unnest1` [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.$unnest1#3]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="KeyValue"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.$unnest1#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.$unnest1#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.$unnest1#1
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[KeyValue.$unnest1#2]
    |       +-input_scan=
    |         +-WithRefScan(column_list=[KeyValue.$unnest1#2], with_query_name="KeyValue")
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.$unnest1#3]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.$unnest1#3], with_query_name="t1")
    +-recursive=TRUE
==

# Under WITH RECURSIVE, a backward reference masks a table in the catalog of the
# same name.
WITH RECURSIVE
  KeyValue AS (SELECT * FROM UNNEST([1,2,3,4])),
  t1 AS (SELECT * FROM KeyValue)
SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.$unnest1#3 AS `$unnest1` [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.$unnest1#3]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="KeyValue"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.$unnest1#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.$unnest1#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.$unnest1#1
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[KeyValue.$unnest1#2]
    |       +-input_scan=
    |         +-WithRefScan(column_list=[KeyValue.$unnest1#2], with_query_name="KeyValue")
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.$unnest1#3]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.$unnest1#3], with_query_name="t1")
    +-recursive=TRUE
==

# ERROR: Unsupported multi-element cycle in dependency graph
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (SELECT * FROM t3 CROSS JOIN t4),
  t3 AS (SELECT * FROM t1),
  t4 AS (SELECT * FROM UNNEST([5,6,7,8]))
SELECT * FROM t1;
--
ERROR: Unsupported WITH entry dependency cycle: t3 => t1 => t2 => t3 [at 1:1]
WITH RECURSIVE
^
==

# Due to name shadowing, this query is allowed (not a multi-element cycle)
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (WITH t1 AS (SELECT 1) SELECT * FROM t1)
SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1_2.$col1#4 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=[t1_2.$col1#4]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t2"
    | | +-with_subquery=
    | |   +-WithScan
    | |     +-column_list=[t1.$col1#2]
    | |     +-with_entry_list=
    | |     | +-WithEntry
    | |     |   +-with_query_name="t1"
    | |     |   +-with_subquery=
    | |     |     +-ProjectScan
    | |     |       +-column_list=[t1.$col1#1]
    | |     |       +-expr_list=
    | |     |       | +-$col1#1 := Literal(type=INT64, value=1)
    | |     |       +-input_scan=
    | |     |         +-SingleRowScan
    | |     +-query=
    | |       +-ProjectScan
    | |         +-column_list=[t1.$col1#2]
    | |         +-input_scan=
    | |           +-WithRefScan(column_list=[t1.$col1#2], with_query_name="t1")
    | +-WithEntry
    |   +-with_query_name="t1_2"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t2.$col1#3]
    |       +-input_scan=
    |         +-WithRefScan(column_list=[t2.$col1#3], with_query_name="t2")
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1_2.$col1#4]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1_2.$col1#4], with_query_name="t1_2")
    +-recursive=TRUE
==

# ERROR: Since the inner WITH is not recursive, the inner
# 'FROM t1' is actually a recursive reference to the other t1, resulting in a
# multi-element cycle.
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (WITH t1 AS (SELECT * FROM t1) SELECT 1)
SELECT * FROM t1;
--
ERROR: Unsupported WITH entry dependency cycle: t2 => t1 => t2 [at 1:1]
WITH RECURSIVE
^
==

# ERROR: Inner t3 goes to catalog because inner WITH is non-recursive
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (WITH t1 AS (SELECT * FROM t3), t3 AS (SELECT 1) SELECT 1)
SELECT * FROM t1;
--
ERROR: Table not found: t3 [at 3:36]
  t2 AS (WITH t1 AS (SELECT * FROM t3), t3 AS (SELECT 1) SELECT 1)
                                   ^
==

# Not a multi-element cycle, due to 't1' being a forward reference in inner,
# recursive WITH
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (WITH RECURSIVE t1 AS (SELECT * FROM t3), t3 AS (SELECT 1) SELECT * FROM t1, t3)
SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1_3.$col1#7 AS `$col1` [INT64]
| +-t1_3.$col1#8 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=t1_3.[$col1#7, $col1#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t2"
    | | +-with_subquery=
    | |   +-WithScan
    | |     +-column_list=[t1.$col1#3, t3.$col1#4]
    | |     +-with_entry_list=
    | |     | +-WithEntry
    | |     | | +-with_query_name="t3"
    | |     | | +-with_subquery=
    | |     | |   +-ProjectScan
    | |     | |     +-column_list=[t3.$col1#1]
    | |     | |     +-expr_list=
    | |     | |     | +-$col1#1 := Literal(type=INT64, value=1)
    | |     | |     +-input_scan=
    | |     | |       +-SingleRowScan
    | |     | +-WithEntry
    | |     |   +-with_query_name="t1"
    | |     |   +-with_subquery=
    | |     |     +-ProjectScan
    | |     |       +-column_list=[t3.$col1#2]
    | |     |       +-input_scan=
    | |     |         +-WithRefScan(column_list=[t3.$col1#2], with_query_name="t3")
    | |     +-query=
    | |     | +-ProjectScan
    | |     |   +-column_list=[t1.$col1#3, t3.$col1#4]
    | |     |   +-input_scan=
    | |     |     +-JoinScan
    | |     |       +-column_list=[t1.$col1#3, t3.$col1#4]
    | |     |       +-left_scan=
    | |     |       | +-WithRefScan(column_list=[t1.$col1#3], with_query_name="t1")
    | |     |       +-right_scan=
    | |     |         +-WithRefScan(column_list=[t3.$col1#4], with_query_name="t3")
    | |     +-recursive=TRUE
    | +-WithEntry
    |   +-with_query_name="t1_3"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t2.[$col1#5, $col1#6]
    |       +-input_scan=
    |         +-WithRefScan(column_list=t2.[$col1#5, $col1#6], with_query_name="t2")
    +-query=
    | +-ProjectScan
    |   +-column_list=t1_3.[$col1#7, $col1#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=t1_3.[$col1#7, $col1#8], with_query_name="t1_3")
    +-recursive=TRUE
==

# Not recursive at all, due to inner t2 shadowing outer t2
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (WITH RECURSIVE t2 AS (SELECT 1) SELECT * FROM t2)
SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.$col1#4 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.$col1#4]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t2"
    | | +-with_subquery=
    | |   +-WithScan
    | |     +-column_list=[t2_1.$col1#2]
    | |     +-with_entry_list=
    | |     | +-WithEntry
    | |     |   +-with_query_name="t2_1"
    | |     |   +-with_subquery=
    | |     |     +-ProjectScan
    | |     |       +-column_list=[t2.$col1#1]
    | |     |       +-expr_list=
    | |     |       | +-$col1#1 := Literal(type=INT64, value=1)
    | |     |       +-input_scan=
    | |     |         +-SingleRowScan
    | |     +-query=
    | |     | +-ProjectScan
    | |     |   +-column_list=[t2_1.$col1#2]
    | |     |   +-input_scan=
    | |     |     +-WithRefScan(column_list=[t2_1.$col1#2], with_query_name="t2_1")
    | |     +-recursive=TRUE
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t2.$col1#3]
    |       +-input_scan=
    |         +-WithRefScan(column_list=[t2.$col1#3], with_query_name="t2")
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.$col1#4]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.$col1#4], with_query_name="t1")
    +-recursive=TRUE
==

# This is not a multi-element cycle due to inner 't1' being recursive too.
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (WITH RECURSIVE t1 AS (SELECT 1 UNION ALL SELECT * FROM t1) SELECT 1)
SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1_2.$col1#6 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=[t1_2.$col1#6]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t2"
    | | +-with_subquery=
    | |   +-WithScan
    | |     +-column_list=[t2.$col1#4]
    | |     +-with_entry_list=
    | |     | +-WithEntry
    | |     |   +-with_query_name="t1"
    | |     |   +-with_subquery=
    | |     |     +-RecursiveScan
    | |     |       +-column_list=[$union_all.$col1#2]
    | |     |       +-op_type=UNION_ALL
    | |     |       +-non_recursive_term=
    | |     |       | +-SetOperationItem
    | |     |       |   +-scan=
    | |     |       |   | +-ProjectScan
    | |     |       |   |   +-column_list=[$union_all1.$col1#1]
    | |     |       |   |   +-expr_list=
    | |     |       |   |   | +-$col1#1 := Literal(type=INT64, value=1)
    | |     |       |   |   +-input_scan=
    | |     |       |   |     +-SingleRowScan
    | |     |       |   +-output_column_list=[$union_all1.$col1#1]
    | |     |       +-recursive_term=
    | |     |         +-SetOperationItem
    | |     |           +-scan=
    | |     |           | +-ProjectScan
    | |     |           |   +-column_list=[t1.$col1#3]
    | |     |           |   +-input_scan=
    | |     |           |     +-RecursiveRefScan(column_list=[t1.$col1#3])
    | |     |           +-output_column_list=[t1.$col1#3]
    | |     +-query=
    | |     | +-ProjectScan
    | |     |   +-column_list=[t2.$col1#4]
    | |     |   +-expr_list=
    | |     |   | +-$col1#4 := Literal(type=INT64, value=1)
    | |     |   +-input_scan=
    | |     |     +-SingleRowScan
    | |     +-recursive=TRUE
    | +-WithEntry
    |   +-with_query_name="t1_2"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t2.$col1#5]
    |       +-input_scan=
    |         +-WithRefScan(column_list=[t2.$col1#5], with_query_name="t2")
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1_2.$col1#6]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1_2.$col1#6], with_query_name="t1_2")
    +-recursive=TRUE
==

# Nested chains of inner WITH's with same alias name. This is ok because all
# t1's inside t2 are actually referring to an inner t1.
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (WITH t1 AS (
    WITH t1 AS (
      WITH t1 AS (SELECT 1) SELECT * FROM t1)
      SELECT * FROM t1)
    SELECT * FROM t1)
SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1_4.$col1#6 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=[t1_4.$col1#6]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t2"
    | | +-with_subquery=
    | |   +-WithScan
    | |     +-column_list=[t1.$col1#4]
    | |     +-with_entry_list=
    | |     | +-WithEntry
    | |     |   +-with_query_name="t1"
    | |     |   +-with_subquery=
    | |     |     +-WithScan
    | |     |       +-column_list=[t1_2.$col1#3]
    | |     |       +-with_entry_list=
    | |     |       | +-WithEntry
    | |     |       |   +-with_query_name="t1_2"
    | |     |       |   +-with_subquery=
    | |     |       |     +-WithScan
    | |     |       |       +-column_list=[t1_3.$col1#2]
    | |     |       |       +-with_entry_list=
    | |     |       |       | +-WithEntry
    | |     |       |       |   +-with_query_name="t1_3"
    | |     |       |       |   +-with_subquery=
    | |     |       |       |     +-ProjectScan
    | |     |       |       |       +-column_list=[t1.$col1#1]
    | |     |       |       |       +-expr_list=
    | |     |       |       |       | +-$col1#1 := Literal(type=INT64, value=1)
    | |     |       |       |       +-input_scan=
    | |     |       |       |         +-SingleRowScan
    | |     |       |       +-query=
    | |     |       |         +-ProjectScan
    | |     |       |           +-column_list=[t1_3.$col1#2]
    | |     |       |           +-input_scan=
    | |     |       |             +-WithRefScan(column_list=[t1_3.$col1#2], with_query_name="t1_3")
    | |     |       +-query=
    | |     |         +-ProjectScan
    | |     |           +-column_list=[t1_2.$col1#3]
    | |     |           +-input_scan=
    | |     |             +-WithRefScan(column_list=[t1_2.$col1#3], with_query_name="t1_2")
    | |     +-query=
    | |       +-ProjectScan
    | |         +-column_list=[t1.$col1#4]
    | |         +-input_scan=
    | |           +-WithRefScan(column_list=[t1.$col1#4], with_query_name="t1")
    | +-WithEntry
    |   +-with_query_name="t1_4"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t2.$col1#5]
    |       +-input_scan=
    |         +-WithRefScan(column_list=[t2.$col1#5], with_query_name="t2")
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1_4.$col1#6]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1_4.$col1#6], with_query_name="t1_4")
    +-recursive=TRUE
==

# ERROR: Here, we have nested chains, but the outermost t1 inside t2 is
# referring to the main t1, so it's mutual recursion
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (WITH t3 AS (
    WITH t1 AS (
      WITH t1 AS (SELECT 1) SELECT * FROM t1
    ) SELECT * FROM t1
  ) SELECT * FROM t1)
SELECT * FROM t1;
--
ERROR: Unsupported WITH entry dependency cycle: t2 => t1 => t2 [at 1:1]
WITH RECURSIVE
^
==

# ERROR: Mutual recursion in subquery WITH
WITH RECURSIVE
  t1 AS ( WITH RECURSIVE
            t2 AS (SELECT * FROM t3),
            t3 AS (SELECT * FROM t2)
          SELECT * FROM t2, t3)
  SELECT * FROM t1;
--
ERROR: Unsupported WITH entry dependency cycle: t3 => t2 => t3 [at 2:11]
  t1 AS ( WITH RECURSIVE
          ^
==

# ERROR: Query which is has both self-recursion and mutual recursion
WITH RECURSIVE
  t1 AS (SELECT * FROM t1, t2),
  t2 AS (SELECT * FROM t3),
  t3 AS (SELECT * FROM t1)
SELECT * FROM t1, t2;
--
ERROR: Unsupported WITH entry dependency cycle: t3 => t1 => t2 => t3 [at 1:1]
WITH RECURSIVE
^
==

# Out-of-order dependency chain where references use different casing from the
# definition.
WITH RECURSIVE
  t1 AS (SELECT * FROM T2),
  t2 AS (SELECT * FROM T3 CROSS JOIN T4),
  t3 AS (SELECT * FROM UNNEST([1,2,3,4])),
  t4 AS (SELECT * FROM UNNEST([5,6,7,8]))
SELECT * FROM T1;
--
QueryStmt
+-output_column_list=
| +-t1.$unnest2#7 AS `$unnest2` [INT64]
| +-t1.$unnest1#8 AS `$unnest1` [INT64]
+-query=
  +-WithScan
    +-column_list=t1.[$unnest2#7, $unnest1#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t4"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.$unnest1#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.$unnest1#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[5, 6, 7, 8])
    | |         +-element_column=$array.$unnest1#1
    | +-WithEntry
    | | +-with_query_name="t3"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.$unnest2#2]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.$unnest2#2]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.$unnest2#2
    | +-WithEntry
    | | +-with_query_name="t2"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[t3.$unnest2#3, t4.$unnest1#4]
    | |     +-input_scan=
    | |       +-JoinScan
    | |         +-column_list=[t3.$unnest2#3, t4.$unnest1#4]
    | |         +-left_scan=
    | |         | +-WithRefScan(column_list=[t3.$unnest2#3], with_query_name="t3")
    | |         +-right_scan=
    | |           +-WithRefScan(column_list=[t4.$unnest1#4], with_query_name="t4")
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t2.[$unnest2#5, $unnest1#6]
    |       +-input_scan=
    |         +-WithRefScan(column_list=t2.[$unnest2#5, $unnest1#6], with_query_name="t2")
    +-query=
    | +-ProjectScan
    |   +-column_list=t1.[$unnest2#7, $unnest1#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=t1.[$unnest2#7, $unnest1#8], with_query_name="t1")
    +-recursive=TRUE
==

# ERROR: Unsupported multi-element cycle in dependency graph
# Mismatched casing between references and definitions don't prevent the cycle.
WITH RECURSIVE
  t1 AS (SELECT * FROM T2),
  t2 AS (SELECT * FROM T3 CROSS JOIN T4),
  t3 AS (SELECT * FROM T1),
  t4 AS (SELECT * FROM UNNEST([5,6,7,8]))
SELECT * FROM t1;
--
ERROR: Unsupported WITH entry dependency cycle: t3 => t1 => t2 => t3 [at 1:1]
WITH RECURSIVE
^
==

# Inner WITH whose alias name differs from outer WITH only in case;
# Note that the inner 't1' binds to the inner alias, 'T1', even though the case
# matches the outer alias 't1'.
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (
    WITH RECURSIVE
      T1 AS (SELECT * FROM t3),
      t3 AS (SELECT 1) SELECT * FROM t1, t3
) SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1_3.$col1#7 AS `$col1` [INT64]
| +-t1_3.$col1#8 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=t1_3.[$col1#7, $col1#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t2"
    | | +-with_subquery=
    | |   +-WithScan
    | |     +-column_list=[T1.$col1#3, t3.$col1#4]
    | |     +-with_entry_list=
    | |     | +-WithEntry
    | |     | | +-with_query_name="t3"
    | |     | | +-with_subquery=
    | |     | |   +-ProjectScan
    | |     | |     +-column_list=[t3.$col1#1]
    | |     | |     +-expr_list=
    | |     | |     | +-$col1#1 := Literal(type=INT64, value=1)
    | |     | |     +-input_scan=
    | |     | |       +-SingleRowScan
    | |     | +-WithEntry
    | |     |   +-with_query_name="T1"
    | |     |   +-with_subquery=
    | |     |     +-ProjectScan
    | |     |       +-column_list=[t3.$col1#2]
    | |     |       +-input_scan=
    | |     |         +-WithRefScan(column_list=[t3.$col1#2], with_query_name="t3")
    | |     +-query=
    | |     | +-ProjectScan
    | |     |   +-column_list=[T1.$col1#3, t3.$col1#4]
    | |     |   +-input_scan=
    | |     |     +-JoinScan
    | |     |       +-column_list=[T1.$col1#3, t3.$col1#4]
    | |     |       +-left_scan=
    | |     |       | +-WithRefScan(column_list=[T1.$col1#3], with_query_name="T1")
    | |     |       +-right_scan=
    | |     |         +-WithRefScan(column_list=[t3.$col1#4], with_query_name="t3")
    | |     +-recursive=TRUE
    | +-WithEntry
    |   +-with_query_name="t1_3"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t2.[$col1#5, $col1#6]
    |       +-input_scan=
    |         +-WithRefScan(column_list=t2.[$col1#5, $col1#6], with_query_name="t2")
    +-query=
    | +-ProjectScan
    |   +-column_list=t1_3.[$col1#7, $col1#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=t1_3.[$col1#7, $col1#8], with_query_name="t1_3")
    +-recursive=TRUE
==

# Diamond-shaped dependency graph
WITH RECURSIVE
   A AS (SELECT * FROM B, C),
   B AS (SELECT * FROM D),
   C AS (SELECT * FROM D),
   D AS (SELECT 1)
SELECT * FROM A;
--
QueryStmt
+-output_column_list=
| +-A.$col1#6 AS `$col1` [INT64]
| +-A.$col1#7 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=A.[$col1#6, $col1#7]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="D"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[D.$col1#1]
    | |     +-expr_list=
    | |     | +-$col1#1 := Literal(type=INT64, value=1)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    | | +-with_query_name="C"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[D.$col1#2]
    | |     +-input_scan=
    | |       +-WithRefScan(column_list=[D.$col1#2], with_query_name="D")
    | +-WithEntry
    | | +-with_query_name="B"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[D.$col1#3]
    | |     +-input_scan=
    | |       +-WithRefScan(column_list=[D.$col1#3], with_query_name="D")
    | +-WithEntry
    |   +-with_query_name="A"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[B.$col1#4, C.$col1#5]
    |       +-input_scan=
    |         +-JoinScan
    |           +-column_list=[B.$col1#4, C.$col1#5]
    |           +-left_scan=
    |           | +-WithRefScan(column_list=[B.$col1#4], with_query_name="B")
    |           +-right_scan=
    |             +-WithRefScan(column_list=[C.$col1#5], with_query_name="C")
    +-query=
    | +-ProjectScan
    |   +-column_list=A.[$col1#6, $col1#7]
    |   +-input_scan=
    |     +-WithRefScan(column_list=A.[$col1#6, $col1#7], with_query_name="A")
    +-recursive=TRUE
==

# Diamond-shaped dependency graph (nodes presented in reverse order)
WITH RECURSIVE
   D AS (SELECT 1),
   C AS (SELECT * FROM D),
   B AS (SELECT * FROM D),
   A AS (SELECT * FROM B, C)
SELECT * FROM A;
--
QueryStmt
+-output_column_list=
| +-A.$col1#6 AS `$col1` [INT64]
| +-A.$col1#7 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=A.[$col1#6, $col1#7]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="D"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[D.$col1#1]
    | |     +-expr_list=
    | |     | +-$col1#1 := Literal(type=INT64, value=1)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    | | +-with_query_name="B"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[D.$col1#2]
    | |     +-input_scan=
    | |       +-WithRefScan(column_list=[D.$col1#2], with_query_name="D")
    | +-WithEntry
    | | +-with_query_name="C"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[D.$col1#3]
    | |     +-input_scan=
    | |       +-WithRefScan(column_list=[D.$col1#3], with_query_name="D")
    | +-WithEntry
    |   +-with_query_name="A"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[B.$col1#4, C.$col1#5]
    |       +-input_scan=
    |         +-JoinScan
    |           +-column_list=[B.$col1#4, C.$col1#5]
    |           +-left_scan=
    |           | +-WithRefScan(column_list=[B.$col1#4], with_query_name="B")
    |           +-right_scan=
    |             +-WithRefScan(column_list=[C.$col1#5], with_query_name="C")
    +-query=
    | +-ProjectScan
    |   +-column_list=A.[$col1#6, $col1#7]
    |   +-input_scan=
    |     +-WithRefScan(column_list=A.[$col1#6, $col1#7], with_query_name="A")
    +-recursive=TRUE
==

# Complex (but not cyclic) dependency graph
WITH RECURSIVE
  A AS (SELECT * FROM B, C, D),
  B AS (SELECT * FROM E, F),
  C AS (SELECT * FROM E, F),
  D AS (SELECT * FROM E, F),
  E AS (SELECT * FROM G),
  F AS (SELECT * FROM G),
  G AS (SELECT 1)
SELECT * FROM A;
--
QueryStmt
+-output_column_list=
| +-A.$col1#16 AS `$col1` [INT64]
| +-A.$col1#17 AS `$col1` [INT64]
| +-A.$col1#18 AS `$col1` [INT64]
| +-A.$col1#19 AS `$col1` [INT64]
| +-A.$col1#20 AS `$col1` [INT64]
| +-A.$col1#21 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=A.[$col1#16, $col1#17, $col1#18, $col1#19, $col1#20, $col1#21]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="G"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[G.$col1#1]
    | |     +-expr_list=
    | |     | +-$col1#1 := Literal(type=INT64, value=1)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    | | +-with_query_name="F"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[G.$col1#2]
    | |     +-input_scan=
    | |       +-WithRefScan(column_list=[G.$col1#2], with_query_name="G")
    | +-WithEntry
    | | +-with_query_name="E"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[G.$col1#3]
    | |     +-input_scan=
    | |       +-WithRefScan(column_list=[G.$col1#3], with_query_name="G")
    | +-WithEntry
    | | +-with_query_name="D"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[E.$col1#4, F.$col1#5]
    | |     +-input_scan=
    | |       +-JoinScan
    | |         +-column_list=[E.$col1#4, F.$col1#5]
    | |         +-left_scan=
    | |         | +-WithRefScan(column_list=[E.$col1#4], with_query_name="E")
    | |         +-right_scan=
    | |           +-WithRefScan(column_list=[F.$col1#5], with_query_name="F")
    | +-WithEntry
    | | +-with_query_name="C"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[E.$col1#6, F.$col1#7]
    | |     +-input_scan=
    | |       +-JoinScan
    | |         +-column_list=[E.$col1#6, F.$col1#7]
    | |         +-left_scan=
    | |         | +-WithRefScan(column_list=[E.$col1#6], with_query_name="E")
    | |         +-right_scan=
    | |           +-WithRefScan(column_list=[F.$col1#7], with_query_name="F")
    | +-WithEntry
    | | +-with_query_name="B"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[E.$col1#8, F.$col1#9]
    | |     +-input_scan=
    | |       +-JoinScan
    | |         +-column_list=[E.$col1#8, F.$col1#9]
    | |         +-left_scan=
    | |         | +-WithRefScan(column_list=[E.$col1#8], with_query_name="E")
    | |         +-right_scan=
    | |           +-WithRefScan(column_list=[F.$col1#9], with_query_name="F")
    | +-WithEntry
    |   +-with_query_name="A"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[B.$col1#10, B.$col1#11, C.$col1#12, C.$col1#13, D.$col1#14, D.$col1#15]
    |       +-input_scan=
    |         +-JoinScan
    |           +-column_list=[B.$col1#10, B.$col1#11, C.$col1#12, C.$col1#13, D.$col1#14, D.$col1#15]
    |           +-left_scan=
    |           | +-JoinScan
    |           |   +-column_list=[B.$col1#10, B.$col1#11, C.$col1#12, C.$col1#13]
    |           |   +-left_scan=
    |           |   | +-WithRefScan(column_list=B.[$col1#10, $col1#11], with_query_name="B")
    |           |   +-right_scan=
    |           |     +-WithRefScan(column_list=C.[$col1#12, $col1#13], with_query_name="C")
    |           +-right_scan=
    |             +-WithRefScan(column_list=D.[$col1#14, $col1#15], with_query_name="D")
    +-query=
    | +-ProjectScan
    |   +-column_list=A.[$col1#16, $col1#17, $col1#18, $col1#19, $col1#20, $col1#21]
    |   +-input_scan=
    |     +-WithRefScan(column_list=A.[$col1#16, $col1#17, $col1#18, $col1#19, $col1#20, $col1#21], with_query_name="A")
    +-recursive=TRUE
==

# Complex dependency graph with cycle
WITH RECURSIVE
  A AS (SELECT * FROM B, C, D),
  B AS (SELECT * FROM E, F),
  C AS (SELECT * FROM E, F),
  D AS (SELECT * FROM E, F),
  E AS (SELECT * FROM F, G),
  F AS (SELECT * FROM E, G),
  G AS (SELECT 1)
SELECT * FROM A;
--
ERROR: Unsupported WITH entry dependency cycle: F => E => F [at 1:1]
WITH RECURSIVE
^
==

# RECURSIVE WITH with duplicate alias names
WITH RECURSIVE
  A AS (SELECT 1 FROM A),
  A AS (SELECT 2 FROM A)
SELECT * FROM A;
--
ERROR: Duplicate alias A for WITH subquery [at 3:3]
  A AS (SELECT 2 FROM A)
  ^
==

# RECURSIVE WITH with alias names differing only by case
WITH RECURSIVE
  A AS (SELECT 1 FROM a),
  a AS (SELECT 2 FROM A)
SELECT * FROM A;
--
ERROR: Duplicate alias a for WITH subquery [at 3:3]
  a AS (SELECT 2 FROM A)
  ^
==

# ERROR: Recursive query not a UNION
WITH RECURSIVE t AS (SELECT * FROM t)
SELECT * FROM t;
--

ERROR: Recursive query does not have the form <non-recursive-term> UNION [ALL|DISTINCT] <recursive-term> [at 1:22]
WITH RECURSIVE t AS (SELECT * FROM t)
                     ^
==

# ERROR: Recursive query a set operation, but not a UNION
WITH RECURSIVE t AS (SELECT 1 INTERSECT ALL SELECT * FROM t)
SELECT * FROM t;
--
ERROR: Recursive query does not have the form <non-recursive-term> UNION [ALL|DISTINCT] <recursive-term> [at 1:22]
WITH RECURSIVE t AS (SELECT 1 INTERSECT ALL SELECT * FROM t)
                     ^
==

# Recursive query is a UNION
WITH RECURSIVE t AS (SELECT 1 UNION {{ALL|DISTINCT}} SELECT * FROM t)
SELECT * FROM t;
--
ALTERNATION GROUP: ALL
--
QueryStmt
+-output_column_list=
| +-t.$col1#4 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=[t.$col1#4]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.$col1#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.$col1#1]
    |       |   |   +-expr_list=
    |       |   |   | +-$col1#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.$col1#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t.$col1#3]
    |           |   +-input_scan=
    |           |     +-RecursiveRefScan(column_list=[t.$col1#3])
    |           +-output_column_list=[t.$col1#3]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.$col1#4]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.$col1#4], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: DISTINCT
--
QueryStmt
+-output_column_list=
| +-t.$col1#4 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=[t.$col1#4]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_distinct.$col1#2]
    |       +-op_type=UNION_DISTINCT
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_distinct1.$col1#1]
    |       |   |   +-expr_list=
    |       |   |   | +-$col1#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_distinct1.$col1#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t.$col1#3]
    |           |   +-input_scan=
    |           |     +-RecursiveRefScan(column_list=[t.$col1#3])
    |           +-output_column_list=[t.$col1#3]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.$col1#4]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.$col1#4], with_query_name="t")
    +-recursive=TRUE
==

# Recursive query is a UNION wrapped by extra parentheses
WITH RECURSIVE t AS ((SELECT 1 UNION {{ALL|DISTINCT}} SELECT * FROM t))
SELECT * FROM t;
--
ALTERNATION GROUP: ALL
--
QueryStmt
+-output_column_list=
| +-t.$col1#4 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=[t.$col1#4]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.$col1#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.$col1#1]
    |       |   |   +-expr_list=
    |       |   |   | +-$col1#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.$col1#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t.$col1#3]
    |           |   +-input_scan=
    |           |     +-RecursiveRefScan(column_list=[t.$col1#3])
    |           +-output_column_list=[t.$col1#3]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.$col1#4]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.$col1#4], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: DISTINCT
--
QueryStmt
+-output_column_list=
| +-t.$col1#4 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=[t.$col1#4]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_distinct.$col1#2]
    |       +-op_type=UNION_DISTINCT
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_distinct1.$col1#1]
    |       |   |   +-expr_list=
    |       |   |   | +-$col1#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_distinct1.$col1#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t.$col1#3]
    |           |   +-input_scan=
    |           |     +-RecursiveRefScan(column_list=[t.$col1#3])
    |           +-output_column_list=[t.$col1#3]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.$col1#4]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.$col1#4], with_query_name="t")
    +-recursive=TRUE
==

# ERROR: Recursive reference in non-recursive UNION term
WITH RECURSIVE t AS (
 SELECT * FROM t
 UNION ALL
 SELECT 1
) SELECT * FROM t;
--
ERROR: Recursive reference is not allowed in non-recursive UNION term [at 2:16]
 SELECT * FROM t
               ^
==

# (OK) Recursive query where non-recursive term is inner UNION.
WITH RECURSIVE t AS (
SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT * FROM t
) SELECT * FROM t;
--
QueryStmt
+-output_column_list=
| +-t.$col1#7 AS `$col1` [INT64]
+-query=
  +-WithScan
    +-column_list=[t.$col1#7]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.$col1#4]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-SetOperationScan
    |       |   |   +-column_list=[$union_all.$col1#6]
    |       |   |   +-op_type=UNION_ALL
    |       |   |   +-input_item_list=
    |       |   |     +-SetOperationItem
    |       |   |     | +-scan=
    |       |   |     | | +-ProjectScan
    |       |   |     | |   +-column_list=[$union_all1.$col1#1]
    |       |   |     | |   +-expr_list=
    |       |   |     | |   | +-$col1#1 := Literal(type=INT64, value=1)
    |       |   |     | |   +-input_scan=
    |       |   |     | |     +-SingleRowScan
    |       |   |     | +-output_column_list=[$union_all1.$col1#1]
    |       |   |     +-SetOperationItem
    |       |   |     | +-scan=
    |       |   |     | | +-ProjectScan
    |       |   |     | |   +-column_list=[$union_all2.$col1#2]
    |       |   |     | |   +-expr_list=
    |       |   |     | |   | +-$col1#2 := Literal(type=INT64, value=2)
    |       |   |     | |   +-input_scan=
    |       |   |     | |     +-SingleRowScan
    |       |   |     | +-output_column_list=[$union_all2.$col1#2]
    |       |   |     +-SetOperationItem
    |       |   |       +-scan=
    |       |   |       | +-ProjectScan
    |       |   |       |   +-column_list=[$union_all3.$col1#3]
    |       |   |       |   +-expr_list=
    |       |   |       |   | +-$col1#3 := Literal(type=INT64, value=3)
    |       |   |       |   +-input_scan=
    |       |   |       |     +-SingleRowScan
    |       |   |       +-output_column_list=[$union_all3.$col1#3]
    |       |   +-output_column_list=[$union_all.$col1#6]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t.$col1#5]
    |           |   +-input_scan=
    |           |     +-RecursiveRefScan(column_list=[t.$col1#5])
    |           +-output_column_list=[t.$col1#5]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.$col1#7]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.$col1#7], with_query_name="t")
    +-recursive=TRUE
==

# (OK) Recursive query with type coercion needed within non-recursive term
WITH RECURSIVE t AS (
SELECT 1 UNION ALL SELECT 2.5 UNION ALL SELECT CAST(3.14 AS NUMERIC)
  UNION ALL SELECT * FROM t
) SELECT * FROM t;
--
QueryStmt
+-output_column_list=
| +-t.$col1#9 AS `$col1` [NUMERIC]
+-query=
  +-WithScan
    +-column_list=[t.$col1#9]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.$col1#4]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-SetOperationScan
    |       |   |   +-column_list=[$union_all.$col1#8]
    |       |   |   +-op_type=UNION_ALL
    |       |   |   +-input_item_list=
    |       |   |     +-SetOperationItem
    |       |   |     | +-scan=
    |       |   |     | | +-ProjectScan
    |       |   |     | |   +-column_list=[$union_all1_cast.$col1#5]
    |       |   |     | |   +-expr_list=
    |       |   |     | |   | +-$col1#5 := Literal(type=NUMERIC, value=1)
    |       |   |     | |   +-input_scan=
    |       |   |     | |     +-ProjectScan
    |       |   |     | |       +-column_list=[$union_all1.$col1#1]
    |       |   |     | |       +-expr_list=
    |       |   |     | |       | +-$col1#1 := Literal(type=INT64, value=1)
    |       |   |     | |       +-input_scan=
    |       |   |     | |         +-SingleRowScan
    |       |   |     | +-output_column_list=[$union_all1_cast.$col1#5]
    |       |   |     +-SetOperationItem
    |       |   |     | +-scan=
    |       |   |     | | +-ProjectScan
    |       |   |     | |   +-column_list=[$union_all2_cast.$col1#6]
    |       |   |     | |   +-expr_list=
    |       |   |     | |   | +-$col1#6 := Literal(type=NUMERIC, value=2.5)
    |       |   |     | |   +-input_scan=
    |       |   |     | |     +-ProjectScan
    |       |   |     | |       +-column_list=[$union_all2.$col1#2]
    |       |   |     | |       +-expr_list=
    |       |   |     | |       | +-$col1#2 := Literal(type=DOUBLE, value=2.5, float_literal_id=1)
    |       |   |     | |       +-input_scan=
    |       |   |     | |         +-SingleRowScan
    |       |   |     | +-output_column_list=[$union_all2_cast.$col1#6]
    |       |   |     +-SetOperationItem
    |       |   |       +-scan=
    |       |   |       | +-ProjectScan
    |       |   |       |   +-column_list=[$union_all3.$col1#3]
    |       |   |       |   +-expr_list=
    |       |   |       |   | +-$col1#3 := Literal(type=NUMERIC, value=3.14, has_explicit_type=TRUE)
    |       |   |       |   +-input_scan=
    |       |   |       |     +-SingleRowScan
    |       |   |       +-output_column_list=[$union_all3.$col1#3]
    |       |   +-output_column_list=[$union_all.$col1#8]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t.$col1#7]
    |           |   +-input_scan=
    |           |     +-RecursiveRefScan(column_list=[t.$col1#7])
    |           +-output_column_list=[t.$col1#7]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.$col1#9]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.$col1#9], with_query_name="t")
    +-recursive=TRUE
==

# (OK) Recursive query with type coercion needed within recursive term
WITH RECURSIVE t AS (
SELECT 2.5
  UNION ALL SELECT 5 FROM t
) SELECT * FROM t;
--
QueryStmt
+-output_column_list=
| +-t.$col1#6 AS `$col1` [DOUBLE]
+-query=
  +-WithScan
    +-column_list=[t.$col1#6]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.$col1#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.$col1#1]
    |       |   |   +-expr_list=
    |       |   |   | +-$col1#1 := Literal(type=DOUBLE, value=2.5, float_literal_id=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.$col1#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all1_cast.$col1#5]
    |           |   +-expr_list=
    |           |   | +-$col1#5 := Literal(type=DOUBLE, value=5)
    |           |   +-input_scan=
    |           |     +-ProjectScan
    |           |       +-column_list=[$union_all2.$col1#4]
    |           |       +-expr_list=
    |           |       | +-$col1#4 := Literal(type=INT64, value=5)
    |           |       +-input_scan=
    |           |         +-RecursiveRefScan(column_list=[t.$col1#3])
    |           +-output_column_list=[$union_all1_cast.$col1#5]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.$col1#6]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.$col1#6], with_query_name="t")
    +-recursive=TRUE
==

# (ERROR) Failure to coerce within non-recursive term
WITH RECURSIVE t AS (
  SELECT 1 UNION ALL SELECT 'test' UNION ALL SELECT CAST(3.14 AS NUMERIC)
    UNION ALL SELECT * FROM t
) SELECT * FROM t;
--
ERROR: Column 1 in UNION ALL has incompatible types: INT64, STRING, NUMERIC [at 2:22]
  SELECT 1 UNION ALL SELECT 'test' UNION ALL SELECT CAST(3.14 AS NUMERIC)
                     ^
==

# (ERROR) Failure to coerce within recursive term
WITH RECURSIVE t AS (
  SELECT 2.5
    UNION ALL SELECT 'test' FROM t
) SELECT * FROM t;
--
ERROR: Cannot coerce column 1 of recursive term (STRING) to column type in non-recursive term ( DOUBLE) [at 3:15]
    UNION ALL SELECT 'test' FROM t
              ^
==

# (ERROR) Mismatched column numbers within non-recursive term
WITH RECURSIVE t AS (
  SELECT 1, 2 UNION ALL SELECT 3, 4, 5
    UNION ALL SELECT * FROM t
) SELECT * FROM t;
--
ERROR: Queries in UNION ALL have mismatched column count; query 1 has 2 columns, query 2 has 3 columns [at 2:25]
  SELECT 1, 2 UNION ALL SELECT 3, 4, 5
                        ^
==

# (ERROR) Mismatched column numbers between non-recursive term and recursive
# term
WITH RECURSIVE t AS (
  SELECT 1, 2 UNION ALL SELECT 3, 4, 5 FROM t
) SELECT * FROM t;
--
ERROR: Queries in UNION ALL have mismatched column count; query 1 has 2 columns, query 2 has 3 columns [at 2:25]
  SELECT 1, 2 UNION ALL SELECT 3, 4, 5 FROM t
                        ^
==

# Non-groupable column types are ok with UNION ALL, but not UNION DISTINCT.
# Note that FEATURE_V_1_2_GROUP_BY_STRUCT is intentionally *not* set.
WITH RECURSIVE t AS (
  SELECT STRUCT('a', 'b') UNION {{ALL|DISTINCT}} SELECT * FROM t
) SELECT * FROM t;
--
ALTERNATION GROUP: ALL
--
QueryStmt
+-output_column_list=
| +-t.$col1#4 AS `$col1` [STRUCT<STRING, STRING>]
+-query=
  +-WithScan
    +-column_list=[t.$col1#4]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.$col1#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.$col1#1]
    |       |   |   +-expr_list=
    |       |   |   | +-$col1#1 := Literal(type=STRUCT<STRING, STRING>, value={"a", "b"})
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.$col1#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t.$col1#3]
    |           |   +-input_scan=
    |           |     +-RecursiveRefScan(column_list=[t.$col1#3])
    |           +-output_column_list=[t.$col1#3]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.$col1#4]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.$col1#4], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: DISTINCT
--
ERROR: Column 1 in UNION DISTINCT has type that does not support set operation comparisons: STRUCT [at 2:42]
  SELECT STRUCT('a', 'b') UNION DISTINCT SELECT * FROM t
                                         ^
==

# ERROR: Columns must be comparable for UNION DISTINCT, but proto comparison is
# not supported.
WITH RECURSIVE
  t AS (
    SELECT 5 AS five, NEW zetasql_test__.KitchenSinkPB(
      1 AS int64_key_1,
      2 AS int64_key_2) AS kitchen_sink_proto
    UNION DISTINCT
    SELECT 5 AS five, NEW zetasql_test__.KitchenSinkPB(
      MOD(kitchen_sink_proto.int64_key_1 + 1, 5) AS int64_key_1,
      2 AS int64_key_2) AS kitchen_sink_proto
      FROM t
) SELECT * FROM t;
--
ERROR: Column 2 in UNION DISTINCT has type that does not support set operation comparisons: PROTO [at 7:5]
    SELECT 5 AS five, NEW zetasql_test__.KitchenSinkPB(
    ^
==

# ERROR: Columns must be comparable for UNION DISTINCT, but geography comparison
# is not supported.
WITH RECURSIVE
  t AS (
    SELECT * FROM GeographyTable
    UNION DISTINCT
    SELECT * FROM GeographyTable INNER JOIN t USING (key)
) SELECT * FROM t;
--
ERROR: Column 3 in UNION DISTINCT has type that does not support set operation comparisons: GEOGRAPHY [at 5:5]
    SELECT * FROM GeographyTable INNER JOIN t USING (key)
    ^
==

# Recursive UNION with hint
WITH RECURSIVE t1 AS (
  SELECT 1 AS n UNION @{key = 3} ALL SELECT n + 1 FROM t1
) SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.n#5 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.n#5]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-hint_list=
    |       | +-key := Literal(type=INT64, value=3)
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#4]
    |           |   +-expr_list=
    |           |   | +-$col1#4 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=t1.n#3)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-RecursiveRefScan(column_list=[t1.n#3])
    |           +-output_column_list=[$union_all2.$col1#4]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.n#5]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.n#5], with_query_name="t1")
    +-recursive=TRUE
==

# Recursive UNION of three items with hints (left only)
WITH RECURSIVE t1 AS (
  SELECT 1 AS n UNION @{key=1} ALL SELECT 2 AS n UNION ALL
  SELECT n + 1 FROM t1
) SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.n#7 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.n#7]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-hint_list=
    |       | +-key := Literal(type=INT64, value=1)
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-SetOperationScan
    |       |   |   +-column_list=[$union_all.n#6]
    |       |   |   +-op_type=UNION_ALL
    |       |   |   +-input_item_list=
    |       |   |     +-SetOperationItem
    |       |   |     | +-scan=
    |       |   |     | | +-ProjectScan
    |       |   |     | |   +-column_list=[$union_all1.n#1]
    |       |   |     | |   +-expr_list=
    |       |   |     | |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |     | |   +-input_scan=
    |       |   |     | |     +-SingleRowScan
    |       |   |     | +-output_column_list=[$union_all1.n#1]
    |       |   |     +-SetOperationItem
    |       |   |       +-scan=
    |       |   |       | +-ProjectScan
    |       |   |       |   +-column_list=[$union_all2.n#2]
    |       |   |       |   +-expr_list=
    |       |   |       |   | +-n#2 := Literal(type=INT64, value=2)
    |       |   |       |   +-input_scan=
    |       |   |       |     +-SingleRowScan
    |       |   |       +-output_column_list=[$union_all2.n#2]
    |       |   +-output_column_list=[$union_all.n#6]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all3.$col1#5]
    |           |   +-expr_list=
    |           |   | +-$col1#5 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=t1.n#4)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-RecursiveRefScan(column_list=[t1.n#4])
    |           +-output_column_list=[$union_all3.$col1#5]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.n#7]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.n#7], with_query_name="t1")
    +-recursive=TRUE
==

# Recursive UNION of three items with hints (right only)
WITH RECURSIVE t1 AS (
  SELECT 1 AS n UNION ALL SELECT 2 AS n UNION @{key=1} ALL
  SELECT n + 1 FROM t1
) SELECT * FROM t1;
--
ERROR: Syntax error: Hints on set operations must appear on the first  operation. [at 2:47]
  SELECT 1 AS n UNION ALL SELECT 2 AS n UNION @{key=1} ALL
                                              ^
==

# Recursive UNION of three items with hints (left and right)
WITH RECURSIVE t1 AS (
  SELECT 1 AS n UNION @{key=1} ALL SELECT 2 AS n UNION @{key=1} ALL
  SELECT n + 1 FROM t1
) SELECT * FROM t1;
--
ERROR: Syntax error: Hints on set operations must appear on the first  operation. [at 2:56]
  SELECT 1 AS n UNION @{key=1} ALL SELECT 2 AS n UNION @{key=1} ALL
                                                       ^
==

# Nested recursive definition, with a recursive query's recursive term.
# Ok because inner query never references outer query.
WITH RECURSIVE
  t1 AS (
    SELECT 1 AS n
    UNION ALL (
      WITH RECURSIVE
        t2 AS (SELECT 1 AS n UNION ALL SELECT n + 1 FROM t2 WHERE n < 15)
      SELECT * FROM t1 INNER JOIN t2 USING (n)
    )
) SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.n#9 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.n#9]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-WithScan
    |           |   +-column_list=[t1.n#7]
    |           |   +-with_entry_list=
    |           |   | +-WithEntry
    |           |   |   +-with_query_name="t2"
    |           |   |   +-with_subquery=
    |           |   |     +-RecursiveScan
    |           |   |       +-column_list=[$union_all.n#4]
    |           |   |       +-op_type=UNION_ALL
    |           |   |       +-non_recursive_term=
    |           |   |       | +-SetOperationItem
    |           |   |       |   +-scan=
    |           |   |       |   | +-ProjectScan
    |           |   |       |   |   +-column_list=[$union_all1.n#3]
    |           |   |       |   |   +-expr_list=
    |           |   |       |   |   | +-n#3 := Literal(type=INT64, value=1)
    |           |   |       |   |   +-input_scan=
    |           |   |       |   |     +-SingleRowScan
    |           |   |       |   +-output_column_list=[$union_all1.n#3]
    |           |   |       +-recursive_term=
    |           |   |         +-SetOperationItem
    |           |   |           +-scan=
    |           |   |           | +-ProjectScan
    |           |   |           |   +-column_list=[$union_all2.$col1#6]
    |           |   |           |   +-expr_list=
    |           |   |           |   | +-$col1#6 :=
    |           |   |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |           |   |     +-ColumnRef(type=INT64, column=t2.n#5)
    |           |   |           |   |     +-Literal(type=INT64, value=1)
    |           |   |           |   +-input_scan=
    |           |   |           |     +-FilterScan
    |           |   |           |       +-column_list=[t2.n#5]
    |           |   |           |       +-input_scan=
    |           |   |           |       | +-RecursiveRefScan(column_list=[t2.n#5])
    |           |   |           |       +-filter_expr=
    |           |   |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |   |           |           +-ColumnRef(type=INT64, column=t2.n#5)
    |           |   |           |           +-Literal(type=INT64, value=15)
    |           |   |           +-output_column_list=[$union_all2.$col1#6]
    |           |   +-query=
    |           |   | +-ProjectScan
    |           |   |   +-column_list=[t1.n#7]
    |           |   |   +-input_scan=
    |           |   |     +-JoinScan
    |           |   |       +-column_list=[t1.n#7, t2.n#8]
    |           |   |       +-left_scan=
    |           |   |       | +-RecursiveRefScan(column_list=[t1.n#7])
    |           |   |       +-right_scan=
    |           |   |       | +-WithRefScan(column_list=[t2.n#8], with_query_name="t2")
    |           |   |       +-join_expr=
    |           |   |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |           |   |           +-ColumnRef(type=INT64, column=t1.n#7)
    |           |   |           +-ColumnRef(type=INT64, column=t2.n#8)
    |           |   +-recursive=TRUE
    |           +-output_column_list=[t1.n#7]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.n#9]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.n#9], with_query_name="t1")
    +-recursive=TRUE
==

# ERROR: Recursive reference to outer query t1 from inner WITH entry.
# Even if the inner WITH entry is non-recursive, this is still an error.
WITH RECURSIVE
  t1 AS (
    SELECT 1 AS n
    UNION ALL (
      WITH {{|RECURSIVE}} t2 AS (SELECT * FROM t1)
      SELECT * FROM t1 INNER JOIN t2 USING (n)
    )
) SELECT * FROM t1;
--
ALTERNATION GROUP: <empty>
--
ERROR: table 't1' may not be recursively referenced from inside an inner WITH entry [at 5:34]
      WITH  t2 AS (SELECT * FROM t1)
                                 ^
--
ALTERNATION GROUP: RECURSIVE
--
ERROR: table 't1' may not be recursively referenced from inside an inner WITH entry [at 5:43]
      WITH RECURSIVE t2 AS (SELECT * FROM t1)
                                          ^
==

# ERROR: (Same as previous case, but inner table is now actually recursive).
WITH RECURSIVE
  t1 AS (
    SELECT 1 AS n
    UNION ALL (
      WITH RECURSIVE t2 AS (
        SELECT 1 AS n UNION ALL SELECT * FROM t1 INNER JOIN t2
      USING (n)) SELECT * FROM t2)
) SELECT * FROM t1;
--
ERROR: table 't1' may not be recursively referenced from inside an inner WITH entry [at 6:47]
        SELECT 1 AS n UNION ALL SELECT * FROM t1 INNER JOIN t2
                                              ^
==

# Recursive reference from inner WITH RECURSIVE clause is ok, since it's within
# the body of the WITH, rather than the definition of a WITH entry.
WITH RECURSIVE
  t1 AS (
    SELECT 1 AS n
    UNION ALL (
      WITH RECURSIVE
        t2 AS (SELECT 1 AS n UNION ALL SELECT * FROM t2)
      SELECT * FROM t1 INNER JOIN t2 USING (n)
    )
) SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.n#8 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.n#8]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-WithScan
    |           |   +-column_list=[t1.n#6]
    |           |   +-with_entry_list=
    |           |   | +-WithEntry
    |           |   |   +-with_query_name="t2"
    |           |   |   +-with_subquery=
    |           |   |     +-RecursiveScan
    |           |   |       +-column_list=[$union_all.n#4]
    |           |   |       +-op_type=UNION_ALL
    |           |   |       +-non_recursive_term=
    |           |   |       | +-SetOperationItem
    |           |   |       |   +-scan=
    |           |   |       |   | +-ProjectScan
    |           |   |       |   |   +-column_list=[$union_all1.n#3]
    |           |   |       |   |   +-expr_list=
    |           |   |       |   |   | +-n#3 := Literal(type=INT64, value=1)
    |           |   |       |   |   +-input_scan=
    |           |   |       |   |     +-SingleRowScan
    |           |   |       |   +-output_column_list=[$union_all1.n#3]
    |           |   |       +-recursive_term=
    |           |   |         +-SetOperationItem
    |           |   |           +-scan=
    |           |   |           | +-ProjectScan
    |           |   |           |   +-column_list=[t2.n#5]
    |           |   |           |   +-input_scan=
    |           |   |           |     +-RecursiveRefScan(column_list=[t2.n#5])
    |           |   |           +-output_column_list=[t2.n#5]
    |           |   +-query=
    |           |   | +-ProjectScan
    |           |   |   +-column_list=[t1.n#6]
    |           |   |   +-input_scan=
    |           |   |     +-JoinScan
    |           |   |       +-column_list=[t1.n#6, t2.n#7]
    |           |   |       +-left_scan=
    |           |   |       | +-RecursiveRefScan(column_list=[t1.n#6])
    |           |   |       +-right_scan=
    |           |   |       | +-WithRefScan(column_list=[t2.n#7], with_query_name="t2")
    |           |   |       +-join_expr=
    |           |   |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |           |   |           +-ColumnRef(type=INT64, column=t1.n#6)
    |           |   |           +-ColumnRef(type=INT64, column=t2.n#7)
    |           |   +-recursive=TRUE
    |           +-output_column_list=[t1.n#6]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.n#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.n#8], with_query_name="t1")
    +-recursive=TRUE
==

# ERROR: Triply nested recursive tables. Error is caused by recursive part of t3
# referencing t1.
WITH RECURSIVE
  t1 AS (
    SELECT 1 AS n
    UNION ALL (
      WITH RECURSIVE t2 AS (
        WITH RECURSIVE t3 AS (SELECT 1 AS n UNION ALL SELECT * FROM
          t1 INNER JOIN t3 USING (n))
        SELECT * FROM t3)
    SELECT * FROM t2)
) SELECT * FROM t1;
--
ERROR: table 't1' may not be recursively referenced from inside an inner WITH entry [at 7:11]
          t1 INNER JOIN t3 USING (n))
          ^
==

# nested recursive table inside FROM clause of recursive term in outer query.
WITH RECURSIVE
  t1 AS (
    SELECT 1 AS n
    UNION ALL (
      SELECT t1.n
        FROM t1
        CROSS JOIN (
          WITH RECURSIVE t2 AS (SELECT 1 AS n UNION ALL SELECT * FROM t2)
          SELECT * FROM t2
        )
    )
) SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.n#8 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.n#8]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t1.n#3]
    |           |   +-input_scan=
    |           |     +-JoinScan
    |           |       +-column_list=[t1.n#3, t2.n#7]
    |           |       +-left_scan=
    |           |       | +-RecursiveRefScan(column_list=[t1.n#3])
    |           |       +-right_scan=
    |           |         +-WithScan
    |           |           +-column_list=[t2.n#7]
    |           |           +-with_entry_list=
    |           |           | +-WithEntry
    |           |           |   +-with_query_name="t2"
    |           |           |   +-with_subquery=
    |           |           |     +-RecursiveScan
    |           |           |       +-column_list=[$union_all.n#5]
    |           |           |       +-op_type=UNION_ALL
    |           |           |       +-non_recursive_term=
    |           |           |       | +-SetOperationItem
    |           |           |       |   +-scan=
    |           |           |       |   | +-ProjectScan
    |           |           |       |   |   +-column_list=[$union_all1.n#4]
    |           |           |       |   |   +-expr_list=
    |           |           |       |   |   | +-n#4 := Literal(type=INT64, value=1)
    |           |           |       |   |   +-input_scan=
    |           |           |       |   |     +-SingleRowScan
    |           |           |       |   +-output_column_list=[$union_all1.n#4]
    |           |           |       +-recursive_term=
    |           |           |         +-SetOperationItem
    |           |           |           +-scan=
    |           |           |           | +-ProjectScan
    |           |           |           |   +-column_list=[t2.n#6]
    |           |           |           |   +-input_scan=
    |           |           |           |     +-RecursiveRefScan(column_list=[t2.n#6])
    |           |           |           +-output_column_list=[t2.n#6]
    |           |           +-query=
    |           |           | +-ProjectScan
    |           |           |   +-column_list=[t2.n#7]
    |           |           |   +-input_scan=
    |           |           |     +-WithRefScan(column_list=[t2.n#7], with_query_name="t2")
    |           |           +-recursive=TRUE
    |           +-output_column_list=[t1.n#3]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.n#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.n#8], with_query_name="t1")
    +-recursive=TRUE
==

# Recursive reference in WITH body of inner WITH RECURSIVE
WITH RECURSIVE
  t1 AS (
    SELECT 1 AS n
    UNION ALL (
      WITH RECURSIVE t2 AS (SELECT 1 AS n UNION ALL SELECT n + 1 FROM t2)
      SELECT t1.n FROM t1 CROSS JOIN t2
    )
) SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.n#9 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.n#9]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-WithScan
    |           |   +-column_list=[t1.n#7]
    |           |   +-with_entry_list=
    |           |   | +-WithEntry
    |           |   |   +-with_query_name="t2"
    |           |   |   +-with_subquery=
    |           |   |     +-RecursiveScan
    |           |   |       +-column_list=[$union_all.n#4]
    |           |   |       +-op_type=UNION_ALL
    |           |   |       +-non_recursive_term=
    |           |   |       | +-SetOperationItem
    |           |   |       |   +-scan=
    |           |   |       |   | +-ProjectScan
    |           |   |       |   |   +-column_list=[$union_all1.n#3]
    |           |   |       |   |   +-expr_list=
    |           |   |       |   |   | +-n#3 := Literal(type=INT64, value=1)
    |           |   |       |   |   +-input_scan=
    |           |   |       |   |     +-SingleRowScan
    |           |   |       |   +-output_column_list=[$union_all1.n#3]
    |           |   |       +-recursive_term=
    |           |   |         +-SetOperationItem
    |           |   |           +-scan=
    |           |   |           | +-ProjectScan
    |           |   |           |   +-column_list=[$union_all2.$col1#6]
    |           |   |           |   +-expr_list=
    |           |   |           |   | +-$col1#6 :=
    |           |   |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |           |   |     +-ColumnRef(type=INT64, column=t2.n#5)
    |           |   |           |   |     +-Literal(type=INT64, value=1)
    |           |   |           |   +-input_scan=
    |           |   |           |     +-RecursiveRefScan(column_list=[t2.n#5])
    |           |   |           +-output_column_list=[$union_all2.$col1#6]
    |           |   +-query=
    |           |   | +-ProjectScan
    |           |   |   +-column_list=[t1.n#7]
    |           |   |   +-input_scan=
    |           |   |     +-JoinScan
    |           |   |       +-column_list=[t1.n#7, t2.n#8]
    |           |   |       +-left_scan=
    |           |   |       | +-RecursiveRefScan(column_list=[t1.n#7])
    |           |   |       +-right_scan=
    |           |   |         +-WithRefScan(column_list=[t2.n#8], with_query_name="t2")
    |           |   +-recursive=TRUE
    |           +-output_column_list=[t1.n#7]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.n#9]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.n#9], with_query_name="t1")
    +-recursive=TRUE
==

# Complex tree of nested WITH RECURSIVE
WITH RECURSIVE
  t1 AS (
    SELECT 1 AS n
    UNION ALL (
      WITH RECURSIVE
        t2 AS (SELECT 1 AS n UNION ALL SELECT n + 1 FROM t2),
        t3 AS (SELECT 1 AS n UNION ALL SELECT t3.n + 1 FROM t2 CROSS JOIN t3),
        t4 AS (
          WITH RECURSIVE
            t5 AS (SELECT 1 AS n UNION ALL SELECT t5.n + 1 FROM t5 CROSS JOIN t3)
          SELECT n FROM t5)
      SELECT * FROM t4
    )
) SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.n#19 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.n#19]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-SetOperationScan
    |       +-column_list=[$union_all.n#18]
    |       +-op_type=UNION_ALL
    |       +-input_item_list=
    |         +-SetOperationItem
    |         | +-scan=
    |         | | +-ProjectScan
    |         | |   +-column_list=[$union_all1.n#1]
    |         | |   +-expr_list=
    |         | |   | +-n#1 := Literal(type=INT64, value=1)
    |         | |   +-input_scan=
    |         | |     +-SingleRowScan
    |         | +-output_column_list=[$union_all1.n#1]
    |         +-SetOperationItem
    |           +-scan=
    |           | +-WithScan
    |           |   +-column_list=[t4.n#17]
    |           |   +-with_entry_list=
    |           |   | +-WithEntry
    |           |   | | +-with_query_name="t2"
    |           |   | | +-with_subquery=
    |           |   | |   +-RecursiveScan
    |           |   | |     +-column_list=[$union_all.n#3]
    |           |   | |     +-op_type=UNION_ALL
    |           |   | |     +-non_recursive_term=
    |           |   | |     | +-SetOperationItem
    |           |   | |     |   +-scan=
    |           |   | |     |   | +-ProjectScan
    |           |   | |     |   |   +-column_list=[$union_all1.n#2]
    |           |   | |     |   |   +-expr_list=
    |           |   | |     |   |   | +-n#2 := Literal(type=INT64, value=1)
    |           |   | |     |   |   +-input_scan=
    |           |   | |     |   |     +-SingleRowScan
    |           |   | |     |   +-output_column_list=[$union_all1.n#2]
    |           |   | |     +-recursive_term=
    |           |   | |       +-SetOperationItem
    |           |   | |         +-scan=
    |           |   | |         | +-ProjectScan
    |           |   | |         |   +-column_list=[$union_all2.$col1#5]
    |           |   | |         |   +-expr_list=
    |           |   | |         |   | +-$col1#5 :=
    |           |   | |         |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   | |         |   |     +-ColumnRef(type=INT64, column=t2.n#4)
    |           |   | |         |   |     +-Literal(type=INT64, value=1)
    |           |   | |         |   +-input_scan=
    |           |   | |         |     +-RecursiveRefScan(column_list=[t2.n#4])
    |           |   | |         +-output_column_list=[$union_all2.$col1#5]
    |           |   | +-WithEntry
    |           |   | | +-with_query_name="t3"
    |           |   | | +-with_subquery=
    |           |   | |   +-RecursiveScan
    |           |   | |     +-column_list=[$union_all.n#7]
    |           |   | |     +-op_type=UNION_ALL
    |           |   | |     +-non_recursive_term=
    |           |   | |     | +-SetOperationItem
    |           |   | |     |   +-scan=
    |           |   | |     |   | +-ProjectScan
    |           |   | |     |   |   +-column_list=[$union_all1.n#6]
    |           |   | |     |   |   +-expr_list=
    |           |   | |     |   |   | +-n#6 := Literal(type=INT64, value=1)
    |           |   | |     |   |   +-input_scan=
    |           |   | |     |   |     +-SingleRowScan
    |           |   | |     |   +-output_column_list=[$union_all1.n#6]
    |           |   | |     +-recursive_term=
    |           |   | |       +-SetOperationItem
    |           |   | |         +-scan=
    |           |   | |         | +-ProjectScan
    |           |   | |         |   +-column_list=[$union_all2.$col1#10]
    |           |   | |         |   +-expr_list=
    |           |   | |         |   | +-$col1#10 :=
    |           |   | |         |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   | |         |   |     +-ColumnRef(type=INT64, column=t3.n#9)
    |           |   | |         |   |     +-Literal(type=INT64, value=1)
    |           |   | |         |   +-input_scan=
    |           |   | |         |     +-JoinScan
    |           |   | |         |       +-column_list=[t2.n#8, t3.n#9]
    |           |   | |         |       +-left_scan=
    |           |   | |         |       | +-WithRefScan(column_list=[t2.n#8], with_query_name="t2")
    |           |   | |         |       +-right_scan=
    |           |   | |         |         +-RecursiveRefScan(column_list=[t3.n#9])
    |           |   | |         +-output_column_list=[$union_all2.$col1#10]
    |           |   | +-WithEntry
    |           |   |   +-with_query_name="t4"
    |           |   |   +-with_subquery=
    |           |   |     +-WithScan
    |           |   |       +-column_list=[t5.n#16]
    |           |   |       +-with_entry_list=
    |           |   |       | +-WithEntry
    |           |   |       |   +-with_query_name="t5"
    |           |   |       |   +-with_subquery=
    |           |   |       |     +-RecursiveScan
    |           |   |       |       +-column_list=[$union_all.n#12]
    |           |   |       |       +-op_type=UNION_ALL
    |           |   |       |       +-non_recursive_term=
    |           |   |       |       | +-SetOperationItem
    |           |   |       |       |   +-scan=
    |           |   |       |       |   | +-ProjectScan
    |           |   |       |       |   |   +-column_list=[$union_all1.n#11]
    |           |   |       |       |   |   +-expr_list=
    |           |   |       |       |   |   | +-n#11 := Literal(type=INT64, value=1)
    |           |   |       |       |   |   +-input_scan=
    |           |   |       |       |   |     +-SingleRowScan
    |           |   |       |       |   +-output_column_list=[$union_all1.n#11]
    |           |   |       |       +-recursive_term=
    |           |   |       |         +-SetOperationItem
    |           |   |       |           +-scan=
    |           |   |       |           | +-ProjectScan
    |           |   |       |           |   +-column_list=[$union_all2.$col1#15]
    |           |   |       |           |   +-expr_list=
    |           |   |       |           |   | +-$col1#15 :=
    |           |   |       |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |       |           |   |     +-ColumnRef(type=INT64, column=t5.n#13)
    |           |   |       |           |   |     +-Literal(type=INT64, value=1)
    |           |   |       |           |   +-input_scan=
    |           |   |       |           |     +-JoinScan
    |           |   |       |           |       +-column_list=[t5.n#13, t3.n#14]
    |           |   |       |           |       +-left_scan=
    |           |   |       |           |       | +-RecursiveRefScan(column_list=[t5.n#13])
    |           |   |       |           |       +-right_scan=
    |           |   |       |           |         +-WithRefScan(column_list=[t3.n#14], with_query_name="t3")
    |           |   |       |           +-output_column_list=[$union_all2.$col1#15]
    |           |   |       +-query=
    |           |   |       | +-ProjectScan
    |           |   |       |   +-column_list=[t5.n#16]
    |           |   |       |   +-input_scan=
    |           |   |       |     +-WithRefScan(column_list=[t5.n#16], with_query_name="t5")
    |           |   |       +-recursive=TRUE
    |           |   +-query=
    |           |   | +-ProjectScan
    |           |   |   +-column_list=[t4.n#17]
    |           |   |   +-input_scan=
    |           |   |     +-WithRefScan(column_list=[t4.n#17], with_query_name="t4")
    |           |   +-recursive=TRUE
    |           +-output_column_list=[t4.n#17]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.n#19]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.n#19], with_query_name="t1")
    +-recursive=TRUE
==

# Aggregate function used when scanning recursive reference
WITH RECURSIVE
  t AS (SELECT 1 AS n UNION ALL SELECT SUM(n) FROM t)
SELECT * FROM t;
--
ERROR: A subquery containing a recursive reference may not use DISTINCT, GROUP BY, or any aggregate function [at 2:52]
  t AS (SELECT 1 AS n UNION ALL SELECT SUM(n) FROM t)
                                                   ^
==

# GROUP BY used against recursive reference
WITH RECURSIVE
  t AS (SELECT 1 AS n UNION ALL SELECT n + 1 FROM t GROUP BY n)
SELECT * FROM t;
--
ERROR: A subquery containing a recursive reference may not use DISTINCT, GROUP BY, or any aggregate function [at 2:51]
  t AS (SELECT 1 AS n UNION ALL SELECT n + 1 FROM t GROUP BY n)
                                                  ^
==

# SELECT DISTINCT used against recursive reference
WITH RECURSIVE
  t AS (SELECT 1 AS n UNION ALL SELECT DISTINCT n + 1 FROM t)
SELECT * FROM t;
--
ERROR: A subquery containing a recursive reference may not use DISTINCT, GROUP BY, or any aggregate function [at 2:60]
  t AS (SELECT 1 AS n UNION ALL SELECT DISTINCT n + 1 FROM t)
                                                           ^
==

# Recursive reference used in expression subquery
WITH RECURSIVE
  t AS (SELECT 1 AS n UNION ALL SELECT (SELECT n FROM t))
SELECT * FROM t;
--
ERROR: A recursive reference from inside an expression subquery is not allowed [at 2:55]
  t AS (SELECT 1 AS n UNION ALL SELECT (SELECT n FROM t))
                                                      ^
==

# Recursive reference used in both expression subquery and aggregate function
WITH RECURSIVE
  t AS (SELECT 1 AS n UNION ALL SELECT COUNT(*) FROM t GROUP BY (SELECT n FROM t))
SELECT * FROM t;
--
ERROR: A subquery containing a recursive reference may not use DISTINCT, GROUP BY, or any aggregate function [at 2:54]
  t AS (SELECT 1 AS n UNION ALL SELECT COUNT(*) FROM t GROUP BY (SELECT n FRO...
                                                     ^
==

# ARRAY/EXIST subqueries which use recursive reference are not allowed
WITH RECURSIVE
  t AS (SELECT 1 AS n UNION ALL SELECT {{ARRAY|EXISTS}}(SELECT n FROM t))
SELECT * FROM t;
--
ALTERNATION GROUP: ARRAY
--
ERROR: A recursive reference from inside an expression subquery is not allowed [at 2:60]
  t AS (SELECT 1 AS n UNION ALL SELECT ARRAY(SELECT n FROM t))
                                                           ^
--
ALTERNATION GROUP: EXISTS
--
ERROR: A recursive reference from inside an expression subquery is not allowed [at 2:61]
  t AS (SELECT 1 AS n UNION ALL SELECT EXISTS(SELECT n FROM t))
                                                            ^
==

# Expression subqueries in the recursive term is ok, so long as they do not
# reference the recursive table (reference a column of t is ok, so long as t
# is not referenced directly).
WITH RECURSIVE
  t AS (SELECT 1 AS n UNION ALL (
    SELECT (SELECT n) FROM t))
SELECT * FROM t;
--
QueryStmt
+-output_column_list=
| +-t.n#6 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#6]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#5]
    |           |   +-expr_list=
    |           |   | +-$col1#5 :=
    |           |   |   +-SubqueryExpr
    |           |   |     +-type=INT64
    |           |   |     +-subquery_type=SCALAR
    |           |   |     +-parameter_list=
    |           |   |     | +-ColumnRef(type=INT64, column=t.n#3)
    |           |   |     +-subquery=
    |           |   |       +-ProjectScan
    |           |   |         +-column_list=[$expr_subquery.n#4]
    |           |   |         +-expr_list=
    |           |   |         | +-n#4 := ColumnRef(type=INT64, column=t.n#3, is_correlated=TRUE)
    |           |   |         +-input_scan=
    |           |   |           +-SingleRowScan
    |           |   +-input_scan=
    |           |     +-RecursiveRefScan(column_list=[t.n#3])
    |           +-output_column_list=[$union_all2.$col1#5]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#6]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#6], with_query_name="t")
    +-recursive=TRUE
==

# Subqueries containing a recursive reference are ok when in a FROM clause.
WITH RECURSIVE
  t AS (SELECT 1 AS n UNION ALL SELECT n + 1 FROM (SELECT n FROM t))
SELECT * FROM t;
--
QueryStmt
+-output_column_list=
| +-t.n#5 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#5]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#4]
    |           |   +-expr_list=
    |           |   | +-$col1#4 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=t.n#3)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-ProjectScan
    |           |       +-column_list=[t.n#3]
    |           |       +-input_scan=
    |           |         +-RecursiveRefScan(column_list=[t.n#3])
    |           +-output_column_list=[$union_all2.$col1#4]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#5]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#5], with_query_name="t")
    +-recursive=TRUE
==

# Aggregation in the recursive term is ok, so long as it's in a subquery which
# does not reference t.
WITH RECURSIVE
  t AS (
    SELECT 1 AS n UNION ALL (
      SELECT n + (SELECT COUNT(*) FROM KeyValue)
      FROM t
  )
) SELECT * FROM t;
--
QueryStmt
+-output_column_list=
| +-t.n#8 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#8]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#7]
    |           |   +-expr_list=
    |           |   | +-$col1#7 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=t.n#3)
    |           |   |     +-SubqueryExpr
    |           |   |       +-type=INT64
    |           |   |       +-subquery_type=SCALAR
    |           |   |       +-subquery=
    |           |   |         +-ProjectScan
    |           |   |           +-column_list=[$aggregate.$agg1#6]
    |           |   |           +-input_scan=
    |           |   |             +-AggregateScan
    |           |   |               +-column_list=[$aggregate.$agg1#6]
    |           |   |               +-input_scan=
    |           |   |               | +-TableScan(table=KeyValue)
    |           |   |               +-aggregate_list=
    |           |   |                 +-$agg1#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    |           |   +-input_scan=
    |           |     +-RecursiveRefScan(column_list=[t.n#3])
    |           +-output_column_list=[$union_all2.$col1#7]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#8], with_query_name="t")
    +-recursive=TRUE
==

# Even inside of a FROM clause, a recursive reference in a subquery expression
# is not allowed.
WITH RECURSIVE
  t AS (SELECT 1 as n UNION ALL
        SELECT arr[safe_offset(0)] FROM (SELECT 1 n, ARRAY(SELECT n FROM t) arr))
SELECT * FROM t;
--
ERROR: A recursive reference from inside an expression subquery is not allowed [at 3:74]
...0)] FROM (SELECT 1 n, ARRAY(SELECT n FROM t) arr))
                                             ^
==

# Recursive reference as TVF argument is disallowed
WITH RECURSIVE t AS (
    SELECT 1.0 AS n
  UNION ALL
    SELECT 1 FROM tvf_one_relation_arg_with_fixed_output((SELECT * FROM t))
  )
  SELECT n FROM t;
--
ERROR: A query containing a recursive reference may not be used as an argument to a table-valued function [at 4:73]
    SELECT 1 FROM tvf_one_relation_arg_with_fixed_output((SELECT * FROM t))
                                                                        ^
==

# Subquery containing recursive reference is also disallowed as TVF argument
WITH RECURSIVE t AS (
    SELECT 1.0 AS n
  UNION ALL
    SELECT 1 FROM tvf_one_relation_arg_with_fixed_output((SELECT * FROM (SELECT * FROM (SELECT * FROM t))))
  )
  SELECT n FROM t;
--
ERROR: A query containing a recursive reference may not be used as an argument to a table-valued function [at 4:103]
...SELECT * FROM (SELECT * FROM (SELECT * FROM t))))
                                               ^
==

# TVF call is ok, so long as the recursive reference is not an input to it
WITH RECURSIVE
  a AS (SELECT n FROM UNNEST([1.0, 2.0, 3.0, 4.0]) AS n),
  t AS (
    SELECT 1.0 AS n
  UNION ALL
    SELECT 1
      FROM tvf_one_relation_arg_output_schema_is_input_schema(
        (SELECT * FROM tvf_one_relation_arg_output_schema_is_input_schema((SELECT * FROM a))))
        AS f
      INNER JOIN t ON (f.n = t.n)
  )
SELECT n FROM t;
--
QueryStmt
+-output_column_list=
| +-t.n#10 AS n [DOUBLE]
+-query=
  +-WithScan
    +-column_list=[t.n#10]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="a"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.n#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.n#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<DOUBLE>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.n#1
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=DOUBLE, value=1, float_literal_id=5)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all1_cast.$col1#9]
    |           |   +-expr_list=
    |           |   | +-$col1#9 := Literal(type=DOUBLE, value=1)
    |           |   +-input_scan=
    |           |     +-ProjectScan
    |           |       +-column_list=[$union_all2.$col1#8]
    |           |       +-expr_list=
    |           |       | +-$col1#8 := Literal(type=INT64, value=1)
    |           |       +-input_scan=
    |           |         +-JoinScan
    |           |           +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.n#6, t.n#7]
    |           |           +-left_scan=
    |           |           | +-TVFScan
    |           |           |   +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.n#6]
    |           |           |   +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
    |           |           |   +-signature=(TABLE<n DOUBLE>) -> TABLE<n DOUBLE>
    |           |           |   +-argument_list=
    |           |           |   | +-FunctionArgument
    |           |           |   |   +-scan=
    |           |           |   |   | +-ProjectScan
    |           |           |   |   |   +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.n#5]
    |           |           |   |   |   +-input_scan=
    |           |           |   |   |     +-TVFScan
    |           |           |   |   |       +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.n#5]
    |           |           |   |   |       +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
    |           |           |   |   |       +-signature=(TABLE<n DOUBLE>) -> TABLE<n DOUBLE>
    |           |           |   |   |       +-argument_list=
    |           |           |   |   |       | +-FunctionArgument
    |           |           |   |   |       |   +-scan=
    |           |           |   |   |       |   | +-ProjectScan
    |           |           |   |   |       |   |   +-column_list=[a.n#4]
    |           |           |   |   |       |   |   +-input_scan=
    |           |           |   |   |       |   |     +-WithRefScan(column_list=[a.n#4], with_query_name="a")
    |           |           |   |   |       |   +-argument_column_list=[a.n#4]
    |           |           |   |   |       +-column_index_list=[0]
    |           |           |   |   +-argument_column_list=[tvf_one_relation_arg_output_schema_is_input_schema.n#5]
    |           |           |   +-column_index_list=[0]
    |           |           |   +-alias="f"
    |           |           +-right_scan=
    |           |           | +-RecursiveRefScan(column_list=[t.n#7])
    |           |           +-join_expr=
    |           |             +-FunctionCall(ZetaSQL:$equal(DOUBLE, DOUBLE) -> BOOL)
    |           |               +-ColumnRef(type=DOUBLE, column=tvf_one_relation_arg_output_schema_is_input_schema.n#6)
    |           |               +-ColumnRef(type=DOUBLE, column=t.n#7)
    |           +-output_column_list=[$union_all1_cast.$col1#9]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#10]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#10], with_query_name="t")
    +-recursive=TRUE
==

# TVF with multiple arguments, first argument is nested TVF, second argument
# contains recursive reference.
WITH RECURSIVE
  t AS (
    SELECT 1.0 AS n
  UNION ALL
    SELECT 1
      FROM tvf_two_relation_args_output_schema_is_input_schema(
        (SELECT * FROM tvf_one_relation_arg_output_schema_is_input_schema((SELECT 1.0 AS n))),
        (SELECT * FROM t)
      )
  )
SELECT n FROM t;
--
ERROR: A query containing a recursive reference may not be used as an argument to a table-valued function [at 8:24]
        (SELECT * FROM t)
                       ^
==

# TVF argument contains a nested TVF argument, followed by a recursive
# reference. Make sure the tree-checking logic realizes we are still in the
# outer TVF argument when the inner TVF call terminates.
WITH RECURSIVE
  t AS (
    SELECT 1.0 AS n
  UNION ALL
    SELECT 1
      FROM tvf_one_relation_arg_output_schema_is_input_schema(
        (SELECT * FROM tvf_one_relation_arg_output_schema_is_input_schema(
          (SELECT * FROM (SELECT 1.0 AS n)
        INNER JOIN t USING (n)))
      )
  )
) SELECT * FROM t;
--
ERROR: A query containing a recursive reference may not be used as an argument to a table-valued function [at 9:20]
        INNER JOIN t USING (n)))
                   ^
==

# Recursive query used in TVF, in non-recursive context
WITH RECURSIVE t AS (
  SELECT 1 AS n
  UNION ALL SELECT n + 1 FROM t WHERE n + 1 < 10
)
SELECT * FROM tvf_one_relation_arg_output_schema_is_input_schema((SELECT * FROM t));
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.n#6 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.n#6]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#4]
    |           |   +-expr_list=
    |           |   | +-$col1#4 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=t.n#3)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=[t.n#3]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=[t.n#3])
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |           | +-ColumnRef(type=INT64, column=t.n#3)
    |           |           | +-Literal(type=INT64, value=1)
    |           |           +-Literal(type=INT64, value=10)
    |           +-output_column_list=[$union_all2.$col1#4]
    +-query=
    | +-ProjectScan
    |   +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.n#6]
    |   +-input_scan=
    |     +-TVFScan
    |       +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.n#6]
    |       +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
    |       +-signature=(TABLE<n INT64>) -> TABLE<n INT64>
    |       +-argument_list=
    |       | +-FunctionArgument
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[t.n#5]
    |       |   |   +-input_scan=
    |       |   |     +-WithRefScan(column_list=[t.n#5], with_query_name="t")
    |       |   +-argument_column_list=[t.n#5]
    |       +-column_index_list=[0]
    +-recursive=TRUE
==

# Error: Multiple recursive references to same query (via join)
WITH RECURSIVE t AS (
  SELECT 1 AS n UNION ALL
  SELECT t1.n + t2.n FROM t AS t1 CROSS JOIN t AS t2
) SELECT * FROM t;
--
ERROR: Multiple recursive references to table 't' are not allowed [at 3:46]
  SELECT t1.n + t2.n FROM t AS t1 CROSS JOIN t AS t2
                                             ^
==

# Error: Multiple recursive references to same query (via union)
WITH RECURSIVE t AS (
  SELECT 1 AS n UNION ALL (
  SELECT n FROM t UNION ALL SELECT n FROM t)
) SELECT * FROM t;
--
ERROR: Multiple recursive references to table 't' are not allowed [at 3:43]
  SELECT n FROM t UNION ALL SELECT n FROM t)
                                          ^
==

# Error: This query contains multiple recursive references to same query;
# however, it also contains recursive references from inside of WITH aliases;
# both are errors, but the latter takes precedence when producing the error
# message.
WITH RECURSIVE
  t1 AS (
    SELECT 1 AS n
    UNION ALL (
      WITH RECURSIVE
        t2 AS (SELECT * FROM t1 AS n UNION ALL SELECT * FROM t2),
        t3 AS (SELECT * FROM t1 AS n UNION ALL SELECT * FROM t3)
      SELECT * FROM t3
    )
) SELECT * FROM t1;
--
ERROR: table 't1' may not be recursively referenced from inside an inner WITH entry [at 7:30]
        t3 AS (SELECT * FROM t1 AS n UNION ALL SELECT * FROM t3)
                             ^
==

# Reference to both t1 and t2 from within t2 does not count as multiple
# recursive references, since the reference to t1 is not recursive.
WITH RECURSIVE
  t1 AS (SELECT 1 AS n1 UNION ALL SELECT n1 + 1 FROM t1),
  t2 AS (SELECT 1 AS n2 UNION ALL SELECT n2 + 1 FROM t1 CROSS JOIN t2)
SELECT * FROM t2;
--
QueryStmt
+-output_column_list=
| +-t2.n2#10 AS n2 [INT64]
+-query=
  +-WithScan
    +-column_list=[t2.n2#10]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t1"
    | | +-with_subquery=
    | |   +-RecursiveScan
    | |     +-column_list=[$union_all.n1#2]
    | |     +-op_type=UNION_ALL
    | |     +-non_recursive_term=
    | |     | +-SetOperationItem
    | |     |   +-scan=
    | |     |   | +-ProjectScan
    | |     |   |   +-column_list=[$union_all1.n1#1]
    | |     |   |   +-expr_list=
    | |     |   |   | +-n1#1 := Literal(type=INT64, value=1)
    | |     |   |   +-input_scan=
    | |     |   |     +-SingleRowScan
    | |     |   +-output_column_list=[$union_all1.n1#1]
    | |     +-recursive_term=
    | |       +-SetOperationItem
    | |         +-scan=
    | |         | +-ProjectScan
    | |         |   +-column_list=[$union_all2.$col1#4]
    | |         |   +-expr_list=
    | |         |   | +-$col1#4 :=
    | |         |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |         |   |     +-ColumnRef(type=INT64, column=t1.n1#3)
    | |         |   |     +-Literal(type=INT64, value=1)
    | |         |   +-input_scan=
    | |         |     +-RecursiveRefScan(column_list=[t1.n1#3])
    | |         +-output_column_list=[$union_all2.$col1#4]
    | +-WithEntry
    |   +-with_query_name="t2"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n2#6]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n2#5]
    |       |   |   +-expr_list=
    |       |   |   | +-n2#5 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n2#5]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#9]
    |           |   +-expr_list=
    |           |   | +-$col1#9 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=t2.n2#8)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-JoinScan
    |           |       +-column_list=[t1.n1#7, t2.n2#8]
    |           |       +-left_scan=
    |           |       | +-WithRefScan(column_list=[t1.n1#7], with_query_name="t1")
    |           |       +-right_scan=
    |           |         +-RecursiveRefScan(column_list=[t2.n2#8])
    |           +-output_column_list=[$union_all2.$col1#9]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t2.n2#10]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t2.n2#10], with_query_name="t2")
    +-recursive=TRUE
==

# ERROR: Analytic function used against recursive reference.
WITH RECURSIVE t AS (
    SELECT 1.0 AS n
  UNION ALL
    SELECT 1 + AVG(n) OVER(ROWS BETWEEN 2 PRECEDING AND 0 FOLLOWING)
    FROM t WHERE n < 10
  )
  SELECT n FROM t;
--
ERROR: A subquery containing a recursive reference may not use an analytic function [at 5:10]
    FROM t WHERE n < 10
         ^
==

# An analytic function which does not use the recursive table as input is ok
WITH RECURSIVE t AS (
    SELECT 1.0 AS n
  UNION ALL
    SELECT r FROM (
      SELECT 1 + AVG(r) OVER(ROWS BETWEEN 2 PRECEDING AND 0 FOLLOWING) AS r
      FROM UNNEST([1.1, 1.2, 1.3]) AS r)
      INNER JOIN t ON (r = t.n) WHERE n < 10
  )
  SELECT n FROM t;
--
QueryStmt
+-output_column_list=
| +-t.n#8 AS n [DOUBLE]
+-query=
  +-WithScan
    +-column_list=[t.n#8]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=DOUBLE, value=1, float_literal_id=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$subquery1.r#6]
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=[$subquery1.r#6, t.n#7]
    |           |       +-input_scan=
    |           |       | +-JoinScan
    |           |       |   +-column_list=[$subquery1.r#6, t.n#7]
    |           |       |   +-left_scan=
    |           |       |   | +-ProjectScan
    |           |       |   |   +-column_list=[$subquery1.r#6]
    |           |       |   |   +-expr_list=
    |           |       |   |   | +-r#6 :=
    |           |       |   |   |   +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
    |           |       |   |   |     +-Literal(type=DOUBLE, value=1)
    |           |       |   |   |     +-ColumnRef(type=DOUBLE, column=$analytic.$analytic1#5)
    |           |       |   |   +-input_scan=
    |           |       |   |     +-AnalyticScan
    |           |       |   |       +-column_list=[$array.r#3, $analytic.$analytic1#5]
    |           |       |   |       +-input_scan=
    |           |       |   |       | +-ArrayScan
    |           |       |   |       |   +-column_list=[$array.r#3]
    |           |       |   |       |   +-array_expr=
    |           |       |   |       |   | +-Literal(type=ARRAY<DOUBLE>, value=[1.1, 1.2, 1.3])
    |           |       |   |       |   +-element_column=$array.r#3
    |           |       |   |       +-function_group_list=
    |           |       |   |         +-AnalyticFunctionGroup
    |           |       |   |           +-analytic_function_list=
    |           |       |   |             +-$analytic1#5 :=
    |           |       |   |               +-AnalyticFunctionCall(ZetaSQL:avg(DOUBLE) -> DOUBLE)
    |           |       |   |                 +-ColumnRef(type=DOUBLE, column=$array.r#3)
    |           |       |   |                 +-window_frame=
    |           |       |   |                   +-WindowFrame(frame_unit=ROWS)
    |           |       |   |                     +-start_expr=
    |           |       |   |                     | +-WindowFrameExpr(boundary_type=OFFSET PRECEDING)
    |           |       |   |                     |   +-Literal(type=INT64, value=2)
    |           |       |   |                     +-end_expr=
    |           |       |   |                       +-WindowFrameExpr(boundary_type=OFFSET FOLLOWING)
    |           |       |   |                         +-Literal(type=INT64, value=0)
    |           |       |   +-right_scan=
    |           |       |   | +-RecursiveRefScan(column_list=[t.n#7])
    |           |       |   +-join_expr=
    |           |       |     +-FunctionCall(ZetaSQL:$equal(DOUBLE, DOUBLE) -> BOOL)
    |           |       |       +-ColumnRef(type=DOUBLE, column=$subquery1.r#6)
    |           |       |       +-ColumnRef(type=DOUBLE, column=t.n#7)
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(DOUBLE, DOUBLE) -> BOOL)
    |           |           +-ColumnRef(type=DOUBLE, column=t.n#7)
    |           |           +-Literal(type=DOUBLE, value=10)
    |           +-output_column_list=[$subquery1.r#6]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#8], with_query_name="t")
    +-recursive=TRUE
==

# ERROR: Similar to the above, but with the parentheses changed so that the
# input to the analytic function is a join between the unnest and the recursive
# reference. The input to the analytic function depends on the recursive
# reference, resulting in an error.
WITH RECURSIVE t AS (
    SELECT 1.0 AS n
  UNION ALL
    SELECT r FROM (
      SELECT 1 + AVG(r) OVER(ROWS BETWEEN 2 PRECEDING AND 0 FOLLOWING) AS r
      FROM UNNEST([1.1, 1.2, 1.3]) AS r
      INNER JOIN t ON (r = t.n) WHERE n < 10)
  )
  SELECT n FROM t;
--
ERROR: A subquery containing a recursive reference may not use an analytic function [at 7:18]
      INNER JOIN t ON (r = t.n) WHERE n < 10)
                 ^
==

# ERROR: Similar to the above, but with an extra "SELECT * FROM" wrapped around
# the input to the analytic function. It still depends on the recursive
# reference.
WITH RECURSIVE t AS (
    SELECT 1.0 AS n
  UNION ALL
    SELECT r FROM (
      SELECT 1 + AVG(r) OVER(ROWS BETWEEN 2 PRECEDING AND 0 FOLLOWING) AS r
      FROM (SELECT * FROM UNNEST([1.1, 1.2, 1.3]) AS r
      INNER JOIN t ON (r = t.n) WHERE n < 10))
  )
  SELECT n FROM t;
--
ERROR: A subquery containing a recursive reference may not use an analytic function [at 7:18]
      INNER JOIN t ON (r = t.n) WHERE n < 10))
                 ^
==

# ERROR: Use of LIMIT when selecting from a recursive reference
WITH RECURSIVE
  t AS (
    SELECT 1 AS n UNION ALL (SELECT n FROM t LIMIT 5)
) SELECT * FROM t;
--
ERROR: A query containing a recursive reference may not use a LIMIT clause [at 3:44]
    SELECT 1 AS n UNION ALL (SELECT n FROM t LIMIT 5)
                                           ^
==

# LIMIT in a subquery not dependent on the recursive reference is ok
WITH RECURSIVE
  t AS (
    SELECT 1 AS n UNION ALL (
      (SELECT * FROM UNNEST([1,2,3,4]) LIMIT 2)
      UNION ALL (SELECT n + 1 FROM t)
  )
) SELECT * FROM t;
--
QueryStmt
+-output_column_list=
| +-t.n#7 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#7]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-SetOperationScan
    |           |   +-column_list=[$union_all.$unnest1#6]
    |           |   +-op_type=UNION_ALL
    |           |   +-input_item_list=
    |           |     +-SetOperationItem
    |           |     | +-scan=
    |           |     | | +-LimitOffsetScan
    |           |     | |   +-column_list=[$array.$unnest1#3]
    |           |     | |   +-input_scan=
    |           |     | |   | +-ProjectScan
    |           |     | |   |   +-column_list=[$array.$unnest1#3]
    |           |     | |   |   +-input_scan=
    |           |     | |   |     +-ArrayScan
    |           |     | |   |       +-column_list=[$array.$unnest1#3]
    |           |     | |   |       +-array_expr=
    |           |     | |   |       | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    |           |     | |   |       +-element_column=$array.$unnest1#3
    |           |     | |   +-limit=
    |           |     | |     +-Literal(type=INT64, value=2)
    |           |     | +-output_column_list=[$array.$unnest1#3]
    |           |     +-SetOperationItem
    |           |       +-scan=
    |           |       | +-ProjectScan
    |           |       |   +-column_list=[$union_all2.$col1#5]
    |           |       |   +-expr_list=
    |           |       |   | +-$col1#5 :=
    |           |       |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |       |   |     +-ColumnRef(type=INT64, column=t.n#4)
    |           |       |   |     +-Literal(type=INT64, value=1)
    |           |       |   +-input_scan=
    |           |       |     +-RecursiveRefScan(column_list=[t.n#4])
    |           |       +-output_column_list=[$union_all2.$col1#5]
    |           +-output_column_list=[$union_all.$unnest1#6]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#7]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#7], with_query_name="t")
    +-recursive=TRUE
==

# ERROR: LIMIT clause in top-level recursive subquery
WITH RECURSIVE
  t AS (
    SELECT 1 AS n UNION ALL SELECT n FROM t LIMIT 5
) SELECT * FROM t;
--
ERROR: A recursive query may not use LIMIT [at 3:45]
    SELECT 1 AS n UNION ALL SELECT n FROM t LIMIT 5
                                            ^
==

# ERROR: Save as above, but with some extra parentheses which cause some extra
# nodes in the AST.
WITH RECURSIVE
  t AS (
    (((SELECT 1 AS n UNION ALL SELECT n FROM t) LIMIT 5))
) SELECT * FROM t;
--
ERROR: A recursive query may not use LIMIT [at 3:49]
    (((SELECT 1 AS n UNION ALL SELECT n FROM t) LIMIT 5))
                                                ^
==

# ERROR: LIMIT on a subquery which depends on recursive reference
WITH RECURSIVE
  t AS (
    SELECT 1 AS n
    UNION ALL (
      SELECT * FROM
          (SELECT n + 1 FROM t)
     LIMIT 2)
) SELECT * FROM t;
--
ERROR: A query containing a recursive reference may not use a LIMIT clause [at 6:30]
          (SELECT n + 1 FROM t)
                             ^
==

# ERROR: Similar to the above, but with extra layer of UNION between the LIMIT
# clause and the recursive reference.
WITH RECURSIVE
  t AS (
    SELECT 1 AS n
    UNION ALL (
      SELECT * FROM
          (SELECT * FROM UNNEST([1,2,3,4])
           UNION ALL
           SELECT n + 1 FROM t)
     LIMIT 2)
) SELECT * FROM t;
--
ERROR: A query containing a recursive reference may not use a LIMIT clause [at 8:30]
           SELECT n + 1 FROM t)
                             ^
==

# ERROR: ORDER BY on recursive reference
WITH RECURSIVE
  t AS (
  SELECT 1 AS n
  UNION ALL (SELECT n + 1 FROM t ORDER BY n)
) SELECT * FROM t;
--
ERROR: A subquery containing a recursive reference may not contain an ORDER BY clause [at 4:32]
  UNION ALL (SELECT n + 1 FROM t ORDER BY n)
                               ^
==

# ERROR: ORDER BY on subquery dependent on recursive reference
WITH RECURSIVE
  t AS (
  SELECT 1 AS n
  UNION ALL (SELECT n + 1 FROM (SELECT * FROM t) ORDER BY n)
) SELECT * FROM t;
--
ERROR: A subquery containing a recursive reference may not contain an ORDER BY clause [at 4:47]
  UNION ALL (SELECT n + 1 FROM (SELECT * FROM t) ORDER BY n)
                                              ^
==

# ERROR: ORDER BY on table expression involving recursive reference
WITH RECURSIVE
  t AS (
  SELECT 1 AS n
  UNION ALL (SELECT n + 1 FROM t INNER JOIN UNNEST([1,2,3,4]) AS arr ORDER BY n)
) SELECT * FROM t;
--
ERROR: A subquery containing a recursive reference may not contain an ORDER BY clause [at 4:32]
  UNION ALL (SELECT n + 1 FROM t INNER JOIN UNNEST([1,2,3,4]) AS arr ORDER BY n)
                               ^
==

# ERROR: ORDER BY on top-level recursive union
WITH RECURSIVE
  t AS (
  SELECT 1 AS n
  UNION ALL SELECT n + 1 FROM t ORDER BY n
) SELECT * FROM t;
--
ERROR: A recursive query may not use ORDER BY [at 4:33]
  UNION ALL SELECT n + 1 FROM t ORDER BY n
                                ^
==

# ERROR: ORDER BY on top-level recursive union (with extra layer of parens)
WITH RECURSIVE
  t AS ((
  SELECT 1 AS n
  UNION ALL SELECT n + 1 FROM t) ORDER BY n
) SELECT * FROM t;
--
ERROR: A recursive query may not use ORDER BY [at 4:34]
  UNION ALL SELECT n + 1 FROM t) ORDER BY n
                                 ^
==

# ERROR: TABLESAMPLE against recursive query (direct)
WITH RECURSIVE t AS (
  SELECT 1 AS n UNION ALL
  SELECT n FROM t TABLESAMPLE RESERVOIR (100 ROWS)
) SELECT * FROM t;
--
ERROR: A subquery containing a recursive reference may not use the TABLESAMPLE operator [at 3:17]
  SELECT n FROM t TABLESAMPLE RESERVOIR (100 ROWS)
                ^
==

# ERROR: TABLESAMPLE against recursive query (indirect)
WITH RECURSIVE t AS (
  SELECT 1 AS n UNION ALL
  SELECT n FROM
    (SELECT n + 1 AS n, 3 AS three FROM t) TABLESAMPLE RESERVOIR (100 ROWS)
) SELECT * FROM t;
--
ERROR: A subquery containing a recursive reference may not use the TABLESAMPLE operator [at 4:41]
    (SELECT n + 1 AS n, 3 AS three FROM t) TABLESAMPLE RESERVOIR (100 ROWS)
                                        ^
==

# ORDER BY and TABLESAMPLE are still allowed in the main query, when the
# reference isn't recursive anymore
WITH RECURSIVE t AS (
  SELECT 1 AS n UNION ALL
  SELECT n FROM
    (SELECT n + 1 AS n, 3 AS three FROM t)
) SELECT * FROM t TABLESAMPLE RESERVOIR (100 ROWS) ORDER BY n;
--
QueryStmt
+-output_column_list=
| +-t.n#6 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#6]
    +-is_ordered=TRUE
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$subquery1.n#4]
    |           |   +-input_scan=
    |           |     +-ProjectScan
    |           |       +-column_list=$subquery1.[n#4, three#5]
    |           |       +-expr_list=
    |           |       | +-n#4 :=
    |           |       | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |       | |   +-ColumnRef(type=INT64, column=t.n#3)
    |           |       | |   +-Literal(type=INT64, value=1)
    |           |       | +-three#5 := Literal(type=INT64, value=3)
    |           |       +-input_scan=
    |           |         +-RecursiveRefScan(column_list=[t.n#3])
    |           +-output_column_list=[$subquery1.n#4]
    +-query=
    | +-OrderByScan
    |   +-column_list=[t.n#6]
    |   +-is_ordered=TRUE
    |   +-input_scan=
    |   | +-SampleScan
    |   |   +-column_list=[t.n#6]
    |   |   +-input_scan=
    |   |   | +-WithRefScan(column_list=[t.n#6], with_query_name="t")
    |   |   +-method="reservoir"
    |   |   +-size=
    |   |   | +-Literal(type=INT64, value=100)
    |   |   +-unit=ROWS
    |   +-order_by_item_list=
    |     +-OrderByItem
    |       +-column_ref=
    |         +-ColumnRef(type=INT64, column=t.n#6)
    +-recursive=TRUE
==

# A recursive term may still use ORDER BY and TABLESAMPLE to reference
# non-recursive subqueries
WITH RECURSIVE
  tbl AS (SELECT n FROM UNNEST([1,2,3,4]) AS n),
  t AS (
  SELECT 1 AS n UNION ALL
  SELECT n FROM
    (SELECT n + 1 AS n, 3 AS three FROM t INNER JOIN (
      SELECT * FROM tbl TABLESAMPLE RESERVOIR (100 ROWS) ORDER BY n) USING(n))
) SELECT * FROM t;
--
QueryStmt
+-output_column_list=
| +-t.n#8 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="tbl"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.n#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.n#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.n#1
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$subquery1.n#6]
    |           |   +-input_scan=
    |           |     +-ProjectScan
    |           |       +-column_list=$subquery1.[n#6, three#7]
    |           |       +-expr_list=
    |           |       | +-n#6 :=
    |           |       | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |       | |   +-ColumnRef(type=INT64, column=t.n#4)
    |           |       | |   +-Literal(type=INT64, value=1)
    |           |       | +-three#7 := Literal(type=INT64, value=3)
    |           |       +-input_scan=
    |           |         +-JoinScan
    |           |           +-column_list=[t.n#4, tbl.n#5]
    |           |           +-left_scan=
    |           |           | +-RecursiveRefScan(column_list=[t.n#4])
    |           |           +-right_scan=
    |           |           | +-OrderByScan
    |           |           |   +-column_list=[tbl.n#5]
    |           |           |   +-input_scan=
    |           |           |   | +-SampleScan
    |           |           |   |   +-column_list=[tbl.n#5]
    |           |           |   |   +-input_scan=
    |           |           |   |   | +-WithRefScan(column_list=[tbl.n#5], with_query_name="tbl")
    |           |           |   |   +-method="reservoir"
    |           |           |   |   +-size=
    |           |           |   |   | +-Literal(type=INT64, value=100)
    |           |           |   |   +-unit=ROWS
    |           |           |   +-order_by_item_list=
    |           |           |     +-OrderByItem
    |           |           |       +-column_ref=
    |           |           |         +-ColumnRef(type=INT64, column=tbl.n#5)
    |           |           +-join_expr=
    |           |             +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |           |               +-ColumnRef(type=INT64, column=t.n#4)
    |           |               +-ColumnRef(type=INT64, column=tbl.n#5)
    |           +-output_column_list=[$subquery1.n#6]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#8], with_query_name="t")
    +-recursive=TRUE
==

# Same as above, but with the recursive reference on the right side of the join
WITH RECURSIVE
  tbl AS (SELECT n FROM UNNEST([1,2,3,4]) AS n),
  t AS (
  SELECT 1 AS n UNION ALL
  SELECT n FROM
    (SELECT n + 1 AS n, 3 AS three FROM
      (SELECT * FROM tbl TABLESAMPLE RESERVOIR (100 ROWS) ORDER BY n)
      INNER JOIN t USING(n))
) SELECT * FROM t;
--
QueryStmt
+-output_column_list=
| +-t.n#8 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="tbl"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.n#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.n#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.n#1
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$subquery1.n#6]
    |           |   +-input_scan=
    |           |     +-ProjectScan
    |           |       +-column_list=$subquery1.[n#6, three#7]
    |           |       +-expr_list=
    |           |       | +-n#6 :=
    |           |       | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |       | |   +-ColumnRef(type=INT64, column=tbl.n#4)
    |           |       | |   +-Literal(type=INT64, value=1)
    |           |       | +-three#7 := Literal(type=INT64, value=3)
    |           |       +-input_scan=
    |           |         +-JoinScan
    |           |           +-column_list=[tbl.n#4, t.n#5]
    |           |           +-left_scan=
    |           |           | +-OrderByScan
    |           |           |   +-column_list=[tbl.n#4]
    |           |           |   +-input_scan=
    |           |           |   | +-SampleScan
    |           |           |   |   +-column_list=[tbl.n#4]
    |           |           |   |   +-input_scan=
    |           |           |   |   | +-WithRefScan(column_list=[tbl.n#4], with_query_name="tbl")
    |           |           |   |   +-method="reservoir"
    |           |           |   |   +-size=
    |           |           |   |   | +-Literal(type=INT64, value=100)
    |           |           |   |   +-unit=ROWS
    |           |           |   +-order_by_item_list=
    |           |           |     +-OrderByItem
    |           |           |       +-column_ref=
    |           |           |         +-ColumnRef(type=INT64, column=tbl.n#4)
    |           |           +-right_scan=
    |           |           | +-RecursiveRefScan(column_list=[t.n#5])
    |           |           +-join_expr=
    |           |             +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |           |               +-ColumnRef(type=INT64, column=tbl.n#4)
    |           |               +-ColumnRef(type=INT64, column=t.n#5)
    |           +-output_column_list=[$subquery1.n#6]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#8], with_query_name="t")
    +-recursive=TRUE
==

# Recursive reference in left operand of join. Allowed only for INNER and LEFT
# joins. Test both direct and indirect reference.
WITH RECURSIVE
  t_other AS (SELECT * FROM UNNEST([1,2,3,4]) AS n),
  t AS (SELECT 1 AS n UNION ALL SELECT n FROM {{t|(SELECT * FROM t)}}
    {{INNER|LEFT|RIGHT|FULL OUTER}} JOIN t_other USING (n))
SELECT * FROM t;
--
ALTERNATION GROUP: t,INNER
--
QueryStmt
+-output_column_list=
| +-t.n#6 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#6]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t_other"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.n#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.n#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.n#1
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t.n#4]
    |           |   +-input_scan=
    |           |     +-JoinScan
    |           |       +-column_list=[t.n#4, t_other.n#5]
    |           |       +-left_scan=
    |           |       | +-RecursiveRefScan(column_list=[t.n#4])
    |           |       +-right_scan=
    |           |       | +-WithRefScan(column_list=[t_other.n#5], with_query_name="t_other")
    |           |       +-join_expr=
    |           |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t.n#4)
    |           |           +-ColumnRef(type=INT64, column=t_other.n#5)
    |           +-output_column_list=[t.n#4]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#6]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#6], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: t,LEFT
--
QueryStmt
+-output_column_list=
| +-t.n#6 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#6]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t_other"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.n#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.n#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.n#1
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t.n#4]
    |           |   +-input_scan=
    |           |     +-JoinScan
    |           |       +-column_list=[t.n#4, t_other.n#5]
    |           |       +-join_type=LEFT
    |           |       +-left_scan=
    |           |       | +-RecursiveRefScan(column_list=[t.n#4])
    |           |       +-right_scan=
    |           |       | +-WithRefScan(column_list=[t_other.n#5], with_query_name="t_other")
    |           |       +-join_expr=
    |           |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t.n#4)
    |           |           +-ColumnRef(type=INT64, column=t_other.n#5)
    |           +-output_column_list=[t.n#4]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#6]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#6], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: t,RIGHT
--
ERROR: A query containing a recursive reference may not be used as the left operand of a RIGHT JOIN [at 3:47]
  t AS (SELECT 1 AS n UNION ALL SELECT n FROM t
                                              ^
--
ALTERNATION GROUP: t,FULL OUTER
--
ERROR: A query containing a recursive reference may not be used as an operand of a FULL OUTER JOIN [at 3:47]
  t AS (SELECT 1 AS n UNION ALL SELECT n FROM t
                                              ^
--
ALTERNATION GROUP: (SELECT * FROM t),INNER
--
QueryStmt
+-output_column_list=
| +-t.n#6 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#6]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t_other"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.n#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.n#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.n#1
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t.n#4]
    |           |   +-input_scan=
    |           |     +-JoinScan
    |           |       +-column_list=[t.n#4, t_other.n#5]
    |           |       +-left_scan=
    |           |       | +-ProjectScan
    |           |       |   +-column_list=[t.n#4]
    |           |       |   +-input_scan=
    |           |       |     +-RecursiveRefScan(column_list=[t.n#4])
    |           |       +-right_scan=
    |           |       | +-WithRefScan(column_list=[t_other.n#5], with_query_name="t_other")
    |           |       +-join_expr=
    |           |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t.n#4)
    |           |           +-ColumnRef(type=INT64, column=t_other.n#5)
    |           +-output_column_list=[t.n#4]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#6]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#6], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: (SELECT * FROM t),LEFT
--
QueryStmt
+-output_column_list=
| +-t.n#6 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#6]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t_other"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.n#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.n#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.n#1
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t.n#4]
    |           |   +-input_scan=
    |           |     +-JoinScan
    |           |       +-column_list=[t.n#4, t_other.n#5]
    |           |       +-join_type=LEFT
    |           |       +-left_scan=
    |           |       | +-ProjectScan
    |           |       |   +-column_list=[t.n#4]
    |           |       |   +-input_scan=
    |           |       |     +-RecursiveRefScan(column_list=[t.n#4])
    |           |       +-right_scan=
    |           |       | +-WithRefScan(column_list=[t_other.n#5], with_query_name="t_other")
    |           |       +-join_expr=
    |           |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t.n#4)
    |           |           +-ColumnRef(type=INT64, column=t_other.n#5)
    |           +-output_column_list=[t.n#4]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#6]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#6], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: (SELECT * FROM t),RIGHT
--
ERROR: A query containing a recursive reference may not be used as the left operand of a RIGHT JOIN [at 3:62]
  t AS (SELECT 1 AS n UNION ALL SELECT n FROM (SELECT * FROM t)
                                                             ^
--
ALTERNATION GROUP: (SELECT * FROM t),FULL OUTER
--
ERROR: A query containing a recursive reference may not be used as an operand of a FULL OUTER JOIN [at 3:62]
  t AS (SELECT 1 AS n UNION ALL SELECT n FROM (SELECT * FROM t)
                                                             ^
==

# Recursive reference in right operand of join. Allowed only for INNER and RIGHT
# joins. Test both direct and indirect reference.
WITH RECURSIVE
  t_other AS (SELECT * FROM UNNEST([1,2,3,4]) AS n),
  t AS (SELECT 1 AS n UNION ALL SELECT n FROM t_other
    {{INNER|LEFT|RIGHT|FULL OUTER}} JOIN {{t|(SELECT * FROM t)}} USING (n))
SELECT * FROM t;
--
ALTERNATION GROUP: INNER,t
--
QueryStmt
+-output_column_list=
| +-t.n#6 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#6]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t_other"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.n#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.n#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.n#1
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t_other.n#4]
    |           |   +-input_scan=
    |           |     +-JoinScan
    |           |       +-column_list=[t_other.n#4, t.n#5]
    |           |       +-left_scan=
    |           |       | +-WithRefScan(column_list=[t_other.n#4], with_query_name="t_other")
    |           |       +-right_scan=
    |           |       | +-RecursiveRefScan(column_list=[t.n#5])
    |           |       +-join_expr=
    |           |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t_other.n#4)
    |           |           +-ColumnRef(type=INT64, column=t.n#5)
    |           +-output_column_list=[t_other.n#4]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#6]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#6], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: INNER,(SELECT * FROM t)
--
QueryStmt
+-output_column_list=
| +-t.n#6 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#6]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t_other"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.n#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.n#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.n#1
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t_other.n#4]
    |           |   +-input_scan=
    |           |     +-JoinScan
    |           |       +-column_list=[t_other.n#4, t.n#5]
    |           |       +-left_scan=
    |           |       | +-WithRefScan(column_list=[t_other.n#4], with_query_name="t_other")
    |           |       +-right_scan=
    |           |       | +-ProjectScan
    |           |       |   +-column_list=[t.n#5]
    |           |       |   +-input_scan=
    |           |       |     +-RecursiveRefScan(column_list=[t.n#5])
    |           |       +-join_expr=
    |           |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t_other.n#4)
    |           |           +-ColumnRef(type=INT64, column=t.n#5)
    |           +-output_column_list=[t_other.n#4]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#6]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#6], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: LEFT,t
--
ERROR: A query containing a recursive reference may not be used as the right operand of a LEFT JOIN [at 4:15]
    LEFT JOIN t USING (n))
              ^
--
ALTERNATION GROUP: LEFT,(SELECT * FROM t)
--
ERROR: A query containing a recursive reference may not be used as the right operand of a LEFT JOIN [at 4:30]
    LEFT JOIN (SELECT * FROM t) USING (n))
                             ^
--
ALTERNATION GROUP: RIGHT,t
--
QueryStmt
+-output_column_list=
| +-t.n#6 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#6]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t_other"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.n#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.n#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.n#1
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t.n#5]
    |           |   +-input_scan=
    |           |     +-JoinScan
    |           |       +-column_list=[t_other.n#4, t.n#5]
    |           |       +-join_type=RIGHT
    |           |       +-left_scan=
    |           |       | +-WithRefScan(column_list=[t_other.n#4], with_query_name="t_other")
    |           |       +-right_scan=
    |           |       | +-RecursiveRefScan(column_list=[t.n#5])
    |           |       +-join_expr=
    |           |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t_other.n#4)
    |           |           +-ColumnRef(type=INT64, column=t.n#5)
    |           +-output_column_list=[t.n#5]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#6]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#6], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: RIGHT,(SELECT * FROM t)
--
QueryStmt
+-output_column_list=
| +-t.n#6 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#6]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t_other"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.n#1]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.n#1]
    | |         +-array_expr=
    | |         | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 4])
    | |         +-element_column=$array.n#1
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[t.n#5]
    |           |   +-input_scan=
    |           |     +-JoinScan
    |           |       +-column_list=[t_other.n#4, t.n#5]
    |           |       +-join_type=RIGHT
    |           |       +-left_scan=
    |           |       | +-WithRefScan(column_list=[t_other.n#4], with_query_name="t_other")
    |           |       +-right_scan=
    |           |       | +-ProjectScan
    |           |       |   +-column_list=[t.n#5]
    |           |       |   +-input_scan=
    |           |       |     +-RecursiveRefScan(column_list=[t.n#5])
    |           |       +-join_expr=
    |           |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t_other.n#4)
    |           |           +-ColumnRef(type=INT64, column=t.n#5)
    |           +-output_column_list=[t.n#5]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#6]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#6], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: FULL OUTER,t
--
ERROR: A query containing a recursive reference may not be used as an operand of a FULL OUTER JOIN [at 4:21]
    FULL OUTER JOIN t USING (n))
                    ^
--
ALTERNATION GROUP: FULL OUTER,(SELECT * FROM t)
--
ERROR: A query containing a recursive reference may not be used as an operand of a FULL OUTER JOIN [at 4:36]
    FULL OUTER JOIN (SELECT * FROM t) USING (n))
                                   ^
==

# ERROR: Recursive reference used on ON expression for join
# (Make sure that checks for recursive references in subquery still happen
#  inside the ON clause of a join).
WITH RECURSIVE
  t_other1 AS (SELECT * FROM UNNEST([1,2,3,4]) AS n1),
  t_other2 AS (SELECT * FROM UNNEST([5,6,7,8]) AS n2),
  t AS (SELECT 1 AS n UNION ALL SELECT n1 FROM t_other1
    INNER JOIN t_other2 ON (SELECT n FROM t) = 1)
SELECT * FROM t;
--
ERROR: A recursive reference from inside an expression subquery is not allowed [at 5:43]
    INNER JOIN t_other2 ON (SELECT n FROM t) = 1)
                                          ^
==

# Recursive query featuring an inner (non-recursive) WITH clause.
# Make sure the inner WITH entries can be referenced from both the recursive and
# non-recursive term.
WITH RECURSIVE a AS (
  WITH
    unused AS (SELECT 5),
    b AS (SELECT 1 AS n)
  (SELECT n FROM b)
  UNION ALL
  (SELECT a.n + 1 FROM a CROSS JOIN b)
) SELECT * FROM a;
--
QueryStmt
+-output_column_list=
| +-a.n#8 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[a.n#8]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="a"
    |   +-with_subquery=
    |     +-WithScan
    |       +-column_list=[$union_all.n#4]
    |       +-with_entry_list=
    |       | +-WithEntry
    |       | | +-with_query_name="unused"
    |       | | +-with_subquery=
    |       | |   +-ProjectScan
    |       | |     +-column_list=[unused.$col1#1]
    |       | |     +-expr_list=
    |       | |     | +-$col1#1 := Literal(type=INT64, value=5)
    |       | |     +-input_scan=
    |       | |       +-SingleRowScan
    |       | +-WithEntry
    |       |   +-with_query_name="b"
    |       |   +-with_subquery=
    |       |     +-ProjectScan
    |       |       +-column_list=[b.n#2]
    |       |       +-expr_list=
    |       |       | +-n#2 := Literal(type=INT64, value=1)
    |       |       +-input_scan=
    |       |         +-SingleRowScan
    |       +-query=
    |         +-RecursiveScan
    |           +-column_list=[$union_all.n#4]
    |           +-op_type=UNION_ALL
    |           +-non_recursive_term=
    |           | +-SetOperationItem
    |           |   +-scan=
    |           |   | +-ProjectScan
    |           |   |   +-column_list=[b.n#3]
    |           |   |   +-input_scan=
    |           |   |     +-WithRefScan(column_list=[b.n#3], with_query_name="b")
    |           |   +-output_column_list=[b.n#3]
    |           +-recursive_term=
    |             +-SetOperationItem
    |               +-scan=
    |               | +-ProjectScan
    |               |   +-column_list=[$union_all2.$col1#7]
    |               |   +-expr_list=
    |               |   | +-$col1#7 :=
    |               |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |               |   |     +-ColumnRef(type=INT64, column=a.n#5)
    |               |   |     +-Literal(type=INT64, value=1)
    |               |   +-input_scan=
    |               |     +-JoinScan
    |               |       +-column_list=[a.n#5, b.n#6]
    |               |       +-left_scan=
    |               |       | +-RecursiveRefScan(column_list=[a.n#5])
    |               |       +-right_scan=
    |               |         +-WithRefScan(column_list=[b.n#6], with_query_name="b")
    |               +-output_column_list=[$union_all2.$col1#7]
    +-query=
    | +-ProjectScan
    |   +-column_list=[a.n#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[a.n#8], with_query_name="a")
    +-recursive=TRUE
==

# Similar to the above, but the inner WITH clause is marked as RECURSIVE,
# but still not actually recursive.
WITH RECURSIVE a AS (
  WITH RECURSIVE
    unused AS (SELECT 5),
    b AS (SELECT 1 AS n)
  (SELECT n FROM b)
  UNION ALL
  (SELECT a.n + 1 FROM a CROSS JOIN b)
) SELECT * FROM a;
--
QueryStmt
+-output_column_list=
| +-a.n#8 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[a.n#8]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="a"
    |   +-with_subquery=
    |     +-WithScan
    |       +-column_list=[$union_all.n#4]
    |       +-with_entry_list=
    |       | +-WithEntry
    |       | | +-with_query_name="b"
    |       | | +-with_subquery=
    |       | |   +-ProjectScan
    |       | |     +-column_list=[b.n#1]
    |       | |     +-expr_list=
    |       | |     | +-n#1 := Literal(type=INT64, value=1)
    |       | |     +-input_scan=
    |       | |       +-SingleRowScan
    |       | +-WithEntry
    |       |   +-with_query_name="unused"
    |       |   +-with_subquery=
    |       |     +-ProjectScan
    |       |       +-column_list=[unused.$col1#2]
    |       |       +-expr_list=
    |       |       | +-$col1#2 := Literal(type=INT64, value=5)
    |       |       +-input_scan=
    |       |         +-SingleRowScan
    |       +-query=
    |       | +-RecursiveScan
    |       |   +-column_list=[$union_all.n#4]
    |       |   +-op_type=UNION_ALL
    |       |   +-non_recursive_term=
    |       |   | +-SetOperationItem
    |       |   |   +-scan=
    |       |   |   | +-ProjectScan
    |       |   |   |   +-column_list=[b.n#3]
    |       |   |   |   +-input_scan=
    |       |   |   |     +-WithRefScan(column_list=[b.n#3], with_query_name="b")
    |       |   |   +-output_column_list=[b.n#3]
    |       |   +-recursive_term=
    |       |     +-SetOperationItem
    |       |       +-scan=
    |       |       | +-ProjectScan
    |       |       |   +-column_list=[$union_all2.$col1#7]
    |       |       |   +-expr_list=
    |       |       |   | +-$col1#7 :=
    |       |       |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       |       |   |     +-ColumnRef(type=INT64, column=a.n#5)
    |       |       |   |     +-Literal(type=INT64, value=1)
    |       |       |   +-input_scan=
    |       |       |     +-JoinScan
    |       |       |       +-column_list=[a.n#5, b.n#6]
    |       |       |       +-left_scan=
    |       |       |       | +-RecursiveRefScan(column_list=[a.n#5])
    |       |       |       +-right_scan=
    |       |       |         +-WithRefScan(column_list=[b.n#6], with_query_name="b")
    |       |       +-output_column_list=[$union_all2.$col1#7]
    |       +-recursive=TRUE
    +-query=
    | +-ProjectScan
    |   +-column_list=[a.n#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[a.n#8], with_query_name="a")
    +-recursive=TRUE
==

# Similar to the above, but this time, the inner WITH query is actually
# recursive.
WITH RECURSIVE a AS (
  WITH RECURSIVE
    unused AS (SELECT 5),
    b AS (SELECT 1 AS n UNION ALL SELECT n + 1 FROM b WHERE n < 5)
  (SELECT n FROM b)
  UNION ALL
  (SELECT a.n + 1 FROM a CROSS JOIN b)
) SELECT * FROM a;
--
QueryStmt
+-output_column_list=
| +-a.n#11 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[a.n#11]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="a"
    |   +-with_subquery=
    |     +-WithScan
    |       +-column_list=[$union_all.n#7]
    |       +-with_entry_list=
    |       | +-WithEntry
    |       | | +-with_query_name="b"
    |       | | +-with_subquery=
    |       | |   +-RecursiveScan
    |       | |     +-column_list=[$union_all.n#2]
    |       | |     +-op_type=UNION_ALL
    |       | |     +-non_recursive_term=
    |       | |     | +-SetOperationItem
    |       | |     |   +-scan=
    |       | |     |   | +-ProjectScan
    |       | |     |   |   +-column_list=[$union_all1.n#1]
    |       | |     |   |   +-expr_list=
    |       | |     |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       | |     |   |   +-input_scan=
    |       | |     |   |     +-SingleRowScan
    |       | |     |   +-output_column_list=[$union_all1.n#1]
    |       | |     +-recursive_term=
    |       | |       +-SetOperationItem
    |       | |         +-scan=
    |       | |         | +-ProjectScan
    |       | |         |   +-column_list=[$union_all2.$col1#4]
    |       | |         |   +-expr_list=
    |       | |         |   | +-$col1#4 :=
    |       | |         |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       | |         |   |     +-ColumnRef(type=INT64, column=b.n#3)
    |       | |         |   |     +-Literal(type=INT64, value=1)
    |       | |         |   +-input_scan=
    |       | |         |     +-FilterScan
    |       | |         |       +-column_list=[b.n#3]
    |       | |         |       +-input_scan=
    |       | |         |       | +-RecursiveRefScan(column_list=[b.n#3])
    |       | |         |       +-filter_expr=
    |       | |         |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |       | |         |           +-ColumnRef(type=INT64, column=b.n#3)
    |       | |         |           +-Literal(type=INT64, value=5)
    |       | |         +-output_column_list=[$union_all2.$col1#4]
    |       | +-WithEntry
    |       |   +-with_query_name="unused"
    |       |   +-with_subquery=
    |       |     +-ProjectScan
    |       |       +-column_list=[unused.$col1#5]
    |       |       +-expr_list=
    |       |       | +-$col1#5 := Literal(type=INT64, value=5)
    |       |       +-input_scan=
    |       |         +-SingleRowScan
    |       +-query=
    |       | +-RecursiveScan
    |       |   +-column_list=[$union_all.n#7]
    |       |   +-op_type=UNION_ALL
    |       |   +-non_recursive_term=
    |       |   | +-SetOperationItem
    |       |   |   +-scan=
    |       |   |   | +-ProjectScan
    |       |   |   |   +-column_list=[b.n#6]
    |       |   |   |   +-input_scan=
    |       |   |   |     +-WithRefScan(column_list=[b.n#6], with_query_name="b")
    |       |   |   +-output_column_list=[b.n#6]
    |       |   +-recursive_term=
    |       |     +-SetOperationItem
    |       |       +-scan=
    |       |       | +-ProjectScan
    |       |       |   +-column_list=[$union_all2.$col1#10]
    |       |       |   +-expr_list=
    |       |       |   | +-$col1#10 :=
    |       |       |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       |       |   |     +-ColumnRef(type=INT64, column=a.n#8)
    |       |       |   |     +-Literal(type=INT64, value=1)
    |       |       |   +-input_scan=
    |       |       |     +-JoinScan
    |       |       |       +-column_list=[a.n#8, b.n#9]
    |       |       |       +-left_scan=
    |       |       |       | +-RecursiveRefScan(column_list=[a.n#8])
    |       |       |       +-right_scan=
    |       |       |         +-WithRefScan(column_list=[b.n#9], with_query_name="b")
    |       |       +-output_column_list=[$union_all2.$col1#10]
    |       +-recursive=TRUE
    +-query=
    | +-ProjectScan
    |   +-column_list=[a.n#11]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[a.n#11], with_query_name="a")
    +-recursive=TRUE
==

# ERROR: Using inner WITH entry in recursive WITH, after it has gone out of
# scope
WITH RECURSIVE a AS (
  WITH RECURSIVE
    b AS (SELECT 1 AS n UNION ALL SELECT n + 1 FROM b WHERE n < 5)
  (SELECT n FROM b)
  UNION ALL
  (SELECT a.n + 1 FROM a CROSS JOIN b)
) SELECT * FROM a CROSS JOIN b;
--
ERROR: Table not found: b [at 7:30]
) SELECT * FROM a CROSS JOIN b;
                             ^
==

# ERROR: Inner WITH entry referencing outer WITH entry containing it
WITH RECURSIVE a AS (
  WITH RECURSIVE
    b AS (SELECT 1 AS n UNION ALL SELECT b.n + 1 FROM a CROSS JOIN b)
  (SELECT n FROM b)
  UNION ALL
  (SELECT a.n + 1 FROM a CROSS JOIN b)
) SELECT * FROM a;
--
ERROR: Table not found: a [at 3:55]
    b AS (SELECT 1 AS n UNION ALL SELECT b.n + 1 FROM a CROSS JOIN b)
                                                      ^
==

# An inner WITH entry may reference other entries from the outer WITH
WITH RECURSIVE
  a0 AS (SELECT 1 AS n),
  a AS (
  WITH
    unused AS (SELECT 5),
    b AS (SELECT n + 1 AS n FROM a0)
  (SELECT n FROM b)
  UNION ALL
  (SELECT a.n + 1 FROM a CROSS JOIN b)
) SELECT * FROM a;
--
QueryStmt
+-output_column_list=
| +-a.n#10 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[a.n#10]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="a0"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[a0.n#1]
    | |     +-expr_list=
    | |     | +-n#1 := Literal(type=INT64, value=1)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name="a"
    |   +-with_subquery=
    |     +-WithScan
    |       +-column_list=[$union_all.n#6]
    |       +-with_entry_list=
    |       | +-WithEntry
    |       | | +-with_query_name="unused"
    |       | | +-with_subquery=
    |       | |   +-ProjectScan
    |       | |     +-column_list=[unused.$col1#2]
    |       | |     +-expr_list=
    |       | |     | +-$col1#2 := Literal(type=INT64, value=5)
    |       | |     +-input_scan=
    |       | |       +-SingleRowScan
    |       | +-WithEntry
    |       |   +-with_query_name="b"
    |       |   +-with_subquery=
    |       |     +-ProjectScan
    |       |       +-column_list=[b.n#4]
    |       |       +-expr_list=
    |       |       | +-n#4 :=
    |       |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       |       |     +-ColumnRef(type=INT64, column=a0.n#3)
    |       |       |     +-Literal(type=INT64, value=1)
    |       |       +-input_scan=
    |       |         +-WithRefScan(column_list=[a0.n#3], with_query_name="a0")
    |       +-query=
    |         +-RecursiveScan
    |           +-column_list=[$union_all.n#6]
    |           +-op_type=UNION_ALL
    |           +-non_recursive_term=
    |           | +-SetOperationItem
    |           |   +-scan=
    |           |   | +-ProjectScan
    |           |   |   +-column_list=[b.n#5]
    |           |   |   +-input_scan=
    |           |   |     +-WithRefScan(column_list=[b.n#5], with_query_name="b")
    |           |   +-output_column_list=[b.n#5]
    |           +-recursive_term=
    |             +-SetOperationItem
    |               +-scan=
    |               | +-ProjectScan
    |               |   +-column_list=[$union_all2.$col1#9]
    |               |   +-expr_list=
    |               |   | +-$col1#9 :=
    |               |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |               |   |     +-ColumnRef(type=INT64, column=a.n#7)
    |               |   |     +-Literal(type=INT64, value=1)
    |               |   +-input_scan=
    |               |     +-JoinScan
    |               |       +-column_list=[a.n#7, b.n#8]
    |               |       +-left_scan=
    |               |       | +-RecursiveRefScan(column_list=[a.n#7])
    |               |       +-right_scan=
    |               |         +-WithRefScan(column_list=[b.n#8], with_query_name="b")
    |               +-output_column_list=[$union_all2.$col1#9]
    +-query=
    | +-ProjectScan
    |   +-column_list=[a.n#10]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[a.n#10], with_query_name="a")
    +-recursive=TRUE
==

# An inner WITH entry may reference other entries from the outer WITH
# (This is simmilar to the above, but the order of entries in the other WITH
#  reversed; this ensures that the dependency analyzer notices that 'a' depends
# on 'a0'.
WITH RECURSIVE
  a AS (
  WITH
    unused AS (SELECT 5),
    b AS (SELECT n + 1 AS n FROM a0)
  (SELECT n FROM b)
  UNION ALL
    (SELECT a.n + 1 FROM a CROSS JOIN b)),
  a0 AS (SELECT 1 AS n)
SELECT * FROM a;
--
QueryStmt
+-output_column_list=
| +-a.n#10 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[a.n#10]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="a0"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[a0.n#1]
    | |     +-expr_list=
    | |     | +-n#1 := Literal(type=INT64, value=1)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name="a"
    |   +-with_subquery=
    |     +-WithScan
    |       +-column_list=[$union_all.n#6]
    |       +-with_entry_list=
    |       | +-WithEntry
    |       | | +-with_query_name="unused"
    |       | | +-with_subquery=
    |       | |   +-ProjectScan
    |       | |     +-column_list=[unused.$col1#2]
    |       | |     +-expr_list=
    |       | |     | +-$col1#2 := Literal(type=INT64, value=5)
    |       | |     +-input_scan=
    |       | |       +-SingleRowScan
    |       | +-WithEntry
    |       |   +-with_query_name="b"
    |       |   +-with_subquery=
    |       |     +-ProjectScan
    |       |       +-column_list=[b.n#4]
    |       |       +-expr_list=
    |       |       | +-n#4 :=
    |       |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       |       |     +-ColumnRef(type=INT64, column=a0.n#3)
    |       |       |     +-Literal(type=INT64, value=1)
    |       |       +-input_scan=
    |       |         +-WithRefScan(column_list=[a0.n#3], with_query_name="a0")
    |       +-query=
    |         +-RecursiveScan
    |           +-column_list=[$union_all.n#6]
    |           +-op_type=UNION_ALL
    |           +-non_recursive_term=
    |           | +-SetOperationItem
    |           |   +-scan=
    |           |   | +-ProjectScan
    |           |   |   +-column_list=[b.n#5]
    |           |   |   +-input_scan=
    |           |   |     +-WithRefScan(column_list=[b.n#5], with_query_name="b")
    |           |   +-output_column_list=[b.n#5]
    |           +-recursive_term=
    |             +-SetOperationItem
    |               +-scan=
    |               | +-ProjectScan
    |               |   +-column_list=[$union_all2.$col1#9]
    |               |   +-expr_list=
    |               |   | +-$col1#9 :=
    |               |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |               |   |     +-ColumnRef(type=INT64, column=a.n#7)
    |               |   |     +-Literal(type=INT64, value=1)
    |               |   +-input_scan=
    |               |     +-JoinScan
    |               |       +-column_list=[a.n#7, b.n#8]
    |               |       +-left_scan=
    |               |       | +-RecursiveRefScan(column_list=[a.n#7])
    |               |       +-right_scan=
    |               |         +-WithRefScan(column_list=[b.n#8], with_query_name="b")
    |               +-output_column_list=[$union_all2.$col1#9]
    +-query=
    | +-ProjectScan
    |   +-column_list=[a.n#10]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[a.n#10], with_query_name="a")
    +-recursive=TRUE
==

# ERROR: Cyclic dependency graph caused by inner WITH on recursive query
WITH RECURSIVE
  a AS (
  WITH
    unused AS (SELECT 5),
    b AS (SELECT n + 1 AS n FROM a0)
  (SELECT n FROM b)
  UNION ALL
    (SELECT a.n + 1 FROM a CROSS JOIN b)),
  a0 AS (SELECT 1 AS n FROM a)
SELECT * FROM a;
--
ERROR: Unsupported WITH entry dependency cycle: a0 => a => a0 [at 1:1]
WITH RECURSIVE
^
==

# Correlated references to columns in outer query are not allowed in a WITH
# entry; make sure this remains prohibited when the WITH entry is recursive.
SELECT (WITH RECURSIVE t AS (SELECT n AS t_n) SELECT t_n) FROM (
  SELECT 1 AS n
);
--
ERROR: Unrecognized name: n [at 1:37]
SELECT (WITH RECURSIVE t AS (SELECT n AS t_n) SELECT t_n) FROM (
                                    ^
==

# Similar to above, but with entry is actually recursive and correlated column
# is referenced from non-recursive term.
SELECT (
  WITH RECURSIVE t AS (
    SELECT n AS t_n UNION ALL SELECT t_n FROM t
  ) SELECT t_n)
FROM (
  SELECT 1 AS n
);
--
ERROR: Unrecognized name: n [at 3:12]
    SELECT n AS t_n UNION ALL SELECT t_n FROM t
           ^
==

# Similar to above, but with entry is actually recursive and correlated column
# is referenced from recursive term.
SELECT (
  WITH RECURSIVE t AS (
    SELECT 1 AS t_n UNION ALL SELECT n + t_n FROM t
  ) SELECT t_n)
FROM (
  SELECT 1 AS n
);
--
ERROR: Unrecognized name: n [at 3:38]
    SELECT 1 AS t_n UNION ALL SELECT n + t_n FROM t
                                     ^
==

# b/191155790: Recursive reference in EXCEPT clause
WITH RECURSIVE
  t0 AS (SELECT 1 AS n),
  t1 AS (SELECT 1 AS n),
  t AS ((SELECT 1 AS n)
  UNION ALL
  (SELECT n + 1 FROM t0
   EXCEPT {{ALL|DISTINCT}} SELECT * FROM t))
SELECT * FROM t;
--
ALTERNATION GROUP: ALL
--
ERROR: A subquery containing a recursive reference may not be used as the right operand of EXCEPT [at 7:29]
   EXCEPT ALL SELECT * FROM t))
                            ^
--
ALTERNATION GROUP: DISTINCT
--
ERROR: A subquery containing a recursive reference may not use INTERSECT, UNION, or EXCEPT with the DISTINCT modifier [at 7:34]
   EXCEPT DISTINCT SELECT * FROM t))
                                 ^
==

# b/191155790: Recursive reference in EXCEPT clause - multiple EXCEPT's
WITH RECURSIVE
  t0 AS (SELECT 1 AS n),
  t1 AS (SELECT 1 AS n),
  t AS ((SELECT 1 AS n)
  UNION ALL
  (SELECT n + 1 FROM t0
   EXCEPT ALL SELECT n + 1 FROM t1
   EXCEPT ALL SELECT * FROM t))
SELECT * FROM t;
--
ERROR: A subquery containing a recursive reference may not be used as the right operand of EXCEPT [at 8:29]
   EXCEPT ALL SELECT * FROM t))
                            ^
==

# b/191155790: Recursive reference in lhs of EXCEPT clause is ok
WITH RECURSIVE
  t0 AS (SELECT 1 AS n),
  t1 AS (SELECT 1 AS n),
  t AS ((SELECT 1 AS n)
  UNION ALL
  (SELECT n + 1 FROM t
   EXCEPT {{ALL|DISTINCT}} SELECT n + 1 FROM t0))
SELECT * FROM t;
--
ALTERNATION GROUP: ALL
--
QueryStmt
+-output_column_list=
| +-t.n#10 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#10]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t0"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[t0.n#1]
    | |     +-expr_list=
    | |     | +-n#1 := Literal(type=INT64, value=1)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    | | +-with_query_name="t"
    | | +-with_subquery=
    | |   +-RecursiveScan
    | |     +-column_list=[$union_all.n#3]
    | |     +-op_type=UNION_ALL
    | |     +-non_recursive_term=
    | |     | +-SetOperationItem
    | |     |   +-scan=
    | |     |   | +-ProjectScan
    | |     |   |   +-column_list=[$union_all1.n#2]
    | |     |   |   +-expr_list=
    | |     |   |   | +-n#2 := Literal(type=INT64, value=1)
    | |     |   |   +-input_scan=
    | |     |   |     +-SingleRowScan
    | |     |   +-output_column_list=[$union_all1.n#2]
    | |     +-recursive_term=
    | |       +-SetOperationItem
    | |         +-scan=
    | |         | +-SetOperationScan
    | |         |   +-column_list=[$except_all.$col1#8]
    | |         |   +-op_type=EXCEPT_ALL
    | |         |   +-input_item_list=
    | |         |     +-SetOperationItem
    | |         |     | +-scan=
    | |         |     | | +-ProjectScan
    | |         |     | |   +-column_list=[$except_all1.$col1#5]
    | |         |     | |   +-expr_list=
    | |         |     | |   | +-$col1#5 :=
    | |         |     | |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |         |     | |   |     +-ColumnRef(type=INT64, column=t.n#4)
    | |         |     | |   |     +-Literal(type=INT64, value=1)
    | |         |     | |   +-input_scan=
    | |         |     | |     +-RecursiveRefScan(column_list=[t.n#4])
    | |         |     | +-output_column_list=[$except_all1.$col1#5]
    | |         |     +-SetOperationItem
    | |         |       +-scan=
    | |         |       | +-ProjectScan
    | |         |       |   +-column_list=[$except_all2.$col1#7]
    | |         |       |   +-expr_list=
    | |         |       |   | +-$col1#7 :=
    | |         |       |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |         |       |   |     +-ColumnRef(type=INT64, column=t0.n#6)
    | |         |       |   |     +-Literal(type=INT64, value=1)
    | |         |       |   +-input_scan=
    | |         |       |     +-WithRefScan(column_list=[t0.n#6], with_query_name="t0")
    | |         |       +-output_column_list=[$except_all2.$col1#7]
    | |         +-output_column_list=[$except_all.$col1#8]
    | +-WithEntry
    |   +-with_query_name="t1"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t1.n#9]
    |       +-expr_list=
    |       | +-n#9 := Literal(type=INT64, value=1)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#10]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#10], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: DISTINCT
--
ERROR: A subquery containing a recursive reference may not use INTERSECT, UNION, or EXCEPT with the DISTINCT modifier [at 6:22]
  (SELECT n + 1 FROM t
                     ^
==

# b/191155790: Other unsupported cases in lhs of EXCEPT clause are still detected
WITH RECURSIVE
  t0 AS (SELECT 1 AS n),
  t1 AS (SELECT 1 AS n),
  t AS ((SELECT 1 AS n)
  UNION ALL
  (SELECT n + 1 FROM (SELECT t_1.n FROM t t_1 CROSS JOIN t t_2)
   EXCEPT {{ALL|DISTINCT}} SELECT n + 1 FROM t0))
SELECT * FROM t;
--
ALTERNATION GROUP: ALL
--
ERROR: Multiple recursive references to table 't' are not allowed [at 6:58]
  (SELECT n + 1 FROM (SELECT t_1.n FROM t t_1 CROSS JOIN t t_2)
                                                         ^
--
ALTERNATION GROUP: DISTINCT
--
ERROR: A subquery containing a recursive reference may not use INTERSECT, UNION, or EXCEPT with the DISTINCT modifier [at 6:41]
  (SELECT n + 1 FROM (SELECT t_1.n FROM t t_1 CROSS JOIN t t_2)
                                        ^
==

# b/191168292: Recursive term in rhs operand of
# INTERSECT/UNION DISTINCT is not allowed
# (but is allowed in INTERSECT ALL).
WITH RECURSIVE
  t0 AS (SELECT 1 as n),
  t AS ((SELECT 1 as n)
  UNION ALL (
    SELECT n + 1 from (
        (SELECT * FROM t0) {{INTERSECT|UNION}} {{ALL|DISTINCT}} (SELECT * FROM t))
    WHERE n < 5))
SELECT * from t;
--
ALTERNATION GROUP: INTERSECT,ALL
--
QueryStmt
+-output_column_list=
| +-t.n#8 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t0"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[t0.n#1]
    | |     +-expr_list=
    | |     | +-n#1 := Literal(type=INT64, value=1)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#7]
    |           |   +-expr_list=
    |           |   | +-$col1#7 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=$intersect_all.n#6)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=[$intersect_all.n#6]
    |           |       +-input_scan=
    |           |       | +-SetOperationScan
    |           |       |   +-column_list=[$intersect_all.n#6]
    |           |       |   +-op_type=INTERSECT_ALL
    |           |       |   +-input_item_list=
    |           |       |     +-SetOperationItem
    |           |       |     | +-scan=
    |           |       |     | | +-ProjectScan
    |           |       |     | |   +-column_list=[t0.n#4]
    |           |       |     | |   +-input_scan=
    |           |       |     | |     +-WithRefScan(column_list=[t0.n#4], with_query_name="t0")
    |           |       |     | +-output_column_list=[t0.n#4]
    |           |       |     +-SetOperationItem
    |           |       |       +-scan=
    |           |       |       | +-ProjectScan
    |           |       |       |   +-column_list=[t.n#5]
    |           |       |       |   +-input_scan=
    |           |       |       |     +-RecursiveRefScan(column_list=[t.n#5])
    |           |       |       +-output_column_list=[t.n#5]
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=$intersect_all.n#6)
    |           |           +-Literal(type=INT64, value=5)
    |           +-output_column_list=[$union_all2.$col1#7]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#8], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: INTERSECT,DISTINCT
--
ERROR: A subquery containing a recursive reference may not use INTERSECT, UNION, or EXCEPT with the DISTINCT modifier [at 6:62]
        (SELECT * FROM t0) INTERSECT DISTINCT (SELECT * FROM t))
                                                             ^
--
ALTERNATION GROUP: UNION,ALL
--
QueryStmt
+-output_column_list=
| +-t.n#8 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t0"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[t0.n#1]
    | |     +-expr_list=
    | |     | +-n#1 := Literal(type=INT64, value=1)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#7]
    |           |   +-expr_list=
    |           |   | +-$col1#7 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=$union_all.n#6)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=[$union_all.n#6]
    |           |       +-input_scan=
    |           |       | +-SetOperationScan
    |           |       |   +-column_list=[$union_all.n#6]
    |           |       |   +-op_type=UNION_ALL
    |           |       |   +-input_item_list=
    |           |       |     +-SetOperationItem
    |           |       |     | +-scan=
    |           |       |     | | +-ProjectScan
    |           |       |     | |   +-column_list=[t0.n#4]
    |           |       |     | |   +-input_scan=
    |           |       |     | |     +-WithRefScan(column_list=[t0.n#4], with_query_name="t0")
    |           |       |     | +-output_column_list=[t0.n#4]
    |           |       |     +-SetOperationItem
    |           |       |       +-scan=
    |           |       |       | +-ProjectScan
    |           |       |       |   +-column_list=[t.n#5]
    |           |       |       |   +-input_scan=
    |           |       |       |     +-RecursiveRefScan(column_list=[t.n#5])
    |           |       |       +-output_column_list=[t.n#5]
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=$union_all.n#6)
    |           |           +-Literal(type=INT64, value=5)
    |           +-output_column_list=[$union_all2.$col1#7]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#8], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: UNION,DISTINCT
--
ERROR: A subquery containing a recursive reference may not use INTERSECT, UNION, or EXCEPT with the DISTINCT modifier [at 6:58]
        (SELECT * FROM t0) UNION DISTINCT (SELECT * FROM t))
                                                         ^
==

# Similar to above, but with recursive reference in lhs of INTERSECT and UNION.
WITH RECURSIVE
  t0 AS (SELECT 1 as n),
  t AS ((SELECT 1 as n)
  UNION ALL (
    SELECT n + 1 from (
        (SELECT * FROM t) {{INTERSECT|UNION}} {{ALL|DISTINCT}} (SELECT * FROM t0))
    WHERE n < 5))
SELECT * from t;
--
ALTERNATION GROUP: INTERSECT,ALL
--
QueryStmt
+-output_column_list=
| +-t.n#8 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t0"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[t0.n#1]
    | |     +-expr_list=
    | |     | +-n#1 := Literal(type=INT64, value=1)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#7]
    |           |   +-expr_list=
    |           |   | +-$col1#7 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=$intersect_all.n#6)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=[$intersect_all.n#6]
    |           |       +-input_scan=
    |           |       | +-SetOperationScan
    |           |       |   +-column_list=[$intersect_all.n#6]
    |           |       |   +-op_type=INTERSECT_ALL
    |           |       |   +-input_item_list=
    |           |       |     +-SetOperationItem
    |           |       |     | +-scan=
    |           |       |     | | +-ProjectScan
    |           |       |     | |   +-column_list=[t.n#4]
    |           |       |     | |   +-input_scan=
    |           |       |     | |     +-RecursiveRefScan(column_list=[t.n#4])
    |           |       |     | +-output_column_list=[t.n#4]
    |           |       |     +-SetOperationItem
    |           |       |       +-scan=
    |           |       |       | +-ProjectScan
    |           |       |       |   +-column_list=[t0.n#5]
    |           |       |       |   +-input_scan=
    |           |       |       |     +-WithRefScan(column_list=[t0.n#5], with_query_name="t0")
    |           |       |       +-output_column_list=[t0.n#5]
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=$intersect_all.n#6)
    |           |           +-Literal(type=INT64, value=5)
    |           +-output_column_list=[$union_all2.$col1#7]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#8], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: INTERSECT,DISTINCT
--
ERROR: A subquery containing a recursive reference may not use INTERSECT, UNION, or EXCEPT with the DISTINCT modifier [at 6:24]
        (SELECT * FROM t) INTERSECT DISTINCT (SELECT * FROM t0))
                       ^
--
ALTERNATION GROUP: UNION,ALL
--
QueryStmt
+-output_column_list=
| +-t.n#8 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[t.n#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="t0"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[t0.n#1]
    | |     +-expr_list=
    | |     | +-n#1 := Literal(type=INT64, value=1)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#3]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#2]
    |       |   |   +-expr_list=
    |       |   |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#7]
    |           |   +-expr_list=
    |           |   | +-$col1#7 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=$union_all.n#6)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=[$union_all.n#6]
    |           |       +-input_scan=
    |           |       | +-SetOperationScan
    |           |       |   +-column_list=[$union_all.n#6]
    |           |       |   +-op_type=UNION_ALL
    |           |       |   +-input_item_list=
    |           |       |     +-SetOperationItem
    |           |       |     | +-scan=
    |           |       |     | | +-ProjectScan
    |           |       |     | |   +-column_list=[t.n#4]
    |           |       |     | |   +-input_scan=
    |           |       |     | |     +-RecursiveRefScan(column_list=[t.n#4])
    |           |       |     | +-output_column_list=[t.n#4]
    |           |       |     +-SetOperationItem
    |           |       |       +-scan=
    |           |       |       | +-ProjectScan
    |           |       |       |   +-column_list=[t0.n#5]
    |           |       |       |   +-input_scan=
    |           |       |       |     +-WithRefScan(column_list=[t0.n#5], with_query_name="t0")
    |           |       |       +-output_column_list=[t0.n#5]
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=$union_all.n#6)
    |           |           +-Literal(type=INT64, value=5)
    |           +-output_column_list=[$union_all2.$col1#7]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#8], with_query_name="t")
    +-recursive=TRUE
--
ALTERNATION GROUP: UNION,DISTINCT
--
ERROR: A subquery containing a recursive reference may not use INTERSECT, UNION, or EXCEPT with the DISTINCT modifier [at 6:24]
        (SELECT * FROM t) UNION DISTINCT (SELECT * FROM t0))
                       ^
==

# b/191168292: Similar to above, but with more than 2 INTERSECT operands
WITH RECURSIVE
  t0 AS (SELECT 1 as n),
  t1 AS (SELECT 1 as n),
  t AS ((SELECT 1 as n)
  UNION ALL (
    SELECT n + 1 from (
        (SELECT * FROM t0) INTERSECT DISTINCT (SELECT * FROM t1)
        INTERSECT DISTINCT (SELECT * FROM t))
    WHERE n < 5))
SELECT * from t;
--
ERROR: A subquery containing a recursive reference may not use INTERSECT, UNION, or EXCEPT with the DISTINCT modifier [at 8:43]
        INTERSECT DISTINCT (SELECT * FROM t))
                                          ^
==

# b/191168292: Similar to above, but with more than 2 UNION operands
WITH RECURSIVE
  t0 AS (SELECT 1 as n),
  t1 AS (SELECT 1 as n),
  t AS ((SELECT 1 as n)
  UNION ALL (
    SELECT n + 1 from (
        (SELECT * FROM t0) UNION DISTINCT (SELECT * FROM t1)
        UNION DISTINCT (SELECT * FROM t))
    WHERE n < 5))
SELECT * from t;
--
ERROR: A subquery containing a recursive reference may not use INTERSECT, UNION, or EXCEPT with the DISTINCT modifier [at 8:39]
        UNION DISTINCT (SELECT * FROM t))
                                      ^
