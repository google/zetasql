# DELETE
DELETE TestTable WHERE KitchenSink.int32_val = 1 THEN RETURN *
--

ERROR: THEN RETURN is not supported [at 1:50]
DELETE TestTable WHERE KitchenSink.int32_val = 1 THEN RETURN *
                                                 ^
==

# UPDATE
UPDATE KeyValue SET key=1, value="a" WHERE key > 10 THEN RETURN *
--
ERROR: THEN RETURN is not supported [at 1:53]
UPDATE KeyValue SET key=1, value="a" WHERE key > 10 THEN RETURN *
                                                    ^
==

# INSERT
[language_features=]
INSERT INTO KeyValue (key, value) VALUES (1, "one") THEN RETURN WITH ACTION *
--
ERROR: THEN RETURN is not supported [at 1:53]
INSERT INTO KeyValue (key, value) VALUES (1, "one") THEN RETURN WITH ACTION *
                                                    ^
==

DELETE FROM TestTable WHERE TRUE THEN RETURN WITH ACTION key as action, TestEnum
--
ERROR: THEN RETURN is not supported [at 1:34]
DELETE FROM TestTable WHERE TRUE THEN RETURN WITH ACTION key as action, TestEnum
                                 ^
==

DELETE FROM TestTable WHERE TRUE THEN RETURN WITH ACTION AS myaction key as myaction, TestEnum
--
ERROR: THEN RETURN is not supported [at 1:34]
DELETE FROM TestTable WHERE TRUE THEN RETURN WITH ACTION AS myaction key as m...
                                 ^
==

UPDATE KeyValue SET key=1 WHERE TRUE THEN RETURN WITH ACTION AS myaction key as myaction
--
ERROR: THEN RETURN is not supported [at 1:38]
UPDATE KeyValue SET key=1 WHERE TRUE THEN RETURN WITH ACTION AS myaction key ...
                                     ^
==

INSERT INTO KeyValue (key, value) VALUES (1, "one") THEN RETURN WITH ACTION AS myaction key as myaction;
--
ERROR: THEN RETURN is not supported [at 1:53]
INSERT INTO KeyValue (key, value) VALUES (1, "one") THEN RETURN WITH ACTION A...
                                                    ^
==

[default language_features=V_1_3_DML_RETURNING,V_1_1_SELECT_STAR_EXCEPT_REPLACE,DML_UPDATE_WITH_JOIN,V_1_3_PIVOT]
DELETE TestTable WHERE KitchenSink.int32_val = 1 THEN RETURN *
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-TestTable.key#1 AS key [INT32]
|     +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
|     +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-column_access_list=READ,READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    +-GetProtoField
    | +-type=INT32
    | +-expr=
    | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | +-field_descriptor=int32_val
    | +-default_value=77
    +-Literal(type=INT32, value=1)
==

DELETE TestTable WHERE KitchenSink.int32_val = 1 THEN RETURN WITH ACTION *
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-TestTable.key#1 AS key [INT32]
|   | +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
|   | +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
|   | +-$with_action.ACTION#4 AS ACTION [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.ACTION#4)
+-column_access_list=READ,READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    +-GetProtoField
    | +-type=INT32
    | +-expr=
    | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | +-field_descriptor=int32_val
    | +-default_value=77
    +-Literal(type=INT32, value=1)
==

DELETE TestTable WHERE KitchenSink.int32_val = 1 THEN RETURN WITH ACTION AS myaction *
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-TestTable.key#1 AS key [INT32]
|   | +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
|   | +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
|   | +-$with_action.myaction#4 AS myaction [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.myaction#4)
+-column_access_list=READ,READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    +-GetProtoField
    | +-type=INT32
    | +-expr=
    | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | +-field_descriptor=int32_val
    | +-default_value=77
    +-Literal(type=INT32, value=1)
==

DELETE TestTable WHERE KitchenSink.int32_val = 1 THEN RETURN key
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-TestTable.key#1 AS key [INT32]
+-column_access_list=READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    +-GetProtoField
    | +-type=INT32
    | +-expr=
    | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | +-field_descriptor=int32_val
    | +-default_value=77
    +-Literal(type=INT32, value=1)
==

DELETE TestTable WHERE KitchenSink.int32_val = 1 THEN RETURN WITH ACTION key+1 As newkey
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-TestTable.newkey#4 AS newkey [INT64]
|   | +-$with_action.ACTION#5 AS ACTION [STRING]
|   +-action_column=
|   | +-ColumnHolder(column=$with_action.ACTION#5)
|   +-expr_list=
|     +-newkey#4 :=
|       +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
|         +-Cast(INT32 -> INT64)
|         | +-ColumnRef(type=INT32, column=TestTable.key#1)
|         +-Literal(type=INT64, value=1)
+-column_access_list=READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    +-GetProtoField
    | +-type=INT32
    | +-expr=
    | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | +-field_descriptor=int32_val
    | +-default_value=77
    +-Literal(type=INT32, value=1)
==

DELETE TestTable WHERE KitchenSink.int32_val = 1
THEN RETURN WITH ACTION key+1 As newkey, TestEnum
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-TestTable.newkey#4 AS newkey [INT64]
|   | +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
|   | +-$with_action.ACTION#5 AS ACTION [STRING]
|   +-action_column=
|   | +-ColumnHolder(column=$with_action.ACTION#5)
|   +-expr_list=
|     +-newkey#4 :=
|       +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
|         +-Cast(INT32 -> INT64)
|         | +-ColumnRef(type=INT32, column=TestTable.key#1)
|         +-Literal(type=INT64, value=1)
+-column_access_list=READ,READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    +-GetProtoField
    | +-type=INT32
    | +-expr=
    | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | +-field_descriptor=int32_val
    | +-default_value=77
    +-Literal(type=INT32, value=1)
==

DELETE TestTable WHERE KitchenSink.int32_val = 1
THEN RETURN WITH ACTION AS action key+1 As newkey, TestEnum, abs(key) as abs_key
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-TestTable.newkey#4 AS newkey [INT64]
|   | +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
|   | +-TestTable.abs_key#5 AS abs_key [INT32]
|   | +-$with_action.action#6 AS action [STRING]
|   +-action_column=
|   | +-ColumnHolder(column=$with_action.action#6)
|   +-expr_list=
|     +-newkey#4 :=
|     | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
|     |   +-Cast(INT32 -> INT64)
|     |   | +-ColumnRef(type=INT32, column=TestTable.key#1)
|     |   +-Literal(type=INT64, value=1)
|     +-abs_key#5 :=
|       +-FunctionCall(ZetaSQL:abs(INT32) -> INT32)
|         +-ColumnRef(type=INT32, column=TestTable.key#1)
+-column_access_list=READ,READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    +-GetProtoField
    | +-type=INT32
    | +-expr=
    | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | +-field_descriptor=int32_val
    | +-default_value=77
    +-Literal(type=INT32, value=1)
==

DELETE TestTable WHERE KitchenSink.int32_val = 1
THEN RETURN WITH ACTION abs(key) abs_key, *
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-TestTable.abs_key#4 AS abs_key [INT32]
|   | +-TestTable.key#1 AS key [INT32]
|   | +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
|   | +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
|   | +-$with_action.ACTION#5 AS ACTION [STRING]
|   +-action_column=
|   | +-ColumnHolder(column=$with_action.ACTION#5)
|   +-expr_list=
|     +-abs_key#4 :=
|       +-FunctionCall(ZetaSQL:abs(INT32) -> INT32)
|         +-ColumnRef(type=INT32, column=TestTable.key#1)
+-column_access_list=READ,READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    +-GetProtoField
    | +-type=INT32
    | +-expr=
    | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | +-field_descriptor=int32_val
    | +-default_value=77
    +-Literal(type=INT32, value=1)
==

# UPDATE
UPDATE KeyValue SET key=1, value="a" WHERE key > 10 THEN RETURN *
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-column_access_list=READ_WRITE,READ_WRITE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Key#1 AS Key [INT64]
|     +-KeyValue.Value#2 AS Value [STRING]
+-where_expr=
| +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|   +-Literal(type=INT64, value=10)
+-update_item_list=
  +-UpdateItem
  | +-target=
  | | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
  | +-set_value=
  |   +-DMLValue
  |     +-value=
  |       +-Literal(type=INT64, value=1)
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-Literal(type=STRING, value="a")
==

UPDATE KeyValue SET value="a" WHERE key > 10 THEN RETURN WITH ACTION *
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-column_access_list=READ,READ_WRITE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS Key [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-$with_action.ACTION#3 AS ACTION [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.ACTION#3)
+-where_expr=
| +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|   +-Literal(type=INT64, value=10)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-Literal(type=STRING, value="a")
==

UPDATE KeyValue SET value="a" WHERE key > 10 THEN RETURN WITH ACTION AS myaction *
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-column_access_list=READ,READ_WRITE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS Key [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-$with_action.myaction#3 AS myaction [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.myaction#3)
+-where_expr=
| +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|   +-Literal(type=INT64, value=10)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-Literal(type=STRING, value="a")
==

UPDATE KeyValue SET value="a" WHERE key > 10 THEN RETURN key, value
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-column_access_list=READ,READ_WRITE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Key#1 AS key [INT64]
|     +-KeyValue.Value#2 AS value [STRING]
+-where_expr=
| +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|   +-Literal(type=INT64, value=10)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-Literal(type=STRING, value="a")

==

UPDATE KeyValue SET value="a" WHERE key > 10
THEN RETURN WITH ACTION abs(key) abs_key, *
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-column_access_list=READ,READ_WRITE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.abs_key#3 AS abs_key [INT64]
|   | +-KeyValue.Key#1 AS Key [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-$with_action.ACTION#4 AS ACTION [STRING]
|   +-action_column=
|   | +-ColumnHolder(column=$with_action.ACTION#4)
|   +-expr_list=
|     +-abs_key#3 :=
|       +-FunctionCall(ZetaSQL:abs(INT64) -> INT64)
|         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
+-where_expr=
| +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|   +-Literal(type=INT64, value=10)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-Literal(type=STRING, value="a")
==

INSERT INTO KeyValue (key, value) VALUES (1, "one") THEN RETURN *
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Key#1 AS Key [INT64]
|     +-KeyValue.Value#2 AS Value [STRING]
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=READ_WRITE,READ_WRITE
==

INSERT INTO KeyValue (key, value) VALUES (1, "one") THEN RETURN WITH ACTION *
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS Key [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-$with_action.ACTION#3 AS ACTION [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.ACTION#3)
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=READ_WRITE,READ_WRITE
==

INSERT INTO KeyValue (key, value) VALUES (1, "one")
THEN RETURN WITH ACTION AS myaction *
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS Key [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-$with_action.myaction#3 AS myaction [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.myaction#3)
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=READ_WRITE,READ_WRITE
==

INSERT INTO KeyValue (key, value) VALUES (1, "one") THEN RETURN key
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Key#1 AS key [INT64]
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=READ_WRITE,WRITE
==

INSERT INTO nested_catalog.KeyValueNested (key, value) VALUES (1, "one") THEN RETURN KeyValueNested.key
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValueNested.[Key#1, Value#2], table=nested_catalog.KeyValueNested, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValueNested.Key#1 AS key [INT64]
+-insert_column_list=KeyValueNested.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=READ_WRITE,WRITE
==

INSERT {{| IGNORE| REPLACE| UPDATE}} INTO KeyValue (key, value)
VALUES (1, "one"), (2, "two") THEN RETURN *
--

ALTERNATION GROUP: <empty>
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Key#1 AS Key [INT64]
|     +-KeyValue.Value#2 AS Value [STRING]
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=INT64, value=1)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=STRING, value="one")
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=2)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="two")
+-column_access_list=READ_WRITE,READ_WRITE
--
ALTERNATION GROUP:  IGNORE
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_mode=OR IGNORE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Key#1 AS Key [INT64]
|     +-KeyValue.Value#2 AS Value [STRING]
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=INT64, value=1)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=STRING, value="one")
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=2)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="two")
+-column_access_list=READ_WRITE,READ_WRITE
--
ALTERNATION GROUP:  REPLACE
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_mode=OR REPLACE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Key#1 AS Key [INT64]
|     +-KeyValue.Value#2 AS Value [STRING]
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=INT64, value=1)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=STRING, value="one")
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=2)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="two")
+-column_access_list=READ_WRITE,READ_WRITE
--
ALTERNATION GROUP:  UPDATE
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_mode=OR UPDATE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Key#1 AS Key [INT64]
|     +-KeyValue.Value#2 AS Value [STRING]
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=INT64, value=1)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=STRING, value="one")
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=2)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="two")
+-column_access_list=READ_WRITE,READ_WRITE
==

INSERT {{| IGNORE| REPLACE| UPDATE}} INTO KeyValue (key, value)
VALUES (1, "one"), (2, "two") THEN RETURN WITH ACTION *
--
ALTERNATION GROUP: <empty>

--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS Key [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-$with_action.ACTION#3 AS ACTION [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.ACTION#3)
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=INT64, value=1)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=STRING, value="one")
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=2)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="two")
+-column_access_list=READ_WRITE,READ_WRITE
--
ALTERNATION GROUP:  IGNORE
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_mode=OR IGNORE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS Key [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-$with_action.ACTION#3 AS ACTION [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.ACTION#3)
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=INT64, value=1)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=STRING, value="one")
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=2)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="two")
+-column_access_list=READ_WRITE,READ_WRITE
--
ALTERNATION GROUP:  REPLACE
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_mode=OR REPLACE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS Key [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-$with_action.ACTION#3 AS ACTION [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.ACTION#3)
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=INT64, value=1)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=STRING, value="one")
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=2)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="two")
+-column_access_list=READ_WRITE,READ_WRITE
--
ALTERNATION GROUP:  UPDATE
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_mode=OR UPDATE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS Key [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-$with_action.ACTION#3 AS ACTION [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.ACTION#3)
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=INT64, value=1)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=STRING, value="one")
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=2)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="two")
+-column_access_list=READ_WRITE,READ_WRITE
==

INSERT INTO KeyValue (key, value) VALUES (1, "one")
THEN RETURN WITH ACTION abs(key) as newkey
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.newkey#3 AS newkey [INT64]
|   | +-$with_action.ACTION#4 AS ACTION [STRING]
|   +-action_column=
|   | +-ColumnHolder(column=$with_action.ACTION#4)
|   +-expr_list=
|     +-newkey#3 :=
|       +-FunctionCall(ZetaSQL:abs(INT64) -> INT64)
|         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=READ_WRITE,WRITE
==

# Nest DMLs

UPDATE TestTable SET
  KitchenSink.int32_val = 1,
  (DELETE KitchenSink.repeated_int64_val
   WHERE repeated_int64_val = 1
   ASSERT_ROWS_MODIFIED 1 THEN RETURN *)
WHERE true
ASSERT_ROWS_MODIFIED 1
--
ERROR: THEN RETURN is not allowed in nested DELETE statements [at 5:27]
   ASSERT_ROWS_MODIFIED 1 THEN RETURN *)
                          ^
==

UPDATE TestTable SET
  KitchenSink.int32_val = 1,
  (DELETE KitchenSink.repeated_int64_val
   WHERE repeated_int64_val = 1
   ASSERT_ROWS_MODIFIED 1)
WHERE true
ASSERT_ROWS_MODIFIED 1
THEN RETURN WITH ACTION key, TestEnum
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
+-column_access_list=READ,READ,READ_WRITE
+-assert_rows_modified=
| +-AssertRowsModified
|   +-rows=
|     +-Literal(type=INT64, value=1)
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-TestTable.key#1 AS key [INT32]
|   | +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
|   | +-$with_action.ACTION#4 AS ACTION [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.ACTION#4)
+-where_expr=
| +-Literal(type=BOOL, value=true)
+-update_item_list=
  +-UpdateItem
  | +-target=
  | | +-GetProtoField
  | |   +-type=INT32
  | |   +-expr=
  | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
  | |   +-field_descriptor=int32_val
  | |   +-default_value=77
  | +-set_value=
  |   +-DMLValue
  |     +-value=
  |       +-Literal(type=INT32, value=1)
  +-UpdateItem
    +-target=
    | +-GetProtoField
    |   +-type=ARRAY<INT64>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=repeated_int64_val
    |   +-default_value=[]
    +-element_column=
    | +-ColumnHolder(column=$array.repeated_int64_val#5)
    +-delete_list=
      +-DeleteStmt
        +-assert_rows_modified=
        | +-AssertRowsModified
        |   +-rows=
        |     +-Literal(type=INT64, value=1)
        +-where_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=$array.repeated_int64_val#5)
            +-Literal(type=INT64, value=1)
==

UPDATE TestTable SET
  (UPDATE KitchenSink.repeated_int64_val SET
     repeated_int64_val = NULL
   WHERE repeated_int64_val < 2),
  (UPDATE KitchenSink.repeated_int64_val SET
     repeated_int64_val = NULL
   WHERE repeated_int64_val >= 2 THEN RETURN *)
WHERE true
--
ERROR: THEN RETURN is not allowed in nested UPDATE statements [at 7:34]
   WHERE repeated_int64_val >= 2 THEN RETURN *)
                                 ^

==

UPDATE TestTable SET
  (UPDATE KitchenSink.repeated_int64_val SET
     repeated_int64_val = NULL
   WHERE repeated_int64_val < 2),
  (UPDATE KitchenSink.repeated_int64_val SET
     repeated_int64_val = NULL
   WHERE repeated_int64_val >= 2)
WHERE true THEN RETURN *
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
+-column_access_list=READ,READ,READ_WRITE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-TestTable.key#1 AS key [INT32]
|     +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
|     +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-where_expr=
| +-Literal(type=BOOL, value=true)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-GetProtoField
    |   +-type=ARRAY<INT64>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=repeated_int64_val
    |   +-default_value=[]
    +-element_column=
    | +-ColumnHolder(column=$array.repeated_int64_val#4)
    +-update_list=
      +-UpdateStmt
      | +-where_expr=
      | | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
      | |   +-ColumnRef(type=INT64, column=$array.repeated_int64_val#4)
      | |   +-Literal(type=INT64, value=2)
      | +-update_item_list=
      |   +-UpdateItem
      |     +-target=
      |     | +-ColumnRef(type=INT64, column=$array.repeated_int64_val#4)
      |     +-set_value=
      |       +-DMLValue
      |         +-value=
      |           +-Literal(type=INT64, value=NULL)
      +-UpdateStmt
        +-where_expr=
        | +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
        |   +-ColumnRef(type=INT64, column=$array.repeated_int64_val#4)
        |   +-Literal(type=INT64, value=2)
        +-update_item_list=
          +-UpdateItem
            +-target=
            | +-ColumnRef(type=INT64, column=$array.repeated_int64_val#4)
            +-set_value=
              +-DMLValue
                +-value=
                  +-Literal(type=INT64, value=NULL)

==

UPDATE TestTable SET
  KitchenSink.int32_val = 1,
  (INSERT KitchenSink.repeated_int64_val
   VALUES (1), (1 + 2), ((select 1))
   ASSERT_ROWS_MODIFIED 1 THEN RETURN *)
WHERE true
ASSERT_ROWS_MODIFIED 1
--
ERROR: THEN RETURN is not allowed in nested INSERT statements [at 5:27]
   ASSERT_ROWS_MODIFIED 1 THEN RETURN *)
                          ^
==

UPDATE TestTable SET
  KitchenSink.int32_val = 1,
  (INSERT KitchenSink.repeated_int64_val
   VALUES (1), (1 + 2), ((select 1))
   ASSERT_ROWS_MODIFIED 1)
WHERE true
ASSERT_ROWS_MODIFIED 1
THEN RETURN WITH ACTION *
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
+-column_access_list=READ,READ,READ_WRITE
+-assert_rows_modified=
| +-AssertRowsModified
|   +-rows=
|     +-Literal(type=INT64, value=1)
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-TestTable.key#1 AS key [INT32]
|   | +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
|   | +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
|   | +-$with_action.ACTION#4 AS ACTION [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.ACTION#4)
+-where_expr=
| +-Literal(type=BOOL, value=true)
+-update_item_list=
  +-UpdateItem
  | +-target=
  | | +-GetProtoField
  | |   +-type=INT32
  | |   +-expr=
  | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
  | |   +-field_descriptor=int32_val
  | |   +-default_value=77
  | +-set_value=
  |   +-DMLValue
  |     +-value=
  |       +-Literal(type=INT32, value=1)
  +-UpdateItem
    +-target=
    | +-GetProtoField
    |   +-type=ARRAY<INT64>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=repeated_int64_val
    |   +-default_value=[]
    +-element_column=
    | +-ColumnHolder(column=$array.repeated_int64_val#5)
    +-insert_list=
      +-InsertStmt
        +-assert_rows_modified=
        | +-AssertRowsModified
        |   +-rows=
        |     +-Literal(type=INT64, value=1)
        +-row_list=
          +-InsertRow
          | +-value_list=
          |   +-DMLValue
          |     +-value=
          |       +-Literal(type=INT64, value=1)
          +-InsertRow
          | +-value_list=
          |   +-DMLValue
          |     +-value=
          |       +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
          |         +-Literal(type=INT64, value=1)
          |         +-Literal(type=INT64, value=2)
          +-InsertRow
            +-value_list=
              +-DMLValue
                +-value=
                  +-SubqueryExpr
                    +-type=INT64
                    +-subquery_type=SCALAR
                    +-subquery=
                      +-ProjectScan
                        +-column_list=[$expr_subquery.$col1#6]
                        +-expr_list=
                        | +-$col1#6 := Literal(type=INT64, value=1)
                        +-input_scan=
                          +-SingleRowScan

==

UPDATE SimpleTypes SET
  int64 = 1
FROM KeyValue
WHERE int64 = Key
THEN RETURN WITH ACTION *
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
+-column_access_list=READ,READ_WRITE,READ,READ,READ,READ,READ,READ,READ,READ,READ,READ,READ,READ,READ,READ,READ,READ
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-SimpleTypes.int32#1 AS int32 [INT32]
|   | +-SimpleTypes.int64#2 AS int64 [INT64]
|   | +-SimpleTypes.uint32#3 AS uint32 [UINT32]
|   | +-SimpleTypes.uint64#4 AS uint64 [UINT64]
|   | +-SimpleTypes.string#5 AS string [STRING]
|   | +-SimpleTypes.bytes#6 AS bytes [BYTES]
|   | +-SimpleTypes.bool#7 AS bool [BOOL]
|   | +-SimpleTypes.float#8 AS float [FLOAT]
|   | +-SimpleTypes.double#9 AS double [DOUBLE]
|   | +-SimpleTypes.date#10 AS date [DATE]
|   | +-SimpleTypes.timestamp_seconds#11 AS timestamp_seconds [TIMESTAMP]
|   | +-SimpleTypes.timestamp_millis#12 AS timestamp_millis [TIMESTAMP]
|   | +-SimpleTypes.timestamp_micros#13 AS timestamp_micros [TIMESTAMP]
|   | +-SimpleTypes.timestamp_nanos#14 AS timestamp_nanos [TIMESTAMP]
|   | +-SimpleTypes.timestamp#15 AS timestamp [TIMESTAMP]
|   | +-SimpleTypes.numeric#16 AS numeric [NUMERIC]
|   | +-SimpleTypes.bignumeric#17 AS bignumeric [BIGNUMERIC]
|   | +-SimpleTypes.json#18 AS json [JSON]
|   | +-$with_action.ACTION#21 AS ACTION [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.ACTION#21)
+-where_expr=
| +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
|   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
|   +-ColumnRef(type=INT64, column=KeyValue.Key#19)
+-update_item_list=
| +-UpdateItem
|   +-target=
|   | +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
|   +-set_value=
|     +-DMLValue
|       +-value=
|         +-Literal(type=INT64, value=1)
+-from_scan=
  +-TableScan(column_list=[KeyValue.Key#19], table=KeyValue, column_index_list=[0])

==

UPDATE SimpleTypes SET
  int64 = 1
FROM KeyValue
WHERE int64 = Key
THEN RETURN Key
--
ERROR: Unrecognized name: Key [at 5:13]
THEN RETURN Key
            ^
==

DELETE KeyValue WHERE Value = 'Value_1'
  THEN RETURN (SELECT k2 FROM (SELECT Key k1, Key k2 FROM KeyValue)
               PIVOT (SUM(k1) FOR k1 IN (0,1)));
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.$col1#11 AS `$col1` [INT64]
|   +-expr_list=
|     +-$col1#11 :=
|       +-SubqueryExpr
|         +-type=INT64
|         +-subquery_type=SCALAR
|         +-subquery=
|           +-ProjectScan
|             +-column_list=[$groupby.k2#8]
|             +-input_scan=
|               +-PivotScan
|                 +-column_list=[$groupby.k2#8]
|                 +-input_scan=
|                 | +-ProjectScan
|                 |   +-column_list=$subquery1.[k1#5, k2#6]
|                 |   +-expr_list=
|                 |   | +-k1#5 := ColumnRef(type=INT64, column=KeyValue.Key#3)
|                 |   | +-k2#6 := ColumnRef(type=INT64, column=KeyValue.Key#3)
|                 |   +-input_scan=
|                 |     +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0])
|                 +-group_by_list=
|                 | +-k2#8 := ColumnRef(type=INT64, column=$subquery1.k2#6)
|                 +-pivot_expr_list=
|                 | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
|                 |   +-parse_location=130-137
|                 |   +-ColumnRef(type=INT64, column=$subquery1.k1#5)
|                 +-for_expr=
|                 | +-ColumnRef(parse_location=142-144, type=INT64, column=$subquery1.k1#5)
|                 +-pivot_value_list=
|                   +-Literal(type=INT64, value=0, preserve_in_literal_remover=TRUE)
|                   +-Literal(type=INT64, value=1, preserve_in_literal_remover=TRUE)
+-column_access_list=READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-Literal(type=STRING, value="Value_1")

==

[language_features=V_1_3_DML_RETURNING]
INSERT INTO KeyValue (key, value) VALUES (1, "one")
THEN RETURN * EXCEPT (KEY)
--
ERROR: SELECT * EXCEPT is not supported [at 2:13]
THEN RETURN * EXCEPT (KEY)
            ^
==

[language_features=V_1_3_DML_RETURNING]
INSERT INTO KeyValue (key, value) VALUES (1, "one")
THEN RETURN * REPLACE ("xxx" as value)
--
ERROR: SELECT * REPLACE is not supported [at 2:13]
THEN RETURN * REPLACE ("xxx" as value)
            ^
==

INSERT INTO KeyValue (key, value) VALUES (1, "one")
THEN RETURN * EXCEPT (KEY)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Value#2 AS Value [STRING]
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=WRITE,READ_WRITE
==

INSERT INTO KeyValue (key, value) VALUES (1, "one")
THEN RETURN * REPLACE ("xxx" as value)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS Key [INT64]
|   | +-KeyValue.value#3 AS value [STRING]
|   +-expr_list=
|     +-value#3 := Literal(type=STRING, value="xxx")
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=READ_WRITE,WRITE
==

INSERT INTO KeyValue (key, value) VALUES (1, "one")
THEN RETURN * REPLACE ("xxx" as value), key + 1
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS Key [INT64]
|   | +-KeyValue.value#3 AS value [STRING]
|   | +-KeyValue.$col2#4 AS `$col2` [INT64]
|   +-expr_list=
|     +-value#3 := Literal(type=STRING, value="xxx")
|     +-$col2#4 :=
|       +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
|         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|         +-Literal(type=INT64, value=1)
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=READ_WRITE,WRITE
==

INSERT INTO FourIntegers (key1, value1, key2) VALUES (1, 2, 1) THEN RETURN value2, key2;
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=FourIntegers.[key1#1, value1#2, key2#3, value2#4], table=FourIntegers, column_index_list=[0, 1, 2, 3])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-FourIntegers.value2#4 AS value2 [INT64]
|     +-FourIntegers.key2#3 AS key2 [INT64]
+-insert_column_list=FourIntegers.[key1#1, value1#2, key2#3]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=2)
|     +-DMLValue
|       +-value=
|         +-Literal(type=INT64, value=1)
+-column_access_list=WRITE,WRITE,READ_WRITE,READ
==



INSERT INTO KeyValue (key, value) VALUES (1, "one")
THEN RETURN * EXCEPT(Key), key
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Value#2 AS Value [STRING]
|     +-KeyValue.Key#1 AS key [INT64]
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=READ_WRITE,READ_WRITE
==

INSERT INTO KeyValue (key, value) VALUES (1, "one")
THEN RETURN key, * EXCEPT(Key)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Key#1 AS key [INT64]
|     +-KeyValue.Value#2 AS Value [STRING]
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=READ_WRITE,READ_WRITE
==

INSERT INTO KeyValue (key, value) VALUES (1, "one")
THEN RETURN WITH ACTION key, * EXCEPT(Key)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS key [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-$with_action.ACTION#3 AS ACTION [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.ACTION#3)
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=READ_WRITE,READ_WRITE
==

INSERT INTO KeyValue (key, value) VALUES (1, "one")
THEN RETURN * EXCEPT (KEY) REPLACE ("xxx" as value)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.value#3 AS value [STRING]
|   +-expr_list=
|     +-value#3 := Literal(type=STRING, value="xxx")
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=WRITE,WRITE
==

INSERT INTO KeyValue (key, value) VALUES (1, "one")
THEN RETURN *, * EXCEPT (KEY), * REPLACE (2 AS KEY)
--

InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS Key [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-KeyValue.KEY#3 AS KEY [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   +-expr_list=
|     +-KEY#3 := Literal(type=INT64, value=2)
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=READ_WRITE,READ_WRITE
==

INSERT INTO KeyValue (key, value) VALUES (1, "one")
THEN RETURN * EXCEPT (KEY), * EXCEPT (KEY)
--

InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Value#2 AS Value [STRING]
|     +-KeyValue.Value#2 AS Value [STRING]
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value="one")
+-column_access_list=WRITE,READ_WRITE
==

[language_features=V_1_3_DML_RETURNING]
UPDATE KeyValue SET value="a" WHERE key > 10 THEN RETURN * EXCEPT (key)
--
ERROR: SELECT * EXCEPT is not supported [at 1:58]
UPDATE KeyValue SET value="a" WHERE key > 10 THEN RETURN * EXCEPT (key)
                                                         ^
==

UPDATE KeyValue SET value="a" WHERE key > 10 THEN RETURN * EXCEPT (key)
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-column_access_list=READ,READ_WRITE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Value#2 AS Value [STRING]
+-where_expr=
| +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|   +-Literal(type=INT64, value=10)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-Literal(type=STRING, value="a")
==

UPDATE KeyValue SET value="a" WHERE key > 10
THEN RETURN * EXCEPT (key) REPLACE ("xxx" as value)
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-column_access_list=READ,WRITE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.value#3 AS value [STRING]
|   +-expr_list=
|     +-value#3 := Literal(type=STRING, value="xxx")
+-where_expr=
| +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|   +-Literal(type=INT64, value=10)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-Literal(type=STRING, value="a")
==

UPDATE KeyValue SET value="a" WHERE key > 10
THEN RETURN * EXCEPT (key), *
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-column_access_list=READ,READ_WRITE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Value#2 AS Value [STRING]
|     +-KeyValue.Key#1 AS Key [INT64]
|     +-KeyValue.Value#2 AS Value [STRING]
+-where_expr=
| +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|   +-Literal(type=INT64, value=10)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-Literal(type=STRING, value="a")
==

UPDATE KeyValue T SET value="a" WHERE key > 10
THEN RETURN T.*
--

UpdateStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="T")
+-column_access_list=READ,READ_WRITE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Key#1 AS Key [INT64]
|     +-KeyValue.Value#2 AS Value [STRING]
+-where_expr=
| +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|   +-Literal(type=INT64, value=10)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-Literal(type=STRING, value="a")
==

UPDATE KeyValue T SET value="a" WHERE key > 10
THEN RETURN T.* EXCEPT(KEY)
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="T")
+-column_access_list=READ,READ_WRITE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Value#2 AS Value [STRING]
+-where_expr=
| +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|   +-Literal(type=INT64, value=10)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-Literal(type=STRING, value="a")
==

UPDATE KeyValue T SET value="a" WHERE key > 10
THEN RETURN T.* EXCEPT (KEY), * REPLACE (2 AS KEY)
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="T")
+-column_access_list=READ,READ_WRITE
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-T.KEY#3 AS KEY [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   +-expr_list=
|     +-KEY#3 := Literal(type=INT64, value=2)
+-where_expr=
| +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|   +-Literal(type=INT64, value=10)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-Literal(type=STRING, value="a")
==

[language_features=V_1_3_DML_RETURNING]
DELETE KeyValue WHERE TRUE THEN RETURN * EXCEPT (key)
--
ERROR: SELECT * EXCEPT is not supported [at 1:40]
DELETE KeyValue WHERE TRUE THEN RETURN * EXCEPT (key)
                                       ^
==

[language_features=V_1_3_DML_RETURNING]
DELETE KeyValue WHERE TRUE THEN RETURN * REPLACE (1 AS key)
--
ERROR: SELECT * REPLACE is not supported [at 1:40]
DELETE KeyValue WHERE TRUE THEN RETURN * REPLACE (1 AS key)
                                       ^
==

DELETE KeyValue WHERE TRUE THEN RETURN * EXCEPT (key)
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Value#2 AS Value [STRING]
+-column_access_list=READ
+-where_expr=
  +-Literal(type=BOOL, value=true)
==

DELETE KeyValue WHERE TRUE THEN RETURN * REPLACE (1 AS KEY)
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.KEY#3 AS KEY [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   +-expr_list=
|     +-KEY#3 := Literal(type=INT64, value=1)
+-column_access_list=READ
+-where_expr=
  +-Literal(type=BOOL, value=true)
==

DELETE KeyValue WHERE TRUE THEN RETURN * EXCEPT (key) REPLACE (1 AS KEY)
--
ERROR: Column KEY cannot occur in both SELECT * EXCEPT and REPLACE [at 1:69]
DELETE KeyValue WHERE TRUE THEN RETURN * EXCEPT (key) REPLACE (1 AS KEY)
                                                                    ^
==

DELETE KeyValue WHERE TRUE THEN RETURN * REPLACE (1 AS KEY) EXCEPT (KEY)
--
ERROR: Syntax error: Expected end of input but got keyword EXCEPT [at 1:61]
DELETE KeyValue WHERE TRUE THEN RETURN * REPLACE (1 AS KEY) EXCEPT (KEY)
                                                            ^
==

DELETE KeyValue WHERE TRUE THEN RETURN WITH ACTION * EXCEPT(KEY), KEY
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-KeyValue.Key#1 AS KEY [INT64]
|   | +-$with_action.ACTION#3 AS ACTION [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.ACTION#3)
+-column_access_list=READ,READ
+-where_expr=
  +-Literal(type=BOOL, value=true)
==

DELETE KeyValue WHERE TRUE THEN RETURN WITH ACTION * EXCEPT(KEY), * EXCEPT(KEY)
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-$with_action.ACTION#3 AS ACTION [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.ACTION#3)
+-column_access_list=READ
+-where_expr=
  +-Literal(type=BOOL, value=true)
==

DELETE KeyValue T WHERE TRUE THEN RETURN *, T.* EXCEPT(KEY)
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="T")
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Key#1 AS Key [INT64]
|     +-KeyValue.Value#2 AS Value [STRING]
|     +-KeyValue.Value#2 AS Value [STRING]
+-column_access_list=READ,READ
+-where_expr=
  +-Literal(type=BOOL, value=true)
==

DELETE KeyValue T WHERE TRUE THEN RETURN WITH ACTION AS action *, T.* EXCEPT(KEY)
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="T")
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS Key [INT64]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-KeyValue.Value#2 AS Value [STRING]
|   | +-$with_action.action#3 AS action [STRING]
|   +-action_column=
|     +-ColumnHolder(column=$with_action.action#3)
+-column_access_list=READ,READ
+-where_expr=
  +-Literal(type=BOOL, value=true)
==

# `value` is a proto column `TestBcPB`.
DELETE TestBcPBValueProtoTable WHERE TRUE
THEN RETURN value.*
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=[TestBcPBValueProtoTable.value#1], table=TestBcPBValueProtoTable, column_index_list=[0])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-TestBcPBValueProtoTable.b#4 AS b [INT32]
|   | +-TestBcPBValueProtoTable.c#5 AS c [STRING]
|   +-expr_list=
|     +-b#4 :=
|     | +-GetProtoField
|     |   +-type=INT32
|     |   +-expr=
|     |   | +-ColumnRef(type=PROTO<zetasql_test__.TestBcPB>, column=TestBcPBValueProtoTable.value#1)
|     |   +-field_descriptor=b
|     |   +-default_value=0
|     +-c#5 :=
|       +-GetProtoField
|         +-type=STRING
|         +-expr=
|         | +-ColumnRef(type=PROTO<zetasql_test__.TestBcPB>, column=TestBcPBValueProtoTable.value#1)
|         +-field_descriptor=c
|         +-default_value=""
+-column_access_list=READ
+-where_expr=
  +-Literal(type=BOOL, value=true)
==

DELETE TestTable WHERE TRUE THEN RETURN KitchenSink.nested_value.*
--
ERROR: Dot-star is only allowed on range variables and columns in THEN RETURN. It cannot be applied on other expressions including field access. [at 1:41]
DELETE TestTable WHERE TRUE THEN RETURN KitchenSink.nested_value.*
                                        ^
==

SELECT KitchenSink.nested_value.* FROM TestTable WHERE TRUE
--
QueryStmt
+-output_column_list=
| +-$query.nested_int64#5 AS nested_int64 [INT64]
| +-$query.nested_repeated_int64#6 AS nested_repeated_int64 [ARRAY<INT64>]
| +-$query.nested_repeated_int32#7 AS nested_repeated_int32 [ARRAY<INT32>]
| +-$query.value#8 AS value [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=$query.[nested_int64#5, nested_repeated_int64#6, nested_repeated_int32#7, value#8]
    +-expr_list=
    | +-nested_int64#5 :=
    | | +-GetProtoField
    | |   +-type=INT64
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#4)
    | |   +-field_descriptor=nested_int64
    | |   +-default_value=88
    | +-nested_repeated_int64#6 :=
    | | +-GetProtoField
    | |   +-type=ARRAY<INT64>
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#4)
    | |   +-field_descriptor=nested_repeated_int64
    | |   +-default_value=[]
    | +-nested_repeated_int32#7 :=
    | | +-GetProtoField
    | |   +-type=ARRAY<INT32>
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#4)
    | |   +-field_descriptor=nested_repeated_int32
    | |   +-default_value=[]
    | +-value#8 :=
    |   +-GetProtoField
    |     +-type=ARRAY<INT32>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#4)
    |     +-field_descriptor=value
    |     +-default_value=[]
    +-input_scan=
      +-ProjectScan
        +-column_list=[TestTable.KitchenSink#3, $preproject.$proto#4]
        +-expr_list=
        | +-$proto#4 :=
        |   +-GetProtoField
        |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
        |     +-expr=
        |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |     +-field_descriptor=nested_value
        |     +-default_value=NULL
        +-input_scan=
          +-FilterScan
            +-column_list=[TestTable.KitchenSink#3]
            +-input_scan=
            | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
            +-filter_expr=
              +-Literal(type=BOOL, value=true)

==

DELETE TestTable WHERE TRUE
THEN RETURN *, EXISTS (SELECT KitchenSink.nested_value.* FROM TestTable)
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-TestTable.key#1 AS key [INT32]
|   | +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
|   | +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
|   | +-TestTable.$col2#12 AS `$col2` [BOOL]
|   +-expr_list=
|     +-$col2#12 :=
|       +-SubqueryExpr
|         +-type=BOOL
|         +-subquery_type=EXISTS
|         +-subquery=
|           +-ProjectScan
|             +-column_list=$expr_subquery.[nested_int64#8, nested_repeated_int64#9, nested_repeated_int32#10, value#11]
|             +-expr_list=
|             | +-nested_int64#8 :=
|             | | +-GetProtoField
|             | |   +-type=INT64
|             | |   +-expr=
|             | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#7)
|             | |   +-field_descriptor=nested_int64
|             | |   +-default_value=88
|             | +-nested_repeated_int64#9 :=
|             | | +-GetProtoField
|             | |   +-type=ARRAY<INT64>
|             | |   +-expr=
|             | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#7)
|             | |   +-field_descriptor=nested_repeated_int64
|             | |   +-default_value=[]
|             | +-nested_repeated_int32#10 :=
|             | | +-GetProtoField
|             | |   +-type=ARRAY<INT32>
|             | |   +-expr=
|             | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#7)
|             | |   +-field_descriptor=nested_repeated_int32
|             | |   +-default_value=[]
|             | +-value#11 :=
|             |   +-GetProtoField
|             |     +-type=ARRAY<INT32>
|             |     +-expr=
|             |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#7)
|             |     +-field_descriptor=value
|             |     +-default_value=[]
|             +-input_scan=
|               +-ProjectScan
|                 +-column_list=[TestTable.KitchenSink#6, $preproject.$proto#7]
|                 +-expr_list=
|                 | +-$proto#7 :=
|                 |   +-GetProtoField
|                 |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
|                 |     +-expr=
|                 |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#6)
|                 |     +-field_descriptor=nested_value
|                 |     +-default_value=NULL
|                 +-input_scan=
|                   +-TableScan(column_list=[TestTable.KitchenSink#6], table=TestTable, column_index_list=[2])
+-column_access_list=READ,READ,READ
+-where_expr=
  +-Literal(type=BOOL, value=true)
==

DELETE KeyValue T WHERE T.Value = 'Value_1'
  THEN RETURN T.key, EXISTS (SELECT P.* FROM KeyValue AS P)
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="T")
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-KeyValue.Key#1 AS key [INT64]
|   | +-T.$col2#5 AS `$col2` [BOOL]
|   +-expr_list=
|     +-$col2#5 :=
|       +-SubqueryExpr
|         +-type=BOOL
|         +-subquery_type=EXISTS
|         +-subquery=
|           +-ProjectScan
|             +-column_list=KeyValue.[Key#3, Value#4]
|             +-input_scan=
|               +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="P")
+-column_access_list=READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-Literal(type=STRING, value="Value_1")
==

DELETE KeyValue T WHERE T.key = (SELECT count(*) FROM (SELECT P.* FROM KeyValue AS P) )
  THEN RETURN T.key
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="T")
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Key#1 AS key [INT64]
+-column_access_list=READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-SubqueryExpr
      +-type=INT64
      +-subquery_type=SCALAR
      +-subquery=
        +-ProjectScan
          +-column_list=[$aggregate.$agg1#5]
          +-input_scan=
            +-AggregateScan
              +-column_list=[$aggregate.$agg1#5]
              +-input_scan=
              | +-ProjectScan
              |   +-column_list=KeyValue.[Key#3, Value#4]
              |   +-input_scan=
              |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="P")
              +-aggregate_list=
                +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

# dot-star used on field access in DML subqueries.
DELETE TestTable WHERE KitchenSink.int32_val = (SELECT COUNT(*) FROM (SELECT P.KitchenSink.nested_value.* FROM TestTable AS P))
THEN RETURN *
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-TestTable.key#1 AS key [INT32]
|     +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
|     +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-column_access_list=READ,READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    +-Cast(INT32 -> INT64)
    | +-GetProtoField
    |   +-type=INT32
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=int32_val
    |   +-default_value=77
    +-SubqueryExpr
      +-type=INT64
      +-subquery_type=SCALAR
      +-subquery=
        +-ProjectScan
          +-column_list=[$aggregate.$agg1#12]
          +-input_scan=
            +-AggregateScan
              +-column_list=[$aggregate.$agg1#12]
              +-input_scan=
              | +-ProjectScan
              |   +-column_list=$subquery1.[nested_int64#8, nested_repeated_int64#9, nested_repeated_int32#10, value#11]
              |   +-expr_list=
              |   | +-nested_int64#8 :=
              |   | | +-GetProtoField
              |   | |   +-type=INT64
              |   | |   +-expr=
              |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#7)
              |   | |   +-field_descriptor=nested_int64
              |   | |   +-default_value=88
              |   | +-nested_repeated_int64#9 :=
              |   | | +-GetProtoField
              |   | |   +-type=ARRAY<INT64>
              |   | |   +-expr=
              |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#7)
              |   | |   +-field_descriptor=nested_repeated_int64
              |   | |   +-default_value=[]
              |   | +-nested_repeated_int32#10 :=
              |   | | +-GetProtoField
              |   | |   +-type=ARRAY<INT32>
              |   | |   +-expr=
              |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#7)
              |   | |   +-field_descriptor=nested_repeated_int32
              |   | |   +-default_value=[]
              |   | +-value#11 :=
              |   |   +-GetProtoField
              |   |     +-type=ARRAY<INT32>
              |   |     +-expr=
              |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#7)
              |   |     +-field_descriptor=value
              |   |     +-default_value=[]
              |   +-input_scan=
              |     +-ProjectScan
              |       +-column_list=[TestTable.KitchenSink#6, $preproject.$proto#7]
              |       +-expr_list=
              |       | +-$proto#7 :=
              |       |   +-GetProtoField
              |       |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
              |       |     +-expr=
              |       |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#6)
              |       |     +-field_descriptor=nested_value
              |       |     +-default_value=NULL
              |       +-input_scan=
              |         +-TableScan(column_list=[TestTable.KitchenSink#6], table=TestTable, column_index_list=[2], alias="P")
              +-aggregate_list=
                +-$agg1#12 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)

==

# dot-star used on field access in DML THEN RETURN subqueries.
DELETE TestTable WHERE KitchenSink.int32_val = 3
THEN RETURN key, (SELECT COUNT(*) FROM (SELECT P.KitchenSink.nested_value.* FROM TestTable AS P)) as mycount
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-TestTable.key#1 AS key [INT32]
|   | +-TestTable.mycount#13 AS mycount [INT64]
|   +-expr_list=
|     +-mycount#13 :=
|       +-SubqueryExpr
|         +-type=INT64
|         +-subquery_type=SCALAR
|         +-subquery=
|           +-ProjectScan
|             +-column_list=[$aggregate.$agg1#12]
|             +-input_scan=
|               +-AggregateScan
|                 +-column_list=[$aggregate.$agg1#12]
|                 +-input_scan=
|                 | +-ProjectScan
|                 |   +-column_list=$subquery1.[nested_int64#8, nested_repeated_int64#9, nested_repeated_int32#10, value#11]
|                 |   +-expr_list=
|                 |   | +-nested_int64#8 :=
|                 |   | | +-GetProtoField
|                 |   | |   +-type=INT64
|                 |   | |   +-expr=
|                 |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#7)
|                 |   | |   +-field_descriptor=nested_int64
|                 |   | |   +-default_value=88
|                 |   | +-nested_repeated_int64#9 :=
|                 |   | | +-GetProtoField
|                 |   | |   +-type=ARRAY<INT64>
|                 |   | |   +-expr=
|                 |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#7)
|                 |   | |   +-field_descriptor=nested_repeated_int64
|                 |   | |   +-default_value=[]
|                 |   | +-nested_repeated_int32#10 :=
|                 |   | | +-GetProtoField
|                 |   | |   +-type=ARRAY<INT32>
|                 |   | |   +-expr=
|                 |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#7)
|                 |   | |   +-field_descriptor=nested_repeated_int32
|                 |   | |   +-default_value=[]
|                 |   | +-value#11 :=
|                 |   |   +-GetProtoField
|                 |   |     +-type=ARRAY<INT32>
|                 |   |     +-expr=
|                 |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$preproject.$proto#7)
|                 |   |     +-field_descriptor=value
|                 |   |     +-default_value=[]
|                 |   +-input_scan=
|                 |     +-ProjectScan
|                 |       +-column_list=[TestTable.KitchenSink#6, $preproject.$proto#7]
|                 |       +-expr_list=
|                 |       | +-$proto#7 :=
|                 |       |   +-GetProtoField
|                 |       |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
|                 |       |     +-expr=
|                 |       |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#6)
|                 |       |     +-field_descriptor=nested_value
|                 |       |     +-default_value=NULL
|                 |       +-input_scan=
|                 |         +-TableScan(column_list=[TestTable.KitchenSink#6], table=TestTable, column_index_list=[2], alias="P")
|                 +-aggregate_list=
|                   +-$agg1#12 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
+-column_access_list=READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    +-GetProtoField
    | +-type=INT32
    | +-expr=
    | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | +-field_descriptor=int32_val
    | +-default_value=77
    +-Literal(type=INT32, value=3)
==

INSERT INTO KeyValue (key, value) VALUES (1, "one") THEN RETURN COUNT(*) GROUP BY key
--
ERROR: Syntax error: Expected end of input but got keyword GROUP [at 1:74]
...key, value) VALUES (1, "one") THEN RETURN COUNT(*) GROUP BY key
                                                      ^
==

INSERT INTO KeyValue (key, value) VALUES (1, "one") THEN RETURN COUNT(*)
--
ERROR: THEN RETURN clause cannot use aggregation [at 1:53]
INSERT INTO KeyValue (key, value) VALUES (1, "one") THEN RETURN COUNT(*)
                                                    ^
==

DELETE TestTable WHERE TRUE THEN RETURN COUNT(*)
--
ERROR: THEN RETURN clause cannot use aggregation [at 1:29]
DELETE TestTable WHERE TRUE THEN RETURN COUNT(*)
                            ^
==

DELETE TestTable WHERE KitchenSink.int32_val = 3
THEN RETURN key, (SELECT COUNT(*) from KeyValue) as col2, SUM(key);
--
ERROR: THEN RETURN clause cannot use aggregation [at 2:1]
THEN RETURN key, (SELECT COUNT(*) from KeyValue) as col2, SUM(key);
^
==

# Window aggregates are not supported.
[language_features=V_1_3_DML_RETURNING,ANALYTIC_FUNCTIONS]
DELETE TestTable WHERE KitchenSink.int32_val = 3
THEN RETURN key, COUNT(key) OVER() AS total;
--
ERROR: THEN RETURN clause cannot use analytic functions [at 2:1]
THEN RETURN key, COUNT(key) OVER() AS total;
^
==

DELETE TestTable WHERE KitchenSink.int32_val = 3
THEN RETURN key, (SELECT COUNT(*) from TestTable) as col2;
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|   | +-TestTable.key#1 AS key [INT32]
|   | +-TestTable.col2#8 AS col2 [INT64]
|   +-expr_list=
|     +-col2#8 :=
|       +-SubqueryExpr
|         +-type=INT64
|         +-subquery_type=SCALAR
|         +-subquery=
|           +-ProjectScan
|             +-column_list=[$aggregate.$agg1#7]
|             +-input_scan=
|               +-AggregateScan
|                 +-column_list=[$aggregate.$agg1#7]
|                 +-input_scan=
|                 | +-TableScan(table=TestTable)
|                 +-aggregate_list=
|                   +-$agg1#7 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
+-column_access_list=READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
    +-GetProtoField
    | +-type=INT32
    | +-expr=
    | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | +-field_descriptor=int32_val
    | +-default_value=77
    +-Literal(type=INT32, value=3)
==

DELETE KeyValue WHERE key = 1;
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-column_access_list=READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-Literal(type=INT64, value=1)
==

DELETE KeyValue WHERE key = 1 THEN RETURN value;
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Value#2 AS value [STRING]
+-column_access_list=READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-Literal(type=INT64, value=1)
==

INSERT INTO KeyValue (key) VALUES (1);
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-insert_column_list=[KeyValue.Key#1]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Literal(type=INT64, value=1)
+-column_access_list=WRITE
==

INSERT INTO KeyValue (key) VALUES (1) THEN RETURN key, value;
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-returning=
| +-ReturningClause
|   +-output_column_list=
|     +-KeyValue.Key#1 AS key [INT64]
|     +-KeyValue.Value#2 AS value [STRING]
+-insert_column_list=[KeyValue.Key#1]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Literal(type=INT64, value=1)
+-column_access_list=READ_WRITE,READ
==
