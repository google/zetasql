[default language_features=CREATE_TABLE_PARTITION_BY,CREATE_TABLE_CLUSTER_BY,UNENFORCED_PRIMARY_KEYS]

create table t1 (
  c1 int32,
  c2 int64,
  c3 string,
  c4 zetasql_test__.TestEnum,
  c5 zetasql_test__.TestExtraPB,
  c6 STRUCT<x int32, y string>,
  c7 ARRAY<int64>
  );
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
  +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
  +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
  +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
  +-ColumnDefinition(name="c4", type=ENUM<zetasql_test__.TestEnum>, column=t1.c4#4)
  +-ColumnDefinition(name="c5", type=PROTO<zetasql_test__.TestExtraPB>, column=t1.c5#5)
  +-ColumnDefinition(name="c6", type=STRUCT<x INT32, y STRING>, column=t1.c6#6)
  +-ColumnDefinition(name="c7", type=ARRAY<INT64>, column=t1.c7#7)
==

create table t1 like t2;
--
ERROR: CREATE TABLE LIKE is not supported [at 1:22]
create table t1 like t2;
                     ^
==

create external table t1 like t2 options();
--
ERROR: CREATE EXTERNAL TABLE LIKE is not supported [at 1:31]
create external table t1 like t2 options();
                              ^
==

create table t1 copy KeyValue;
--
ERROR: CREATE TABLE COPY is not supported [at 1:22]
create table t1 copy KeyValue;
                     ^
==

create table t1 clone KeyValue;
--
ERROR: CREATE TABLE CLONE is not supported [at 1:23]
create table t1 clone KeyValue;
                      ^
==

[language_features=CREATE_TABLE_LIKE]
create table t1 like t2;
--
ERROR: Table not found: t2 [at 1:22]
create table t1 like t2;
                     ^
==

[language_features=CREATE_TABLE_LIKE]
create table t1 (a int64) like t2;
--
ERROR: Cannot have both column definition list and LIKE [at 1:32]
create table t1 (a int64) like t2;
                               ^
==

[language_features=CREATE_TABLE_COPY,CREATE_TABLE_CLONE]
create table t1 clone KeyValue copy KeyValue;
--
ERROR: COPY and CLONE cannot both be used for CREATE TABLE [at 1:1]
create table t1 clone KeyValue copy KeyValue;
^
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_COPY]
create table t1 {{CLONE|COPY}} KeyValue;
--
ALTERNATION GROUP: CLONE
--
CreateTableStmt
+-name_path=t1
+-clone_from=
  +-TableScan(table=KeyValue)
--
ALTERNATION GROUP: COPY
--
CreateTableStmt
+-name_path=t1
+-copy_from=
  +-TableScan(table=KeyValue)
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_COPY]
create table t1 {{CLONE|COPY}} KeyValue FOR SYSTEM_TIME AS OF CURRENT_TIMESTAMP();
--
ALTERNATION GROUP: CLONE
--
CreateTableStmt
+-name_path=t1
+-clone_from=
  +-TableScan
    +-table=KeyValue
    +-for_system_time_expr=
      +-FunctionCall(ZetaSQL:current_timestamp() -> TIMESTAMP)
--
ALTERNATION GROUP: COPY
--
CreateTableStmt
+-name_path=t1
+-copy_from=
  +-TableScan
    +-table=KeyValue
    +-for_system_time_expr=
      +-FunctionCall(ZetaSQL:current_timestamp() -> TIMESTAMP)
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_COPY]
create table t1
{{CLONE|COPY}} KeyValue FOR SYSTEM_TIME AS OF CURRENT_TIMESTAMP() WHERE key = 1;
--
ALTERNATION GROUP: CLONE
--
CreateTableStmt
+-name_path=t1
+-clone_from=
  +-FilterScan
    +-column_list=[KeyValue.Key#1]
    +-input_scan=
    | +-TableScan
    |   +-column_list=[KeyValue.Key#1]
    |   +-table=KeyValue
    |   +-for_system_time_expr=
    |   | +-FunctionCall(ZetaSQL:current_timestamp() -> TIMESTAMP)
    |   +-column_index_list=[0]
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-Literal(type=INT64, value=1)
--
ALTERNATION GROUP: COPY
--
CreateTableStmt
+-name_path=t1
+-copy_from=
  +-FilterScan
    +-column_list=[KeyValue.Key#1]
    +-input_scan=
    | +-TableScan
    |   +-column_list=[KeyValue.Key#1]
    |   +-table=KeyValue
    |   +-for_system_time_expr=
    |   | +-FunctionCall(ZetaSQL:current_timestamp() -> TIMESTAMP)
    |   +-column_index_list=[0]
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-Literal(type=INT64, value=1)
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_COPY]
create table t1
{{CLONE|COPY}} KeyValue
WHERE key = 1 AND value = '';
--
ALTERNATION GROUP: CLONE
--
CreateTableStmt
+-name_path=t1
+-clone_from=
  +-FilterScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
        +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        | +-Literal(type=INT64, value=1)
        +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
          +-ColumnRef(type=STRING, column=KeyValue.Value#2)
          +-Literal(type=STRING, value="")
--
ALTERNATION GROUP: COPY
--
CreateTableStmt
+-name_path=t1
+-copy_from=
  +-FilterScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
        +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        | +-Literal(type=INT64, value=1)
        +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
          +-ColumnRef(type=STRING, column=KeyValue.Value#2)
          +-Literal(type=STRING, value="")
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_COPY]
create table t1
{{CLONE|COPY}} KeyValue
OPTIONS (description = null, partition_expiration_days=10);
--
ALTERNATION GROUP: CLONE
--
CreateTableStmt
+-name_path=t1
+-option_list=
| +-description := Literal(type=INT64, value=NULL)
| +-partition_expiration_days := Literal(type=INT64, value=10)
+-clone_from=
  +-TableScan(table=KeyValue)
--
ALTERNATION GROUP: COPY
--
CreateTableStmt
+-name_path=t1
+-option_list=
| +-description := Literal(type=INT64, value=NULL)
| +-partition_expiration_days := Literal(type=INT64, value=10)
+-copy_from=
  +-TableScan(table=KeyValue)
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_PARTITION_BY]
create table t1 {{CLONE|COPY}} KeyValue PARTITION BY key;
--

ALTERNATION GROUP: CLONE

--
ERROR: CREATE TABLE CLONE cannot be used together with PARTITION BY [at 1:32]
create table t1 CLONE KeyValue PARTITION BY key;
                               ^
--
ALTERNATION GROUP: COPY
--
ERROR: CREATE TABLE COPY is not supported [at 1:22]
create table t1 COPY KeyValue PARTITION BY key;
                     ^
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_COPY]
create table t1 {{CLONE|COPY}} Int64ValueTable;
--

ALTERNATION GROUP: CLONE

--
ERROR: Cannot copy from value table: Int64ValueTable [at 1:23]
create table t1 CLONE Int64ValueTable;
                      ^
--
ALTERNATION GROUP: COPY
--
ERROR: Cannot copy from value table: Int64ValueTable [at 1:22]
create table t1 COPY Int64ValueTable;
                     ^
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_CLUSTER_BY]
create table t1 {{CLONE|COPY}} KeyValue CLUSTER BY key;
--

ALTERNATION GROUP: CLONE

--
ERROR: CREATE TABLE CLONE cannot be used together with CLUSTER BY [at 1:32]
create table t1 CLONE KeyValue CLUSTER BY key;
                               ^
--
ALTERNATION GROUP: COPY
--
ERROR: CREATE TABLE COPY is not supported [at 1:22]
create table t1 COPY KeyValue CLUSTER BY key;
                     ^
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_COPY]
create table t1(k STRING, v STRING) {{CLONE|COPY}} KeyValue;
--

ALTERNATION GROUP: CLONE
--
ERROR: CREATE TABLE CLONE cannot define column list [at 1:16]
create table t1(k STRING, v STRING) CLONE KeyValue;
               ^
--
ALTERNATION GROUP: COPY
--
ERROR: CREATE TABLE COPY cannot define column list [at 1:16]
create table t1(k STRING, v STRING) COPY KeyValue;
               ^
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_COPY]
create table t1 {{CLONE|COPY}} KeyValue AS kv;
--
ALTERNATION GROUP: CLONE
--
ERROR: Syntax error: Expected "(" or keyword SELECT or keyword WITH but got identifier "kv" [at 1:35]
create table t1 CLONE KeyValue AS kv;
                                  ^
--
ALTERNATION GROUP: COPY
--
ERROR: Syntax error: Expected "(" or keyword SELECT or keyword WITH but got identifier "kv" [at 1:34]
create table t1 COPY KeyValue AS kv;
                                 ^
==

[language_features=CREATE_TABLE_LIKE,CREATE_TABLE_CLONE,CREATE_TABLE_COPY]
create table t1 like KeyValue {{CLONE|COPY}} KeyValue;
--
ALTERNATION GROUP: CLONE
--
ERROR: CLONE and LIKE cannot both be used for CREATE TABLE [at 1:1]
create table t1 like KeyValue CLONE KeyValue;
^
--
ALTERNATION GROUP: COPY
--
ERROR: COPY and LIKE cannot both be used for CREATE TABLE [at 1:1]
create table t1 like KeyValue COPY KeyValue;
^
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_COPY]
create table t1 {{CLONE|COPY}} KeyValue AS SELECT 1;
--
ALTERNATION GROUP: CLONE
--
ERROR: CREATE TABLE CLONE cannot be used together with AS SELECT [at 1:35]
create table t1 CLONE KeyValue AS SELECT 1;
                                  ^
--
ALTERNATION GROUP: COPY
--
ERROR: CREATE TABLE COPY cannot be used together with AS SELECT [at 1:34]
create table t1 COPY KeyValue AS SELECT 1;
                                 ^
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_COPY]
create table t1 {{CLONE|COPY}} KeyValue WHERE nosuchcol = 1;
--
ALTERNATION GROUP: CLONE
--
ERROR: Unrecognized name: nosuchcol [at 1:38]
create table t1 CLONE KeyValue WHERE nosuchcol = 1;
                                     ^
--
ALTERNATION GROUP: COPY
--
ERROR: Unrecognized name: nosuchcol [at 1:37]
create table t1 COPY KeyValue WHERE nosuchcol = 1;
                                    ^
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_COPY]
create table t1 {{CLONE|COPY}} KeyValue AS SELECT 1 as n from KeyValue;
--
ALTERNATION GROUP: CLONE
--
ERROR: CREATE TABLE CLONE cannot be used together with AS SELECT [at 1:35]
create table t1 CLONE KeyValue AS SELECT 1 as n from KeyValue;
                                  ^
--
ALTERNATION GROUP: COPY
--
ERROR: CREATE TABLE COPY cannot be used together with AS SELECT [at 1:34]
create table t1 COPY KeyValue AS SELECT 1 as n from KeyValue;
                                 ^
==

[language_features=CREATE_TABLE_CLONE,CREATE_TABLE_COPY]
create table t1 {{CLONE|COPY}} KeyValue FOR SYSTEM_TIME AS OF 1;
--
ALTERNATION GROUP: CLONE
--
ERROR: FOR SYSTEM_TIME AS OF must be of type TIMESTAMP but was of type INT64 [at 1:54]
create table t1 CLONE KeyValue FOR SYSTEM_TIME AS OF 1;
                                                     ^
--
ALTERNATION GROUP: COPY
--
ERROR: FOR SYSTEM_TIME AS OF must be of type TIMESTAMP but was of type INT64 [at 1:53]
create table t1 COPY KeyValue FOR SYSTEM_TIME AS OF 1;
                                                    ^
==

[language_features=CREATE_TABLE_LIKE,CREATE_TABLE_PARTITION_BY,CREATE_TABLE_CLUSTER_BY]
[create_table_like_not_scanned]
create table t1 like KeyValue partition by Key cluster by Key options(table_option=1) ;
--
CreateTableStmt
+-name_path=t1
+-option_list=
| +-table_option := Literal(type=INT64, value=1)
+-column_definition_list=
| +-ColumnDefinition(name="Key", type=INT64, column=t1.Key#1)
| +-ColumnDefinition(name="Value", type=STRING, column=t1.Value#2)
+-pseudo_column_list=t1.[pseudo_column_int32#3, pseudo_column_kitchensink#4, pseudo_column_timestamp#5]
+-like_table=KeyValue
+-partition_by_list=
| +-ColumnRef(type=INT64, column=t1.Key#1)
+-cluster_by_list=
  +-ColumnRef(type=INT64, column=t1.Key#1)
==

create table t1 (a int32 options(option_a=1), b int64 options(option_b=2))
options(table_option=3);
--
CreateTableStmt
+-name_path=t1
+-option_list=
| +-table_option := Literal(type=INT64, value=3)
+-column_definition_list=
  +-ColumnDefinition
  | +-name="a"
  | +-type=INT32
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-option_list=
  | |     +-option_a := Literal(type=INT64, value=1)
  | +-column=t1.a#1
  +-ColumnDefinition
    +-name="b"
    +-type=INT64
    +-annotations=
    | +-ColumnAnnotations
    |   +-option_list=
    |     +-option_b := Literal(type=INT64, value=2)
    +-column=t1.b#2
==

create table t1 (c1 int32, c2 int64 primary key);
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
+-primary_key=
  +-PrimaryKey(column_offset_list=[1], column_name_list=[c2])
==

create table t1 (c1 int32, primary key(c1,C3) options(x=1,y=2), c3 string);
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#2)
+-primary_key=
  +-PrimaryKey
    +-column_offset_list=[0, 1]
    +-option_list=
    | +-x := Literal(type=INT64, value=1)
    | +-y := Literal(type=INT64, value=2)
    +-column_name_list=[c1, C3]
==

create table t (a int64, b int32 PRIMARY KEY OPTIONS(x=1));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
| +-ColumnDefinition
|   +-name="b"
|   +-type=INT32
|   +-annotations=
|   | +-ColumnAnnotations
|   |   +-option_list=
|   |     +-x := Literal(type=INT64, value=1)
|   +-column=t.b#2
+-primary_key=
  +-PrimaryKey(column_offset_list=[1], column_name_list=[b])
==

# An empty primary key is used for tables that can have at most one row.
create table t (primary key(), a int64);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
+-primary_key=
  +-PrimaryKey(column_offset_list=[])
==

create table t (aaA int64, b int32, PRIMARY KEY(Aaa));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="aaA", type=INT64, column=t.aaA#1)
| +-ColumnDefinition(name="b", type=INT32, column=t.b#2)
+-primary_key=
  +-PrimaryKey(column_offset_list=[0], column_name_list=[Aaa])
==

create table t1 (c1 int32, c2 int32, c3 int32, c4 int32, c5 int32, primary key (c3, c5, c1));
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT32, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=INT32, column=t1.c3#3)
| +-ColumnDefinition(name="c4", type=INT32, column=t1.c4#4)
| +-ColumnDefinition(name="c5", type=INT32, column=t1.c5#5)
+-primary_key=
  +-PrimaryKey(column_offset_list=[2, 4, 0], column_name_list=[c3, c5, c1])
==

# Could not resolve type.
create table t1 (int64 a, b string);
--
ERROR: Type not found: a [at 1:24]
create table t1 (int64 a, b string);
                       ^
==

# Non-unique column names.
create table t2 (a int64, a int64, b string);
--
ERROR: Duplicate column name a in CREATE TABLE [at 1:27]
create table t2 (a int64, a int64, b string);
                          ^
==

# Column names must unique with case insensitive comparison.
create table t2 (aaA int64, Aaa int64, b string);
--
ERROR: Duplicate column name Aaa in CREATE TABLE [at 1:29]
create table t2 (aaA int64, Aaa int64, b string);
                            ^
==

create table t;
--
ERROR: No column definitions in CREATE TABLE [at 1:1]
create table t;
^

==

create table t (primary key());
--
ERROR: No column definitions in CREATE TABLE [at 1:1]
create table t (primary key());
^
==

create table t (a int64 PRIMARY KEY, b int32 PRIMARY KEY, c int64);
--
ERROR: Multiple PRIMARY KEY definitions found in CREATE TABLE [at 1:38]
create table t (a int64 PRIMARY KEY, b int32 PRIMARY KEY, c int64);
                                     ^
==

create table t (a int64 PRIMARY KEY, b int32, PRIMARY KEY(a));
--
ERROR: Multiple PRIMARY KEY definitions found in CREATE TABLE [at 1:47]
create table t (a int64 PRIMARY KEY, b int32, PRIMARY KEY(a));
                                              ^
==

create table t (PRIMARY KEY(a), a int64, b int32, PRIMARY KEY(a));
--
ERROR: Multiple PRIMARY KEY definitions found in CREATE TABLE [at 1:51]
create table t (PRIMARY KEY(a), a int64, b int32, PRIMARY KEY(a));
                                                  ^
==

create table t (a int64, primary key(a, a));
--
ERROR: Duplicate column a specified in PRIMARY KEY of CREATE TABLE [at 1:41]
create table t (a int64, primary key(a, a));
                                        ^
==

create table t (a int64, b int32, PRIMARY KEY(a, c));
--
ERROR: Unsupported primary key column c either does not exist or is a pseudocolumn [at 1:50]
create table t (a int64, b int32, PRIMARY KEY(a, c));
                                                 ^
==

create table t (aaA int64, b int32, PRIMARY KEY(aaA, aAa));
--
ERROR: Duplicate column aAa specified in PRIMARY KEY of CREATE TABLE [at 1:54]
create table t (aaA int64, b int32, PRIMARY KEY(aaA, aAa));
                                                     ^
==

# Use a path expression for table name.
create table a.b.t3 (a int64);
--
CreateTableStmt
+-name_path=a.b.t3
+-column_definition_list=
  +-ColumnDefinition(name="a", type=INT64, column=a.b.t3.a#1)
==

create {{|or replace}} {{|temporary|temp}} table {{|if not exists}} T
(a int64) options ()
--
ALTERNATION GROUP: <empty>
--
CreateTableStmt
+-name_path=T
+-column_definition_list=
  +-ColumnDefinition(name="a", type=INT64, column=T.a#1)
--
ALTERNATION GROUP: if not exists
--
CreateTableStmt
+-name_path=T
+-create_mode=CREATE_IF_NOT_EXISTS
+-column_definition_list=
  +-ColumnDefinition(name="a", type=INT64, column=T.a#1)
--
ALTERNATION GROUPS:
    temporary,
    temp,
--
CreateTableStmt
+-name_path=T
+-create_scope=CREATE_TEMP
+-column_definition_list=
  +-ColumnDefinition(name="a", type=INT64, column=T.a#1)
--
ALTERNATION GROUPS:
    temporary,if not exists
    temp,if not exists
--
CreateTableStmt
+-name_path=T
+-create_scope=CREATE_TEMP
+-create_mode=CREATE_IF_NOT_EXISTS
+-column_definition_list=
  +-ColumnDefinition(name="a", type=INT64, column=T.a#1)
--
ALTERNATION GROUP: or replace,,
--
CreateTableStmt
+-name_path=T
+-create_mode=CREATE_OR_REPLACE
+-column_definition_list=
  +-ColumnDefinition(name="a", type=INT64, column=T.a#1)
--
ALTERNATION GROUP: or replace,,if not exists
--
ERROR: CREATE TABLE cannot have both OR REPLACE and IF NOT EXISTS [at 1:1]
create or replace  table if not exists T
^
--
ALTERNATION GROUPS:
    or replace,temporary,
    or replace,temp,
--
CreateTableStmt
+-name_path=T
+-create_scope=CREATE_TEMP
+-create_mode=CREATE_OR_REPLACE
+-column_definition_list=
  +-ColumnDefinition(name="a", type=INT64, column=T.a#1)
--
ALTERNATION GROUP: or replace,temporary,if not exists
--
ERROR: CREATE TABLE cannot have both OR REPLACE and IF NOT EXISTS [at 1:1]
create or replace temporary table if not exists T
^
--
ALTERNATION GROUP: or replace,temp,if not exists
--
ERROR: CREATE TABLE cannot have both OR REPLACE and IF NOT EXISTS [at 1:1]
create or replace temp table if not exists T
^
==

[statement_context={{|module}}]
create {{public|private}} table T (a int64) options ()
--
ALTERNATION GROUP: public
--
ERROR: CREATE TABLE with PUBLIC or PRIVATE modifiers is not supported [at 1:1]
create public table T (a int64) options ()
^
--
ALTERNATION GROUP: private
--
ERROR: CREATE TABLE with PUBLIC or PRIVATE modifiers is not supported [at 1:1]
create private table T (a int64) options ()
^
--
ALTERNATION GROUP: module,public
--
ERROR: Statement not supported inside modules: CreateTableStatement [at 1:1]
create public table T (a int64) options ()
^
--
ALTERNATION GROUP: module,private
--
ERROR: Statement not supported inside modules: CreateTableStatement [at 1:1]
create private table T (a int64) options ()
^
==

# Column being marked as hidden.
create table t1 (
  c1 int32,
  c2 int64 hidden,
  c3 string primary key
);
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, is_hidden=TRUE, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-primary_key=
  +-PrimaryKey(column_offset_list=[2], column_name_list=[c3])
==

# Column with both being marked as hidden and primary key (1).
create table t1 (
  c1 int32,
  c2 int64 hidden primary key,
  c3 string
);
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, is_hidden=TRUE, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-primary_key=
  +-PrimaryKey(column_offset_list=[1], column_name_list=[c2])
==

# Column with both being marked as hidden and primary key (2).
create table t1 (
  c1 int32,
  c2 int64 primary key hidden,
  c3 string
);
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, is_hidden=TRUE, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-primary_key=
  +-PrimaryKey(column_offset_list=[1], column_name_list=[c2])
==

# Column being marked twice as hidden.
create table t1 (
  c1 int32,
  c2 int64 hidden hidden,
  c3 string
);
--
ERROR: The HIDDEN attribute was specified multiple times [at 3:19]
  c2 int64 hidden hidden,
                  ^
==

# Column being marked twice as primary key.
create table t1 (
  c1 int32,
  c2 int64 primary key primary key,
  c3 string
);
--
ERROR: The PRIMARY KEY attribute was specified multiple times [at 3:24]
  c2 int64 primary key primary key,
                       ^
==

# Column being marked twice as primary key and once hidden.
create table t1 (
  c1 int32,
  c2 int64 primary key hidden primary key,
  c3 string
);
--
ERROR: The PRIMARY KEY attribute was specified multiple times [at 3:31]
  c2 int64 primary key hidden primary key,
                              ^

==

# PARTITION BY
[language_features={{|CREATE_TABLE_PARTITION_BY|CREATE_TABLE_CLUSTER_BY|CREATE_TABLE_PARTITION_BY,CREATE_TABLE_CLUSTER_BY}}]
create table t1 (
  c1 int64,
  c2 int32,
  c3 string
)
partition by c2, cast(c3 as int64) + c1
--
ALTERNATION GROUPS:
    <empty>
    CREATE_TABLE_CLUSTER_BY
--
ERROR: CREATE TABLE with PARTITION BY is unsupported [at 6:1]
partition by c2, cast(c3 as int64) + c1
^
--
ALTERNATION GROUPS:
    CREATE_TABLE_PARTITION_BY
    CREATE_TABLE_PARTITION_BY,CREATE_TABLE_CLUSTER_BY
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT64, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT32, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-partition_by_list=
  +-ColumnRef(type=INT32, column=t1.c2#2)
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    +-Cast(STRING -> INT64)
    | +-ColumnRef(type=STRING, column=t1.c3#3)
    +-ColumnRef(type=INT64, column=t1.c1#1)
==

# PARTITION BY with struct and array column references
create table t1 (
  c1 int32,
  c2 int64,
  c3 struct<x int64, y array<struct<a BOOL, b STRING>>>
)
partition by c1, c3.x, ARRAY_LENGTH(c3.y)
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRUCT<x INT64, y ARRAY<STRUCT<a BOOL, b STRING>>>, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-partition_by_list=
  +-ColumnRef(type=INT32, column=t1.c1#1)
  +-GetStructField
  | +-type=INT64
  | +-expr=
  | | +-ColumnRef(type=STRUCT<x INT64, y ARRAY<STRUCT<a BOOL, b STRING>>>, column=t1.c3#3)
  | +-field_idx=0
  +-FunctionCall(ZetaSQL:array_length(ARRAY<STRUCT<a BOOL, b STRING>>) -> INT64)
    +-GetStructField
      +-type=ARRAY<STRUCT<a BOOL, b STRING>>
      +-expr=
      | +-ColumnRef(type=STRUCT<x INT64, y ARRAY<STRUCT<a BOOL, b STRING>>>, column=t1.c3#3)
      +-field_idx=1
==

# PARTITION BY floating point type
create table t1 (
  c1 int32,
  c2 double,
  c3 string
)
partition by c1, c3, c2
--
ERROR: PARTITION BY expression may not be a floating point type [at 6:22]
partition by c1, c3, c2
                     ^
==

# PARTITION BY non-groupable type
create table t1 (
  c1 int32,
  c2 struct<x array<int64>, y int64>,
  c3 string
)
partition by c1, c3, c2
--
ERROR: PARTITION BY expression must be groupable, but type is STRUCT [at 6:22]
partition by c1, c3, c2
                     ^
==

# PARTITION BY constant
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by c1, c3, concat('foo', 'bar'), c2
--
ERROR: PARTITION BY expression must not be constant [at 6:22]
partition by c1, c3, concat('foo', 'bar'), c2
                     ^
==

# PARTITION BY aggregate function
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by c1, c3, sum(c2)
--
ERROR: Aggregate function SUM not allowed in PARTITION BY [at 6:22]
partition by c1, c3, sum(c2)
                     ^
==

# PARTITION BY analytic function
[language_features=ANALYTIC_FUNCTIONS,CREATE_TABLE_PARTITION_BY]
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by c1, c3, sum(c2) over ()
--
ERROR: Analytic function not allowed in PARTITION BY [at 6:22]
partition by c1, c3, sum(c2) over ()
                     ^
==

# PARTITION BY with array scan
create table t1 (
  c1 int32,
  c2 int64,
  c3 struct<x int64, y array<struct<a BOOL, b STRING>>>
)
partition by c1, c2, (select min(b) AS c2 from unnest(c3.y))
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRUCT<x INT64, y ARRAY<STRUCT<a BOOL, b STRING>>>, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-partition_by_list=
  +-ColumnRef(type=INT32, column=t1.c1#1)
  +-ColumnRef(type=INT64, column=t1.c2#2)
  +-SubqueryExpr
    +-type=STRING
    +-subquery_type=SCALAR
    +-parameter_list=
    | +-ColumnRef(type=STRUCT<x INT64, y ARRAY<STRUCT<a BOOL, b STRING>>>, column=t1.c3#3)
    +-subquery=
      +-ProjectScan
        +-column_list=[$aggregate.c2#8]
        +-input_scan=
          +-AggregateScan
            +-column_list=[$aggregate.c2#8]
            +-input_scan=
            | +-ArrayScan
            |   +-column_list=[$array.$unnest1#7]
            |   +-array_expr=
            |   | +-GetStructField
            |   |   +-type=ARRAY<STRUCT<a BOOL, b STRING>>
            |   |   +-expr=
            |   |   | +-ColumnRef(type=STRUCT<x INT64, y ARRAY<STRUCT<a BOOL, b STRING>>>, column=t1.c3#3, is_correlated=TRUE)
            |   |   +-field_idx=1
            |   +-element_column=$array.$unnest1#7
            +-aggregate_list=
              +-c2#8 :=
                +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                  +-GetStructField
                    +-type=STRING
                    +-expr=
                    | +-ColumnRef(type=STRUCT<a BOOL, b STRING>, column=$array.$unnest1#7)
                    +-field_idx=1
==

# PARTITION BY with pseudo-column
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by pseudo_column_int32, c2
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-partition_by_list=
  +-ColumnRef(type=INT32, column=t1.pseudo_column_int32#4)
  +-ColumnRef(type=INT64, column=t1.c2#2)
==

# PARTITION BY with pseudo-column that shadows a column name
create table t1 (
  pseudo_column_int32 int32,
  c2 int32,
  pseudo_column_timestamp timestamp
)
partition by pseudo_column_timestamp, c2 + pseudo_column_int32
--
ERROR: Column name pseudo_column_timestamp is ambiguous [at 6:14]
partition by pseudo_column_timestamp, c2 + pseudo_column_int32
             ^
==

# PARTITION BY with pseudo-column that shadows a column name (no reference to
# it)
create table t1 (
  pseudo_column_int32 int32,
  c2 int32,
  pseudo_column_timestamp timestamp
)
partition by c2
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="pseudo_column_int32", type=INT32, column=t1.pseudo_column_int32#1)
| +-ColumnDefinition(name="c2", type=INT32, column=t1.c2#2)
| +-ColumnDefinition(name="pseudo_column_timestamp", type=TIMESTAMP, column=t1.pseudo_column_timestamp#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-partition_by_list=
  +-ColumnRef(type=INT32, column=t1.c2#2)
==

# PARTITION BY with expressions over pseudo-columns
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by c3, date(pseudo_column_timestamp),
  pseudo_column_KitchenSink.int64_key_1 + pseudo_column_int32 + c2
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-partition_by_list=
  +-ColumnRef(type=STRING, column=t1.c3#3)
  +-FunctionCall(ZetaSQL:date(TIMESTAMP, optional(0) STRING) -> DATE)
  | +-ColumnRef(type=TIMESTAMP, column=t1.pseudo_column_timestamp#6)
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | +-GetProtoField
    | | +-type=INT64
    | | +-expr=
    | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=t1.pseudo_column_kitchensink#5)
    | | +-field_descriptor=int64_key_1
    | +-Cast(INT32 -> INT64)
    |   +-ColumnRef(type=INT32, column=t1.pseudo_column_int32#4)
    +-ColumnRef(type=INT64, column=t1.c2#2)
==

# pseudo-column is not present for this table
[ddl_pseudo_column_mode=callback]
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by extra_pseudo_column_table_int64
--
ERROR: Unrecognized name: extra_pseudo_column_table_int64 [at 6:14]
partition by extra_pseudo_column_table_int64
             ^
==

# pseudo-column is present for this particular table name
[ddl_pseudo_column_mode=callback]
[no_java]
create table table_with_extra_pseudo_column (
  c1 int32,
  c2 int64,
  c3 string
)
partition by extra_pseudo_column_table_int64
--
CreateTableStmt
+-name_path=table_with_extra_pseudo_column
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=table_with_extra_pseudo_column.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=table_with_extra_pseudo_column.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=table_with_extra_pseudo_column.c3#3)
+-pseudo_column_list=[table_with_extra_pseudo_column.extra_pseudo_column_table_int64#4]
+-partition_by_list=
  +-ColumnRef(type=INT64, column=table_with_extra_pseudo_column.extra_pseudo_column_table_int64#4)
==

# pseudo-column is not present based on OPTIONS
[ddl_pseudo_column_mode=callback]
create table table_with_extra_pseudo_column (
  c1 int32,
  c2 int64,
  c3 string
)
partition by extra_pseudo_column_option_string
options (option1=1, option2=true)
--
ERROR: Unrecognized name: extra_pseudo_column_option_string [at 6:14]
partition by extra_pseudo_column_option_string
             ^
==

# pseudo-column is present for these OPTIONS
[ddl_pseudo_column_mode=callback]
[no_java]
create table table_with_extra_pseudo_column (
  c1 int32,
  c2 int64,
  c3 string
)
partition by extra_pseudo_column_option_string
options (option1=1, pseudo_column_option=true)
--
CreateTableStmt
+-name_path=table_with_extra_pseudo_column
+-option_list=
| +-option1 := Literal(type=INT64, value=1)
| +-pseudo_column_option := Literal(type=BOOL, value=true)
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=table_with_extra_pseudo_column.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=table_with_extra_pseudo_column.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=table_with_extra_pseudo_column.c3#3)
+-pseudo_column_list=table_with_extra_pseudo_column.[extra_pseudo_column_option_string#4, extra_pseudo_column_table_int64#5]
+-partition_by_list=
  +-ColumnRef(type=STRING, column=table_with_extra_pseudo_column.extra_pseudo_column_option_string#4)
==

# PARTITION BY with hint (unsupported)
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition @{hint_name=5} by c1, c2 + cast(c3 as int64)
--
ERROR: Syntax error: Expected keyword BY but got "@" [at 6:11]
partition @{hint_name=5} by c1, c2 + cast(c3 as int64)
          ^
==

# PARTITION BY with column named cluster
create table t1 (
  c1 int32,
  c2 int64,
  cluster string
)
partition by cluster
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="cluster", type=STRING, column=t1.cluster#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-partition_by_list=
  +-ColumnRef(type=STRING, column=t1.cluster#3)
==

# PARTITION BY with OPTIONS
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by c1, c2 + cast(c3 as int64)
options (foo=true)
--
CreateTableStmt
+-name_path=t1
+-option_list=
| +-foo := Literal(type=BOOL, value=true)
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-partition_by_list=
  +-ColumnRef(type=INT32, column=t1.c1#1)
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    +-ColumnRef(type=INT64, column=t1.c2#2)
    +-Cast(STRING -> INT64)
      +-ColumnRef(type=STRING, column=t1.c3#3)
==

# CLUSTER BY
[language_features={{|CREATE_TABLE_PARTITION_BY|CREATE_TABLE_CLUSTER_BY|CREATE_TABLE_PARTITION_BY,CREATE_TABLE_CLUSTER_BY}}]
create table t1 (
  c1 int64,
  c2 int32,
  c3 string
)
cluster by c2, cast(c3 as int64) + c1
--
ALTERNATION GROUPS:
    <empty>
    CREATE_TABLE_PARTITION_BY
--
ERROR: CREATE TABLE with CLUSTER BY is unsupported [at 6:1]
cluster by c2, cast(c3 as int64) + c1
^
--
ALTERNATION GROUPS:
    CREATE_TABLE_CLUSTER_BY
    CREATE_TABLE_PARTITION_BY,CREATE_TABLE_CLUSTER_BY
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT64, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT32, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-cluster_by_list=
  +-ColumnRef(type=INT32, column=t1.c2#2)
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    +-Cast(STRING -> INT64)
    | +-ColumnRef(type=STRING, column=t1.c3#3)
    +-ColumnRef(type=INT64, column=t1.c1#1)
==

# CLUSTER BY with pseudo-column
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
cluster by pseudo_column_int32, c2
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-cluster_by_list=
  +-ColumnRef(type=INT32, column=t1.pseudo_column_int32#4)
  +-ColumnRef(type=INT64, column=t1.c2#2)
==

# CLUSTER BY with expressions over pseudo-columns
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
cluster by c3, date(pseudo_column_timestamp),
  pseudo_column_KitchenSink.int64_key_1 + pseudo_column_int32 + c2
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-cluster_by_list=
  +-ColumnRef(type=STRING, column=t1.c3#3)
  +-FunctionCall(ZetaSQL:date(TIMESTAMP, optional(0) STRING) -> DATE)
  | +-ColumnRef(type=TIMESTAMP, column=t1.pseudo_column_timestamp#6)
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | +-GetProtoField
    | | +-type=INT64
    | | +-expr=
    | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=t1.pseudo_column_kitchensink#5)
    | | +-field_descriptor=int64_key_1
    | +-Cast(INT32 -> INT64)
    |   +-ColumnRef(type=INT32, column=t1.pseudo_column_int32#4)
    +-ColumnRef(type=INT64, column=t1.c2#2)
==

# CLUSTER BY with hint (unsupported)
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
cluster @{hint_name=5} by c1, c2 + 5, c3
--
ERROR: Syntax error: Expected keyword BY but got "@" [at 6:9]
cluster @{hint_name=5} by c1, c2 + 5, c3
        ^
==

# CLUSTER BY floating point type
create table t1 (
  c1 int32,
  c2 double,
  c3 string
)
cluster by c1, c3, c2
--
ERROR: CLUSTER BY expression may not be a floating point type [at 6:20]
cluster by c1, c3, c2
                   ^
==

# CLUSTER BY non-groupable type
create table t1 (
  c1 int32,
  c2 struct<x array<int64>, y int64>,
  c3 string
)
cluster by c1, c3, c2
--
ERROR: CLUSTER BY expression must be groupable, but type is STRUCT [at 6:20]
cluster by c1, c3, c2
                   ^
==

# CLUSTER BY Geography type
[language_features={{CREATE_TABLE_CLUSTER_BY|CREATE_TABLE_CLUSTER_BY,GEOGRAPHY}}]
create table t1 (
  c1 int32,
  c2 int64,
  c3 geography
)
cluster by c1, c3, c2
--
ALTERNATION GROUP: CREATE_TABLE_CLUSTER_BY
--
ERROR: Type not found: geography [at 4:6]
  c3 geography
     ^
--
ALTERNATION GROUP: CREATE_TABLE_CLUSTER_BY,GEOGRAPHY
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=GEOGRAPHY, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-cluster_by_list=
  +-ColumnRef(type=INT32, column=t1.c1#1)
  +-ColumnRef(type=GEOGRAPHY, column=t1.c3#3)
  +-ColumnRef(type=INT64, column=t1.c2#2)
==

# CLUSTER BY aggregate function
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
cluster by c1, c3, sum(c2)
--
ERROR: Aggregate function SUM not allowed in CLUSTER BY [at 6:20]
cluster by c1, c3, sum(c2)
                   ^
==

# CLUSTER BY analytic function
[language_features=ANALYTIC_FUNCTIONS,CREATE_TABLE_CLUSTER_BY]
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
cluster by c1, c3, sum(c2) over ()
--
ERROR: Analytic function not allowed in CLUSTER BY [at 6:20]
cluster by c1, c3, sum(c2) over ()
                   ^
==

# CLUSTER BY constant
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
cluster by c1, c3, concat('foo', 'bar'), c2
--
ERROR: CLUSTER BY expression must not be constant [at 6:20]
cluster by c1, c3, concat('foo', 'bar'), c2
                   ^
==

# PARTITION BY and CLUSTER BY
[language_features={{|CREATE_TABLE_PARTITION_BY|CREATE_TABLE_CLUSTER_BY|CREATE_TABLE_PARTITION_BY,CREATE_TABLE_CLUSTER_BY}}]
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by c1, c2 + cast(c3 as int64)
cluster by mod(c1, 2)
--
ALTERNATION GROUPS:
    <empty>
    CREATE_TABLE_CLUSTER_BY
--
ERROR: CREATE TABLE with PARTITION BY is unsupported [at 6:1]
partition by c1, c2 + cast(c3 as int64)
^
--
ALTERNATION GROUP: CREATE_TABLE_PARTITION_BY
--
ERROR: CREATE TABLE with CLUSTER BY is unsupported [at 7:1]
cluster by mod(c1, 2)
^
--
ALTERNATION GROUP: CREATE_TABLE_PARTITION_BY,CREATE_TABLE_CLUSTER_BY
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-partition_by_list=
| +-ColumnRef(type=INT32, column=t1.c1#1)
| +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
|   +-ColumnRef(type=INT64, column=t1.c2#2)
|   +-Cast(STRING -> INT64)
|     +-ColumnRef(type=STRING, column=t1.c3#3)
+-cluster_by_list=
  +-FunctionCall(ZetaSQL:mod(INT64, INT64) -> INT64)
    +-Cast(INT32 -> INT64)
    | +-ColumnRef(type=INT32, column=t1.c1#1)
    +-Literal(type=INT64, value=2)
==

# PARTITION BY and CLUSTER BY with pseudo-columns
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by pseudo_column_timestamp
cluster by c3, pseudo_column_KitchenSink.int64_key_1 + pseudo_column_int32 + c2
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-partition_by_list=
| +-ColumnRef(type=TIMESTAMP, column=t1.pseudo_column_timestamp#6)
+-cluster_by_list=
  +-ColumnRef(type=STRING, column=t1.c3#3)
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | +-GetProtoField
    | | +-type=INT64
    | | +-expr=
    | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=t1.pseudo_column_kitchensink#5)
    | | +-field_descriptor=int64_key_1
    | +-Cast(INT32 -> INT64)
    |   +-ColumnRef(type=INT32, column=t1.pseudo_column_int32#4)
    +-ColumnRef(type=INT64, column=t1.c2#2)
==

# PARTITION BY and CLUSTER BY with OPTIONS
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by c1, c2 + cast(c3 as int64)
cluster by mod(c1, 2)
options (foo=true)
--
CreateTableStmt
+-name_path=t1
+-option_list=
| +-foo := Literal(type=BOOL, value=true)
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-partition_by_list=
| +-ColumnRef(type=INT32, column=t1.c1#1)
| +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
|   +-ColumnRef(type=INT64, column=t1.c2#2)
|   +-Cast(STRING -> INT64)
|     +-ColumnRef(type=STRING, column=t1.c3#3)
+-cluster_by_list=
  +-FunctionCall(ZetaSQL:mod(INT64, INT64) -> INT64)
    +-Cast(INT32 -> INT64)
    | +-ColumnRef(type=INT32, column=t1.c1#1)
    +-Literal(type=INT64, value=2)
==

# PARTITION BY with a query parameter
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by concat(c3, @test_param_string)
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-partition_by_list=
  +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    +-ColumnRef(type=STRING, column=t1.c3#3)
    +-Parameter(type=STRING, name="test_param_string")
==

# CLUSTER BY with a query parameter
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
cluster by concat(c3, @test_param_string)
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
| +-ColumnDefinition(name="c2", type=INT64, column=t1.c2#2)
| +-ColumnDefinition(name="c3", type=STRING, column=t1.c3#3)
+-pseudo_column_list=t1.[pseudo_column_int32#4, pseudo_column_kitchensink#5, pseudo_column_timestamp#6]
+-cluster_by_list=
  +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    +-ColumnRef(type=STRING, column=t1.c3#3)
    +-Parameter(type=STRING, name="test_param_string")
==

# PARTITION BY with no expressions
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by
--
ERROR: Syntax error: Unexpected end of statement [at 6:13]
partition by
            ^
==

# PARTITION BY with table reference
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by (select key from KeyValue)
--
ERROR: PARTITION BY expression cannot contain a table scan [at 6:31]
partition by (select key from KeyValue)
                              ^
==

# PARTITION BY with self-reference
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by (select c1 from t1)
--
ERROR: PARTITION BY expression cannot contain a table scan [at 6:30]
partition by (select c1 from t1)
                             ^
==

# PARTITION BY with type mismatch in expression
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by c1, c2 + 5 = c3
--
ERROR: No matching signature for operator = for argument types: INT64, STRING. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 6:18]
partition by c1, c2 + 5 = c3
                 ^
==

# CLUSTER BY with no expressions
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
cluster by
--
ERROR: Syntax error: Unexpected end of statement [at 6:11]
cluster by
          ^
==

# CLUSTER BY with table reference
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
cluster by (select key from KeyValue)
--
ERROR: CLUSTER BY expression cannot contain a table scan [at 6:29]
cluster by (select key from KeyValue)
                            ^
==

# NOT NULL constraint.
[language_features={{|CREATE_TABLE_NOT_NULL|CREATE_TABLE_NOT_NULL,CREATE_TABLE_FIELD_ANNOTATIONS}}]
create table t1 (
  c1 int32 not null,
  c2 STRUCT<x int64 not null, y bytes> not null,
  c3 STRUCT<int64, bytes not null>,
  c4 ARRAY<STRUCT<> not null>
);
--
ALTERNATION GROUP: <empty>

--
ERROR: NOT NULL constraint is unsupported [at 2:12]
  c1 int32 not null,
           ^
--
ALTERNATION GROUP: CREATE_TABLE_NOT_NULL
--
ERROR: Nested column attributes are unsupported [at 3:21]
  c2 STRUCT<x int64 not null, y bytes> not null,
                    ^
--
ALTERNATION GROUP: CREATE_TABLE_NOT_NULL,CREATE_TABLE_FIELD_ANNOTATIONS
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
  +-ColumnDefinition
  | +-name="c1"
  | +-type=INT32
  | +-annotations=
  | | +-ColumnAnnotations(not_null=TRUE)
  | +-column=t1.c1#1
  +-ColumnDefinition
  | +-name="c2"
  | +-type=STRUCT<x INT64, y BYTES>
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-not_null=TRUE
  | |   +-child_list=
  | |     +-ColumnAnnotations(not_null=TRUE)
  | +-column=t1.c2#2
  +-ColumnDefinition
  | +-name="c3"
  | +-type=STRUCT<INT64, BYTES>
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-child_list=
  | |     +-ColumnAnnotations
  | |     +-ColumnAnnotations(not_null=TRUE)
  | +-column=t1.c3#3
  +-ColumnDefinition
    +-name="c4"
    +-type=ARRAY<STRUCT<>>
    +-annotations=
    | +-ColumnAnnotations
    |   +-child_list=
    |     +-ColumnAnnotations(not_null=TRUE)
    +-column=t1.c4#4

==

# Options in nested columns
[language_features={{|CREATE_TABLE_FIELD_ANNOTATIONS}}]
create table t1 (
  c1 int32,
  c2 STRUCT<x int64 options(x="y"), y bytes> options(y="x"),
  c3 STRUCT<x int64 options(), bytes>,
  c4 ARRAY<STRUCT<>> options(x="x")
);
--
ALTERNATION GROUP: <empty>
--
ERROR: Nested column options are unsupported [at 3:28]
  c2 STRUCT<x int64 options(x="y"), y bytes> options(y="x"),
                           ^
--
ALTERNATION GROUP: CREATE_TABLE_FIELD_ANNOTATIONS
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
  +-ColumnDefinition(name="c1", type=INT32, column=t1.c1#1)
  +-ColumnDefinition
  | +-name="c2"
  | +-type=STRUCT<x INT64, y BYTES>
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-option_list=
  | |   | +-y := Literal(type=STRING, value="x")
  | |   +-child_list=
  | |     +-ColumnAnnotations
  | |       +-option_list=
  | |         +-x := Literal(type=STRING, value="y")
  | +-column=t1.c2#2
  +-ColumnDefinition(name="c3", type=STRUCT<x INT64, BYTES>, column=t1.c3#3)
  +-ColumnDefinition
    +-name="c4"
    +-type=ARRAY<STRUCT<>>
    +-annotations=
    | +-ColumnAnnotations
    |   +-option_list=
    |     +-x := Literal(type=STRING, value="x")
    +-column=t1.c4#4

==

# CREATE_TABLE_FIELD_ANNOTATIONS does not imply CREATE_TABLE_NOT_NULL
[language_features=CREATE_TABLE_FIELD_ANNOTATIONS]
create table t1 (
  c1 {{STRUCT<int64, bytes not null>| ARRAY<int64 not null>}}
);
--
ALTERNATION GROUP: STRUCT<int64, bytes not null>
--
ERROR: NOT NULL constraint is unsupported [at 2:26]
  c1 STRUCT<int64, bytes not null>
                         ^
--
ALTERNATION GROUP:  ARRAY<int64 not null>
--
ERROR: NOT NULL constraint is unsupported [at 2:19]
  c1  ARRAY<int64 not null>
                  ^
==

# Mixed annotations
[language_features={{|CREATE_TABLE_NOT_NULL|CREATE_TABLE_NOT_NULL,CREATE_TABLE_FIELD_ANNOTATIONS}}]
create table t1 (
  c1 int32 not null primary key hidden OPTIONS(a=1),
  c2 STRUCT<x int64 not null, y bytes  OPTIONS(x=2)> OPTIONS(z=0),
  c3 STRUCT<int64, z bytes not null OPTIONS(y=3)> not null,
  c4 ARRAY<STRUCT<> OPTIONS()> hidden
);
--
ALTERNATION GROUP: <empty>
--
ERROR: NOT NULL constraint is unsupported [at 2:12]
  c1 int32 not null primary key hidden OPTIONS(a=1),
           ^

--
ALTERNATION GROUP: CREATE_TABLE_NOT_NULL
--
ERROR: Nested column attributes are unsupported [at 3:21]
  c2 STRUCT<x int64 not null, y bytes  OPTIONS(x=2)> OPTIONS(z=0),
                    ^
--
ALTERNATION GROUP: CREATE_TABLE_NOT_NULL,CREATE_TABLE_FIELD_ANNOTATIONS
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition
| | +-name="c1"
| | +-type=INT32
| | +-annotations=
| | | +-ColumnAnnotations
| | |   +-not_null=TRUE
| | |   +-option_list=
| | |     +-a := Literal(type=INT64, value=1)
| | +-is_hidden=TRUE
| | +-column=t1.c1#1
| +-ColumnDefinition
| | +-name="c2"
| | +-type=STRUCT<x INT64, y BYTES>
| | +-annotations=
| | | +-ColumnAnnotations
| | |   +-option_list=
| | |   | +-z := Literal(type=INT64, value=0)
| | |   +-child_list=
| | |     +-ColumnAnnotations(not_null=TRUE)
| | |     +-ColumnAnnotations
| | |       +-option_list=
| | |         +-x := Literal(type=INT64, value=2)
| | +-column=t1.c2#2
| +-ColumnDefinition
| | +-name="c3"
| | +-type=STRUCT<INT64, z BYTES>
| | +-annotations=
| | | +-ColumnAnnotations
| | |   +-not_null=TRUE
| | |   +-child_list=
| | |     +-ColumnAnnotations
| | |     +-ColumnAnnotations
| | |       +-not_null=TRUE
| | |       +-option_list=
| | |         +-y := Literal(type=INT64, value=3)
| | +-column=t1.c3#3
| +-ColumnDefinition(name="c4", type=ARRAY<STRUCT<>>, is_hidden=TRUE, column=t1.c4#4)
+-primary_key=
  +-PrimaryKey(column_offset_list=[0], column_name_list=[c1])

==

# ARRAY<ARRAY<>>
create table t1 (c1 array<array<int64>>)
--
ERROR: Arrays of arrays are not supported [at 1:21]
create table t1 (c1 array<array<int64>>)
                    ^
==

# Generated Columns: Disabled feature
CREATE TABLE foo (a as (1));
--
ERROR: Generated columns are not supported [at 1:21]
CREATE TABLE foo (a as (1));
                    ^
==

# Generated column with explicit type.
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a int32 AS (CAST(1 as INT32)));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=INT32
    +-column=t.a#1
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
          +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
==

# Generated column without explicit type.
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a AS (CAST(1 as INT32)));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=INT32
    +-column=t.a#1
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
          +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
==

# Generated column with mismatched but assignable type.
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a int32 AS (FARM_FINGERPRINT("foo")));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=INT32
    +-column=t.a#1
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
          +-Cast(INT64 -> INT32)
            +-FunctionCall(ZetaSQL:farm_fingerprint(STRING) -> INT64)
              +-Literal(type=STRING, value="foo")
==

# Generated column with mismatched and not assignable type.
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a int32 AS (CAST("" as STRING)));
--
ERROR: Generated column expression has type STRING which cannot be assigned to column type INT32 [at 1:25]
create table t (a int32 AS (CAST("" as STRING)));
                        ^
==

# Generated column with a function that doesn't exist.
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a int32 AS (CSAT(1)));
--
ERROR: Function not found: CSAT; Did you mean cot? [at 1:29]
create table t (a int32 AS (CSAT(1)));
                            ^
==

# Generated column with an expression on another column
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a int64, b AS (CAST(a as INT32)), c AS (CAST(b as UINT32)));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
  +-ColumnDefinition
  | +-name="b"
  | +-type=INT32
  | +-column=t.b#2
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-Cast(INT64 -> INT32)
  |         +-ColumnRef(type=INT64, column=t.a#1)
  +-ColumnDefinition
    +-name="c"
    +-type=UINT32
    +-column=t.c#3
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
          +-Cast(INT32 -> UINT32)
            +-ColumnRef(type=INT32, column=t.b#2)
==

# Generated column with a expression on another column in reverse order
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (b int64 as (a), a int32);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
  | +-name="b"
  | +-type=INT64
  | +-column=t.b#2
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-Cast(INT32 -> INT64)
  |         +-ColumnRef(type=INT32, column=t.a#1)
  +-ColumnDefinition(name="a", type=INT32, column=t.a#1)
==

# Generated Columns: With Stored
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a AS (CAST(1 as INT32)) STORED);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=INT32
    +-column=t.a#1
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
        | +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
        +-stored_mode=STORED
==

# Generated Columns: With STORED VOLATILE
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a AS (CAST(1 as INT32)) STORED VOLATILE);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=INT32
    +-column=t.a#1
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
        | +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
        +-stored_mode=STORED_VOLATILE
==

# Generated Columns: Parameters (Disallowed)
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a as (cast(@param as INT64)));
--
ERROR: Query parameters cannot be used inside generated columns [at 1:28]
create table t (a as (cast(@param as INT64)));
                           ^
==

# Generated Columns: Subquery with aggregation (Disallowed)
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a as ((select max(x) from (select 1 x union all select 2 x))));
--
ERROR: Generated column expression must not include a subquery [at 1:23]
create table t (a as ((select max(x) from (select 1 x union all select 2 x))));
                      ^
==

# Generated Columns: Subquery without aggregation (Disallowed)
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a as ((select x from (select 1 x union all select 2 x))));
--
ERROR: Generated column expression must not include a subquery [at 1:23]
create table t (a as ((select x from (select 1 x union all select 2 x))));
                      ^
==

# Generated Columns: Subquery with aggregation and expression (Disallowed)
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a as (1 + (select max(x) from (select 1 x union all select 2 x))));
--
ERROR: Generated column expression must not include a subquery [at 1:27]
create table t (a as (1 + (select max(x) from (select 1 x union all select 2 ...
                          ^
==

# Generated Columns: SUM() Aggregate function (Disallowed)
[language_features=V_1_2_GENERATED_COLUMNS,ANALYTIC_FUNCTIONS]
[no_enable_literal_replacement]
create table t (a INT64, b as (SUM(a)));
--
ERROR: Aggregate function SUM not allowed in computed column expression [at 1:32]
create table t (a INT64, b as (SUM(a)));
                               ^
==

# Generated Columns: SUM() OVER() Analytic function (Disallowed)
[language_features=V_1_2_GENERATED_COLUMNS,ANALYTIC_FUNCTIONS]
[no_enable_literal_replacement]
create table t (a INT64, b as (SUM(a) OVER ()));
--
ERROR: Analytic functions cannot be used inside generated columns [at 1:32]
create table t (a INT64, b as (SUM(a) OVER ()));
                               ^
==

# Generated Columns: Using volatile function without stored
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a as (rand()));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=DOUBLE
    +-column=t.a#1
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
          +-FunctionCall(ZetaSQL:rand() -> DOUBLE)
==

# Generated Columns: Using volatile function with stored (Disallowed).
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a as (rand()) stored);
--
ERROR: Function RAND is not allowed in expressions that are stored as each invocation might return a different value [at 1:23]
create table t (a as (rand()) stored);
                      ^
==

# Generated Columns: Using volatile function with STORED VOLATILE
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a as (rand()) stored volatile);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=DOUBLE
    +-column=t.a#1
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
        | +-FunctionCall(ZetaSQL:rand() -> DOUBLE)
        +-stored_mode=STORED_VOLATILE
==

# Generated Columns: Using volatile function with stored (Disallowed).
# We are testing here that the volatile function should be detected even
# as a sub-expression.
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a as (CAST(rand() as INT64)) stored);
--
ERROR: Function RAND is not allowed in expressions that are stored as each invocation might return a different value [at 1:28]
create table t (a as (CAST(rand() as INT64)) stored);
                           ^
==

# Generated Columns: Expression on duplicate column.
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (
  a AS (CONCAT(b,b)),
  b as (c),
  c STRING
);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
  | +-name="a"
  | +-type=STRING
  | +-column=t.a#3
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
  |         +-ColumnRef(type=STRING, column=t.b#2)
  |         +-ColumnRef(type=STRING, column=t.b#2)
  +-ColumnDefinition
  | +-name="b"
  | +-type=STRING
  | +-column=t.b#2
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-ColumnRef(type=STRING, column=t.c#1)
  +-ColumnDefinition(name="c", type=STRING, column=t.c#1)
==

# Generated Columns: Two dependencies from the same function
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
CREATE TABLE T(
  c AS (CONCAT(b, d)),
  b AS (CONCAT(a)),
  a string,
  d string,
  e string
);

--
CreateTableStmt
+-name_path=T
+-column_definition_list=
  +-ColumnDefinition
  | +-name="c"
  | +-type=STRING
  | +-column=T.c#5
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
  |         +-ColumnRef(type=STRING, column=T.b#4)
  |         +-ColumnRef(type=STRING, column=T.d#2)
  +-ColumnDefinition
  | +-name="b"
  | +-type=STRING
  | +-column=T.b#4
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-FunctionCall(ZetaSQL:concat(STRING, repeated(0) STRING) -> STRING)
  |         +-ColumnRef(type=STRING, column=T.a#1)
  +-ColumnDefinition(name="a", type=STRING, column=T.a#1)
  +-ColumnDefinition(name="d", type=STRING, column=T.d#2)
  +-ColumnDefinition(name="e", type=STRING, column=T.e#3)
==


# Generated Columns: Array
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a int32, b int32 as (a), c ARRAY<int32> as ([a,b]));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition(name="a", type=INT32, column=t.a#1)
  +-ColumnDefinition
  | +-name="b"
  | +-type=INT32
  | +-column=t.b#2
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-ColumnRef(type=INT32, column=t.a#1)
  +-ColumnDefinition
    +-name="c"
    +-type=ARRAY<INT32>
    +-column=t.c#3
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
          +-FunctionCall(ZetaSQL:$make_array(repeated(2) INT32) -> ARRAY<INT32>)
            +-ColumnRef(type=INT32, column=t.a#1)
            +-ColumnRef(type=INT32, column=t.b#2)
==

# Generated Columns: Struct type
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (
  a STRUCT<int64, string> AS ((1, c)),
  b AS ((1, c)),
  c string
);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
  | +-name="a"
  | +-type=STRUCT<INT64, STRING>
  | +-column=t.a#2
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-MakeStruct
  |         +-type=STRUCT<INT64, STRING>
  |         +-field_list=
  |           +-Literal(type=INT64, value=1)
  |           +-ColumnRef(type=STRING, column=t.c#1)
  +-ColumnDefinition
  | +-name="b"
  | +-type=STRUCT<INT64, STRING>
  | +-column=t.b#3
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-MakeStruct
  |         +-type=STRUCT<INT64, STRING>
  |         +-field_list=
  |           +-Literal(type=INT64, value=1)
  |           +-ColumnRef(type=STRING, column=t.c#1)
  +-ColumnDefinition(name="c", type=STRING, column=t.c#1)
==

# Generated Columns: Reference another column with dot
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a int32, b as (t.a));
--
ERROR: Unrecognized name: t [at 1:32]
create table t (a int32, b as (t.a));
                               ^
==

# Generated Columns: Reference itself
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (a as (a+1));
--
ERROR: The column a is recursive [at 1:17]
create table t (a as (a+1));
                ^
==

# Generated Columns: Interval expression with cycle
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (
  a int64 as (EXTRACT(HOUR from b)),
  b ARRAY<DATE> as (c),
  c ARRAY<DATE> as (GENERATE_DATE_ARRAY('2016-10-05', '2016-10-09', INTERVAL a DAY))
);
--
ERROR: Recursive dependencies detected when resolving column a, which include objects (a, b, c) [at 2:3]
  a int64 as (EXTRACT(HOUR from b)),
  ^
==

# Generated Columns: More elaborate cycle (c -> a -> b -> c)
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (
  d int64,
  c int64 as (a),
  b int64 as (c),
  a int64 as (b)
);
--
ERROR: Recursive dependencies detected when resolving column c, which include objects (c, a, b) [at 3:3]
  c int64 as (a),
  ^
==

# Generated Columns: Proto with legit references.
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t1 (
  k1 int64 as (k2),
  k2 int64,
  b zetasql_test__.KitchenSinkPB as (NEW zetasql_test__.KitchenSinkPB(k1 as int64_key_1, k2 as int64_key_2))
  );
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
  +-ColumnDefinition
  | +-name="k1"
  | +-type=INT64
  | +-column=t1.k1#2
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-ColumnRef(type=INT64, column=t1.k2#1)
  +-ColumnDefinition(name="k2", type=INT64, column=t1.k2#1)
  +-ColumnDefinition
    +-name="b"
    +-type=PROTO<zetasql_test__.KitchenSinkPB>
    +-column=t1.b#3
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
          +-MakeProto
            +-type=PROTO<zetasql_test__.KitchenSinkPB>
            +-field_list=
              +-int64_key_1 := ColumnRef(type=INT64, column=t1.k1#2)
              +-int64_key_2 := ColumnRef(type=INT64, column=t1.k2#1)
==

# Generated Columns: Case No value with cycles
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t1 (
  v1 int32 as (case1),
  case1 int32 as (case when v1 < 0 then 5 else 10 end));
--
ERROR: Recursive dependencies detected when resolving column v1, which include objects (v1, case1) [at 2:3]
  v1 int32 as (case1),
  ^
==

# Generated Columns: Case With value with cycles
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t1 (
  v1 int32 as (case1),
  case1 int32 as (case v1 > 0 when 0 then 5 else 10 end));
--
ERROR: Recursive dependencies detected when resolving column v1, which include objects (v1, case1) [at 2:3]
  v1 int32 as (case1),
  ^
==

# Generated Columns: Array Element with cycles
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t1 (
  v1 array<int32> as ([v2]),
  v2 int32 as (v1[0]));
--
ERROR: Recursive dependencies detected when resolving column v1, which include objects (v1, v2) [at 2:3]
  v1 array<int32> as ([v2]),
  ^
==

# Generated Columns: IN Expression with cycles
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t1 (
  v1 int32 as (v2),
  v2 int32 as (IF(v1 in (1,2,3), 5, 10)));
--
ERROR: Recursive dependencies detected when resolving column v1, which include objects (v1, v2) [at 2:3]
  v1 int32 as (v2),
  ^
==

# Generated Columns: Cycle a->b->c with start node being b.
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (
  b int32 as (c),
  c int32 as (a),
  a int32 as (b));
--
ERROR: Recursive dependencies detected when resolving column b, which include objects (b, c, a) [at 2:3]
  b int32 as (c),
  ^
==

# Generated Column: Interesting graph without cycles
# Graph is acyclic, but it would have a cycle if it was a un-directed graph.
# A -> B -> C<-|
#       \-> D--|
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (
  a as (b),
  b as (CONCAT(c, d)),
  c string,
  d as (c));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
  | +-name="a"
  | +-type=STRING
  | +-column=t.a#4
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-ColumnRef(type=STRING, column=t.b#3)
  +-ColumnDefinition
  | +-name="b"
  | +-type=STRING
  | +-column=t.b#3
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
  |         +-ColumnRef(type=STRING, column=t.c#1)
  |         +-ColumnRef(type=STRING, column=t.d#2)
  +-ColumnDefinition(name="c", type=STRING, column=t.c#1)
  +-ColumnDefinition
    +-name="d"
    +-type=STRING
    +-column=t.d#2
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
          +-ColumnRef(type=STRING, column=t.c#1)
==

# Recursive dependencies won't change column order (b/114869529).
[language_features=V_1_2_GENERATED_COLUMNS,FOREIGN_KEYS]
[no_enable_literal_replacement]
create table t (
  a as (c),
  b int64,
  c string,
  foreign key (a) references SimpleTypes (string) on update cascade on delete cascade
);

--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition
| | +-name="a"
| | +-type=STRING
| | +-column=t.a#3
| | +-generated_column_info=
| |   +-GeneratedColumnInfo
| |     +-expression=
| |       +-ColumnRef(type=STRING, column=t.c#2)
| +-ColumnDefinition(name="b", type=INT64, column=t.b#1)
| +-ColumnDefinition(name="c", type=STRING, column=t.c#2)
+-foreign_key_list=
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[0], referenced_table=SimpleTypes, referenced_column_offset_list=[4], match_mode=SIMPLE, update_action=CASCADE, delete_action=CASCADE, enforced=TRUE, referencing_column_list=a)

==

# Generated Column: Interesting graph with cycles
# A -> B <- C<-|
#       \-> D--|
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (
  a as (b),
  b as (d),
  c as (b),
  d as (c));
--
ERROR: Recursive dependencies detected when resolving column a, which include objects (a, b, d, c) [at 2:3]
  a as (b),
  ^
==

# Generated Columns: Cycle a->b->c with start node being b.
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (
  a int32 as (c),
  b int32 as (a),
  c int32 as (b));
--
ERROR: Recursive dependencies detected when resolving column a, which include objects (a, c, b) [at 2:3]
  a int32 as (c),
  ^
==

# Generated Columns: Fail twice
[language_features=V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (
  a AS (CONCAT(b,c)),
  b as (b1),
  c as (c1),
  b1 STRING,
  c1 STRING
);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
  | +-name="a"
  | +-type=STRING
  | +-column=t.a#5
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
  |         +-ColumnRef(type=STRING, column=t.b#3)
  |         +-ColumnRef(type=STRING, column=t.c#4)
  +-ColumnDefinition
  | +-name="b"
  | +-type=STRING
  | +-column=t.b#3
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-ColumnRef(type=STRING, column=t.b1#1)
  +-ColumnDefinition
  | +-name="c"
  | +-type=STRING
  | +-column=t.c#4
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-ColumnRef(type=STRING, column=t.c1#2)
  +-ColumnDefinition(name="b1", type=STRING, column=t.b1#1)
  +-ColumnDefinition(name="c1", type=STRING, column=t.c1#2)
==

# Foreign key column and table constraints.
[language_features=FOREIGN_KEYS]
create table t (
  a string,
  b uint64
    hidden
    constraint f
      references Value (Value)
      match full
      on update restrict
      on delete cascade
      enforced
    references KeyValue (Key)
    options (),
  primary key (a),
  constraint c
    foreign key (b, a)
    references KeyValue (Key, Value)
    match simple
    on update set null
    on delete no action
    not enforced
    options ());
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=STRING, column=t.a#1)
| +-ColumnDefinition(name="b", type=UINT64, is_hidden=TRUE, column=t.b#2)
+-primary_key=
| +-PrimaryKey(column_offset_list=[0], column_name_list=[a])
+-foreign_key_list=
  +-ForeignKey(constraint_name="f", referencing_column_offset_list=[1], referenced_table=Value, referenced_column_offset_list=[0], match_mode=FULL, update_action=RESTRICT, delete_action=CASCADE, enforced=TRUE, referencing_column_list=b)
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[1], referenced_table=KeyValue, referenced_column_offset_list=[0], match_mode=SIMPLE, update_action=NO_ACTION, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=b)
  +-ForeignKey(constraint_name="c", referencing_column_offset_list=[1, 0], referenced_table=KeyValue, referenced_column_offset_list=[0, 1], match_mode=SIMPLE, update_action=SET_NULL, delete_action=NO_ACTION, enforced=FALSE, referencing_column_list=b.a)
==

# Foreign key enums.
[language_features=FOREIGN_KEYS]
create table t (
  a int64 references Value (Value) match simple,
  b int64 references Value (Value) match full,
  c int64 references Value (Value) match not distinct,
  d int64 references Value (Value) on update no action,
  e int64 references Value (Value) on update restrict,
  f int64 references Value (Value) on delete cascade,
  g int64 references Value (Value) on delete set null);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
| +-ColumnDefinition(name="b", type=INT64, column=t.b#2)
| +-ColumnDefinition(name="c", type=INT64, column=t.c#3)
| +-ColumnDefinition(name="d", type=INT64, column=t.d#4)
| +-ColumnDefinition(name="e", type=INT64, column=t.e#5)
| +-ColumnDefinition(name="f", type=INT64, column=t.f#6)
| +-ColumnDefinition(name="g", type=INT64, column=t.g#7)
+-foreign_key_list=
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[0], referenced_table=Value, referenced_column_offset_list=[0], match_mode=SIMPLE, update_action=NO_ACTION, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=a)
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[1], referenced_table=Value, referenced_column_offset_list=[0], match_mode=FULL, update_action=NO_ACTION, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=b)
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[2], referenced_table=Value, referenced_column_offset_list=[0], match_mode=NOT_DISTINCT, update_action=NO_ACTION, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=c)
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[3], referenced_table=Value, referenced_column_offset_list=[0], match_mode=SIMPLE, update_action=NO_ACTION, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=d)
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[4], referenced_table=Value, referenced_column_offset_list=[0], match_mode=SIMPLE, update_action=RESTRICT, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=e)
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[5], referenced_table=Value, referenced_column_offset_list=[0], match_mode=SIMPLE, update_action=NO_ACTION, delete_action=CASCADE, enforced=TRUE, referencing_column_list=f)
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[6], referenced_table=Value, referenced_column_offset_list=[0], match_mode=SIMPLE, update_action=NO_ACTION, delete_action=SET_NULL, enforced=TRUE, referencing_column_list=g)
==

# Foreign key column constraints not supported.
create table t (
  a int64 references Value (Value));
--
ERROR: Foreign keys are not supported [at 2:11]
  a int64 references Value (Value));
          ^
==

# Foreign key column table constraints not supported.
create table t (
  a int64,
  foreign key (a) references Value (Value));
--
ERROR: Foreign keys are not supported [at 3:3]
  foreign key (a) references Value (Value));
  ^
==

# Foreign key duplicate constraint name.
[language_features=FOREIGN_KEYS]
create table t (
  a int64,
  b int64,
  constraint c foreign key (a) references Value (Value),
  constraint C foreign key (b) references Value (Value));
--
ERROR: Duplicate constraint name C [at 5:3]
  constraint C foreign key (b) references Value (Value));
  ^
==

# Foreign key column constraint reference to more than one column.
[language_features=FOREIGN_KEYS]
create table t (
  a int64 references KeyValue (Key, Value));
--
ERROR: Foreign key definition must include exactly one column name [at 2:31]
  a int64 references KeyValue (Key, Value));
                              ^
==

# Foreign key duplicate attributes permitted.
[language_features=FOREIGN_KEYS]
create table t (
  a int64,
  b string,
  constraint c foreign key (a, b)
    references KeyValue (Key, Value)
    on update set null,
  constraint d foreign key (a, b)
    references KeyValue (Key, Value)
    on update set null);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
| +-ColumnDefinition(name="b", type=STRING, column=t.b#2)
+-foreign_key_list=
  +-ForeignKey(constraint_name="c", referencing_column_offset_list=[0, 1], referenced_table=KeyValue, referenced_column_offset_list=[0, 1], match_mode=SIMPLE, update_action=SET_NULL, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=a.b)
  +-ForeignKey(constraint_name="d", referencing_column_offset_list=[0, 1], referenced_table=KeyValue, referenced_column_offset_list=[0, 1], match_mode=SIMPLE, update_action=SET_NULL, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=a.b)
==

# Foreign key column list is empty.
[language_features=FOREIGN_KEYS]
create table t (
  a int64,
  foreign key () references Value (Value));
--
ERROR: Syntax error: Unexpected ")" [at 3:16]
  foreign key () references Value (Value));
               ^
==

# Foreign key referenced column list is empty.
[language_features=FOREIGN_KEYS]
create table t (
  a int64,
  foreign key (a) references Value ());
--
ERROR: Syntax error: Unexpected ")" [at 3:37]
  foreign key (a) references Value ());
                                    ^
==

# Foreign key column list size do not match.
[language_features=FOREIGN_KEYS]
create table t (
  a int64,
  foreign key (a) references KeyValue (Key, Value));
--
ERROR: Number of foreign columns does not match the number of referenced columns [at 3:39]
  foreign key (a) references KeyValue (Key, Value));
                                      ^
==

# Foreign key duplicate foreign key column name.
[language_features=FOREIGN_KEYS]
create table t (
  a int64,
  foreign key (a, A) references KeyValue (Key, Value));
--
ERROR: Duplicate foreign key column name [at 3:19]
  foreign key (a, A) references KeyValue (Key, Value));
                  ^
==

# Foreign key duplicate referenced column name.
[language_features=FOREIGN_KEYS]
create table t (
  a int64,
  b int64,
  foreign key (a, b) references KeyValue (Key, key));
--
ERROR: Duplicate referenced column name [at 4:48]
  foreign key (a, b) references KeyValue (Key, key));
                                               ^
==

# Foreign key referenced column not found.
[language_features=FOREIGN_KEYS]
create table t (
  a int64,
  foreign key (a) references Value (Key));
--
ERROR: Column name Key not found in Value [at 3:37]
  foreign key (a) references Value (Key));
                                    ^
==

# Foreign key referencing and referenced columns are compatible if they
# support equality. This is intended to test a few representative types; it is
# not intended to be an exhaustive list of types. See fk_numerical_columns.test
# for an exhaustive test of numerical types.
[language_features=FOREIGN_KEYS]
create table t (
  a int64 references SimpleTypes (int64),
  b string references SimpleTypes (string),
  c bytes references SimpleTypes (bytes),
  d bool references SimpleTypes (bool),
  e date references SimpleTypes (date),
  f timestamp references SimpleTypes (timestamp));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
| +-ColumnDefinition(name="b", type=STRING, column=t.b#2)
| +-ColumnDefinition(name="c", type=BYTES, column=t.c#3)
| +-ColumnDefinition(name="d", type=BOOL, column=t.d#4)
| +-ColumnDefinition(name="e", type=DATE, column=t.e#5)
| +-ColumnDefinition(name="f", type=TIMESTAMP, column=t.f#6)
+-foreign_key_list=
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[0], referenced_table=SimpleTypes, referenced_column_offset_list=[1], match_mode=SIMPLE, update_action=NO_ACTION, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=a)
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[1], referenced_table=SimpleTypes, referenced_column_offset_list=[4], match_mode=SIMPLE, update_action=NO_ACTION, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=b)
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[2], referenced_table=SimpleTypes, referenced_column_offset_list=[5], match_mode=SIMPLE, update_action=NO_ACTION, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=c)
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[3], referenced_table=SimpleTypes, referenced_column_offset_list=[6], match_mode=SIMPLE, update_action=NO_ACTION, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=d)
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[4], referenced_table=SimpleTypes, referenced_column_offset_list=[9], match_mode=SIMPLE, update_action=NO_ACTION, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=e)
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[5], referenced_table=SimpleTypes, referenced_column_offset_list=[14], match_mode=SIMPLE, update_action=NO_ACTION, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=f)
==

# Foreign key incompatible column type.
[language_features=FOREIGN_KEYS,GEOGRAPHY]
create table t (
  a geography,
  foreign key (a) references GeographyTable (geo1));
--
ERROR: The type of the referencing column a does not support equality ('=') and therefore is not compatible with foreign keys [at 3:16]
  foreign key (a) references GeographyTable (geo1));
               ^
==

# Foreign key incompatible referenced column type.
[language_features=FOREIGN_KEYS]
create table t (
  a int64,
  foreign key (a) references SimpleTypes (date));
--
ERROR: Referenced column date from SimpleTypes is not compatible with the referencing column a [at 3:43]
  foreign key (a) references SimpleTypes (date));
                                          ^
==

# Foreign key different but compatible referenced column type.
[language_features=FOREIGN_KEYS]
create table t (
  a int64,
  foreign key (a) references SimpleTypes (uint32));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
+-foreign_key_list=
  +-ForeignKey(constraint_name="", referencing_column_offset_list=[0], referenced_table=SimpleTypes, referenced_column_offset_list=[2], match_mode=SIMPLE, update_action=NO_ACTION, delete_action=NO_ACTION, enforced=TRUE, referencing_column_list=a)
==

# Foreign key duplicate attributes.
[language_features=FOREIGN_KEYS]
create table t (
  a int64 references Value (Value) match simple match not distinct);
--
ERROR: Syntax error: Expected ")" or "," but got keyword MATCH [at 2:49]
  a int64 references Value (Value) match simple match not distinct);
                                                ^
==

[language_features=FOREIGN_KEYS]
create table foo (i int64, foreign key (nonexistent) references SimpleTypes (timestamp))

--

ERROR: Unsupported foreign key column nonexistent either does not exist or is a pseudocolumn [at 1:41]
create table foo (i int64, foreign key (nonexistent) references SimpleTypes (...
                                        ^

==

[language_features=FOREIGN_KEYS]
[ddl_pseudo_column_mode=list]
create table foo (i int64, foreign key (Pseudo_Column_int32) references SimpleTypes (int32))

--

ERROR: Unsupported foreign key column Pseudo_Column_int32 either does not exist or is a pseudocolumn [at 1:41]
create table foo (i int64, foreign key (Pseudo_Column_int32) references Simpl...
                                        ^
==

# Proper error message when check constraint feature is not enabled.
create table t (
  a int64,
  b int64,
  check (a < b)
);
--
ERROR: CHECK constraints are not supported [at 4:3]
  check (a < b)
  ^
==

# Check constraint basic tests.
[language_features=CHECK_CONSTRAINT]
create table t (
  a int64,
  b int64,
  check (a < b),
  check (a < b) enforced,
  check (a < b) not enforced,
  constraint check_a_and_b_1 check (a < b),
  constraint check_a_and_b_2 check (a < b) enforced,
  constraint check_a_and_b_3 check (a < b) not enforced,
  constraint with_options check (a < b) options(foo=1)
);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
| +-ColumnDefinition(name="b", type=INT64, column=t.b#2)
+-pseudo_column_list=t.[pseudo_column_int32#3, pseudo_column_kitchensink#4, pseudo_column_timestamp#5]
+-check_constraint_list=
  +-CheckConstraint
  | +-constraint_name=""
  | +-expression=
  | | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
  | |   +-ColumnRef(type=INT64, column=t.a#1)
  | |   +-ColumnRef(type=INT64, column=t.b#2)
  | +-enforced=TRUE
  +-CheckConstraint
  | +-constraint_name=""
  | +-expression=
  | | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
  | |   +-ColumnRef(type=INT64, column=t.a#1)
  | |   +-ColumnRef(type=INT64, column=t.b#2)
  | +-enforced=TRUE
  +-CheckConstraint
  | +-constraint_name=""
  | +-expression=
  | | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
  | |   +-ColumnRef(type=INT64, column=t.a#1)
  | |   +-ColumnRef(type=INT64, column=t.b#2)
  | +-enforced=FALSE
  +-CheckConstraint
  | +-constraint_name="check_a_and_b_1"
  | +-expression=
  | | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
  | |   +-ColumnRef(type=INT64, column=t.a#1)
  | |   +-ColumnRef(type=INT64, column=t.b#2)
  | +-enforced=TRUE
  +-CheckConstraint
  | +-constraint_name="check_a_and_b_2"
  | +-expression=
  | | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
  | |   +-ColumnRef(type=INT64, column=t.a#1)
  | |   +-ColumnRef(type=INT64, column=t.b#2)
  | +-enforced=TRUE
  +-CheckConstraint
  | +-constraint_name="check_a_and_b_3"
  | +-expression=
  | | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
  | |   +-ColumnRef(type=INT64, column=t.a#1)
  | |   +-ColumnRef(type=INT64, column=t.b#2)
  | +-enforced=FALSE
  +-CheckConstraint
    +-constraint_name="with_options"
    +-expression=
    | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=t.a#1)
    |   +-ColumnRef(type=INT64, column=t.b#2)
    +-enforced=TRUE
    +-option_list=
      +-foo := Literal(type=INT64, value=1)
==

# Check constraint expression can reference generated column.
[language_features=CHECK_CONSTRAINT,V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (
  a int64,
  b as (a * 2),
  check (b != 100)
);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
| +-ColumnDefinition
|   +-name="b"
|   +-type=INT64
|   +-column=t.b#2
|   +-generated_column_info=
|     +-GeneratedColumnInfo
|       +-expression=
|         +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
|           +-ColumnRef(type=INT64, column=t.a#1)
|           +-Literal(type=INT64, value=2)
+-pseudo_column_list=t.[pseudo_column_int32#3, pseudo_column_kitchensink#4, pseudo_column_timestamp#5]
+-check_constraint_list=
  +-CheckConstraint
    +-constraint_name=""
    +-expression=
    | +-FunctionCall(ZetaSQL:$not_equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=t.b#2)
    |   +-Literal(type=INT64, value=100)
    +-enforced=TRUE
==

# Check constraint expression can reference pseudo column.
[language_features=CHECK_CONSTRAINT]
[no_enable_literal_replacement]
create table t (
  a int64,
  check (pseudo_column_timestamp > "2018-12-20 12:00:00")
);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
+-pseudo_column_list=t.[pseudo_column_int32#2, pseudo_column_kitchensink#3, pseudo_column_timestamp#4]
+-check_constraint_list=
  +-CheckConstraint
    +-constraint_name=""
    +-expression=
    | +-FunctionCall(ZetaSQL:$greater(TIMESTAMP, TIMESTAMP) -> BOOL)
    |   +-ColumnRef(type=TIMESTAMP, column=t.pseudo_column_timestamp#4)
    |   +-Literal(type=TIMESTAMP, value=2018-12-20 20:00:00+00)
    +-enforced=TRUE
==

# Check constraint expression can call built-in functions.
[language_features=CHECK_CONSTRAINT]
[no_enable_literal_replacement]
create table t (
  a ARRAY<int64>,
  check (ARRAY_LENGTH(a) > 0)
);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=ARRAY<INT64>, column=t.a#1)
+-pseudo_column_list=t.[pseudo_column_int32#2, pseudo_column_kitchensink#3, pseudo_column_timestamp#4]
+-check_constraint_list=
  +-CheckConstraint
    +-constraint_name=""
    +-expression=
    | +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |   +-FunctionCall(ZetaSQL:array_length(ARRAY<INT64>) -> INT64)
    |   | +-ColumnRef(type=ARRAY<INT64>, column=t.a#1)
    |   +-Literal(type=INT64, value=0)
    +-enforced=TRUE
==

# Check constraint expression can reference a column defined after it.
[language_features=CHECK_CONSTRAINT]
[no_enable_literal_replacement]
create table t (
  check (a != 100),
  a int64
);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
+-pseudo_column_list=t.[pseudo_column_int32#2, pseudo_column_kitchensink#3, pseudo_column_timestamp#4]
+-check_constraint_list=
  +-CheckConstraint
    +-constraint_name=""
    +-expression=
    | +-FunctionCall(ZetaSQL:$not_equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=t.a#1)
    |   +-Literal(type=INT64, value=100)
    +-enforced=TRUE
==

# Check constraint expression cannot reference table names.
[language_features=CHECK_CONSTRAINT]
[no_enable_literal_replacement]
create table t (
  a int64,
  check (t.a != 100)
);
--
ERROR: Unrecognized name: t [at 3:10]
  check (t.a != 100)
         ^
==

# Check constraint cannot reference non-existing columns.
[language_features=CHECK_CONSTRAINT]
[no_enable_literal_replacement]
create table t (
  a int64,
  check (b < 100)
);
--
ERROR: Unrecognized name: b [at 3:10]
  check (b < 100)
         ^
==

# Check constraint expression has to produce boolean result.
[language_features=CHECK_CONSTRAINT]
[no_enable_literal_replacement]
create table t (
  a string,
  check (CONCAT(a, "hello"))
);
--
ERROR: CHECK constraint expects a boolean expression [at 3:10]
  check (CONCAT(a, "hello"))
         ^
==

# Duplicate table constraint name
[language_features=CHECK_CONSTRAINT,FOREIGN_KEYS]
[no_enable_literal_replacement]
create table t (
  a int64,
  b int64,
  constraint c foreign key (a) references Value (Value),
  constraint C check (b > a)
);
--
ERROR: Duplicate constraint name C [at 5:3]
  constraint C check (b > a)
  ^
==

# Check constraint expression must not contain query parameter
[language_features=CHECK_CONSTRAINT]
[no_enable_literal_replacement]
create table t (
  a int64,
  check (a > @param)
);
--
ERROR: Query parameters cannot be used inside CHECK constraint expression [at 3:14]
  check (a > @param)
             ^
==

# Check constraint expression needs to be immutable.
[language_features=CHECK_CONSTRAINT]
[no_enable_literal_replacement]
create table t (
  a float,
  check (RAND() > a)
);
--
ERROR: Function RAND is not allowed in CHECK constraint expression as each invocation might return a different value [at 3:10]
  check (RAND() > a)
         ^
==

# Check constraint expression needs to be immutable.
[language_features=CHECK_CONSTRAINT]
create table t (
  a timestamp,
  check (CURRENT_TIMESTAMP() > a)
);
--
ERROR: Function CURRENT_TIMESTAMP is not allowed in CHECK constraint expression as each invocation might return a different value [at 3:10]
  check (CURRENT_TIMESTAMP() > a)
         ^
==

# Check constraint expression needs to be immutable, so it should not reference
# volatile columns. This is currently passing because of b/116735804.
[language_features=CHECK_CONSTRAINT,V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (
  a as (RAND() * 2.0),
  check (a > 100)
);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition
|   +-name="a"
|   +-type=DOUBLE
|   +-column=t.a#1
|   +-generated_column_info=
|     +-GeneratedColumnInfo
|       +-expression=
|         +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
|           +-FunctionCall(ZetaSQL:rand() -> DOUBLE)
|           +-Literal(type=DOUBLE, value=2)
+-pseudo_column_list=t.[pseudo_column_int32#2, pseudo_column_kitchensink#3, pseudo_column_timestamp#4]
+-check_constraint_list=
  +-CheckConstraint
    +-constraint_name=""
    +-expression=
    | +-FunctionCall(ZetaSQL:$greater(DOUBLE, DOUBLE) -> BOOL)
    |   +-ColumnRef(type=DOUBLE, column=t.a#1)
    |   +-Literal(type=DOUBLE, value=100)
    +-enforced=TRUE
==

# Aggregate functions are not allowed in check constraint expression.
[language_features=CHECK_CONSTRAINT]
[no_enable_literal_replacement]
create table t (
  a timestamp,
  check (COUNT(a) > 100)
);
--
ERROR: Aggregate function COUNT not allowed in CHECK constraint [at 3:10]
  check (COUNT(a) > 100)
         ^
==

# Analytic functions are not allowed in check constraint expression.
[language_features=CHECK_CONSTRAINT,ANALYTIC_FUNCTIONS]
[no_enable_literal_replacement]
create table t (
  a string,
  check (COUNT(a HAVING MAX (LENGTH(a))) OVER() > 0)
);
--
ERROR: Analytic function not allowed in CHECK constraint [at 3:10]
  check (COUNT(a HAVING MAX (LENGTH(a))) OVER() > 0)
         ^
==

# Check constraint expression cannot contain subqueries.
[language_features=CHECK_CONSTRAINT]
[no_enable_literal_replacement]
create table t (
  a int64,
  check ( (select 123 b) > a )
);
--
ERROR: CHECK constraint expression must not include a subquery [at 3:11]
  check ( (select 123 b) > a )
          ^
==

# Check constraint expression cannot contain subqueries.
[language_features=CHECK_CONSTRAINT]
[no_enable_literal_replacement]
create table t (
  a int64,
  check ( 0 < ARRAY_LENGTH(ARRAY(select Value from KeyValue)))
);
--
ERROR: CHECK constraint expression must not include a subquery [at 3:28]
  check ( 0 < ARRAY_LENGTH(ARRAY(select Value from KeyValue)))
                           ^
==

# Check constraint expression cannot contain subqueries.
[language_features=CHECK_CONSTRAINT]
[no_enable_literal_replacement]
create table t (
  a ARRAY<int64>,
  check (not exists (select * from KeyValue where Key = 2))
);
--
ERROR: CHECK constraint expression must not include a subquery [at 3:14]
  check (not exists (select * from KeyValue where Key = 2))
             ^
==

# Limitations in check constraint expression should only apply to the constraint
# itself, not the column definitions after it. This test checks whether the
# flag used while resolving check constraint expression is properly cleaned up.
[language_features=CHECK_CONSTRAINT,V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
create table t (
  a int64,
  check (a > 100),
  b as (RAND() * 2.0)
);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
| +-ColumnDefinition
|   +-name="b"
|   +-type=DOUBLE
|   +-column=t.b#2
|   +-generated_column_info=
|     +-GeneratedColumnInfo
|       +-expression=
|         +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
|           +-FunctionCall(ZetaSQL:rand() -> DOUBLE)
|           +-Literal(type=DOUBLE, value=2)
+-pseudo_column_list=t.[pseudo_column_int32#3, pseudo_column_kitchensink#4, pseudo_column_timestamp#5]
+-check_constraint_list=
  +-CheckConstraint
    +-constraint_name=""
    +-expression=
    | +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=t.a#1)
    |   +-Literal(type=INT64, value=100)
    +-enforced=TRUE
==

# Option values specified as identifiers without parentheses or backticks should
# be treated as literals.
create table t1 (a int32 options(option_a=literal))
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=INT32
    +-annotations=
    | +-ColumnAnnotations
    |   +-option_list=
    |     +-option_a := Literal(type=STRING, value="literal")
    +-column=t1.a#1
==

# Option values enclosed in parentheses should be parsed as
# expressions and interpreted as identifiers, not treated as literals
create table t1 (a int32 options(option_a=literal),
                 b int64 options(option_b=(TestConstantString)))
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
  +-ColumnDefinition
  | +-name="a"
  | +-type=INT32
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-option_list=
  | |     +-option_a := Literal(type=STRING, value="literal")
  | +-column=t1.a#1
  +-ColumnDefinition
    +-name="b"
    +-type=INT64
    +-annotations=
    | +-ColumnAnnotations
    |   +-option_list=
    |     +-option_b := Constant(TestConstantString, type=STRING, value="foo")
    +-column=t1.b#2
==

# Option values enclosed in parentheses should be parsed as
# expressions and interpreted as identifiers, not treated as literals.
# Including when the identifier also has backticks.
#
# Note that when the identifier contains multiple parts, the use of parentheses
# is optional.
create table t1 (
  a int32 options(option_a=literal),
  b int64 options(option_b=(`TestConstantString`)),
  c int64 options(option_c=(nested_catalog.TestConstantBool)),
  d int64 options(option_d=nested_catalog.TestConstantBool),
  e int64 options(option_e=(nested_catalog.`Test Constant-String`)),
  f int64 options(option_f=nested_catalog.`Test Constant-String`))
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
  +-ColumnDefinition
  | +-name="a"
  | +-type=INT32
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-option_list=
  | |     +-option_a := Literal(type=STRING, value="literal")
  | +-column=t1.a#1
  +-ColumnDefinition
  | +-name="b"
  | +-type=INT64
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-option_list=
  | |     +-option_b := Constant(TestConstantString, type=STRING, value="foo")
  | +-column=t1.b#2
  +-ColumnDefinition
  | +-name="c"
  | +-type=INT64
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-option_list=
  | |     +-option_c := Constant(nested_catalog.TestConstantBool, type=BOOL, value=false)
  | +-column=t1.c#3
  +-ColumnDefinition
  | +-name="d"
  | +-type=INT64
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-option_list=
  | |     +-option_d := Constant(nested_catalog.TestConstantBool, type=BOOL, value=false)
  | +-column=t1.d#4
  +-ColumnDefinition
  | +-name="e"
  | +-type=INT64
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-option_list=
  | |     +-option_e := Constant(nested_catalog.Test Constant-String, type=STRING, value="Test constant in nested catalog")
  | +-column=t1.e#5
  +-ColumnDefinition
    +-name="f"
    +-type=INT64
    +-annotations=
    | +-ColumnAnnotations
    |   +-option_list=
    |     +-option_f := Constant(nested_catalog.Test Constant-String, type=STRING, value="Test constant in nested catalog")
    +-column=t1.f#6
==

# Option values which conflict with constant names should result in an error.
create table t1 (a int32 options(option_a=literal),
                 c int64 options(option_c=TestConstantString))
--
ERROR: Unable to determine if TestConstantString is a string or expression.  If a string is intended, please enclose it with quotation marks.  If an expression is intended, please enclose it with parentheses. [at 2:43]
                 c int64 options(option_c=TestConstantString))
                                          ^
==

# Option values which conflict with constant names should result in an error,
# even when the name is in backticks.
create table t1 (a int32 options(option_a=literal),
                 c int64 options(option_c=`TestConstantString`))
--
ERROR: Unable to determine if TestConstantString is a string or expression.  If a string is intended, please enclose it with quotation marks.  If an expression is intended, please enclose it with parentheses. [at 2:43]
                 c int64 options(option_c=`TestConstantString`))
                                          ^

==

# Alternation group for PARTITION BY expressions

[language_features=CREATE_TABLE_PARTITION_BY]
create table a.b.c.T(x int64, y int64)
partition by {{x + 2, y|x / y|x + y|x * y|mod(x, y)|unknown(x, y)|unknown_col|32}}
--
ALTERNATION GROUP: x + 2, y
--
CreateTableStmt
+-name_path=a.b.c.T
+-column_definition_list=
| +-ColumnDefinition(name="x", type=INT64, column=a.b.c.T.x#1)
| +-ColumnDefinition(name="y", type=INT64, column=a.b.c.T.y#2)
+-pseudo_column_list=a.b.c.T.[pseudo_column_int32#3, pseudo_column_kitchensink#4, pseudo_column_timestamp#5]
+-partition_by_list=
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
  | +-ColumnRef(type=INT64, column=a.b.c.T.x#1)
  | +-Literal(type=INT64, value=2)
  +-ColumnRef(type=INT64, column=a.b.c.T.y#2)
--
ALTERNATION GROUP: x / y
--
ERROR: PARTITION BY expression may not be a floating point type [at 2:14]
partition by x / y
             ^
--
ALTERNATION GROUP: x + y
--
CreateTableStmt
+-name_path=a.b.c.T
+-column_definition_list=
| +-ColumnDefinition(name="x", type=INT64, column=a.b.c.T.x#1)
| +-ColumnDefinition(name="y", type=INT64, column=a.b.c.T.y#2)
+-pseudo_column_list=a.b.c.T.[pseudo_column_int32#3, pseudo_column_kitchensink#4, pseudo_column_timestamp#5]
+-partition_by_list=
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    +-ColumnRef(type=INT64, column=a.b.c.T.x#1)
    +-ColumnRef(type=INT64, column=a.b.c.T.y#2)
--
ALTERNATION GROUP: x * y
--
CreateTableStmt
+-name_path=a.b.c.T
+-column_definition_list=
| +-ColumnDefinition(name="x", type=INT64, column=a.b.c.T.x#1)
| +-ColumnDefinition(name="y", type=INT64, column=a.b.c.T.y#2)
+-pseudo_column_list=a.b.c.T.[pseudo_column_int32#3, pseudo_column_kitchensink#4, pseudo_column_timestamp#5]
+-partition_by_list=
  +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    +-ColumnRef(type=INT64, column=a.b.c.T.x#1)
    +-ColumnRef(type=INT64, column=a.b.c.T.y#2)
--
ALTERNATION GROUP: mod(x, y)
--
CreateTableStmt
+-name_path=a.b.c.T
+-column_definition_list=
| +-ColumnDefinition(name="x", type=INT64, column=a.b.c.T.x#1)
| +-ColumnDefinition(name="y", type=INT64, column=a.b.c.T.y#2)
+-pseudo_column_list=a.b.c.T.[pseudo_column_int32#3, pseudo_column_kitchensink#4, pseudo_column_timestamp#5]
+-partition_by_list=
  +-FunctionCall(ZetaSQL:mod(INT64, INT64) -> INT64)
    +-ColumnRef(type=INT64, column=a.b.c.T.x#1)
    +-ColumnRef(type=INT64, column=a.b.c.T.y#2)
--
ALTERNATION GROUP: unknown(x, y)
--
ERROR: Function not found: unknown [at 2:14]
partition by unknown(x, y)
             ^
--
ALTERNATION GROUP: unknown_col
--
ERROR: Unrecognized name: unknown_col [at 2:14]
partition by unknown_col
             ^
--
ALTERNATION GROUP: 32
--
ERROR: PARTITION BY expression must not be constant [at 2:14]
partition by 32
             ^
==

# Alternation group for different data types used in cluster by

[language_features=CREATE_TABLE_CLUSTER_BY]
create table a.b.c.T(x {{boolean|date|array<int64>|numeric}})
cluster by x
options ()
--
ALTERNATION GROUP: boolean
--
CreateTableStmt
+-name_path=a.b.c.T
+-column_definition_list=
| +-ColumnDefinition(name="x", type=BOOL, column=a.b.c.T.x#1)
+-pseudo_column_list=a.b.c.T.[pseudo_column_int32#2, pseudo_column_kitchensink#3, pseudo_column_timestamp#4]
+-cluster_by_list=
  +-ColumnRef(type=BOOL, column=a.b.c.T.x#1)
--
ALTERNATION GROUP: date
--
CreateTableStmt
+-name_path=a.b.c.T
+-column_definition_list=
| +-ColumnDefinition(name="x", type=DATE, column=a.b.c.T.x#1)
+-pseudo_column_list=a.b.c.T.[pseudo_column_int32#2, pseudo_column_kitchensink#3, pseudo_column_timestamp#4]
+-cluster_by_list=
  +-ColumnRef(type=DATE, column=a.b.c.T.x#1)
--
ALTERNATION GROUP: array<int64>
--
ERROR: CLUSTER BY expression must be groupable, but type is ARRAY [at 2:12]
cluster by x
           ^
--
ALTERNATION GROUP: numeric
--
ERROR: Type not found: numeric [at 1:24]
create table a.b.c.T(x numeric)
                       ^
==

# Alternation group for CLUSTER BY expressions

[language_features=CREATE_TABLE_CLUSTER_BY]
create table a.b.c.T(x int64, y int64)
cluster by {{x + 2|x + 2, y|x / y|x * y|max(x, y)|unknown(x, y)|unknown_col|32|"x"}}
--
ALTERNATION GROUP: x + 2
--
CreateTableStmt
+-name_path=a.b.c.T
+-column_definition_list=
| +-ColumnDefinition(name="x", type=INT64, column=a.b.c.T.x#1)
| +-ColumnDefinition(name="y", type=INT64, column=a.b.c.T.y#2)
+-pseudo_column_list=a.b.c.T.[pseudo_column_int32#3, pseudo_column_kitchensink#4, pseudo_column_timestamp#5]
+-cluster_by_list=
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    +-ColumnRef(type=INT64, column=a.b.c.T.x#1)
    +-Literal(type=INT64, value=2)
--
ALTERNATION GROUP: x + 2, y
--
CreateTableStmt
+-name_path=a.b.c.T
+-column_definition_list=
| +-ColumnDefinition(name="x", type=INT64, column=a.b.c.T.x#1)
| +-ColumnDefinition(name="y", type=INT64, column=a.b.c.T.y#2)
+-pseudo_column_list=a.b.c.T.[pseudo_column_int32#3, pseudo_column_kitchensink#4, pseudo_column_timestamp#5]
+-cluster_by_list=
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
  | +-ColumnRef(type=INT64, column=a.b.c.T.x#1)
  | +-Literal(type=INT64, value=2)
  +-ColumnRef(type=INT64, column=a.b.c.T.y#2)
--
ALTERNATION GROUP: x / y
--
ERROR: CLUSTER BY expression may not be a floating point type [at 2:12]
cluster by x / y
           ^
--
ALTERNATION GROUP: x * y
--
CreateTableStmt
+-name_path=a.b.c.T
+-column_definition_list=
| +-ColumnDefinition(name="x", type=INT64, column=a.b.c.T.x#1)
| +-ColumnDefinition(name="y", type=INT64, column=a.b.c.T.y#2)
+-pseudo_column_list=a.b.c.T.[pseudo_column_int32#3, pseudo_column_kitchensink#4, pseudo_column_timestamp#5]
+-cluster_by_list=
  +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    +-ColumnRef(type=INT64, column=a.b.c.T.x#1)
    +-ColumnRef(type=INT64, column=a.b.c.T.y#2)
--
ALTERNATION GROUP: max(x, y)
--
ERROR: Number of arguments does not match for aggregate function MAX. Supported signature: MAX(ANY) [at 2:12]
cluster by max(x, y)
           ^
--
ALTERNATION GROUP: unknown(x, y)
--
ERROR: Function not found: unknown [at 2:12]
cluster by unknown(x, y)
           ^
--
ALTERNATION GROUP: unknown_col
--
ERROR: Unrecognized name: unknown_col [at 2:12]
cluster by unknown_col
           ^
--
ALTERNATION GROUP: 32
--
ERROR: CLUSTER BY expression must not be constant [at 2:12]
cluster by 32
           ^
--
ALTERNATION GROUP: "x"
--
ERROR: CLUSTER BY expression must not be constant [at 2:12]
cluster by "x"
           ^
==

[language_features=]
create table t (aaA int64, b int32, PRIMARY KEY(Aaa) NOT ENFORCED);
--
ERROR: NOT ENFORCED primary key table constraints are unsupported [at 1:37]
create table t (aaA int64, b int32, PRIMARY KEY(Aaa) NOT ENFORCED);
                                    ^
==

[language_features=]
create table t (aaA int64, b int32 PRIMARY KEY NOT ENFORCED);
--
ERROR: NOT ENFORCED primary key column constraints are unsupported [at 1:36]
create table t (aaA int64, b int32 PRIMARY KEY NOT ENFORCED);
                                   ^
==

create table t (aaA int64, b int32, PRIMARY KEY(Aaa) NOT ENFORCED);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="aaA", type=INT64, column=t.aaA#1)
| +-ColumnDefinition(name="b", type=INT32, column=t.b#2)
+-primary_key=
  +-PrimaryKey(column_offset_list=[0], unenforced=TRUE, column_name_list=[Aaa])
==

create table t (aaA int64, b int32 PRIMARY KEY NOT ENFORCED);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="aaA", type=INT64, column=t.aaA#1)
| +-ColumnDefinition(name="b", type=INT32, column=t.b#2)
+-primary_key=
  +-PrimaryKey(column_offset_list=[1], unenforced=TRUE, column_name_list=[b])

==

# Simple parameterized type test cases, you can found more tests in
# parameterized_types.test
[language_features=PARAMETERIZED_TYPES,NUMERIC_TYPE]
create table t (a string(10), b numeric(10, 5));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
  | +-name="a"
  | +-type=STRING
  | +-annotations=
  | | +-ColumnAnnotations(type_parameters=(max_length=10))
  | +-column=t.a#1
  +-ColumnDefinition
    +-name="b"
    +-type=NUMERIC
    +-annotations=
    | +-ColumnAnnotations(type_parameters=(precision=10,scale=5))
    +-column=t.b#2
==

# Column default value: disabled feature.
CREATE TABLE foo (a int32 default 1);
--
ERROR: Column DEFAULT value is not supported. [at 1:35]
CREATE TABLE foo (a int32 default 1);
                                  ^
==

# Column default value without explicit type (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a default CAST(1 as INT32));
--
ERROR: Syntax error: Unexpected keyword DEFAULT [at 1:19]
create table t (a default CAST(1 as INT32));
                  ^
==

# Column default value with explicit type.
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default CAST(1 as INT32));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=INT32
    +-column=t.a#1
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
        +-sql="CAST(1 as INT32)"
==

# Column default value with mismatched but assignable type.
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default FARM_FINGERPRINT("foo"));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=INT32
    +-column=t.a#1
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-Cast(INT64 -> INT32)
        |   +-FunctionCall(ZetaSQL:farm_fingerprint(STRING) -> INT64)
        |     +-Literal(type=STRING, value="foo")
        +-sql='FARM_FINGERPRINT("foo")'
==

# Column default value with mismatched and not assignable type (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default (CAST("" as STRING)));
--
ERROR: Column default expression has type STRING which cannot be assigned to column type INT32 [at 1:34]
create table t (a int32 default (CAST("" as STRING)));
                                 ^
==

# Column default value, column type is double, default value is int64 (allowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a DOUBLE default FARM_FINGERPRINT("foo"));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=DOUBLE
    +-column=t.a#1
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-Cast(INT64 -> DOUBLE)
        |   +-FunctionCall(ZetaSQL:farm_fingerprint(STRING) -> INT64)
        |     +-Literal(type=STRING, value="foo")
        +-sql='FARM_FINGERPRINT("foo")'
==

# Column default value, column type is timestamp, default value is string
# (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a TIMESTAMP default (CAST("0001-01-01 00:00:00" as STRING)));
--
ERROR: Column default expression has type STRING which cannot be assigned to column type TIMESTAMP [at 1:38]
create table t (a TIMESTAMP default (CAST("0001-01-01 00:00:00" as STRING)));
                                     ^
==

# Column default value, column type is TIMESTAMP, default value is a quoted
# string, no explicit cast, the quoted string is input as TIMESTAMP.
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a TIMESTAMP default "0001-01-01 00:00:00");
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=TIMESTAMP
    +-column=t.a#1
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-Literal(type=TIMESTAMP, value=0001-01-01 07:52:58+00)
        +-sql='"0001-01-01 00:00:00"'
==

# Array column default value, column type is ARRAY<DOUBLE>, default value is
# ARRAY<INT64> (disallowed).
[language_features={{V_1_3_COLUMN_DEFAULT_VALUE|V_1_1_CAST_DIFFERENT_ARRAY_TYPES,V_1_3_COLUMN_DEFAULT_VALUE}}]
[no_enable_literal_replacement]
create table t (a ARRAY<double> default
                  [FARM_FINGERPRINT("foo"),
                   FARM_FINGERPRINT("bar")]);
--
ERROR: Column default expression has type ARRAY<INT64> which cannot be assigned to column type ARRAY<DOUBLE> [at 2:19]
                  [FARM_FINGERPRINT("foo"),
                  ^
==

# Array column default value, column type is ARRAY<TIMESTAMP>, default value is
# ARRAY<STRING> (disallowed).
[language_features={{V_1_3_COLUMN_DEFAULT_VALUE|V_1_1_CAST_DIFFERENT_ARRAY_TYPES,V_1_3_COLUMN_DEFAULT_VALUE}}]
[no_enable_literal_replacement]
create table t (a ARRAY<TIMESTAMP> default
                  [CAST("0001-01-01 00:00:00" as STRING),
                   CAST("0001-01-01 00:00:00" as STRING)]
);
--
ERROR: Column default expression has type ARRAY<STRING> which cannot be assigned to column type ARRAY<TIMESTAMP> [at 2:19]
                  [CAST("0001-01-01 00:00:00" as STRING),
                  ^
==

# Array column default value, column type is ARRAY<TIMESTAMP>, default value is
# ARRAY<STRING>, no explicit cast (disallowed).
[language_features={{V_1_3_COLUMN_DEFAULT_VALUE|V_1_1_CAST_DIFFERENT_ARRAY_TYPES,V_1_3_COLUMN_DEFAULT_VALUE}}]
[no_enable_literal_replacement]
create table t (a ARRAY<DATE> DEFAULT ["2020-01-01", "2020-01-02"]);

--
ALTERNATION GROUP: V_1_3_COLUMN_DEFAULT_VALUE
--
ERROR: Column default expression has type ARRAY<STRING> which cannot be assigned to column type ARRAY<DATE> [at 1:39]
create table t (a ARRAY<DATE> DEFAULT ["2020-01-01", "2020-01-02"]);
                                      ^
--
ALTERNATION GROUP: V_1_1_CAST_DIFFERENT_ARRAY_TYPES,V_1_3_COLUMN_DEFAULT_VALUE
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=ARRAY<DATE>
    +-column=t.a#1
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-Literal(type=ARRAY<DATE>, value=[2020-01-01, 2020-01-02])
        +-sql='["2020-01-01", "2020-01-02"]'

==

# Column has type ARRAY<int64>, default value has type ARRAY<STRING> (disallowed).
[language_features={{V_1_3_COLUMN_DEFAULT_VALUE|V_1_1_CAST_DIFFERENT_ARRAY_TYPES,V_1_3_COLUMN_DEFAULT_VALUE}}]
[no_enable_literal_replacement]
create table t (a ARRAY<int64> default ["1","2"]);
--
ERROR: Column default expression has type ARRAY<STRING> which cannot be assigned to column type ARRAY<INT64> [at 1:40]
create table t (a ARRAY<int64> default ["1","2"]);
                                       ^
==

# A STRUCT<INT64, INT64> column with an ARRAY<INT64> default value (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a STRUCT<int64, int64> default
                  [FARM_FINGERPRINT("foo"),
                   FARM_FINGERPRINT("bar")]
);
--
ERROR: Column default expression has type ARRAY<INT64> which cannot be assigned to column type STRUCT<INT64, INT64> [at 2:19]
                  [FARM_FINGERPRINT("foo"),
                  ^
==

# A STRUCT<INT64, DOUBLE> column with a STRUCT<INT64, INT64> default value
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a STRUCT<int64, double> default
                  (FARM_FINGERPRINT("foo"),
                   FARM_FINGERPRINT("bar"))
);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=STRUCT<INT64, DOUBLE>
    +-column=t.a#1
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-MakeStruct
        |   +-type=STRUCT<INT64, DOUBLE>
        |   +-field_list=
        |     +-FunctionCall(ZetaSQL:farm_fingerprint(STRING) -> INT64)
        |     | +-Literal(type=STRING, value="foo")
        |     +-Cast(INT64 -> DOUBLE)
        |       +-FunctionCall(ZetaSQL:farm_fingerprint(STRING) -> INT64)
        |         +-Literal(type=STRING, value="bar")
        +-sql='(FARM_FINGERPRINT("foo"),\n                   FARM_FINGERPRINT("bar"))'
==

# A STRUCT<int64, TIMESTAMP> column with a STRUCT<int64, STRING> default value
# (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a STRUCT<int64, TIMESTAMP> default
                  (FARM_FINGERPRINT("foo"),
                   CAST("0001-01-01 00:00:00" as STRING))
);
--
ERROR: Column default expression has type STRUCT<INT64, STRING> which cannot be assigned to column type STRUCT<INT64, TIMESTAMP> [at 2:19]
                  (FARM_FINGERPRINT("foo"),
                  ^
==

# A STRUCT<int64, STRING> column with a STRUCT<STRING, STRING> default value
# (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a STRUCT<int64, string> default ("1", "xyz"));
--
ERROR: Column default expression has type STRUCT<STRING, STRING> which cannot be assigned to column type STRUCT<INT64, STRING> [at 1:49]
create table t (a STRUCT<int64, string> default ("1", "xyz"));
                                                ^
==

# Column default value with a function that doesn't exist.
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default (CSAT(1)));
--
ERROR: Function not found: CSAT; Did you mean cot? [at 1:34]
create table t (a int32 default (CSAT(1)));
                                 ^
==

# Column default value with an expression on another column (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int64, b int32 default a+1);
--
ERROR: Default value expressions cannot reference columns [at 1:42]
create table t (a int64, b int32 default a+1);
                                         ^
==

# Column default value with a dependent column in reverse order (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default b+1, b int32);
--
ERROR: Default value expressions cannot reference columns [at 1:33]
create table t (a int32 default b+1, b int32);
                                ^
==

# A column with default value cannot also be a generated column.
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default 1 {{|GENERATED}} AS (CAST(1 as INT32)) {{|STORED}});
--
ALTERNATION GROUP: <empty>
--
ERROR: Syntax error: "DEFAULT" and "GENERATED ALWAYS AS" clauses must not be both provided for the column [at 1:36]
create table t (a int32 default 1  AS (CAST(1 as INT32)) );
                                   ^
--
ALTERNATION GROUP: STORED
--
ERROR: Syntax error: "DEFAULT" and "GENERATED ALWAYS AS" clauses must not be both provided for the column [at 1:36]
create table t (a int32 default 1  AS (CAST(1 as INT32)) STORED);
                                   ^
--
ALTERNATION GROUP: GENERATED,
--
ERROR: Syntax error: "DEFAULT" and "GENERATED ALWAYS AS" clauses must not be both provided for the column [at 1:35]
create table t (a int32 default 1 GENERATED AS (CAST(1 as INT32)) );
                                  ^
--
ALTERNATION GROUP: GENERATED,STORED
--
ERROR: Syntax error: "DEFAULT" and "GENERATED ALWAYS AS" clauses must not be both provided for the column [at 1:35]
create table t (a int32 default 1 GENERATED AS (CAST(1 as INT32)) STORED);
                                  ^
==


# A generated column cannot have a default value.
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 {{|GENERATED}} AS (CAST(1 as INT32)) {{|STORED}} default 1);
--
ALTERNATION GROUP: <empty>
--
ERROR: Syntax error: "DEFAULT" and "GENERATED ALWAYS AS" clauses must not be both provided for the column [at 1:49]
create table t (a int32  AS (CAST(1 as INT32))  default 1);
                                                ^
--
ALTERNATION GROUP: STORED
--
ERROR: Syntax error: "DEFAULT" and "GENERATED ALWAYS AS" clauses must not be both provided for the column [at 1:55]
create table t (a int32  AS (CAST(1 as INT32)) STORED default 1);
                                                      ^
--
ALTERNATION GROUP: GENERATED,
--
ERROR: Syntax error: "DEFAULT" and "GENERATED ALWAYS AS" clauses must not be both provided for the column [at 1:58]
create table t (a int32 GENERATED AS (CAST(1 as INT32))  default 1);
                                                         ^
--
ALTERNATION GROUP: GENERATED,STORED
--
ERROR: Syntax error: "DEFAULT" and "GENERATED ALWAYS AS" clauses must not be both provided for the column [at 1:64]
create table t (a int32 GENERATED AS (CAST(1 as INT32)) STORED default 1);
                                                               ^
==

# Column default value: reference itself (disallowed)
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default a+1);
--
ERROR: Default value expressions cannot reference columns [at 1:33]
create table t (a int32 default a+1);
                                ^
==

# Column default value: reference itself (disallowed)
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
CREATE TABLE T (
  a INT64 DEFAULT b,
  b INT64 DEFAULT 1,
);
--
ERROR: Default value expressions cannot reference columns [at 2:19]
  a INT64 DEFAULT b,
                  ^
==

[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default c+1);
--
ERROR: Unrecognized name: c [at 1:33]
create table t (a int32 default c+1);
                                ^
==

# Column default value: parameters (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int64 default cast(@param as INT64));
--
ERROR: Query parameters cannot be used inside a column default expression [at 1:38]
create table t (a int64 default cast(@param as INT64));
                                     ^
==

# Column default value: select query (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default (select 1));
--
ERROR: A column default expression must not include a subquery [at 1:33]
create table t (a int32 default (select 1));
                                ^
==

# Column default value: subquery with aggregation (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default (select max(x) from (select 1 x union all select 2 x)));
--
ERROR: A column default expression must not include a subquery [at 1:33]
create table t (a int32 default (select max(x) from (select 1 x union all sel...
                                ^
==

# Column default value: subquery without aggregation (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default (select x from (select 1 x union all select 2 x)));
--
ERROR: A column default expression must not include a subquery [at 1:33]
create table t (a int32 default (select x from (select 1 x union all select 2...
                                ^
==

# Column default value: subquery with aggregation and expression (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default 1 + (select max(x) from (select 1 x union all select 2 x)));
--
ERROR: A column default expression must not include a subquery [at 1:37]
create table t (a int32 default 1 + (select max(x) from (select 1 x union all...
                                    ^
==

# Column default value: SUM() aggregate function (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE,ANALYTIC_FUNCTIONS]
[no_enable_literal_replacement]
create table t (a INT64, b int64 default SUM(1.1));
--
ERROR: Aggregate function SUM not allowed in a column default expression [at 1:42]
create table t (a INT64, b int64 default SUM(1.1));
                                         ^
==

# Column default value: SUM() OVER() analytic function (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE,ANALYTIC_FUNCTIONS]
[no_enable_literal_replacement]
create table t (a INT64, b int64 default SUM(1.1) OVER ());
--
ERROR: Analytic functions cannot be used inside a column default expression [at 1:42]
create table t (a INT64, b int64 default SUM(1.1) OVER ());
                                         ^
==

# Column default value: aggregate function (disallowed).
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a INT64, b int64 default AVG(1));
--
ERROR: Aggregate function AVG not allowed in a column default expression [at 1:42]
create table t (a INT64, b int64 default AVG(1));
                                         ^
==

# Column default value: default empty string.
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a string default "");
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=STRING
    +-column=t.a#1
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-Literal(type=STRING, value="")
        +-sql='""'
==

# Column default values and generated columns in a table.
[language_features=V_1_2_GENERATED_COLUMNS,V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default 1, b as (a+1), c as (d-1), d int32);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
  | +-name="a"
  | +-type=INT32
  | +-column=t.a#2
  | +-default_value=
  |   +-ColumnDefaultValue
  |     +-expression=
  |     | +-Literal(type=INT32, value=1)
  |     +-sql="1"
  +-ColumnDefinition
  | +-name="b"
  | +-type=INT64
  | +-column=t.b#3
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
  |         +-Cast(INT32 -> INT64)
  |         | +-ColumnRef(type=INT32, column=t.a#2)
  |         +-Literal(type=INT64, value=1)
  +-ColumnDefinition
  | +-name="c"
  | +-type=INT64
  | +-column=t.c#4
  | +-generated_column_info=
  |   +-GeneratedColumnInfo
  |     +-expression=
  |       +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
  |         +-Cast(INT32 -> INT64)
  |         | +-ColumnRef(type=INT32, column=t.d#1)
  |         +-Literal(type=INT64, value=1)
  +-ColumnDefinition(name="d", type=INT32, column=t.d#1)
==

# Column default value: using volatile function.
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a double default rand());
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=DOUBLE
    +-column=t.a#1
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-FunctionCall(ZetaSQL:rand() -> DOUBLE)
        +-sql="rand()"
==

# Column default value: Array
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a ARRAY<int64> default [1,2]);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=ARRAY<INT64>
    +-column=t.a#1
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-Literal(type=ARRAY<INT64>, value=[1, 2])
        +-sql="[1,2]"
==

# Column default value: Struct type
[language_features=V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a STRUCT<int64, string> default (1, "xyz"));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=STRUCT<INT64, STRING>
    +-column=t.a#1
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-Literal(type=STRUCT<INT64, STRING>, value={1, "xyz"})
        +-sql='(1, "xyz")'
==

# Column default value is NULL and NOT NULL attribute (disallowed).
[language_features=CREATE_TABLE_NOT_NULL,V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default NULL NOT NULL);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=INT32
    +-annotations=
    | +-ColumnAnnotations(not_null=TRUE)
    +-column=t.a#1
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-Literal(type=INT32, value=NULL)
        +-sql="NULL"
==

# Column default value is NOT NULL and NOT NULL attribute (disallowed).
[language_features=CREATE_TABLE_NOT_NULL,V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default NOT NULL NOT NULL);
--
ERROR: Operands of NOT cannot be literal NULL [at 1:37]
create table t (a int32 default NOT NULL NOT NULL);
                                    ^
==

# Column default value is 1 and NOT NULL attribute.
[language_features=CREATE_TABLE_NOT_NULL,V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
create table t (a int32 default 1 NOT NULL);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="a"
    +-type=INT32
    +-annotations=
    | +-ColumnAnnotations(not_null=TRUE)
    +-column=t.a#1
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-Literal(type=INT32, value=1)
        +-sql="1"
==

# CREATE TABLE DEFAULT with lambda
[language_features=V_1_3_COLUMN_DEFAULT_VALUE,V_1_3_INLINE_LAMBDA_ARGUMENT]
[no_enable_literal_replacement]
CREATE TABLE t (c ARRAY<STRING> DEFAULT ARRAY_FILTER(['a'], c -> c = 'a'));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition
    +-name="c"
    +-type=ARRAY<STRING>
    +-column=t.c#2
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-FunctionCall(ZetaSQL:array_filter(ARRAY<STRING>, LAMBDA(STRING->BOOL)) -> ARRAY<STRING>)
        |   +-FunctionArgument
        |   | +-expr=
        |   |   +-Literal(type=ARRAY<STRING>, value=["a"])
        |   +-FunctionArgument
        |     +-inline_lambda=
        |       +-InlineLambda
        |         +-argument_list=[$lambda_arg.c#1]
        |         +-body=
        |           +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
        |             +-ColumnRef(type=STRING, column=$lambda_arg.c#1)
        |             +-Literal(type=STRING, value="a")
        +-sql="ARRAY_FILTER(['a'], c -> c = 'a')"
==

# CREATE TABLE DEFAULT with lambda and using previous column as argument.
[language_features=V_1_3_COLUMN_DEFAULT_VALUE,V_1_3_INLINE_LAMBDA_ARGUMENT]
[no_enable_literal_replacement]
CREATE TABLE t (a STRING, c ARRAY<STRING> DEFAULT ARRAY_FILTER(['a'], a -> a = 'a'));
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition(name="a", type=STRING, column=t.a#1)
  +-ColumnDefinition
    +-name="c"
    +-type=ARRAY<STRING>
    +-column=t.c#3
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-FunctionCall(ZetaSQL:array_filter(ARRAY<STRING>, LAMBDA(STRING->BOOL)) -> ARRAY<STRING>)
        |   +-FunctionArgument
        |   | +-expr=
        |   |   +-Literal(type=ARRAY<STRING>, value=["a"])
        |   +-FunctionArgument
        |     +-inline_lambda=
        |       +-InlineLambda
        |         +-argument_list=[$lambda_arg.a#2]
        |         +-body=
        |           +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
        |             +-ColumnRef(type=STRING, column=$lambda_arg.a#2)
        |             +-Literal(type=STRING, value="a")
        +-sql="ARRAY_FILTER(['a'], a -> a = 'a')"
==

# CREATE TABLE DEFAULT with lambda and accessing previous column.
[language_features=V_1_3_COLUMN_DEFAULT_VALUE,V_1_3_INLINE_LAMBDA_ARGUMENT]
[no_enable_literal_replacement]
CREATE TABLE t (a STRING, c ARRAY<STRING> DEFAULT ARRAY_FILTER(['a'], c -> c = a));
--
ERROR: No matching signature for function ARRAY_FILTER for argument types: ARRAY<STRING>, LAMBDA. Supported signatures: ARRAY_FILTER(ARRAY, LAMBDA(ANY->BOOL)); ARRAY_FILTER(ARRAY, LAMBDA((ANY, INT64)->BOOL)) [at 1:51]
CREATE TABLE t (a STRING, c ARRAY<STRING> DEFAULT ARRAY_FILTER(['a'], c -> c ...
                                                  ^
==

# CREATE TABLE DEFAULT with lambda and accessing previous column.
# This should be working instead of giving error.
[language_features=V_1_2_GENERATED_COLUMNS,V_1_3_INLINE_LAMBDA_ARGUMENT]
[no_enable_literal_replacement]
CREATE TABLE T (
  a AS (b),
  b AS (ARRAY_FILTER([1, 2, 3], a -> a = 2)),
)
--
ERROR: No matching signature for function ARRAY_FILTER for argument types: ARRAY<INT64>, LAMBDA. Supported signatures: ARRAY_FILTER(ARRAY, LAMBDA(ANY->BOOL)); ARRAY_FILTER(ARRAY, LAMBDA((ANY, INT64)->BOOL)) [at 3:9]
  b AS (ARRAY_FILTER([1, 2, 3], a -> a = 2)),
        ^
==


[language_features={{|V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK}}]
create table t (a int64, b string collate 'und:ci');
--
ALTERNATION GROUP: <empty>
--
ERROR: COLLATE is not supported [at 1:35]
create table t (a int64, b string collate 'und:ci');
                                  ^
--
ALTERNATION GROUP: V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
  +-ColumnDefinition
    +-name="b"
    +-type=STRING
    +-annotations=
    | +-ColumnAnnotations
    |   +-collation_name=
    |     +-Literal(type=STRING, value="und:ci")
    +-column=t.b#2
==

[language_features={{|V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK}}]
create table t (a int64, b string collate @test_param_string);
--
ALTERNATION GROUP: <empty>
--
ERROR: COLLATE is not supported [at 1:35]
create table t (a int64, b string collate @test_param_string);
                                  ^
--
ALTERNATION GROUP: V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK
--
ERROR: COLLATE must be followed by a string literal [at 1:43]
create table t (a int64, b string collate @test_param_string);
                                          ^
==

[language_features={{|V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK}}]
create {{|temp}} table t (a int64, b string) default collate 'und:ci';
--
ALTERNATION GROUP: <empty>
--
ERROR: CREATE TABLE with DEFAULT COLLATE is not supported [at 1:45]
create  table t (a int64, b string) default collate 'und:ci';
                                            ^
--
ALTERNATION GROUP: temp
--
ERROR: CREATE TABLE with DEFAULT COLLATE is not supported [at 1:49]
create temp table t (a int64, b string) default collate 'und:ci';
                                                ^
--
ALTERNATION GROUP: V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK,
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
| +-ColumnDefinition(name="b", type=STRING, column=t.b#2)
+-collation_name=
  +-Literal(type=STRING, value="und:ci")
--
ALTERNATION GROUP: V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK,temp
--
CreateTableStmt
+-name_path=t
+-create_scope=CREATE_TEMP
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
| +-ColumnDefinition(name="b", type=STRING, column=t.b#2)
+-collation_name=
  +-Literal(type=STRING, value="und:ci")
==

[language_features={{|V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK}}]
create external table t default collate 'und:ci' options();
--
ALTERNATION GROUP: <empty>
--
ERROR: CREATE EXTERNAL TABLE with DEFAULT COLLATE is not supported [at 1:33]
create external table t default collate 'und:ci' options();
                                ^
--
ALTERNATION GROUP: V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK
--
CreateExternalTableStmt
+-name_path=t
+-collation_name=
  +-Literal(type=STRING, value="und:ci")
==

[language_features={{CREATE_TABLE_FIELD_ANNOTATIONS|CREATE_TABLE_FIELD_ANNOTATIONS,V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK}}]
create table t (a int64, b string collate 'und:cs') default collate 'und:ci';
--
ALTERNATION GROUP: CREATE_TABLE_FIELD_ANNOTATIONS
--
ERROR: CREATE TABLE with DEFAULT COLLATE is not supported [at 1:61]
create table t (a int64, b string collate 'und:cs') default collate 'und:ci';
                                                            ^
--
ALTERNATION GROUP: CREATE_TABLE_FIELD_ANNOTATIONS,V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
| +-ColumnDefinition
|   +-name="b"
|   +-type=STRING
|   +-annotations=
|   | +-ColumnAnnotations
|   |   +-collation_name=
|   |     +-Literal(type=STRING, value="und:cs")
|   +-column=t.b#2
+-collation_name=
  +-Literal(type=STRING, value="und:ci")
==

[language_features={{CREATE_TABLE_FIELD_ANNOTATIONS|CREATE_TABLE_FIELD_ANNOTATIONS,V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK}}]
create table t (a int64, b array<string collate 'und:ci'>);
--
ALTERNATION GROUP: CREATE_TABLE_FIELD_ANNOTATIONS
--
ERROR: COLLATE is not supported [at 1:41]
create table t (a int64, b array<string collate 'und:ci'>);
                                        ^
--
ALTERNATION GROUP: CREATE_TABLE_FIELD_ANNOTATIONS,V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
  +-ColumnDefinition
    +-name="b"
    +-type=ARRAY<STRING>
    +-annotations=
    | +-ColumnAnnotations
    |   +-child_list=
    |     +-ColumnAnnotations
    |       +-collation_name=
    |         +-Literal(type=STRING, value="und:ci")
    +-column=t.b#2
==

[language_features={{CREATE_TABLE_FIELD_ANNOTATIONS|CREATE_TABLE_FIELD_ANNOTATIONS,V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK}}]
create table t (a int64, b struct<int64, string collate 'und:ci', float64>);
--
ALTERNATION GROUP: CREATE_TABLE_FIELD_ANNOTATIONS
--
ERROR: COLLATE is not supported [at 1:49]
create table t (a int64, b struct<int64, string collate 'und:ci', float64>);
                                                ^
--
ALTERNATION GROUP: CREATE_TABLE_FIELD_ANNOTATIONS,V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition(name="a", type=INT64, column=t.a#1)
  +-ColumnDefinition
    +-name="b"
    +-type=STRUCT<INT64, STRING, DOUBLE>
    +-annotations=
    | +-ColumnAnnotations
    |   +-child_list=
    |     +-ColumnAnnotations
    |     +-ColumnAnnotations
    |       +-collation_name=
    |         +-Literal(type=STRING, value="und:ci")
    +-column=t.b#2
==

# PRIMARY KEY with pseudo-column
create table t1 (
  c1 int32,
  primary key (pseudo_column_int32)
)
--
ERROR: Unsupported primary key column pseudo_column_int32 either does not exist or is a pseudocolumn [at 3:16]
  primary key (pseudo_column_int32)
               ^
==

create table t (
  p zetasql_test__.TestExtraPB primary key
);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name="p", type=PROTO<zetasql_test__.TestExtraPB>, column=t.p#1)
+-primary_key=
  +-PrimaryKey(column_offset_list=[0], column_name_list=[p])
==

create table t (c int64, primary key(c {{ASC|NULLS FIRST}}));
--
ALTERNATION GROUP: ASC
--
ERROR: Ordering for primary keys is not supported [at 1:40]
create table t (c int64, primary key(c ASC));
                                       ^
--
ALTERNATION GROUP: NULLS FIRST
--
ERROR: Ordering for primary keys is not supported [at 1:39]
create table t (c int64, primary key(c NULLS FIRST));
                                      ^
==
