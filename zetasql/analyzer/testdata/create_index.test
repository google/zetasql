create index i1 on KeyValue(Value) options (x=1);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
|   +-descending=FALSE
+-option_list=
  +-x := Literal(type=INT64, value=1)
==

create index i1 on KeyValue(Key DESC, Value ASC);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-is_unique=FALSE
+-index_item_list=
  +-IndexItem
  | +-column_ref=
  | | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
  | +-descending=TRUE
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-descending=FALSE
==

# Refer to the table name in the index items.
create index i1 on KeyValue (KeyValue.Key DESC, KeyValue.Value ASC);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-is_unique=FALSE
+-index_item_list=
  +-IndexItem
  | +-column_ref=
  | | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
  | +-descending=TRUE
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-descending=FALSE
==

# Refer to the table name alias in the index items.
create index i1 on KeyValue AS foo (foo.Key DESC, foo.Value ASC);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="foo")
+-is_unique=FALSE
+-index_item_list=
  +-IndexItem
  | +-column_ref=
  | | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
  | +-descending=TRUE
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-descending=FALSE
==

create index i1 on KeyValue UNNEST(Key) (Key DESC, Value ASC);
--
ERROR: Values referenced in UNNEST must be arrays. UNNEST contains expression of type INT64 [at 1:36]
create index i1 on KeyValue UNNEST(Key) (Key DESC, Value ASC);
                                   ^
==

# Non-path expression is not supported.
create index i1 on KeyValue(Key + 1);
--
ERROR: Non-path index key expression for CREATE INDEX is not supported yet [at 1:29]
create index i1 on KeyValue(Key + 1);
                            ^
==

# Path expression on non-proto and non-struct fields is not supported.
create index i1 on KeyValue(Value.field);
--
ERROR: Cannot access field field on a value with type STRING [at 1:35]
create index i1 on KeyValue(Value.field);
                                  ^
==

create index i1 on TestTable(KitchenSink.timestamp_seconds);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=TIMESTAMP, column=TestTable.timestamp_seconds#4)
|   +-descending=FALSE
+-computed_columns_list=
  +-timestamp_seconds#4 :=
    +-GetProtoField
      +-type=TIMESTAMP
      +-expr=
      | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
      +-field_descriptor=timestamp_seconds
      +-default_value=1970-01-01 00:00:00+00
      +-format=TIMESTAMP_SECONDS
==

# Create index on the whole array works.
create index i1 on TestTable(KitchenSink.repeated_int32_val);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=ARRAY<INT32>, column=TestTable.repeated_int32_val#4)
|   +-descending=FALSE
+-computed_columns_list=
  +-repeated_int32_val#4 :=
    +-GetProtoField
      +-type=ARRAY<INT32>
      +-expr=
      | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
      +-field_descriptor=repeated_int32_val
      +-default_value=[]
==

# Create index on the elements of an array works. The UNNEST expression gets an
# implicit alias repeated_int32_val, so we are indexing on the array elements,
# not the array itself.
create index i1 on TestTable UNNEST(KitchenSink.repeated_int32_val) (repeated_int32_val);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT32, column=$array.repeated_int32_val#4)
|   +-descending=FALSE
+-unnest_expressions_list=
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<INT32>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=repeated_int32_val
    |   +-default_value=[]
    +-element_column=$array.repeated_int32_val#4
==

# Same as above but we refer to the table name in UNNEST.
create index i1 on TestTable UNNEST(TestTable.KitchenSink.repeated_int32_val)
(repeated_int32_val);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT32, column=$array.repeated_int32_val#4)
|   +-descending=FALSE
+-unnest_expressions_list=
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<INT32>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=repeated_int32_val
    |   +-default_value=[]
    +-element_column=$array.repeated_int32_val#4
==

# Same as above but we refer to the table name alias in UNNEST.
create index i1 on TestTable AS foo UNNEST(foo.KitchenSink.repeated_int32_val)
(repeated_int32_val);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="foo")
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT32, column=$array.repeated_int32_val#4)
|   +-descending=FALSE
+-unnest_expressions_list=
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<INT32>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=repeated_int32_val
    |   +-default_value=[]
    +-element_column=$array.repeated_int32_val#4
==

# Create index on the elements of an array with alias works.
create index i1 on TestTable UNNEST(KitchenSink.repeated_int32_val) AS foo (foo);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT32, column=$array.foo#4)
|   +-descending=FALSE
+-unnest_expressions_list=
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<INT32>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=repeated_int32_val
    |   +-default_value=[]
    +-element_column=$array.foo#4
==

# Create index on the elements of an array with offset works.
create index i1 on TestTable UNNEST(KitchenSink.repeated_int32_val) AS foo WITH OFFSET (foo, offset);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
| | +-column_ref=
| | | +-ColumnRef(type=INT32, column=$array.foo#4)
| | +-descending=FALSE
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT64, column=$array_offset.offset#5)
|   +-descending=FALSE
+-unnest_expressions_list=
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<INT32>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=repeated_int32_val
    |   +-default_value=[]
    +-element_column=$array.foo#4
    +-array_offset_column=
      +-ColumnHolder(column=$array_offset.offset#5)
==

# Create index on the elements of an array with offset works.
create index i1 on TestTable UNNEST(KitchenSink.repeated_int32_val)
AS foo WITH OFFSET AS offset (foo, offset);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
| | +-column_ref=
| | | +-ColumnRef(type=INT32, column=$array.foo#4)
| | +-descending=FALSE
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT64, column=$array_offset.offset#5)
|   +-descending=FALSE
+-unnest_expressions_list=
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<INT32>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=repeated_int32_val
    |   +-default_value=[]
    +-element_column=$array.foo#4
    +-array_offset_column=
      +-ColumnHolder(column=$array_offset.offset#5)
==

# Create index on the elements of an array with offset and explicit alias works.
create index i1 on TestTable UNNEST(KitchenSink.repeated_int32_val) AS foo WITH
OFFSET foo_offset (foo, foo_offset);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
| | +-column_ref=
| | | +-ColumnRef(type=INT32, column=$array.foo#4)
| | +-descending=FALSE
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT64, column=$array_offset.foo_offset#5)
|   +-descending=FALSE
+-unnest_expressions_list=
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<INT32>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=repeated_int32_val
    |   +-default_value=[]
    +-element_column=$array.foo#4
    +-array_offset_column=
      +-ColumnHolder(column=$array_offset.foo_offset#5)
==

# Unnest expression and key on extracted field together.
create index i1 on TestTable UNNEST(KitchenSink.nested_repeated_value)
(nested_repeated_value.nested_int64);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT64, column=TestTable.nested_int64#5)
|   +-descending=FALSE
+-computed_columns_list=
| +-nested_int64#5 :=
|   +-GetProtoField
|     +-type=INT64
|     +-expr=
|     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nested_repeated_value#4)
|     +-field_descriptor=nested_int64
|     +-default_value=88
+-unnest_expressions_list=
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=nested_repeated_value
    |   +-default_value=[]
    +-element_column=$array.nested_repeated_value#4
==

# Unnest two sibling arrays.
create index i1 on TestTable UNNEST(KitchenSink.repeated_int32_val)
UNNEST(KitchenSink.repeated_int64_val) (repeated_int32_val, repeated_int64_val);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
| | +-column_ref=
| | | +-ColumnRef(type=INT32, column=$array.repeated_int32_val#4)
| | +-descending=FALSE
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT64, column=$array.repeated_int64_val#5)
|   +-descending=FALSE
+-unnest_expressions_list=
  +-UnnestItem
  | +-array_expr=
  | | +-GetProtoField
  | |   +-type=ARRAY<INT32>
  | |   +-expr=
  | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
  | |   +-field_descriptor=repeated_int32_val
  | |   +-default_value=[]
  | +-element_column=$array.repeated_int32_val#4
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<INT64>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=repeated_int64_val
    |   +-default_value=[]
    +-element_column=$array.repeated_int64_val#5
==

# Unnest two nested arrays.
create index i1 on TestTable UNNEST(KitchenSink.nested_repeated_value)
UNNEST(nested_repeated_value.nested_repeated_int64)
(nested_repeated_value, nested_repeated_int64);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
| | +-column_ref=
| | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nested_repeated_value#4)
| | +-descending=FALSE
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT64, column=$array.nested_repeated_int64#5)
|   +-descending=FALSE
+-unnest_expressions_list=
  +-UnnestItem
  | +-array_expr=
  | | +-GetProtoField
  | |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
  | |   +-expr=
  | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
  | |   +-field_descriptor=nested_repeated_value
  | |   +-default_value=[]
  | +-element_column=$array.nested_repeated_value#4
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<INT64>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nested_repeated_value#4)
    |   +-field_descriptor=nested_repeated_int64
    |   +-default_value=[]
    +-element_column=$array.nested_repeated_int64#5
==

# Index on two arrays which are two fields from the same array proto.
create index i1 on TestTable UNNEST(KitchenSink.nested_repeated_value)
(nested_repeated_value.nested_repeated_int64, nested_repeated_value.nested_repeated_int32);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
| | +-column_ref=
| | | +-ColumnRef(type=ARRAY<INT64>, column=TestTable.nested_repeated_int64#5)
| | +-descending=FALSE
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=ARRAY<INT32>, column=TestTable.nested_repeated_int32#6)
|   +-descending=FALSE
+-computed_columns_list=
| +-nested_repeated_int64#5 :=
| | +-GetProtoField
| |   +-type=ARRAY<INT64>
| |   +-expr=
| |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nested_repeated_value#4)
| |   +-field_descriptor=nested_repeated_int64
| |   +-default_value=[]
| +-nested_repeated_int32#6 :=
|   +-GetProtoField
|     +-type=ARRAY<INT32>
|     +-expr=
|     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nested_repeated_value#4)
|     +-field_descriptor=nested_repeated_int32
|     +-default_value=[]
+-unnest_expressions_list=
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=nested_repeated_value
    |   +-default_value=[]
    +-element_column=$array.nested_repeated_value#4
==

# Unnest expression alias is the same with table name.
create index i1 on TestTable
UNNEST(KitchenSink.nested_repeated_value) AS TestTable (TestTable);
--
ERROR: Duplicate alias TestTable found [at 2:43]
UNNEST(KitchenSink.nested_repeated_value) AS TestTable (TestTable);
                                          ^
==

# Array offset alias is the same with table name.
create index i1 on TestTable
UNNEST(KitchenSink.nested_repeated_value) WITH OFFSET AS TestTable (TestTable);
--
ERROR: Duplicate alias TestTable found [at 2:55]
UNNEST(KitchenSink.nested_repeated_value) WITH OFFSET AS TestTable (TestTable);
                                                      ^
==

# The unnest element name with explicit alias overrides the table top level
# column name.
create index i1 on TestTable UNNEST(KitchenSink.repeated_int32_val) as key (key);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT32, column=$array.key#4)
|   +-descending=FALSE
+-unnest_expressions_list=
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<INT32>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   +-field_descriptor=repeated_int32_val
    |   +-default_value=[]
    +-element_column=$array.key#4
==

# The unnest element name with implicit alias overrides the table top level
# column name.
create index i1 on TestTable UNNEST(KitchenSink.nested_value.value) (value);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT32, column=$array.value#4)
|   +-descending=FALSE
+-unnest_expressions_list=
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<INT32>
    |   +-expr=
    |   | +-GetProtoField
    |   |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |   |   +-expr=
    |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   |   +-field_descriptor=nested_value
    |   |   +-default_value=NULL
    |   +-field_descriptor=value
    |   +-default_value=[]
    +-element_column=$array.value#4
==

# Error out if two UNNEST array elements have name collision.
create index i1 on TestTable UNNEST(KitchenSink.nested_repeated_value) AS foo
UNNEST(foo.nested_repeated_int64) AS foo
(foo);
--
ERROR: Duplicate alias foo found [at 2:35]
UNNEST(foo.nested_repeated_int64) AS foo
                                  ^
==

# Error out if UNNEST array elements and array offsets have name collision.
create index i1 on TestTable
UNNEST(KitchenSink.nested_repeated_value) AS foo WITH OFFSET AS foo
(foo.nested_repeated_int64, foo.nested_repeated_int32);
--
ERROR: Duplicate alias foo found [at 2:62]
UNNEST(KitchenSink.nested_repeated_value) AS foo WITH OFFSET AS foo
                                                             ^
==

# Error out if UNNEST array offsets have name collision.
create index i1 on TestTable
UNNEST(KitchenSink.nested_repeated_value) AS foo WITH OFFSET AS offset
UNNEST(foo.nested_repeated_int64) AS bar WITH OFFSET AS offset
(bar);
--
ERROR: Duplicate alias offset found [at 3:54]
UNNEST(foo.nested_repeated_int64) AS bar WITH OFFSET AS offset
                                                     ^
==

# Unnest non-path expression does not work yet.
create index i1 on TestTable UNNEST([1,2,3]) AS foo (foo);
--
ERROR: Non-path unnest expression for CREATE INDEX is not supported yet [at 1:37]
create index i1 on TestTable UNNEST([1,2,3]) AS foo (foo);
                                    ^
==

# Unnest non-path expression does not work yet.
create index i1 on TestTable UNNEST([1,2,3]) AS foo (foo);
--
ERROR: Non-path unnest expression for CREATE INDEX is not supported yet [at 1:37]
create index i1 on TestTable UNNEST([1,2,3]) AS foo (foo);
                                    ^
==

create index i1 on TestTable(KitchenSink.NoSuchField);
--
ERROR: Protocol buffer zetasql_test__.KitchenSinkPB does not have a field called NoSuchField [at 1:42]
create index i1 on TestTable(KitchenSink.NoSuchField);
                                         ^
==

# Mathematical expression in STORING clause.
[no_enable_literal_replacement]
create index i1 on KeyValue(key) STORING (key+1);
--

CreateIndexStmt
+-name_path=i1
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|   +-descending=FALSE
+-storing_expression_list=
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-Literal(type=INT64, value=1)
==

# Table not found.
create index i1 on NoSuchTable(a);
--
ERROR: Table not found: NoSuchTable [at 1:20]
create index i1 on NoSuchTable(a);
                   ^
==

# Column not found on index keys.
create index i1 on KeyValue(NoSuchColumn);
--
ERROR: Unrecognized name: NoSuchColumn [at 1:29]
create index i1 on KeyValue(NoSuchColumn);
                            ^
==

# Column not found on STORING clause.
create index i1 on KeyValue(Key) STORING (NoSuchColumn);
--
ERROR: Unrecognized name: NoSuchColumn [at 1:43]
create index i1 on KeyValue(Key) STORING (NoSuchColumn);
                                          ^
==

# Index key on the whole row of a SQL table is not supported.
create index i1 on KeyValue(KeyValue);
--
ERROR: Index key KeyValue is on the whole row of a SQL table, which is not supported [at 1:29]
create index i1 on KeyValue(KeyValue);
                            ^
==

# Indexing on the whole value column for value table is supported.
create index i1 on TestStructValueTable(TestStructValueTable);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestStructValueTable
+-table_scan=
| +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0])
+-is_unique=FALSE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    +-descending=FALSE
==

# Indexing on the whole value column for value table is supported.
create index i1 ON TestExtraValueTable(TestExtraValueTable);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestExtraValueTable
+-table_scan=
| +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
+-is_unique=FALSE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    +-descending=FALSE
==

# Indexing on the value table column.
create index i1 ON TestStructValueTable(a);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestStructValueTable
+-table_scan=
| +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT32, column=TestStructValueTable.a#2)
|   +-descending=FALSE
+-computed_columns_list=
  +-a#2 :=
    +-GetStructField
      +-type=INT32
      +-expr=
      | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
      +-field_idx=0
==

# Indexing on the value table column.
create index i1 ON TestExtraValueTable(int32_val1);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestExtraValueTable
+-table_scan=
| +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT32, column=TestExtraValueTable.int32_val1#4)
|   +-descending=FALSE
+-computed_columns_list=
  +-int32_val1#4 :=
    +-GetProtoField
      +-type=INT32
      +-expr=
      | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
      +-field_descriptor=int32_val1
      +-default_value=0
==

# Unnest expressions on the value table column.
create index i1 ON TestExtraValueTable UNNEST(str_value) (str_value);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestExtraValueTable
+-table_scan=
| +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=STRING, column=$array.str_value#4)
|   +-descending=FALSE
+-unnest_expressions_list=
  +-UnnestItem
    +-array_expr=
    | +-GetProtoField
    |   +-type=ARRAY<STRING>
    |   +-expr=
    |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |   +-field_descriptor=str_value
    |   +-default_value=[]
    +-element_column=$array.str_value#4
==

# Implicit aliases are supported on STORING clause.
create index i1 on KeyValue(Key) STORING (KeyValue);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
|   +-descending=FALSE
+-storing_expression_list=
  +-MakeStruct
    +-type=STRUCT<Key INT64, Value STRING>
    +-field_list=
      +-ColumnRef(type=INT64, column=KeyValue.Key#1)
      +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# Column found multiple times on index keys.
create index i1 on KeyValue(Key, Key);
--
ERROR: Column Key found multiple times in i1 [at 1:34]
create index i1 on KeyValue(Key, Key);
                                 ^
==

# Column found multiple times on STORING clause.
create index KeyValueByValueDuplicate on KeyValue(Key) STORING (Value, Value);
--
ERROR: Column Value found multiple times in KeyValueByValueDuplicate [at 1:72]
create index KeyValueByValueDuplicate on KeyValue(Key) STORING (Value, Value);
                                                                       ^
==

# Column found multiple times on index keys and STORING clause.
create index KeyValueByValueDuplicate on KeyValue(Value) STORING (Value);
--
ERROR: Column Value found multiple times in KeyValueByValueDuplicate [at 1:67]
create index KeyValueByValueDuplicate on KeyValue(Value) STORING (Value);
                                                                  ^
==

# Error resolving options.
create index i1 on KeyValue(Key) options(o=1+'2');
--
ERROR: No matching signature for operator + for argument types: INT64, STRING. Supported signatures: INT64 + INT64; UINT64 + UINT64; DOUBLE + DOUBLE [at 1:44]
create index i1 on KeyValue(Key) options(o=1+'2');
                                           ^
==

create {{|or replace}} {{|unique}} {{|search}} index {{|if not exists}} i1 on KeyValue(Key)
options()
--
ALTERNATION GROUP: <empty>
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-is_unique=FALSE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-descending=FALSE
--
ALTERNATION GROUP: if not exists
--
CreateIndexStmt
+-name_path=i1
+-create_mode=CREATE_IF_NOT_EXISTS
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-is_unique=FALSE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-descending=FALSE
--
ALTERNATION GROUP: search,
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-is_unique=FALSE
+-is_search=TRUE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-descending=FALSE
--
ALTERNATION GROUP: search,if not exists
--
CreateIndexStmt
+-name_path=i1
+-create_mode=CREATE_IF_NOT_EXISTS
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-is_unique=FALSE
+-is_search=TRUE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-descending=FALSE
--
ALTERNATION GROUP: unique,,
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-is_unique=TRUE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-descending=FALSE
--
ALTERNATION GROUP: unique,,if not exists
--
CreateIndexStmt
+-name_path=i1
+-create_mode=CREATE_IF_NOT_EXISTS
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-is_unique=TRUE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-descending=FALSE
--
ALTERNATION GROUP: unique,search,
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-is_unique=TRUE
+-is_search=TRUE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-descending=FALSE
--
ALTERNATION GROUP: unique,search,if not exists
--
CreateIndexStmt
+-name_path=i1
+-create_mode=CREATE_IF_NOT_EXISTS
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-is_unique=TRUE
+-is_search=TRUE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-descending=FALSE
--
ALTERNATION GROUP: or replace,,,
--
CreateIndexStmt
+-name_path=i1
+-create_mode=CREATE_OR_REPLACE
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-is_unique=FALSE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-descending=FALSE
--
ALTERNATION GROUP: or replace,,,if not exists
--
ERROR: CREATE INDEX cannot have both OR REPLACE and IF NOT EXISTS [at 1:1]
create or replace   index if not exists i1 on KeyValue(Key)
^
--
ALTERNATION GROUP: or replace,,search,
--
CreateIndexStmt
+-name_path=i1
+-create_mode=CREATE_OR_REPLACE
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-is_unique=FALSE
+-is_search=TRUE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-descending=FALSE
--
ALTERNATION GROUP: or replace,,search,if not exists
--
ERROR: CREATE INDEX cannot have both OR REPLACE and IF NOT EXISTS [at 1:1]
create or replace  search index if not exists i1 on KeyValue(Key)
^
--
ALTERNATION GROUP: or replace,unique,,
--
CreateIndexStmt
+-name_path=i1
+-create_mode=CREATE_OR_REPLACE
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-is_unique=TRUE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-descending=FALSE
--
ALTERNATION GROUP: or replace,unique,,if not exists
--
ERROR: CREATE INDEX cannot have both OR REPLACE and IF NOT EXISTS [at 1:1]
create or replace unique  index if not exists i1 on KeyValue(Key)
^
--
ALTERNATION GROUP: or replace,unique,search,
--
CreateIndexStmt
+-name_path=i1
+-create_mode=CREATE_OR_REPLACE
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-is_unique=TRUE
+-is_search=TRUE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-descending=FALSE
--
ALTERNATION GROUP: or replace,unique,search,if not exists
--
ERROR: CREATE INDEX cannot have both OR REPLACE and IF NOT EXISTS [at 1:1]
create or replace unique search index if not exists i1 on KeyValue(Key)
^
==

# Simple usage of storing clause.
create index KeyValueByValue on KeyValue(Value) STORING (Key);
--
CreateIndexStmt
+-name_path=KeyValueByValue
+-table_name_path=KeyValue
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
|   +-descending=FALSE
+-storing_expression_list=
  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# Storing clause with more than one column.
create index SimpleTypesStoringTwoValues on SimpleTypes(int32) STORING (int64, uint64);
--
CreateIndexStmt
+-name_path=SimpleTypesStoringTwoValues
+-table_name_path=SimpleTypes
+-table_scan=
| +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint64#4], table=SimpleTypes, column_index_list=[0, 1, 3])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
|   +-descending=FALSE
+-storing_expression_list=
  +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
  +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
==

# Storing clause with field path.
create index TestTableByEnumStoringPath ON TestTable(TestEnum) STORING(KitchenSink.int32_val);
--
CreateIndexStmt
+-name_path=TestTableByEnumStoringPath
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=TestTable.[TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[1, 2])
+-is_unique=FALSE
+-index_item_list=
| +-IndexItem
|   +-column_ref=
|   | +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#2)
|   +-descending=FALSE
+-storing_expression_list=
  +-GetProtoField
    +-type=INT32
    +-expr=
    | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    +-field_descriptor=int32_val
    +-default_value=77
==

# Storing clause with RAND (Disallowed).
create index SimpleTypesStoringRand on SimpleTypes(int32) STORING (RAND());
--
ERROR: Function RAND is not allowed in expressions that are stored as each invocation might return a different value [at 1:68]
create index SimpleTypesStoringRand on SimpleTypes(int32) STORING (RAND());
                                                                   ^
==

# Storing clause with parameter (Disallowed).
create index SimpleTypesStoringRand on SimpleTypes(int32) STORING (@param);
--
ERROR: Query parameters cannot be used inside expressions of CREATE INDEX statement [at 1:68]
create index SimpleTypesStoringRand on SimpleTypes(int32) STORING (@param);
                                                                   ^
==

# The key expression should not have asc/desc option when creating search index.
create search index i1 on KeyValue (Value asc)
--
ERROR: Key expression with ASC or DESC option for CREATE SEARCH INDEX is not allowed [at 1:37]
create search index i1 on KeyValue (Value asc)
                                    ^
==

# The key expression should not have null order option when creating search
# index.
create search index i1 on KeyValue (Value nulls first)
--
ERROR: Key expression with NULL order option for CREATE SEARCH INDEX is not allowed [at 1:37]
create search index i1 on KeyValue (Value nulls first)
                                    ^
==

# The proto column can be used as key expression when creating search index.
create search index i1 on TestTable (KitchenSink);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=TestTable
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-is_unique=FALSE
+-is_search=TRUE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    +-descending=FALSE
==

# The key expression can't refer to proto message field when creating search index.
create search index i1 on TestTable (KitchenSink.int64_key_1);
--
ERROR: CREATE SEARCH INDEX does not yet support expressions to define index keys, only column name is supported [at 1:38]
create search index i1 on TestTable (KitchenSink.int64_key_1);
                                     ^
==

# The struct column can be used as key expression when creating search index.
create search index i1 on ComplexTypes (TestStruct);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=ComplexTypes
+-table_scan=
| +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4])
+-is_unique=FALSE
+-is_search=TRUE
+-index_item_list=
  +-IndexItem
    +-column_ref=
    | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
    +-descending=FALSE
==

# The key expression can't refer to struct field when creating search index.
create search index i1 on ComplexTypes (TestStruct.c);
--
ERROR: CREATE SEARCH INDEX does not yet support expressions to define index keys, only column name is supported [at 1:41]
create search index i1 on ComplexTypes (TestStruct.c);
                                        ^
==

# Create a search index and index all columns should succeed.
create search index i1 on ComplexTypes (ALL COLUMNS);
--
CreateIndexStmt
+-name_path=i1
+-table_name_path=ComplexTypes
+-table_scan=
| +-TableScan(table=ComplexTypes)
+-is_unique=FALSE
+-is_search=TRUE
+-index_all_columns=TRUE
==

# Create a non-search index with ALL COLUMNS in key_expression should fail.
create index i1 on ComplexTypes (ALL COLUMNS);
--
ERROR: 'ALL COLUMNS' is not a supported index key expression for CREATE INDEX statement [at 1:33]
create index i1 on ComplexTypes (ALL COLUMNS);
                                ^
==

# Index an non-exist `ALL COLUMNS` column should fail.
create search index i1 on ComplexTypes (`ALL COLUMNS`);
--
ERROR: Unrecognized name: `ALL COLUMNS` [at 1:41]
create search index i1 on ComplexTypes (`ALL COLUMNS`);
                                        ^
