[default language_features=V_1_1_ORDER_BY_IN_AGGREGATE,V_1_1_ORDER_BY_COLLATE,ANALYTIC_FUNCTIONS,V_1_1_LIMIT_IN_AGGREGATE]

select array_agg(Key order by Key)
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT32, column=TestTable.key#1)

==

# The ORDER BY in aggregate function is turned off by default.
[language_features=]
select array_agg(Key order by Key)
from TestTable
--
ERROR: ORDER BY in aggregate function is not supported [at 1:22]
select array_agg(Key order by Key)
                     ^

==

select array_agg(Key order by Key + 100, key * 200)
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#6 AS `$col1` [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#6]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#6]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, $orderby.$orderbycol1#4, $orderby.$orderbycol2#5]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   | |   +-Cast(INT32 -> INT64)
        |   | |   | +-ColumnRef(type=INT32, column=TestTable.key#1)
        |   | |   +-Literal(type=INT64, value=100)
        |   | +-$orderbycol2#5 :=
        |   |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
        |   |     +-Cast(INT32 -> INT64)
        |   |     | +-ColumnRef(type=INT32, column=TestTable.key#1)
        |   |     +-Literal(type=INT64, value=200)
        |   +-input_scan=
        |     +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#6 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-order_by_item_list=
                +-OrderByItem
                | +-column_ref=
                |   +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT64, column=$orderby.$orderbycol2#5)

==

select array_agg(KitchenSink.int64_val + 1 order by Key)
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                +-GetProtoField
                | +-type=INT64
                | +-expr=
                | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                | +-field_descriptor=int64_val
                | +-default_value=0
                +-Literal(type=INT64, value=1)
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT32, column=TestTable.key#1)

==

select Key, array_agg(KitchenSink.int64_val order by Key)
from TestTable
group by Key
order by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#5 AS Key [INT32]
| +-$aggregate.$agg1#4 AS `$col2` [ARRAY<INT64>]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.Key#5, $aggregate.$agg1#4]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.Key#5, $aggregate.$agg1#4]
    |   +-input_scan=
    |   | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
    |   +-group_by_list=
    |   | +-Key#5 := ColumnRef(type=INT32, column=TestTable.key#1)
    |   +-aggregate_list=
    |     +-$agg1#4 :=
    |       +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
    |         +-GetProtoField
    |           +-type=INT64
    |           +-expr=
    |           | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |           +-field_descriptor=int64_val
    |           +-default_value=0
    |         +-order_by_item_list=
    |           +-OrderByItem
    |             +-column_ref=
    |               +-ColumnRef(type=INT32, column=TestTable.key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$groupby.Key#5)

==

select string_agg(KitchenSink.string_val order by Key + 1)
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $orderby.$orderbycol1#4]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |     +-Cast(INT32 -> INT64)
        |   |     | +-ColumnRef(type=INT32, column=TestTable.key#1)
        |   |     +-Literal(type=INT64, value=1)
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-aggregate_list=
          +-$agg1#5 :=
            +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
              +-GetProtoField
                +-type=STRING
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=string_val
                +-default_value="default_name"
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)

==

select key,
       string_agg(value order by value) as s1,
       string_agg(value, ',' order by value) as s2,
       string_agg(cast(value as bytes), b'b' order by value) as s3
from KeyValue
group by key
order by key, s1, s2, s3
--
QueryStmt
+-output_column_list=
| +-$groupby.key#6 AS key [INT64]
| +-$aggregate.s1#3 AS s1 [STRING]
| +-$aggregate.s2#4 AS s2 [STRING]
| +-$aggregate.s3#5 AS s3 [BYTES]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#6, $aggregate.s1#3, $aggregate.s2#4, $aggregate.s3#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.key#6, $aggregate.s1#3, $aggregate.s2#4, $aggregate.s3#5]
    |   +-input_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-group_by_list=
    |   | +-key#6 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-aggregate_list=
    |     +-s1#3 :=
    |     | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
    |     |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     |   +-order_by_item_list=
    |     |     +-OrderByItem
    |     |       +-column_ref=
    |     |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-s2#4 :=
    |     | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING, STRING) -> STRING)
    |     |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     |   +-Literal(type=STRING, value=",")
    |     |   +-order_by_item_list=
    |     |     +-OrderByItem
    |     |       +-column_ref=
    |     |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-s3#5 :=
    |       +-AggregateFunctionCall(ZetaSQL:string_agg(BYTES, BYTES) -> BYTES)
    |         +-Cast(STRING -> BYTES)
    |         | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |         +-Literal(type=BYTES, value=b"b")
    |         +-order_by_item_list=
    |           +-OrderByItem
    |             +-column_ref=
    |               +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.key#6)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=$aggregate.s1#3)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=$aggregate.s2#4)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=BYTES, column=$aggregate.s3#5)

==

select min(Key order by Key)
from TestTable
--
ERROR: Aggregate function MIN does not support ORDER BY in arguments [at 1:16]
select min(Key order by Key)
               ^

==

select Key,
       array_agg(KitchenSink.int64_val order by KitchenSink.int64_val),
       string_agg(KitchenSink.string_val order by KitchenSink.string_val)
from TestTable
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#8 AS Key [INT32]
| +-$aggregate.$agg1#5 AS `$col2` [ARRAY<INT64>]
| +-$aggregate.$agg2#7 AS `$col3` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#8, $aggregate.$agg1#5, $aggregate.$agg2#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#8, $aggregate.$agg1#5, $aggregate.$agg2#7]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $orderby.$orderbycol1#4, $orderby.$orderbycol1#6]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   | | +-GetProtoField
        |   | |   +-type=INT64
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   +-field_descriptor=int64_val
        |   | |   +-default_value=0
        |   | +-$orderbycol1#6 :=
        |   |   +-GetProtoField
        |   |     +-type=STRING
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=string_val
        |   |     +-default_value="default_name"
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#8 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-$agg1#5 :=
          | +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
          |   +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
          |   +-order_by_item_list=
          |     +-OrderByItem
          |       +-column_ref=
          |         +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
          +-$agg2#7 :=
            +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
              +-ColumnRef(type=STRING, column=$orderby.$orderbycol1#6)
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=STRING, column=$orderby.$orderbycol1#6)

==

select array_agg(Key order by 1)
from TestTable
--
ERROR: Aggregate functions do not allow ORDER BY by index in arguments [at 1:22]
select array_agg(Key order by 1)
                     ^

==

select a from (
    select Key, array_agg(KitchenSink.int64_val order by Key) as a
    from TestTable
    group by Key
)
--
QueryStmt
+-output_column_list=
| +-$aggregate.a#4 AS a [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.a#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$groupby.Key#5, $aggregate.a#4]
        +-input_scan=
          +-AggregateScan
            +-column_list=[$groupby.Key#5, $aggregate.a#4]
            +-input_scan=
            | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
            +-group_by_list=
            | +-Key#5 := ColumnRef(type=INT32, column=TestTable.key#1)
            +-aggregate_list=
              +-a#4 :=
                +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  +-GetProtoField
                    +-type=INT64
                    +-expr=
                    | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                    +-field_descriptor=int64_val
                    +-default_value=0
                  +-order_by_item_list=
                    +-OrderByItem
                      +-column_ref=
                        +-ColumnRef(type=INT32, column=TestTable.key#1)

==

select Key,
       array_agg(KitchenSink.int64_val
           order by (select Key from TestTable limit 1))
from TestTable
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#9 AS Key [INT32]
| +-$aggregate.$agg1#8 AS `$col2` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#9, $aggregate.$agg1#8]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#9, $aggregate.$agg1#8]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $orderby.$orderbycol1#7]
        |   +-expr_list=
        |   | +-$orderbycol1#7 :=
        |   |   +-SubqueryExpr
        |   |     +-type=INT32
        |   |     +-subquery_type=SCALAR
        |   |     +-subquery=
        |   |       +-LimitOffsetScan
        |   |         +-column_list=[TestTable.key#4]
        |   |         +-input_scan=
        |   |         | +-ProjectScan
        |   |         |   +-column_list=[TestTable.key#4]
        |   |         |   +-input_scan=
        |   |         |     +-TableScan(column_list=[TestTable.key#4], table=TestTable, column_index_list=[0])
        |   |         +-limit=
        |   |           +-Literal(type=INT64, value=1)
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#9 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-$agg1#8 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-GetProtoField
                +-type=INT64
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=int64_val
                +-default_value=0
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#7)

==

select Key,
       array_agg(distinct KitchenSink.int64_val order by KitchenSink.int64_val)
from TestTable
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#6 AS Key [INT32]
| +-$aggregate.$agg1#5 AS `$col2` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#6, $aggregate.$agg1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#6, $aggregate.$agg1#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $orderby.$orderbycol1#4]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   |   +-GetProtoField
        |   |     +-type=INT64
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=int64_val
        |   |     +-default_value=0
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#6 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-$agg1#5 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)

==

select sqrt(KitchenSink.int64_val order by Key) from TestTable;
--
ERROR: ORDER BY in arguments is not supported on scalar functions [at 1:35]
select sqrt(KitchenSink.int64_val order by Key) from TestTable;
                                  ^

==

select sort_count(order by Key) as c from TestTable;
--
ERROR: ORDER BY in aggregate function call with no arguments is not allowed [at 1:19]
select sort_count(order by Key) as c from TestTable;
                  ^

==

select Key,
       array_agg(KitchenSink.int64_val
           order by Key DESC, KitchenSink.int32_val DESC) as a
from TestTable
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#6 AS Key [INT32]
| +-$aggregate.a#5 AS a [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#6, $aggregate.a#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#6, $aggregate.a#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $orderby.$orderbycol2#4]
        |   +-expr_list=
        |   | +-$orderbycol2#4 :=
        |   |   +-GetProtoField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=int32_val
        |   |     +-default_value=77
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#6 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-a#5 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-GetProtoField
                +-type=INT64
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=int64_val
                +-default_value=0
              +-order_by_item_list=
                +-OrderByItem
                | +-column_ref=
                | | +-ColumnRef(type=INT32, column=TestTable.key#1)
                | +-is_descending=TRUE
                +-OrderByItem
                  +-column_ref=
                  | +-ColumnRef(type=INT32, column=$orderby.$orderbycol2#4)
                  +-is_descending=TRUE

==

select Key,
       string_agg(KitchenSink.string_val
           order by KitchenSink.string_val COLLATE "en_US" DESC) as s
from TestTable
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#6 AS Key [INT32]
| +-$aggregate.s#5 AS s [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#6, $aggregate.s#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#6, $aggregate.s#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $orderby.$orderbycol1#4]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   |   +-GetProtoField
        |   |     +-type=STRING
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=string_val
        |   |     +-default_value="default_name"
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#6 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-s#5 :=
            +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
              +-ColumnRef(type=STRING, column=$orderby.$orderbycol1#4)
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                  | +-ColumnRef(type=STRING, column=$orderby.$orderbycol1#4)
                  +-collation_name=
                  | +-Literal(type=STRING, value="en_US")
                  +-is_descending=TRUE

==

select Key,
       array_agg(KitchenSink.int64_val
           order by KitchenSink.int64_val COLLATE "en_US" DESC) as a
from TestTable
group by Key
--
ERROR: COLLATE can only be applied to expressions of type STRING, but was applied to INT64 [at 3:21]
           order by KitchenSink.int64_val COLLATE "en_US" DESC) as a
                    ^

==

select count(* order by KitchenSink.int64_val) as c
from TestTable
--
ERROR: Aggregate function COUNT(*) does not support ORDER BY in arguments [at 1:16]
select count(* order by KitchenSink.int64_val) as c
               ^

==

select Key,
       array_agg(KitchenSink.int64_val
           order by KitchenSink.int64_val,
                    KitchenSink.int32_val + 1 DESC,
                    KitchenSink.string_val) as a,
       array_agg(KitchenSink.int32_val
           order by KitchenSink.int64_val,
                    KitchenSink.string_val,
                    KitchenSink.int32_val + 1 DESC) as b,
       string_agg(KitchenSink.string_val
           order by KitchenSink.int32_val,
                    KitchenSink.int64_val DESC,
                    KitchenSink.string_val COLLATE "en_US" DESC) as c
from TestTable
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#12 AS Key [INT32]
| +-$aggregate.a#7 AS a [ARRAY<INT64>]
| +-$aggregate.b#9 AS b [ARRAY<INT32>]
| +-$aggregate.c#11 AS c [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#12, $aggregate.a#7, $aggregate.b#9, $aggregate.c#11]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#12, $aggregate.a#7, $aggregate.b#9, $aggregate.c#11]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $orderby.$orderbycol1#4, $orderby.$orderbycol2#5, $orderby.$orderbycol3#6, $orderby.$orderbycol3#8, $orderby.$orderbycol1#10]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   | | +-GetProtoField
        |   | |   +-type=INT64
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   +-field_descriptor=int64_val
        |   | |   +-default_value=0
        |   | +-$orderbycol2#5 :=
        |   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   | |   +-Cast(INT32 -> INT64)
        |   | |   | +-GetProtoField
        |   | |   |   +-type=INT32
        |   | |   |   +-expr=
        |   | |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   |   +-field_descriptor=int32_val
        |   | |   |   +-default_value=77
        |   | |   +-Literal(type=INT64, value=1)
        |   | +-$orderbycol3#6 :=
        |   | | +-GetProtoField
        |   | |   +-type=STRING
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   +-field_descriptor=string_val
        |   | |   +-default_value="default_name"
        |   | +-$orderbycol3#8 :=
        |   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   | |   +-Cast(INT32 -> INT64)
        |   | |   | +-GetProtoField
        |   | |   |   +-type=INT32
        |   | |   |   +-expr=
        |   | |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   |   +-field_descriptor=int32_val
        |   | |   |   +-default_value=77
        |   | |   +-Literal(type=INT64, value=1)
        |   | +-$orderbycol1#10 :=
        |   |   +-GetProtoField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=int32_val
        |   |     +-default_value=77
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#12 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-a#7 :=
          | +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
          |   +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
          |   +-order_by_item_list=
          |     +-OrderByItem
          |     | +-column_ref=
          |     |   +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
          |     +-OrderByItem
          |     | +-column_ref=
          |     | | +-ColumnRef(type=INT64, column=$orderby.$orderbycol2#5)
          |     | +-is_descending=TRUE
          |     +-OrderByItem
          |       +-column_ref=
          |         +-ColumnRef(type=STRING, column=$orderby.$orderbycol3#6)
          +-b#9 :=
          | +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
          |   +-GetProtoField
          |     +-type=INT32
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int32_val
          |     +-default_value=77
          |   +-order_by_item_list=
          |     +-OrderByItem
          |     | +-column_ref=
          |     |   +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
          |     +-OrderByItem
          |     | +-column_ref=
          |     |   +-ColumnRef(type=STRING, column=$orderby.$orderbycol3#6)
          |     +-OrderByItem
          |       +-column_ref=
          |       | +-ColumnRef(type=INT64, column=$orderby.$orderbycol3#8)
          |       +-is_descending=TRUE
          +-c#11 :=
            +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
              +-ColumnRef(type=STRING, column=$orderby.$orderbycol3#6)
              +-order_by_item_list=
                +-OrderByItem
                | +-column_ref=
                |   +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#10)
                +-OrderByItem
                | +-column_ref=
                | | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
                | +-is_descending=TRUE
                +-OrderByItem
                  +-column_ref=
                  | +-ColumnRef(type=STRING, column=$orderby.$orderbycol3#6)
                  +-collation_name=
                  | +-Literal(type=STRING, value="en_US")
                  +-is_descending=TRUE

==

select Key,
       array_agg(KitchenSink.int64_val
           order by min(KitchenSink.int64_val)) as a
from TestTable
group by Key
--
ERROR: Aggregations of aggregations are not allowed [at 2:8]
       array_agg(KitchenSink.int64_val
       ^

==

select Key,
       array_agg(KitchenSink.int64_val
           order by rank() over (partition by Key ORDER BY Key)) as a
from TestTable
group by Key
--
ERROR: Analytic functions cannot be arguments to aggregate functions [at 2:8]
       array_agg(KitchenSink.int64_val
       ^

==

select Key,
       array_agg(KitchenSink.int64_val order by KitchenSink.int64_val) as a,
       rank() over (partition by Key ORDER BY Key) as b
from TestTable
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#7 AS Key [INT32]
| +-$aggregate.a#5 AS a [ARRAY<INT64>]
| +-$analytic.b#8 AS b [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#7, $aggregate.a#5, $analytic.b#8]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$groupby.Key#7, $aggregate.a#5, $analytic.b#8]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.Key#7, $aggregate.a#5]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $orderby.$orderbycol1#4]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#4 :=
        |   |   |   +-GetProtoField
        |   |   |     +-type=INT64
        |   |   |     +-expr=
        |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   |     +-field_descriptor=int64_val
        |   |   |     +-default_value=0
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        |   +-group_by_list=
        |   | +-Key#7 := ColumnRef(type=INT32, column=TestTable.key#1)
        |   +-aggregate_list=
        |     +-a#5 :=
        |       +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
        |         +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
        |         +-order_by_item_list=
        |           +-OrderByItem
        |             +-column_ref=
        |               +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT32, column=$groupby.Key#7)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT32, column=$groupby.Key#7)
            +-analytic_function_list=
              +-b#8 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)

==

select sort_count(distinct order by Key) as c from TestTable;
--
ERROR: DISTINCT function call with no arguments is not allowed [at 1:8]
select sort_count(distinct order by Key) as c from TestTable;
       ^

==

select ntile(10 order by Key) over (partition by Key ORDER BY Key) as b
from TestTable;
--
ERROR: ORDER BY in arguments is not supported on analytic functions [at 1:8]
select ntile(10 order by Key) over (partition by Key ORDER BY Key) as b
       ^

==

select sum(Key order by Key) over (partition by Key ORDER BY Key) as b
from TestTable;
--
ERROR: ORDER BY in arguments is not supported on analytic functions [at 1:8]
select sum(Key order by Key) over (partition by Key ORDER BY Key) as b
       ^

==

select array_agg(Key order by Key) over (partition by Key ORDER BY Key) as b
from TestTable;
--
ERROR: ORDER BY in arguments is not supported on analytic functions [at 1:8]
select array_agg(Key order by Key) over (partition by Key ORDER BY Key) as b
       ^

==

select array_agg(distinct Key order by Key)
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT32, column=TestTable.key#1)

==

select array_agg(distinct {{|TestTable.}}Key order by {{|TestTable.}}Key)
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT32, column=TestTable.key#1)

==

select array_agg({{|KitchenSinkValueTable.}}int64_key_1
                 order by {{|KitchenSinkValueTable.}}int64_key_1)
from KitchenSinkValueTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[KitchenSinkValueTable.value#1, $orderby.$orderbycol1#2]
        |   +-expr_list=
        |   | +-$orderbycol1#2 :=
        |   |   +-GetProtoField
        |   |     +-type=INT64
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
        |   |     +-field_descriptor=int64_key_1
        |   +-input_scan=
        |     +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#2)
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#2)

==

select array_agg(distinct KitchenSinkValueTable.int64_key_1
                 order by KitchenSinkValueTable.int64_key_1)
from KitchenSinkValueTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[KitchenSinkValueTable.value#1, $orderby.$orderbycol1#2]
        |   +-expr_list=
        |   | +-$orderbycol1#2 :=
        |   |   +-GetProtoField
        |   |     +-type=INT64
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
        |   |     +-field_descriptor=int64_key_1
        |   +-input_scan=
        |     +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#2)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#2)

==

select array_agg({{|TestStructValueTable.}}a
                 order by {{|TestStructValueTable.}}a)
from TestStructValueTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestStructValueTable.value#1, $orderby.$orderbycol1#2]
        |   +-expr_list=
        |   | +-$orderbycol1#2 :=
        |   |   +-GetStructField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
        |   |     +-field_idx=0
        |   +-input_scan=
        |     +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#2)
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#2)

==

select array_agg(distinct TestStructValueTable.a
                 order by TestStructValueTable.a)
from TestStructValueTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestStructValueTable.value#1, $orderby.$orderbycol1#2]
        |   +-expr_list=
        |   | +-$orderbycol1#2 :=
        |   |   +-GetStructField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
        |   |     +-field_idx=0
        |   +-input_scan=
        |     +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#2)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#2)

==

select array_agg(distinct {{|T.}}Key order by {{|T.}}Key)
from
    (select Key,
            KitchenSink.int64_val as int64_val,
            KitchenSink.int32_val as int32_val,
            KitchenSink.string_val as string_val
     from TestTable) as T
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#7 AS `$col1` [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#7]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, T.int64_val#4, T.int32_val#5, T.string_val#6]
        |   +-expr_list=
        |   | +-int64_val#4 :=
        |   | | +-GetProtoField
        |   | |   +-type=INT64
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   +-field_descriptor=int64_val
        |   | |   +-default_value=0
        |   | +-int32_val#5 :=
        |   | | +-GetProtoField
        |   | |   +-type=INT32
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   +-field_descriptor=int32_val
        |   | |   +-default_value=77
        |   | +-string_val#6 :=
        |   |   +-GetProtoField
        |   |     +-type=STRING
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=string_val
        |   |     +-default_value="default_name"
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-aggregate_list=
          +-$agg1#7 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT32, column=TestTable.key#1)

==

select Key,
       multi_sort_count(distinct int32_val, int64_val, string_val
                        order by int32_val) as a,
       multi_sort_count(distinct int32_val, int64_val, string_val
                        order by int32_val, int64_val) as b,
       multi_sort_count(distinct int32_val, int64_val, string_val
                        order by int32_val, int64_val, string_val) as c
from
    (select Key,
            KitchenSink.int64_val as int64_val,
            KitchenSink.int32_val as int32_val,
            KitchenSink.string_val as string_val
     from TestTable)
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#10 AS Key [INT32]
| +-$aggregate.a#7 AS a [INT64]
| +-$aggregate.b#8 AS b [INT64]
| +-$aggregate.c#9 AS c [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#10, $aggregate.a#7, $aggregate.b#8, $aggregate.c#9]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#10, $aggregate.a#7, $aggregate.b#8, $aggregate.c#9]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, $subquery1.int64_val#4, $subquery1.int32_val#5, $subquery1.string_val#6]
        |   +-expr_list=
        |   | +-int64_val#4 :=
        |   | | +-GetProtoField
        |   | |   +-type=INT64
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   +-field_descriptor=int64_val
        |   | |   +-default_value=0
        |   | +-int32_val#5 :=
        |   | | +-GetProtoField
        |   | |   +-type=INT32
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   +-field_descriptor=int32_val
        |   | |   +-default_value=77
        |   | +-string_val#6 :=
        |   |   +-GetProtoField
        |   |     +-type=STRING
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=string_val
        |   |     +-default_value="default_name"
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#10 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-a#7 :=
          | +-AggregateFunctionCall(sample_functions:multi_sort_count(INT32, INT64, STRING) -> INT64)
          |   +-ColumnRef(type=INT32, column=$subquery1.int32_val#5)
          |   +-ColumnRef(type=INT64, column=$subquery1.int64_val#4)
          |   +-ColumnRef(type=STRING, column=$subquery1.string_val#6)
          |   +-distinct=TRUE
          |   +-order_by_item_list=
          |     +-OrderByItem
          |       +-column_ref=
          |         +-ColumnRef(type=INT32, column=$subquery1.int32_val#5)
          +-b#8 :=
          | +-AggregateFunctionCall(sample_functions:multi_sort_count(INT32, INT64, STRING) -> INT64)
          |   +-ColumnRef(type=INT32, column=$subquery1.int32_val#5)
          |   +-ColumnRef(type=INT64, column=$subquery1.int64_val#4)
          |   +-ColumnRef(type=STRING, column=$subquery1.string_val#6)
          |   +-distinct=TRUE
          |   +-order_by_item_list=
          |     +-OrderByItem
          |     | +-column_ref=
          |     |   +-ColumnRef(type=INT32, column=$subquery1.int32_val#5)
          |     +-OrderByItem
          |       +-column_ref=
          |         +-ColumnRef(type=INT64, column=$subquery1.int64_val#4)
          +-c#9 :=
            +-AggregateFunctionCall(sample_functions:multi_sort_count(INT32, INT64, STRING) -> INT64)
              +-ColumnRef(type=INT32, column=$subquery1.int32_val#5)
              +-ColumnRef(type=INT64, column=$subquery1.int64_val#4)
              +-ColumnRef(type=STRING, column=$subquery1.string_val#6)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                | +-column_ref=
                |   +-ColumnRef(type=INT32, column=$subquery1.int32_val#5)
                +-OrderByItem
                | +-column_ref=
                |   +-ColumnRef(type=INT64, column=$subquery1.int64_val#4)
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=STRING, column=$subquery1.string_val#6)

==

select Key,
       multi_sort_count(distinct int32_val, int64_val, string_val
                        order by int32_val DESC,
                                 int64_val ASC,
                                 string_val DESC) as a
from
    (select Key,
            KitchenSink.int64_val as int64_val,
            KitchenSink.int32_val as int32_val,
            KitchenSink.string_val as string_val
     from TestTable)
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#8 AS Key [INT32]
| +-$aggregate.a#7 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#8, $aggregate.a#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#8, $aggregate.a#7]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, $subquery1.int64_val#4, $subquery1.int32_val#5, $subquery1.string_val#6]
        |   +-expr_list=
        |   | +-int64_val#4 :=
        |   | | +-GetProtoField
        |   | |   +-type=INT64
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   +-field_descriptor=int64_val
        |   | |   +-default_value=0
        |   | +-int32_val#5 :=
        |   | | +-GetProtoField
        |   | |   +-type=INT32
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   +-field_descriptor=int32_val
        |   | |   +-default_value=77
        |   | +-string_val#6 :=
        |   |   +-GetProtoField
        |   |     +-type=STRING
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=string_val
        |   |     +-default_value="default_name"
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#8 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-a#7 :=
            +-AggregateFunctionCall(sample_functions:multi_sort_count(INT32, INT64, STRING) -> INT64)
              +-ColumnRef(type=INT32, column=$subquery1.int32_val#5)
              +-ColumnRef(type=INT64, column=$subquery1.int64_val#4)
              +-ColumnRef(type=STRING, column=$subquery1.string_val#6)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                | +-column_ref=
                | | +-ColumnRef(type=INT32, column=$subquery1.int32_val#5)
                | +-is_descending=TRUE
                +-OrderByItem
                | +-column_ref=
                |   +-ColumnRef(type=INT64, column=$subquery1.int64_val#4)
                +-OrderByItem
                  +-column_ref=
                  | +-ColumnRef(type=STRING, column=$subquery1.string_val#6)
                  +-is_descending=TRUE

==

select Key,
       multi_sort_count(distinct int32_val, int64_val, string_val
                        order by int32_val, int32_val, int64_val) as a
from
    (select Key,
            KitchenSink.int64_val as int64_val,
            KitchenSink.int32_val as int32_val,
            KitchenSink.string_val as string_val
     from TestTable)
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#8 AS Key [INT32]
| +-$aggregate.a#7 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#8, $aggregate.a#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#8, $aggregate.a#7]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, $subquery1.int64_val#4, $subquery1.int32_val#5, $subquery1.string_val#6]
        |   +-expr_list=
        |   | +-int64_val#4 :=
        |   | | +-GetProtoField
        |   | |   +-type=INT64
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   +-field_descriptor=int64_val
        |   | |   +-default_value=0
        |   | +-int32_val#5 :=
        |   | | +-GetProtoField
        |   | |   +-type=INT32
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   +-field_descriptor=int32_val
        |   | |   +-default_value=77
        |   | +-string_val#6 :=
        |   |   +-GetProtoField
        |   |     +-type=STRING
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=string_val
        |   |     +-default_value="default_name"
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#8 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-a#7 :=
            +-AggregateFunctionCall(sample_functions:multi_sort_count(INT32, INT64, STRING) -> INT64)
              +-ColumnRef(type=INT32, column=$subquery1.int32_val#5)
              +-ColumnRef(type=INT64, column=$subquery1.int64_val#4)
              +-ColumnRef(type=STRING, column=$subquery1.string_val#6)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                | +-column_ref=
                |   +-ColumnRef(type=INT32, column=$subquery1.int32_val#5)
                +-OrderByItem
                | +-column_ref=
                |   +-ColumnRef(type=INT32, column=$subquery1.int32_val#5)
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT64, column=$subquery1.int64_val#4)

==

select array_agg(distinct a order by b)
from (select 1 a, 2 b);
--
ERROR: An aggregate function that has both DISTINCT and ORDER BY arguments can only ORDER BY expressions that are arguments to the function [at 1:38]
select array_agg(distinct a order by b)
                                     ^
==

select array_agg(distinct T.a order by T.b)
from (select 1 a, 2 b) as T;
--
ERROR: An aggregate function that has both DISTINCT and ORDER BY arguments can only ORDER BY expressions that are arguments to the function [at 1:40]
select array_agg(distinct T.a order by T.b)
                                       ^
==

select array_agg(distinct s.a order by s.b)
from (select struct<a string, b string>("1", "2") as s);
--
ERROR: An aggregate function that has both DISTINCT and ORDER BY arguments can only ORDER BY expressions that are arguments to the function [at 1:40]
select array_agg(distinct s.a order by s.b)
                                       ^
==

select Key,
       multi_sort_count(distinct int32_val, int64_val, string_val
                        order by bool_val) as a
from
    (select Key,
            KitchenSink.int64_val as int64_val,
            KitchenSink.int32_val as int32_val,
            KitchenSink.string_val as string_val,
            KitchenSink.bool_val as bool_val
     from TestTable)
group by Key
--
ERROR: An aggregate function that has both DISTINCT and ORDER BY arguments can only ORDER BY expressions that are arguments to the function [at 3:34]
                        order by bool_val) as a
                                 ^

==

select Key,
       multi_sort_count(distinct int32_val, int64_val, string_val
                        order by int32_val, bool_val) as a
from
    (select Key,
            KitchenSink.int64_val as int64_val,
            KitchenSink.int32_val as int32_val,
            KitchenSink.string_val as string_val,
            KitchenSink.bool_val as bool_val
     from TestTable)
group by Key
--
ERROR: An aggregate function that has both DISTINCT and ORDER BY arguments can only ORDER BY expressions that are arguments to the function [at 3:45]
                        order by int32_val, bool_val) as a
                                            ^

==

select array_agg(distinct -Key order by -Key)
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS `$col1` [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, $orderby.$orderbycol1#4]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   |   +-FunctionCall(ZetaSQL:$unary_minus(INT32) -> INT32)
        |   |     +-ColumnRef(type=INT32, column=TestTable.key#1)
        |   +-input_scan=
        |     +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#5 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#4)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#4)
==

select array_concat_agg(x order by w)
from (select 1 as w, [1, 2] as x union all select 2 as w, [5, 2] as x
      union all select 3 as w, [3] as x) foo;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#9 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#9]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#9]
        +-input_scan=
        | +-SetOperationScan
        |   +-column_list=$union_all.[w#7, x#8]
        |   +-op_type=UNION_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=$union_all1.[w#1, x#2]
        |     | |   +-expr_list=
        |     | |   | +-w#1 := Literal(type=INT64, value=1)
        |     | |   | +-x#2 := Literal(type=ARRAY<INT64>, value=[1, 2])
        |     | |   +-input_scan=
        |     | |     +-SingleRowScan
        |     | +-output_column_list=$union_all1.[w#1, x#2]
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=$union_all2.[w#3, x#4]
        |     | |   +-expr_list=
        |     | |   | +-w#3 := Literal(type=INT64, value=2)
        |     | |   | +-x#4 := Literal(type=ARRAY<INT64>, value=[5, 2])
        |     | |   +-input_scan=
        |     | |     +-SingleRowScan
        |     | +-output_column_list=$union_all2.[w#3, x#4]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=$union_all3.[w#5, x#6]
        |       |   +-expr_list=
        |       |   | +-w#5 := Literal(type=INT64, value=3)
        |       |   | +-x#6 := Literal(type=ARRAY<INT64>, value=[3])
        |       |   +-input_scan=
        |       |     +-SingleRowScan
        |       +-output_column_list=$union_all3.[w#5, x#6]
        +-aggregate_list=
          +-$agg1#9 :=
            +-AggregateFunctionCall(ZetaSQL:array_concat_agg(ARRAY<INT64>) -> ARRAY<INT64>)
              +-ColumnRef(type=ARRAY<INT64>, column=$union_all.x#8)
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT64, column=$union_all.w#7)
==

select array_concat_agg(x order by w desc)
from (select 1 as w, [1, 2] as x union all select 2 as w, [5, 2] as x
      union all select 3 as w, [3] as x) foo;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#9 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#9]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#9]
        +-input_scan=
        | +-SetOperationScan
        |   +-column_list=$union_all.[w#7, x#8]
        |   +-op_type=UNION_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=$union_all1.[w#1, x#2]
        |     | |   +-expr_list=
        |     | |   | +-w#1 := Literal(type=INT64, value=1)
        |     | |   | +-x#2 := Literal(type=ARRAY<INT64>, value=[1, 2])
        |     | |   +-input_scan=
        |     | |     +-SingleRowScan
        |     | +-output_column_list=$union_all1.[w#1, x#2]
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=$union_all2.[w#3, x#4]
        |     | |   +-expr_list=
        |     | |   | +-w#3 := Literal(type=INT64, value=2)
        |     | |   | +-x#4 := Literal(type=ARRAY<INT64>, value=[5, 2])
        |     | |   +-input_scan=
        |     | |     +-SingleRowScan
        |     | +-output_column_list=$union_all2.[w#3, x#4]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=$union_all3.[w#5, x#6]
        |       |   +-expr_list=
        |       |   | +-w#5 := Literal(type=INT64, value=3)
        |       |   | +-x#6 := Literal(type=ARRAY<INT64>, value=[3])
        |       |   +-input_scan=
        |       |     +-SingleRowScan
        |       +-output_column_list=$union_all3.[w#5, x#6]
        +-aggregate_list=
          +-$agg1#9 :=
            +-AggregateFunctionCall(ZetaSQL:array_concat_agg(ARRAY<INT64>) -> ARRAY<INT64>)
              +-ColumnRef(type=ARRAY<INT64>, column=$union_all.x#8)
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                  | +-ColumnRef(type=INT64, column=$union_all.w#7)
                  +-is_descending=TRUE
==

select Key,
       array_agg(KitchenSink.int64_val order by KitchenSink.int64_val limit 10),
       string_agg(KitchenSink.string_val order by KitchenSink.string_val limit 5)
from TestTable
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#8 AS Key [INT32]
| +-$aggregate.$agg1#5 AS `$col2` [ARRAY<INT64>]
| +-$aggregate.$agg2#7 AS `$col3` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#8, $aggregate.$agg1#5, $aggregate.$agg2#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#8, $aggregate.$agg1#5, $aggregate.$agg2#7]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $orderby.$orderbycol1#4, $orderby.$orderbycol1#6]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   | | +-GetProtoField
        |   | |   +-type=INT64
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | |   +-field_descriptor=int64_val
        |   | |   +-default_value=0
        |   | +-$orderbycol1#6 :=
        |   |   +-GetProtoField
        |   |     +-type=STRING
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=string_val
        |   |     +-default_value="default_name"
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#8 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-$agg1#5 :=
          | +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
          |   +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
          |   +-order_by_item_list=
          |   | +-OrderByItem
          |   |   +-column_ref=
          |   |     +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
          |   +-limit=
          |     +-Literal(type=INT64, value=10)
          +-$agg2#7 :=
            +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
              +-ColumnRef(type=STRING, column=$orderby.$orderbycol1#6)
              +-order_by_item_list=
              | +-OrderByItem
              |   +-column_ref=
              |     +-ColumnRef(type=STRING, column=$orderby.$orderbycol1#6)
              +-limit=
                +-Literal(type=INT64, value=5)
==

select Key,
       array_agg(KitchenSink.int64_val limit 10),
       string_agg(KitchenSink.string_val limit 5)
from TestTable
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#6 AS Key [INT32]
| +-$aggregate.$agg1#4 AS `$col2` [ARRAY<INT64>]
| +-$aggregate.$agg2#5 AS `$col3` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#6, $aggregate.$agg1#4, $aggregate.$agg2#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#6, $aggregate.$agg1#4, $aggregate.$agg2#5]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#6 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-$agg1#4 :=
          | +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
          |   +-GetProtoField
          |     +-type=INT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int64_val
          |     +-default_value=0
          |   +-limit=
          |     +-Literal(type=INT64, value=10)
          +-$agg2#5 :=
            +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
              +-GetProtoField
                +-type=STRING
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=string_val
                +-default_value="default_name"
              +-limit=
                +-Literal(type=INT64, value=5)
==

select array_agg(distinct Key order by Key limit 10)
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-distinct=TRUE
              +-order_by_item_list=
              | +-OrderByItem
              |   +-column_ref=
              |     +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-limit=
                +-Literal(type=INT64, value=10)
==

select Key,
       array_agg(KitchenSink.int64_val
           order by Key DESC, KitchenSink.int32_val DESC limit 5) as a
from TestTable
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#6 AS Key [INT32]
| +-$aggregate.a#5 AS a [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#6, $aggregate.a#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#6, $aggregate.a#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $orderby.$orderbycol2#4]
        |   +-expr_list=
        |   | +-$orderbycol2#4 :=
        |   |   +-GetProtoField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=int32_val
        |   |     +-default_value=77
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#6 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-a#5 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-GetProtoField
                +-type=INT64
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=int64_val
                +-default_value=0
              +-order_by_item_list=
              | +-OrderByItem
              | | +-column_ref=
              | | | +-ColumnRef(type=INT32, column=TestTable.key#1)
              | | +-is_descending=TRUE
              | +-OrderByItem
              |   +-column_ref=
              |   | +-ColumnRef(type=INT32, column=$orderby.$orderbycol2#4)
              |   +-is_descending=TRUE
              +-limit=
                +-Literal(type=INT64, value=5)
==

[language_features=V_1_1_ORDER_BY_IN_AGGREGATE{{|,V_1_3_ARRAY_ORDERING}}]
SELECT array_concat_agg(arr1 ORDER BY arr2)
FROM (select [1] as arr1, [2] as arr2);
--
ALTERNATION GROUP: <empty>
--
ERROR: ORDER BY does not support expressions of type ARRAY<INT64> [at 1:39]
SELECT array_concat_agg(arr1 ORDER BY arr2)
                                      ^
--
ALTERNATION GROUP: ,V_1_3_ARRAY_ORDERING
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$subquery1.[arr1#1, arr2#2]
        |   +-expr_list=
        |   | +-arr1#1 := Literal(type=ARRAY<INT64>, value=[1])
        |   | +-arr2#2 := Literal(type=ARRAY<INT64>, value=[2])
        |   +-input_scan=
        |     +-SingleRowScan
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:array_concat_agg(ARRAY<INT64>) -> ARRAY<INT64>)
              +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.arr1#1)
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.arr2#2)
==

[language_features=V_1_1_ORDER_BY_IN_AGGREGATE{{|,V_1_3_ARRAY_ORDERING}}]
SELECT array_concat_agg(arr1 ORDER BY arr2)
FROM (select [1] as arr1, [KitchenSink] as arr2 FROM ComplexTypes);
--
ERROR: ORDER BY does not support expressions of type ARRAY<zetasql_test__.KitchenSinkPB> [at 1:39]
SELECT array_concat_agg(arr1 ORDER BY arr2)
                                      ^
==

[language_features=V_1_1_ORDER_BY_IN_AGGREGATE{{|,V_1_3_ARRAY_ORDERING|,V_1_3_ARRAY_ORDERING,V_1_1_ARRAY_EQUALITY|,V_1_3_ARRAY_ORDERING,V_1_2_GROUP_BY_ARRAY|,V_1_3_ARRAY_ORDERING,V_1_1_ARRAY_EQUALITY,V_1_2_GROUP_BY_ARRAY}}]
SELECT array_concat_agg(distinct arr1 ORDER BY arr1)
FROM (select [1] as arr1);
--
ALTERNATION GROUPS:
    <empty>
    ,V_1_3_ARRAY_ORDERING
    ,V_1_3_ARRAY_ORDERING,V_1_1_ARRAY_EQUALITY
--
ERROR: Aggregate functions with DISTINCT cannot be used with arguments of type ARRAY [at 1:8]
SELECT array_concat_agg(distinct arr1 ORDER BY arr1)
       ^
--
ALTERNATION GROUPS:
    ,V_1_3_ARRAY_ORDERING,V_1_2_GROUP_BY_ARRAY
    ,V_1_3_ARRAY_ORDERING,V_1_1_ARRAY_EQUALITY,V_1_2_GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$subquery1.arr1#1]
        |   +-expr_list=
        |   | +-arr1#1 := Literal(type=ARRAY<INT64>, value=[1])
        |   +-input_scan=
        |     +-SingleRowScan
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall(ZetaSQL:array_concat_agg(ARRAY<INT64>) -> ARRAY<INT64>)
              +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.arr1#1)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.arr1#1)
==

[language_features=V_1_1_ORDER_BY_IN_AGGREGATE{{|,V_1_3_ARRAY_ORDERING|,V_1_3_ARRAY_ORDERING,V_1_1_ARRAY_EQUALITY|,V_1_3_ARRAY_ORDERING,V_1_2_GROUP_BY_ARRAY|,V_1_3_ARRAY_ORDERING,V_1_1_ARRAY_EQUALITY,V_1_2_GROUP_BY_ARRAY}}]
SELECT array_concat_agg(distinct arr1 ORDER BY arr1)
FROM (select [KitchenSink] as arr1 FROM ComplexTypes);
--
ALTERNATION GROUPS:
    <empty>
    ,V_1_3_ARRAY_ORDERING
    ,V_1_3_ARRAY_ORDERING,V_1_1_ARRAY_EQUALITY
--
ERROR: Aggregate functions with DISTINCT cannot be used with arguments of type ARRAY [at 1:8]
SELECT array_concat_agg(distinct arr1 ORDER BY arr1)
       ^
--
ALTERNATION GROUPS:
    ,V_1_3_ARRAY_ORDERING,V_1_2_GROUP_BY_ARRAY
    ,V_1_3_ARRAY_ORDERING,V_1_1_ARRAY_EQUALITY,V_1_2_GROUP_BY_ARRAY
--
ERROR: Aggregate functions with DISTINCT cannot be used with arguments of type ARRAY containing PROTO [at 1:8]
SELECT array_concat_agg(distinct arr1 ORDER BY arr1)
       ^
==

[no_enable_literal_replacement]
select array_agg(distinct Key + 1 order by Key + 1)
from TestTable

--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, $orderby.$orderbycol1#4]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |     +-Cast(INT32 -> INT64)
        |   |     | +-ColumnRef(type=INT32, column=TestTable.key#1)
        |   |     +-Literal(type=INT64, value=1)
        |   +-input_scan=
        |     +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#5 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
==

[no_enable_literal_replacement]
select Key,
       array_agg(distinct KitchenSink.int64_val * 5 order by KitchenSink.int64_val * 5)
from TestTable
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#6 AS Key [INT32]
| +-$aggregate.$agg1#5 AS `$col2` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#6, $aggregate.$agg1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#6, $aggregate.$agg1#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $orderby.$orderbycol1#4]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
        |   |     +-GetProtoField
        |   |     | +-type=INT64
        |   |     | +-expr=
        |   |     | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     | +-field_descriptor=int64_val
        |   |     | +-default_value=0
        |   |     +-Literal(type=INT64, value=5)
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#6 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-$agg1#5 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
==

[no_enable_literal_replacement]
select Key, array_agg(
    distinct SAFE_CAST(KitchenSink.string_val AS INT64) + KEY + 5 + SAFE_CAST(KEY AS INT32)
    order by SAFE_CAST(KitchenSink.string_val AS INT64) + KEY + 5 + SAFE_CAST(KEY AS INT32))
from TestTable
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#6 AS Key [INT32]
| +-$aggregate.$agg1#5 AS `$col2` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#6, $aggregate.$agg1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#6, $aggregate.$agg1#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $orderby.$orderbycol1#4]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |     | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |     | | +-Cast(STRING -> INT64)
        |   |     | | | +-GetProtoField
        |   |     | | |   +-type=STRING
        |   |     | | |   +-expr=
        |   |     | | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     | | |   +-field_descriptor=string_val
        |   |     | | |   +-default_value="default_name"
        |   |     | | | +-return_null_on_error=TRUE
        |   |     | | +-Cast(INT32 -> INT64)
        |   |     | |   +-ColumnRef(type=INT32, column=TestTable.key#1)
        |   |     | +-Literal(type=INT64, value=5)
        |   |     +-Cast(INT32 -> INT64)
        |   |       +-ColumnRef(type=INT32, column=TestTable.key#1)
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#6 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-$agg1#5 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
==

select array_agg(distinct kitchensink.{{|has_}}string_val
                          order by kitchensink.{{|has_}}string_val)
from TestTable;
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.KitchenSink#3, $orderby.$orderbycol1#4]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   |   +-GetProtoField
        |   |     +-type=STRING
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=string_val
        |   |     +-default_value="default_name"
        |   +-input_scan=
        |     +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-aggregate_list=
          +-$agg1#5 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(STRING) -> ARRAY<STRING>)
              +-ColumnRef(type=STRING, column=$orderby.$orderbycol1#4)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=STRING, column=$orderby.$orderbycol1#4)
--
ALTERNATION GROUP: has_
--
ERROR: An aggregate function that has both DISTINCT and ORDER BY arguments can only ORDER BY expressions that are arguments to the function [at 2:36]
                          order by kitchensink.has_string_val)
                                   ^
--
ALTERNATION GROUP: has_,
--
ERROR: An aggregate function that has both DISTINCT and ORDER BY arguments can only ORDER BY expressions that are arguments to the function [at 2:36]
                          order by kitchensink.string_val)
                                   ^
--
ALTERNATION GROUP: has_,has_
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS `$col1` [ARRAY<BOOL>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.KitchenSink#3, $orderby.$orderbycol1#4]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   |   +-GetProtoField
        |   |     +-type=BOOL
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=string_val
        |   |     +-get_has_bit=TRUE
        |   +-input_scan=
        |     +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-aggregate_list=
          +-$agg1#5 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(BOOL) -> ARRAY<BOOL>)
              +-ColumnRef(type=BOOL, column=$orderby.$orderbycol1#4)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=BOOL, column=$orderby.$orderbycol1#4)
==

select array_agg(distinct Key + 1024 order by Key + 2048) from TestTable
--
ERROR: An aggregate function that has both DISTINCT and ORDER BY arguments can only ORDER BY expressions that are arguments to the function [at 1:47]
select array_agg(distinct Key + 1024 order by Key + 2048) from TestTable
                                              ^
==

[language_features=V_1_1_ORDER_BY_IN_AGGREGATE{{|,V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY}}]
select array_agg(key order by key nulls {{first|last}})
from TestTable
--
ALTERNATION GROUP: first

--
ERROR: NULLS FIRST and NULLS LAST are not supported [at 1:35]
select array_agg(key order by key nulls first)
                                  ^
--
ALTERNATION GROUP: last
--
ERROR: NULLS FIRST and NULLS LAST are not supported [at 1:35]
select array_agg(key order by key nulls last)
                                  ^
--
ALTERNATION GROUP: ,V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY,first
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                  | +-ColumnRef(type=INT32, column=TestTable.key#1)
                  +-null_order=NULLS_FIRST
--
ALTERNATION GROUP: ,V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY,last
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                  | +-ColumnRef(type=INT32, column=TestTable.key#1)
                  +-null_order=NULLS_LAST
