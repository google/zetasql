# This test statements with pipe suffixes.
# The pipe suffixes are not analyzed.  They are attached as a string in
# the wrapper ResolvedStatementWithPipeOperatorsStmt and must be handled
# by the query engine or script interpreter.
#
# This feature is off by default so not included in MAXIMUM.
[language_features={{NONE|MAXIMUM}}{{|,+PIPES}}{{|,+STATEMENT_WITH_PIPE_OPERATORS}}]
show tables
|> WHERE true
--
ALTERNATION GROUPS:
    NONE,,
    NONE,,+PIPES,
    MAXIMUM,,
    MAXIMUM,,+PIPES,
--
ERROR: Pipe operators are not supported on this statement [at 2:1]
|> WHERE true
^
--
ALTERNATION GROUP: NONE,,,+STATEMENT_WITH_PIPE_OPERATORS
--
ERROR: Pipe query syntax not supported [at 2:1]
|> WHERE true
^
--
ALTERNATION GROUPS:
    NONE,,+PIPES,,+STATEMENT_WITH_PIPE_OPERATORS
    MAXIMUM,,,+STATEMENT_WITH_PIPE_OPERATORS
    MAXIMUM,,+PIPES,,+STATEMENT_WITH_PIPE_OPERATORS
--
StatementWithPipeOperatorsStmt
+-statement=
| +-ShowStmt(identifier="tables")
+-suffix_subpipeline_sql="|> WHERE true"
==

[default language_features=MAXIMUM,+STATEMENT_WITH_PIPE_OPERATORS]
# The pipe suffix has to parse but is not analyzed.
SHOW TABLES
|> select abc, def
|> where true{{| invalid}}
|> limit 1
--
ALTERNATION GROUP: <empty>
--
StatementWithPipeOperatorsStmt
+-statement=
| +-ShowStmt(identifier="TABLES")
+-suffix_subpipeline_sql="|> select abc, def\n|> where true\n|> limit 1"
--
ALTERNATION GROUP:  invalid
--
ERROR: Syntax error: Expected end of input but got identifier "invalid" [at 4:15]
|> where true invalid
              ^
==

# Using `|> DESCRIBE` to see the schema is a nice pattern.
SHOW TABLES
|> DESCRIBE
--
StatementWithPipeOperatorsStmt
+-statement=
| +-ShowStmt(identifier="TABLES")
+-suffix_subpipeline_sql="|> DESCRIBE"
==

DESCRIBE abc
|> EXTEND describe+1
--
StatementWithPipeOperatorsStmt
+-statement=
| +-DescribeStmt(object_type="", name_path=abc)
+-suffix_subpipeline_sql="|> EXTEND describe+1"
==

@{hint=1}
SHOW TABLES
|> WHERE true
--
StatementWithPipeOperatorsStmt
+-hint_list=
| +-hint := Literal(type=INT64, value=1)
+-statement=
| +-ShowStmt(identifier="TABLES")
+-suffix_subpipeline_sql="|> WHERE true"
==

@{hint1=1}
EXPLAIN
@{hint2=2}
SHOW TABLES
|> WHERE true
--
ExplainStmt
+-hint_list=
| +-hint1 := Literal(type=INT64, value=1)
+-statement=
  +-StatementWithPipeOperatorsStmt
    +-hint_list=
    | +-hint2 := Literal(type=INT64, value=2)
    +-statement=
    | +-ShowStmt(identifier="TABLES")
    +-suffix_subpipeline_sql="|> WHERE true"
==

# Analysis for RUN doesn't work yet.
RUN some_script()
|> SELECT x
--
ERROR: RUN statement is not supported. [at 1:1]
RUN some_script()
^
==

CALL proc_no_args()
|> SELECT x
--
StatementWithPipeOperatorsStmt
+-statement=
| +-CallStmt(procedure=proc_no_args, signature=() -> BOOL)
+-suffix_subpipeline_sql="|> SELECT x"
==

CALL invalid_prod()
|> SELECT x
--
ERROR: Procedure not found: invalid_prod [at 1:6]
CALL invalid_prod()
     ^
==

# This checks that ExtractTableNamesFromStatement works
# on a statement with a pipe suffix.
CALL proc_on_bool( (SELECT COUNT(*) FROM KeyValue) = 10 )
|> WHERE true
--
StatementWithPipeOperatorsStmt
+-statement=
| +-CallStmt
|   +-procedure=proc_on_bool
|   +-signature=(BOOL) -> BOOL
|   +-argument_list=
|     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
|       +-SubqueryExpr
|       | +-type=INT64
|       | +-subquery_type=SCALAR
|       | +-subquery=
|       |   +-ProjectScan
|       |     +-column_list=[$aggregate.$agg1#3]
|       |     +-input_scan=
|       |       +-AggregateScan
|       |         +-column_list=[$aggregate.$agg1#3]
|       |         +-input_scan=
|       |         | +-TableScan(table=KeyValue)
|       |         +-aggregate_list=
|       |           +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
|       +-Literal(type=INT64, value=10)
+-suffix_subpipeline_sql="|> WHERE true"
==

EXECUTE IMMEDIATE "SELECT 1 x"
|> EXTEND x+1
--
StatementWithPipeOperatorsStmt
+-statement=
| +-ExecuteImmediateStmt
|   +-sql=
|   | +-Literal(type=STRING, value="SELECT 1 x")
|   +-into_identifier_list=[]
+-suffix_subpipeline_sql="|> EXTEND x+1"
==

# Pipe operators after a GQL query.
# This is excluded right now because the GQL statement resolves
# as a ResolvedQueryStmt, so the unresolved pipe suffix confuses things
# in the SQLBuilder testing.
GRAPH aml
MATCH (n:Person)
RETURN n.name
|> WHERE true
|> EXTEND UPPER(name)
--
ERROR: Syntax error: Expected end of input but got "|>" [at 4:1]
|> WHERE true
^
