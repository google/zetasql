[default language_features=MAXIMUM]
[default zetasql_idstring_allow_unicode_characters]

[no_java]
# Access top level field with Unicode name in the same case as the column name
# in the table.

select `Ã¥å­¦`
from unicode_column_table;
--
QueryStmt
+-output_column_list=
| +-unicode_column_table.Ã¥å­¦#1 AS `Ã¥å­¦` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[unicode_column_table.Ã¥å­¦#1]
    +-input_scan=
      +-TableScan(column_list=[unicode_column_table.Ã¥å­¦#1], table=unicode_column_table, column_index_list=[0])
==

[no_java]

select a.`1ğŒ°:`
from unicode_column_table;
--
ERROR: Field name `1ğŒ°:` does not exist in STRUCT<`1ğŒ°:aoÌ‚` STRING> [at 1:10]
select a.`1ğŒ°:`
         ^
==

[no_java]

# Access nested field with Unicode name in the same case as the column name in
# the table.

select a.`1ğŒ°:aoÌ‚`
from unicode_column_table;
--
QueryStmt
+-output_column_list=
| +-$query.1ğŒ°:aoÌ‚#4 AS `1ğŒ°:aoÌ‚` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.1ğŒ°:aoÌ‚#4]
    +-expr_list=
    | +-1ğŒ°:aoÌ‚#4 :=
    |   +-GetStructField
    |     +-type=STRING
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<`1ğŒ°:aoÌ‚` STRING>, column=unicode_column_table.a#3)
    |     +-field_idx=0
    +-input_scan=
      +-TableScan(column_list=[unicode_column_table.a#3], table=unicode_column_table, column_index_list=[2])
==

[no_java]

# Access sub fields of a struct field using .*.

select a.*
from unicode_column_table;
--
QueryStmt
+-output_column_list=
| +-$query.1ğŒ°:aoÌ‚#4 AS `1ğŒ°:aoÌ‚` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.1ğŒ°:aoÌ‚#4]
    +-expr_list=
    | +-1ğŒ°:aoÌ‚#4 :=
    |   +-GetStructField
    |     +-type=STRING
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<`1ğŒ°:aoÌ‚` STRING>, column=unicode_column_table.a#3)
    |     +-field_idx=0
    +-input_scan=
      +-TableScan(column_list=[unicode_column_table.a#3], table=unicode_column_table, column_index_list=[2])
==

[no_java]

select *
from unicode_column_table;
--
QueryStmt
+-output_column_list=
| +-unicode_column_table.Ã¥å­¦#1 AS `Ã¥å­¦` [INT64]
| +-unicode_column_table.oÌ‚#2 AS `oÌ‚` [STRING]
| +-unicode_column_table.a#3 AS a [STRUCT<`1ğŒ°:aoÌ‚` STRING>]
+-query=
  +-ProjectScan
    +-column_list=unicode_column_table.[Ã¥å­¦#1, oÌ‚#2, a#3]
    +-input_scan=
      +-TableScan(column_list=unicode_column_table.[Ã¥å­¦#1, oÌ‚#2, a#3], table=unicode_column_table, column_index_list=[0, 1, 2])
==

[no_java]

# Access top level field with Unicode character name in a different case than
# the field name in the table.

select `Ã…å­¦`
from unicode_column_table;
--
QueryStmt
+-output_column_list=
| +-unicode_column_table.Ã¥å­¦#1 AS `Ã…å­¦` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[unicode_column_table.Ã¥å­¦#1]
    +-input_scan=
      +-TableScan(column_list=[unicode_column_table.Ã¥å­¦#1], table=unicode_column_table, column_index_list=[0])
==

[no_java]

# Access top level field with Unicode character name in a different
# respresentation (normalization) than the field name in the table.

select `Ã…å­¦`, `O\u0302`
from unicode_column_table;
--
QueryStmt
+-output_column_list=
| +-unicode_column_table.Ã¥å­¦#1 AS `Ã…å­¦` [INT64]
| +-unicode_column_table.oÌ‚#2 AS `OÌ‚` [STRING]
+-query=
  +-ProjectScan
    +-column_list=unicode_column_table.[Ã¥å­¦#1, oÌ‚#2]
    +-input_scan=
      +-TableScan(column_list=unicode_column_table.[Ã¥å­¦#1, oÌ‚#2], table=unicode_column_table, column_index_list=[0, 1])
==

[no_java]

# Access nested field with Unicode character name in a different respresentation
# (normalization) than the field name in the table.

select `Ã”`, a.`1ğŒ°:AÃ”`
from unicode_column_table;
--
QueryStmt
+-output_column_list=
| +-unicode_column_table.oÌ‚#2 AS `Ã”` [STRING]
| +-$query.1ğŒ°:AÃ”#4 AS `1ğŒ°:AÃ”` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[unicode_column_table.oÌ‚#2, $query.1ğŒ°:AÃ”#4]
    +-expr_list=
    | +-1ğŒ°:AÃ”#4 :=
    |   +-GetStructField
    |     +-type=STRING
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<`1ğŒ°:aoÌ‚` STRING>, column=unicode_column_table.a#3)
    |     +-field_idx=0
    +-input_scan=
      +-TableScan(column_list=unicode_column_table.[oÌ‚#2, a#3], table=unicode_column_table, column_index_list=[1, 2])
==

[no_java]

# Access nested field with Unicode character name in a different respresentation
# (normalization) than the field name in the table.

select `Ã”`, a.`1ğŒ°:AO\u0302`
from unicode_column_table;
--
QueryStmt
+-output_column_list=
| +-unicode_column_table.oÌ‚#2 AS `Ã”` [STRING]
| +-$query.1ğŒ°:AOÌ‚#4 AS `1ğŒ°:AOÌ‚` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[unicode_column_table.oÌ‚#2, $query.1ğŒ°:AOÌ‚#4]
    +-expr_list=
    | +-1ğŒ°:AOÌ‚#4 :=
    |   +-GetStructField
    |     +-type=STRING
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<`1ğŒ°:aoÌ‚` STRING>, column=unicode_column_table.a#3)
    |     +-field_idx=0
    +-input_scan=
      +-TableScan(column_list=unicode_column_table.[oÌ‚#2, a#3], table=unicode_column_table, column_index_list=[1, 2])
==

[no_java]

create table tbl(`Ã”` INT64, `Ã…å­¦` INT64);
--
CreateTableStmt
+-name_path=tbl
+-column_definition_list=
  +-ColumnDefinition(name="Ã”", type=INT64, column=tbl.Ã”#1)
  +-ColumnDefinition(name="Ã…å­¦", type=INT64, column=tbl.Ã…å­¦#2)
==

[no_java]

create table tbl(`Ã”` INT64, `oÌ‚` INT64);
--
ERROR: Duplicate column name oÌ‚ in CREATE TABLE [at 1:29]
create table tbl(`Ã”` INT64, `oÌ‚` INT64);
                            ^
==
