select KitchenSink.repeated_int32_val from TestTable;
--
QueryStmt
+-output_column_list=
| +-$query.repeated_int32_val#4 AS repeated_int32_val [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.repeated_int32_val#4]
    +-expr_list=
    | +-repeated_int32_val#4 :=
    |   +-GetProtoField
    |     +-type=ARRAY<INT32>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-field_descriptor=repeated_int32_val
    |     +-default_value=[]
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

select key, val
from TestTable tt, tt.KitchenSink.repeated_int32_val val;
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-$array.val#4 AS val [INT32]
+-query=
  +-ProjectScan
    +-column_list=[TestTable.key#1, $array.val#4]
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $array.val#4]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2], alias="tt")
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<INT32>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   +-field_descriptor=repeated_int32_val
        |   +-default_value=[]
        +-element_column=$array.val#4
==

# The second `TestTable` is an alias for the first scan, not a new table scan.
select repeated_int32_val
from TestTable, TestTable.KitchenSink.repeated_int32_val;
--
QueryStmt
+-output_column_list=
| +-$array.repeated_int32_val#4 AS repeated_int32_val [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$array.repeated_int32_val#4]
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.KitchenSink#3, $array.repeated_int32_val#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<INT32>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   +-field_descriptor=repeated_int32_val
        |   +-default_value=[]
        +-element_column=$array.repeated_int32_val#4
==

# Flatten a chain of nested arrays of structs of arrays.
# This one works without using any aliases.
select TestTable.key, nested_repeated_value, nested_repeated_value.nested_int64, nested_repeated_int64
from TestTable, TestTable.KitchenSink.nested_repeated_value, nested_repeated_value.nested_repeated_int64;
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-$array.nested_repeated_value#4 AS nested_repeated_value [PROTO<zetasql_test__.KitchenSinkPB.Nested>]
| +-$query.nested_int64#6 AS nested_int64 [INT64]
| +-$array.nested_repeated_int64#5 AS nested_repeated_int64 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[TestTable.key#1, $array.nested_repeated_value#4, $query.nested_int64#6, $array.nested_repeated_int64#5]
    +-expr_list=
    | +-nested_int64#6 :=
    |   +-GetProtoField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nested_repeated_value#4)
    |     +-field_descriptor=nested_int64
    |     +-default_value=88
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $array.nested_repeated_value#4, $array.nested_repeated_int64#5]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $array.nested_repeated_value#4]
        |   +-input_scan=
        |   | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        |   +-array_expr=
        |   | +-GetProtoField
        |   |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
        |   |   +-expr=
        |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   +-field_descriptor=nested_repeated_value
        |   |   +-default_value=[]
        |   +-element_column=$array.nested_repeated_value#4
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<INT64>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nested_repeated_value#4)
        |   +-field_descriptor=nested_repeated_int64
        |   +-default_value=[]
        +-element_column=$array.nested_repeated_int64#5
==

# Flatten a chain of nested arrays of structs of arrays.
# This one gives aliases to each step.
select tt.key, nrv, nrv.nested_int64, ri
from TestTable tt, tt.KitchenSink.nested_repeated_value nrv, nrv.nested_repeated_int64 ri;
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-$array.nrv#4 AS nrv [PROTO<zetasql_test__.KitchenSinkPB.Nested>]
| +-$query.nested_int64#6 AS nested_int64 [INT64]
| +-$array.ri#5 AS ri [INT64]
+-query=
  +-ProjectScan
    +-column_list=[TestTable.key#1, $array.nrv#4, $query.nested_int64#6, $array.ri#5]
    +-expr_list=
    | +-nested_int64#6 :=
    |   +-GetProtoField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nrv#4)
    |     +-field_descriptor=nested_int64
    |     +-default_value=88
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $array.nrv#4, $array.ri#5]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $array.nrv#4]
        |   +-input_scan=
        |   | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2], alias="tt")
        |   +-array_expr=
        |   | +-GetProtoField
        |   |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
        |   |   +-expr=
        |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   +-field_descriptor=nested_repeated_value
        |   |   +-default_value=[]
        |   +-element_column=$array.nrv#4
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<INT64>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nrv#4)
        |   +-field_descriptor=nested_repeated_int64
        |   +-default_value=[]
        +-element_column=$array.ri#5
==

# Here we go through a path of multiple optional fields to get to the repeated field.
select ri
from TestTable tt, tt.KitchenSink.nested_value.nested_repeated_int64 ri;
--
QueryStmt
+-output_column_list=
| +-$array.ri#4 AS ri [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$array.ri#4]
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.KitchenSink#3, $array.ri#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<INT64>
        |   +-expr=
        |   | +-GetProtoField
        |   |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
        |   |   +-expr=
        |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   +-field_descriptor=nested_value
        |   |   +-default_value=NULL
        |   +-field_descriptor=nested_repeated_int64
        |   +-default_value=[]
        +-element_column=$array.ri#4
==

# TODO We may want to make this work.
# TODO Bad error message right now. Should identify that a prefix is
# a table.
select ri
from TestTable.KitchenSink.nested_value.nested_repeated_int64 ri;
--
ERROR: Table not found: TestTable.KitchenSink.nested_value.nested_repeated_int64 [at 2:6]
from TestTable.KitchenSink.nested_value.nested_repeated_int64 ri;
     ^
==

# Expand multiple arrays, making cross products.
select tt.key, nrv.nested_int64, ri, nested_repeated_value
from TestTable tt,
     tt.KitchenSink.nested_repeated_value nrv,
     tt.KitchenSink.repeated_int32_val ri,
     tt.KitchenSink.nested_repeated_value;
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-$query.nested_int64#7 AS nested_int64 [INT64]
| +-$array.ri#5 AS ri [INT32]
| +-$array.nested_repeated_value#6 AS nested_repeated_value [PROTO<zetasql_test__.KitchenSinkPB.Nested>]
+-query=
  +-ProjectScan
    +-column_list=[TestTable.key#1, $query.nested_int64#7, $array.ri#5, $array.nested_repeated_value#6]
    +-expr_list=
    | +-nested_int64#7 :=
    |   +-GetProtoField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nrv#4)
    |     +-field_descriptor=nested_int64
    |     +-default_value=88
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $array.nrv#4, $array.ri#5, $array.nested_repeated_value#6]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $array.nrv#4, $array.ri#5]
        |   +-input_scan=
        |   | +-ArrayScan
        |   |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $array.nrv#4]
        |   |   +-input_scan=
        |   |   | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2], alias="tt")
        |   |   +-array_expr=
        |   |   | +-GetProtoField
        |   |   |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
        |   |   |   +-expr=
        |   |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   |   +-field_descriptor=nested_repeated_value
        |   |   |   +-default_value=[]
        |   |   +-element_column=$array.nrv#4
        |   +-array_expr=
        |   | +-GetProtoField
        |   |   +-type=ARRAY<INT32>
        |   |   +-expr=
        |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   +-field_descriptor=repeated_int32_val
        |   |   +-default_value=[]
        |   +-element_column=$array.ri#5
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   +-field_descriptor=nested_repeated_value
        |   +-default_value=[]
        +-element_column=$array.nested_repeated_value#6
==

# Array names are always treated as explicit so duplicates are not allowed.
select key
from TestTable tt,
     tt.KitchenSink.nested_repeated_value,
     tt.KitchenSink.nested_repeated_value;
--
ERROR: Duplicate alias nested_repeated_value found [at 4:6]
     tt.KitchenSink.nested_repeated_value;
     ^
==

# Duplicate explicit array aliases.
select tt.key
from TestTable tt,
     tt.KitchenSink.nested_repeated_value nrv,
     tt.KitchenSink.nested_repeated_value nrv;
--
ERROR: Duplicate alias nrv found [at 4:43]
     tt.KitchenSink.nested_repeated_value nrv;
                                          ^
==

# An array cannot create a column that duplicates an explicit scan alias.
select tt.key
from TestTable tt, tt.KitchenSink.nested_repeated_value tt;
--
ERROR: Duplicate alias tt found [at 2:57]
from TestTable tt, tt.KitchenSink.nested_repeated_value tt;
                                                        ^
==

# Two array scans that contain a field with the same name, so it
# is ambiguous to resolve without qualification.
select key, nrv1.nested_int64, nested_int64
from TestTable tt,
     tt.KitchenSink.nested_repeated_value nrv1,
     tt.KitchenSink.nested_repeated_value nrv2;
--
ERROR: Column name nested_int64 is ambiguous [at 1:32]
select key, nrv1.nested_int64, nested_int64
                               ^
==

# JOIN syntax.
select tt.key, ri, nrv, rb, rs
from TestTable tt
  JOIN tt.KitchenSink.repeated_int32_val ri
  INNER JOIN tt.KitchenSink.nested_repeated_value nrv
  LEFT JOIN tt.KitchenSink.repeated_string_val rs
  CROSS JOIN tt.KitchenSink.repeated_bytes_val rb;
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-$array.ri#4 AS ri [INT32]
| +-$array.nrv#5 AS nrv [PROTO<zetasql_test__.KitchenSinkPB.Nested>]
| +-$array.rb#7 AS rb [BYTES]
| +-$array.rs#6 AS rs [STRING]
+-query=
  +-ProjectScan
    +-column_list=[TestTable.key#1, $array.ri#4, $array.nrv#5, $array.rb#7, $array.rs#6]
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $array.ri#4, $array.nrv#5, $array.rs#6, $array.rb#7]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $array.ri#4, $array.nrv#5, $array.rs#6]
        |   +-input_scan=
        |   | +-ArrayScan
        |   |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $array.ri#4, $array.nrv#5]
        |   |   +-input_scan=
        |   |   | +-ArrayScan
        |   |   |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $array.ri#4]
        |   |   |   +-input_scan=
        |   |   |   | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2], alias="tt")
        |   |   |   +-array_expr=
        |   |   |   | +-GetProtoField
        |   |   |   |   +-type=ARRAY<INT32>
        |   |   |   |   +-expr=
        |   |   |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   |   |   +-field_descriptor=repeated_int32_val
        |   |   |   |   +-default_value=[]
        |   |   |   +-element_column=$array.ri#4
        |   |   +-array_expr=
        |   |   | +-GetProtoField
        |   |   |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
        |   |   |   +-expr=
        |   |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   |   +-field_descriptor=nested_repeated_value
        |   |   |   +-default_value=[]
        |   |   +-element_column=$array.nrv#5
        |   +-array_expr=
        |   | +-GetProtoField
        |   |   +-type=ARRAY<STRING>
        |   |   +-expr=
        |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   +-field_descriptor=repeated_string_val
        |   |   +-default_value=[]
        |   +-element_column=$array.rs#6
        |   +-is_outer=TRUE
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<BYTES>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   +-field_descriptor=repeated_bytes_val
        |   +-default_value=[]
        +-element_column=$array.rb#7
==

select 1
from TestTable tt
  LEFT JOIN tt.KitchenSink.repeated_string_val rs
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 := Literal(type=INT64, value=1)
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<STRING>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   +-field_descriptor=repeated_string_val
        |   +-default_value=[]
        +-element_column=$array.rs#4
        +-is_outer=TRUE
==

select 1
from TestTable tt
  LEFT JOIN tt.KitchenSink.repeated_string_val rs
      ON tt.KitchenSink.string_val = rs
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 := Literal(type=INT64, value=1)
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.KitchenSink#3, $array.rs#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<STRING>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   +-field_descriptor=repeated_string_val
        |   +-default_value=[]
        +-element_column=$array.rs#4
        +-join_expr=
        | +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
        |   +-GetProtoField
        |   | +-type=STRING
        |   | +-expr=
        |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   | +-field_descriptor=string_val
        |   | +-default_value="default_name"
        |   +-ColumnRef(type=STRING, column=$array.rs#4)
        +-is_outer=TRUE
==

select 1
from TestTable tt
  JOIN tt.KitchenSink.repeated_string_val rs
      ON tt.KitchenSink.string_val
--
ERROR: JOIN ON clause should return type BOOL, but returns STRING [at 4:10]
      ON tt.KitchenSink.string_val
         ^
==

# Error inside the ON expression.
select 1
from TestTable tt
  LEFT JOIN tt.KitchenSink.repeated_string_val rs
      ON tt.string_val = rs
--
ERROR: Name string_val not found inside tt [at 4:13]
      ON tt.string_val = rs
            ^
==

select 1
from TestTable tt RIGHT JOIN tt.KitchenSink.repeated_int32_val ri;
--
ERROR: Array scan is not allowed with RIGHT JOIN: tt.KitchenSink.repeated_int32_val [at 2:30]
from TestTable tt RIGHT JOIN tt.KitchenSink.repeated_int32_val ri;
                             ^
==

select 1
from TestTable tt FULL JOIN tt.KitchenSink.repeated_int32_val ri;
--
ERROR: Array scan is not allowed with FULL JOIN: tt.KitchenSink.repeated_int32_val [at 2:29]
from TestTable tt FULL JOIN tt.KitchenSink.repeated_int32_val ri;
                            ^
==

select 1
from TestTable tt NATURAL JOIN tt.KitchenSink.repeated_int32_val ri;
--
ERROR: Array scan is not allowed with NATURAL JOIN: tt.KitchenSink.repeated_int32_val [at 2:32]
from TestTable tt NATURAL JOIN tt.KitchenSink.repeated_int32_val ri;
                               ^
==

select 1
from TestTable tt
  JOIN tt.KitchenSink.repeated_int64_val ON repeated_int64_val = 0;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 := Literal(type=INT64, value=1)
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.KitchenSink#3, $array.repeated_int64_val#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<INT64>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   +-field_descriptor=repeated_int64_val
        |   +-default_value=[]
        +-element_column=$array.repeated_int64_val#4
        +-join_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=$array.repeated_int64_val#4)
            +-Literal(type=INT64, value=0)
==

select 1
from TestTable tt
  JOIN tt.KitchenSink.repeated_int64_val ON NULL;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 := Literal(type=INT64, value=1)
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<INT64>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   +-field_descriptor=repeated_int64_val
        |   +-default_value=[]
        +-element_column=$array.repeated_int64_val#4
        +-join_expr=
          +-Literal(type=BOOL, value=NULL)
==

select 1
from TestTable tt JOIN tt.KitchenSink.repeated_int32_val USING (x);
--
ERROR: Column x in USING clause not found on left side of join [at 2:65]
from TestTable tt JOIN tt.KitchenSink.repeated_int32_val USING (x);
                                                                ^
==

select 1
from TestTable tt JOIN tt.KitchenSink.int32_val;
--
ERROR: Values referenced in FROM clause must be arrays. tt.KitchenSink.int32_val has type INT32 [at 2:24]
from TestTable tt JOIN tt.KitchenSink.int32_val;
                       ^
==

# Array scan from a subquery result.
# `nrv` is unambiguous because the range variable always takes precedence
# over the column.
select key, nrv.nested_int64
from (select Key, KitchenSink.nested_repeated_value nrv from TestTable) subq,
     subq.nrv {{|as nrv}};
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-$query.nested_int64#6 AS nested_int64 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[TestTable.key#1, $query.nested_int64#6]
    +-expr_list=
    | +-nested_int64#6 :=
    |   +-GetProtoField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nrv#5)
    |     +-field_descriptor=nested_int64
    |     +-default_value=88
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.key#1, subq.nrv#4, $array.nrv#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, subq.nrv#4]
        |   +-expr_list=
        |   | +-nrv#4 :=
        |   |   +-GetProtoField
        |   |     +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=nested_repeated_value
        |   |     +-default_value=[]
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-array_expr=
        | +-ColumnRef(type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>, column=subq.nrv#4)
        +-element_column=$array.nrv#5
==

# `nested_repeated_value` is unambiguous, like in the previous query.
select key, nested_repeated_value.nested_int64
from (select Key, KitchenSink.nested_repeated_value from TestTable) subq,
     subq.nested_repeated_value;
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-$query.nested_int64#6 AS nested_int64 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[TestTable.key#1, $query.nested_int64#6]
    +-expr_list=
    | +-nested_int64#6 :=
    |   +-GetProtoField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nested_repeated_value#5)
    |     +-field_descriptor=nested_int64
    |     +-default_value=88
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.key#1, subq.nested_repeated_value#4, $array.nested_repeated_value#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, subq.nested_repeated_value#4]
        |   +-expr_list=
        |   | +-nested_repeated_value#4 :=
        |   |   +-GetProtoField
        |   |     +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=nested_repeated_value
        |   |     +-default_value=[]
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-array_expr=
        | +-ColumnRef(type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>, column=subq.nested_repeated_value#4)
        +-element_column=$array.nested_repeated_value#5
==

# `nested_repeated_int64` is unambiguous because the range variable version
# (second clause in from) hides the column version (inside first clause in from).
#
# (This test uses nested_value.nested_repeated_int64 rather than
#  nested_repeated_value because .* on KitchenSink is huge and volatile.)
select key, nested_repeated_int64
from (select Key, KitchenSink.nested_value.nested_repeated_int64
      from TestTable) subq,
     subq.nested_repeated_int64
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-$array.nested_repeated_int64#5 AS nested_repeated_int64 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[TestTable.key#1, $array.nested_repeated_int64#5]
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.key#1, subq.nested_repeated_int64#4, $array.nested_repeated_int64#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.key#1, subq.nested_repeated_int64#4]
        |   +-expr_list=
        |   | +-nested_repeated_int64#4 :=
        |   |   +-GetProtoField
        |   |     +-type=ARRAY<INT64>
        |   |     +-expr=
        |   |     | +-GetProtoField
        |   |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
        |   |     |   +-expr=
        |   |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     |   +-field_descriptor=nested_value
        |   |     |   +-default_value=NULL
        |   |     +-field_descriptor=nested_repeated_int64
        |   |     +-default_value=[]
        |   +-input_scan=
        |     +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-array_expr=
        | +-ColumnRef(type=ARRAY<INT64>, column=subq.nested_repeated_int64#4)
        +-element_column=$array.nested_repeated_int64#5
==

select 1
from (select Key, KitchenSink.nested_repeated_value nrv).nrv;
--
ERROR: Syntax error: Expected end of input but got "." [at 2:57]
from (select Key, KitchenSink.nested_repeated_value nrv).nrv;
                                                        ^
==

select 1
from TestTable, KitchenSink;
--
ERROR: Table not found: KitchenSink (Unqualified identifiers in a FROM clause are always resolved as tables. Identifier KitchenSink is in scope but unqualified names cannot be resolved here.) [at 2:17]
from TestTable, KitchenSink;
                ^
==

# Refencing a column name from a previous scan without using its alias
# is not allowed.
select 1
from TestTable, KitchenSink.nested_repeated_value nrv;
--
ERROR: Aliases referenced in the from clause must refer to preceding scans, and cannot refer to columns on those scans. KitchenSink refers to a column and must be qualified with a table name. [at 2:17]
from TestTable, KitchenSink.nested_repeated_value nrv;
                ^
==

# Mixing comma JOIN and join keywords.  The scoping behavior is that the
# names from the leftwards comma joins are visible inside the JOIN clause to
# their right.
select 1
from TestTable tt,
     KeyValue CROSS JOIN tt.KitchenSink.repeated_int32_val val1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 := Literal(type=INT64, value=1)
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[TestTable.KitchenSink#3]
        |   +-left_scan=
        |   | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
        |   +-right_scan=
        |     +-TableScan(table=KeyValue)
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<INT32>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   +-field_descriptor=repeated_int32_val
        |   +-default_value=[]
        +-element_column=$array.val1#6
==

select 1
from TestTable tt,
     KeyValue JOIN tt.KitchenSink.repeated_int32_val val ON tt.Key = val
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 := Literal(type=INT64, value=1)
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, $array.val#6]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=TestTable.[key#1, KitchenSink#3]
        |   +-left_scan=
        |   | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2], alias="tt")
        |   +-right_scan=
        |     +-TableScan(table=KeyValue)
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<INT32>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   +-field_descriptor=repeated_int32_val
        |   +-default_value=[]
        +-element_column=$array.val#6
        +-join_expr=
          +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
            +-ColumnRef(type=INT32, column=TestTable.key#1)
            +-ColumnRef(type=INT32, column=$array.val#6)
==

# Join two arrays coming from correlated references to an outer query
# using UNNEST.
# We get an ArrayScan of an ArrayScan, rather than a join of two ArrayScans.
# Either plan would work here because the arrays are uncorrelated to each
# other, but the resolver always builds joins to arrays this way.
select (select count(*)
        from UNNEST(t.KitchenSink.repeated_date) d1 join
             UNNEST(t.KitchenSink.repeated_date) d2 on d1=d2)
from TestTable t
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$aggregate.$agg1#6]
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$aggregate.$agg1#6]
    |             +-input_scan=
    |             | +-ArrayScan
    |             |   +-column_list=$array.[d1#4, d2#5]
    |             |   +-input_scan=
    |             |   | +-ArrayScan
    |             |   |   +-column_list=[$array.d1#4]
    |             |   |   +-array_expr=
    |             |   |   | +-GetProtoField
    |             |   |   |   +-type=ARRAY<DATE>
    |             |   |   |   +-expr=
    |             |   |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |             |   |   |   +-field_descriptor=repeated_date
    |             |   |   |   +-default_value=[]
    |             |   |   |   +-format=DATE
    |             |   |   +-element_column=$array.d1#4
    |             |   +-array_expr=
    |             |   | +-GetProtoField
    |             |   |   +-type=ARRAY<DATE>
    |             |   |   +-expr=
    |             |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |             |   |   +-field_descriptor=repeated_date
    |             |   |   +-default_value=[]
    |             |   |   +-format=DATE
    |             |   +-element_column=$array.d2#5
    |             |   +-join_expr=
    |             |     +-FunctionCall(ZetaSQL:$equal(DATE, DATE) -> BOOL)
    |             |       +-ColumnRef(type=DATE, column=$array.d1#4)
    |             |       +-ColumnRef(type=DATE, column=$array.d2#5)
    |             +-aggregate_list=
    |               +-$agg1#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="t")
==

# Same thing with implicit array references, without UNNEST.

select (select count(*)
        from t.KitchenSink.repeated_date d1 join
             t.KitchenSink.repeated_date d2 on d1=d2)
from TestTable t
--
[SAME AS PREVIOUS]
==

select (select AS STRUCT d1, offset
        from t.KitchenSink.repeated_date d1 with offset cross join
             UNNEST([1]))
from TestTable t
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS `$col1` [STRUCT<d1 DATE, offset INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8]
    +-expr_list=
    | +-$col1#8 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<d1 DATE, offset INT64>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#7]
    |         +-expr_list=
    |         | +-$struct#7 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<d1 DATE, offset INT64>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=DATE, column=$array.d1#4)
    |         |       +-ColumnRef(type=INT64, column=$array_offset.offset#5)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$array.d1#4, $array_offset.offset#5]
    |             +-input_scan=
    |               +-ArrayScan
    |                 +-column_list=[$array.d1#4, $array_offset.offset#5]
    |                 +-input_scan=
    |                 | +-ArrayScan
    |                 |   +-column_list=[$array.d1#4, $array_offset.offset#5]
    |                 |   +-array_expr=
    |                 |   | +-GetProtoField
    |                 |   |   +-type=ARRAY<DATE>
    |                 |   |   +-expr=
    |                 |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |                 |   |   +-field_descriptor=repeated_date
    |                 |   |   +-default_value=[]
    |                 |   |   +-format=DATE
    |                 |   +-element_column=$array.d1#4
    |                 |   +-array_offset_column=
    |                 |     +-ColumnHolder(column=$array_offset.offset#5)
    |                 +-array_expr=
    |                 | +-Literal(type=ARRAY<INT64>, value=[1])
    |                 +-element_column=$array.$unnest1#6
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="t")
==

# Bad correlated array reference inside a join.
select (select count(*)
        from t.bad_name d1 cross join UNNEST([1]))
from TestTable t
--
ERROR: Name bad_name not found inside t [at 2:16]
        from t.bad_name d1 cross join UNNEST([1]))
               ^
==

# Single identifier path is always resolved as a table name.
select (select count(*)
        from t d1 cross join UNNEST([1]))
from TestTable t
--
ERROR: Table not found: t (Unqualified identifiers in a FROM clause are always resolved as tables. Identifier t is in scope but unqualified names cannot be resolved here.) [at 2:14]
        from t d1 cross join UNNEST([1]))
             ^
==

# The 'KitchenSink' reference is ambiguous since it appears in
# both t1 and t2.  This query is similar to the one in b/26886818, with an
# invalid field reference from KitchenSink.
select t1.KitchenSink.int64_key_1
from TestTable t1, TestTable t2,
     KitchenSink.invalid_column_name int32_val
--
ERROR: KitchenSink ambiguously references multiple columns in previous FROM clause tables [at 3:6]
     KitchenSink.invalid_column_name int32_val
     ^
==

# Similar to the previous, but with a valid field reference.
select t1.KitchenSink.int64_key_1
from TestTable t1, TestTable t2,
     KitchenSink.repeated_int32_val int32_val
--
ERROR: KitchenSink ambiguously references multiple columns in previous FROM clause tables [at 3:6]
     KitchenSink.repeated_int32_val int32_val
     ^
==

# Similar to the previous, but with an explicit UNNEST().
select t1.KitchenSink.int64_key_1
from TestTable t1, TestTable t2,
     UNNEST(KitchenSink.repeated_int32_val) int32_val
--
ERROR: Column name KitchenSink is ambiguous [at 3:13]
     UNNEST(KitchenSink.repeated_int32_val) int32_val
            ^
==

# Similar test as the previous tests, but with value tables.
# An unqualified reference to 'repeated_int32_val' is ambiguous,
# but qualified references are ok.
select t1.int64_key_1
from KitchenSinkValueTable t1, KitchenSinkValueTable t2,
     {{t1.|t2.|}} repeated_int32_val int32_val
--
ALTERNATION GROUP: t1.
--
QueryStmt
+-output_column_list=
| +-$query.int64_key_1#4 AS int64_key_1 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.int64_key_1#4]
    +-expr_list=
    | +-int64_key_1#4 :=
    |   +-GetProtoField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |     +-field_descriptor=int64_key_1
    +-input_scan=
      +-ArrayScan
        +-column_list=[KitchenSinkValueTable.value#1]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[KitchenSinkValueTable.value#1]
        |   +-left_scan=
        |   | +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0], alias="t1")
        |   +-right_scan=
        |     +-TableScan(table=KitchenSinkValueTable, alias="t2")
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<INT32>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
        |   +-field_descriptor=repeated_int32_val
        |   +-default_value=[]
        +-element_column=$array.int32_val#3
--
ALTERNATION GROUP: t2.
--
QueryStmt
+-output_column_list=
| +-$query.int64_key_1#4 AS int64_key_1 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.int64_key_1#4]
    +-expr_list=
    | +-int64_key_1#4 :=
    |   +-GetProtoField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |     +-field_descriptor=int64_key_1
    +-input_scan=
      +-ArrayScan
        +-column_list=KitchenSinkValueTable.[value#1, value#2]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=KitchenSinkValueTable.[value#1, value#2]
        |   +-left_scan=
        |   | +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0], alias="t1")
        |   +-right_scan=
        |     +-TableScan(column_list=[KitchenSinkValueTable.value#2], table=KitchenSinkValueTable, column_index_list=[0], alias="t2")
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<INT32>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#2)
        |   +-field_descriptor=repeated_int32_val
        |   +-default_value=[]
        +-element_column=$array.int32_val#3
--
ALTERNATION GROUP: <empty>
--
ERROR: Table not found: repeated_int32_val (Unqualified identifiers in a FROM clause are always resolved as tables. Identifier repeated_int32_val is in scope but unqualified names cannot be resolved here.) [at 3:7]
      repeated_int32_val int32_val
      ^
==

# These are similar to the previous tests, but with structs instead of protos.
select *
from (select struct<arraycol array<int64>>([0,1,2]) as struct_field) t1,
     (select struct<arraycol array<int64>>([0,1,2]) as struct_field) t2,
     {{t1.|t2.|}}struct_field.arraycol
--
ALTERNATION GROUP: t1.
--
QueryStmt
+-output_column_list=
| +-t1.struct_field#1 AS struct_field [STRUCT<arraycol ARRAY<INT64>>]
| +-t2.struct_field#2 AS struct_field [STRUCT<arraycol ARRAY<INT64>>]
| +-$array.arraycol#3 AS arraycol [INT64]
+-query=
  +-ProjectScan
    +-column_list=[t1.struct_field#1, t2.struct_field#2, $array.arraycol#3]
    +-input_scan=
      +-ArrayScan
        +-column_list=[t1.struct_field#1, t2.struct_field#2, $array.arraycol#3]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[t1.struct_field#1, t2.struct_field#2]
        |   +-left_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[t1.struct_field#1]
        |   |   +-expr_list=
        |   |   | +-struct_field#1 := Literal(type=STRUCT<arraycol ARRAY<INT64>>, value={arraycol:[0, 1, 2]}, has_explicit_type=TRUE)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-right_scan=
        |     +-ProjectScan
        |       +-column_list=[t2.struct_field#2]
        |       +-expr_list=
        |       | +-struct_field#2 := Literal(type=STRUCT<arraycol ARRAY<INT64>>, value={arraycol:[0, 1, 2]}, has_explicit_type=TRUE)
        |       +-input_scan=
        |         +-SingleRowScan
        +-array_expr=
        | +-GetStructField
        |   +-type=ARRAY<INT64>
        |   +-expr=
        |   | +-ColumnRef(type=STRUCT<arraycol ARRAY<INT64>>, column=t1.struct_field#1)
        |   +-field_idx=0
        +-element_column=$array.arraycol#3
--
ALTERNATION GROUP: t2.
--
QueryStmt
+-output_column_list=
| +-t1.struct_field#1 AS struct_field [STRUCT<arraycol ARRAY<INT64>>]
| +-t2.struct_field#2 AS struct_field [STRUCT<arraycol ARRAY<INT64>>]
| +-$array.arraycol#3 AS arraycol [INT64]
+-query=
  +-ProjectScan
    +-column_list=[t1.struct_field#1, t2.struct_field#2, $array.arraycol#3]
    +-input_scan=
      +-ArrayScan
        +-column_list=[t1.struct_field#1, t2.struct_field#2, $array.arraycol#3]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[t1.struct_field#1, t2.struct_field#2]
        |   +-left_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[t1.struct_field#1]
        |   |   +-expr_list=
        |   |   | +-struct_field#1 := Literal(type=STRUCT<arraycol ARRAY<INT64>>, value={arraycol:[0, 1, 2]}, has_explicit_type=TRUE)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-right_scan=
        |     +-ProjectScan
        |       +-column_list=[t2.struct_field#2]
        |       +-expr_list=
        |       | +-struct_field#2 := Literal(type=STRUCT<arraycol ARRAY<INT64>>, value={arraycol:[0, 1, 2]}, has_explicit_type=TRUE)
        |       +-input_scan=
        |         +-SingleRowScan
        +-array_expr=
        | +-GetStructField
        |   +-type=ARRAY<INT64>
        |   +-expr=
        |   | +-ColumnRef(type=STRUCT<arraycol ARRAY<INT64>>, column=t2.struct_field#2)
        |   +-field_idx=0
        +-element_column=$array.arraycol#3
--
ALTERNATION GROUP: <empty>
--
ERROR: struct_field ambiguously references multiple columns in previous FROM clause tables [at 4:6]
     struct_field.arraycol
     ^
==

# Similar to the previous, but only one of the columns is an array type.
select *
from (select struct<arraycol array<int64>>([0,1,2]) as struct_field) t1,
     (select struct<arraycol int64>(0) as struct_field) t2,
     {{t1.|t2.|}}struct_field.arraycol
--
ALTERNATION GROUP: t1.
--
QueryStmt
+-output_column_list=
| +-t1.struct_field#1 AS struct_field [STRUCT<arraycol ARRAY<INT64>>]
| +-t2.struct_field#2 AS struct_field [STRUCT<arraycol INT64>]
| +-$array.arraycol#3 AS arraycol [INT64]
+-query=
  +-ProjectScan
    +-column_list=[t1.struct_field#1, t2.struct_field#2, $array.arraycol#3]
    +-input_scan=
      +-ArrayScan
        +-column_list=[t1.struct_field#1, t2.struct_field#2, $array.arraycol#3]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[t1.struct_field#1, t2.struct_field#2]
        |   +-left_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[t1.struct_field#1]
        |   |   +-expr_list=
        |   |   | +-struct_field#1 := Literal(type=STRUCT<arraycol ARRAY<INT64>>, value={arraycol:[0, 1, 2]}, has_explicit_type=TRUE)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-right_scan=
        |     +-ProjectScan
        |       +-column_list=[t2.struct_field#2]
        |       +-expr_list=
        |       | +-struct_field#2 := Literal(type=STRUCT<arraycol INT64>, value={arraycol:0}, has_explicit_type=TRUE)
        |       +-input_scan=
        |         +-SingleRowScan
        +-array_expr=
        | +-GetStructField
        |   +-type=ARRAY<INT64>
        |   +-expr=
        |   | +-ColumnRef(type=STRUCT<arraycol ARRAY<INT64>>, column=t1.struct_field#1)
        |   +-field_idx=0
        +-element_column=$array.arraycol#3
--
ALTERNATION GROUP: t2.
--
ERROR: Values referenced in FROM clause must be arrays. t2.struct_field.arraycol has type INT64 [at 4:6]
     t2.struct_field.arraycol
     ^
--
ALTERNATION GROUP: <empty>
--
ERROR: struct_field ambiguously references multiple columns in previous FROM clause tables [at 4:6]
     struct_field.arraycol
     ^
==

select *
from (select struct<arraycol array<int64>>([0,1,2]) as struct_field) t1,
     (select struct<arraycol array<int64>>([0,1,2]) as struct_field) t2,
     {{t1.|t2.|}}struct_field.bad_col_name
--
ALTERNATION GROUP: t1.
--
ERROR: Field name bad_col_name does not exist in STRUCT<arraycol ARRAY<INT64>> [at 4:22]
     t1.struct_field.bad_col_name
                     ^
--
ALTERNATION GROUP: t2.
--
ERROR: Field name bad_col_name does not exist in STRUCT<arraycol ARRAY<INT64>> [at 4:22]
     t2.struct_field.bad_col_name
                     ^
--
ALTERNATION GROUP: <empty>
--
ERROR: struct_field ambiguously references multiple columns in previous FROM clause tables [at 4:6]
     struct_field.bad_col_name
     ^
==

# The array name is ambiguous in the same table.
select *
from (select struct<arraycol array<int64>>([0,1,2]) as struct_field,
             struct<arraycol array<int64>>([0,1,2]) as struct_field) t1,
     {{t1.|}}struct_field.arraycol
--
ALTERNATION GROUP: t1.
--
ERROR: Name struct_field is ambiguous inside t1 [at 4:9]
     t1.struct_field.arraycol
        ^
--
ALTERNATION GROUP: <empty>
--
ERROR: struct_field ambiguously references multiple columns in previous FROM clause tables [at 4:6]
     struct_field.arraycol
     ^
==

select *
from (select struct<arraycol array<int64>>([0,1,2]) as struct_field,
             struct<arraycol array<string>>(["a","b"]) as struct_field) t1,
     {{t1.|}}struct_field.arraycol
--
ALTERNATION GROUP: t1.
--
ERROR: Name struct_field is ambiguous inside t1 [at 4:9]
     t1.struct_field.arraycol
        ^
--
ALTERNATION GROUP: <empty>
--
ERROR: struct_field ambiguously references multiple columns in previous FROM clause tables [at 4:6]
     struct_field.arraycol
     ^
