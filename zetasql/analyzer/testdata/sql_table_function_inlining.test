[default enabled_ast_rewrites=ALL]
[default language_features=NONE,+TABLE_VALUED_FUNCTIONS,+WITH_EXPRESSION,+ORDER_BY_IN_AGGREGATE]
[default no_java]

SELECT {{*|a|b}} FROM NullarySelect();
--
ALTERNATION GROUP: *
--
QueryStmt
+-output_column_list=
| +-NullarySelect.a#1 AS a [INT64]
| +-NullarySelect.b#2 AS b [INT64]
+-query=
  +-ProjectScan
    +-column_list=NullarySelect.[a#1, b#2]
    +-input_scan=
      +-TVFScan(column_list=NullarySelect.[a#1, b#2], tvf=NullarySelect(() -> TABLE<a INT64, b INT64>), signature=() -> TABLE<a INT64, b INT64>, column_index_list=[0, 1], function_call_signature=() -> TABLE<a INT64, b INT64>)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-NullarySelect.a#1 AS a [INT64]
| +-NullarySelect.b#2 AS b [INT64]
+-query=
  +-ProjectScan
    +-column_list=NullarySelect.[a#1, b#2]
    +-input_scan=
      +-ProjectScan
        +-column_list=NullarySelect.[a#1, b#2]
        +-expr_list=
        | +-a#1 := Literal(type=INT64, value=1)
        | +-b#2 := Literal(type=INT64, value=2)
        +-input_scan=
          +-SingleRowScan
--
ALTERNATION GROUP: a
--
QueryStmt
+-output_column_list=
| +-NullarySelect.a#1 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[NullarySelect.a#1]
    +-input_scan=
      +-TVFScan(column_list=[NullarySelect.a#1], tvf=NullarySelect(() -> TABLE<a INT64, b INT64>), signature=() -> TABLE<a INT64, b INT64>, column_index_list=[0], function_call_signature=() -> TABLE<a INT64, b INT64>)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-NullarySelect.a#1 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[NullarySelect.a#1]
    +-input_scan=
      +-ProjectScan
        +-column_list=[NullarySelect.a#1, $query.b#3]
        +-expr_list=
        | +-a#1 := Literal(type=INT64, value=1)
        | +-b#3 := Literal(type=INT64, value=2)
        +-input_scan=
          +-SingleRowScan
--
ALTERNATION GROUP: b
--
QueryStmt
+-output_column_list=
| +-NullarySelect.b#2 AS b [INT64]
+-query=
  +-ProjectScan
    +-column_list=[NullarySelect.b#2]
    +-input_scan=
      +-TVFScan(column_list=[NullarySelect.b#2], tvf=NullarySelect(() -> TABLE<a INT64, b INT64>), signature=() -> TABLE<a INT64, b INT64>, column_index_list=[1], function_call_signature=() -> TABLE<a INT64, b INT64>)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-NullarySelect.b#2 AS b [INT64]
+-query=
  +-ProjectScan
    +-column_list=[NullarySelect.b#2]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$query.a#3, NullarySelect.b#2]
        +-expr_list=
        | +-a#3 := Literal(type=INT64, value=1)
        | +-b#2 := Literal(type=INT64, value=2)
        +-input_scan=
          +-SingleRowScan
==

SELECT * FROM NullarySelectUnion();
--
QueryStmt
+-output_column_list=
| +-NullarySelectUnion.a#1 AS a [INT64]
| +-NullarySelectUnion.b#2 AS b [INT64]
+-query=
  +-ProjectScan
    +-column_list=NullarySelectUnion.[a#1, b#2]
    +-input_scan=
      +-TVFScan(column_list=NullarySelectUnion.[a#1, b#2], tvf=NullarySelectUnion(() -> TABLE<a INT64, b INT64>), signature=() -> TABLE<a INT64, b INT64>, column_index_list=[0, 1], function_call_signature=() -> TABLE<a INT64, b INT64>)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-NullarySelectUnion.a#1 AS a [INT64]
| +-NullarySelectUnion.b#2 AS b [INT64]
+-query=
  +-ProjectScan
    +-column_list=NullarySelectUnion.[a#1, b#2]
    +-input_scan=
      +-SetOperationScan
        +-column_list=NullarySelectUnion.[a#1, b#2]
        +-op_type=UNION_ALL
        +-input_item_list=
          +-SetOperationItem
          | +-scan=
          | | +-ProjectScan
          | |   +-column_list=$union_all1.[a#3, b#4]
          | |   +-expr_list=
          | |   | +-a#3 := Literal(type=INT64, value=1)
          | |   | +-b#4 := Literal(type=INT64, value=2)
          | |   +-input_scan=
          | |     +-SingleRowScan
          | +-output_column_list=$union_all1.[a#3, b#4]
          +-SetOperationItem
            +-scan=
            | +-ProjectScan
            |   +-column_list=$union_all2.[$col1#5, $col2#6]
            |   +-expr_list=
            |   | +-$col1#5 := Literal(type=INT64, value=1)
            |   | +-$col2#6 := Literal(type=INT64, value=4)
            |   +-input_scan=
            |     +-SingleRowScan
            +-output_column_list=$union_all2.[$col1#5, $col2#6]
==

SELECT * FROM NullarySelectCTE();
--
QueryStmt
+-output_column_list=
| +-NullarySelectCTE.a#1 AS a [INT64]
| +-NullarySelectCTE.b#2 AS b [INT64]
+-query=
  +-ProjectScan
    +-column_list=NullarySelectCTE.[a#1, b#2]
    +-input_scan=
      +-TVFScan(column_list=NullarySelectCTE.[a#1, b#2], tvf=NullarySelectCTE(() -> TABLE<a INT64, b INT64>), signature=() -> TABLE<a INT64, b INT64>, column_index_list=[0, 1], function_call_signature=() -> TABLE<a INT64, b INT64>)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-NullarySelectCTE.a#1 AS a [INT64]
| +-NullarySelectCTE.b#2 AS b [INT64]
+-query=
  +-ProjectScan
    +-column_list=NullarySelectCTE.[a#1, b#2]
    +-input_scan=
      +-WithScan
        +-column_list=NullarySelectCTE.[a#1, b#2]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="t"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=t.[a#3, b#4]
        |       +-expr_list=
        |       | +-a#3 := Literal(type=INT64, value=1)
        |       | +-b#4 := Literal(type=INT64, value=2)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=NullarySelectCTE.[a#1, b#2]
            +-input_scan=
              +-WithRefScan(column_list=NullarySelectCTE.[a#1, b#2], with_query_name="t")
==

SELECT * FROM NullarySelectFromTvf();
--
QueryStmt
+-output_column_list=
| +-NullarySelectFromTvf.a#1 AS a [INT64]
| +-NullarySelectFromTvf.b#2 AS b [INT64]
+-query=
  +-ProjectScan
    +-column_list=NullarySelectFromTvf.[a#1, b#2]
    +-input_scan=
      +-TVFScan(column_list=NullarySelectFromTvf.[a#1, b#2], tvf=NullarySelectFromTvf(() -> TABLE<a INT64, b INT64>), signature=() -> TABLE<a INT64, b INT64>, column_index_list=[0, 1], function_call_signature=() -> TABLE<a INT64, b INT64>)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-NullarySelectFromTvf.a#1 AS a [INT64]
| +-NullarySelectFromTvf.b#2 AS b [INT64]
+-query=
  +-ProjectScan
    +-column_list=NullarySelectFromTvf.[a#1, b#2]
    +-input_scan=
      +-ProjectScan
        +-column_list=NullarySelectFromTvf.[a#1, b#2]
        +-input_scan=
          +-ProjectScan
            +-column_list=NullarySelectFromTvf.[a#1, b#2]
            +-expr_list=
            | +-a#1 := Literal(type=INT64, value=1)
            | +-b#2 := Literal(type=INT64, value=2)
            +-input_scan=
              +-SingleRowScan
==

SELECT * FROM NullarySelectCallingScalarUDF();
--
QueryStmt
+-output_column_list=
| +-NullarySelectCallingScalarUDF.pi#1 AS pi [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[NullarySelectCallingScalarUDF.pi#1]
    +-input_scan=
      +-TVFScan(column_list=[NullarySelectCallingScalarUDF.pi#1], tvf=NullarySelectCallingScalarUDF(() -> TABLE<pi DOUBLE>), signature=() -> TABLE<pi DOUBLE>, column_index_list=[0], function_call_signature=() -> TABLE<pi DOUBLE>)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-NullarySelectCallingScalarUDF.pi#1 AS pi [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[NullarySelectCallingScalarUDF.pi#1]
    +-input_scan=
      +-ProjectScan
        +-column_list=[NullarySelectCallingScalarUDF.pi#1]
        +-expr_list=
        | +-pi#1 := Literal(type=DOUBLE, value=3.141597)
        +-input_scan=
          +-SingleRowScan
==

SELECT * FROM NullarySelectCallingLambdaArgFunction();
--
QueryStmt
+-output_column_list=
| +-NullarySelectCallingLambdaArgFunction.arr#1 AS arr [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[NullarySelectCallingLambdaArgFunction.arr#1]
    +-input_scan=
      +-TVFScan(column_list=[NullarySelectCallingLambdaArgFunction.arr#1], tvf=NullarySelectCallingLambdaArgFunction(() -> TABLE<arr ARRAY<INT64>>), signature=() -> TABLE<arr ARRAY<INT64>>, column_index_list=[0], function_call_signature=() -> TABLE<arr ARRAY<INT64>>)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-NullarySelectCallingLambdaArgFunction.arr#1 AS arr [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[NullarySelectCallingLambdaArgFunction.arr#1]
    +-input_scan=
      +-ProjectScan
        +-column_list=[NullarySelectCallingLambdaArgFunction.arr#1]
        +-expr_list=
        | +-arr#1 :=
        |   +-SubqueryExpr
        |     +-type=ARRAY<INT64>
        |     +-subquery_type=SCALAR
        |     +-subquery=
        |       +-ProjectScan
        |         +-column_list=[$expr_subquery.$col1#2]
        |         +-expr_list=
        |         | +-$col1#2 :=
        |         |   +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<INT64>, ARRAY<INT64>) -> ARRAY<INT64>)
        |         |     +-FunctionCall(ZetaSQL:$is_null(ARRAY<INT64>) -> BOOL)
        |         |     | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_to_filter#3)
        |         |     +-Literal(type=ARRAY<INT64>, value=NULL)
        |         |     +-SubqueryExpr
        |         |       +-type=ARRAY<INT64>
        |         |       +-subquery_type=ARRAY
        |         |       +-parameter_list=
        |         |       | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_to_filter#3)
        |         |       +-subquery=
        |         |         +-OrderByScan
        |         |           +-column_list=[$array.element#4]
        |         |           +-is_ordered=TRUE
        |         |           +-input_scan=
        |         |           | +-FilterScan
        |         |           |   +-column_list=[$array.element#4, $array_offset.off#5]
        |         |           |   +-input_scan=
        |         |           |   | +-ArrayScan
        |         |           |   |   +-column_list=[$array.element#4, $array_offset.off#5]
        |         |           |   |   +-array_expr_list=
        |         |           |   |   | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_to_filter#3, is_correlated=TRUE)
        |         |           |   |   +-element_column_list=[$array.element#4]
        |         |           |   |   +-array_offset_column=
        |         |           |   |     +-ColumnHolder(column=$array_offset.off#5)
        |         |           |   +-filter_expr=
        |         |           |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |         |           |       +-ColumnRef(type=INT64, column=$array.element#4)
        |         |           |       +-Literal(type=INT64, value=1)
        |         |           +-order_by_item_list=
        |         |             +-OrderByItem
        |         |               +-column_ref=
        |         |                 +-ColumnRef(type=INT64, column=$array_offset.off#5)
        |         +-input_scan=
        |           +-ProjectScan
        |             +-column_list=[$subquery1.array_to_filter#3]
        |             +-expr_list=
        |             | +-array_to_filter#3 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
        |             +-input_scan=
        |               +-SingleRowScan
        +-input_scan=
          +-SingleRowScan
==

SELECT * FROM UnaryScalarArg(1);
--
QueryStmt
+-output_column_list=
| +-UnaryScalarArg.arg0#1 AS arg0 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryScalarArg.arg0#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryScalarArg.arg0#1]
        +-tvf=UnaryScalarArg((INT64 arg0) -> TABLE<arg0 INT64>)
        +-signature=(literal INT64) -> TABLE<arg0 INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=1)
        +-column_index_list=[0]
        +-function_call_signature=(INT64 arg0) -> TABLE<arg0 INT64>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryScalarArg.arg0#1 AS arg0 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryScalarArg.arg0#1]
    +-input_scan=
      +-WithScan
        +-column_list=[UnaryScalarArg.arg0#1]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="$inlined_UnaryScalarArg_scalar_args"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[$inlined_UnaryScalarArg.arg0#2]
        |       +-expr_list=
        |       | +-arg0#2 := Literal(type=INT64, value=1)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[UnaryScalarArg.arg0#1]
            +-expr_list=
            | +-arg0#1 :=
            |   +-SubqueryExpr
            |     +-type=INT64
            |     +-subquery_type=SCALAR
            |     +-subquery=
            |       +-ProjectScan
            |         +-column_list=[$inlined_UnaryScalarArg.arg0#3]
            |         +-input_scan=
            |           +-WithRefScan(column_list=[$inlined_UnaryScalarArg.arg0#3], with_query_name="$inlined_UnaryScalarArg_scalar_args")
            +-input_scan=
              +-SingleRowScan
==

SELECT * FROM UnaryScalarArg(1) CROSS JOIN UnaryScalarArg(2);
--
QueryStmt
+-output_column_list=
| +-UnaryScalarArg.arg0#1 AS arg0 [INT64]
| +-UnaryScalarArg.arg0#2 AS arg0 [INT64]
+-query=
  +-ProjectScan
    +-column_list=UnaryScalarArg.[arg0#1, arg0#2]
    +-input_scan=
      +-JoinScan
        +-column_list=UnaryScalarArg.[arg0#1, arg0#2]
        +-left_scan=
        | +-TVFScan
        |   +-column_list=[UnaryScalarArg.arg0#1]
        |   +-tvf=UnaryScalarArg((INT64 arg0) -> TABLE<arg0 INT64>)
        |   +-signature=(literal INT64) -> TABLE<arg0 INT64>
        |   +-argument_list=
        |   | +-FunctionArgument
        |   |   +-expr=
        |   |     +-Literal(type=INT64, value=1)
        |   +-column_index_list=[0]
        |   +-function_call_signature=(INT64 arg0) -> TABLE<arg0 INT64>
        +-right_scan=
          +-TVFScan
            +-column_list=[UnaryScalarArg.arg0#2]
            +-tvf=UnaryScalarArg((INT64 arg0) -> TABLE<arg0 INT64>)
            +-signature=(literal INT64) -> TABLE<arg0 INT64>
            +-argument_list=
            | +-FunctionArgument
            |   +-expr=
            |     +-Literal(type=INT64, value=2)
            +-column_index_list=[0]
            +-function_call_signature=(INT64 arg0) -> TABLE<arg0 INT64>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryScalarArg.arg0#1 AS arg0 [INT64]
| +-UnaryScalarArg.arg0#2 AS arg0 [INT64]
+-query=
  +-ProjectScan
    +-column_list=UnaryScalarArg.[arg0#1, arg0#2]
    +-input_scan=
      +-JoinScan
        +-column_list=UnaryScalarArg.[arg0#1, arg0#2]
        +-left_scan=
        | +-WithScan
        |   +-column_list=[UnaryScalarArg.arg0#1]
        |   +-with_entry_list=
        |   | +-WithEntry
        |   |   +-with_query_name="$inlined_UnaryScalarArg_scalar_args"
        |   |   +-with_subquery=
        |   |     +-ProjectScan
        |   |       +-column_list=[$inlined_UnaryScalarArg.arg0#3]
        |   |       +-expr_list=
        |   |       | +-arg0#3 := Literal(type=INT64, value=1)
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-query=
        |     +-ProjectScan
        |       +-column_list=[UnaryScalarArg.arg0#1]
        |       +-expr_list=
        |       | +-arg0#1 :=
        |       |   +-SubqueryExpr
        |       |     +-type=INT64
        |       |     +-subquery_type=SCALAR
        |       |     +-subquery=
        |       |       +-ProjectScan
        |       |         +-column_list=[$inlined_UnaryScalarArg.arg0#4]
        |       |         +-input_scan=
        |       |           +-WithRefScan(column_list=[$inlined_UnaryScalarArg.arg0#4], with_query_name="$inlined_UnaryScalarArg_scalar_args")
        |       +-input_scan=
        |         +-SingleRowScan
        +-right_scan=
          +-WithScan
            +-column_list=[UnaryScalarArg.arg0#2]
            +-with_entry_list=
            | +-WithEntry
            |   +-with_query_name="$inlined_UnaryScalarArg_scalar_args"
            |   +-with_subquery=
            |     +-ProjectScan
            |       +-column_list=[$inlined_UnaryScalarArg.arg0#5]
            |       +-expr_list=
            |       | +-arg0#5 := Literal(type=INT64, value=2)
            |       +-input_scan=
            |         +-SingleRowScan
            +-query=
              +-ProjectScan
                +-column_list=[UnaryScalarArg.arg0#2]
                +-expr_list=
                | +-arg0#2 :=
                |   +-SubqueryExpr
                |     +-type=INT64
                |     +-subquery_type=SCALAR
                |     +-subquery=
                |       +-ProjectScan
                |         +-column_list=[$inlined_UnaryScalarArg.arg0#6]
                |         +-input_scan=
                |           +-WithRefScan(column_list=[$inlined_UnaryScalarArg.arg0#6], with_query_name="$inlined_UnaryScalarArg_scalar_args")
                +-input_scan=
                  +-SingleRowScan
==

SELECT * FROM UnaryScalarArgMultipleReferences(CAST(100 * rand() AS INT64));
--
QueryStmt
+-output_column_list=
| +-UnaryScalarArgMultipleReferences.ret0#1 AS ret0 [INT64]
| +-UnaryScalarArgMultipleReferences.ret1#2 AS ret1 [INT64]
+-query=
  +-ProjectScan
    +-column_list=UnaryScalarArgMultipleReferences.[ret0#1, ret1#2]
    +-input_scan=
      +-TVFScan
        +-column_list=UnaryScalarArgMultipleReferences.[ret0#1, ret1#2]
        +-tvf=UnaryScalarArgMultipleReferences((INT64 arg0) -> TABLE<ret0 INT64, ret1 INT64>)
        +-signature=(INT64) -> TABLE<ret0 INT64, ret1 INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Cast(DOUBLE -> INT64)
        |       +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
        |         +-Literal(type=DOUBLE, value=100)
        |         +-FunctionCall(ZetaSQL:rand() -> DOUBLE)
        +-column_index_list=[0, 1]
        +-function_call_signature=(INT64 arg0) -> TABLE<ret0 INT64, ret1 INT64>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryScalarArgMultipleReferences.ret0#1 AS ret0 [INT64]
| +-UnaryScalarArgMultipleReferences.ret1#2 AS ret1 [INT64]
+-query=
  +-ProjectScan
    +-column_list=UnaryScalarArgMultipleReferences.[ret0#1, ret1#2]
    +-input_scan=
      +-WithScan
        +-column_list=UnaryScalarArgMultipleReferences.[ret0#1, ret1#2]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="$inlined_UnaryScalarArgMultipleReferences_scalar_args"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[$inlined_UnaryScalarArgMultipleReferences.arg0#3]
        |       +-expr_list=
        |       | +-arg0#3 :=
        |       |   +-Cast(DOUBLE -> INT64)
        |       |     +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
        |       |       +-Literal(type=DOUBLE, value=100)
        |       |       +-FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=UnaryScalarArgMultipleReferences.[ret0#1, ret1#2]
            +-expr_list=
            | +-ret0#1 :=
            | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            | |   +-SubqueryExpr
            | |   | +-type=INT64
            | |   | +-subquery_type=SCALAR
            | |   | +-subquery=
            | |   |   +-ProjectScan
            | |   |     +-column_list=[$inlined_UnaryScalarArgMultipleReferences.arg0#4]
            | |   |     +-input_scan=
            | |   |       +-WithRefScan(column_list=[$inlined_UnaryScalarArgMultipleReferences.arg0#4], with_query_name="$inlined_UnaryScalarArgMultipleReferences_scalar_args")
            | |   +-SubqueryExpr
            | |     +-type=INT64
            | |     +-subquery_type=SCALAR
            | |     +-subquery=
            | |       +-ProjectScan
            | |         +-column_list=[$inlined_UnaryScalarArgMultipleReferences.arg0#5]
            | |         +-input_scan=
            | |           +-WithRefScan(column_list=[$inlined_UnaryScalarArgMultipleReferences.arg0#5], with_query_name="$inlined_UnaryScalarArgMultipleReferences_scalar_args")
            | +-ret1#2 :=
            |   +-SubqueryExpr
            |     +-type=INT64
            |     +-subquery_type=SCALAR
            |     +-subquery=
            |       +-ProjectScan
            |         +-column_list=[$inlined_UnaryScalarArgMultipleReferences.arg0#6]
            |         +-input_scan=
            |           +-WithRefScan(column_list=[$inlined_UnaryScalarArgMultipleReferences.arg0#6], with_query_name="$inlined_UnaryScalarArgMultipleReferences_scalar_args")
            +-input_scan=
              +-SingleRowScan
==

SELECT * FROM BinaryScalarArg(1, 2);
--
QueryStmt
+-output_column_list=
| +-BinaryScalarArg.arg0#1 AS arg0 [INT64]
| +-BinaryScalarArg.arg1#2 AS arg1 [INT64]
| +-BinaryScalarArg.ret2#3 AS ret2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=BinaryScalarArg.[arg0#1, arg1#2, ret2#3]
    +-input_scan=
      +-TVFScan
        +-column_list=BinaryScalarArg.[arg0#1, arg1#2, ret2#3]
        +-tvf=BinaryScalarArg((INT64 arg0, INT64 arg1) -> TABLE<arg0 INT64, arg1 INT64, ret2 INT64>)
        +-signature=(literal INT64, literal INT64) -> TABLE<arg0 INT64, arg1 INT64, ret2 INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=1)
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=2)
        +-column_index_list=[0, 1, 2]
        +-function_call_signature=(INT64 arg0, INT64 arg1) -> TABLE<arg0 INT64, arg1 INT64, ret2 INT64>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-BinaryScalarArg.arg0#1 AS arg0 [INT64]
| +-BinaryScalarArg.arg1#2 AS arg1 [INT64]
| +-BinaryScalarArg.ret2#3 AS ret2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=BinaryScalarArg.[arg0#1, arg1#2, ret2#3]
    +-input_scan=
      +-WithScan
        +-column_list=BinaryScalarArg.[arg0#1, arg1#2, ret2#3]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="$inlined_BinaryScalarArg_scalar_args"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$inlined_BinaryScalarArg.[arg0#4, arg1#5]
        |       +-expr_list=
        |       | +-arg0#4 := Literal(type=INT64, value=1)
        |       | +-arg1#5 := Literal(type=INT64, value=2)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=BinaryScalarArg.[arg0#1, arg1#2, ret2#3]
            +-expr_list=
            | +-arg0#1 :=
            | | +-SubqueryExpr
            | |   +-type=INT64
            | |   +-subquery_type=SCALAR
            | |   +-subquery=
            | |     +-ProjectScan
            | |       +-column_list=[$inlined_BinaryScalarArg.arg0#6]
            | |       +-input_scan=
            | |         +-WithRefScan(column_list=$inlined_BinaryScalarArg.[arg0#6, arg1#7], with_query_name="$inlined_BinaryScalarArg_scalar_args")
            | +-arg1#2 :=
            | | +-SubqueryExpr
            | |   +-type=INT64
            | |   +-subquery_type=SCALAR
            | |   +-subquery=
            | |     +-ProjectScan
            | |       +-column_list=[$inlined_BinaryScalarArg.arg1#9]
            | |       +-input_scan=
            | |         +-WithRefScan(column_list=$inlined_BinaryScalarArg.[arg0#8, arg1#9], with_query_name="$inlined_BinaryScalarArg_scalar_args")
            | +-ret2#3 :=
            |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |     +-SubqueryExpr
            |     | +-type=INT64
            |     | +-subquery_type=SCALAR
            |     | +-subquery=
            |     |   +-ProjectScan
            |     |     +-column_list=[$inlined_BinaryScalarArg.arg0#10]
            |     |     +-input_scan=
            |     |       +-WithRefScan(column_list=$inlined_BinaryScalarArg.[arg0#10, arg1#11], with_query_name="$inlined_BinaryScalarArg_scalar_args")
            |     +-SubqueryExpr
            |       +-type=INT64
            |       +-subquery_type=SCALAR
            |       +-subquery=
            |         +-ProjectScan
            |           +-column_list=[$inlined_BinaryScalarArg.arg1#13]
            |           +-input_scan=
            |             +-WithRefScan(column_list=$inlined_BinaryScalarArg.[arg0#12, arg1#13], with_query_name="$inlined_BinaryScalarArg_scalar_args")
            +-input_scan=
              +-SingleRowScan
==

SELECT * FROM BinaryScalarArg(1, 2) CROSS JOIN BinaryScalarArg(3, 4);
--
QueryStmt
+-output_column_list=
| +-BinaryScalarArg.arg0#1 AS arg0 [INT64]
| +-BinaryScalarArg.arg1#2 AS arg1 [INT64]
| +-BinaryScalarArg.ret2#3 AS ret2 [INT64]
| +-BinaryScalarArg.arg0#4 AS arg0 [INT64]
| +-BinaryScalarArg.arg1#5 AS arg1 [INT64]
| +-BinaryScalarArg.ret2#6 AS ret2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=BinaryScalarArg.[arg0#1, arg1#2, ret2#3, arg0#4, arg1#5, ret2#6]
    +-input_scan=
      +-JoinScan
        +-column_list=BinaryScalarArg.[arg0#1, arg1#2, ret2#3, arg0#4, arg1#5, ret2#6]
        +-left_scan=
        | +-TVFScan
        |   +-column_list=BinaryScalarArg.[arg0#1, arg1#2, ret2#3]
        |   +-tvf=BinaryScalarArg((INT64 arg0, INT64 arg1) -> TABLE<arg0 INT64, arg1 INT64, ret2 INT64>)
        |   +-signature=(literal INT64, literal INT64) -> TABLE<arg0 INT64, arg1 INT64, ret2 INT64>
        |   +-argument_list=
        |   | +-FunctionArgument
        |   | | +-expr=
        |   | |   +-Literal(type=INT64, value=1)
        |   | +-FunctionArgument
        |   |   +-expr=
        |   |     +-Literal(type=INT64, value=2)
        |   +-column_index_list=[0, 1, 2]
        |   +-function_call_signature=(INT64 arg0, INT64 arg1) -> TABLE<arg0 INT64, arg1 INT64, ret2 INT64>
        +-right_scan=
          +-TVFScan
            +-column_list=BinaryScalarArg.[arg0#4, arg1#5, ret2#6]
            +-tvf=BinaryScalarArg((INT64 arg0, INT64 arg1) -> TABLE<arg0 INT64, arg1 INT64, ret2 INT64>)
            +-signature=(literal INT64, literal INT64) -> TABLE<arg0 INT64, arg1 INT64, ret2 INT64>
            +-argument_list=
            | +-FunctionArgument
            | | +-expr=
            | |   +-Literal(type=INT64, value=3)
            | +-FunctionArgument
            |   +-expr=
            |     +-Literal(type=INT64, value=4)
            +-column_index_list=[0, 1, 2]
            +-function_call_signature=(INT64 arg0, INT64 arg1) -> TABLE<arg0 INT64, arg1 INT64, ret2 INT64>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-BinaryScalarArg.arg0#1 AS arg0 [INT64]
| +-BinaryScalarArg.arg1#2 AS arg1 [INT64]
| +-BinaryScalarArg.ret2#3 AS ret2 [INT64]
| +-BinaryScalarArg.arg0#4 AS arg0 [INT64]
| +-BinaryScalarArg.arg1#5 AS arg1 [INT64]
| +-BinaryScalarArg.ret2#6 AS ret2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=BinaryScalarArg.[arg0#1, arg1#2, ret2#3, arg0#4, arg1#5, ret2#6]
    +-input_scan=
      +-JoinScan
        +-column_list=BinaryScalarArg.[arg0#1, arg1#2, ret2#3, arg0#4, arg1#5, ret2#6]
        +-left_scan=
        | +-WithScan
        |   +-column_list=BinaryScalarArg.[arg0#1, arg1#2, ret2#3]
        |   +-with_entry_list=
        |   | +-WithEntry
        |   |   +-with_query_name="$inlined_BinaryScalarArg_scalar_args"
        |   |   +-with_subquery=
        |   |     +-ProjectScan
        |   |       +-column_list=$inlined_BinaryScalarArg.[arg0#7, arg1#8]
        |   |       +-expr_list=
        |   |       | +-arg0#7 := Literal(type=INT64, value=1)
        |   |       | +-arg1#8 := Literal(type=INT64, value=2)
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-query=
        |     +-ProjectScan
        |       +-column_list=BinaryScalarArg.[arg0#1, arg1#2, ret2#3]
        |       +-expr_list=
        |       | +-arg0#1 :=
        |       | | +-SubqueryExpr
        |       | |   +-type=INT64
        |       | |   +-subquery_type=SCALAR
        |       | |   +-subquery=
        |       | |     +-ProjectScan
        |       | |       +-column_list=[$inlined_BinaryScalarArg.arg0#9]
        |       | |       +-input_scan=
        |       | |         +-WithRefScan(column_list=$inlined_BinaryScalarArg.[arg0#9, arg1#10], with_query_name="$inlined_BinaryScalarArg_scalar_args")
        |       | +-arg1#2 :=
        |       | | +-SubqueryExpr
        |       | |   +-type=INT64
        |       | |   +-subquery_type=SCALAR
        |       | |   +-subquery=
        |       | |     +-ProjectScan
        |       | |       +-column_list=[$inlined_BinaryScalarArg.arg1#12]
        |       | |       +-input_scan=
        |       | |         +-WithRefScan(column_list=$inlined_BinaryScalarArg.[arg0#11, arg1#12], with_query_name="$inlined_BinaryScalarArg_scalar_args")
        |       | +-ret2#3 :=
        |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       |     +-SubqueryExpr
        |       |     | +-type=INT64
        |       |     | +-subquery_type=SCALAR
        |       |     | +-subquery=
        |       |     |   +-ProjectScan
        |       |     |     +-column_list=[$inlined_BinaryScalarArg.arg0#13]
        |       |     |     +-input_scan=
        |       |     |       +-WithRefScan(column_list=$inlined_BinaryScalarArg.[arg0#13, arg1#14], with_query_name="$inlined_BinaryScalarArg_scalar_args")
        |       |     +-SubqueryExpr
        |       |       +-type=INT64
        |       |       +-subquery_type=SCALAR
        |       |       +-subquery=
        |       |         +-ProjectScan
        |       |           +-column_list=[$inlined_BinaryScalarArg.arg1#16]
        |       |           +-input_scan=
        |       |             +-WithRefScan(column_list=$inlined_BinaryScalarArg.[arg0#15, arg1#16], with_query_name="$inlined_BinaryScalarArg_scalar_args")
        |       +-input_scan=
        |         +-SingleRowScan
        +-right_scan=
          +-WithScan
            +-column_list=BinaryScalarArg.[arg0#4, arg1#5, ret2#6]
            +-with_entry_list=
            | +-WithEntry
            |   +-with_query_name="$inlined_BinaryScalarArg_scalar_args"
            |   +-with_subquery=
            |     +-ProjectScan
            |       +-column_list=$inlined_BinaryScalarArg.[arg0#17, arg1#18]
            |       +-expr_list=
            |       | +-arg0#17 := Literal(type=INT64, value=3)
            |       | +-arg1#18 := Literal(type=INT64, value=4)
            |       +-input_scan=
            |         +-SingleRowScan
            +-query=
              +-ProjectScan
                +-column_list=BinaryScalarArg.[arg0#4, arg1#5, ret2#6]
                +-expr_list=
                | +-arg0#4 :=
                | | +-SubqueryExpr
                | |   +-type=INT64
                | |   +-subquery_type=SCALAR
                | |   +-subquery=
                | |     +-ProjectScan
                | |       +-column_list=[$inlined_BinaryScalarArg.arg0#19]
                | |       +-input_scan=
                | |         +-WithRefScan(column_list=$inlined_BinaryScalarArg.[arg0#19, arg1#20], with_query_name="$inlined_BinaryScalarArg_scalar_args")
                | +-arg1#5 :=
                | | +-SubqueryExpr
                | |   +-type=INT64
                | |   +-subquery_type=SCALAR
                | |   +-subquery=
                | |     +-ProjectScan
                | |       +-column_list=[$inlined_BinaryScalarArg.arg1#22]
                | |       +-input_scan=
                | |         +-WithRefScan(column_list=$inlined_BinaryScalarArg.[arg0#21, arg1#22], with_query_name="$inlined_BinaryScalarArg_scalar_args")
                | +-ret2#6 :=
                |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                |     +-SubqueryExpr
                |     | +-type=INT64
                |     | +-subquery_type=SCALAR
                |     | +-subquery=
                |     |   +-ProjectScan
                |     |     +-column_list=[$inlined_BinaryScalarArg.arg0#23]
                |     |     +-input_scan=
                |     |       +-WithRefScan(column_list=$inlined_BinaryScalarArg.[arg0#23, arg1#24], with_query_name="$inlined_BinaryScalarArg_scalar_args")
                |     +-SubqueryExpr
                |       +-type=INT64
                |       +-subquery_type=SCALAR
                |       +-subquery=
                |         +-ProjectScan
                |           +-column_list=[$inlined_BinaryScalarArg.arg1#26]
                |           +-input_scan=
                |             +-WithRefScan(column_list=$inlined_BinaryScalarArg.[arg0#25, arg1#26], with_query_name="$inlined_BinaryScalarArg_scalar_args")
                +-input_scan=
                  +-SingleRowScan
==

SELECT * FROM UnaryScalarArgSubqueryReference(1);
--
QueryStmt
+-output_column_list=
| +-UnaryScalarArgSubqueryReference.ret0#1 AS ret0 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryScalarArgSubqueryReference.ret0#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryScalarArgSubqueryReference.ret0#1]
        +-tvf=UnaryScalarArgSubqueryReference((INT64 arg0) -> TABLE<ret0 INT64>)
        +-signature=(literal INT64) -> TABLE<ret0 INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=1)
        +-column_index_list=[0]
        +-function_call_signature=(INT64 arg0) -> TABLE<ret0 INT64>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryScalarArgSubqueryReference.ret0#1 AS ret0 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryScalarArgSubqueryReference.ret0#1]
    +-input_scan=
      +-WithScan
        +-column_list=[UnaryScalarArgSubqueryReference.ret0#1]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="$inlined_UnaryScalarArgSubqueryReference_scalar_args"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[$inlined_UnaryScalarArgSubqueryReference.arg0#3]
        |       +-expr_list=
        |       | +-arg0#3 := Literal(type=INT64, value=1)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[UnaryScalarArgSubqueryReference.ret0#1]
            +-expr_list=
            | +-ret0#1 :=
            |   +-SubqueryExpr
            |     +-type=INT64
            |     +-subquery_type=SCALAR
            |     +-subquery=
            |       +-ProjectScan
            |         +-column_list=[$expr_subquery.arg0#2]
            |         +-expr_list=
            |         | +-arg0#2 :=
            |         |   +-SubqueryExpr
            |         |     +-type=INT64
            |         |     +-subquery_type=SCALAR
            |         |     +-subquery=
            |         |       +-ProjectScan
            |         |         +-column_list=[$inlined_UnaryScalarArgSubqueryReference.arg0#4]
            |         |         +-input_scan=
            |         |           +-WithRefScan(column_list=[$inlined_UnaryScalarArgSubqueryReference.arg0#4], with_query_name="$inlined_UnaryScalarArgSubqueryReference_scalar_args")
            |         +-input_scan=
            |           +-SingleRowScan
            +-input_scan=
              +-SingleRowScan
==

SELECT * FROM UnaryScalarArgSubqueryWithReference(1);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-UnaryScalarArgSubqueryWithReference.ret0#1 AS ret0 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryScalarArgSubqueryWithReference.ret0#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryScalarArgSubqueryWithReference.ret0#1]
        +-tvf=UnaryScalarArgSubqueryWithReference((INT64 arg0) -> TABLE<ret0 INT64>)
        +-signature=(literal INT64) -> TABLE<ret0 INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=1)
        +-column_index_list=[0]
        +-function_call_signature=(INT64 arg0) -> TABLE<ret0 INT64>

Rewrite ERROR: generic::unimplemented: SQL defined functions that contain argument references inside embedded WITH clauses are not implemented.
==

SELECT (SELECT * FROM UnaryScalarArg(a)) FROM (SELECT 1 AS a);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$subquery1.a#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[UnaryScalarArg.arg0#2]
    |         +-input_scan=
    |           +-TVFScan
    |             +-column_list=[UnaryScalarArg.arg0#2]
    |             +-tvf=UnaryScalarArg((INT64 arg0) -> TABLE<arg0 INT64>)
    |             +-signature=(INT64) -> TABLE<arg0 INT64>
    |             +-argument_list=
    |             | +-FunctionArgument
    |             |   +-expr=
    |             |     +-ColumnRef(type=INT64, column=$subquery1.a#1, is_correlated=TRUE)
    |             +-column_index_list=[0]
    |             +-function_call_signature=(INT64 arg0) -> TABLE<arg0 INT64>
    +-input_scan=
      +-ProjectScan
        +-column_list=[$subquery1.a#1]
        +-expr_list=
        | +-a#1 := Literal(type=INT64, value=1)
        +-input_scan=
          +-SingleRowScan

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #1 ('arg0') references column 'a'.
==

SELECT * FROM (SELECT 1 AS a) CROSS JOIN UNNEST(ARRAY(SELECT AS STRUCT * FROM UnaryScalarArg(a)));
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$subquery1.a#1 AS a [INT64]
| +-$query.arg0#5 AS arg0 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$subquery1.a#1, $query.arg0#5]
    +-expr_list=
    | +-arg0#5 :=
    |   +-GetStructField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<arg0 INT64>, column=$array.$unnest1#4)
    |     +-field_idx=0
    +-input_scan=
      +-ArrayScan
        +-column_list=[$subquery1.a#1, $array.$unnest1#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$subquery1.a#1]
        |   +-expr_list=
        |   | +-a#1 := Literal(type=INT64, value=1)
        |   +-input_scan=
        |     +-SingleRowScan
        +-array_expr_list=
        | +-SubqueryExpr
        |   +-type=ARRAY<STRUCT<arg0 INT64>>
        |   +-subquery_type=ARRAY
        |   +-parameter_list=
        |   | +-ColumnRef(type=INT64, column=$subquery1.a#1)
        |   +-subquery=
        |     +-ProjectScan
        |       +-column_list=[$make_struct.$struct#3]
        |       +-expr_list=
        |       | +-$struct#3 :=
        |       |   +-MakeStruct
        |       |     +-type=STRUCT<arg0 INT64>
        |       |     +-field_list=
        |       |       +-ColumnRef(type=INT64, column=UnaryScalarArg.arg0#2)
        |       +-input_scan=
        |         +-ProjectScan
        |           +-column_list=[UnaryScalarArg.arg0#2]
        |           +-input_scan=
        |             +-TVFScan
        |               +-column_list=[UnaryScalarArg.arg0#2]
        |               +-tvf=UnaryScalarArg((INT64 arg0) -> TABLE<arg0 INT64>)
        |               +-signature=(INT64) -> TABLE<arg0 INT64>
        |               +-argument_list=
        |               | +-FunctionArgument
        |               |   +-expr=
        |               |     +-ColumnRef(type=INT64, column=$subquery1.a#1, is_correlated=TRUE)
        |               +-column_index_list=[0]
        |               +-function_call_signature=(INT64 arg0) -> TABLE<arg0 INT64>
        +-element_column_list=[$array.$unnest1#4]

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #1 ('arg0') references column 'a'.
==

SELECT * FROM UnaryTableArg((SELECT 1 AS a));
--
QueryStmt
+-output_column_list=
| +-UnaryTableArg.a#2 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryTableArg.a#2]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryTableArg.a#2]
        +-tvf=UnaryTableArg((TABLE<a INT64> arg0) -> TABLE<a INT64>)
        +-signature=(TABLE<a INT64>) -> TABLE<a INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.a#1]
        |   |   +-expr_list=
        |   |   | +-a#1 := Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.a#1]
        +-column_index_list=[0]
        +-function_call_signature=(TABLE<a INT64> arg0) -> TABLE<a INT64>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryTableArg.a#2 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryTableArg.a#2]
    +-input_scan=
      +-WithScan
        +-column_list=[UnaryTableArg.a#2]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[$subquery1.a#1]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[UnaryTableArg.a#2]
            +-input_scan=
              +-WithRefScan(column_list=[UnaryTableArg.a#2], with_query_name="arg0")
==

SELECT * FROM ScalarParamUsedAsTVFArgument(1);

--
QueryStmt
+-output_column_list=
| +-ScalarParamUsedAsTVFArgument.arg0#1 AS arg0 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[ScalarParamUsedAsTVFArgument.arg0#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[ScalarParamUsedAsTVFArgument.arg0#1]
        +-tvf=ScalarParamUsedAsTVFArgument((INT64 arg0) -> TABLE<arg0 INT64>)
        +-signature=(literal INT64) -> TABLE<arg0 INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=1)
        +-column_index_list=[0]
        +-function_call_signature=(INT64 arg0) -> TABLE<arg0 INT64>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-ScalarParamUsedAsTVFArgument.arg0#1 AS arg0 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[ScalarParamUsedAsTVFArgument.arg0#1]
    +-input_scan=
      +-WithScan
        +-column_list=[ScalarParamUsedAsTVFArgument.arg0#1]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="$inlined_ScalarParamUsedAsTVFArgument_scalar_args"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[$inlined_ScalarParamUsedAsTVFArgument.arg0#2]
        |       +-expr_list=
        |       | +-arg0#2 := Literal(type=INT64, value=1)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[ScalarParamUsedAsTVFArgument.arg0#1]
            +-input_scan=
              +-WithScan
                +-column_list=[ScalarParamUsedAsTVFArgument.arg0#1]
                +-with_entry_list=
                | +-WithEntry
                |   +-with_query_name="$inlined_UnaryScalarArg_scalar_args"
                |   +-with_subquery=
                |     +-ProjectScan
                |       +-column_list=[$inlined_UnaryScalarArg.arg0#4]
                |       +-expr_list=
                |       | +-arg0#4 :=
                |       |   +-SubqueryExpr
                |       |     +-type=INT64
                |       |     +-subquery_type=SCALAR
                |       |     +-subquery=
                |       |       +-ProjectScan
                |       |         +-column_list=[$inlined_ScalarParamUsedAsTVFArgument.arg0#3]
                |       |         +-input_scan=
                |       |           +-WithRefScan(column_list=[$inlined_ScalarParamUsedAsTVFArgument.arg0#3], with_query_name="$inlined_ScalarParamUsedAsTVFArgument_scalar_args")
                |       +-input_scan=
                |         +-SingleRowScan
                +-query=
                  +-ProjectScan
                    +-column_list=[ScalarParamUsedAsTVFArgument.arg0#1]
                    +-expr_list=
                    | +-arg0#1 :=
                    |   +-SubqueryExpr
                    |     +-type=INT64
                    |     +-subquery_type=SCALAR
                    |     +-subquery=
                    |       +-ProjectScan
                    |         +-column_list=[$inlined_UnaryScalarArg.arg0#5]
                    |         +-input_scan=
                    |           +-WithRefScan(column_list=[$inlined_UnaryScalarArg.arg0#5], with_query_name="$inlined_UnaryScalarArg_scalar_args")
                    +-input_scan=
                      +-SingleRowScan
==

SELECT WITH(a AS 1, (SELECT * FROM ScalarParamUsedAsTVFArgument(a)));

--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-WithExpr
    |     +-type=INT64
    |     +-assignment_list=
    |     | +-a#1 := Literal(type=INT64, value=1)
    |     +-expr=
    |       +-SubqueryExpr
    |         +-type=INT64
    |         +-subquery_type=SCALAR
    |         +-parameter_list=
    |         | +-ColumnRef(type=INT64, column=$with_expr.a#1)
    |         +-subquery=
    |           +-ProjectScan
    |             +-column_list=[ScalarParamUsedAsTVFArgument.arg0#2]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=[ScalarParamUsedAsTVFArgument.arg0#2]
    |                 +-tvf=ScalarParamUsedAsTVFArgument((INT64 arg0) -> TABLE<arg0 INT64>)
    |                 +-signature=(INT64) -> TABLE<arg0 INT64>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-ColumnRef(type=INT64, column=$with_expr.a#1, is_correlated=TRUE)
    |                 +-column_index_list=[0]
    |                 +-function_call_signature=(INT64 arg0) -> TABLE<arg0 INT64>
    +-input_scan=
      +-SingleRowScan

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #1 ('arg0') references column 'a'.

==

# Skip unparser because of b/224585752
[no_run_sqlbuilder]
SELECT {{*|a|b}}
FROM UnaryAbTableArg{{|SelfJoin|ScannedInCTE}}(
    {{TABLE abTable|(SELECT 1 AS a, "two" AS b)}});

--
ALTERNATION GROUP: *,,TABLE abTable
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArg.a#3 AS a [INT64]
| +-UnaryAbTableArg.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArg.[a#3, b#4]
    +-input_scan=
      +-TVFScan
        +-column_list=UnaryAbTableArg.[a#3, b#4]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[0, 1]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArg.a#3 AS a [INT64]
| +-UnaryAbTableArg.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArg.[a#3, b#4]
    +-input_scan=
      +-WithScan
        +-column_list=UnaryAbTableArg.[a#3, b#4]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        +-query=
          +-ProjectScan
            +-column_list=UnaryAbTableArg.[a#3, b#4]
            +-input_scan=
              +-WithRefScan(column_list=UnaryAbTableArg.[a#3, b#4], with_query_name="arg0")
--
ALTERNATION GROUP: *,,(SELECT 1 AS a, "two" AS b)
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArg.a#3 AS a [INT64]
| +-UnaryAbTableArg.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArg.[a#3, b#4]
    +-input_scan=
      +-TVFScan
        +-column_list=UnaryAbTableArg.[a#3, b#4]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[a#1, b#2]
        |   |   +-expr_list=
        |   |   | +-a#1 := Literal(type=INT64, value=1)
        |   |   | +-b#2 := Literal(type=STRING, value="two")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[a#1, b#2]
        +-column_index_list=[0, 1]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArg.a#3 AS a [INT64]
| +-UnaryAbTableArg.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArg.[a#3, b#4]
    +-input_scan=
      +-WithScan
        +-column_list=UnaryAbTableArg.[a#3, b#4]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$subquery1.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=STRING, value="two")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=UnaryAbTableArg.[a#3, b#4]
            +-input_scan=
              +-WithRefScan(column_list=UnaryAbTableArg.[a#3, b#4], with_query_name="arg0")
--
ALTERNATION GROUP: *,SelfJoin,TABLE abTable
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgSelfJoin.a#3 AS a [INT64]
| +-UnaryAbTableArgSelfJoin.b#4 AS b [STRING]
| +-UnaryAbTableArgSelfJoin.a#5 AS a [INT64]
| +-UnaryAbTableArgSelfJoin.b#6 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArgSelfJoin.[a#3, b#4, a#5, b#6]
    +-input_scan=
      +-TVFScan
        +-column_list=UnaryAbTableArgSelfJoin.[a#3, b#4, a#5, b#6]
        +-tvf=UnaryAbTableArgSelfJoin((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING, a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING, a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[0, 1, 2, 3]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING, a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgSelfJoin.a#3 AS a [INT64]
| +-UnaryAbTableArgSelfJoin.b#4 AS b [STRING]
| +-UnaryAbTableArgSelfJoin.a#5 AS a [INT64]
| +-UnaryAbTableArgSelfJoin.b#6 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArgSelfJoin.[a#3, b#4, a#5, b#6]
    +-input_scan=
      +-WithScan
        +-column_list=UnaryAbTableArgSelfJoin.[a#3, b#4, a#5, b#6]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        +-query=
          +-ProjectScan
            +-column_list=UnaryAbTableArgSelfJoin.[a#3, b#4, a#5, b#6]
            +-input_scan=
              +-JoinScan
                +-column_list=UnaryAbTableArgSelfJoin.[a#3, b#4, a#5, b#6]
                +-left_scan=
                | +-WithRefScan(column_list=UnaryAbTableArgSelfJoin.[a#3, b#4], with_query_name="arg0")
                +-right_scan=
                  +-WithRefScan(column_list=UnaryAbTableArgSelfJoin.[a#5, b#6], with_query_name="arg0")
--
ALTERNATION GROUP: *,SelfJoin,(SELECT 1 AS a, "two" AS b)
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgSelfJoin.a#3 AS a [INT64]
| +-UnaryAbTableArgSelfJoin.b#4 AS b [STRING]
| +-UnaryAbTableArgSelfJoin.a#5 AS a [INT64]
| +-UnaryAbTableArgSelfJoin.b#6 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArgSelfJoin.[a#3, b#4, a#5, b#6]
    +-input_scan=
      +-TVFScan
        +-column_list=UnaryAbTableArgSelfJoin.[a#3, b#4, a#5, b#6]
        +-tvf=UnaryAbTableArgSelfJoin((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING, a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING, a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[a#1, b#2]
        |   |   +-expr_list=
        |   |   | +-a#1 := Literal(type=INT64, value=1)
        |   |   | +-b#2 := Literal(type=STRING, value="two")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[a#1, b#2]
        +-column_index_list=[0, 1, 2, 3]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING, a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgSelfJoin.a#3 AS a [INT64]
| +-UnaryAbTableArgSelfJoin.b#4 AS b [STRING]
| +-UnaryAbTableArgSelfJoin.a#5 AS a [INT64]
| +-UnaryAbTableArgSelfJoin.b#6 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArgSelfJoin.[a#3, b#4, a#5, b#6]
    +-input_scan=
      +-WithScan
        +-column_list=UnaryAbTableArgSelfJoin.[a#3, b#4, a#5, b#6]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$subquery1.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=STRING, value="two")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=UnaryAbTableArgSelfJoin.[a#3, b#4, a#5, b#6]
            +-input_scan=
              +-JoinScan
                +-column_list=UnaryAbTableArgSelfJoin.[a#3, b#4, a#5, b#6]
                +-left_scan=
                | +-WithRefScan(column_list=UnaryAbTableArgSelfJoin.[a#3, b#4], with_query_name="arg0")
                +-right_scan=
                  +-WithRefScan(column_list=UnaryAbTableArgSelfJoin.[a#5, b#6], with_query_name="arg0")
--
ALTERNATION GROUP: *,ScannedInCTE,TABLE abTable
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgScannedInCTE.a#3 AS a [INT64]
| +-UnaryAbTableArgScannedInCTE.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4]
    +-input_scan=
      +-TVFScan
        +-column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4]
        +-tvf=UnaryAbTableArgScannedInCTE((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[0, 1]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgScannedInCTE.a#3 AS a [INT64]
| +-UnaryAbTableArgScannedInCTE.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4]
    +-input_scan=
      +-WithScan
        +-column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        +-query=
          +-WithScan
            +-column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4]
            +-with_entry_list=
            | +-WithEntry
            |   +-with_query_name="t"
            |   +-with_subquery=
            |     +-ProjectScan
            |       +-column_list=arg0.[a#5, b#6]
            |       +-input_scan=
            |         +-WithRefScan(column_list=arg0.[a#5, b#6], with_query_name="arg0")
            +-query=
              +-ProjectScan
                +-column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4]
                +-input_scan=
                  +-WithRefScan(column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4], with_query_name="t")
--
ALTERNATION GROUP: *,ScannedInCTE,(SELECT 1 AS a, "two" AS b)
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgScannedInCTE.a#3 AS a [INT64]
| +-UnaryAbTableArgScannedInCTE.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4]
    +-input_scan=
      +-TVFScan
        +-column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4]
        +-tvf=UnaryAbTableArgScannedInCTE((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[a#1, b#2]
        |   |   +-expr_list=
        |   |   | +-a#1 := Literal(type=INT64, value=1)
        |   |   | +-b#2 := Literal(type=STRING, value="two")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[a#1, b#2]
        +-column_index_list=[0, 1]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgScannedInCTE.a#3 AS a [INT64]
| +-UnaryAbTableArgScannedInCTE.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4]
    +-input_scan=
      +-WithScan
        +-column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$subquery1.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=STRING, value="two")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-WithScan
            +-column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4]
            +-with_entry_list=
            | +-WithEntry
            |   +-with_query_name="t"
            |   +-with_subquery=
            |     +-ProjectScan
            |       +-column_list=arg0.[a#5, b#6]
            |       +-input_scan=
            |         +-WithRefScan(column_list=arg0.[a#5, b#6], with_query_name="arg0")
            +-query=
              +-ProjectScan
                +-column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4]
                +-input_scan=
                  +-WithRefScan(column_list=UnaryAbTableArgScannedInCTE.[a#3, b#4], with_query_name="t")
--
ALTERNATION GROUP: a,,TABLE abTable
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArg.a#3 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArg.a#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArg.a#3]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[0]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArg.a#3 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArg.a#3]
    +-input_scan=
      +-WithScan
        +-column_list=[UnaryAbTableArg.a#3, arg0.b#5]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        +-query=
          +-ProjectScan
            +-column_list=[UnaryAbTableArg.a#3, arg0.b#5]
            +-input_scan=
              +-WithRefScan(column_list=[UnaryAbTableArg.a#3, arg0.b#5], with_query_name="arg0")
--
ALTERNATION GROUP: a,,(SELECT 1 AS a, "two" AS b)
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArg.a#3 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArg.a#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArg.a#3]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[a#1, b#2]
        |   |   +-expr_list=
        |   |   | +-a#1 := Literal(type=INT64, value=1)
        |   |   | +-b#2 := Literal(type=STRING, value="two")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[a#1, b#2]
        +-column_index_list=[0]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArg.a#3 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArg.a#3]
    +-input_scan=
      +-WithScan
        +-column_list=[UnaryAbTableArg.a#3, arg0.b#5]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$subquery1.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=STRING, value="two")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[UnaryAbTableArg.a#3, arg0.b#5]
            +-input_scan=
              +-WithRefScan(column_list=[UnaryAbTableArg.a#3, arg0.b#5], with_query_name="arg0")
--
ALTERNATION GROUPS:
    a,SelfJoin,TABLE abTable
    a,SelfJoin,(SELECT 1 AS a, "two" AS b)
--
ERROR: Column name a is ambiguous [at 1:8]
SELECT a
       ^
--
ALTERNATION GROUP: a,ScannedInCTE,TABLE abTable
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgScannedInCTE.a#3 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArgScannedInCTE.a#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArgScannedInCTE.a#3]
        +-tvf=UnaryAbTableArgScannedInCTE((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[0]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgScannedInCTE.a#3 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArgScannedInCTE.a#3]
    +-input_scan=
      +-WithScan
        +-column_list=[UnaryAbTableArgScannedInCTE.a#3, t.b#7]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        +-query=
          +-WithScan
            +-column_list=[UnaryAbTableArgScannedInCTE.a#3, t.b#7]
            +-with_entry_list=
            | +-WithEntry
            |   +-with_query_name="t"
            |   +-with_subquery=
            |     +-ProjectScan
            |       +-column_list=arg0.[a#5, b#6]
            |       +-input_scan=
            |         +-WithRefScan(column_list=arg0.[a#5, b#6], with_query_name="arg0")
            +-query=
              +-ProjectScan
                +-column_list=[UnaryAbTableArgScannedInCTE.a#3, t.b#7]
                +-input_scan=
                  +-WithRefScan(column_list=[UnaryAbTableArgScannedInCTE.a#3, t.b#7], with_query_name="t")
--
ALTERNATION GROUP: a,ScannedInCTE,(SELECT 1 AS a, "two" AS b)
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgScannedInCTE.a#3 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArgScannedInCTE.a#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArgScannedInCTE.a#3]
        +-tvf=UnaryAbTableArgScannedInCTE((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[a#1, b#2]
        |   |   +-expr_list=
        |   |   | +-a#1 := Literal(type=INT64, value=1)
        |   |   | +-b#2 := Literal(type=STRING, value="two")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[a#1, b#2]
        +-column_index_list=[0]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgScannedInCTE.a#3 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArgScannedInCTE.a#3]
    +-input_scan=
      +-WithScan
        +-column_list=[UnaryAbTableArgScannedInCTE.a#3, t.b#7]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$subquery1.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=STRING, value="two")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-WithScan
            +-column_list=[UnaryAbTableArgScannedInCTE.a#3, t.b#7]
            +-with_entry_list=
            | +-WithEntry
            |   +-with_query_name="t"
            |   +-with_subquery=
            |     +-ProjectScan
            |       +-column_list=arg0.[a#5, b#6]
            |       +-input_scan=
            |         +-WithRefScan(column_list=arg0.[a#5, b#6], with_query_name="arg0")
            +-query=
              +-ProjectScan
                +-column_list=[UnaryAbTableArgScannedInCTE.a#3, t.b#7]
                +-input_scan=
                  +-WithRefScan(column_list=[UnaryAbTableArgScannedInCTE.a#3, t.b#7], with_query_name="t")
--
ALTERNATION GROUP: b,,TABLE abTable
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArg.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArg.b#4]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArg.b#4]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[1]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArg.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArg.b#4]
    +-input_scan=
      +-WithScan
        +-column_list=[arg0.a#5, UnaryAbTableArg.b#4]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        +-query=
          +-ProjectScan
            +-column_list=[arg0.a#5, UnaryAbTableArg.b#4]
            +-input_scan=
              +-WithRefScan(column_list=[arg0.a#5, UnaryAbTableArg.b#4], with_query_name="arg0")
--
ALTERNATION GROUP: b,,(SELECT 1 AS a, "two" AS b)
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArg.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArg.b#4]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArg.b#4]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[a#1, b#2]
        |   |   +-expr_list=
        |   |   | +-a#1 := Literal(type=INT64, value=1)
        |   |   | +-b#2 := Literal(type=STRING, value="two")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[a#1, b#2]
        +-column_index_list=[1]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArg.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArg.b#4]
    +-input_scan=
      +-WithScan
        +-column_list=[arg0.a#5, UnaryAbTableArg.b#4]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$subquery1.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=STRING, value="two")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[arg0.a#5, UnaryAbTableArg.b#4]
            +-input_scan=
              +-WithRefScan(column_list=[arg0.a#5, UnaryAbTableArg.b#4], with_query_name="arg0")
--
ALTERNATION GROUPS:
    b,SelfJoin,TABLE abTable
    b,SelfJoin,(SELECT 1 AS a, "two" AS b)
--
ERROR: Column name b is ambiguous [at 1:8]
SELECT b
       ^
--
ALTERNATION GROUP: b,ScannedInCTE,TABLE abTable
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgScannedInCTE.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArgScannedInCTE.b#4]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArgScannedInCTE.b#4]
        +-tvf=UnaryAbTableArgScannedInCTE((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[1]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgScannedInCTE.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArgScannedInCTE.b#4]
    +-input_scan=
      +-WithScan
        +-column_list=[t.a#7, UnaryAbTableArgScannedInCTE.b#4]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        +-query=
          +-WithScan
            +-column_list=[t.a#7, UnaryAbTableArgScannedInCTE.b#4]
            +-with_entry_list=
            | +-WithEntry
            |   +-with_query_name="t"
            |   +-with_subquery=
            |     +-ProjectScan
            |       +-column_list=arg0.[a#5, b#6]
            |       +-input_scan=
            |         +-WithRefScan(column_list=arg0.[a#5, b#6], with_query_name="arg0")
            +-query=
              +-ProjectScan
                +-column_list=[t.a#7, UnaryAbTableArgScannedInCTE.b#4]
                +-input_scan=
                  +-WithRefScan(column_list=[t.a#7, UnaryAbTableArgScannedInCTE.b#4], with_query_name="t")
--
ALTERNATION GROUP: b,ScannedInCTE,(SELECT 1 AS a, "two" AS b)
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgScannedInCTE.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArgScannedInCTE.b#4]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArgScannedInCTE.b#4]
        +-tvf=UnaryAbTableArgScannedInCTE((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[a#1, b#2]
        |   |   +-expr_list=
        |   |   | +-a#1 := Literal(type=INT64, value=1)
        |   |   | +-b#2 := Literal(type=STRING, value="two")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[a#1, b#2]
        +-column_index_list=[1]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgScannedInCTE.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=[UnaryAbTableArgScannedInCTE.b#4]
    +-input_scan=
      +-WithScan
        +-column_list=[t.a#7, UnaryAbTableArgScannedInCTE.b#4]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$subquery1.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=STRING, value="two")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-WithScan
            +-column_list=[t.a#7, UnaryAbTableArgScannedInCTE.b#4]
            +-with_entry_list=
            | +-WithEntry
            |   +-with_query_name="t"
            |   +-with_subquery=
            |     +-ProjectScan
            |       +-column_list=arg0.[a#5, b#6]
            |       +-input_scan=
            |         +-WithRefScan(column_list=arg0.[a#5, b#6], with_query_name="arg0")
            +-query=
              +-ProjectScan
                +-column_list=[t.a#7, UnaryAbTableArgScannedInCTE.b#4]
                +-input_scan=
                  +-WithRefScan(column_list=[t.a#7, UnaryAbTableArgScannedInCTE.b#4], with_query_name="t")
==

SELECT *
FROM BinaryTableArg({{TABLE abTable|(SELECT 1 AS a, "two" AS b)}},
                    (SELECT 1 AS c, "two" AS d));
--
ALTERNATION GROUP: TABLE abTable
--
QueryStmt
+-output_column_list=
| +-BinaryTableArg.a#5 AS a [INT64]
| +-BinaryTableArg.b#6 AS b [STRING]
| +-BinaryTableArg.c#7 AS c [INT64]
| +-BinaryTableArg.d#8 AS d [STRING]
+-query=
  +-ProjectScan
    +-column_list=BinaryTableArg.[a#5, b#6, c#7, d#8]
    +-input_scan=
      +-TVFScan
        +-column_list=BinaryTableArg.[a#5, b#6, c#7, d#8]
        +-tvf=BinaryTableArg((TABLE<a INT64, b STRING> arg0, TABLE<c INT64, d STRING> arg1) -> TABLE<a INT64, b STRING, c INT64, d STRING>)
        +-signature=(TABLE<a INT64, b STRING>, TABLE<c INT64, d STRING>) -> TABLE<a INT64, b STRING, c INT64, d STRING>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        | | +-argument_column_list=abTable.[a#1, b#2]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[c#3, d#4]
        |   |   +-expr_list=
        |   |   | +-c#3 := Literal(type=INT64, value=1)
        |   |   | +-d#4 := Literal(type=STRING, value="two")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[c#3, d#4]
        +-column_index_list=[0, 1, 2, 3]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0, TABLE<c INT64, d STRING> arg1) -> TABLE<a INT64, b STRING, c INT64, d STRING>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-BinaryTableArg.a#5 AS a [INT64]
| +-BinaryTableArg.b#6 AS b [STRING]
| +-BinaryTableArg.c#7 AS c [INT64]
| +-BinaryTableArg.d#8 AS d [STRING]
+-query=
  +-ProjectScan
    +-column_list=BinaryTableArg.[a#5, b#6, c#7, d#8]
    +-input_scan=
      +-WithScan
        +-column_list=BinaryTableArg.[a#5, b#6, c#7, d#8]
        +-with_entry_list=
        | +-WithEntry
        | | +-with_query_name="arg0"
        | | +-with_subquery=
        | |   +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        | +-WithEntry
        |   +-with_query_name="arg1"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$subquery1.[c#3, d#4]
        |       +-expr_list=
        |       | +-c#3 := Literal(type=INT64, value=1)
        |       | +-d#4 := Literal(type=STRING, value="two")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=BinaryTableArg.[a#5, b#6, c#7, d#8]
            +-input_scan=
              +-JoinScan
                +-column_list=BinaryTableArg.[a#5, b#6, c#7, d#8]
                +-left_scan=
                | +-WithRefScan(column_list=BinaryTableArg.[a#5, b#6], with_query_name="arg0")
                +-right_scan=
                  +-WithRefScan(column_list=BinaryTableArg.[c#7, d#8], with_query_name="arg1")
--
ALTERNATION GROUP: (SELECT 1 AS a, "two" AS b)
--
QueryStmt
+-output_column_list=
| +-BinaryTableArg.a#5 AS a [INT64]
| +-BinaryTableArg.b#6 AS b [STRING]
| +-BinaryTableArg.c#7 AS c [INT64]
| +-BinaryTableArg.d#8 AS d [STRING]
+-query=
  +-ProjectScan
    +-column_list=BinaryTableArg.[a#5, b#6, c#7, d#8]
    +-input_scan=
      +-TVFScan
        +-column_list=BinaryTableArg.[a#5, b#6, c#7, d#8]
        +-tvf=BinaryTableArg((TABLE<a INT64, b STRING> arg0, TABLE<c INT64, d STRING> arg1) -> TABLE<a INT64, b STRING, c INT64, d STRING>)
        +-signature=(TABLE<a INT64, b STRING>, TABLE<c INT64, d STRING>) -> TABLE<a INT64, b STRING, c INT64, d STRING>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$subquery1.[a#1, b#2]
        | | |   +-expr_list=
        | | |   | +-a#1 := Literal(type=INT64, value=1)
        | | |   | +-b#2 := Literal(type=STRING, value="two")
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=$subquery1.[a#1, b#2]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery2.[c#3, d#4]
        |   |   +-expr_list=
        |   |   | +-c#3 := Literal(type=INT64, value=1)
        |   |   | +-d#4 := Literal(type=STRING, value="two")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery2.[c#3, d#4]
        +-column_index_list=[0, 1, 2, 3]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0, TABLE<c INT64, d STRING> arg1) -> TABLE<a INT64, b STRING, c INT64, d STRING>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-BinaryTableArg.a#5 AS a [INT64]
| +-BinaryTableArg.b#6 AS b [STRING]
| +-BinaryTableArg.c#7 AS c [INT64]
| +-BinaryTableArg.d#8 AS d [STRING]
+-query=
  +-ProjectScan
    +-column_list=BinaryTableArg.[a#5, b#6, c#7, d#8]
    +-input_scan=
      +-WithScan
        +-column_list=BinaryTableArg.[a#5, b#6, c#7, d#8]
        +-with_entry_list=
        | +-WithEntry
        | | +-with_query_name="arg0"
        | | +-with_subquery=
        | |   +-ProjectScan
        | |     +-column_list=$subquery1.[a#1, b#2]
        | |     +-expr_list=
        | |     | +-a#1 := Literal(type=INT64, value=1)
        | |     | +-b#2 := Literal(type=STRING, value="two")
        | |     +-input_scan=
        | |       +-SingleRowScan
        | +-WithEntry
        |   +-with_query_name="arg1"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$subquery2.[c#3, d#4]
        |       +-expr_list=
        |       | +-c#3 := Literal(type=INT64, value=1)
        |       | +-d#4 := Literal(type=STRING, value="two")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=BinaryTableArg.[a#5, b#6, c#7, d#8]
            +-input_scan=
              +-JoinScan
                +-column_list=BinaryTableArg.[a#5, b#6, c#7, d#8]
                +-left_scan=
                | +-WithRefScan(column_list=BinaryTableArg.[a#5, b#6], with_query_name="arg0")
                +-right_scan=
                  +-WithRefScan(column_list=BinaryTableArg.[c#7, d#8], with_query_name="arg1")
==

# Skip unparser because of b/224585752
[no_run_sqlbuilder]
SELECT *
FROM BinaryAbTableArg({{TABLE abTable|(SELECT 1 AS a, "two" AS b)}},
                      {{TABLE abTable|(SELECT 1 AS a, "two" AS b)}});
--
ALTERNATION GROUP: TABLE abTable,TABLE abTable
--
QueryStmt
+-output_column_list=
| +-BinaryAbTableArg.a#5 AS a [INT64]
| +-BinaryAbTableArg.b#6 AS b [STRING]
| +-BinaryAbTableArg.a#7 AS a [INT64]
| +-BinaryAbTableArg.b#8 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
    +-input_scan=
      +-TVFScan
        +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
        +-tvf=BinaryAbTableArg((TABLE<a INT64, b STRING> arg0, TABLE<a INT64, b STRING> arg1) -> TABLE<a INT64, b STRING, a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>, TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING, a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        | | +-argument_column_list=abTable.[a#1, b#2]
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#3, b#4], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#3, b#4]
        +-column_index_list=[0, 1, 2, 3]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0, TABLE<a INT64, b STRING> arg1) -> TABLE<a INT64, b STRING, a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-BinaryAbTableArg.a#5 AS a [INT64]
| +-BinaryAbTableArg.b#6 AS b [STRING]
| +-BinaryAbTableArg.a#7 AS a [INT64]
| +-BinaryAbTableArg.b#8 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
    +-input_scan=
      +-WithScan
        +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
        +-with_entry_list=
        | +-WithEntry
        | | +-with_query_name="arg0"
        | | +-with_subquery=
        | |   +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        | +-WithEntry
        |   +-with_query_name="arg1"
        |   +-with_subquery=
        |     +-TableScan(column_list=abTable.[a#3, b#4], table=abTable, column_index_list=[0, 1])
        +-query=
          +-ProjectScan
            +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
            +-input_scan=
              +-JoinScan
                +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
                +-left_scan=
                | +-WithRefScan(column_list=BinaryAbTableArg.[a#5, b#6], with_query_name="arg0")
                +-right_scan=
                  +-WithRefScan(column_list=BinaryAbTableArg.[a#7, b#8], with_query_name="arg1")
--
ALTERNATION GROUP: TABLE abTable,(SELECT 1 AS a, "two" AS b)
--
QueryStmt
+-output_column_list=
| +-BinaryAbTableArg.a#5 AS a [INT64]
| +-BinaryAbTableArg.b#6 AS b [STRING]
| +-BinaryAbTableArg.a#7 AS a [INT64]
| +-BinaryAbTableArg.b#8 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
    +-input_scan=
      +-TVFScan
        +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
        +-tvf=BinaryAbTableArg((TABLE<a INT64, b STRING> arg0, TABLE<a INT64, b STRING> arg1) -> TABLE<a INT64, b STRING, a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>, TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING, a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        | | +-argument_column_list=abTable.[a#1, b#2]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[a#3, b#4]
        |   |   +-expr_list=
        |   |   | +-a#3 := Literal(type=INT64, value=1)
        |   |   | +-b#4 := Literal(type=STRING, value="two")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[a#3, b#4]
        +-column_index_list=[0, 1, 2, 3]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0, TABLE<a INT64, b STRING> arg1) -> TABLE<a INT64, b STRING, a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-BinaryAbTableArg.a#5 AS a [INT64]
| +-BinaryAbTableArg.b#6 AS b [STRING]
| +-BinaryAbTableArg.a#7 AS a [INT64]
| +-BinaryAbTableArg.b#8 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
    +-input_scan=
      +-WithScan
        +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
        +-with_entry_list=
        | +-WithEntry
        | | +-with_query_name="arg0"
        | | +-with_subquery=
        | |   +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        | +-WithEntry
        |   +-with_query_name="arg1"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$subquery1.[a#3, b#4]
        |       +-expr_list=
        |       | +-a#3 := Literal(type=INT64, value=1)
        |       | +-b#4 := Literal(type=STRING, value="two")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
            +-input_scan=
              +-JoinScan
                +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
                +-left_scan=
                | +-WithRefScan(column_list=BinaryAbTableArg.[a#5, b#6], with_query_name="arg0")
                +-right_scan=
                  +-WithRefScan(column_list=BinaryAbTableArg.[a#7, b#8], with_query_name="arg1")
--
ALTERNATION GROUP: (SELECT 1 AS a, "two" AS b),TABLE abTable
--
QueryStmt
+-output_column_list=
| +-BinaryAbTableArg.a#5 AS a [INT64]
| +-BinaryAbTableArg.b#6 AS b [STRING]
| +-BinaryAbTableArg.a#7 AS a [INT64]
| +-BinaryAbTableArg.b#8 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
    +-input_scan=
      +-TVFScan
        +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
        +-tvf=BinaryAbTableArg((TABLE<a INT64, b STRING> arg0, TABLE<a INT64, b STRING> arg1) -> TABLE<a INT64, b STRING, a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>, TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING, a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$subquery1.[a#1, b#2]
        | | |   +-expr_list=
        | | |   | +-a#1 := Literal(type=INT64, value=1)
        | | |   | +-b#2 := Literal(type=STRING, value="two")
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=$subquery1.[a#1, b#2]
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#3, b#4], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#3, b#4]
        +-column_index_list=[0, 1, 2, 3]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0, TABLE<a INT64, b STRING> arg1) -> TABLE<a INT64, b STRING, a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-BinaryAbTableArg.a#5 AS a [INT64]
| +-BinaryAbTableArg.b#6 AS b [STRING]
| +-BinaryAbTableArg.a#7 AS a [INT64]
| +-BinaryAbTableArg.b#8 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
    +-input_scan=
      +-WithScan
        +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
        +-with_entry_list=
        | +-WithEntry
        | | +-with_query_name="arg0"
        | | +-with_subquery=
        | |   +-ProjectScan
        | |     +-column_list=$subquery1.[a#1, b#2]
        | |     +-expr_list=
        | |     | +-a#1 := Literal(type=INT64, value=1)
        | |     | +-b#2 := Literal(type=STRING, value="two")
        | |     +-input_scan=
        | |       +-SingleRowScan
        | +-WithEntry
        |   +-with_query_name="arg1"
        |   +-with_subquery=
        |     +-TableScan(column_list=abTable.[a#3, b#4], table=abTable, column_index_list=[0, 1])
        +-query=
          +-ProjectScan
            +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
            +-input_scan=
              +-JoinScan
                +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
                +-left_scan=
                | +-WithRefScan(column_list=BinaryAbTableArg.[a#5, b#6], with_query_name="arg0")
                +-right_scan=
                  +-WithRefScan(column_list=BinaryAbTableArg.[a#7, b#8], with_query_name="arg1")
--
ALTERNATION GROUP: (SELECT 1 AS a, "two" AS b),(SELECT 1 AS a, "two" AS b)
--
QueryStmt
+-output_column_list=
| +-BinaryAbTableArg.a#5 AS a [INT64]
| +-BinaryAbTableArg.b#6 AS b [STRING]
| +-BinaryAbTableArg.a#7 AS a [INT64]
| +-BinaryAbTableArg.b#8 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
    +-input_scan=
      +-TVFScan
        +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
        +-tvf=BinaryAbTableArg((TABLE<a INT64, b STRING> arg0, TABLE<a INT64, b STRING> arg1) -> TABLE<a INT64, b STRING, a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>, TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING, a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$subquery1.[a#1, b#2]
        | | |   +-expr_list=
        | | |   | +-a#1 := Literal(type=INT64, value=1)
        | | |   | +-b#2 := Literal(type=STRING, value="two")
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=$subquery1.[a#1, b#2]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery2.[a#3, b#4]
        |   |   +-expr_list=
        |   |   | +-a#3 := Literal(type=INT64, value=1)
        |   |   | +-b#4 := Literal(type=STRING, value="two")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery2.[a#3, b#4]
        +-column_index_list=[0, 1, 2, 3]
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0, TABLE<a INT64, b STRING> arg1) -> TABLE<a INT64, b STRING, a INT64, b STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-BinaryAbTableArg.a#5 AS a [INT64]
| +-BinaryAbTableArg.b#6 AS b [STRING]
| +-BinaryAbTableArg.a#7 AS a [INT64]
| +-BinaryAbTableArg.b#8 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
    +-input_scan=
      +-WithScan
        +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
        +-with_entry_list=
        | +-WithEntry
        | | +-with_query_name="arg0"
        | | +-with_subquery=
        | |   +-ProjectScan
        | |     +-column_list=$subquery1.[a#1, b#2]
        | |     +-expr_list=
        | |     | +-a#1 := Literal(type=INT64, value=1)
        | |     | +-b#2 := Literal(type=STRING, value="two")
        | |     +-input_scan=
        | |       +-SingleRowScan
        | +-WithEntry
        |   +-with_query_name="arg1"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$subquery2.[a#3, b#4]
        |       +-expr_list=
        |       | +-a#3 := Literal(type=INT64, value=1)
        |       | +-b#4 := Literal(type=STRING, value="two")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
            +-input_scan=
              +-JoinScan
                +-column_list=BinaryAbTableArg.[a#5, b#6, a#7, b#8]
                +-left_scan=
                | +-WithRefScan(column_list=BinaryAbTableArg.[a#5, b#6], with_query_name="arg0")
                +-right_scan=
                  +-WithRefScan(column_list=BinaryAbTableArg.[a#7, b#8], with_query_name="arg1")
==

SELECT *
FROM UnaryAbTableArgWithScalarArgs(5,
                                   {{TABLE abTable|(SELECT 1 AS a, "two" AS b)}},
                                   "six");
--
ALTERNATION GROUP: TABLE abTable
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgWithScalarArgs.a#3 AS a [INT64]
| +-UnaryAbTableArgWithScalarArgs.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4]
    +-input_scan=
      +-TVFScan
        +-column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4]
        +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
        +-signature=(literal INT64, TABLE<a INT64, b STRING>, literal STRING) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=5)
        | +-FunctionArgument
        | | +-scan=
        | | | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        | | +-argument_column_list=abTable.[a#1, b#2]
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="six")
        +-column_index_list=[0, 1]
        +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgWithScalarArgs.a#3 AS a [INT64]
| +-UnaryAbTableArgWithScalarArgs.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4]
    +-input_scan=
      +-WithScan
        +-column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4]
        +-with_entry_list=
        | +-WithEntry
        | | +-with_query_name="arg0"
        | | +-with_subquery=
        | |   +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        | +-WithEntry
        |   +-with_query_name="$inlined_UnaryAbTableArgWithScalarArgs_scalar_args"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$inlined_UnaryAbTableArgWithScalarArgs.[x#5, y#6]
        |       +-expr_list=
        |       | +-x#5 := Literal(type=INT64, value=5)
        |       | +-y#6 := Literal(type=STRING, value="six")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4]
            +-input_scan=
              +-FilterScan
                +-column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4]
                +-input_scan=
                | +-WithRefScan(column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4], with_query_name="arg0")
                +-filter_expr=
                  +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
                    +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                    | +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#3)
                    | +-SubqueryExpr
                    |   +-type=INT64
                    |   +-subquery_type=SCALAR
                    |   +-subquery=
                    |     +-ProjectScan
                    |       +-column_list=[$inlined_UnaryAbTableArgWithScalarArgs.x#7]
                    |       +-input_scan=
                    |         +-WithRefScan(column_list=$inlined_UnaryAbTableArgWithScalarArgs.[x#7, y#8], with_query_name="$inlined_UnaryAbTableArgWithScalarArgs_scalar_args")
                    +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
                      +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#4)
                      +-SubqueryExpr
                        +-type=STRING
                        +-subquery_type=SCALAR
                        +-subquery=
                          +-ProjectScan
                            +-column_list=[$inlined_UnaryAbTableArgWithScalarArgs.y#10]
                            +-input_scan=
                              +-WithRefScan(column_list=$inlined_UnaryAbTableArgWithScalarArgs.[x#9, y#10], with_query_name="$inlined_UnaryAbTableArgWithScalarArgs_scalar_args")
--
ALTERNATION GROUP: (SELECT 1 AS a, "two" AS b)
--
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgWithScalarArgs.a#3 AS a [INT64]
| +-UnaryAbTableArgWithScalarArgs.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4]
    +-input_scan=
      +-TVFScan
        +-column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4]
        +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
        +-signature=(literal INT64, TABLE<a INT64, b STRING>, literal STRING) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=5)
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$subquery1.[a#1, b#2]
        | | |   +-expr_list=
        | | |   | +-a#1 := Literal(type=INT64, value=1)
        | | |   | +-b#2 := Literal(type=STRING, value="two")
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=$subquery1.[a#1, b#2]
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="six")
        +-column_index_list=[0, 1]
        +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryAbTableArgWithScalarArgs.a#3 AS a [INT64]
| +-UnaryAbTableArgWithScalarArgs.b#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4]
    +-input_scan=
      +-WithScan
        +-column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4]
        +-with_entry_list=
        | +-WithEntry
        | | +-with_query_name="arg0"
        | | +-with_subquery=
        | |   +-ProjectScan
        | |     +-column_list=$subquery1.[a#1, b#2]
        | |     +-expr_list=
        | |     | +-a#1 := Literal(type=INT64, value=1)
        | |     | +-b#2 := Literal(type=STRING, value="two")
        | |     +-input_scan=
        | |       +-SingleRowScan
        | +-WithEntry
        |   +-with_query_name="$inlined_UnaryAbTableArgWithScalarArgs_scalar_args"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=$inlined_UnaryAbTableArgWithScalarArgs.[x#5, y#6]
        |       +-expr_list=
        |       | +-x#5 := Literal(type=INT64, value=5)
        |       | +-y#6 := Literal(type=STRING, value="six")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4]
            +-input_scan=
              +-FilterScan
                +-column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4]
                +-input_scan=
                | +-WithRefScan(column_list=UnaryAbTableArgWithScalarArgs.[a#3, b#4], with_query_name="arg0")
                +-filter_expr=
                  +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
                    +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                    | +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#3)
                    | +-SubqueryExpr
                    |   +-type=INT64
                    |   +-subquery_type=SCALAR
                    |   +-subquery=
                    |     +-ProjectScan
                    |       +-column_list=[$inlined_UnaryAbTableArgWithScalarArgs.x#7]
                    |       +-input_scan=
                    |         +-WithRefScan(column_list=$inlined_UnaryAbTableArgWithScalarArgs.[x#7, y#8], with_query_name="$inlined_UnaryAbTableArgWithScalarArgs_scalar_args")
                    +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
                      +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#4)
                      +-SubqueryExpr
                        +-type=STRING
                        +-subquery_type=SCALAR
                        +-subquery=
                          +-ProjectScan
                            +-column_list=[$inlined_UnaryAbTableArgWithScalarArgs.y#10]
                            +-input_scan=
                              +-WithRefScan(column_list=$inlined_UnaryAbTableArgWithScalarArgs.[x#9, y#10], with_query_name="$inlined_UnaryAbTableArgWithScalarArgs_scalar_args")
==

# Invoke a TVF with various argument including correlated columns invarious
# configurations.
SELECT (SELECT AS STRUCT *
        FROM UnaryAbTableArgWithScalarArgs(
            {{1|t.a}},
            {{TABLE abTable|(SELECT 1 AS a, "two" AS b)|(SELECT t.a, "two" AS b)}},
            {{"two"|t.b}}
            )
        )
FROM UnaryAbTableArg(TABLE abTable) AS t;
--
ALTERNATION GROUP: 1,TABLE abTable,"two"
--
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
    |                 +-signature=(literal INT64, TABLE<a INT64, b STRING>, literal STRING) -> TABLE<a INT64, b STRING>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 | | +-expr=
    |                 | |   +-Literal(type=INT64, value=1)
    |                 | +-FunctionArgument
    |                 | | +-scan=
    |                 | | | +-TableScan(column_list=abTable.[a#5, b#6], table=abTable, column_index_list=[0, 1])
    |                 | | +-argument_column_list=abTable.[a#5, b#6]
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-Literal(type=STRING, value="two")
    |                 +-column_index_list=[0, 1]
    |                 +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>
    +-input_scan=
      +-TVFScan
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-alias="t"
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-WithScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-with_entry_list=
    |                 | +-WithEntry
    |                 | | +-with_query_name="arg0"
    |                 | | +-with_subquery=
    |                 | |   +-TableScan(column_list=abTable.[a#5, b#6], table=abTable, column_index_list=[0, 1])
    |                 | +-WithEntry
    |                 |   +-with_query_name="$inlined_UnaryAbTableArgWithScalarArgs_scalar_args"
    |                 |   +-with_subquery=
    |                 |     +-ProjectScan
    |                 |       +-column_list=$inlined_UnaryAbTableArgWithScalarArgs.[x#11, y#12]
    |                 |       +-expr_list=
    |                 |       | +-x#11 := Literal(type=INT64, value=1)
    |                 |       | +-y#12 := Literal(type=STRING, value="two")
    |                 |       +-input_scan=
    |                 |         +-SingleRowScan
    |                 +-query=
    |                   +-ProjectScan
    |                     +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                     +-input_scan=
    |                       +-FilterScan
    |                         +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                         +-input_scan=
    |                         | +-WithRefScan(column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8], with_query_name="arg0")
    |                         +-filter_expr=
    |                           +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
    |                             +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |                             | +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |                             | +-SubqueryExpr
    |                             |   +-type=INT64
    |                             |   +-subquery_type=SCALAR
    |                             |   +-subquery=
    |                             |     +-ProjectScan
    |                             |       +-column_list=[$inlined_UnaryAbTableArgWithScalarArgs.x#13]
    |                             |       +-input_scan=
    |                             |         +-WithRefScan(column_list=$inlined_UnaryAbTableArgWithScalarArgs.[x#13, y#14], with_query_name="$inlined_UnaryAbTableArgWithScalarArgs_scalar_args")
    |                             +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |                               +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |                               +-SubqueryExpr
    |                                 +-type=STRING
    |                                 +-subquery_type=SCALAR
    |                                 +-subquery=
    |                                   +-ProjectScan
    |                                     +-column_list=[$inlined_UnaryAbTableArgWithScalarArgs.y#16]
    |                                     +-input_scan=
    |                                       +-WithRefScan(column_list=$inlined_UnaryAbTableArgWithScalarArgs.[x#15, y#16], with_query_name="$inlined_UnaryAbTableArgWithScalarArgs_scalar_args")
    +-input_scan=
      +-WithScan
        +-column_list=arg0.[a#17, b#18]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        +-query=
          +-ProjectScan
            +-column_list=arg0.[a#17, b#18]
            +-input_scan=
              +-WithRefScan(column_list=arg0.[a#17, b#18], with_query_name="arg0")
--
ALTERNATION GROUP: 1,TABLE abTable,t.b
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=STRING, column=UnaryAbTableArg.b#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
    |                 +-signature=(literal INT64, TABLE<a INT64, b STRING>, STRING) -> TABLE<a INT64, b STRING>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 | | +-expr=
    |                 | |   +-Literal(type=INT64, value=1)
    |                 | +-FunctionArgument
    |                 | | +-scan=
    |                 | | | +-TableScan(column_list=abTable.[a#5, b#6], table=abTable, column_index_list=[0, 1])
    |                 | | +-argument_column_list=abTable.[a#5, b#6]
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-ColumnRef(type=STRING, column=UnaryAbTableArg.b#4, is_correlated=TRUE)
    |                 +-column_index_list=[0, 1]
    |                 +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArg.b#4]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[1]
        +-alias="t"
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #3 ('y') references column 'b'.
--
ALTERNATION GROUP: 1,(SELECT 1 AS a, "two" AS b),"two"
--
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
    |                 +-signature=(literal INT64, TABLE<a INT64, b STRING>, literal STRING) -> TABLE<a INT64, b STRING>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 | | +-expr=
    |                 | |   +-Literal(type=INT64, value=1)
    |                 | +-FunctionArgument
    |                 | | +-scan=
    |                 | | | +-ProjectScan
    |                 | | |   +-column_list=$subquery1.[a#5, b#6]
    |                 | | |   +-expr_list=
    |                 | | |   | +-a#5 := Literal(type=INT64, value=1)
    |                 | | |   | +-b#6 := Literal(type=STRING, value="two")
    |                 | | |   +-input_scan=
    |                 | | |     +-SingleRowScan
    |                 | | +-argument_column_list=$subquery1.[a#5, b#6]
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-Literal(type=STRING, value="two")
    |                 +-column_index_list=[0, 1]
    |                 +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>
    +-input_scan=
      +-TVFScan
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-alias="t"
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-WithScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-with_entry_list=
    |                 | +-WithEntry
    |                 | | +-with_query_name="arg0"
    |                 | | +-with_subquery=
    |                 | |   +-ProjectScan
    |                 | |     +-column_list=$subquery1.[a#5, b#6]
    |                 | |     +-expr_list=
    |                 | |     | +-a#5 := Literal(type=INT64, value=1)
    |                 | |     | +-b#6 := Literal(type=STRING, value="two")
    |                 | |     +-input_scan=
    |                 | |       +-SingleRowScan
    |                 | +-WithEntry
    |                 |   +-with_query_name="$inlined_UnaryAbTableArgWithScalarArgs_scalar_args"
    |                 |   +-with_subquery=
    |                 |     +-ProjectScan
    |                 |       +-column_list=$inlined_UnaryAbTableArgWithScalarArgs.[x#11, y#12]
    |                 |       +-expr_list=
    |                 |       | +-x#11 := Literal(type=INT64, value=1)
    |                 |       | +-y#12 := Literal(type=STRING, value="two")
    |                 |       +-input_scan=
    |                 |         +-SingleRowScan
    |                 +-query=
    |                   +-ProjectScan
    |                     +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                     +-input_scan=
    |                       +-FilterScan
    |                         +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                         +-input_scan=
    |                         | +-WithRefScan(column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8], with_query_name="arg0")
    |                         +-filter_expr=
    |                           +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
    |                             +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |                             | +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |                             | +-SubqueryExpr
    |                             |   +-type=INT64
    |                             |   +-subquery_type=SCALAR
    |                             |   +-subquery=
    |                             |     +-ProjectScan
    |                             |       +-column_list=[$inlined_UnaryAbTableArgWithScalarArgs.x#13]
    |                             |       +-input_scan=
    |                             |         +-WithRefScan(column_list=$inlined_UnaryAbTableArgWithScalarArgs.[x#13, y#14], with_query_name="$inlined_UnaryAbTableArgWithScalarArgs_scalar_args")
    |                             +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |                               +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |                               +-SubqueryExpr
    |                                 +-type=STRING
    |                                 +-subquery_type=SCALAR
    |                                 +-subquery=
    |                                   +-ProjectScan
    |                                     +-column_list=[$inlined_UnaryAbTableArgWithScalarArgs.y#16]
    |                                     +-input_scan=
    |                                       +-WithRefScan(column_list=$inlined_UnaryAbTableArgWithScalarArgs.[x#15, y#16], with_query_name="$inlined_UnaryAbTableArgWithScalarArgs_scalar_args")
    +-input_scan=
      +-WithScan
        +-column_list=arg0.[a#17, b#18]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        +-query=
          +-ProjectScan
            +-column_list=arg0.[a#17, b#18]
            +-input_scan=
              +-WithRefScan(column_list=arg0.[a#17, b#18], with_query_name="arg0")
--
ALTERNATION GROUP: 1,(SELECT 1 AS a, "two" AS b),t.b
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=STRING, column=UnaryAbTableArg.b#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
    |                 +-signature=(literal INT64, TABLE<a INT64, b STRING>, STRING) -> TABLE<a INT64, b STRING>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 | | +-expr=
    |                 | |   +-Literal(type=INT64, value=1)
    |                 | +-FunctionArgument
    |                 | | +-scan=
    |                 | | | +-ProjectScan
    |                 | | |   +-column_list=$subquery1.[a#5, b#6]
    |                 | | |   +-expr_list=
    |                 | | |   | +-a#5 := Literal(type=INT64, value=1)
    |                 | | |   | +-b#6 := Literal(type=STRING, value="two")
    |                 | | |   +-input_scan=
    |                 | | |     +-SingleRowScan
    |                 | | +-argument_column_list=$subquery1.[a#5, b#6]
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-ColumnRef(type=STRING, column=UnaryAbTableArg.b#4, is_correlated=TRUE)
    |                 +-column_index_list=[0, 1]
    |                 +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArg.b#4]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[1]
        +-alias="t"
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #3 ('y') references column 'b'.
--
ALTERNATION GROUP: 1,(SELECT t.a, "two" AS b),"two"
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
    |                 +-signature=(literal INT64, TABLE<a INT64, b STRING>, literal STRING) -> TABLE<a INT64, b STRING>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 | | +-expr=
    |                 | |   +-Literal(type=INT64, value=1)
    |                 | +-FunctionArgument
    |                 | | +-scan=
    |                 | | | +-ProjectScan
    |                 | | |   +-column_list=$subquery1.[a#5, b#6]
    |                 | | |   +-expr_list=
    |                 | | |   | +-a#5 := ColumnRef(type=INT64, column=UnaryAbTableArg.a#3, is_correlated=TRUE)
    |                 | | |   | +-b#6 := Literal(type=STRING, value="two")
    |                 | | |   +-input_scan=
    |                 | | |     +-SingleRowScan
    |                 | | +-argument_column_list=$subquery1.[a#5, b#6]
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-Literal(type=STRING, value="two")
    |                 +-column_index_list=[0, 1]
    |                 +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArg.a#3]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[0]
        +-alias="t"
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #2 ('arg0') references column 'a'.
--
ALTERNATION GROUP: 1,(SELECT t.a, "two" AS b),t.b
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3)
    |     | +-ColumnRef(type=STRING, column=UnaryAbTableArg.b#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
    |                 +-signature=(literal INT64, TABLE<a INT64, b STRING>, STRING) -> TABLE<a INT64, b STRING>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 | | +-expr=
    |                 | |   +-Literal(type=INT64, value=1)
    |                 | +-FunctionArgument
    |                 | | +-scan=
    |                 | | | +-ProjectScan
    |                 | | |   +-column_list=$subquery1.[a#5, b#6]
    |                 | | |   +-expr_list=
    |                 | | |   | +-a#5 := ColumnRef(type=INT64, column=UnaryAbTableArg.a#3, is_correlated=TRUE)
    |                 | | |   | +-b#6 := Literal(type=STRING, value="two")
    |                 | | |   +-input_scan=
    |                 | | |     +-SingleRowScan
    |                 | | +-argument_column_list=$subquery1.[a#5, b#6]
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-ColumnRef(type=STRING, column=UnaryAbTableArg.b#4, is_correlated=TRUE)
    |                 +-column_index_list=[0, 1]
    |                 +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>
    +-input_scan=
      +-TVFScan
        +-column_list=UnaryAbTableArg.[a#3, b#4]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[0, 1]
        +-alias="t"
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #2 ('arg0') references column 'a'.
--
ALTERNATION GROUP: t.a,TABLE abTable,"two"
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
    |                 +-signature=(INT64, TABLE<a INT64, b STRING>, literal STRING) -> TABLE<a INT64, b STRING>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 | | +-expr=
    |                 | |   +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3, is_correlated=TRUE)
    |                 | +-FunctionArgument
    |                 | | +-scan=
    |                 | | | +-TableScan(column_list=abTable.[a#5, b#6], table=abTable, column_index_list=[0, 1])
    |                 | | +-argument_column_list=abTable.[a#5, b#6]
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-Literal(type=STRING, value="two")
    |                 +-column_index_list=[0, 1]
    |                 +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArg.a#3]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[0]
        +-alias="t"
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #1 ('x') references column 'a'.
--
ALTERNATION GROUP: t.a,TABLE abTable,t.b
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3)
    |     | +-ColumnRef(type=STRING, column=UnaryAbTableArg.b#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
    |                 +-signature=(INT64, TABLE<a INT64, b STRING>, STRING) -> TABLE<a INT64, b STRING>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 | | +-expr=
    |                 | |   +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3, is_correlated=TRUE)
    |                 | +-FunctionArgument
    |                 | | +-scan=
    |                 | | | +-TableScan(column_list=abTable.[a#5, b#6], table=abTable, column_index_list=[0, 1])
    |                 | | +-argument_column_list=abTable.[a#5, b#6]
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-ColumnRef(type=STRING, column=UnaryAbTableArg.b#4, is_correlated=TRUE)
    |                 +-column_index_list=[0, 1]
    |                 +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>
    +-input_scan=
      +-TVFScan
        +-column_list=UnaryAbTableArg.[a#3, b#4]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[0, 1]
        +-alias="t"
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #1 ('x') references column 'a'.
--
ALTERNATION GROUP: t.a,(SELECT 1 AS a, "two" AS b),"two"
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
    |                 +-signature=(INT64, TABLE<a INT64, b STRING>, literal STRING) -> TABLE<a INT64, b STRING>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 | | +-expr=
    |                 | |   +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3, is_correlated=TRUE)
    |                 | +-FunctionArgument
    |                 | | +-scan=
    |                 | | | +-ProjectScan
    |                 | | |   +-column_list=$subquery1.[a#5, b#6]
    |                 | | |   +-expr_list=
    |                 | | |   | +-a#5 := Literal(type=INT64, value=1)
    |                 | | |   | +-b#6 := Literal(type=STRING, value="two")
    |                 | | |   +-input_scan=
    |                 | | |     +-SingleRowScan
    |                 | | +-argument_column_list=$subquery1.[a#5, b#6]
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-Literal(type=STRING, value="two")
    |                 +-column_index_list=[0, 1]
    |                 +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArg.a#3]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[0]
        +-alias="t"
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #1 ('x') references column 'a'.
--
ALTERNATION GROUP: t.a,(SELECT 1 AS a, "two" AS b),t.b
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3)
    |     | +-ColumnRef(type=STRING, column=UnaryAbTableArg.b#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
    |                 +-signature=(INT64, TABLE<a INT64, b STRING>, STRING) -> TABLE<a INT64, b STRING>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 | | +-expr=
    |                 | |   +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3, is_correlated=TRUE)
    |                 | +-FunctionArgument
    |                 | | +-scan=
    |                 | | | +-ProjectScan
    |                 | | |   +-column_list=$subquery1.[a#5, b#6]
    |                 | | |   +-expr_list=
    |                 | | |   | +-a#5 := Literal(type=INT64, value=1)
    |                 | | |   | +-b#6 := Literal(type=STRING, value="two")
    |                 | | |   +-input_scan=
    |                 | | |     +-SingleRowScan
    |                 | | +-argument_column_list=$subquery1.[a#5, b#6]
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-ColumnRef(type=STRING, column=UnaryAbTableArg.b#4, is_correlated=TRUE)
    |                 +-column_index_list=[0, 1]
    |                 +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>
    +-input_scan=
      +-TVFScan
        +-column_list=UnaryAbTableArg.[a#3, b#4]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[0, 1]
        +-alias="t"
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #1 ('x') references column 'a'.
--
ALTERNATION GROUP: t.a,(SELECT t.a, "two" AS b),"two"
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
    |                 +-signature=(INT64, TABLE<a INT64, b STRING>, literal STRING) -> TABLE<a INT64, b STRING>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 | | +-expr=
    |                 | |   +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3, is_correlated=TRUE)
    |                 | +-FunctionArgument
    |                 | | +-scan=
    |                 | | | +-ProjectScan
    |                 | | |   +-column_list=$subquery1.[a#5, b#6]
    |                 | | |   +-expr_list=
    |                 | | |   | +-a#5 := ColumnRef(type=INT64, column=UnaryAbTableArg.a#3, is_correlated=TRUE)
    |                 | | |   | +-b#6 := Literal(type=STRING, value="two")
    |                 | | |   +-input_scan=
    |                 | | |     +-SingleRowScan
    |                 | | +-argument_column_list=$subquery1.[a#5, b#6]
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-Literal(type=STRING, value="two")
    |                 +-column_index_list=[0, 1]
    |                 +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryAbTableArg.a#3]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[0]
        +-alias="t"
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #1 ('x') references column 'a'.
--
ALTERNATION GROUP: t.a,(SELECT t.a, "two" AS b),t.b
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<a INT64, b STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3)
    |     | +-ColumnRef(type=STRING, column=UnaryAbTableArg.b#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<a INT64, b STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=UnaryAbTableArgWithScalarArgs.a#7)
    |         |       +-ColumnRef(type=STRING, column=UnaryAbTableArgWithScalarArgs.b#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=UnaryAbTableArgWithScalarArgs.[a#7, b#8]
    |                 +-tvf=UnaryAbTableArgWithScalarArgs((INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>)
    |                 +-signature=(INT64, TABLE<a INT64, b STRING>, STRING) -> TABLE<a INT64, b STRING>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 | | +-expr=
    |                 | |   +-ColumnRef(type=INT64, column=UnaryAbTableArg.a#3, is_correlated=TRUE)
    |                 | +-FunctionArgument
    |                 | | +-scan=
    |                 | | | +-ProjectScan
    |                 | | |   +-column_list=$subquery1.[a#5, b#6]
    |                 | | |   +-expr_list=
    |                 | | |   | +-a#5 := ColumnRef(type=INT64, column=UnaryAbTableArg.a#3, is_correlated=TRUE)
    |                 | | |   | +-b#6 := Literal(type=STRING, value="two")
    |                 | | |   +-input_scan=
    |                 | | |     +-SingleRowScan
    |                 | | +-argument_column_list=$subquery1.[a#5, b#6]
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-ColumnRef(type=STRING, column=UnaryAbTableArg.b#4, is_correlated=TRUE)
    |                 +-column_index_list=[0, 1]
    |                 +-function_call_signature=(INT64 x, TABLE<a INT64, b STRING> arg0, STRING y) -> TABLE<a INT64, b STRING>
    +-input_scan=
      +-TVFScan
        +-column_list=UnaryAbTableArg.[a#3, b#4]
        +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
        +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=abTable.[a#1, b#2], table=abTable, column_index_list=[0, 1])
        |   +-argument_column_list=abTable.[a#1, b#2]
        +-column_index_list=[0, 1]
        +-alias="t"
        +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #1 ('x') references column 'a'.
==

# The correlated column reference is inside a subquery within the argument
# subquery.
SELECT (SELECT b FROM UnaryAbTableArg((SELECT 1 AS a, (SELECT t.b) AS b)))
FROM (SELECT 'b' AS b) AS t;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=STRING
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=STRING, column=t.b#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[UnaryAbTableArg.b#6]
    |         +-input_scan=
    |           +-TVFScan
    |             +-column_list=[UnaryAbTableArg.b#6]
    |             +-tvf=UnaryAbTableArg((TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>)
    |             +-signature=(TABLE<a INT64, b STRING>) -> TABLE<a INT64, b STRING>
    |             +-argument_list=
    |             | +-FunctionArgument
    |             |   +-scan=
    |             |   | +-ProjectScan
    |             |   |   +-column_list=$subquery1.[a#3, b#4]
    |             |   |   +-expr_list=
    |             |   |   | +-a#3 := Literal(type=INT64, value=1)
    |             |   |   | +-b#4 :=
    |             |   |   |   +-SubqueryExpr
    |             |   |   |     +-type=STRING
    |             |   |   |     +-subquery_type=SCALAR
    |             |   |   |     +-parameter_list=
    |             |   |   |     | +-ColumnRef(type=STRING, column=t.b#1, is_correlated=TRUE)
    |             |   |   |     +-subquery=
    |             |   |   |       +-ProjectScan
    |             |   |   |         +-column_list=[$expr_subquery.b#2]
    |             |   |   |         +-expr_list=
    |             |   |   |         | +-b#2 := ColumnRef(type=STRING, column=t.b#1, is_correlated=TRUE)
    |             |   |   |         +-input_scan=
    |             |   |   |           +-SingleRowScan
    |             |   |   +-input_scan=
    |             |   |     +-SingleRowScan
    |             |   +-argument_column_list=$subquery1.[a#3, b#4]
    |             +-column_index_list=[1]
    |             +-function_call_signature=(TABLE<a INT64, b STRING> arg0) -> TABLE<a INT64, b STRING>
    +-input_scan=
      +-ProjectScan
        +-column_list=[t.b#1]
        +-expr_list=
        | +-b#1 := Literal(type=STRING, value="b")
        +-input_scan=
          +-SingleRowScan

Rewrite ERROR: generic::unimplemented: TVF arguments that reference columns are not supported. Arg #1 ('arg0') references column 'b'.
==

[no_run_sqlbuilder]
SELECT * FROM DefinerRightsTvf((select count(*) from KeyValue))
--
QueryStmt
+-output_column_list=
| +-DefinerRightsTvf.Key#4 AS Key [INT64]
| +-DefinerRightsTvf.Value#5 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=DefinerRightsTvf.[Key#4, Value#5]
    +-input_scan=
      +-TVFScan
        +-column_list=DefinerRightsTvf.[Key#4, Value#5]
        +-tvf=DefinerRightsTvf((INT64 a) -> TABLE<Key INT64, Value STRING>)
        +-signature=(INT64) -> TABLE<Key INT64, Value STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-SubqueryExpr
        |       +-type=INT64
        |       +-subquery_type=SCALAR
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$aggregate.$agg1#3]
        |           +-input_scan=
        |             +-AggregateScan
        |               +-column_list=[$aggregate.$agg1#3]
        |               +-input_scan=
        |               | +-TableScan(table=KeyValue)
        |               +-aggregate_list=
        |                 +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-column_index_list=[0, 1]
        +-function_call_signature=(INT64 a) -> TABLE<Key INT64, Value STRING>


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-DefinerRightsTvf.Key#4 AS Key [INT64]
| +-DefinerRightsTvf.Value#5 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=DefinerRightsTvf.[Key#4, Value#5]
    +-input_scan=
      +-WithScan
        +-column_list=DefinerRightsTvf.[Key#4, Value#5]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="$inlined_DefinerRightsTvf_scalar_args"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[$inlined_DefinerRightsTvf.a#8]
        |       +-expr_list=
        |       | +-a#8 :=
        |       |   +-SubqueryExpr
        |       |     +-type=INT64
        |       |     +-subquery_type=SCALAR
        |       |     +-subquery=
        |       |       +-ProjectScan
        |       |         +-column_list=[$aggregate.$agg1#3]
        |       |         +-input_scan=
        |       |           +-AggregateScan
        |       |             +-column_list=[$aggregate.$agg1#3]
        |       |             +-input_scan=
        |       |             | +-TableScan(table=KeyValue)
        |       |             +-aggregate_list=
        |       |               +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ExecuteAsRoleScan
            +-column_list=DefinerRightsTvf.[Key#4, Value#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=DefinerRightsTvf.[Key#6, Value#7]
            |   +-input_scan=
            |     +-FilterScan
            |       +-column_list=DefinerRightsTvf.[Key#6, Value#7]
            |       +-input_scan=
            |       | +-TableScan(column_list=DefinerRightsTvf.[Key#6, Value#7], table=KeyValue, column_index_list=[0, 1])
            |       +-filter_expr=
            |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |           +-ColumnRef(type=INT64, column=DefinerRightsTvf.Key#6)
            |           +-SubqueryExpr
            |             +-type=INT64
            |             +-subquery_type=SCALAR
            |             +-subquery=
            |               +-ProjectScan
            |                 +-column_list=[$inlined_DefinerRightsTvf.a#9]
            |                 +-input_scan=
            |                   +-WithRefScan(column_list=[$inlined_DefinerRightsTvf.a#9], with_query_name="$inlined_DefinerRightsTvf_scalar_args")
            +-original_inlined_view=<null>
            +-original_inlined_tvf=DefinerRightsTvf((INT64 a) -> TABLE<Key INT64, Value STRING>)
==

SELECT *
FROM JoinsTableArgToScannedTable(
  (SELECT `key`, `value` FROM TwoIntegers), "arg");
--
QueryStmt
+-output_column_list=
| +-JoinsTableArgToScannedTable.c#3 AS c [STRING]
| +-JoinsTableArgToScannedTable.key#4 AS key [INT64]
| +-JoinsTableArgToScannedTable.value#5 AS value [INT64]
+-query=
  +-ProjectScan
    +-column_list=JoinsTableArgToScannedTable.[c#3, key#4, value#5]
    +-input_scan=
      +-TVFScan
        +-column_list=JoinsTableArgToScannedTable.[c#3, key#4, value#5]
        +-tvf=JoinsTableArgToScannedTable((TABLE<key INT64, value INT64> arg_table, STRING arg_scalar) -> TABLE<c STRING, key INT64, value INT64>)
        +-signature=(TABLE<key INT64, value INT64>, literal STRING) -> TABLE<c STRING, key INT64, value INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=TwoIntegers.[key#1, value#2]
        | | |   +-input_scan=
        | | |     +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        | | +-argument_column_list=TwoIntegers.[key#1, value#2]
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="arg")
        +-column_index_list=[0, 1, 2]
        +-function_call_signature=(TABLE<key INT64, value INT64> arg_table, STRING arg_scalar) -> TABLE<c STRING, key INT64, value INT64>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-JoinsTableArgToScannedTable.c#3 AS c [STRING]
| +-JoinsTableArgToScannedTable.key#4 AS key [INT64]
| +-JoinsTableArgToScannedTable.value#5 AS value [INT64]
+-query=
  +-ProjectScan
    +-column_list=JoinsTableArgToScannedTable.[c#3, key#4, value#5]
    +-input_scan=
      +-WithScan
        +-column_list=JoinsTableArgToScannedTable.[c#3, key#4, value#5]
        +-with_entry_list=
        | +-WithEntry
        | | +-with_query_name="arg_table"
        | | +-with_subquery=
        | |   +-ProjectScan
        | |     +-column_list=TwoIntegers.[key#1, value#2]
        | |     +-input_scan=
        | |       +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        | +-WithEntry
        |   +-with_query_name="$inlined_JoinsTableArgToScannedTable_scalar_args"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[$inlined_JoinsTableArgToScannedTable.arg_scalar#8]
        |       +-expr_list=
        |       | +-arg_scalar#8 := Literal(type=STRING, value="arg")
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=JoinsTableArgToScannedTable.[c#3, key#4, value#5]
            +-expr_list=
            | +-c#3 :=
            |   +-SubqueryExpr
            |     +-type=STRING
            |     +-subquery_type=SCALAR
            |     +-subquery=
            |       +-ProjectScan
            |         +-column_list=[$inlined_JoinsTableArgToScannedTable.arg_scalar#9]
            |         +-input_scan=
            |           +-WithRefScan(column_list=[$inlined_JoinsTableArgToScannedTable.arg_scalar#9], with_query_name="$inlined_JoinsTableArgToScannedTable_scalar_args")
            +-input_scan=
              +-JoinScan
                +-column_list=[JoinsTableArgToScannedTable.key#4, JoinsTableArgToScannedTable.value#5, arg_table.key#6, arg_table.value#7]
                +-left_scan=
                | +-TableScan(column_list=JoinsTableArgToScannedTable.[key#4, value#5], table=TwoIntegers, column_index_list=[0, 1])
                +-right_scan=
                | +-WithRefScan(column_list=arg_table.[key#6, value#7], with_query_name="arg_table")
                +-join_expr=
                | +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
                |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                |   | +-ColumnRef(type=INT64, column=JoinsTableArgToScannedTable.key#4)
                |   | +-ColumnRef(type=INT64, column=arg_table.key#6)
                |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                |     +-ColumnRef(type=INT64, column=JoinsTableArgToScannedTable.value#5)
                |     +-ColumnRef(type=INT64, column=arg_table.value#7)
                +-has_using=TRUE

==

# Make sure order by in aggregate is not mangled by ORDER_BY_AND_LIMIT_IN_AGGREGATE rewriter
SELECT * FROM UnaryTableArgAggregatedWithOrderBy((SELECT a FROM abTable));
--
QueryStmt
+-output_column_list=
| +-UnaryTableArgAggregatedWithOrderBy.arr#3 AS arr [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[UnaryTableArgAggregatedWithOrderBy.arr#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryTableArgAggregatedWithOrderBy.arr#3]
        +-tvf=UnaryTableArgAggregatedWithOrderBy((TABLE<a INT64> arg0) -> TABLE<arr ARRAY<INT64>>)
        +-signature=(TABLE<a INT64>) -> TABLE<arr ARRAY<INT64>>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[abTable.a#1]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[abTable.a#1], table=abTable, column_index_list=[0])
        |   +-argument_column_list=[abTable.a#1]
        +-column_index_list=[0]
        +-function_call_signature=(TABLE<a INT64> arg0) -> TABLE<arr ARRAY<INT64>>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryTableArgAggregatedWithOrderBy.arr#3 AS arr [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[UnaryTableArgAggregatedWithOrderBy.arr#3]
    +-input_scan=
      +-WithScan
        +-column_list=[UnaryTableArgAggregatedWithOrderBy.arr#3]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[abTable.a#1]
        |       +-input_scan=
        |         +-TableScan(column_list=[abTable.a#1], table=abTable, column_index_list=[0])
        +-query=
          +-WithScan
            +-column_list=[UnaryTableArgAggregatedWithOrderBy.arr#3]
            +-with_entry_list=
            | +-WithEntry
            |   +-with_query_name="t"
            |   +-with_subquery=
            |     +-ProjectScan
            |       +-column_list=[$aggregate.arr#4]
            |       +-input_scan=
            |         +-ProjectScan
            |           +-column_list=[$aggregate.arr#4]
            |           +-expr_list=
            |           | +-arr#4 :=
            |           |   +-SubqueryExpr
            |           |     +-type=ARRAY<INT64>
            |           |     +-subquery_type=SCALAR
            |           |     +-parameter_list=
            |           |     | +-ColumnRef(type=ARRAY<STRUCT<a_0 INT64>>, column=$agg_rewriter.$array#7)
            |           |     +-subquery=
            |           |       +-ProjectScan
            |           |         +-column_list=[$with_expr.injected#10]
            |           |         +-expr_list=
            |           |         | +-injected#10 :=
            |           |         |   +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<INT64>, ARRAY<INT64>) -> ARRAY<INT64>)
            |           |         |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |           |         |     | +-FunctionCall(ZetaSQL:array_length(ARRAY<INT64>) -> INT64)
            |           |         |     | | +-ColumnRef(type=ARRAY<INT64>, column=null_if_empty_array.$out#9)
            |           |         |     | +-Literal(type=INT64, value=1)
            |           |         |     +-ColumnRef(type=ARRAY<INT64>, column=null_if_empty_array.$out#9)
            |           |         |     +-Literal(type=ARRAY<INT64>, value=NULL)
            |           |         +-input_scan=
            |           |           +-ProjectScan
            |           |             +-column_list=[null_if_empty_array.$out#9]
            |           |             +-expr_list=
            |           |             | +-$out#9 :=
            |           |             |   +-SubqueryExpr
            |           |             |     +-type=ARRAY<INT64>
            |           |             |     +-subquery_type=ARRAY
            |           |             |     +-parameter_list=
            |           |             |     | +-ColumnRef(type=ARRAY<STRUCT<a_0 INT64>>, column=$agg_rewriter.$array#7, is_correlated=TRUE)
            |           |             |     +-subquery=
            |           |             |       +-OrderByScan
            |           |             |         +-column_list=[$agg_rewriter.a#6]
            |           |             |         +-is_ordered=TRUE
            |           |             |         +-input_scan=
            |           |             |         | +-ProjectScan
            |           |             |         |   +-column_list=[$agg_rewriter.a#6]
            |           |             |         |   +-expr_list=
            |           |             |         |   | +-a#6 :=
            |           |             |         |   |   +-GetStructField
            |           |             |         |   |     +-type=INT64
            |           |             |         |   |     +-expr=
            |           |             |         |   |     | +-ColumnRef(type=STRUCT<a_0 INT64>, column=$agg_rewriter.$struct#8)
            |           |             |         |   |     +-field_idx=0
            |           |             |         |   +-input_scan=
            |           |             |         |     +-ArrayScan
            |           |             |         |       +-column_list=[$agg_rewriter.$struct#8]
            |           |             |         |       +-array_expr_list=
            |           |             |         |       | +-ColumnRef(type=ARRAY<STRUCT<a_0 INT64>>, column=$agg_rewriter.$array#7, is_correlated=TRUE)
            |           |             |         |       +-element_column_list=[$agg_rewriter.$struct#8]
            |           |             |         +-order_by_item_list=
            |           |             |           +-OrderByItem
            |           |             |             +-column_ref=
            |           |             |               +-ColumnRef(type=INT64, column=$agg_rewriter.a#6)
            |           |             +-input_scan=
            |           |               +-SingleRowScan
            |           +-input_scan=
            |             +-AggregateScan
            |               +-column_list=[$agg_rewriter.$array#7]
            |               +-input_scan=
            |               | +-WithRefScan(column_list=[arg0.a#5], with_query_name="arg0")
            |               +-aggregate_list=
            |                 +-$array#7 :=
            |                   +-AggregateFunctionCall(ZetaSQL:array_agg(STRUCT<a_0 INT64>) -> ARRAY<STRUCT<a_0 INT64>>)
            |                     +-MakeStruct
            |                       +-type=STRUCT<a_0 INT64>
            |                       +-field_list=
            |                         +-ColumnRef(type=INT64, column=arg0.a#5)
            +-query=
              +-ProjectScan
                +-column_list=[UnaryTableArgAggregatedWithOrderBy.arr#3]
                +-input_scan=
                  +-WithRefScan(column_list=[UnaryTableArgAggregatedWithOrderBy.arr#3], with_query_name="t")
==

[language_features=NONE,+MULTILEVEL_AGGREGATION,+TABLE_VALUED_FUNCTIONS,+WITH_EXPRESSION,+ORDER_BY_IN_AGGREGATE]
SELECT *
FROM tvf_templated_multi_agg_valid_grouping_constants(1);
--
QueryStmt
+-output_column_list=
| +-tvf_templated_multi_agg_valid_grouping_constants.result#1 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_multi_agg_valid_grouping_constants.result#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_multi_agg_valid_grouping_constants.result#1]
        +-tvf=tvf_templated_multi_agg_valid_grouping_constants((ANY TYPE) -> ANY TABLE)
        +-signature=(literal INT64) -> TABLE<result INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=1)
        +-column_index_list=[0]
        +-function_call_signature=(INT64) -> ANY TABLE

With Templated SQL TVF signature:
  tvf_templated_multi_agg_valid_grouping_constants(literal INT64) -> TABLE<result INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$aggregate.result#4 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.result#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.result#4]
        +-input_scan=
        | +-TableScan(column_list=[TwoIntegers.key#1], table=TwoIntegers, column_index_list=[0])
        +-aggregate_list=
          +-result#4 :=
            +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
              +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#3)
                +-ArgumentRef(type=INT64, name="int64_arg")
              +-group_by_list=
                +-$groupbymod#3 := ColumnRef(type=INT64, column=TwoIntegers.key#1)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-tvf_templated_multi_agg_valid_grouping_constants.result#1 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_multi_agg_valid_grouping_constants.result#1]
    +-input_scan=
      +-WithScan
        +-column_list=[tvf_templated_multi_agg_valid_grouping_constants.result#1]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="$inlined_tvf_templated_multi_agg_valid_grouping_constants_scalar_args"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[$inlined_tvf_templated_multi_agg_valid_grouping_constants.int64_arg#4]
        |       +-expr_list=
        |       | +-int64_arg#4 := Literal(type=INT64, value=1)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[tvf_templated_multi_agg_valid_grouping_constants.result#1]
            +-input_scan=
              +-AggregateScan
                +-column_list=[tvf_templated_multi_agg_valid_grouping_constants.result#1]
                +-input_scan=
                | +-TableScan(column_list=[TwoIntegers.key#2], table=TwoIntegers, column_index_list=[0])
                +-aggregate_list=
                  +-result#1 :=
                    +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                        +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#3)
                        +-SubqueryExpr
                          +-type=INT64
                          +-subquery_type=SCALAR
                          +-subquery=
                            +-ProjectScan
                              +-column_list=[$inlined_tvf_templated_multi_agg_valid_grouping_constants.int64_arg#5]
                              +-input_scan=
                                +-WithRefScan(column_list=[$inlined_tvf_templated_multi_agg_valid_grouping_constants.int64_arg#5], with_query_name="$inlined_tvf_templated_multi_agg_valid_grouping_constants_scalar_args")
                      +-group_by_list=
                        +-$groupbymod#3 := ColumnRef(type=INT64, column=TwoIntegers.key#2)
==

[language_features=NONE,+MULTILEVEL_AGGREGATION,+TABLE_VALUED_FUNCTIONS,+WITH_EXPRESSION,+ORDER_BY_IN_AGGREGATE]
SELECT *
FROM tvf_templated_multi_agg_invalid_grouping_constants(1);
--
ERROR: Invalid table-valued function tvf_templated_multi_agg_invalid_grouping_constants [at 2:6]
FROM tvf_templated_multi_agg_invalid_grouping_constants(1);
     ^
Analysis of table-valued function tvf_templated_multi_agg_invalid_grouping_constants failed [at 1:12]
SELECT SUM(value + int64_arg GROUP BY key) AS result FROM TwoIntegers
           ^
multi-level aggregate expression references column value which is neither grouped nor aggregated [at 1:12]
SELECT SUM(value + int64_arg GROUP BY key) AS result FROM TwoIntegers
           ^
==

[language_features=NONE,+TABLE_VALUED_FUNCTIONS]
SELECT *
FROM UnaryTableArgColumnsUnused(Table TwoIntegers)
--
QueryStmt
+-output_column_list=
| +-UnaryTableArgColumnsUnused.result#3 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryTableArgColumnsUnused.result#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[UnaryTableArgColumnsUnused.result#3]
        +-tvf=UnaryTableArgColumnsUnused((TABLE<key INT64, value INT64> arg0) -> TABLE<result INT64>)
        +-signature=(TABLE<key INT64, value INT64>) -> TABLE<result INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        |   +-argument_column_list=TwoIntegers.[key#1, value#2]
        +-column_index_list=[0]
        +-function_call_signature=(TABLE<key INT64, value INT64> arg0) -> TABLE<result INT64>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-UnaryTableArgColumnsUnused.result#3 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[UnaryTableArgColumnsUnused.result#3]
    +-input_scan=
      +-WithScan
        +-column_list=[UnaryTableArgColumnsUnused.result#3]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg0"
        |   +-with_subquery=
        |     +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        +-query=
          +-ProjectScan
            +-column_list=[UnaryTableArgColumnsUnused.result#3]
            +-expr_list=
            | +-result#3 := Literal(type=INT64, value=1)
            +-input_scan=
              +-WithRefScan(column_list=arg0.[key#4, value#5], with_query_name="arg0")
==

[language_features=NONE,+MULTILEVEL_AGGREGATION,+TABLE_VALUED_FUNCTIONS]
SELECT *
FROM TvfMultiAggNullary();
--
QueryStmt
+-output_column_list=
| +-TvfMultiAggNullary.result#1 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[TvfMultiAggNullary.result#1]
    +-input_scan=
      +-TVFScan(column_list=[TvfMultiAggNullary.result#1], tvf=TvfMultiAggNullary(() -> TABLE<result INT64>), signature=() -> TABLE<result INT64>, column_index_list=[0], function_call_signature=() -> TABLE<result INT64>)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-TvfMultiAggNullary.result#1 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[TvfMultiAggNullary.result#1]
    +-input_scan=
      +-WithScan
        +-column_list=[TvfMultiAggNullary.result#1]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="t"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=t.[a#2, b#3]
        |       +-expr_list=
        |       | +-a#2 := Literal(type=INT64, value=1)
        |       | +-b#3 := Literal(type=INT64, value=2)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[TvfMultiAggNullary.result#1]
            +-input_scan=
              +-AggregateScan
                +-column_list=[TvfMultiAggNullary.result#1]
                +-input_scan=
                | +-WithRefScan(column_list=t.[a#4, b#5], with_query_name="t")
                +-aggregate_list=
                  +-result#1 :=
                    +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                        +-ColumnRef(type=INT64, column=$aggregate.$agg1#8)
                        +-ColumnRef(type=INT64, column=$aggregate.$agg2#11)
                      +-group_by_list=
                      | +-$groupbymod#6 := ColumnRef(type=INT64, column=t.a#4)
                      | +-$groupbymod#7 := ColumnRef(type=INT64, column=t.b#5)
                      +-group_by_aggregate_list=
                        +-$agg1#8 :=
                        | +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
                        |   +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#9)
                        |   +-group_by_list=
                        |     +-$groupbymod#9 := ColumnRef(type=INT64, column=t.a#4)
                        |     +-$groupbymod#10 := ColumnRef(type=INT64, column=t.b#5)
                        +-$agg2#11 :=
                          +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
                            +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#13)
                            +-group_by_list=
                              +-$groupbymod#12 := ColumnRef(type=INT64, column=t.a#4)
                              +-$groupbymod#13 := ColumnRef(type=INT64, column=t.b#5)
==

[language_features=NONE,+MULTILEVEL_AGGREGATION,+TABLE_VALUED_FUNCTIONS,+GROUP_BY_STRUCT]
SELECT *
FROM TvfMultiAggGroupingConstantsWithStruct((SELECT STRUCT(STRUCT(1 as b) as a)), 1);
--
QueryStmt
+-output_column_list=
| +-TvfMultiAggGroupingConstantsWithStruct.result#2 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[TvfMultiAggGroupingConstantsWithStruct.result#2]
    +-input_scan=
      +-TVFScan
        +-column_list=[TvfMultiAggGroupingConstantsWithStruct.result#2]
        +-tvf=TvfMultiAggGroupingConstantsWithStruct((TABLE<STRUCT<a STRUCT<b INT64>>> arg_table, INT64 int64_arg) -> TABLE<result INT64>)
        +-signature=(TABLE<$col1 STRUCT<a STRUCT<b INT64>>>, literal INT64) -> TABLE<result INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery1.$col1#1]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=STRUCT<a STRUCT<b INT64>>, value={a:{b:1}})
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery1.$col1#1]
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=1)
        +-column_index_list=[0]
        +-function_call_signature=(TABLE<STRUCT<a STRUCT<b INT64>>> arg_table, INT64 int64_arg) -> TABLE<result INT64>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-TvfMultiAggGroupingConstantsWithStruct.result#2 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[TvfMultiAggGroupingConstantsWithStruct.result#2]
    +-input_scan=
      +-WithScan
        +-column_list=[TvfMultiAggGroupingConstantsWithStruct.result#2]
        +-with_entry_list=
        | +-WithEntry
        | | +-with_query_name="arg_table"
        | | +-with_subquery=
        | |   +-ProjectScan
        | |     +-column_list=[$subquery1.$col1#1]
        | |     +-expr_list=
        | |     | +-$col1#1 := Literal(type=STRUCT<a STRUCT<b INT64>>, value={a:{b:1}})
        | |     +-input_scan=
        | |       +-SingleRowScan
        | +-WithEntry
        |   +-with_query_name="$inlined_TvfMultiAggGroupingConstantsWithStruct_scalar_args"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[$inlined_TvfMultiAggGroupingConstantsWithStruct.int64_arg#5]
        |       +-expr_list=
        |       | +-int64_arg#5 := Literal(type=INT64, value=1)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[TvfMultiAggGroupingConstantsWithStruct.result#2]
            +-input_scan=
              +-AggregateScan
                +-column_list=[TvfMultiAggGroupingConstantsWithStruct.result#2]
                +-input_scan=
                | +-WithRefScan(column_list=[arg_table.$value_column#3], with_query_name="arg_table")
                +-aggregate_list=
                  +-result#2 :=
                    +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                        +-GetStructField
                        | +-type=INT64
                        | +-expr=
                        | | +-ColumnRef(type=STRUCT<b INT64>, column=$group_by_list.$groupbymod#4)
                        | +-field_idx=0
                        +-SubqueryExpr
                          +-type=INT64
                          +-subquery_type=SCALAR
                          +-subquery=
                            +-ProjectScan
                              +-column_list=[$inlined_TvfMultiAggGroupingConstantsWithStruct.int64_arg#6]
                              +-input_scan=
                                +-WithRefScan(column_list=[$inlined_TvfMultiAggGroupingConstantsWithStruct.int64_arg#6], with_query_name="$inlined_TvfMultiAggGroupingConstantsWithStruct_scalar_args")
                      +-group_by_list=
                        +-$groupbymod#4 :=
                          +-GetStructField
                            +-type=STRUCT<b INT64>
                            +-expr=
                            | +-ColumnRef(type=STRUCT<a STRUCT<b INT64>>, column=arg_table.$value_column#3)
                            +-field_idx=0
==

[language_features=NONE,+MULTILEVEL_AGGREGATION,+TABLE_VALUED_FUNCTIONS,+GROUP_BY_STRUCT]
SELECT *
FROM tvf_templated_multi_agg_valid_grouping_constants_with_struct((SELECT STRUCT(1 as b) as a));
--
QueryStmt
+-output_column_list=
| +-tvf_templated_multi_agg_valid_grouping_constants_with_struct.result#2 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_multi_agg_valid_grouping_constants_with_struct.result#2]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_multi_agg_valid_grouping_constants_with_struct.result#2]
        +-tvf=tvf_templated_multi_agg_valid_grouping_constants_with_struct((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<a STRUCT<b INT64>>) -> TABLE<result INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.a#1]
        |   |   +-expr_list=
        |   |   | +-a#1 := Literal(type=STRUCT<b INT64>, value={b:1})
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.a#1]
        +-column_index_list=[0]
        +-function_call_signature=(ANY TABLE) -> ANY TABLE

With Templated SQL TVF signature:
  tvf_templated_multi_agg_valid_grouping_constants_with_struct(TABLE<a STRUCT<b INT64>>) -> TABLE<result INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$aggregate.result#3 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.result#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.result#3]
        +-input_scan=
        | +-RelationArgumentScan(column_list=[arg_table.a#1], name="arg_table")
        +-aggregate_list=
          +-result#3 :=
            +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
              +-GetStructField
                +-type=INT64
                +-expr=
                | +-ColumnRef(type=STRUCT<b INT64>, column=$group_by_list.$groupbymod#2)
                +-field_idx=0
              +-group_by_list=
                +-$groupbymod#2 := ColumnRef(type=STRUCT<b INT64>, column=arg_table.a#1)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-tvf_templated_multi_agg_valid_grouping_constants_with_struct.result#2 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_multi_agg_valid_grouping_constants_with_struct.result#2]
    +-input_scan=
      +-WithScan
        +-column_list=[tvf_templated_multi_agg_valid_grouping_constants_with_struct.result#2]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg_table"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[$subquery1.a#1]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=STRUCT<b INT64>, value={b:1})
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[tvf_templated_multi_agg_valid_grouping_constants_with_struct.result#2]
            +-input_scan=
              +-AggregateScan
                +-column_list=[tvf_templated_multi_agg_valid_grouping_constants_with_struct.result#2]
                +-input_scan=
                | +-WithRefScan(column_list=[arg_table.a#3], with_query_name="arg_table")
                +-aggregate_list=
                  +-result#2 :=
                    +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                      +-GetStructField
                        +-type=INT64
                        +-expr=
                        | +-ColumnRef(type=STRUCT<b INT64>, column=$group_by_list.$groupbymod#4)
                        +-field_idx=0
                      +-group_by_list=
                        +-$groupbymod#4 := ColumnRef(type=STRUCT<b INT64>, column=arg_table.a#3)
==

[language_features=NONE,+MULTILEVEL_AGGREGATION,+TABLE_VALUED_FUNCTIONS]
SELECT *
FROM tvf_templated_call_udf_with_multi_agg(TABLE TwoIntegers);
--
QueryStmt
+-output_column_list=
| +-tvf_templated_call_udf_with_multi_agg.result#3 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_call_udf_with_multi_agg.result#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_call_udf_with_multi_agg.result#3]
        +-tvf=tvf_templated_call_udf_with_multi_agg((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<key INT64, value INT64>) -> TABLE<result INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        |   +-argument_column_list=TwoIntegers.[key#1, value#2]
        +-column_index_list=[0]
        +-function_call_signature=(ANY TABLE) -> ANY TABLE

With Templated SQL TVF signature:
  tvf_templated_call_udf_with_multi_agg(TABLE<key INT64, value INT64>) -> TABLE<result INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.result#1 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.result#1]
    +-expr_list=
    | +-result#1 := FunctionCall(Lazy_resolution_function:NullaryWithMultilevelAgg() -> INT64)
    +-input_scan=
      +-SingleRowScan

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-tvf_templated_call_udf_with_multi_agg.result#3 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_call_udf_with_multi_agg.result#3]
    +-input_scan=
      +-WithScan
        +-column_list=[tvf_templated_call_udf_with_multi_agg.result#3]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg_table"
        |   +-with_subquery=
        |     +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        +-query=
          +-ProjectScan
            +-column_list=[tvf_templated_call_udf_with_multi_agg.result#3]
            +-expr_list=
            | +-result#3 :=
            |   +-SubqueryExpr
            |     +-type=INT64
            |     +-subquery_type=SCALAR
            |     +-subquery=
            |       +-ProjectScan
            |         +-column_list=[$aggregate.$agg1#4]
            |         +-input_scan=
            |           +-AggregateScan
            |             +-column_list=[$aggregate.$agg1#4]
            |             +-input_scan=
            |             | +-ArrayScan
            |             |   +-column_list=[$array.x#5]
            |             |   +-array_expr_list=
            |             |   | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3, 3])
            |             |   +-element_column_list=[$array.x#5]
            |             +-aggregate_list=
            |               +-$agg1#4 :=
            |                 +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
            |                   +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#6)
            |                   +-group_by_list=
            |                     +-$groupbymod#6 := ColumnRef(type=INT64, column=$array.x#5)
            +-input_scan=
              +-SingleRowScan
==

[language_features=NONE,+MULTILEVEL_AGGREGATION,+TABLE_VALUED_FUNCTIONS]
SELECT *
FROM tvf_templated_call_uda_with_multi_agg(TABLE TwoIntegers);
--
QueryStmt
+-output_column_list=
| +-tvf_templated_call_uda_with_multi_agg.result#3 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_call_uda_with_multi_agg.result#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_call_uda_with_multi_agg.result#3]
        +-tvf=tvf_templated_call_uda_with_multi_agg((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<key INT64, value INT64>) -> TABLE<result INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        |   +-argument_column_list=TwoIntegers.[key#1, value#2]
        +-column_index_list=[0]
        +-function_call_signature=(ANY TABLE) -> ANY TABLE

With Templated SQL TVF signature:
  tvf_templated_call_uda_with_multi_agg(TABLE<key INT64, value INT64>) -> TABLE<result INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$aggregate.result#3 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.result#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.result#3]
        +-input_scan=
        | +-RelationArgumentScan(column_list=arg_table.[key#1, value#2], name="arg_table")
        +-aggregate_list=
          +-result#3 :=
            +-AggregateFunctionCall(Lazy_resolution_function:SumOfValuesForDistinctKey(INT64 value, INT64 key) -> INT64)
              +-ColumnRef(type=INT64, column=arg_table.key#1)
              +-ColumnRef(type=INT64, column=arg_table.value#2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-tvf_templated_call_uda_with_multi_agg.result#3 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_call_uda_with_multi_agg.result#3]
    +-input_scan=
      +-WithScan
        +-column_list=[tvf_templated_call_uda_with_multi_agg.result#3]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="arg_table"
        |   +-with_subquery=
        |     +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        +-query=
          +-ProjectScan
            +-column_list=[tvf_templated_call_uda_with_multi_agg.result#3]
            +-input_scan=
              +-ProjectScan
                +-column_list=[tvf_templated_call_uda_with_multi_agg.result#3]
                +-expr_list=
                | +-result#3 := ColumnRef(type=INT64, column=$aggregate.$agg1#8)
                +-input_scan=
                  +-AggregateScan
                    +-column_list=[$aggregate.$agg1#8]
                    +-input_scan=
                    | +-ProjectScan
                    |   +-column_list=[arg_table.key#4, arg_table.value#5, $inlined_SumOfValuesForDistinctKey.value#6, $inlined_SumOfValuesForDistinctKey.key#7]
                    |   +-expr_list=
                    |   | +-value#6 := ColumnRef(type=INT64, column=arg_table.key#4)
                    |   | +-key#7 := ColumnRef(type=INT64, column=arg_table.value#5)
                    |   +-input_scan=
                    |     +-WithRefScan(column_list=arg_table.[key#4, value#5], with_query_name="arg_table")
                    +-aggregate_list=
                      +-$agg1#8 :=
                        +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                          +-ColumnRef(type=INT64, column=$aggregate.$agg1#10)
                          +-group_by_list=
                          | +-$groupbymod#9 := ColumnRef(type=INT64, column=$inlined_SumOfValuesForDistinctKey.key#7)
                          +-group_by_aggregate_list=
                            +-$agg1#10 :=
                              +-AggregateFunctionCall(ZetaSQL:any_value(INT64) -> INT64)
                                +-ColumnRef(type=INT64, column=$inlined_SumOfValuesForDistinctKey.value#6)
==

[language_features=NONE,+MULTILEVEL_AGGREGATION,+TABLE_VALUED_FUNCTIONS]
SELECT * FROM TvfMultiAggReferencesScannedTable(TABLE TwoIntegers, ((SELECT value FROM TwoIntegers)));
--
QueryStmt
+-output_column_list=
| +-TvfMultiAggReferencesScannedTable.result#5 AS result [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[TvfMultiAggReferencesScannedTable.result#5]
    +-input_scan=
      +-TVFScan
        +-column_list=[TvfMultiAggReferencesScannedTable.result#5]
        +-tvf=TvfMultiAggReferencesScannedTable((TABLE<key INT64, value INT64> arg_table, INT64 arg_scalar) -> TABLE<result DOUBLE>)
        +-signature=(TABLE<key INT64, value INT64>, INT64) -> TABLE<result DOUBLE>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        | | +-argument_column_list=TwoIntegers.[key#1, value#2]
        | +-FunctionArgument
        |   +-expr=
        |     +-SubqueryExpr
        |       +-type=INT64
        |       +-subquery_type=SCALAR
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[TwoIntegers.value#4]
        |           +-input_scan=
        |             +-TableScan(column_list=[TwoIntegers.value#4], table=TwoIntegers, column_index_list=[1])
        +-column_index_list=[0]
        +-function_call_signature=(TABLE<key INT64, value INT64> arg_table, INT64 arg_scalar) -> TABLE<result DOUBLE>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-TvfMultiAggReferencesScannedTable.result#5 AS result [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[TvfMultiAggReferencesScannedTable.result#5]
    +-input_scan=
      +-WithScan
        +-column_list=[TvfMultiAggReferencesScannedTable.result#5]
        +-with_entry_list=
        | +-WithEntry
        | | +-with_query_name="arg_table"
        | | +-with_subquery=
        | |   +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        | +-WithEntry
        |   +-with_query_name="$inlined_TvfMultiAggReferencesScannedTable_scalar_args"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[$inlined_TvfMultiAggReferencesScannedTable.arg_scalar#16]
        |       +-expr_list=
        |       | +-arg_scalar#16 :=
        |       |   +-SubqueryExpr
        |       |     +-type=INT64
        |       |     +-subquery_type=SCALAR
        |       |     +-subquery=
        |       |       +-ProjectScan
        |       |         +-column_list=[TwoIntegers.value#4]
        |       |         +-input_scan=
        |       |           +-TableScan(column_list=[TwoIntegers.value#4], table=TwoIntegers, column_index_list=[1])
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[TvfMultiAggReferencesScannedTable.result#5]
            +-expr_list=
            | +-result#5 :=
            |   +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
            |     +-FunctionCall(ZetaSQL:$divide(DOUBLE, DOUBLE) -> DOUBLE)
            |     | +-Cast(INT64 -> DOUBLE)
            |     | | +-ColumnRef(type=INT64, column=$aggregate.$agg1#6)
            |     | +-Cast(INT64 -> DOUBLE)
            |     |   +-ColumnRef(type=INT64, column=$aggregate.$agg2#7)
            |     +-Cast(INT64 -> DOUBLE)
            |       +-SubqueryExpr
            |         +-type=INT64
            |         +-subquery_type=SCALAR
            |         +-subquery=
            |           +-ProjectScan
            |             +-column_list=[$inlined_TvfMultiAggReferencesScannedTable.arg_scalar#17]
            |             +-input_scan=
            |               +-WithRefScan(column_list=[$inlined_TvfMultiAggReferencesScannedTable.arg_scalar#17], with_query_name="$inlined_TvfMultiAggReferencesScannedTable_scalar_args")
            +-input_scan=
              +-AggregateScan
                +-column_list=$aggregate.[$agg1#6, $agg2#7]
                +-input_scan=
                | +-JoinScan
                |   +-column_list=[TwoIntegers.key#8, TwoIntegers.value#9, arg_table.key#10, arg_table.value#11]
                |   +-left_scan=
                |   | +-TableScan(column_list=TwoIntegers.[key#8, value#9], table=TwoIntegers, column_index_list=[0, 1])
                |   +-right_scan=
                |   | +-WithRefScan(column_list=arg_table.[key#10, value#11], with_query_name="arg_table")
                |   +-join_expr=
                |   | +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
                |   |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                |   |   | +-ColumnRef(type=INT64, column=TwoIntegers.key#8)
                |   |   | +-ColumnRef(type=INT64, column=arg_table.key#10)
                |   |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                |   |     +-ColumnRef(type=INT64, column=TwoIntegers.value#9)
                |   |     +-ColumnRef(type=INT64, column=arg_table.value#11)
                |   +-has_using=TRUE
                +-aggregate_list=
                  +-$agg1#6 :=
                  | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                  |   +-ColumnRef(type=INT64, column=$aggregate.$agg1#13)
                  |   +-group_by_list=
                  |   | +-$groupbymod#12 := ColumnRef(type=INT64, column=TwoIntegers.key#8)
                  |   +-group_by_aggregate_list=
                  |     +-$agg1#13 :=
                  |       +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                  |         +-ColumnRef(type=INT64, column=TwoIntegers.value#9)
                  +-$agg2#7 :=
                    +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                      +-ColumnRef(type=INT64, column=$aggregate.$agg1#15)
                      +-group_by_list=
                      | +-$groupbymod#14 := ColumnRef(type=INT64, column=TwoIntegers.value#9)
                      +-group_by_aggregate_list=
                        +-$agg1#15 :=
                          +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
                            +-ColumnRef(type=INT64, column=TwoIntegers.key#8)
==

[language_features=NONE,+MULTILEVEL_AGGREGATION,+TABLE_VALUED_FUNCTIONS]
SELECT * FROM TvfMultiAggScalarArgGroupingConst(TABLE TwoIntegers, 100);
--
QueryStmt
+-output_column_list=
| +-TvfMultiAggScalarArgGroupingConst.result#3 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[TvfMultiAggScalarArgGroupingConst.result#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[TvfMultiAggScalarArgGroupingConst.result#3]
        +-tvf=TvfMultiAggScalarArgGroupingConst((TABLE<key INT64, value INT64> arg_table, INT64 arg_scalar) -> TABLE<result INT64>)
        +-signature=(TABLE<key INT64, value INT64>, literal INT64) -> TABLE<result INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        | | +-argument_column_list=TwoIntegers.[key#1, value#2]
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=100)
        +-column_index_list=[0]
        +-function_call_signature=(TABLE<key INT64, value INT64> arg_table, INT64 arg_scalar) -> TABLE<result INT64>

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-TvfMultiAggScalarArgGroupingConst.result#3 AS result [INT64]
+-query=
  +-ProjectScan
    +-column_list=[TvfMultiAggScalarArgGroupingConst.result#3]
    +-input_scan=
      +-WithScan
        +-column_list=[TvfMultiAggScalarArgGroupingConst.result#3]
        +-with_entry_list=
        | +-WithEntry
        | | +-with_query_name="arg_table"
        | | +-with_subquery=
        | |   +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        | +-WithEntry
        |   +-with_query_name="$inlined_TvfMultiAggScalarArgGroupingConst_scalar_args"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[$inlined_TvfMultiAggScalarArgGroupingConst.arg_scalar#8]
        |       +-expr_list=
        |       | +-arg_scalar#8 := Literal(type=INT64, value=100)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[TvfMultiAggScalarArgGroupingConst.result#3]
            +-input_scan=
              +-AggregateScan
                +-column_list=[TvfMultiAggScalarArgGroupingConst.result#3]
                +-input_scan=
                | +-WithRefScan(column_list=arg_table.[key#4, value#5], with_query_name="arg_table")
                +-aggregate_list=
                  +-result#3 :=
                    +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                        +-ColumnRef(type=INT64, column=$aggregate.$agg1#7)
                        +-SubqueryExpr
                          +-type=INT64
                          +-subquery_type=SCALAR
                          +-subquery=
                            +-ProjectScan
                              +-column_list=[$inlined_TvfMultiAggScalarArgGroupingConst.arg_scalar#9]
                              +-input_scan=
                                +-WithRefScan(column_list=[$inlined_TvfMultiAggScalarArgGroupingConst.arg_scalar#9], with_query_name="$inlined_TvfMultiAggScalarArgGroupingConst_scalar_args")
                      +-group_by_list=
                      | +-$groupbymod#6 := ColumnRef(type=INT64, column=arg_table.value#5)
                      +-group_by_aggregate_list=
                        +-$agg1#7 :=
                          +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
                            +-ColumnRef(type=INT64, column=arg_table.key#4)
