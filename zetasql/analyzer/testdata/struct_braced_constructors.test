[default language_features=BRACED_PROTO_CONSTRUCTORS,CAST_DIFFERENT_ARRAY_TYPES,PROTO_EXTENSIONS_WITH_NEW,WITH_ON_SUBQUERY,WITH_RECURSIVE,STRUCT_BRACED_CONSTRUCTORS]

[language_features=]
SELECT STRUCT {}
--
ERROR: Braced constructors are not supported [at 1:15]
SELECT STRUCT {}
              ^
==

# Error
SELECT {}
--
ERROR: Unable to infer a type for braced constructor [at 1:8]
SELECT {}
       ^
==


[show_sqlbuilder_output]
SELECT STRUCT {}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<>, value={})
    +-input_scan=
      +-SingleRowScan

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT
  STRUCT< > () AS a_1;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
SELECT
  STRUCT< > () AS a_1;
==

# Error using braced constructors without an inferred type.
SELECT { abc: 1 }
--
ERROR: Unable to infer a type for braced constructor [at 1:8]
SELECT { abc: 1 }
       ^
==

# Match examples from the designdoc: http://shortn/_OYQOTcX2AM
# Pattern 1: explicit type
# Positions and names matched
SELECT STRUCT<a INT64, b STRING>{a:1, b:"foo"}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<a INT64, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<a INT64, b STRING>, value={a:1, b:"foo"}, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Positions and names matched, INT64 coerces to DOUBLE.
SELECT STRUCT<a DOUBLE, b STRING>{a:1, b:"foo"}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<a DOUBLE, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<a DOUBLE, b STRING>, value={a:1, b:"foo"}, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Error: Positions mismatched, names are matched.
SELECT STRUCT<a INT64, b STRING>{b:"foo", a:1}
--
ERROR: Require naming match but field name does not match at position 0: 'a' vs 'b' [at 1:34]
SELECT STRUCT<a INT64, b STRING>{b:"foo", a:1}
                                 ^
==

# Error: Positions mismatched, skipping "a".
SELECT STRUCT<a INT64, b STRING>{b:"foo"}
--
ERROR: STRUCT type has 2 fields but constructor call has 1 fields [at 1:8]
SELECT STRUCT<a INT64, b STRING>{b:"foo"}
       ^
==

# Error: Positions are matched, names mismatched.
SELECT STRUCT<a INT64>{b:1}
--
ERROR: Require naming match but field name does not match at position 0: 'a' vs 'b' [at 1:24]
SELECT STRUCT<a INT64>{b:1}
                       ^
==

# Error: Positions are matched, names missing.
SELECT STRUCT<INT64>{a:1}
--
ERROR: Require naming match but field name does not match at position 0: '' vs 'a' [at 1:22]
SELECT STRUCT<INT64>{a:1}
                     ^
==

# Pattern 2: Bare STRUCT
# struct_system_variable type: STRUCT<c INT64, d STRUCT<a INT64, b STRING>>
# OK
SET @@struct_system_variable = STRUCT{c:1, d: {a:2, b:'foo'}}
--
AssignmentStmt
+-target=
| +-SystemVariable(struct_system_variable, type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>)
+-expr=
  +-Literal(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, value={c:1, d:{a:2, b:"foo"}})
==

# struct_system_variable type: STRUCT<c INT64, d STRUCT<a INT64, b STRING>>
# Error:Setting struct system variables with imcompatible type.
SET @@struct_system_variable = STRUCT{c:1, d: 2}
--
ERROR: Expected type STRUCT<c INT32, d STRUCT<a INT32, b STRING>>; found STRUCT<c INT64, d INT64> [at 1:32]
SET @@struct_system_variable = STRUCT{c:1, d: 2}
                               ^
==

# Pattern 3: Bare braces

# Error: no expected type
SELECT {b: "foo"}
--
ERROR: Unable to infer a type for braced constructor [at 1:8]
SELECT {b: "foo"}
       ^
==

# struct_system_variable type: STRUCT<c INT64, d STRUCT<a INT64, b STRING>>
# OK
SET @@struct_system_variable = {c:1, d: {a:2, b:'foo'}}
--
AssignmentStmt
+-target=
| +-SystemVariable(struct_system_variable, type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>)
+-expr=
  +-Literal(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, value={c:1, d:{a:2, b:"foo"}})
==

# struct_system_variable type: STRUCT<c INT64, d STRUCT<a INT64, b STRING>>
# Error: Name mismatch
SET @@struct_system_variable = {c:1, d: {a:2, e:'foo'}}
--
ERROR: Require naming match but field name does not match at position 1: 'b' vs 'e' [at 1:47]
SET @@struct_system_variable = {c:1, d: {a:2, e:'foo'}}
                                              ^
==

# struct_system_variable type: STRUCT<c INT64, d STRUCT<a INT64, b STRING>>
# Error: Name missing
SET @@struct_system_variable = {c:1}
--
ERROR: Require naming match but field num does not match, expected: 2, actual: 1 [at 1:32]
SET @@struct_system_variable = {c:1}
                               ^
==

# Error: STRUCT should not use proto extension.
SELECT STRUCT {(a.b): 1}
--
ERROR: Fields in STRUCT Braced constructor should always have a single identifier specified, not a path expression [at 1:16]
SELECT STRUCT {(a.b): 1}
               ^
==

# Compatible test.
# New syntax wraps old syntax.
SELECT STRUCT {
  value: STRUCT ("foo", "bar")
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<value STRUCT<STRING, STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<value STRUCT<STRING, STRING>>, value={value:{"foo", "bar"}})
    +-input_scan=
      +-SingleRowScan
==

# old syntax wraps new syntax
SELECT STRUCT (
  STRUCT {foo: "foo", bar: "bar"} AS value
)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<value STRUCT<foo STRING, bar STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<value STRUCT<foo STRING, bar STRING>>, value={value:{foo:"foo", bar:"bar"}})
    +-input_scan=
      +-SingleRowScan
==

# Edge case: Duplicated field names are OK.
SELECT STRUCT<a DOUBLE, a STRING>{a:1, a:"foo"}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<a DOUBLE, a STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<a DOUBLE, a STRING>, value={a:1, a:"foo"}, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# A simple field + string array example.
SELECT STRUCT {
        int32_val2: 5,
        str_value: ["abc", "def"]
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<int32_val2 INT64, str_value ARRAY<STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<int32_val2 INT64, str_value ARRAY<STRING>>, value={int32_val2:5, str_value:["abc", "def"]})
    +-input_scan=
      +-SingleRowScan
==

# An integer array example.
SELECT STRUCT {
    int64_key_1: 1,
    int64_key_2: 2,
    repeated_int32_val: [1, 2]
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<int64_key_1 INT64, int64_key_2 INT64, repeated_int32_val ARRAY<INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<int64_key_1 INT64, int64_key_2 INT64, repeated_int32_val ARRAY<INT64>>, value={int64_key_1:1, int64_key_2:2, repeated_int32_val:[1, 2]})
    +-input_scan=
      +-SingleRowScan
==

SELECT STRUCT {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: STRUCT {
    nested_int64: 10
  }
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>>, value={int64_key_1:1, int64_key_2:2, nested_value:{nested_int64:10}})
    +-input_scan=
      +-SingleRowScan
==

# Example using expression for the leaf values.
SELECT STRUCT {
        int32_val1: coalesce(4),
        int32_val2: cast(4 as uint64)
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<int32_val1 INT64, int32_val2 UINT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeStruct
    |     +-type=STRUCT<int32_val1 INT64, int32_val2 UINT64>
    |     +-field_list=
    |       +-FunctionCall(ZetaSQL:coalesce(repeated(1) INT64) -> INT64)
    |       | +-Literal(type=INT64, value=4)
    |       +-Literal(type=UINT64, value=4, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Example using a sub-query.
SELECT STRUCT {
  int32_val1: (SELECT key FROM TestTable)
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [STRUCT<int32_val1 INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-MakeStruct
    |     +-type=STRUCT<int32_val1 INT32>
    |     +-field_list=
    |       +-SubqueryExpr
    |         +-type=INT32
    |         +-subquery_type=SCALAR
    |         +-subquery=
    |           +-ProjectScan
    |             +-column_list=[TestTable.key#1]
    |             +-input_scan=
    |               +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
    +-input_scan=
      +-SingleRowScan
==

# Error:Non-scalar subquery.
SELECT STRUCT {
  int32_val1: (SELECT TestTable.* FROM TestTable)
}
--
ERROR: Scalar subquery cannot have more than one column unless using SELECT AS STRUCT to build STRUCT values [at 2:15]
  int32_val1: (SELECT TestTable.* FROM TestTable)
              ^
==

# Filling STRUCT fields from an external query.
SELECT STRUCT {int32_val1: t.int32_val1,
               int32_val2: t.int32_val2}
from (SELECT 1 int32_val1, 2 int32_val2) t
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [STRUCT<int32_val1 INT64, int32_val2 INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-MakeStruct
    |     +-type=STRUCT<int32_val1 INT64, int32_val2 INT64>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=t.int32_val1#1)
    |       +-ColumnRef(type=INT64, column=t.int32_val2#2)
    +-input_scan=
      +-ProjectScan
        +-column_list=t.[int32_val1#1, int32_val2#2]
        +-expr_list=
        | +-int32_val1#1 := Literal(type=INT64, value=1)
        | +-int32_val2#2 := Literal(type=INT64, value=2)
        +-input_scan=
          +-SingleRowScan
==

# Mixing with aggregation.
# ANY_VALUE is necessary here because we don't detect it is the same
# expression as shows up in GROUP BY.
SELECT STRUCT {
  int64_key_1: ANY_VALUE(KitchenSink.int64_key_1),
  int64_key_2: ANY_VALUE(KitchenSink.int64_key_2),
  int64_val: count(*),
  uint64_val: sum(length(KitchenSink.string_val)),
  repeated_string_val: array_agg(KitchenSink.string_val)}
from TestTable
group by KitchenSink.int64_key_1, KitchenSink.int64_key_2
--
QueryStmt
+-output_column_list=
| +-$query.$col1#11 AS `$col1` [STRUCT<int64_key_1 INT64, int64_key_2 INT64, int64_val INT64, uint64_val INT64, repeated_string_val ARRAY<STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#11]
    +-expr_list=
    | +-$col1#11 :=
    |   +-MakeStruct
    |     +-type=STRUCT<int64_key_1 INT64, int64_key_2 INT64, int64_val INT64, uint64_val INT64, repeated_string_val ARRAY<STRING>>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=$aggregate.$agg1#4)
    |       +-ColumnRef(type=INT64, column=$aggregate.$agg2#5)
    |       +-ColumnRef(type=INT64, column=$aggregate.$agg3#6)
    |       +-ColumnRef(type=INT64, column=$aggregate.$agg4#7)
    |       +-ColumnRef(type=ARRAY<STRING>, column=$aggregate.$agg5#8)
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#4, $agg2#5, $agg3#6, $agg4#7, $agg5#8]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-group_by_list=
        | +-int64_key_1#9 :=
        | | +-GetProtoField
        | |   +-type=INT64
        | |   +-expr=
        | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        | |   +-field_descriptor=int64_key_1
        | +-int64_key_2#10 :=
        |   +-GetProtoField
        |     +-type=INT64
        |     +-expr=
        |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |     +-field_descriptor=int64_key_2
        +-aggregate_list=
          +-$agg1#4 :=
          | +-AggregateFunctionCall(ZetaSQL:any_value(INT64) -> INT64)
          |   +-GetProtoField
          |     +-type=INT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int64_key_1
          +-$agg2#5 :=
          | +-AggregateFunctionCall(ZetaSQL:any_value(INT64) -> INT64)
          |   +-GetProtoField
          |     +-type=INT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int64_key_2
          +-$agg3#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
          +-$agg4#7 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
          |     +-GetProtoField
          |       +-type=STRING
          |       +-expr=
          |       | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |       +-field_descriptor=string_val
          |       +-default_value="default_name"
          +-$agg5#8 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(STRING) -> ARRAY<STRING>)
              +-GetProtoField
                +-type=STRING
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=string_val
                +-default_value="default_name"
==

# Mixing with other expressions.
SELECT 1 + STRUCT {int32_val1: 5}.int32_val1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Literal(type=INT64, value=1)
    |     +-GetStructField
    |       +-type=INT64
    |       +-expr=
    |       | +-Literal(type=STRUCT<int32_val1 INT64>, value={int32_val1:5})
    |       +-field_idx=0
    +-input_scan=
      +-SingleRowScan
==

# Untyped constructor.
# type of TestStruct: STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
UPDATE SimpleTypesWithStruct SET TestStruct = {
  c: 1,
  d: {
    a: 2,
    b: "bar",
  }
}
WHERE TRUE;
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=[SimpleTypesWithStruct.TestStruct#3], table=SimpleTypesWithStruct, column_index_list=[2])
+-column_access_list=WRITE
+-where_expr=
| +-Literal(type=BOOL, value=true)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=SimpleTypesWithStruct.TestStruct#3)
    +-set_value=
      +-DMLValue
        +-value=
          +-Literal(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, value={c:1, d:{a:2, b:"bar"}})
==

# Array constructor.
SELECT ARRAY<STRUCT<str_value ARRAY<string>>>[{
    str_value: ["foo", "bar"]
  }, {
    str_value: ["baz"]
  }]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<str_value ARRAY<STRING>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=ARRAY<STRUCT<str_value ARRAY<STRING>>>, value=[{str_value:["foo", "bar"]}, {str_value:["baz"]}], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Mixed use of struct and proto
# Complex array constructor.
# STRUCT<a INT64, b ARRAY<STRUCT<kitchen_sink KitchenSinkPB>>>
UPDATE StructWithKitchenSinkTable SET t = {
    a: 1,
    b: [
      {
        kitchen_sink: {int64_key_1: 1, int64_key_2: 2}
      },
      {
        kitchen_sink: {int64_key_1: 3, int64_key_2: 4}
      }
    ]
}
WHERE TRUE;
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=[StructWithKitchenSinkTable.t#3], table=StructWithKitchenSinkTable, column_index_list=[2])
+-column_access_list=WRITE
+-where_expr=
| +-Literal(type=BOOL, value=true)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRUCT<a INT64, b ARRAY<STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>>, column=StructWithKitchenSinkTable.t#3)
    +-set_value=
      +-DMLValue
        +-value=
          +-MakeStruct
            +-type=STRUCT<a INT64, b ARRAY<STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>>
            +-field_list=
              +-Literal(type=INT64, value=1)
              +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>) -> ARRAY<STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>)
                +-MakeStruct
                | +-type=STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>
                | +-field_list=
                |   +-MakeProto
                |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
                |     +-field_list=
                |       +-int64_key_1 := Literal(type=INT64, value=1)
                |       +-int64_key_2 := Literal(type=INT64, value=2)
                +-MakeStruct
                  +-type=STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>
                  +-field_list=
                    +-MakeProto
                      +-type=PROTO<zetasql_test__.KitchenSinkPB>
                      +-field_list=
                        +-int64_key_1 := Literal(type=INT64, value=3)
                        +-int64_key_2 := Literal(type=INT64, value=4)
==

# Non-array inferred type for array constructor, inferred type is ignored.
UPDATE TestTable SET KitchenSink = [{}]
WHERE TRUE;
--
ERROR: Unable to infer a type for braced constructor [at 1:37]
UPDATE TestTable SET KitchenSink = [{}]
                                    ^
==

# Nested explicit STRUCT constructor.
SELECT STRUCT<c INT64, d STRUCT<a INT64, b INT64>>{c: 1, d: { a: 1, b:2 }}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<c INT64, d STRUCT<a INT64, b INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<c INT64, d STRUCT<a INT64, b INT64>>, value={c:1, d:{a:1, b:2}}, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Nested explicit STRUCT constructor.
# Mixed use old and new syntax.
SELECT STRUCT<INT64, STRUCT<a INT64, b INT64>>(1, { a: 1, b:2 })
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<INT64, STRUCT<a INT64, b INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<INT64, STRUCT<a INT64, b INT64>>, value={1, {a:1, b:2}}, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Errror: Nested field without explicit STRUCT constructor or STRUCT keyword.
SELECT STRUCT{c: 1, d: { a: 1, b: 2 }}
--
ERROR: Unable to infer a type for braced constructor [at 1:24]
SELECT STRUCT{c: 1, d: { a: 1, b: 2 }}
                       ^
==

# Errror: Nested field should still have colon.
SELECT STRUCT<c INT64, d STRUCT<a INT64, b INT64>>{c: 1, d { a: 1, b:2 }}
--
ERROR: Struct field 2 should use colon(:) to separate field and value [at 1:60]
SELECT STRUCT<c INT64, d STRUCT<a INT64, b INT64>>{c: 1, d { a: 1, b:2 }}
                                                           ^
==

# Have trailing comma is fine.
SELECT STRUCT{c: 1, d: STRUCT { a: 1, b: 2 },}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<c INT64, d STRUCT<a INT64, b INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<c INT64, d STRUCT<a INT64, b INT64>>, value={c:1, d:{a:1, b:2}})
    +-input_scan=
      +-SingleRowScan
==

# Leading comma is not allowed.
SELECT STRUCT{,}
--
ERROR: Syntax error: Unexpected "," [at 1:15]
SELECT STRUCT{,}
              ^
==

# Error: should use comma instead of space for field separation.
SELECT STRUCT{c:1 d:2}
--
ERROR: STRUCT Braced constructor is not allowed to use pure whitespace separation, please use comma instead [at 1:19]
SELECT STRUCT{c:1 d:2}
                  ^
==

# Struct constructors with type specified in nested constructor.
# type of s: STRUCT<kitchen_sink KitchenSinkPB, s STRUCT<kitchen_sink KitchenSinkPB>>
UPDATE StructWithKitchenSinkTable SET s = STRUCT<kitchen_sink zetasql_test__.KitchenSinkPB, s STRUCT<kitchen_sink zetasql_test__.KitchenSinkPB>> {
  kitchen_sink: new zetasql_test__.KitchenSinkPB {
     int64_key_1: 1,
     int64_key_2: 1
  },
  s: STRUCT<kitchen_sink zetasql_test__.KitchenSinkPB> {
    kitchen_sink: NEW zetasql_test__.KitchenSinkPB {
     int64_key_1: 1,
     int64_key_2: 1
    }
  }
}
WHERE TRUE;
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=[StructWithKitchenSinkTable.s#2], table=StructWithKitchenSinkTable, column_index_list=[1])
+-column_access_list=WRITE
+-where_expr=
| +-Literal(type=BOOL, value=true)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>, s STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>, column=StructWithKitchenSinkTable.s#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-MakeStruct
            +-type=STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>, s STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>
            +-field_list=
              +-MakeProto
              | +-type=PROTO<zetasql_test__.KitchenSinkPB>
              | +-field_list=
              |   +-int64_key_1 := Literal(type=INT64, value=1)
              |   +-int64_key_2 := Literal(type=INT64, value=1)
              +-MakeStruct
                +-type=STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>
                +-field_list=
                  +-MakeProto
                    +-type=PROTO<zetasql_test__.KitchenSinkPB>
                    +-field_list=
                      +-int64_key_1 := Literal(type=INT64, value=1)
                      +-int64_key_2 := Literal(type=INT64, value=1)
==

# Struct constructors with type not specified in nested constructor, it is
# inferred from the STRUCT field definition.
# type of s: STRUCT<kitchen_sink KitchenSinkPB, s STRUCT<kitchen_sink KitchenSinkPB>>
UPDATE StructWithKitchenSinkTable SET s = {
  kitchen_sink: {
     int64_key_1: 1,
     int64_key_2: 1
  },
  s: {
    kitchen_sink: {
     int64_key_1: 1,
     int64_key_2: 1
    }
  }
}
WHERE TRUE;
--
[SAME AS PREVIOUS]
==

# Struct of array of struct.
# type of t: STRUCT<a INT64, b ARRAY<STRUCT<kitchen_sink KitchenSinkPB>>>
UPDATE StructWithKitchenSinkTable SET t = {
    a: 1,
    b: [{kitchen_sink: { int64_key_1: 1 int64_key_2: 2 }},
        {kitchen_sink: { int64_key_1: 10 int64_key_2: 20 }}
       ]
}
WHERE TRUE;
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=[StructWithKitchenSinkTable.t#3], table=StructWithKitchenSinkTable, column_index_list=[2])
+-column_access_list=WRITE
+-where_expr=
| +-Literal(type=BOOL, value=true)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRUCT<a INT64, b ARRAY<STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>>, column=StructWithKitchenSinkTable.t#3)
    +-set_value=
      +-DMLValue
        +-value=
          +-MakeStruct
            +-type=STRUCT<a INT64, b ARRAY<STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>>
            +-field_list=
              +-Literal(type=INT64, value=1)
              +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>) -> ARRAY<STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>)
                +-MakeStruct
                | +-type=STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>
                | +-field_list=
                |   +-MakeProto
                |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
                |     +-field_list=
                |       +-int64_key_1 := Literal(type=INT64, value=1)
                |       +-int64_key_2 := Literal(type=INT64, value=2)
                +-MakeStruct
                  +-type=STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>
                  +-field_list=
                    +-MakeProto
                      +-type=PROTO<zetasql_test__.KitchenSinkPB>
                      +-field_list=
                        +-int64_key_1 := Literal(type=INT64, value=10)
                        +-int64_key_2 := Literal(type=INT64, value=20)
==

## Inferred type is different from actual.
UPDATE StructWithKitchenSinkTable SET t = {
    a: 1,
    b: 'foo'
}
WHERE TRUE;
--
ERROR: Value of type STRUCT<a INT64, b STRING> cannot be assigned to t, which has type STRUCT<a INT64, b ARRAY<STRUCT<kitchen_sink zetasql_test__.KitchenSinkPB>>> [at 1:43]
UPDATE StructWithKitchenSinkTable SET t = {
                                          ^
==

# Infer the type of submessages in REPLACE_FIELDS.
[language_features=BRACED_PROTO_CONSTRUCTORS,REPLACE_FIELDS,STRUCT_BRACED_CONSTRUCTORS]
SELECT
  REPLACE_FIELDS(STRUCT {a: 1, b: STRUCT {c: 1}},
                 { c:2 } AS b)
FROM TestTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [STRUCT<a INT64, b STRUCT<c INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-ReplaceField
    |     +-type=STRUCT<a INT64, b STRUCT<c INT64>>
    |     +-expr=
    |     | +-Literal(type=STRUCT<a INT64, b STRUCT<c INT64>>, value={a:1, b:{c:1}})
    |     +-replace_field_item_list=
    |       +-ReplaceFieldItem
    |         +-expr=
    |         | +-Literal(type=STRUCT<c INT64>, value={c:2})
    |         +-struct_index_path=[1]
    +-input_scan=
      +-TableScan(table=TestTable)
==

# Infer the type of the lhs when trying to CAST braced constructors.
SELECT CAST( { a: 1 } AS STRUCT<a INT32>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<a INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<a INT32>, value={a:1}, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# CAST works with arrays of protos as well.
SELECT CAST( [{ nested_int64: 10 }, { nested_int64: 20 }] AS ARRAY<STRUCT<nested_int64 INT64>>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<nested_int64 INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=ARRAY<STRUCT<nested_int64 INT64>>, value=[{nested_int64:10}, {nested_int64:20}], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Test CAST behaviors.

# Mismatched by name.
SELECT CAST( { a: 1 } AS STRUCT<INT32>);
--
ERROR: Require naming match but field name does not match at position 0: '' vs 'a' [at 1:16]
SELECT CAST( { a: 1 } AS STRUCT<INT32>);
               ^
==

# Mismatched, fewer fields.
SELECT CAST( { a: 1 } AS STRUCT<a INT32, b STRING>);
--
ERROR: Require naming match but field num does not match, expected: 2, actual: 1 [at 1:14]
SELECT CAST( { a: 1 } AS STRUCT<a INT32, b STRING>);
             ^
==

# Matched by ignorecase.
SELECT CAST( { a: 1 } AS STRUCT<A INT32>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<A INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<A INT32>, value={A:1}, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Matched for nested.
SELECT CAST( { a: 1, b: {c: 'foo'}} AS STRUCT<a INT32, b STRUCT<c STRING>>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<a INT32, b STRUCT<c STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<a INT32, b STRUCT<c STRING>>, value={a:1, b:{c:"foo"}}, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Mismatched for nested field.
SELECT CAST( { a: 1, b: {c: 'foo'}} AS STRUCT<a INT32, b STRUCT<d STRING>>);
--
ERROR: Require naming match but field name does not match at position 0: 'd' vs 'c' [at 1:26]
SELECT CAST( { a: 1, b: {c: 'foo'}} AS STRUCT<a INT32, b STRUCT<d STRING>>);
                         ^
==

# Mismatched for missing nested field.
SELECT CAST( { a: 1, b: {c: 'foo'}} AS STRUCT<a INT32, b STRUCT<STRING>>);
--
ERROR: Require naming match but field name does not match at position 0: '' vs 'c' [at 1:26]
SELECT CAST( { a: 1, b: {c: 'foo'}} AS STRUCT<a INT32, b STRUCT<STRING>>);
                         ^
==

[language_features=BRACED_PROTO_CONSTRUCTORS,STRUCT_BRACED_CONSTRUCTORS,GENERATED_COLUMNS]
[no_enable_literal_replacement]
CREATE TABLE T (
  IntColumn INT32,
  StructColumn STRUCT<a INT32, b STRING> AS ({a:1, b:'foo'})
)
--
CreateTableStmt
+-name_path=T
+-column_definition_list=
  +-ColumnDefinition(name="IntColumn", type=INT32, column=T.IntColumn#1)
  +-ColumnDefinition
    +-name="StructColumn"
    +-type=STRUCT<a INT32, b STRING>
    +-column=T.StructColumn#2
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
          +-Literal(type=STRUCT<a INT32, b STRING>, value={a:1, b:"foo"})
==

[language_features=BRACED_PROTO_CONSTRUCTORS,STRUCT_BRACED_CONSTRUCTORS,GENERATED_COLUMNS]
[no_enable_literal_replacement]
CREATE TABLE T (
  IntColumn INT32,
  StructColumn STRUCT<a INT32, b STRING> AS ({a:IntColumn, b:'foo'})
)
--
CreateTableStmt
+-name_path=T
+-column_definition_list=
  +-ColumnDefinition(name="IntColumn", type=INT32, column=T.IntColumn#1)
  +-ColumnDefinition
    +-name="StructColumn"
    +-type=STRUCT<a INT32, b STRING>
    +-column=T.StructColumn#2
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
          +-MakeStruct
            +-type=STRUCT<a INT32, b STRING>
            +-field_list=
              +-ColumnRef(type=INT32, column=T.IntColumn#1)
              +-Literal(type=STRING, value="foo")
==

# Braced constructor types inferred in default column value.
[language_features=BRACED_PROTO_CONSTRUCTORS,STRUCT_BRACED_CONSTRUCTORS,COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
CREATE TABLE T (
  IntColumn INT32,
  StructColumn STRUCT<a INT32, b STRING> DEFAULT ({a:1, b:'foo'})
)
--
CreateTableStmt
+-name_path=T
+-column_definition_list=
  +-ColumnDefinition(name="IntColumn", type=INT32, column=T.IntColumn#1)
  +-ColumnDefinition
    +-name="StructColumn"
    +-type=STRUCT<a INT32, b STRING>
    +-column=T.StructColumn#2
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-Literal(type=STRUCT<a INT32, b STRING>, value={a:1, b:"foo"})
        +-sql="{a:1, b:'foo'}"
==

# Need to do coercion with generated column.
[language_features=BRACED_PROTO_CONSTRUCTORS,STRUCT_BRACED_CONSTRUCTORS,GENERATED_COLUMNS]
[no_enable_literal_replacement]
CREATE TABLE T (
  IntColumn INT32,
  StructColumn STRUCT<a INT64, b STRING> AS ({a:IntColumn, b:'foo'})
)
--
CreateTableStmt
+-name_path=T
+-column_definition_list=
  +-ColumnDefinition(name="IntColumn", type=INT32, column=T.IntColumn#1)
  +-ColumnDefinition
    +-name="StructColumn"
    +-type=STRUCT<a INT64, b STRING>
    +-column=T.StructColumn#2
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
          +-MakeStruct
            +-type=STRUCT<a INT64, b STRING>
            +-field_list=
              +-Cast(INT32 -> INT64)
              | +-ColumnRef(type=INT32, column=T.IntColumn#1)
              +-Literal(type=STRING, value="foo")
==

# Braced constructor type inferred in SQL function body.
CREATE FUNCTION myfunc (  ) RETURNS STRUCT<a INT32, b STRING> AS ({a: 3, b: 'foo'});
--
CreateFunctionStmt
+-name_path=myfunc
+-has_explicit_return_type=TRUE
+-return_type=STRUCT<a INT32, b STRING>
+-signature=() -> STRUCT<a INT32, b STRING>
+-language="SQL"
+-code="{a: 3, b: 'foo'}"
+-function_expression=
  +-Literal(type=STRUCT<a INT32, b STRING>, value={a:3, b:"foo"})
==

# Braced constructor type without a return type in a SQL function body is an error.
CREATE FUNCTION myfunc (  ) AS ({a: 3, b: 'foo'});
--
ERROR: Unable to infer a type for braced constructor [at 1:33]
CREATE FUNCTION myfunc (  ) AS ({a: 3, b: 'foo'});
                                ^
==

## Braced constructor type inferred in aggregate SQL function body.
[language_features=BRACED_PROTO_CONSTRUCTORS,STRUCT_BRACED_CONSTRUCTORS,CREATE_AGGREGATE_FUNCTION,TEMPLATE_FUNCTIONS]
CREATE AGGREGATE FUNCTION myfunc (  ) RETURNS STRUCT<int32_val1 INT32, int32_val2 INT32> AS ({int32_val1: 3, int32_val2: 5});
--
CreateFunctionStmt
+-name_path=myfunc
+-has_explicit_return_type=TRUE
+-return_type=STRUCT<int32_val1 INT32, int32_val2 INT32>
+-signature=() -> STRUCT<int32_val1 INT32, int32_val2 INT32>
+-is_aggregate=TRUE
+-language="SQL"
+-code="{int32_val1: 3, int32_val2: 5}"
+-function_expression=
  +-Literal(type=STRUCT<int32_val1 INT32, int32_val2 INT32>, value={int32_val1:3, int32_val2:5})
==

# Braced constructor type without a return type in an aggregate SQL function body is an error.
[language_features=BRACED_PROTO_CONSTRUCTORS,STRUCT_BRACED_CONSTRUCTORS,CREATE_AGGREGATE_FUNCTION,TEMPLATE_FUNCTIONS]
CREATE AGGREGATE FUNCTION myfunc (  ) AS ({int32_val1: 3 int32_val2: 5});
--
ERROR: Unable to infer a type for braced constructor [at 1:43]
CREATE AGGREGATE FUNCTION myfunc (  ) AS ({int32_val1: 3 int32_val2: 5});
                                          ^
==

# Inferring through a scalar subquery works for array and non-array types.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>, nested_repeated_value ARRAY<STRUCT<nested_int64 INT64>>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: (SELECT { nested_int64: 5 }),
  nested_repeated_value: (SELECT ARRAY[{ nested_int64: 6 },{ nested_int64: 7 }])
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>, nested_repeated_value ARRAY<STRUCT<nested_int64 INT64>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-MakeStruct
    |     +-type=STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>, nested_repeated_value ARRAY<STRUCT<nested_int64 INT64>>>
    |     +-field_list=
    |       +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |       +-Literal(type=INT64, value=2, has_explicit_type=TRUE)
    |       +-SubqueryExpr
    |       | +-type=STRUCT<nested_int64 INT64>
    |       | +-subquery_type=SCALAR
    |       | +-subquery=
    |       |   +-ProjectScan
    |       |     +-column_list=[$expr_subquery.$col1#1]
    |       |     +-expr_list=
    |       |     | +-$col1#1 := Literal(type=STRUCT<nested_int64 INT64>, value={nested_int64:5})
    |       |     +-input_scan=
    |       |       +-SingleRowScan
    |       +-SubqueryExpr
    |         +-type=ARRAY<STRUCT<nested_int64 INT64>>
    |         +-subquery_type=SCALAR
    |         +-subquery=
    |           +-ProjectScan
    |             +-column_list=[$expr_subquery.$col1#2]
    |             +-expr_list=
    |             | +-$col1#2 := Literal(type=ARRAY<STRUCT<nested_int64 INT64>>, value=[{nested_int64:6}, {nested_int64:7}])
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Inferring through a scalar subquery with the wrong type.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: (SELECT 1)
}
--
ERROR: Struct field 3 has type INT64 which does not coerce to STRUCT<nested_int64 INT64> [at 4:17]
  nested_value: (SELECT 1)
                ^
==

# Inferring through a scalar subquery with the wrong protocol buffer type.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: (SELECT { nested: 5 })
}
--
ERROR: Require naming match but field name does not match at position 0: 'nested_int64' vs 'nested' [at 4:27]
  nested_value: (SELECT { nested: 5 })
                          ^
==

# Inferring through a scalar subquery with GROUP BY. Note this does not fail on
# type inference and if grouping by proto is supported will work.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: (SELECT { nested_int64: 5 } FROM TestTable GROUP BY 1)
}
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 4:69]
  nested_value: (SELECT { nested_int64: 5 } FROM TestTable GROUP BY 1)
                                                                    ^
==

# Recursively inferring through a scalar subquery works.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: (SELECT (SELECT { nested_int64: 5 }))
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-MakeStruct
    |     +-type=STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>>
    |     +-field_list=
    |       +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |       +-Literal(type=INT64, value=2, has_explicit_type=TRUE)
    |       +-SubqueryExpr
    |         +-type=STRUCT<nested_int64 INT64>
    |         +-subquery_type=SCALAR
    |         +-subquery=
    |           +-ProjectScan
    |             +-column_list=[$expr_subquery.$col1#2]
    |             +-expr_list=
    |             | +-$col1#2 :=
    |             |   +-SubqueryExpr
    |             |     +-type=STRUCT<nested_int64 INT64>
    |             |     +-subquery_type=SCALAR
    |             |     +-subquery=
    |             |       +-ProjectScan
    |             |         +-column_list=[$expr_subquery.$col1#1]
    |             |         +-expr_list=
    |             |         | +-$col1#1 := Literal(type=STRUCT<nested_int64 INT64>, value={nested_int64:5})
    |             |         +-input_scan=
    |             |           +-SingleRowScan
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Inferring through an array subquery works.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_repeated_value ARRAY<STRUCT<nested_int64 INT64>>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_repeated_value: ARRAY(
        SELECT {nested_int64: x} FROM UNNEST(GENERATE_ARRAY(1, 2)) x
  )
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_repeated_value ARRAY<STRUCT<nested_int64 INT64>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-MakeStruct
    |     +-type=STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_repeated_value ARRAY<STRUCT<nested_int64 INT64>>>
    |     +-field_list=
    |       +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |       +-Literal(type=INT64, value=2, has_explicit_type=TRUE)
    |       +-SubqueryExpr
    |         +-type=ARRAY<STRUCT<nested_int64 INT64>>
    |         +-subquery_type=ARRAY
    |         +-subquery=
    |           +-ProjectScan
    |             +-column_list=[$expr_subquery.$col1#2]
    |             +-expr_list=
    |             | +-$col1#2 :=
    |             |   +-MakeStruct
    |             |     +-type=STRUCT<nested_int64 INT64>
    |             |     +-field_list=
    |             |       +-ColumnRef(type=INT64, column=$array.x#1)
    |             +-input_scan=
    |               +-ArrayScan
    |                 +-column_list=[$array.x#1]
    |                 +-array_expr_list=
    |                 | +-FunctionCall(ZetaSQL:generate_array(INT64, INT64, optional(0) INT64) -> ARRAY<INT64>)
    |                 |   +-Literal(type=INT64, value=1)
    |                 |   +-Literal(type=INT64, value=2)
    |                 +-element_column_list=[$array.x#1]
    +-input_scan=
      +-SingleRowScan
==

# Inferring from the LHS to the RHS of an IN subquery works.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64> {
  int64_key_1: 1,
  int64_key_2: 2,
} IN (SELECT {int64_key_1: 1, int64_key_2: 2} )
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=STRUCT<int64_key_1 INT64, int64_key_2 INT64>, value={int64_key_1:1, int64_key_2:2}, has_explicit_type=TRUE)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#1]
    |         +-expr_list=
    |         | +-$col1#1 := Literal(type=STRUCT<int64_key_1 INT64, int64_key_2 INT64>, value={int64_key_1:1, int64_key_2:2})
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Subquery type does not match inferred type.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: (SELECT 'foo')
}
--
ERROR: Struct field 3 has type STRING which does not coerce to STRUCT<nested_int64 INT64> [at 4:17]
  nested_value: (SELECT 'foo')
                ^
==

# Inferred type is not an array for an array subquery.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: ARRAY(SELECT { nested_int64: 5 })
}
--
ERROR: Unable to infer a type for braced constructor [at 4:30]
  nested_value: ARRAY(SELECT { nested_int64: 5 })
                             ^
==

# Not inferring through a EXISTS query.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: EXISTS(SELECT { nested_int64: 5 })
}
--
ERROR: Unable to infer a type for braced constructor [at 4:31]
  nested_value: EXISTS(SELECT { nested_int64: 5 })
                              ^
==

# Not inferring through a SELECT AS STRUCT query.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: (SELECT AS STRUCT { nested_int64: 5 })
}
--
ERROR: Unable to infer a type for braced constructor [at 4:35]
  nested_value: (SELECT AS STRUCT { nested_int64: 5 })
                                  ^
==

# Not inferring through a SELECT AS PROTO query because of differing syntax.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: (SELECT AS zetasql_test__.KitchenSinkPB { nested_int64: 5 })
}
--
ERROR: Unable to infer a type for braced constructor [at 4:57]
  nested_value: (SELECT AS zetasql_test__.KitchenSinkPB { nested_int64: 5 })
                                                        ^
==

# Inference workds inside bracket constructor.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>> (
  1,
  2,
  { nested_int64: 5 }
)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>>, value={int64_key_1:1, int64_key_2:2, nested_value:{nested_int64:5}}, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Inferring through a subquery using WITH does inference only on the returned
# SELECT column and not any select in the WITH.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: (WITH Foo AS (SELECT { nested_int64: 5 } AS x) SELECT Foo.x)
}
--
ERROR: Unable to infer a type for braced constructor [at 4:38]
  nested_value: (WITH Foo AS (SELECT { nested_int64: 5 } AS x) SELECT Foo.x)
                                     ^
==

# Inferring through a subquery using WITH working on first non-WITH SELECT
# column.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: (WITH Foo AS (SELECT "foo" AS x) SELECT { nested_int64: 5 })
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-MakeStruct
    |     +-type=STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>>
    |     +-field_list=
    |       +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |       +-Literal(type=INT64, value=2, has_explicit_type=TRUE)
    |       +-SubqueryExpr
    |         +-type=STRUCT<nested_int64 INT64>
    |         +-subquery_type=SCALAR
    |         +-subquery=
    |           +-WithScan
    |             +-column_list=[$expr_subquery.$col1#2]
    |             +-with_entry_list=
    |             | +-WithEntry
    |             |   +-with_query_name="Foo"
    |             |   +-with_subquery=
    |             |     +-ProjectScan
    |             |       +-column_list=[Foo.x#1]
    |             |       +-expr_list=
    |             |       | +-x#1 := Literal(type=STRING, value="foo")
    |             |       +-input_scan=
    |             |         +-SingleRowScan
    |             +-query=
    |               +-ProjectScan
    |                 +-column_list=[$expr_subquery.$col1#2]
    |                 +-expr_list=
    |                 | +-$col1#2 := Literal(type=STRUCT<nested_int64 INT64>, value={nested_int64:5})
    |                 +-input_scan=
    |                   +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Inferring through multiple WITH clauses.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_value: (WITH Foo AS (SELECT "foo" AS x) (WITH Bar AS (SELECT "bar" AS y) SELECT { nested_int64: 5 }))
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-MakeStruct
    |     +-type=STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_value STRUCT<nested_int64 INT64>>
    |     +-field_list=
    |       +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |       +-Literal(type=INT64, value=2, has_explicit_type=TRUE)
    |       +-SubqueryExpr
    |         +-type=STRUCT<nested_int64 INT64>
    |         +-subquery_type=SCALAR
    |         +-subquery=
    |           +-WithScan
    |             +-column_list=[$expr_subquery.$col1#3]
    |             +-with_entry_list=
    |             | +-WithEntry
    |             |   +-with_query_name="Foo"
    |             |   +-with_subquery=
    |             |     +-ProjectScan
    |             |       +-column_list=[Foo.x#1]
    |             |       +-expr_list=
    |             |       | +-x#1 := Literal(type=STRING, value="foo")
    |             |       +-input_scan=
    |             |         +-SingleRowScan
    |             +-query=
    |               +-WithScan
    |                 +-column_list=[$expr_subquery.$col1#3]
    |                 +-with_entry_list=
    |                 | +-WithEntry
    |                 |   +-with_query_name="Bar"
    |                 |   +-with_subquery=
    |                 |     +-ProjectScan
    |                 |       +-column_list=[Bar.y#2]
    |                 |       +-expr_list=
    |                 |       | +-y#2 := Literal(type=STRING, value="bar")
    |                 |       +-input_scan=
    |                 |         +-SingleRowScan
    |                 +-query=
    |                   +-ProjectScan
    |                     +-column_list=[$expr_subquery.$col1#3]
    |                     +-expr_list=
    |                     | +-$col1#3 := Literal(type=STRUCT<nested_int64 INT64>, value={nested_int64:5})
    |                     +-input_scan=
    |                       +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Inferring through a subquery which has UNION ALL.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_repeated_value ARRAY<STRUCT<nested_int64 INT64>>> {
  int64_key_1: 1,
  int64_key_2: 2,
  nested_repeated_value: ARRAY(SELECT { nested_int64: 5 } UNION ALL
                               SELECT { nested_int64: 6 })
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_repeated_value ARRAY<STRUCT<nested_int64 INT64>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-MakeStruct
    |     +-type=STRUCT<int64_key_1 INT64, int64_key_2 INT64, nested_repeated_value ARRAY<STRUCT<nested_int64 INT64>>>
    |     +-field_list=
    |       +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |       +-Literal(type=INT64, value=2, has_explicit_type=TRUE)
    |       +-SubqueryExpr
    |         +-type=ARRAY<STRUCT<nested_int64 INT64>>
    |         +-subquery_type=ARRAY
    |         +-subquery=
    |           +-SetOperationScan
    |             +-column_list=[$union_all.$col1#3]
    |             +-op_type=UNION_ALL
    |             +-input_item_list=
    |               +-SetOperationItem
    |               | +-scan=
    |               | | +-ProjectScan
    |               | |   +-column_list=[$union_all1.$col1#1]
    |               | |   +-expr_list=
    |               | |   | +-$col1#1 := Literal(type=STRUCT<nested_int64 INT64>, value={nested_int64:5})
    |               | |   +-input_scan=
    |               | |     +-SingleRowScan
    |               | +-output_column_list=[$union_all1.$col1#1]
    |               +-SetOperationItem
    |                 +-scan=
    |                 | +-ProjectScan
    |                 |   +-column_list=[$union_all2.$col1#2]
    |                 |   +-expr_list=
    |                 |   | +-$col1#2 := Literal(type=STRUCT<nested_int64 INT64>, value={nested_int64:6})
    |                 |   +-input_scan=
    |                 |     +-SingleRowScan
    |                 +-output_column_list=[$union_all2.$col1#2]
    +-input_scan=
      +-SingleRowScan
==

# The analyzer allows setting required fields to NULL, but the engine will
# give an error.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64> {
  int64_key_1: null,
  int64_key_2: null,
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<int64_key_1 INT64, int64_key_2 INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<int64_key_1 INT64, int64_key_2 INT64>, value={int64_key_1:NULL, int64_key_2:NULL}, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# The analyzer allows setting values of repeated fields to NULL, but the engine
# will give an error.
SELECT STRUCT<int64_key_1 INT64, int64_key_2 INT64, repeated_int64_val ARRAY<INT64>> {
  int64_key_1: 10,
  int64_key_2: 20,
  repeated_int64_val: [1, 2, NULL, 4]
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<int64_key_1 INT64, int64_key_2 INT64, repeated_int64_val ARRAY<INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRUCT<int64_key_1 INT64, int64_key_2 INT64, repeated_int64_val ARRAY<INT64>>, value={int64_key_1:10, int64_key_2:20, repeated_int64_val:[1, 2, NULL, 4]}, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Error using braced constructors without an inferred type.
SELECT ARRAY[{ str_value: ["foo", "bar"] }, { str_value: ["baz"] }]
--
ERROR: Unable to infer a type for braced constructor [at 1:14]
SELECT ARRAY[{ str_value: ["foo", "bar"] }, { str_value: ["baz"] }]
             ^
==

# Using STRUCT can work.
SELECT ARRAY[STRUCT{ str_value: ["foo", "bar"] }, STRUCT{ str_value: ["baz"] }]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<str_value ARRAY<STRING>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=ARRAY<STRUCT<str_value ARRAY<STRING>>>, value=[{str_value:["foo", "bar"]}, {str_value:["baz"]}])
    +-input_scan=
      +-SingleRowScan
==

# Or with explicit type.
SELECT ARRAY<STRUCT<str_value ARRAY<STRING>>>[{ str_value: ["foo", "bar"] }, { str_value: ["baz"] }]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<str_value ARRAY<STRING>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=ARRAY<STRUCT<str_value ARRAY<STRING>>>, value=[{str_value:["foo", "bar"]}, {str_value:["baz"]}], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Similar to b/259000660.
# TVF using braced constructor should also work.
[language_features=BRACED_PROTO_CONSTRUCTORS,STRUCT_BRACED_CONSTRUCTORS,TABLE_VALUED_FUNCTIONS,CREATE_TABLE_FUNCTION,TEMPLATE_FUNCTIONS]
WITH
  T AS (
    SELECT CAST(v as INT32) v
    FROM UNNEST(GENERATE_ARRAY(2, 12)) AS v
  )
SELECT *
FROM templated_struct_braced_ctor_tvf(TABLE T)
ORDER BY dice_roll.int32_val1;
--
QueryStmt
+-output_column_list=
| +-templated_struct_braced_ctor_tvf.dice_roll#4 AS dice_roll [STRUCT<int32_val1 INT32>]
+-query=
  +-WithScan
    +-column_list=[templated_struct_braced_ctor_tvf.dice_roll#4]
    +-is_ordered=TRUE
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="T"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[T.v#2]
    |       +-expr_list=
    |       | +-v#2 :=
    |       |   +-Cast(INT64 -> INT32)
    |       |     +-ColumnRef(type=INT64, column=$array.v#1)
    |       +-input_scan=
    |         +-ArrayScan
    |           +-column_list=[$array.v#1]
    |           +-array_expr_list=
    |           | +-FunctionCall(ZetaSQL:generate_array(INT64, INT64, optional(0) INT64) -> ARRAY<INT64>)
    |           |   +-Literal(type=INT64, value=2)
    |           |   +-Literal(type=INT64, value=12)
    |           +-element_column_list=[$array.v#1]
    +-query=
      +-OrderByScan
        +-column_list=[templated_struct_braced_ctor_tvf.dice_roll#4]
        +-is_ordered=TRUE
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[templated_struct_braced_ctor_tvf.dice_roll#4, $orderby.$orderbycol1#5]
        |   +-expr_list=
        |   | +-$orderbycol1#5 :=
        |   |   +-GetStructField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=STRUCT<int32_val1 INT32>, column=templated_struct_braced_ctor_tvf.dice_roll#4)
        |   |     +-field_idx=0
        |   +-input_scan=
        |     +-TVFScan
        |       +-column_list=[templated_struct_braced_ctor_tvf.dice_roll#4]
        |       +-tvf=templated_struct_braced_ctor_tvf((ANY TABLE) -> ANY TABLE)
        |       +-signature=(TABLE<v INT32>) -> TABLE<dice_roll STRUCT<int32_val1 INT32>>
        |       +-argument_list=
        |       | +-FunctionArgument
        |       |   +-scan=
        |       |   | +-WithRefScan(column_list=[T.v#3], with_query_name="T")
        |       |   +-argument_column_list=[T.v#3]
        |       +-column_index_list=[0]
        |       +-function_call_signature=(ANY TABLE) -> ANY TABLE
        +-order_by_item_list=
          +-OrderByItem
            +-column_ref=
              +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#5)

With Templated SQL TVF signature:
  templated_struct_braced_ctor_tvf(TABLE<v INT32>) -> TABLE<dice_roll STRUCT<int32_val1 INT32>>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.dice_roll#2 AS dice_roll [STRUCT<int32_val1 INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.dice_roll#2]
    +-expr_list=
    | +-dice_roll#2 :=
    |   +-MakeStruct
    |     +-type=STRUCT<int32_val1 INT32>
    |     +-field_list=
    |       +-ColumnRef(type=INT32, column=T.v#1)
    +-input_scan=
      +-RelationArgumentScan(column_list=[T.v#1], name="T")
