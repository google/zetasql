# Use (broken link) for pretty-printing the generated sql.
[default show_unparsed]
[default no_show_resolved_ast]
[default language_features=PARAMETERS_IN_GRANTEE_LIST,CREATE_TABLE_FUNCTION]

create temporary table X
options(x=5, y='abc', z=@test_param_array, z=abc)
as
select key, key k1, key k2, key+1 k3 from keYvalue limit 5
--
[UNPARSED_SQL]
CREATE TEMP TABLE X OPTIONS(x = 5, y = "abc", z = @test_param_array, z = "abc") AS
SELECT
  keyvalue_2.a_1 AS key,
  keyvalue_2.a_1 AS k1,
  keyvalue_2.a_1 AS k2,
  (keyvalue_2.a_1) + 1 AS k3
FROM
  (
    SELECT
      KeyValue.Key AS a_1
    FROM
      KeyValue
  ) AS keyvalue_2
LIMIT 5;
==

create or replace table x.y as (select 1 a)
--
[UNPARSED_SQL]
CREATE OR REPLACE TABLE x.y AS
SELECT
  1 AS a;
==

create table if not exists x.y options (x=y) as (select 1 a)
--
[UNPARSED_SQL]
CREATE TABLE IF NOT EXISTS x.y OPTIONS(x = "y") AS
SELECT
  1 AS a;
==

define table a.`b`.`c 2` (x='''
foo''',y="2011-10-22",z=@test_param_int64)
--
[UNPARSED_SQL]
DEFINE TABLE a.b.`c 2`(x = "\nfoo", y = "2011-10-22", z = @test_param_int64);
==

define table t1 ()
--
[UNPARSED_SQL]
DEFINE TABLE t1();
==

export data
as select as `zetasql_test__.TestExtraPB` 55 int32_val1
--
[UNPARSED_SQL]
EXPORT DATA AS
SELECT AS VALUE
  NEW `zetasql_test__.TestExtraPB`(CAST(55 AS INT32) AS int32_val1) AS a_3
FROM
  (
    SELECT
      55 AS a_1
  ) AS projectscan_2;
==

EXPLAIN select KitchenSink.repeated_date, KitchenSink.repeated_timestamp_micros
from TestTable;
--
[UNPARSED_SQL]
EXPLAIN
SELECT
  testtable_2.a_1.repeated_date AS repeated_date,
  testtable_2.a_1.repeated_timestamp_micros AS repeated_timestamp_micros
FROM
  (
    SELECT
      TestTable.KitchenSink AS a_1
    FROM
      TestTable
  ) AS testtable_2;
==

@{h1=1} EXPLAIN
@{h2=2} create or replace table x.y options(o1=1) as (select @{h3=3} 1 a)
--
[UNPARSED_SQL]
@{ h1 = 1 } EXPLAIN @{ h2 = 2 } CREATE OR REPLACE TABLE x.y OPTIONS(o1 = 1) AS
SELECT @{ h3 = 3 }
  projectscan_2.a_1 AS a
FROM
  (
    SELECT
      1 AS a_1
  ) AS projectscan_2;
==

EXPLAIN define table t1 ()
--
[UNPARSED_SQL]
EXPLAIN DEFINE TABLE t1();
==

EXPLAIN export data as select key, value from KeyValue
--
[UNPARSED_SQL]
EXPLAIN EXPORT DATA AS
SELECT
  keyvalue_3.a_1 AS key,
  keyvalue_3.a_2 AS value
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3;
==

grant select on table foo to "bar@google.com"
--
[UNPARSED_SQL]
GRANT `select` ON table foo TO "bar@google.com";
==

grant update, insert (col1, `col2`, `group`, `et cetera`) on foo to "bar@google.com"
--
[UNPARSED_SQL]
GRANT `update`, insert(col1, col2, `group`, `et cetera`) ON foo TO "bar@google.com";
==

grant select, `et cetera` on `temporary table` `table name` to "bar@google.com"
--
[UNPARSED_SQL]
GRANT `select`, `et cetera` ON `temporary table` `table name` TO "bar@google.com";
==

grant delete on `temporary table` to "bar@google.com"
--
[UNPARSED_SQL]
GRANT delete ON `temporary table` TO "bar@google.com";
==

revoke all on table foo from "mdbuser/user", 'mdbgroup/group'
--
[UNPARSED_SQL]
REVOKE ALL PRIVILEGES ON table foo FROM "mdbuser/user", "mdbgroup/group";
==

drop table foo
--
[UNPARSED_SQL]
DROP TABLE foo;
==

drop table if exists foo
--
[UNPARSED_SQL]
DROP TABLE IF EXISTS foo;
==

drop row access policy foo on bar
--
[UNPARSED_SQL]
DROP ROW ACCESS POLICY foo ON bar;
==

drop row access policy if exists foo on bar
--
[UNPARSED_SQL]
DROP ROW ACCESS POLICY IF EXISTS foo ON bar;
==

drop row access policy `all` on bar
--
[UNPARSED_SQL]
DROP ROW ACCESS POLICY `all` ON bar;
==

drop row access policy foo on `the namespace`.bar
--
[UNPARSED_SQL]
DROP ROW ACCESS POLICY foo ON `the namespace`.bar;
==

[language_features=ALLOW_LEGACY_ROW_ACCESS_POLICY_SYNTAX]
drop all row {{access|}} policies on bar
--
[UNPARSED_SQL]
DROP ALL ROW ACCESS POLICIES ON bar;
==

[language_features=ALLOW_LEGACY_ROW_ACCESS_POLICY_SYNTAX]
drop all row {{access|}} policies on `the namespace`.`all`
--
[UNPARSED_SQL]
DROP ALL ROW ACCESS POLICIES ON `the namespace`.`all`;
==

rename table foo to bar
--
[UNPARSED_SQL]
RENAME table foo TO bar;
==

rename `temporary table` foo to bar
--
[UNPARSED_SQL]
RENAME `temporary table` foo TO bar;
==

rename foo `bar 1` to `bar 2`
--
[UNPARSED_SQL]
RENAME foo `bar 1` TO `bar 2`;
==

rename view namespace.`if` to `the new namespace`.bar
--
[UNPARSED_SQL]
RENAME view namespace.`if` TO `the new namespace`.bar;
==

[language_features=ALLOW_LEGACY_ROW_ACCESS_POLICY_SYNTAX]
create row policy on KeyValue to 'foo@google.com' using (key = 1);
--
[UNPARSED_SQL]
CREATE ROW ACCESS POLICY ON KeyValue GRANT TO ("foo@google.com") FILTER USING (key = 1);
==

[language_features=ALLOW_LEGACY_ROW_ACCESS_POLICY_SYNTAX]
create row policy p1 on KeyValue to 'foo@google.com', 'mdbuser/bar'
using (key = 1);
--
[UNPARSED_SQL]
CREATE ROW ACCESS POLICY p1 ON KeyValue GRANT TO ("foo@google.com", "mdbuser/bar") FILTER USING (key =
1);
==

[language_features=ALLOW_LEGACY_ROW_ACCESS_POLICY_SYNTAX]
create row policy `all` on KeyValue to 'everyone@google.com' using (false);
--
[UNPARSED_SQL]
CREATE ROW ACCESS POLICY `all` ON KeyValue GRANT TO ("everyone@google.com") FILTER USING (false);
==

[language_features=ALLOW_LEGACY_ROW_ACCESS_POLICY_SYNTAX]
create or replace row policy p1 on KeyValue to 'foo@google.com', 'mdbuser/bar'
using (key = 1);
--
[UNPARSED_SQL]
CREATE OR REPLACE ROW ACCESS POLICY p1 ON KeyValue GRANT TO ("foo@google.com", "mdbuser/bar") FILTER USING (key =
1);
==

[language_features=ALLOW_LEGACY_ROW_ACCESS_POLICY_SYNTAX]
create row policy if not exists p1 on KeyValue to 'foo@google.com',
'mdbuser/bar'
using (key = 1);
--
[UNPARSED_SQL]
CREATE ROW ACCESS POLICY IF NOT EXISTS p1 ON KeyValue GRANT TO ("foo@google.com", "mdbuser/bar") FILTER USING (key =
1);
==

create row access policy on KeyValue grant to ('foo@google.com') filter using (key = 1);
--
[UNPARSED_SQL]
CREATE ROW ACCESS POLICY ON KeyValue GRANT TO ("foo@google.com") FILTER USING (key = 1);
==

create row access policy p1 on KeyValue grant to ('foo@google.com', 'mdbuser/bar')
filter using (key = 1);
--
[UNPARSED_SQL]
CREATE ROW ACCESS POLICY p1 ON KeyValue GRANT TO ("foo@google.com", "mdbuser/bar") FILTER USING (key =
1);
==

create row access policy `all` on KeyValue grant to ('everyone@google.com') filter using (false);
--
[UNPARSED_SQL]
CREATE ROW ACCESS POLICY `all` ON KeyValue GRANT TO ("everyone@google.com") FILTER USING (false);
==

create or replace row access policy p1 on KeyValue grant to ('foo@google.com', 'mdbuser/bar')
filter using (key = 1);
--
[UNPARSED_SQL]
CREATE OR REPLACE ROW ACCESS POLICY p1 ON KeyValue GRANT TO ("foo@google.com", "mdbuser/bar") FILTER USING (key =
1);
==

create row access policy if not exists p1 on KeyValue grant to ('foo@google.com',
'mdbuser/bar')
filter using (key = 1);
--
[UNPARSED_SQL]
CREATE ROW ACCESS POLICY IF NOT EXISTS p1 ON KeyValue GRANT TO ("foo@google.com", "mdbuser/bar") FILTER USING (key =
1);
==

create row access policy p1 on KeyValue filter using (key = 1);
--
[UNPARSED_SQL]
CREATE ROW ACCESS POLICY p1 ON KeyValue FILTER USING (key = 1);
==

alter row access policy p1 on KeyValue rename to p2 ;
--
[UNPARSED_SQL]
ALTER ROW ACCESS POLICY p1 ON KeyValue RENAME TO p2;
==

alter row access policy p1 on KeyValue grant to ('foo@google.com');
--
[UNPARSED_SQL]
ALTER ROW ACCESS POLICY p1 ON KeyValue GRANT TO ("foo@google.com");
==

alter row access policy p1 on KeyValue filter using (key = 1);
--
[UNPARSED_SQL]
ALTER ROW ACCESS POLICY p1 ON KeyValue FILTER USING (key = 1);
==

alter row access policy p1 on KeyValue revoke from ('bar@google.com');
--
[UNPARSED_SQL]
ALTER ROW ACCESS POLICY p1 ON KeyValue REVOKE FROM ("bar@google.com");
==

alter row access policy p1 on KeyValue revoke from all;
--
[UNPARSED_SQL]
ALTER ROW ACCESS POLICY p1 ON KeyValue REVOKE FROM ALL;
==

alter row access policy if exists p1 on KeyValue revoke from all;
--
[UNPARSED_SQL]
ALTER ROW ACCESS POLICY IF EXISTS p1 ON KeyValue REVOKE FROM ALL;
==

alter row access policy p1 on KeyValue rename to p2, grant to ('foo@google.com');
--
[UNPARSED_SQL]
ALTER ROW ACCESS POLICY p1 ON KeyValue RENAME TO p2, GRANT TO ("foo@google.com");
==

alter row access policy p1 on KeyValue rename to p2, filter using (false);
--
[UNPARSED_SQL]
ALTER ROW ACCESS POLICY p1 ON KeyValue RENAME TO p2, FILTER USING (false);
==

alter row access policy p1 on KeyValue rename to p2, grant to ('foo@google.com'),
filter using(true);
--
[UNPARSED_SQL]
ALTER ROW ACCESS POLICY p1 ON KeyValue RENAME TO p2, GRANT TO ("foo@google.com"), FILTER USING (true);
==

alter row access policy `my policy` on KeyValue rename to p2,
grant to ('foo@google.com', "mdbuser/bar");
--
[UNPARSED_SQL]
ALTER ROW ACCESS POLICY `my policy` ON KeyValue RENAME TO p2, GRANT TO ("foo@google.com", "mdbuser/bar");
==

[no_test_extract_table_names]
alter row access policy `my policy` on nested_catalog.KeyValue
rename to `my new policy`,
grant to ('foo@google.com', "mdbuser/bar");
--
[UNPARSED_SQL]
ALTER ROW ACCESS POLICY `my policy` ON nested_catalog.KeyValue RENAME TO `my new policy`, GRANT TO ("foo@google.com",
  "mdbuser/bar");
==

alter row access policy `my policy` on KeyValue
rename to p2, revoke from all, grant to ('foo@google.com', "mdbuser/bar"),
filter using(Key = 123);
--
[UNPARSED_SQL]
ALTER ROW ACCESS POLICY `my policy` ON KeyValue RENAME TO p2, REVOKE FROM ALL, GRANT TO ("foo@google.com",
  "mdbuser/bar"), FILTER USING (Key = 123);
==

alter row access policy `my policy` on KeyValue
rename to p2, revoke from ('allAuthenticatedUsers', "domain:google.com"),
grant to ('foo@google.com', "mdbuser/bar"),
filter using(Key = 123);
--
[UNPARSED_SQL]
ALTER ROW ACCESS POLICY `my policy` ON KeyValue RENAME TO p2, REVOKE FROM ("allAuthenticatedUsers", "domain:google.com"),
  GRANT TO ("foo@google.com", "mdbuser/bar"), FILTER USING (Key = 123);
==

# Create external language function.
create function foo.fn( x struct<a string, b int32>, y boolean )
returns string language testlang
as "return 'hi';"
--
[UNPARSED_SQL]
CREATE FUNCTION foo.fn(x STRUCT< a STRING, b INT32 >, y BOOL)
RETURNS STRING LANGUAGE testlang AS "return 'hi';";
==

# Create multi-line external language function, with modifiers (if not exists).
create temporary function if not exists
fn( x struct<a string, b int32>, y boolean )
returns string language testlang
as """ return
  "presto!" + s + '\n';
"""
--
[UNPARSED_SQL]
CREATE TEMP FUNCTION IF NOT EXISTS fn(x STRUCT< a STRING, b INT32 >, y BOOL)
RETURNS STRING LANGUAGE testlang AS " return\n  \"presto!\" + s + '\n';\n";
==

# Create multi-line external language function, with modifiers (or replace).
create or replace temporary function
fn( x struct<a string, b int32>, y boolean )
returns string language testlang
as """ return
  "presto!" + s + '\n';
"""
--
[UNPARSED_SQL]
CREATE OR REPLACE TEMP FUNCTION fn(x STRUCT< a STRING, b INT32 >, y BOOL)
RETURNS STRING LANGUAGE testlang AS " return\n  \"presto!\" + s + '\n';\n";
==

# Create SQL function with quoted name.
create function `my func` ( a int32 )
  returns int32
  as ( if ( a > 0, a, -1 ) ) ;
--
[UNPARSED_SQL]
CREATE FUNCTION `my func`(a INT32)
RETURNS INT32 AS (
  `IF`(a > CAST(0 AS INT32), a, CAST(-1 AS INT32))
);
==

# Create SQL function with explicit return type.
create function myfunc ( a int32 )
  returns int32
  as ( if ( a > 0, a, -1 ) ) ;
--
[UNPARSED_SQL]
CREATE FUNCTION myfunc(a INT32)
RETURNS INT32 AS (
  `IF`(a > CAST(0 AS INT32), a, CAST(-1 AS INT32))
);
==

# Create SQL function with inferred return type.
create function myfunc ( a int32 )
  as ( if ( a > 0, a, -1 ) ) ;
--
[UNPARSED_SQL]
CREATE FUNCTION myfunc(a INT32)
RETURNS INT32 AS (
  `IF`(a > CAST(0 AS INT32), a, CAST(-1 AS INT32))
);
==

# Create SQL function with quoted variable name.
create function foo.myfunc ( `four score` int32 )
  returns int32
  as ( if ( `four score` > 0, `four score`, -1 ) ) ;
--
[UNPARSED_SQL]
CREATE FUNCTION foo.myfunc(`four score` INT32)
RETURNS INT32 AS (
  `IF`((`four score`) > CAST(0 AS INT32), `four score`, CAST(-1 AS INT32))
);
==

# Create SQL table function with quoted name.
create table function `my func` ( a int64 )
  returns table<int64>
  as ( SELECT a+2 AS result ) ;
--
[UNPARSED_SQL]
CREATE TABLE FUNCTION `my func`(a INT64)
RETURNS TABLE< INT64 > AS
  SELECT
    a + 2 AS result;
==

# Create SQL table function with quoted variable.
create table function myfunc ( `my var` int64 )
  returns table<int64>
  as ( SELECT `my var`+2 AS result ) ;
--
[UNPARSED_SQL]
CREATE TABLE FUNCTION myfunc(`my var` INT64)
RETURNS TABLE< INT64 > AS
  SELECT
    (`my var`) + 2 AS result;
==

# Create SQL table function with explicit return type.
create table function myfunc ( a int64 )
  returns table<a int64, result int64>
  as ( SELECT a, a+2 AS result ) ;
--
[UNPARSED_SQL]
CREATE TABLE FUNCTION myfunc(a INT64)
RETURNS TABLE< a INT64, result INT64 > AS
  SELECT
    a AS a,
    a + 2 AS result;
==

# Create SQL table function with inferred return type.
create table function myfunc ( a int64 )
  as ( SELECT a, a+2 AS result ) ;
--
[UNPARSED_SQL]
CREATE TABLE FUNCTION myfunc(a INT64)
RETURNS TABLE< a INT64, result INT64 > AS
  SELECT
    a AS a,
    a + 2 AS result;
==

# Create SQL function with inferred return type and modifiers (if not exists).
create temporary function if not exists myfunc ( a int32 )
  returns int32
  as ( if ( a > 0, a, -1 ) ) ;
--
[UNPARSED_SQL]
CREATE TEMP FUNCTION IF NOT EXISTS myfunc(a INT32)
RETURNS INT32 AS (
  `IF`(a > CAST(0 AS INT32), a, CAST(-1 AS INT32))
);
==

# Create SQL function with inferred return type and modifiers (or replace).
create or replace temporary function myfunc ( a int32 )
  returns int32
  as ( if ( a > 0, a, -1 ) ) ;
--
[UNPARSED_SQL]
CREATE OR REPLACE TEMP FUNCTION myfunc(a INT32)
RETURNS INT32 AS (
  `IF`(a > CAST(0 AS INT32), a, CAST(-1 AS INT32))
);
==

[language_features=CREATE_AGGREGATE_FUNCTION]
CREATE AGGREGATE FUNCTION f(x int32, y int32 NOT AGGREGATE)
AS (SUM(x) / y);
--
[UNPARSED_SQL]
CREATE AGGREGATE FUNCTION f(x INT32, y INT32 NOT AGGREGATE)
RETURNS DOUBLE AS (
  CAST(SUM(CAST(x AS INT64)) AS DOUBLE) / CAST(y AS DOUBLE)
);
==

# Drop function, all overrides.
drop function foo.bar ;
--
[UNPARSED_SQL]
DROP FUNCTION foo.bar;
==

# Drop function if exists, all overrides.
drop function if exists foo ;
--
[UNPARSED_SQL]
DROP FUNCTION IF EXISTS foo;
==

# Drop function, zero-arg override.
drop function foo.bar() ;
--
[UNPARSED_SQL]
DROP FUNCTION foo.bar();
==

# Drop function, unnamed arg.
drop function foo.bar(string) ;
--
[UNPARSED_SQL]
DROP FUNCTION foo.bar(STRING);
==

# Drop function, named arg.
drop function foo.bar(a string) ;
--
[UNPARSED_SQL]
DROP FUNCTION foo.bar(STRING);
==

# Drop function, multiple unnamed args.
drop function foo.bar(string, struct<int32, bool>) ;
--
[UNPARSED_SQL]
DROP FUNCTION foo.bar(STRING, STRUCT< INT32, BOOL >);
==

# Drop function, multiple named args.
drop function foo.bar(a string, b struct<x int32, y bool>) ;
--
[UNPARSED_SQL]
DROP FUNCTION foo.bar(STRING, STRUCT< x INT32, y BOOL >);
==

# Drop function, mix of named and unnamed args.
drop function foo.bar(a string, struct<a int32, bool>, string) ;
--
[UNPARSED_SQL]
DROP FUNCTION foo.bar(STRING, STRUCT< a INT32, BOOL >, STRING);
==

# Drop function with quoted name.
drop function `foo bar`(a string, struct<a int32, bool>, string) ;
--
[UNPARSED_SQL]
DROP FUNCTION `foo bar`(STRING, STRUCT< a INT32, BOOL >, STRING);
==

# Drop table function.
drop table function foo.bar ;
--
[UNPARSED_SQL]
DROP TABLE FUNCTION foo.bar;
==

# Drop table function if exists.
drop table function if exists foo ;
--
[UNPARSED_SQL]
DROP TABLE FUNCTION IF EXISTS foo;
==

# Drop table function with quoted name.
drop table function `foo bar` ;
--
[UNPARSED_SQL]
DROP TABLE FUNCTION `foo bar`;
==

# Drop table function, doesn't support empty argument list
drop table function foo.bar() ;
--
ERROR: Syntax error: Parameters are not supported for DROP TABLE FUNCTION because table functions don't support overloading [at 1:28]
drop table function foo.bar() ;
                           ^
==

# Drop table function, doesn't support populated argument list
drop table function foo.bar(int64) ;
--
ERROR: Syntax error: Parameters are not supported for DROP TABLE FUNCTION because table functions don't support overloading [at 1:28]
drop table function foo.bar(int64) ;
                           ^
==

[language_features=EXPERIMENTAL_MODULES]
IMPORT MODULE a.b.c {{|AS c}} {{|OPTIONS(e=1)}};
--
ALTERNATION GROUPS:
    <empty>
    AS c,
--
[UNPARSED_SQL]
IMPORT MODULE a.b.c AS c;
--
ALTERNATION GROUPS:
    OPTIONS(e=1)
    AS c,OPTIONS(e=1)
--
[UNPARSED_SQL]
IMPORT MODULE a.b.c AS c OPTIONS(e = 1);
==

IMPORT PROTO "a/b/c" {{|INTO d}} {{|OPTIONS(e=2)}};
--
ALTERNATION GROUP: <empty>
--
[UNPARSED_SQL]
IMPORT PROTO "a/b/c";
--
ALTERNATION GROUP: OPTIONS(e=2)
--
[UNPARSED_SQL]
IMPORT PROTO "a/b/c" OPTIONS(e = 2);
--
ALTERNATION GROUP: INTO d,
--
[UNPARSED_SQL]
IMPORT PROTO "a/b/c" INTO d;
--
ALTERNATION GROUP: INTO d,OPTIONS(e=2)
--
[UNPARSED_SQL]
IMPORT PROTO "a/b/c" INTO d OPTIONS(e = 2);
==

# ALTER TABLE SET OPTIONS
ALTER TABLE foo.bar SET OPTIONS(description="foo") ;
--
[UNPARSED_SQL]
ALTER TABLE foo.bar SET OPTIONS(description = "foo");
==

# ALTER TABLE SET OPTIONS
ALTER TABLE IF EXISTS foo.bar SET OPTIONS(description="foo") ;
--
[UNPARSED_SQL]
ALTER TABLE IF EXISTS foo.bar SET OPTIONS(description = "foo");
==

# ALTER DATABASE SET OPTIONS
ALTER DATABASE db1 SET OPTIONS(description="foo") ;
--
[UNPARSED_SQL]
ALTER DATABASE db1 SET OPTIONS(description = "foo");
==

# ALTER DATABASE SET OPTIONS
ALTER DATABASE IF EXISTS db1 SET OPTIONS(description="foo") ;
--
[UNPARSED_SQL]
ALTER DATABASE IF EXISTS db1 SET OPTIONS(description = "foo");
==

EXECUTE IMMEDIATE "select 1" INTO x,y USING 4,5;
--
[UNPARSED_SQL]
EXECUTE IMMEDIATE "select 1" INTO x, y USING 4, 5;
==

EXECUTE IMMEDIATE CONCAT("select", " 1") INTO x,y USING 4 as x,5 as y;
--
[UNPARSED_SQL]
EXECUTE IMMEDIATE CONCAT("select", " 1") INTO x, y USING 4 AS x, 5 AS y;

==

analyze OPTIONS(p1=a1,p2=a2) SimpleTypes(int32,int64,double)
--
[UNPARSED_SQL]
ANALYZE OPTIONS(p1 = "a1", p2 = "a2") SimpleTypes(int32, int64, double);
==

analyze OPTIONS(p1=a1,p2=a2) AllPseudoColumns(Key, Value)
--
ERROR: Cannot ANALYZE pseudo-column Key [at 1:30]
analyze OPTIONS(p1=a1,p2=a2) AllPseudoColumns(Key, Value)
                             ^
==

analyze OPTIONS(p1=a1,p2=a2) SimpleTypes(int32,int64,double), SimpleTypesWithAnonymizationUid(string,double)
--
[UNPARSED_SQL]
ANALYZE OPTIONS(p1 = "a1", p2 = "a2") SimpleTypes(int32, int64, double), SimpleTypesWithAnonymizationUid(string,
    double);
==

analyze OPTIONS(p1=a1,p2=a2) SimpleTypes, SimpleTypesWithAnonymizationUid(string,double)
--
[UNPARSED_SQL]
ANALYZE OPTIONS(p1 = "a1", p2 = "a2") SimpleTypes, SimpleTypesWithAnonymizationUid(string, double);
==

# Note that the order of the columns being analyzed is canonicalized in the
# generated SQL to reflect the order of the columns in the Catalog Table.
analyze SimpleTypes(string,double,int32)
--
[UNPARSED_SQL]
ANALYZE SimpleTypes(int32, string, double);
==

analyze SimpleTypes
--
[UNPARSED_SQL]
ANALYZE SimpleTypes;
==

analyze SimpleTypes, SimpleTypesWithAnonymizationUid
--
[UNPARSED_SQL]
ANALYZE SimpleTypes, SimpleTypesWithAnonymizationUid;
==

analyze OPTIONS()
--
[UNPARSED_SQL]
ANALYZE;
==

analyze OPTIONS(p1=a1,p2=a2)
--
[UNPARSED_SQL]
ANALYZE OPTIONS(p1 = "a1", p2 = "a2");
==

analyze
--
[UNPARSED_SQL]
ANALYZE;
==
