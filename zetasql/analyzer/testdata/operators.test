select 1 from SimpleTypes
where int32 = 5
   or int64 = 6
   or uint32 = 7
   or uint64 = 8
   or string = 'aaa'
   or bytes = b'aaa'
   or float = 9
   or double = 10
   or date = date
   or bool = true
   or timestamp = timestamp
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$or(BOOL, repeated(10) BOOL) -> BOOL)
            +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
            | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            | +-Literal(type=INT32, value=5)
            +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            | +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            | +-Literal(type=INT64, value=6)
            +-FunctionCall(ZetaSQL:$equal(UINT32, UINT32) -> BOOL)
            | +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
            | +-Literal(type=UINT32, value=7)
            +-FunctionCall(ZetaSQL:$equal(UINT64, INT64) -> BOOL)
            | +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
            | +-Literal(type=INT64, value=8)
            +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
            | +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
            | +-Literal(type=STRING, value="aaa")
            +-FunctionCall(ZetaSQL:$equal(BYTES, BYTES) -> BOOL)
            | +-ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
            | +-Literal(type=BYTES, value=b"aaa")
            +-FunctionCall(ZetaSQL:$equal(FLOAT, FLOAT) -> BOOL)
            | +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
            | +-Literal(type=FLOAT, value=9)
            +-FunctionCall(ZetaSQL:$equal(DOUBLE, DOUBLE) -> BOOL)
            | +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
            | +-Literal(type=DOUBLE, value=10)
            +-FunctionCall(ZetaSQL:$equal(DATE, DATE) -> BOOL)
            | +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
            | +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
            +-FunctionCall(ZetaSQL:$equal(BOOL, BOOL) -> BOOL)
            | +-ColumnRef(type=BOOL, column=SimpleTypes.bool#7)
            | +-Literal(type=BOOL, value=true)
            +-FunctionCall(ZetaSQL:$equal(TIMESTAMP, TIMESTAMP) -> BOOL)
              +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
              +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
==

# A few basic tests for comparisons between UINT64 and INT32/INT64.
select uint64 = int64,
       uint64 > int32,
       uint64 >= int64,
       uint64 <= int32,
       uint64 < int64,
       uint64 != int32,
       "------------------------------",
       int64 = uint64,
       int32 > uint64,
       int64 >= uint64,
       int32 <= uint64,
       int64 < uint64,
       int32 != uint64
from SimpleTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [BOOL]
| +-$query.$col2#20 AS `$col2` [BOOL]
| +-$query.$col3#21 AS `$col3` [BOOL]
| +-$query.$col4#22 AS `$col4` [BOOL]
| +-$query.$col5#23 AS `$col5` [BOOL]
| +-$query.$col6#24 AS `$col6` [BOOL]
| +-$query.$col7#25 AS `$col7` [STRING]
| +-$query.$col8#26 AS `$col8` [BOOL]
| +-$query.$col9#27 AS `$col9` [BOOL]
| +-$query.$col10#28 AS `$col10` [BOOL]
| +-$query.$col11#29 AS `$col11` [BOOL]
| +-$query.$col12#30 AS `$col12` [BOOL]
| +-$query.$col13#31 AS `$col13` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#19, $col2#20, $col3#21, $col4#22, $col5#23, $col6#24, $col7#25, $col8#26, $col9#27, $col10#28, $col11#29, $col12#30, $col13#31]
    +-expr_list=
    | +-$col1#19 :=
    | | +-FunctionCall(ZetaSQL:$equal(UINT64, INT64) -> BOOL)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | +-$col2#20 :=
    | | +-FunctionCall(ZetaSQL:$greater(UINT64, INT64) -> BOOL)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | |   +-Cast(INT32 -> INT64)
    | |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | +-$col3#21 :=
    | | +-FunctionCall(ZetaSQL:$greater_or_equal(UINT64, INT64) -> BOOL)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | +-$col4#22 :=
    | | +-FunctionCall(ZetaSQL:$less_or_equal(UINT64, INT64) -> BOOL)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | |   +-Cast(INT32 -> INT64)
    | |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | +-$col5#23 :=
    | | +-FunctionCall(ZetaSQL:$less(UINT64, INT64) -> BOOL)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | +-$col6#24 :=
    | | +-FunctionCall(ZetaSQL:$not_equal(UINT64, INT64) -> BOOL)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | |   +-Cast(INT32 -> INT64)
    | |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | +-$col7#25 := Literal(type=STRING, value="------------------------------")
    | +-$col8#26 :=
    | | +-FunctionCall(ZetaSQL:$equal(INT64, UINT64) -> BOOL)
    | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | +-$col9#27 :=
    | | +-FunctionCall(ZetaSQL:$greater(INT64, UINT64) -> BOOL)
    | |   +-Cast(INT32 -> INT64)
    | |   | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | +-$col10#28 :=
    | | +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, UINT64) -> BOOL)
    | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | +-$col11#29 :=
    | | +-FunctionCall(ZetaSQL:$less_or_equal(INT64, UINT64) -> BOOL)
    | |   +-Cast(INT32 -> INT64)
    | |   | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | +-$col12#30 :=
    | | +-FunctionCall(ZetaSQL:$less(INT64, UINT64) -> BOOL)
    | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | +-$col13#31 :=
    |   +-FunctionCall(ZetaSQL:$not_equal(INT64, UINT64) -> BOOL)
    |     +-Cast(INT32 -> INT64)
    |     | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    |     +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    +-input_scan=
      +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint64#4], table=SimpleTypes, column_index_list=[0, 1, 3])
==

select TestEnum = TestEnum from ComplexTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
    |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
    |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.TestEnum#2], table=ComplexTypes, column_index_list=[1])
==

select KitchenSink = KitchenSink from ComplexTypes;
--
ERROR: Equality is not defined for arguments of type PROTO<zetasql_test__.KitchenSinkPB> [at 1:8]
select KitchenSink = KitchenSink from ComplexTypes;
       ^
==

[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select Int32Array = Int32Array from ComplexTypes;
--
ALTERNATION GROUP: <empty>
--
ERROR: Equality is not defined for arguments of type ARRAY<INT32> [at 1:8]
select Int32Array = Int32Array from ComplexTypes;
       ^
--
ALTERNATION GROUP: V_1_1_ARRAY_EQUALITY
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$equal(ARRAY<INT32>, ARRAY<INT32>) -> BOOL)
    |     +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |     +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.Int32Array#4], table=ComplexTypes, column_index_list=[3])
==

[language_features={{|V_1_3_ARRAY_ORDERING}}]
select Int32Array < Int32Array from ComplexTypes;
--
ALTERNATION GROUP: <empty>
--
ERROR: Less than is not defined for arguments of type ARRAY<INT32> [at 1:8]
select Int32Array < Int32Array from ComplexTypes;
       ^
--
ALTERNATION GROUP: V_1_3_ARRAY_ORDERING
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$less(ARRAY<INT32>, ARRAY<INT32>) -> BOOL)
    |     +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |     +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.Int32Array#4], table=ComplexTypes, column_index_list=[3])
==

[language_features={{|V_1_3_ARRAY_ORDERING}}]
select Int32Array <= Int32Array from ComplexTypes;
--
ALTERNATION GROUP: <empty>
--
ERROR: Less than is not defined for arguments of type ARRAY<INT32> [at 1:8]
select Int32Array <= Int32Array from ComplexTypes;
       ^
--
ALTERNATION GROUP: V_1_3_ARRAY_ORDERING
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$less_or_equal(ARRAY<INT32>, ARRAY<INT32>) -> BOOL)
    |     +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |     +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.Int32Array#4], table=ComplexTypes, column_index_list=[3])
==

[language_features={{|V_1_3_ARRAY_ORDERING}}]
select Int32Array > Int32Array from ComplexTypes;
--
ALTERNATION GROUP: <empty>
--
ERROR: Greater than is not defined for arguments of type ARRAY<INT32> [at 1:8]
select Int32Array > Int32Array from ComplexTypes;
       ^
--
ALTERNATION GROUP: V_1_3_ARRAY_ORDERING
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$greater(ARRAY<INT32>, ARRAY<INT32>) -> BOOL)
    |     +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |     +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.Int32Array#4], table=ComplexTypes, column_index_list=[3])
==

[language_features={{|V_1_3_ARRAY_ORDERING}}]
select Int32Array >= Int32Array from ComplexTypes;
--
ALTERNATION GROUP: <empty>
--
ERROR: Greater than is not defined for arguments of type ARRAY<INT32> [at 1:8]
select Int32Array >= Int32Array from ComplexTypes;
       ^
--
ALTERNATION GROUP: V_1_3_ARRAY_ORDERING
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$greater_or_equal(ARRAY<INT32>, ARRAY<INT32>) -> BOOL)
    |     +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |     +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.Int32Array#4], table=ComplexTypes, column_index_list=[3])
==

# Arrays of uncomparable elements are uncomparable.
[language_features={{|V_1_3_ARRAY_ORDERING}}]
select [KitchenSink] > [KitchenSink] from ComplexTypes
--
ERROR: Greater than is not defined for arguments of type ARRAY<PROTO<zetasql_test__.KitchenSinkPB>> [at 1:8]
select [KitchenSink] > [KitchenSink] from ComplexTypes
       ^
==

# Structs are not comparable if any of the field types are not comparable.
select (KitchenSink, 0) = (KitchenSink, 0) from ComplexTypes
--
ERROR: Equality is not defined for arguments of type STRUCT<PROTO<zetasql_test__.KitchenSinkPB>, INT64> [at 1:8]
select (KitchenSink, 0) = (KitchenSink, 0) from ComplexTypes
       ^
==

[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select (Int32Array, 0) = (Int32Array, 0) from ComplexTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: Equality is not defined for arguments of type STRUCT<ARRAY<INT32>, INT64> [at 1:8]
select (Int32Array, 0) = (Int32Array, 0) from ComplexTypes
       ^
--
ALTERNATION GROUP: V_1_1_ARRAY_EQUALITY
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$equal(STRUCT<ARRAY<INT32>, INT64>, STRUCT<ARRAY<INT32>, INT64>) -> BOOL)
    |     +-MakeStruct
    |     | +-type=STRUCT<ARRAY<INT32>, INT64>
    |     | +-field_list=
    |     |   +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |     |   +-Literal(type=INT64, value=0)
    |     +-MakeStruct
    |       +-type=STRUCT<ARRAY<INT32>, INT64>
    |       +-field_list=
    |         +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |         +-Literal(type=INT64, value=0)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.Int32Array#4], table=ComplexTypes, column_index_list=[3])
==

# Structs are not comparable if any of the field types are not comparable.
select (KitchenSink, 0) = (KitchenSink, 0) from ComplexTypes
--
ERROR: Equality is not defined for arguments of type STRUCT<PROTO<zetasql_test__.KitchenSinkPB>, INT64> [at 1:8]
select (KitchenSink, 0) = (KitchenSink, 0) from ComplexTypes
       ^
==

select struct() = struct()
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$equal(STRUCT<>, STRUCT<>) -> BOOL)
    |     +-Literal(type=STRUCT<>, value={})
    |     +-Literal(type=STRUCT<>, value={})
    +-input_scan=
      +-SingleRowScan
==

select TestStruct = TestStruct from ComplexTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$equal(STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, STRUCT<c INT32, d STRUCT<a INT32, b STRING>>) -> BOOL)
    |     +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
    |     +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4])
==

select 1 from SimpleTypes
where int32 != 5
   or int64 <> 6
   or uint32 != 7
   or uint64 <> 8
   or string != 'aaa'
   or bytes <> b'bbb'
   or float != 9
   or double <> 10
   or date != date
   or bool <> true
   or timestamp != timestamp
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$or(BOOL, repeated(10) BOOL) -> BOOL)
            +-FunctionCall(ZetaSQL:$not_equal(INT32, INT32) -> BOOL)
            | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            | +-Literal(type=INT32, value=5)
            +-FunctionCall(ZetaSQL:$not_equal(INT64, INT64) -> BOOL)
            | +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            | +-Literal(type=INT64, value=6)
            +-FunctionCall(ZetaSQL:$not_equal(UINT32, UINT32) -> BOOL)
            | +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
            | +-Literal(type=UINT32, value=7)
            +-FunctionCall(ZetaSQL:$not_equal(UINT64, INT64) -> BOOL)
            | +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
            | +-Literal(type=INT64, value=8)
            +-FunctionCall(ZetaSQL:$not_equal(STRING, STRING) -> BOOL)
            | +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
            | +-Literal(type=STRING, value="aaa")
            +-FunctionCall(ZetaSQL:$not_equal(BYTES, BYTES) -> BOOL)
            | +-ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
            | +-Literal(type=BYTES, value=b"bbb")
            +-FunctionCall(ZetaSQL:$not_equal(FLOAT, FLOAT) -> BOOL)
            | +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
            | +-Literal(type=FLOAT, value=9)
            +-FunctionCall(ZetaSQL:$not_equal(DOUBLE, DOUBLE) -> BOOL)
            | +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
            | +-Literal(type=DOUBLE, value=10)
            +-FunctionCall(ZetaSQL:$not_equal(DATE, DATE) -> BOOL)
            | +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
            | +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
            +-FunctionCall(ZetaSQL:$not_equal(BOOL, BOOL) -> BOOL)
            | +-ColumnRef(type=BOOL, column=SimpleTypes.bool#7)
            | +-Literal(type=BOOL, value=true)
            +-FunctionCall(ZetaSQL:$not_equal(TIMESTAMP, TIMESTAMP) -> BOOL)
              +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
              +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
==

select TestEnum != TestEnum from ComplexTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$not_equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
    |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
    |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.TestEnum#2], table=ComplexTypes, column_index_list=[1])
==

select KitchenSink <> KitchenSink from ComplexTypes;
--
ERROR: Inequality is not defined for arguments of type PROTO<zetasql_test__.KitchenSinkPB> [at 1:8]
select KitchenSink <> KitchenSink from ComplexTypes;
       ^
==

[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select Int32Array != Int32Array from ComplexTypes;
--
ALTERNATION GROUP: <empty>
--
ERROR: Inequality is not defined for arguments of type ARRAY<INT32> [at 1:8]
select Int32Array != Int32Array from ComplexTypes;
       ^
--
ALTERNATION GROUP: V_1_1_ARRAY_EQUALITY
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$not_equal(ARRAY<INT32>, ARRAY<INT32>) -> BOOL)
    |     +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |     +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.Int32Array#4], table=ComplexTypes, column_index_list=[3])
==

select TestStruct <> TestStruct from ComplexTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$not_equal(STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, STRUCT<c INT32, d STRUCT<a INT32, b STRING>>) -> BOOL)
    |     +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
    |     +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4])
==

select 1 from SimpleTypes
where int32 < 5
   or int64 < 6
   or uint32 < 7
   or uint64 < 8
   or string < 'aaa'
   or bytes < b'bbb'
   or float < 9
   or double < 10
   or bool < true
   or date < date
   or timestamp <  timestamp
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$or(BOOL, repeated(10) BOOL) -> BOOL)
            +-FunctionCall(ZetaSQL:$less(INT32, INT32) -> BOOL)
            | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            | +-Literal(type=INT32, value=5)
            +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            | +-Literal(type=INT64, value=6)
            +-FunctionCall(ZetaSQL:$less(UINT32, UINT32) -> BOOL)
            | +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
            | +-Literal(type=UINT32, value=7)
            +-FunctionCall(ZetaSQL:$less(UINT64, INT64) -> BOOL)
            | +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
            | +-Literal(type=INT64, value=8)
            +-FunctionCall(ZetaSQL:$less(STRING, STRING) -> BOOL)
            | +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
            | +-Literal(type=STRING, value="aaa")
            +-FunctionCall(ZetaSQL:$less(BYTES, BYTES) -> BOOL)
            | +-ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
            | +-Literal(type=BYTES, value=b"bbb")
            +-FunctionCall(ZetaSQL:$less(FLOAT, FLOAT) -> BOOL)
            | +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
            | +-Literal(type=FLOAT, value=9)
            +-FunctionCall(ZetaSQL:$less(DOUBLE, DOUBLE) -> BOOL)
            | +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
            | +-Literal(type=DOUBLE, value=10)
            +-FunctionCall(ZetaSQL:$less(BOOL, BOOL) -> BOOL)
            | +-ColumnRef(type=BOOL, column=SimpleTypes.bool#7)
            | +-Literal(type=BOOL, value=true)
            +-FunctionCall(ZetaSQL:$less(DATE, DATE) -> BOOL)
            | +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
            | +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
            +-FunctionCall(ZetaSQL:$less(TIMESTAMP, TIMESTAMP) -> BOOL)
              +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
              +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
==

select TestEnum < TestEnum from ComplexTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$less(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
    |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
    |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.TestEnum#2], table=ComplexTypes, column_index_list=[1])
==

select KitchenSink < KitchenSink from ComplexTypes;
--
ERROR: Less than is not defined for arguments of type PROTO<zetasql_test__.KitchenSinkPB> [at 1:8]
select KitchenSink < KitchenSink from ComplexTypes;
       ^
==

select Int32Array < Int32Array from ComplexTypes;
--
ERROR: Less than is not defined for arguments of type ARRAY<INT32> [at 1:8]
select Int32Array < Int32Array from ComplexTypes;
       ^
==

select TestStruct < TestStruct from ComplexTypes;
--
ERROR: Less than is not defined for arguments of type STRUCT<c INT32, d STRUCT<a INT32, b STRING>> [at 1:8]
select TestStruct < TestStruct from ComplexTypes;
       ^
==

select 1 from SimpleTypes
where int32 <= 5
   or int64 <= 6
   or uint32 <= 7
   or uint64 <= 8
   or string <= 'aaa'
   or bytes <= b'bbb'
   or float <= 9
   or double <= 10
   or bool <= true
   or date <= date
   or timestamp <=  timestamp
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$or(BOOL, repeated(10) BOOL) -> BOOL)
            +-FunctionCall(ZetaSQL:$less_or_equal(INT32, INT32) -> BOOL)
            | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            | +-Literal(type=INT32, value=5)
            +-FunctionCall(ZetaSQL:$less_or_equal(INT64, INT64) -> BOOL)
            | +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            | +-Literal(type=INT64, value=6)
            +-FunctionCall(ZetaSQL:$less_or_equal(UINT32, UINT32) -> BOOL)
            | +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
            | +-Literal(type=UINT32, value=7)
            +-FunctionCall(ZetaSQL:$less_or_equal(UINT64, INT64) -> BOOL)
            | +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
            | +-Literal(type=INT64, value=8)
            +-FunctionCall(ZetaSQL:$less_or_equal(STRING, STRING) -> BOOL)
            | +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
            | +-Literal(type=STRING, value="aaa")
            +-FunctionCall(ZetaSQL:$less_or_equal(BYTES, BYTES) -> BOOL)
            | +-ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
            | +-Literal(type=BYTES, value=b"bbb")
            +-FunctionCall(ZetaSQL:$less_or_equal(FLOAT, FLOAT) -> BOOL)
            | +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
            | +-Literal(type=FLOAT, value=9)
            +-FunctionCall(ZetaSQL:$less_or_equal(DOUBLE, DOUBLE) -> BOOL)
            | +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
            | +-Literal(type=DOUBLE, value=10)
            +-FunctionCall(ZetaSQL:$less_or_equal(BOOL, BOOL) -> BOOL)
            | +-ColumnRef(type=BOOL, column=SimpleTypes.bool#7)
            | +-Literal(type=BOOL, value=true)
            +-FunctionCall(ZetaSQL:$less_or_equal(DATE, DATE) -> BOOL)
            | +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
            | +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
            +-FunctionCall(ZetaSQL:$less_or_equal(TIMESTAMP, TIMESTAMP) -> BOOL)
              +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
              +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
==

select TestEnum <= TestEnum from ComplexTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$less_or_equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
    |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
    |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.TestEnum#2], table=ComplexTypes, column_index_list=[1])
==

select KitchenSink <= KitchenSink from ComplexTypes;
--
ERROR: Less than is not defined for arguments of type PROTO<zetasql_test__.KitchenSinkPB> [at 1:8]
select KitchenSink <= KitchenSink from ComplexTypes;
       ^
==

select Int32Array <= Int32Array from ComplexTypes;
--
ERROR: Less than is not defined for arguments of type ARRAY<INT32> [at 1:8]
select Int32Array <= Int32Array from ComplexTypes;
       ^
==

select TestStruct <= TestStruct from ComplexTypes;
--
ERROR: Less than is not defined for arguments of type STRUCT<c INT32, d STRUCT<a INT32, b STRING>> [at 1:8]
select TestStruct <= TestStruct from ComplexTypes;
       ^
==

select 1 from SimpleTypes
where int32 >= 5
   or int64 >= 6
   or uint32 >= 7
   or uint64 >= 8
   or string >= 'aaa'
   or bytes >= b'bbb'
   or float >= 9
   or double >= 10
   or bool >= false
   or date >= date
   or timestamp >=  timestamp
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$or(BOOL, repeated(10) BOOL) -> BOOL)
            +-FunctionCall(ZetaSQL:$greater_or_equal(INT32, INT32) -> BOOL)
            | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            | +-Literal(type=INT32, value=5)
            +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            | +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            | +-Literal(type=INT64, value=6)
            +-FunctionCall(ZetaSQL:$greater_or_equal(UINT32, UINT32) -> BOOL)
            | +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
            | +-Literal(type=UINT32, value=7)
            +-FunctionCall(ZetaSQL:$greater_or_equal(UINT64, INT64) -> BOOL)
            | +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
            | +-Literal(type=INT64, value=8)
            +-FunctionCall(ZetaSQL:$greater_or_equal(STRING, STRING) -> BOOL)
            | +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
            | +-Literal(type=STRING, value="aaa")
            +-FunctionCall(ZetaSQL:$greater_or_equal(BYTES, BYTES) -> BOOL)
            | +-ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
            | +-Literal(type=BYTES, value=b"bbb")
            +-FunctionCall(ZetaSQL:$greater_or_equal(FLOAT, FLOAT) -> BOOL)
            | +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
            | +-Literal(type=FLOAT, value=9)
            +-FunctionCall(ZetaSQL:$greater_or_equal(DOUBLE, DOUBLE) -> BOOL)
            | +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
            | +-Literal(type=DOUBLE, value=10)
            +-FunctionCall(ZetaSQL:$greater_or_equal(BOOL, BOOL) -> BOOL)
            | +-ColumnRef(type=BOOL, column=SimpleTypes.bool#7)
            | +-Literal(type=BOOL, value=false)
            +-FunctionCall(ZetaSQL:$greater_or_equal(DATE, DATE) -> BOOL)
            | +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
            | +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
            +-FunctionCall(ZetaSQL:$greater_or_equal(TIMESTAMP, TIMESTAMP) -> BOOL)
              +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
              +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
==

select TestEnum >= TestEnum from ComplexTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$greater_or_equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
    |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
    |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.TestEnum#2], table=ComplexTypes, column_index_list=[1])
==

select KitchenSink >= KitchenSink from ComplexTypes;
--
ERROR: Greater than is not defined for arguments of type PROTO<zetasql_test__.KitchenSinkPB> [at 1:8]
select KitchenSink >= KitchenSink from ComplexTypes;
       ^
==

select Int32Array >= Int32Array from ComplexTypes;
--
ERROR: Greater than is not defined for arguments of type ARRAY<INT32> [at 1:8]
select Int32Array >= Int32Array from ComplexTypes;
       ^
==

select TestStruct >= TestStruct from ComplexTypes;
--
ERROR: Greater than is not defined for arguments of type STRUCT<c INT32, d STRUCT<a INT32, b STRING>> [at 1:8]
select TestStruct >= TestStruct from ComplexTypes;
       ^
==

select 1 from SimpleTypes
where int32 > 5
   or int64 > 6
   or uint32 > 7
   or uint64 > 8
   or string > 'aaa'
   or bytes > b'bbb'
   or float > 9
   or double > 10
   or bool > false
   or date > date
   or timestamp >  timestamp
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$or(BOOL, repeated(10) BOOL) -> BOOL)
            +-FunctionCall(ZetaSQL:$greater(INT32, INT32) -> BOOL)
            | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            | +-Literal(type=INT32, value=5)
            +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            | +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            | +-Literal(type=INT64, value=6)
            +-FunctionCall(ZetaSQL:$greater(UINT32, UINT32) -> BOOL)
            | +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
            | +-Literal(type=UINT32, value=7)
            +-FunctionCall(ZetaSQL:$greater(UINT64, INT64) -> BOOL)
            | +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
            | +-Literal(type=INT64, value=8)
            +-FunctionCall(ZetaSQL:$greater(STRING, STRING) -> BOOL)
            | +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
            | +-Literal(type=STRING, value="aaa")
            +-FunctionCall(ZetaSQL:$greater(BYTES, BYTES) -> BOOL)
            | +-ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
            | +-Literal(type=BYTES, value=b"bbb")
            +-FunctionCall(ZetaSQL:$greater(FLOAT, FLOAT) -> BOOL)
            | +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
            | +-Literal(type=FLOAT, value=9)
            +-FunctionCall(ZetaSQL:$greater(DOUBLE, DOUBLE) -> BOOL)
            | +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
            | +-Literal(type=DOUBLE, value=10)
            +-FunctionCall(ZetaSQL:$greater(BOOL, BOOL) -> BOOL)
            | +-ColumnRef(type=BOOL, column=SimpleTypes.bool#7)
            | +-Literal(type=BOOL, value=false)
            +-FunctionCall(ZetaSQL:$greater(DATE, DATE) -> BOOL)
            | +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
            | +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
            +-FunctionCall(ZetaSQL:$greater(TIMESTAMP, TIMESTAMP) -> BOOL)
              +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
              +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
==

select TestEnum > TestEnum from ComplexTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$greater(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
    |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
    |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.TestEnum#2], table=ComplexTypes, column_index_list=[1])
==

select KitchenSink > KitchenSink from ComplexTypes;
--
ERROR: Greater than is not defined for arguments of type PROTO<zetasql_test__.KitchenSinkPB> [at 1:8]
select KitchenSink > KitchenSink from ComplexTypes;
       ^
==

select Int32Array > Int32Array from ComplexTypes;
--
ERROR: Greater than is not defined for arguments of type ARRAY<INT32> [at 1:8]
select Int32Array > Int32Array from ComplexTypes;
       ^
==

select TestStruct > TestStruct from ComplexTypes;
--
ERROR: Greater than is not defined for arguments of type STRUCT<c INT32, d STRUCT<a INT32, b STRING>> [at 1:8]
select TestStruct > TestStruct from ComplexTypes;
       ^
==

select 1<<3, ~2, 3&2, 2>>1, 1|2, 2^2;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
| +-$query.$col2#2 AS `$col2` [INT64]
| +-$query.$col3#3 AS `$col3` [INT64]
| +-$query.$col4#4 AS `$col4` [INT64]
| +-$query.$col5#5 AS `$col5` [INT64]
| +-$query.$col6#6 AS `$col6` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:$bitwise_left_shift(INT64, INT64) -> INT64)
    | |   +-Literal(type=INT64, value=1)
    | |   +-Literal(type=INT64, value=3)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:$bitwise_not(INT64) -> INT64)
    | |   +-Literal(type=INT64, value=2)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:$bitwise_and(INT64, INT64) -> INT64)
    | |   +-Literal(type=INT64, value=3)
    | |   +-Literal(type=INT64, value=2)
    | +-$col4#4 :=
    | | +-FunctionCall(ZetaSQL:$bitwise_right_shift(INT64, INT64) -> INT64)
    | |   +-Literal(type=INT64, value=2)
    | |   +-Literal(type=INT64, value=1)
    | +-$col5#5 :=
    | | +-FunctionCall(ZetaSQL:$bitwise_or(INT64, INT64) -> INT64)
    | |   +-Literal(type=INT64, value=1)
    | |   +-Literal(type=INT64, value=2)
    | +-$col6#6 :=
    |   +-FunctionCall(ZetaSQL:$bitwise_xor(INT64, INT64) -> INT64)
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=INT64, value=2)
    +-input_scan=
      +-SingleRowScan
==

select 1~2;
--
ERROR: Syntax error: Expected end of input but got "~" [at 1:9]
select 1~2;
        ^
==

select 1<<3&-2>>1|2^2
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$bitwise_or(INT64, INT64) -> INT64)
    |     +-FunctionCall(ZetaSQL:$bitwise_and(INT64, INT64) -> INT64)
    |     | +-FunctionCall(ZetaSQL:$bitwise_left_shift(INT64, INT64) -> INT64)
    |     | | +-Literal(type=INT64, value=1)
    |     | | +-Literal(type=INT64, value=3)
    |     | +-FunctionCall(ZetaSQL:$bitwise_right_shift(INT64, INT64) -> INT64)
    |     |   +-Literal(type=INT64, value=-2)
    |     |   +-Literal(type=INT64, value=1)
    |     +-FunctionCall(ZetaSQL:$bitwise_xor(INT64, INT64) -> INT64)
    |       +-Literal(type=INT64, value=2)
    |       +-Literal(type=INT64, value=2)
    +-input_scan=
      +-SingleRowScan
==

select b'foo'<<3&~b'bar'>>1|b'abc'^b'xyz'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$bitwise_or(BYTES, BYTES) -> BYTES)
    |     +-FunctionCall(ZetaSQL:$bitwise_and(BYTES, BYTES) -> BYTES)
    |     | +-FunctionCall(ZetaSQL:$bitwise_left_shift(BYTES, INT64) -> BYTES)
    |     | | +-Literal(type=BYTES, value=b"foo")
    |     | | +-Literal(type=INT64, value=3)
    |     | +-FunctionCall(ZetaSQL:$bitwise_right_shift(BYTES, INT64) -> BYTES)
    |     |   +-FunctionCall(ZetaSQL:$bitwise_not(BYTES) -> BYTES)
    |     |   | +-Literal(type=BYTES, value=b"bar")
    |     |   +-Literal(type=INT64, value=1)
    |     +-FunctionCall(ZetaSQL:$bitwise_xor(BYTES, BYTES) -> BYTES)
    |       +-Literal(type=BYTES, value=b"abc")
    |       +-Literal(type=BYTES, value=b"xyz")
    +-input_scan=
      +-SingleRowScan
==

# The second argument can coerce to INT64 for left and right shift.
select * from TestTable
where KitchenSink.uint64_val>>KitchenSink.int32_val > 2
and   KitchenSink.uint32_val<<KitchenSink.uint32_val > 2;
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3]
    +-input_scan=
      +-FilterScan
        +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
            +-FunctionCall(ZetaSQL:$greater(UINT64, INT64) -> BOOL)
            | +-FunctionCall(ZetaSQL:$bitwise_right_shift(UINT64, INT64) -> UINT64)
            | | +-GetProtoField
            | | | +-type=UINT64
            | | | +-expr=
            | | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | | | +-field_descriptor=uint64_val
            | | | +-default_value=0
            | | +-Cast(INT32 -> INT64)
            | |   +-GetProtoField
            | |     +-type=INT32
            | |     +-expr=
            | |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | |     +-field_descriptor=int32_val
            | |     +-default_value=77
            | +-Literal(type=INT64, value=2)
            +-FunctionCall(ZetaSQL:$greater(UINT32, UINT32) -> BOOL)
              +-FunctionCall(ZetaSQL:$bitwise_left_shift(UINT32, INT64) -> UINT32)
              | +-GetProtoField
              | | +-type=UINT32
              | | +-expr=
              | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              | | +-field_descriptor=uint32_val
              | | +-default_value=777
              | +-Cast(UINT32 -> INT64)
              |   +-GetProtoField
              |     +-type=UINT32
              |     +-expr=
              |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              |     +-field_descriptor=uint32_val
              |     +-default_value=777
              +-Literal(type=UINT32, value=2)
==

select * from TestTable
where KitchenSink.uint64_val>>KitchenSink.uint64_val > 2
--
ERROR: No matching signature for operator >> for argument types: UINT64, UINT64. Supported signatures: INT32 >> INT64; INT64 >> INT64; UINT32 >> INT64; UINT64 >> INT64; BYTES >> INT64 [at 2:29]
where KitchenSink.uint64_val>>KitchenSink.uint64_val > 2
                            ^
==

select * from TestTable
where KitchenSink.uint64_val & CAST(1 as UINT64) > 2
and   KitchenSink.uint32_val | CAST(1 as UINT32) > 2
and   KitchenSink.int64_val ^ CAST(1 as INT64) > 2
and   KitchenSink.int32_val & CAST(1 as INT32) > 2
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3]
    +-input_scan=
      +-FilterScan
        +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$and(BOOL, repeated(3) BOOL) -> BOOL)
            +-FunctionCall(ZetaSQL:$greater(UINT64, INT64) -> BOOL)
            | +-FunctionCall(ZetaSQL:$bitwise_and(UINT64, UINT64) -> UINT64)
            | | +-GetProtoField
            | | | +-type=UINT64
            | | | +-expr=
            | | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | | | +-field_descriptor=uint64_val
            | | | +-default_value=0
            | | +-Literal(type=UINT64, value=1, has_explicit_type=TRUE)
            | +-Literal(type=INT64, value=2)
            +-FunctionCall(ZetaSQL:$greater(UINT32, UINT32) -> BOOL)
            | +-FunctionCall(ZetaSQL:$bitwise_or(UINT32, UINT32) -> UINT32)
            | | +-GetProtoField
            | | | +-type=UINT32
            | | | +-expr=
            | | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | | | +-field_descriptor=uint32_val
            | | | +-default_value=777
            | | +-Literal(type=UINT32, value=1, has_explicit_type=TRUE)
            | +-Literal(type=UINT32, value=2)
            +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            | +-FunctionCall(ZetaSQL:$bitwise_xor(INT64, INT64) -> INT64)
            | | +-GetProtoField
            | | | +-type=INT64
            | | | +-expr=
            | | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | | | +-field_descriptor=int64_val
            | | | +-default_value=0
            | | +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
            | +-Literal(type=INT64, value=2)
            +-FunctionCall(ZetaSQL:$greater(INT32, INT32) -> BOOL)
              +-FunctionCall(ZetaSQL:$bitwise_and(INT32, INT32) -> INT32)
              | +-GetProtoField
              | | +-type=INT32
              | | +-expr=
              | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              | | +-field_descriptor=int32_val
              | | +-default_value=77
              | +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
              +-Literal(type=INT32, value=2)
==

select
KitchenSink.uint64_val & 1,
KitchenSink.uint32_val | 1,
KitchenSink.int64_val ^ 1,
KitchenSink.int32_val & 1,
2 | 1
from TestTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [UINT64]
| +-$query.$col2#5 AS `$col2` [UINT32]
| +-$query.$col3#6 AS `$col3` [INT64]
| +-$query.$col4#7 AS `$col4` [INT32]
| +-$query.$col5#8 AS `$col5` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#4, $col2#5, $col3#6, $col4#7, $col5#8]
    +-expr_list=
    | +-$col1#4 :=
    | | +-FunctionCall(ZetaSQL:$bitwise_and(UINT64, UINT64) -> UINT64)
    | |   +-GetProtoField
    | |   | +-type=UINT64
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=uint64_val
    | |   | +-default_value=0
    | |   +-Literal(type=UINT64, value=1)
    | +-$col2#5 :=
    | | +-FunctionCall(ZetaSQL:$bitwise_or(UINT32, UINT32) -> UINT32)
    | |   +-GetProtoField
    | |   | +-type=UINT32
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=uint32_val
    | |   | +-default_value=777
    | |   +-Literal(type=UINT32, value=1)
    | +-$col3#6 :=
    | | +-FunctionCall(ZetaSQL:$bitwise_xor(INT64, INT64) -> INT64)
    | |   +-GetProtoField
    | |   | +-type=INT64
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=int64_val
    | |   | +-default_value=0
    | |   +-Literal(type=INT64, value=1)
    | +-$col4#7 :=
    | | +-FunctionCall(ZetaSQL:$bitwise_and(INT32, INT32) -> INT32)
    | |   +-GetProtoField
    | |   | +-type=INT32
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=int32_val
    | |   | +-default_value=77
    | |   +-Literal(type=INT32, value=1)
    | +-$col5#8 :=
    |   +-FunctionCall(ZetaSQL:$bitwise_or(INT64, INT64) -> INT64)
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

select KitchenSink.uint64_val & cast(1 as int64)
from TestTable
--
ERROR: Bitwise operator & requires two integer/BYTES arguments of the same type, but saw UINT64 and INT64 [at 1:8]
select KitchenSink.uint64_val & cast(1 as int64)
       ^
==

select KitchenSink.uint32_val | cast(1 as int32)
from TestTable
--
ERROR: Bitwise operator | requires two integer/BYTES arguments of the same type, but saw UINT32 and INT32 [at 1:8]
select KitchenSink.uint32_val | cast(1 as int32)
       ^
==

select KitchenSink.int64_val ^ cast(1 as uint32)
from TestTable
--
ERROR: Bitwise operator ^ requires two integer/BYTES arguments of the same type, but saw INT64 and UINT32 [at 1:8]
select KitchenSink.int64_val ^ cast(1 as uint32)
       ^
==

select KitchenSink.int32_val & cast(1 as uint64)
from TestTable
--
ERROR: Bitwise operator & requires two integer/BYTES arguments of the same type, but saw INT32 and UINT64 [at 1:8]
select KitchenSink.int32_val & cast(1 as uint64)
       ^
==

select cast(2 as int32) | cast(1 as uint32)
--
ERROR: Bitwise operator | requires two integer/BYTES arguments of the same type, but saw INT32 and UINT32 [at 1:8]
select cast(2 as int32) | cast(1 as uint32)
       ^
==

select cast(2 as int32) | cast(1 as int64)
--
ERROR: Bitwise operator | requires two integer/BYTES arguments of the same type, but saw INT32 and INT64 [at 1:8]
select cast(2 as int32) | cast(1 as int64)
       ^
==

select 1 | 9223372036854775808
--
ERROR: Could not cast literal 9223372036854775808 to type INT64 [at 1:12]
select 1 | 9223372036854775808
           ^
==

# Different type integers do not coerce.
select * from TestTable
where KitchenSink.uint64_val & KitchenSink.uint32_val > 2;
--
ERROR: Bitwise operator & requires two integer/BYTES arguments of the same type, but saw UINT64 and UINT32 [at 2:7]
where KitchenSink.uint64_val & KitchenSink.uint32_val > 2;
      ^
==

# Different type integers do not coerce.
select * from TestTable
where KitchenSink.int64_val | KitchenSink.int32_val > 2;
--
ERROR: Bitwise operator | requires two integer/BYTES arguments of the same type, but saw INT64 and INT32 [at 2:7]
where KitchenSink.int64_val | KitchenSink.int32_val > 2;
      ^
==

# Different type integers do not coerce.
select * from TestTable
where KitchenSink.uint32_val ^ KitchenSink.int32_val > 2;
--
ERROR: Bitwise operator ^ requires two integer/BYTES arguments of the same type, but saw UINT32 and INT32 [at 2:7]
where KitchenSink.uint32_val ^ KitchenSink.int32_val > 2;
      ^
==

# Different type integers do not coerce.
select * from TestTable
where KitchenSink.uint64_val & KitchenSink.int32_val > 2;
--
ERROR: Bitwise operator & requires two integer/BYTES arguments of the same type, but saw UINT64 and INT32 [at 2:7]
where KitchenSink.uint64_val & KitchenSink.int32_val > 2;
      ^
==

select * from TestTable
where KitchenSink.uint64_val>>KitchenSink.int64_val > 2;
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3]
    +-input_scan=
      +-FilterScan
        +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$greater(UINT64, INT64) -> BOOL)
            +-FunctionCall(ZetaSQL:$bitwise_right_shift(UINT64, INT64) -> UINT64)
            | +-GetProtoField
            | | +-type=UINT64
            | | +-expr=
            | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | | +-field_descriptor=uint64_val
            | | +-default_value=0
            | +-GetProtoField
            |   +-type=INT64
            |   +-expr=
            |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            |   +-field_descriptor=int64_val
            |   +-default_value=0
            +-Literal(type=INT64, value=2)
==

select * from TestTable
where KitchenSink.uint64_val>>KitchenSink.uint32_val > 2;
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3]
    +-input_scan=
      +-FilterScan
        +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$greater(UINT64, INT64) -> BOOL)
            +-FunctionCall(ZetaSQL:$bitwise_right_shift(UINT64, INT64) -> UINT64)
            | +-GetProtoField
            | | +-type=UINT64
            | | +-expr=
            | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | | +-field_descriptor=uint64_val
            | | +-default_value=0
            | +-Cast(UINT32 -> INT64)
            |   +-GetProtoField
            |     +-type=UINT32
            |     +-expr=
            |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            |     +-field_descriptor=uint32_val
            |     +-default_value=777
            +-Literal(type=INT64, value=2)
==

select * from TestTable
where KitchenSink.uint64_val>>KitchenSink.uint64_val > 2;
--
ERROR: No matching signature for operator >> for argument types: UINT64, UINT64. Supported signatures: INT32 >> INT64; INT64 >> INT64; UINT32 >> INT64; UINT64 >> INT64; BYTES >> INT64 [at 2:29]
where KitchenSink.uint64_val>>KitchenSink.uint64_val > 2;
                            ^
==

# Bitwise operations are only defined on integers and BYTES.
select 'foo' >> 2;
--
ERROR: The first argument to bitwise operator >> must be an integer or BYTES but saw STRING [at 1:14]
select 'foo' >> 2;
             ^
==

select 'foo' & 'foo';
--
ERROR: Bitwise operator & requires two integer/BYTES arguments of the same type, but saw STRING and STRING [at 1:8]
select 'foo' & 'foo';
       ^
==

select true ^ false;
--
ERROR: Bitwise operator ^ requires two integer/BYTES arguments of the same type, but saw BOOL and BOOL [at 1:8]
select true ^ false;
       ^
==

select 1.0 & 2.0;
--
ERROR: Bitwise operator & requires two integer/BYTES arguments of the same type, but saw DOUBLE and DOUBLE [at 1:8]
select 1.0 & 2.0;
       ^
==

select KitchenSink.test_enum>>2 from TestTable;
--
ERROR: The first argument to bitwise operator >> must be an integer or BYTES but saw ENUM<zetasql_test__.TestEnum> [at 1:29]
select KitchenSink.test_enum>>2 from TestTable;
                            ^
==

select Int32Array>>2 from ComplexTypes;
--
ERROR: The first argument to bitwise operator >> must be an integer or BYTES but saw ARRAY<INT32> [at 1:18]
select Int32Array>>2 from ComplexTypes;
                 ^
==

select KitchenSink>>2 from ComplexTypes;
--
ERROR: The first argument to bitwise operator >> must be an integer or BYTES but saw PROTO<zetasql_test__.KitchenSinkPB> [at 1:19]
select KitchenSink>>2 from ComplexTypes;
                  ^
==

select TestStruct>>2 from ComplexTypes;
--
ERROR: The first argument to bitwise operator >> must be an integer or BYTES but saw STRUCT<c INT32, d STRUCT<a INT32, b STRING>> [at 1:18]
select TestStruct>>2 from ComplexTypes;
                 ^
==

select 1 + '1';
--
ERROR: No matching signature for operator + for argument types: INT64, STRING. Supported signatures: INT64 + INT64; UINT64 + UINT64; DOUBLE + DOUBLE [at 1:8]
select 1 + '1';
       ^
==

select +5
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=INT64, value=5)
    +-input_scan=
      +-SingleRowScan
==

select 5 = null
--
ERROR: Operands of = cannot be literal NULL [at 1:12]
select 5 = null
           ^
==

select null = 6
--
ERROR: Operands of = cannot be literal NULL [at 1:8]
select null = 6
       ^
==

select -null
--
ERROR: Operands of - cannot be literal NULL [at 1:9]
select -null
        ^
==

select +++1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

select - - - 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$unary_minus(INT64) -> INT64)
    |     +-FunctionCall(ZetaSQL:$unary_minus(INT64) -> INT64)
    |       +-Literal(type=INT64, value=-1)
    +-input_scan=
      +-SingleRowScan
==

select +-+-1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$unary_minus(INT64) -> INT64)
    |     +-Literal(type=INT64, value=-1)
    +-input_scan=
      +-SingleRowScan
==

select -+-+1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$unary_minus(INT64) -> INT64)
    |     +-FunctionCall(ZetaSQL:$unary_minus(INT64) -> INT64)
    |       +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

select +int32, + int64, +uint32, +uint64, +float, +double,
       "------------------------" as separator,
       -int32, - int64, -float, -double
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-SimpleTypes.int32#1 AS `$col1` [INT32]
| +-SimpleTypes.int64#2 AS `$col2` [INT64]
| +-SimpleTypes.uint32#3 AS `$col3` [UINT32]
| +-SimpleTypes.uint64#4 AS `$col4` [UINT64]
| +-SimpleTypes.float#8 AS `$col5` [FLOAT]
| +-SimpleTypes.double#9 AS `$col6` [DOUBLE]
| +-$query.separator#19 AS separator [STRING]
| +-$query.$col8#20 AS `$col8` [INT32]
| +-$query.$col9#21 AS `$col9` [INT64]
| +-$query.$col10#22 AS `$col10` [FLOAT]
| +-$query.$col11#23 AS `$col11` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[SimpleTypes.int32#1, SimpleTypes.int64#2, SimpleTypes.uint32#3, SimpleTypes.uint64#4, SimpleTypes.float#8, SimpleTypes.double#9, $query.separator#19, $query.$col8#20, $query.$col9#21, $query.$col10#22, $query.$col11#23]
    +-expr_list=
    | +-separator#19 := Literal(type=STRING, value="------------------------")
    | +-$col8#20 :=
    | | +-FunctionCall(ZetaSQL:$unary_minus(INT32) -> INT32)
    | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | +-$col9#21 :=
    | | +-FunctionCall(ZetaSQL:$unary_minus(INT64) -> INT64)
    | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | +-$col10#22 :=
    | | +-FunctionCall(ZetaSQL:$unary_minus(FLOAT) -> FLOAT)
    | |   +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
    | +-$col11#23 :=
    |   +-FunctionCall(ZetaSQL:$unary_minus(DOUBLE) -> DOUBLE)
    |     +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
    +-input_scan=
      +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, float#8, double#9], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 7, 8])
==

select -uint32
from SimpleTypes
--
ERROR: No matching signature for operator - for argument types: UINT32. Supported signatures: -(INT32); -(INT64); -(FLOAT); -(DOUBLE) [at 1:8]
select -uint32
       ^
==

select -uint64
from SimpleTypes
--
ERROR: No matching signature for operator - for argument types: UINT64. Supported signatures: -(INT32); -(INT64); -(FLOAT); -(DOUBLE) [at 1:8]
select -uint64
       ^
==

select 5++2, 5 +-2, 5- +2, 5- -2
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
| +-$query.$col2#2 AS `$col2` [INT64]
| +-$query.$col3#3 AS `$col3` [INT64]
| +-$query.$col4#4 AS `$col4` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-Literal(type=INT64, value=5)
    | |   +-Literal(type=INT64, value=2)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-Literal(type=INT64, value=5)
    | |   +-Literal(type=INT64, value=-2)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
    | |   +-Literal(type=INT64, value=5)
    | |   +-Literal(type=INT64, value=2)
    | +-$col4#4 :=
    |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
    |     +-Literal(type=INT64, value=5)
    |     +-Literal(type=INT64, value=-2)
    +-input_scan=
      +-SingleRowScan
==

select -bool from SimpleTypes
--
ERROR: No matching signature for operator - for argument types: BOOL. Supported signatures: -(INT32); -(INT64); -(FLOAT); -(DOUBLE) [at 1:8]
select -bool from SimpleTypes
       ^
==

select +"555"
--
ERROR: Operands of + must be numeric type but was STRING [at 1:9]
select +"555"
        ^
==

# b/17461053
select -187639081645735783 < cast(155636293719598921 as uint64),
       cast(155636293719598921 as uint64) = -187639081645735783
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
| +-$query.$col2#2 AS `$col2` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:$less(INT64, UINT64) -> BOOL)
    | |   +-Literal(type=INT64, value=-187639081645735783)
    | |   +-Literal(type=UINT64, value=155636293719598921, has_explicit_type=TRUE)
    | +-$col2#2 :=
    |   +-FunctionCall(ZetaSQL:$equal(UINT64, INT64) -> BOOL)
    |     +-Literal(type=UINT64, value=155636293719598921, has_explicit_type=TRUE)
    |     +-Literal(type=INT64, value=-187639081645735783)
    +-input_scan=
      +-SingleRowScan
==

# b/18816213, supertyping with parameters
select int32
from SimpleTypes
where date = @test_param_string
--
QueryStmt
+-output_column_list=
| +-SimpleTypes.int32#1 AS int32 [INT32]
+-query=
  +-ProjectScan
    +-column_list=[SimpleTypes.int32#1]
    +-input_scan=
      +-FilterScan
        +-column_list=SimpleTypes.[int32#1, date#10]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, date#10], table=SimpleTypes, column_index_list=[0, 9])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(DATE, DATE) -> BOOL)
            +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
            +-Cast(STRING -> DATE)
              +-Parameter(type=STRING, name="test_param_string")
==

# Java proto library fails in debugString() of the invalid proto message
select
  case
  when KitchenSink.int64_key_1 = 0 then @test_param_string
  when KitchenSink.int64_key_1 = 1 then @test_param_bytes
  when KitchenSink.int64_key_1 = 2 then "int64_key_1: 1, int64_key_2: 2"
  when KitchenSink.int64_key_1 = 3 then b"""int64_key_1: 3, int64_key_2: 4"""
  when KitchenSink.int64_key_1 = 4 then NULL
  else KitchenSink
  end
from ComplexTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-FunctionCall(ZetaSQL:$case_no_value(repeated(5) BOOL, repeated(5) PROTO<zetasql_test__.KitchenSinkPB>, PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |     | +-GetProtoField
    |     | | +-type=INT64
    |     | | +-expr=
    |     | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3)
    |     | | +-field_descriptor=int64_key_1
    |     | +-Literal(type=INT64, value=0)
    |     +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     | +-Parameter(type=STRING, name="test_param_string")
    |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |     | +-GetProtoField
    |     | | +-type=INT64
    |     | | +-expr=
    |     | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3)
    |     | | +-field_descriptor=int64_key_1
    |     | +-Literal(type=INT64, value=1)
    |     +-Cast(BYTES -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     | +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |     | +-GetProtoField
    |     | | +-type=INT64
    |     | | +-expr=
    |     | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3)
    |     | | +-field_descriptor=int64_key_1
    |     | +-Literal(type=INT64, value=2)
    |     +-Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={int64_key_1: 1 int64_key_2: 2})
    |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |     | +-GetProtoField
    |     | | +-type=INT64
    |     | | +-expr=
    |     | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3)
    |     | | +-field_descriptor=int64_key_1
    |     | +-Literal(type=INT64, value=3)
    |     +-Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={<unparseable>})
    |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |     | +-GetProtoField
    |     | | +-type=INT64
    |     | | +-expr=
    |     | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3)
    |     | | +-field_descriptor=int64_key_1
    |     | +-Literal(type=INT64, value=4)
    |     +-Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value=NULL)
    |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3)
    +-input_scan=
      +-TableScan(column_list=[ComplexTypes.KitchenSink#3], table=ComplexTypes, column_index_list=[2])
==

select 1
from ComplexTypes
where TestEnum in (@test_param_string, @test_param_int32, @test_param_int64,
                   "TESTENUM0", 0, null)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[ComplexTypes.TestEnum#2]
        +-input_scan=
        | +-TableScan(column_list=[ComplexTypes.TestEnum#2], table=ComplexTypes, column_index_list=[1])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$in(ENUM<zetasql_test__.TestEnum>, repeated(6) ENUM<zetasql_test__.TestEnum>) -> BOOL)
            +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
            +-Cast(STRING -> ENUM<zetasql_test__.TestEnum>)
            | +-Parameter(type=STRING, name="test_param_string")
            +-Cast(INT32 -> ENUM<zetasql_test__.TestEnum>)
            | +-Parameter(type=INT32, name="test_param_int32")
            +-Cast(INT64 -> ENUM<zetasql_test__.TestEnum>)
            | +-Parameter(type=INT64, name="test_param_int64")
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=NULL)
==

select NOT 0
--
ERROR: No matching signature for operator NOT for argument types: INT64. Supported signature: NOT (BOOL) [at 1:8]
select NOT 0
       ^
==

select 'abc' {{<|<=|>|>=|=|!=|LIKE}} b'abc'
--
ALTERNATION GROUP: <
--
ERROR: No matching signature for operator < for argument types: STRING, BYTES. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY < ANY; INT64 < UINT64; UINT64 < INT64 [at 1:8]
select 'abc' < b'abc'
       ^
--
ALTERNATION GROUP: <=
--
ERROR: No matching signature for operator <= for argument types: STRING, BYTES. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY <= ANY; INT64 <= UINT64; UINT64 <= INT64 [at 1:8]
select 'abc' <= b'abc'
       ^
--
ALTERNATION GROUP: >
--
ERROR: No matching signature for operator > for argument types: STRING, BYTES. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY > ANY; INT64 > UINT64; UINT64 > INT64 [at 1:8]
select 'abc' > b'abc'
       ^
--
ALTERNATION GROUP: >=
--
ERROR: No matching signature for operator >= for argument types: STRING, BYTES. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY >= ANY; INT64 >= UINT64; UINT64 >= INT64 [at 1:8]
select 'abc' >= b'abc'
       ^
--
ALTERNATION GROUP: =
--
ERROR: No matching signature for operator = for argument types: STRING, BYTES. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 1:8]
select 'abc' = b'abc'
       ^
--
ALTERNATION GROUP: !=
--
ERROR: No matching signature for operator != for argument types: STRING, BYTES. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY != ANY; INT64 != UINT64; UINT64 != INT64 [at 1:8]
select 'abc' != b'abc'
       ^
--
ALTERNATION GROUP: LIKE
--
ERROR: No matching signature for operator LIKE for argument types: STRING, BYTES. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: STRING LIKE STRING; BYTES LIKE BYTES [at 1:8]
select 'abc' LIKE b'abc'
       ^
==

select b'abc' {{<|<=|>|>=|=|!=|LIKE}} 'abc'
--
ALTERNATION GROUP: <
--
ERROR: No matching signature for operator < for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY < ANY; INT64 < UINT64; UINT64 < INT64 [at 1:8]
select b'abc' < 'abc'
       ^
--
ALTERNATION GROUP: <=
--
ERROR: No matching signature for operator <= for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY <= ANY; INT64 <= UINT64; UINT64 <= INT64 [at 1:8]
select b'abc' <= 'abc'
       ^
--
ALTERNATION GROUP: >
--
ERROR: No matching signature for operator > for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY > ANY; INT64 > UINT64; UINT64 > INT64 [at 1:8]
select b'abc' > 'abc'
       ^
--
ALTERNATION GROUP: >=
--
ERROR: No matching signature for operator >= for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY >= ANY; INT64 >= UINT64; UINT64 >= INT64 [at 1:8]
select b'abc' >= 'abc'
       ^
--
ALTERNATION GROUP: =
--
ERROR: No matching signature for operator = for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 1:8]
select b'abc' = 'abc'
       ^
--
ALTERNATION GROUP: !=
--
ERROR: No matching signature for operator != for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY != ANY; INT64 != UINT64; UINT64 != INT64 [at 1:8]
select b'abc' != 'abc'
       ^
--
ALTERNATION GROUP: LIKE
--
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: STRING LIKE STRING; BYTES LIKE BYTES [at 1:8]
select b'abc' LIKE 'abc'
       ^
==

select bytes {{<|<=|>|>=|=|!=|LIKE}} 'abc' from SimpleTypes
--
ALTERNATION GROUP: <
--
ERROR: No matching signature for operator < for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY < ANY; INT64 < UINT64; UINT64 < INT64 [at 1:8]
select bytes < 'abc' from SimpleTypes
       ^
--
ALTERNATION GROUP: <=
--
ERROR: No matching signature for operator <= for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY <= ANY; INT64 <= UINT64; UINT64 <= INT64 [at 1:8]
select bytes <= 'abc' from SimpleTypes
       ^
--
ALTERNATION GROUP: >
--
ERROR: No matching signature for operator > for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY > ANY; INT64 > UINT64; UINT64 > INT64 [at 1:8]
select bytes > 'abc' from SimpleTypes
       ^
--
ALTERNATION GROUP: >=
--
ERROR: No matching signature for operator >= for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY >= ANY; INT64 >= UINT64; UINT64 >= INT64 [at 1:8]
select bytes >= 'abc' from SimpleTypes
       ^
--
ALTERNATION GROUP: =
--
ERROR: No matching signature for operator = for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 1:8]
select bytes = 'abc' from SimpleTypes
       ^
--
ALTERNATION GROUP: !=
--
ERROR: No matching signature for operator != for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY != ANY; INT64 != UINT64; UINT64 != INT64 [at 1:8]
select bytes != 'abc' from SimpleTypes
       ^
--
ALTERNATION GROUP: LIKE
--
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: STRING LIKE STRING; BYTES LIKE BYTES [at 1:8]
select bytes LIKE 'abc' from SimpleTypes
       ^
==

select bytes from SimpleTypes where bytes {{<|<=|>|>=|=|!=|LIKE}} 'abc'
--
ALTERNATION GROUP: <
--
ERROR: No matching signature for operator < for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY < ANY; INT64 < UINT64; UINT64 < INT64 [at 1:37]
select bytes from SimpleTypes where bytes < 'abc'
                                    ^
--
ALTERNATION GROUP: <=
--
ERROR: No matching signature for operator <= for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY <= ANY; INT64 <= UINT64; UINT64 <= INT64 [at 1:37]
select bytes from SimpleTypes where bytes <= 'abc'
                                    ^
--
ALTERNATION GROUP: >
--
ERROR: No matching signature for operator > for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY > ANY; INT64 > UINT64; UINT64 > INT64 [at 1:37]
select bytes from SimpleTypes where bytes > 'abc'
                                    ^
--
ALTERNATION GROUP: >=
--
ERROR: No matching signature for operator >= for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY >= ANY; INT64 >= UINT64; UINT64 >= INT64 [at 1:37]
select bytes from SimpleTypes where bytes >= 'abc'
                                    ^
--
ALTERNATION GROUP: =
--
ERROR: No matching signature for operator = for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 1:37]
select bytes from SimpleTypes where bytes = 'abc'
                                    ^
--
ALTERNATION GROUP: !=
--
ERROR: No matching signature for operator != for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY != ANY; INT64 != UINT64; UINT64 != INT64 [at 1:37]
select bytes from SimpleTypes where bytes != 'abc'
                                    ^
--
ALTERNATION GROUP: LIKE
--
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: STRING LIKE STRING; BYTES LIKE BYTES [at 1:37]
select bytes from SimpleTypes where bytes LIKE 'abc'
                                    ^
==

select @test_param_bytes {{<|<=|>|>=|=|!=|LIKE}} 'abc'
--
ALTERNATION GROUP: <
--
ERROR: No matching signature for operator < for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY < ANY; INT64 < UINT64; UINT64 < INT64 [at 1:8]
select @test_param_bytes < 'abc'
       ^
--
ALTERNATION GROUP: <=
--
ERROR: No matching signature for operator <= for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY <= ANY; INT64 <= UINT64; UINT64 <= INT64 [at 1:8]
select @test_param_bytes <= 'abc'
       ^
--
ALTERNATION GROUP: >
--
ERROR: No matching signature for operator > for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY > ANY; INT64 > UINT64; UINT64 > INT64 [at 1:8]
select @test_param_bytes > 'abc'
       ^
--
ALTERNATION GROUP: >=
--
ERROR: No matching signature for operator >= for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY >= ANY; INT64 >= UINT64; UINT64 >= INT64 [at 1:8]
select @test_param_bytes >= 'abc'
       ^
--
ALTERNATION GROUP: =
--
ERROR: No matching signature for operator = for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 1:8]
select @test_param_bytes = 'abc'
       ^
--
ALTERNATION GROUP: !=
--
ERROR: No matching signature for operator != for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: ANY != ANY; INT64 != UINT64; UINT64 != INT64 [at 1:8]
select @test_param_bytes != 'abc'
       ^
--
ALTERNATION GROUP: LIKE
--
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: STRING LIKE STRING; BYTES LIKE BYTES [at 1:8]
select @test_param_bytes LIKE 'abc'
       ^
==

select 'abc' IN (b'abc', b'abd')
--
ERROR: No matching signature for operator IN for argument types literal STRING and {BYTES}. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value' [at 1:14]
select 'abc' IN (b'abc', b'abd')
             ^

==

select 'abc' IN ('abc', b'abc')
--
ERROR: No matching signature for operator IN for argument types literal STRING and {STRING, BYTES}. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value' [at 1:14]
select 'abc' IN ('abc', b'abc')
             ^
==

select 'abc' IN (@test_param_bytes, @test_param_bytes)
--
ERROR: No matching signature for operator IN for argument types literal STRING and {BYTES}. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value' [at 1:14]
select 'abc' IN (@test_param_bytes, @test_param_bytes)
             ^
==

select b'abc' IN ('abc', 'abc')
--
ERROR: No matching signature for operator IN for argument types literal BYTES and {STRING}. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value' [at 1:15]
select b'abc' IN ('abc', 'abc')
              ^
==

select b'abc' IN (@test_param_string, @test_param_string)
--
ERROR: No matching signature for operator IN for argument types literal BYTES and {STRING} [at 1:15]
select b'abc' IN (@test_param_string, @test_param_string)
              ^
==

select b'abc' IN ('abc', b'abd')
--
ERROR: No matching signature for operator IN for argument types literal BYTES and {STRING, BYTES}. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value' [at 1:15]
select b'abc' IN ('abc', b'abd')
              ^

==

select 'abc' IN UNNEST([b'abc', b'abd'])
--
ERROR: No matching signature for operator IN UNNEST for argument types: STRING, ARRAY<BYTES>. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value' [at 1:14]
select 'abc' IN UNNEST([b'abc', b'abd'])
             ^
==

select 'abc' IN UNNEST([@test_param_bytes, @test_param_bytes])
--
ERROR: No matching signature for operator IN UNNEST for argument types: STRING, ARRAY<BYTES>. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value' [at 1:14]
select 'abc' IN UNNEST([@test_param_bytes, @test_param_bytes])
             ^
==

select 'abc' IN UNNEST([CAST('abc' AS BYTES), CAST('abd' AS BYTES)])
--
ERROR: No matching signature for operator IN UNNEST for argument types: STRING, ARRAY<BYTES>. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value' [at 1:14]
select 'abc' IN UNNEST([CAST('abc' AS BYTES), CAST('abd' AS BYTES)])
             ^
==

select BytesArray from ArrayTypes where 'abc' IN UNNEST(BytesArray)
--
ERROR: No matching signature for operator IN UNNEST for argument types: STRING, ARRAY<BYTES>. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value' [at 1:47]
select BytesArray from ArrayTypes where 'abc' IN UNNEST(BytesArray)
                                              ^
==

select b'abc' IN UNNEST(['abc', 'abd'])
--
ERROR: No matching signature for operator IN UNNEST for argument types: BYTES, ARRAY<STRING>. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value' [at 1:15]
select b'abc' IN UNNEST(['abc', 'abd'])
              ^
==

select b'abc' IN UNNEST([@test_param_string, @test_param_string])
--
ERROR: No matching signature for operator IN UNNEST for argument types: BYTES, ARRAY<STRING> [at 1:15]
select b'abc' IN UNNEST([@test_param_string, @test_param_string])
              ^
==

select b'abc' IN UNNEST([CAST(b'abc' AS STRING), CAST(b'abd' AS STRING)])
--
ERROR: No matching signature for operator IN UNNEST for argument types: BYTES, ARRAY<STRING> [at 1:15]
select b'abc' IN UNNEST([CAST(b'abc' AS STRING), CAST(b'abd' AS STRING)])
              ^
==

select StringArray from ArrayTypes where b'abc' IN UNNEST(StringArray)
--
ERROR: No matching signature for operator IN UNNEST for argument types: BYTES, ARRAY<STRING> [at 1:49]
select StringArray from ArrayTypes where b'abc' IN UNNEST(StringArray)
                                                ^
==

select b'abc' IN UNNEST(['abc', b'abd'])
--
ERROR: Array elements of types {STRING, BYTES} do not have a common supertype [at 1:25]
select b'abc' IN UNNEST(['abc', b'abd'])
                        ^
==

select 'abc' IN UNNEST(['abc', b'abd'])
--
ERROR: Array elements of types {STRING, BYTES} do not have a common supertype [at 1:24]
select 'abc' IN UNNEST(['abc', b'abd'])
                       ^
==

# Test case from b/79755993 (now fixed).
select {{|SAFE_}}CAST(CAST(- 1769384439 AS INT32) AS UINT32)
       & CAST(1834360097 AS UINT32);
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [UINT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$bitwise_and(UINT32, UINT32) -> UINT32)
    |     +-Cast(INT32 -> UINT32)
    |     | +-Literal(type=INT32, value=-1769384439, has_explicit_type=TRUE)
    |     +-Literal(type=UINT32, value=1834360097, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: SAFE_
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [UINT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$bitwise_and(UINT32, UINT32) -> UINT32)
    |     +-Literal(type=UINT32, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=UINT32, value=1834360097, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# IS DISTINCT FROM - unsupported in language options
SELECT 1 IS {{NOT|}} DISTINCT FROM 2;
--
ALTERNATION GROUP: NOT
--
ERROR: IS DISTINCT FROM is not supported [at 1:17]
SELECT 1 IS NOT DISTINCT FROM 2;
                ^
--
ALTERNATION GROUP: <empty>
--
ERROR: IS DISTINCT FROM is not supported [at 1:10]
SELECT 1 IS  DISTINCT FROM 2;
         ^
==

# IS DISTINCT FROM - simple example
[language_features=V_1_3_IS_DISTINCT]
[show_unparsed]
SELECT 1 IS {{NOT|}} DISTINCT FROM 2;
--
ALTERNATION GROUP: NOT
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$is_not_distinct_from(INT64, INT64) -> BOOL)
    |     +-Literal(type=INT64, value=1)
    |     +-Literal(type=INT64, value=2)
    +-input_scan=
      +-SingleRowScan

[UNPARSED_SQL]
SELECT
  1 IS NOT DISTINCT FROM 2 AS a_1;
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$is_distinct_from(INT64, INT64) -> BOOL)
    |     +-Literal(type=INT64, value=1)
    |     +-Literal(type=INT64, value=2)
    +-input_scan=
      +-SingleRowScan

[UNPARSED_SQL]
SELECT
  1 IS DISTINCT FROM 2 AS a_1;
==

# IS DISTINCT FROM - mismatched types
[language_features=V_1_3_IS_DISTINCT]
SELECT 'test' IS {{NOT|}} DISTINCT FROM 2;
--
ALTERNATION GROUP: NOT
--
ERROR: No matching signature for operator IS NOT DISTINCT FROM for argument types: STRING, INT64. Supported signatures: ANY IS NOT DISTINCT FROM ANY; INT64 IS NOT DISTINCT FROM UINT64; UINT64 IS NOT DISTINCT FROM INT64 [at 1:8]
SELECT 'test' IS NOT DISTINCT FROM 2;
       ^
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for operator IS DISTINCT FROM for argument types: STRING, INT64. Supported signatures: ANY IS DISTINCT FROM ANY; INT64 IS DISTINCT FROM UINT64; UINT64 IS DISTINCT FROM INT64 [at 1:8]
SELECT 'test' IS  DISTINCT FROM 2;
       ^
==

# IS DISTINCT FROM - NULL coercion of rhs
[language_features=V_1_3_IS_DISTINCT]
SELECT 'test' IS DISTINCT FROM NULL;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$is_distinct_from(STRING, STRING) -> BOOL)
    |     +-Literal(type=STRING, value="test")
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

# IS DISTINCT FROM - NULL coercion of lhs
[language_features=V_1_3_IS_DISTINCT]
SELECT NULL IS DISTINCT FROM 'test';
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$is_distinct_from(STRING, STRING) -> BOOL)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=STRING, value="test")
    +-input_scan=
      +-SingleRowScan
==

# IS DISTINCT FROM - TIMESTAMP coercion
[language_features=V_1_3_IS_DISTINCT]
SELECT CURRENT_TIMESTAMP() IS DISTINCT FROM '2020-01-03';
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$is_distinct_from(TIMESTAMP, TIMESTAMP) -> BOOL)
    |     +-FunctionCall(ZetaSQL:current_timestamp() -> TIMESTAMP)
    |     +-Literal(type=TIMESTAMP, value=2020-01-03 08:00:00+00)
    +-input_scan=
      +-SingleRowScan
==

# IS DISTINCT FROM - INT64/FLOAT64 coercion
[language_features=V_1_3_IS_DISTINCT]
SELECT 2.3 + 1 IS DISTINCT FROM 12345;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$is_distinct_from(DOUBLE, DOUBLE) -> BOOL)
    |     +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
    |     | +-Literal(type=DOUBLE, value=2.3)
    |     | +-Literal(type=DOUBLE, value=1)
    |     +-Literal(type=DOUBLE, value=12345)
    +-input_scan=
      +-SingleRowScan
==

# IS DISTINCT FROM - INT64/UINT64 signature
[language_features=V_1_3_IS_DISTINCT]
SELECT 12345 * 2 IS DISTINCT FROM CAST(10000 AS UINT64);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$is_distinct_from(INT64, UINT64) -> BOOL)
    |     +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |     | +-Literal(type=INT64, value=12345)
    |     | +-Literal(type=INT64, value=2)
    |     +-Literal(type=UINT64, value=10000, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# IS DISTINCT FROM - UINT64/INT64 signature
[language_features=V_1_3_IS_DISTINCT]
SELECT CAST(10000 AS UINT64) IS DISTINCT FROM 12345 * 2;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$is_distinct_from(UINT64, INT64) -> BOOL)
    |     +-Literal(type=UINT64, value=10000, has_explicit_type=TRUE)
    |     +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |       +-Literal(type=INT64, value=12345)
    |       +-Literal(type=INT64, value=2)
    +-input_scan=
      +-SingleRowScan
==

# IS DISTINCT FROM - enum->int64 coercion.
[language_features=V_1_3_IS_DISTINCT]
SELECT
  CAST('TESTENUM0' AS `zetasql_test__.TestEnum`)
  IS DISTINCT FROM
  0;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$is_distinct_from(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
    |     +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0, has_explicit_type=TRUE)
    |     +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
    +-input_scan=
      +-SingleRowScan
==

# IS DISTINCT FROM - type which doesn't support equality
[language_features=V_1_3_IS_DISTINCT,GEOGRAPHY]
SELECT geo1 IS DISTINCT FROM geo2 FROM GeographyTable;
--
ERROR: Grouping is not defined for arguments of type GEOGRAPHY [at 1:8]
SELECT geo1 IS DISTINCT FROM geo2 FROM GeographyTable;
       ^
==

# IS DISTINCT FROM - type supports equality, but is not groupable.
[language_features=V_1_3_IS_DISTINCT,V_1_1_ARRAY_EQUALITY]
SELECT [1, 2, 3] IS DISTINCT FROM [4, 5, 6];
--
ERROR: Grouping is not defined for arguments of type ARRAY<INT64> [at 1:8]
SELECT [1, 2, 3] IS DISTINCT FROM [4, 5, 6];
       ^
==

# IS DISTINCT FROM - FLOAT64 NaN/Inf values
[language_features=V_1_3_IS_DISTINCT]
SELECT IEEE_DIVIDE(1,0) IS DISTINCT FROM IEEE_DIVIDE(0,0);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$is_distinct_from(DOUBLE, DOUBLE) -> BOOL)
    |     +-FunctionCall(ZetaSQL:ieee_divide(DOUBLE, DOUBLE) -> DOUBLE)
    |     | +-Literal(type=DOUBLE, value=1)
    |     | +-Literal(type=DOUBLE, value=0)
    |     +-FunctionCall(ZetaSQL:ieee_divide(DOUBLE, DOUBLE) -> DOUBLE)
    |       +-Literal(type=DOUBLE, value=0)
    |       +-Literal(type=DOUBLE, value=0)
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_3_IS_DISTINCT]
[show_unparsed]
SELECT (1 IS DISTINCT FROM 2) IS TRUE;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$is_true(BOOL) -> BOOL)
    |     +-FunctionCall(ZetaSQL:$is_distinct_from(INT64, INT64) -> BOOL)
    |       +-Literal(type=INT64, value=1)
    |       +-Literal(type=INT64, value=2)
    +-input_scan=
      +-SingleRowScan

[UNPARSED_SQL]
SELECT
  (1 IS DISTINCT FROM 2) IS TRUE AS a_1;
