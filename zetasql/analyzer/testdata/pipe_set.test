[default language_features=PIPES,PIPE_STATIC_DESCRIBE,ANALYTIC_FUNCTIONS]
from KeyValue
|> STATIC_DESCRIBE
|> SET kEY = 'abc'
|> STATIC_DESCRIBE
|> WHERE value is null
|> WHERE KeyValue.value is null
|> WHERE KeyValue.key is null
--
QueryStmt
+-output_column_list=
| +-$pipe_set.kEY#3 AS Key [STRING]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-FilterScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_set.kEY#3]
    +-input_scan=
    | +-FilterScan
    |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_set.kEY#3]
    |   +-input_scan=
    |   | +-FilterScan
    |   |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_set.kEY#3]
    |   |   +-input_scan=
    |   |   | +-StaticDescribeScan
    |   |   |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_set.kEY#3]
    |   |   |   +-describe_text=
    |   |   |   |   """
    |   |   |   |   NameList:
    |   |   |   |     Key STRING $pipe_set.kEY#3
    |   |   |   |     Value STRING KeyValue.Value#2
    |   |   |   |   NameScope:
    |   |   |   |     Names:
    |   |   |   |       Key -> STRING ($pipe_set.kEY#3)
    |   |   |   |       Value -> STRING (KeyValue.Value#2) (implicit)
    |   |   |   |     Range variables:
    |   |   |   |       KeyValue -> RANGE_VARIABLE<Key,Value>
    |   |   |   |   """
    |   |   |   +-input_scan=
    |   |   |     +-ProjectScan
    |   |   |       +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_set.kEY#3]
    |   |   |       +-expr_list=
    |   |   |       | +-kEY#3 := Literal(type=STRING, value="abc")
    |   |   |       +-input_scan=
    |   |   |         +-StaticDescribeScan
    |   |   |           +-column_list=KeyValue.[Key#1, Value#2]
    |   |   |           +-describe_text=
    |   |   |           |   """
    |   |   |           |   NameList:
    |   |   |           |     Key INT64 KeyValue.Key#1
    |   |   |           |     Value STRING KeyValue.Value#2
    |   |   |           |   NameScope:
    |   |   |           |     Names:
    |   |   |           |       Key -> INT64 (KeyValue.Key#1) (implicit)
    |   |   |           |       Value -> STRING (KeyValue.Value#2) (implicit)
    |   |   |           |     Range variables:
    |   |   |           |       KeyValue -> RANGE_VARIABLE<Key,Value>
    |   |   |           |   """
    |   |   |           +-input_scan=
    |   |   |             +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-filter_expr=
    |   |     +-FunctionCall(ZetaSQL:$is_null(STRING) -> BOOL)
    |   |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |   +-filter_expr=
    |     +-FunctionCall(ZetaSQL:$is_null(STRING) -> BOOL)
    |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=KeyValue.Key#1)
==

from KeyValue
|> set Key = 5, kEy = 6
--
ERROR: Duplicate column name in pipe SET: kEy [at 2:17]
|> set Key = 5, kEy = 6
                ^
==

# Column order is preserved by SET.
select 1 c, 2 b, 3 d
|> SET b = 'x'
|> STATIC_DESCRIBE
|> select *
--
QueryStmt
+-output_column_list=
| +-$query.c#1 AS c [INT64]
| +-$pipe_set.b#4 AS b [STRING]
| +-$query.d#3 AS d [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.c#1, $pipe_set.b#4, $query.d#3]
    +-input_scan=
      +-StaticDescribeScan
        +-column_list=[$query.c#1, $query.b#2, $query.d#3, $pipe_set.b#4]
        +-describe_text=
        |   """
        |   NameList:
        |     c INT64 $query.c#1
        |     b STRING $pipe_set.b#4
        |     d INT64 $query.d#3
        |   NameScope:
        |     Names:
        |       b -> STRING ($pipe_set.b#4)
        |       c -> INT64 ($query.c#1)
        |       d -> INT64 ($query.d#3)
        |   """
        +-input_scan=
          +-ProjectScan
            +-column_list=[$query.c#1, $query.b#2, $query.d#3, $pipe_set.b#4]
            +-expr_list=
            | +-b#4 := Literal(type=STRING, value="x")
            +-input_scan=
              +-ProjectScan
                +-column_list=$query.[c#1, b#2, d#3]
                +-expr_list=
                | +-c#1 := Literal(type=INT64, value=1)
                | +-b#2 := Literal(type=INT64, value=2)
                | +-d#3 := Literal(type=INT64, value=3)
                +-input_scan=
                  +-SingleRowScan
==

from KeyValue
|> set key = 1, something = 2, value = 3
--
ERROR: Column name in pipe SET not found in input table: something [at 2:17]
|> set key = 1, something = 2, value = 3
                ^
==

from KeyValue
|> set `$abc` = 5
--
ERROR: Cannot use pipe SET with internal alias `$abc` [at 2:8]
|> set `$abc` = 5
       ^
==

FROM KeyValue kv1 CROSS JOIN KeyValue kv2
|> set key = 5
--
ERROR: Column name in pipe SET exists more than once in input table: Key [at 2:8]
|> set key = 5
       ^
==

FROM KeyValue kv
|> set key = 1.5
|> SELECT key, kv.key, *, kv.*
--
QueryStmt
+-output_column_list=
| +-$pipe_set.key#3 AS key [DOUBLE]
| +-KeyValue.Key#1 AS key [INT64]
| +-$pipe_set.key#3 AS Key [DOUBLE]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$pipe_set.key#3, KeyValue.Key#1, $pipe_set.key#3, KeyValue.Value#2, KeyValue.Key#1, KeyValue.Value#2]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_set.key#3]
        +-expr_list=
        | +-key#3 := Literal(type=DOUBLE, value=1.5)
        +-input_scan=
          +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
==

FROM KeyValue
|> SET key = key+1, value = value
--
QueryStmt
+-output_column_list=
| +-$pipe_set.key#3 AS Key [INT64]
| +-$pipe_set.value#4 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_set.key#3, $pipe_set.value#4]
    +-expr_list=
    | +-key#3 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    | |   +-Literal(type=INT64, value=1)
    | +-value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
==

FROM KeyValue kv
|> SET kv = 5
--
ERROR: Name in pipe SET is a table alias; SET can only update columns: kv [at 2:8]
|> SET kv = 5
       ^
==

# This is allowed because there's a column `key`.
# The range variable `key` is also dropped in favor of the new column.
FROM KeyValue key
|> SET key = 1.5
|> SELECT {{key|key.key|value}}
--
ALTERNATION GROUP: key
--
QueryStmt
+-output_column_list=
| +-$pipe_set.key#3 AS key [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$pipe_set.key#3]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$pipe_set.key#3]
        +-expr_list=
        | +-key#3 := Literal(type=DOUBLE, value=1.5)
        +-input_scan=
          +-TableScan(table=KeyValue, alias="key")
--
ALTERNATION GROUP: key.key
--
ERROR: Cannot access field key on a value with type DOUBLE [at 3:15]
|> SELECT key.key
              ^
--
ALTERNATION GROUP: value
--
QueryStmt
+-output_column_list=
| +-KeyValue.Value#2 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Value#2]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Value#2, $pipe_set.key#3]
        +-expr_list=
        | +-key#3 := Literal(type=DOUBLE, value=1.5)
        +-input_scan=
          +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1], alias="key")
==

# Replacing a pseudo-column doesn't work.
FROM EnumTable
|> WHERE Filename is not null
|> SET Filename = 5
--
ERROR: Name in pipe SET is present but is not a column on the pipe input table; SET can only update columns: Filename [at 3:8]
|> SET Filename = 5
       ^
==

# SET works because there is a real column Filename.
# The pseudo-column Filename is also dropped in favor of the column.
FROM EnumTable
|> WHERE Filename is null
|> EXTEND 'abc' AS Filename
|> STATIC_DESCRIBE
|> SET Filename = 1.5
|> STATIC_DESCRIBE
|> WHERE Filename is null
--
QueryStmt
+-output_column_list=
| +-EnumTable.key#1 AS key [INT32]
| +-EnumTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-EnumTable.AnotherTestEnum#3 AS AnotherTestEnum [ENUM<zetasql_test__.AnotherTestEnum>]
| +-$pipe_set.Filename#7 AS Filename [DOUBLE]
+-query=
  +-FilterScan
    +-column_list=[EnumTable.key#1, EnumTable.TestEnum#2, EnumTable.AnotherTestEnum#3, EnumTable.Filename#4, $pipe_extend.Filename#6, $pipe_set.Filename#7]
    +-input_scan=
    | +-StaticDescribeScan
    |   +-column_list=[EnumTable.key#1, EnumTable.TestEnum#2, EnumTable.AnotherTestEnum#3, EnumTable.Filename#4, $pipe_extend.Filename#6, $pipe_set.Filename#7]
    |   +-describe_text=
    |   |   """
    |   |   NameList:
    |   |     key INT32 EnumTable.key#1
    |   |     TestEnum zetasql_test__.TestEnum EnumTable.TestEnum#2
    |   |     AnotherTestEnum zetasql_test__.AnotherTestEnum EnumTable.AnotherTestEnum#3
    |   |     Filename DOUBLE $pipe_set.Filename#7
    |   |   NameScope:
    |   |     Names:
    |   |       AnotherTestEnum -> zetasql_test__.AnotherTestEnum (EnumTable.AnotherTestEnum#3) (implicit)
    |   |       Filename -> DOUBLE ($pipe_set.Filename#7)
    |   |       RowId -> BYTES (EnumTable.RowId#5) (implicit) (pseudo-column)
    |   |       TestEnum -> zetasql_test__.TestEnum (EnumTable.TestEnum#2) (implicit)
    |   |       key -> INT32 (EnumTable.key#1) (implicit)
    |   |     Range variables:
    |   |       EnumTable -> RANGE_VARIABLE<key,TestEnum,AnotherTestEnum>
    |   |   """
    |   +-input_scan=
    |     +-ProjectScan
    |       +-column_list=[EnumTable.key#1, EnumTable.TestEnum#2, EnumTable.AnotherTestEnum#3, EnumTable.Filename#4, $pipe_extend.Filename#6, $pipe_set.Filename#7]
    |       +-expr_list=
    |       | +-Filename#7 := Literal(type=DOUBLE, value=1.5)
    |       +-input_scan=
    |         +-StaticDescribeScan
    |           +-column_list=[EnumTable.key#1, EnumTable.TestEnum#2, EnumTable.AnotherTestEnum#3, EnumTable.Filename#4, $pipe_extend.Filename#6]
    |           +-describe_text=
    |           |   """
    |           |   NameList:
    |           |     key INT32 EnumTable.key#1
    |           |     TestEnum zetasql_test__.TestEnum EnumTable.TestEnum#2
    |           |     AnotherTestEnum zetasql_test__.AnotherTestEnum EnumTable.AnotherTestEnum#3
    |           |     Filename STRING $pipe_extend.Filename#6
    |           |   NameScope:
    |           |     Names:
    |           |       AnotherTestEnum -> zetasql_test__.AnotherTestEnum (EnumTable.AnotherTestEnum#3) (implicit)
    |           |       Filename -> ambiguous
    |           |       RowId -> BYTES (EnumTable.RowId#5) (implicit) (pseudo-column)
    |           |       TestEnum -> zetasql_test__.TestEnum (EnumTable.TestEnum#2) (implicit)
    |           |       key -> INT32 (EnumTable.key#1) (implicit)
    |           |     Range variables:
    |           |       EnumTable -> RANGE_VARIABLE<key,TestEnum,AnotherTestEnum>
    |           |   """
    |           +-input_scan=
    |             +-ProjectScan
    |               +-column_list=[EnumTable.key#1, EnumTable.TestEnum#2, EnumTable.AnotherTestEnum#3, EnumTable.Filename#4, $pipe_extend.Filename#6]
    |               +-expr_list=
    |               | +-Filename#6 := Literal(type=STRING, value="abc")
    |               +-input_scan=
    |                 +-FilterScan
    |                   +-column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3, Filename#4]
    |                   +-input_scan=
    |                   | +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3, Filename#4], table=EnumTable, column_index_list=[0, 1, 2, 3])
    |                   +-filter_expr=
    |                     +-FunctionCall(ZetaSQL:$is_null(STRING) -> BOOL)
    |                       +-ColumnRef(type=STRING, column=EnumTable.Filename#4)
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$is_null(DOUBLE) -> BOOL)
        +-ColumnRef(type=DOUBLE, column=$pipe_set.Filename#7)
==

FROM KeyValue, UNNEST([1]) elem WITH OFFSET
|> STATIC_DESCRIBE
|> SET elem = 'x', offset = 'y'
|> STATIC_DESCRIBE
|> WHERE elem is null
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-$pipe_set.elem#5 AS elem [STRING]
| +-$pipe_set.offset#6 AS offset [STRING]
+-query=
  +-FilterScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_set.elem#5, $pipe_set.offset#6]
    +-input_scan=
    | +-StaticDescribeScan
    |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_set.elem#5, $pipe_set.offset#6]
    |   +-describe_text=
    |   |   """
    |   |   NameList:
    |   |     Key INT64 KeyValue.Key#1
    |   |     Value STRING KeyValue.Value#2
    |   |     elem STRING $pipe_set.elem#5
    |   |     offset STRING $pipe_set.offset#6
    |   |   NameScope:
    |   |     Names:
    |   |       Key -> INT64 (KeyValue.Key#1) (implicit)
    |   |       Value -> STRING (KeyValue.Value#2) (implicit)
    |   |       elem -> STRING ($pipe_set.elem#5)
    |   |       offset -> STRING ($pipe_set.offset#6)
    |   |     Range variables:
    |   |       KeyValue -> RANGE_VARIABLE<Key,Value>
    |   |   """
    |   +-input_scan=
    |     +-ProjectScan
    |       +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_set.elem#5, $pipe_set.offset#6]
    |       +-expr_list=
    |       | +-elem#5 := Literal(type=STRING, value="x")
    |       | +-offset#6 := Literal(type=STRING, value="y")
    |       +-input_scan=
    |         +-StaticDescribeScan
    |           +-column_list=KeyValue.[Key#1, Value#2]
    |           +-describe_text=
    |           |   """
    |           |   NameList:
    |           |     Key INT64 KeyValue.Key#1
    |           |     Value STRING KeyValue.Value#2
    |           |     elem INT64 $array.elem#3 (value table)
    |           |     offset INT64 $array_offset.offset#4 (value table)
    |           |   NameScope:
    |           |     Names:
    |           |       Key -> INT64 (KeyValue.Key#1) (implicit)
    |           |       Value -> STRING (KeyValue.Value#2) (implicit)
    |           |     Range variables:
    |           |       KeyValue -> RANGE_VARIABLE<Key,Value>
    |           |       elem -> RANGE_VARIABLE<$value>
    |           |       offset -> RANGE_VARIABLE<$value>
    |           |     Value table columns:
    |           |       $array.elem#3
    |           |       $array_offset.offset#4
    |           |   """
    |           +-input_scan=
    |             +-ArrayScan
    |               +-column_list=KeyValue.[Key#1, Value#2]
    |               +-input_scan=
    |               | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |               +-array_expr_list=
    |               | +-Literal(type=ARRAY<INT64>, value=[1])
    |               +-element_column_list=[$array.elem#3]
    |               +-array_offset_column=
    |                 +-ColumnHolder(column=$array_offset.offset#4)
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$is_null(STRING) -> BOOL)
        +-ColumnRef(type=STRING, column=$pipe_set.elem#5)
==

# We can't SET field names or pseudo-columns from a value table.
FROM TestExtraValueTable vt
|> SET {{int32_val1|Filename}} = 5
--
ALTERNATION GROUP: int32_val1
--
ERROR: Name in pipe SET is a field inside a value table; SET can only update columns: int32_val1 [at 2:8]
|> SET int32_val1 = 5
       ^
--
ALTERNATION GROUP: Filename
--
ERROR: Name in pipe SET is present but is not a column on the pipe input table; SET can only update columns: Filename [at 2:8]
|> SET Filename = 5
       ^
==

# We can update a value table column (which is also a range variable).
FROM TestExtraValueTable vt1, TestExtraValueTable vt2
|> STATIC_DESCRIBE
|> SET vt1 = 0
|> STATIC_DESCRIBE
|> WHERE int32_val1 = 1
--
QueryStmt
+-output_column_list=
| +-$pipe_set.vt1#7 AS vt1 [INT64]
| +-TestExtraValueTable.value#4 AS vt2 [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-FilterScan
    +-column_list=[TestExtraValueTable.value#4, $pipe_set.vt1#7]
    +-input_scan=
    | +-StaticDescribeScan
    |   +-column_list=[TestExtraValueTable.value#4, $pipe_set.vt1#7]
    |   +-describe_text=
    |   |   """
    |   |   NameList:
    |   |     vt1 INT64 $pipe_set.vt1#7
    |   |     vt2 zetasql_test__.TestExtraPB TestExtraValueTable.value#4 (value table) (excluded_field_names vt1)
    |   |   NameScope:
    |   |     Names:
    |   |       Filename -> ambiguous
    |   |       RowId -> ambiguous
    |   |       vt1 -> INT64 ($pipe_set.vt1#7)
    |   |     Range variables:
    |   |       vt2 -> RANGE_VARIABLE<$value>
    |   |     Value table columns:
    |   |       TestExtraValueTable.value#4 (excluded_field_names vt1)
    |   |   """
    |   +-input_scan=
    |     +-ProjectScan
    |       +-column_list=[TestExtraValueTable.value#4, $pipe_set.vt1#7]
    |       +-expr_list=
    |       | +-vt1#7 := Literal(type=INT64, value=0)
    |       +-input_scan=
    |         +-StaticDescribeScan
    |           +-column_list=[TestExtraValueTable.value#4]
    |           +-describe_text=
    |           |   """
    |           |   NameList:
    |           |     vt1 zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
    |           |     vt2 zetasql_test__.TestExtraPB TestExtraValueTable.value#4 (value table)
    |           |   NameScope:
    |           |     Names:
    |           |       Filename -> ambiguous
    |           |       RowId -> ambiguous
    |           |     Range variables:
    |           |       vt1 -> RANGE_VARIABLE<$value>
    |           |       vt2 -> RANGE_VARIABLE<$value>
    |           |     Value table columns:
    |           |       TestExtraValueTable.value#1
    |           |       TestExtraValueTable.value#4
    |           |   """
    |           +-input_scan=
    |             +-JoinScan
    |               +-column_list=[TestExtraValueTable.value#4]
    |               +-left_scan=
    |               | +-TableScan(table=TestExtraValueTable, alias="vt1")
    |               +-right_scan=
    |                 +-TableScan(column_list=[TestExtraValueTable.value#4], table=TestExtraValueTable, column_index_list=[0], alias="vt2")
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
        +-GetProtoField
        | +-type=INT32
        | +-expr=
        | | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#4)
        | +-field_descriptor=int32_val1
        | +-default_value=0
        +-Literal(type=INT32, value=1)
==

# Tricky case where we update a column that is also a field of a value
# table.  This adds an exclusion on the value table so the column
# works as expected after SET.  Before the SET, reading
# int32_val1 is ambiguous, since it is both a column and a field.
# SELECT * finds the column int32_val1, not the field.
FROM TestExtraValueTable vt1
|> EXTEND vt1.int32_val1
|> WHERE {{int32_val1=1|true}}
|> STATIC_DESCRIBE
|> SET int32_val1 = 1.9
|> STATIC_DESCRIBE
|> WHERE int32_val1 = 1
|> SELECT *
--
ALTERNATION GROUP: int32_val1=1
--
ERROR: Column name int32_val1 is ambiguous [at 3:10]
|> WHERE int32_val1=1
         ^
--
ALTERNATION GROUP: true
--
QueryStmt
+-output_column_list=
| +-$pipe_select.int32_val2#6 AS int32_val2 [INT32]
| +-$pipe_select.str_value#7 AS str_value [ARRAY<STRING>]
| +-$pipe_set.int32_val1#5 AS int32_val1 [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$pipe_select.int32_val2#6, $pipe_select.str_value#7, $pipe_set.int32_val1#5]
    +-expr_list=
    | +-int32_val2#6 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#7 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-FilterScan
        +-column_list=[TestExtraValueTable.value#1, $pipe_extend.int32_val1#4, $pipe_set.int32_val1#5]
        +-input_scan=
        | +-StaticDescribeScan
        |   +-column_list=[TestExtraValueTable.value#1, $pipe_extend.int32_val1#4, $pipe_set.int32_val1#5]
        |   +-describe_text=
        |   |   """
        |   |   NameList:
        |   |     vt1 zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table) (excluded_field_names int32_val1)
        |   |     int32_val1 DOUBLE $pipe_set.int32_val1#5
        |   |   NameScope:
        |   |     Names:
        |   |       Filename -> STRING (TestExtraValueTable.Filename#2) (implicit) (pseudo-column)
        |   |       RowId -> BYTES (TestExtraValueTable.RowId#3) (implicit) (pseudo-column)
        |   |       int32_val1 -> DOUBLE ($pipe_set.int32_val1#5)
        |   |     Range variables:
        |   |       vt1 -> RANGE_VARIABLE<$value>
        |   |     Value table columns:
        |   |       TestExtraValueTable.value#1 (excluded_field_names int32_val1)
        |   |   """
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[TestExtraValueTable.value#1, $pipe_extend.int32_val1#4, $pipe_set.int32_val1#5]
        |       +-expr_list=
        |       | +-int32_val1#5 := Literal(type=DOUBLE, value=1.9)
        |       +-input_scan=
        |         +-StaticDescribeScan
        |           +-column_list=[TestExtraValueTable.value#1, $pipe_extend.int32_val1#4]
        |           +-describe_text=
        |           |   """
        |           |   NameList:
        |           |     vt1 zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
        |           |     int32_val1 INT32 $pipe_extend.int32_val1#4
        |           |   NameScope:
        |           |     Names:
        |           |       Filename -> STRING (TestExtraValueTable.Filename#2) (implicit) (pseudo-column)
        |           |       RowId -> BYTES (TestExtraValueTable.RowId#3) (implicit) (pseudo-column)
        |           |       int32_val1 -> INT32 ($pipe_extend.int32_val1#4)
        |           |     Range variables:
        |           |       vt1 -> RANGE_VARIABLE<$value>
        |           |     Value table columns:
        |           |       TestExtraValueTable.value#1
        |           |   """
        |           +-input_scan=
        |             +-FilterScan
        |               +-column_list=[TestExtraValueTable.value#1, $pipe_extend.int32_val1#4]
        |               +-input_scan=
        |               | +-ProjectScan
        |               |   +-column_list=[TestExtraValueTable.value#1, $pipe_extend.int32_val1#4]
        |               |   +-expr_list=
        |               |   | +-int32_val1#4 :=
        |               |   |   +-GetProtoField
        |               |   |     +-type=INT32
        |               |   |     +-expr=
        |               |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
        |               |   |     +-field_descriptor=int32_val1
        |               |   |     +-default_value=0
        |               |   +-input_scan=
        |               |     +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias="vt1")
        |               +-filter_expr=
        |                 +-Literal(type=BOOL, value=true)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(DOUBLE, DOUBLE) -> BOOL)
            +-ColumnRef(type=DOUBLE, column=$pipe_set.int32_val1#5)
            +-Literal(type=DOUBLE, value=1)
==

# DEFAULT reserved keyword works in DML UPDATE...SET but not here.
from KeyValue
|> set key = DEFAULT
--
ERROR: Syntax error: Unexpected keyword DEFAULT [at 2:14]
|> set key = DEFAULT
             ^
==

from KeyValue
|> set key[0] = 5
--
ERROR: Syntax error: Expected "." or "=" but got "[" [at 2:11]
|> set key[0] = 5
          ^
==

from KeyValue
|> set key += 5
--
ERROR: Syntax error: Expected "." or "=" but got "+=" [at 2:12]
|> set key += 5
           ^
==

from KeyValue
|> set key = sum(key)
--
ERROR: Aggregate function SUM not allowed in pipe SET clause [at 2:14]
|> set key = sum(key)
             ^
==

from KeyValue
|> set key = avg(sum(key)) OVER ()
--
ERROR: Aggregate function SUM not allowed in pipe SET clause [at 2:18]
|> set key = avg(sum(key)) OVER ()
                 ^
==

[language_features=PIPES]
from KeyValue
|> set key = sum(key) OVER ()
--
ERROR: Analytic functions not supported [at 2:14]
|> set key = sum(key) OVER ()
             ^
==

# Replace a column by an window function of itself.
from KeyValue
|> set key = sum(key) OVER ()
--
QueryStmt
+-output_column_list=
| +-$pipe_set.key#4 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.key#3, $pipe_set.key#4]
    +-expr_list=
    | +-key#4 := ColumnRef(type=INT64, column=$analytic.key#3)
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.key#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-key#3 :=
                +-AnalyticFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

# Replace a column by an window function of a different column.
from KeyValue
|> set value = sum(key) OVER (partition by key)
|> select *, value, KeyValue.value
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-$pipe_set.value#4 AS Value [INT64]
| +-$pipe_set.value#4 AS value [INT64]
| +-KeyValue.Value#2 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1, $pipe_set.value#4, $pipe_set.value#4, KeyValue.Value#2]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.value#3, $pipe_set.value#4]
        +-expr_list=
        | +-value#4 := ColumnRef(type=INT64, column=$analytic.value#3)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.value#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-analytic_function_list=
                  +-value#3 :=
                    +-AnalyticFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                      +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                      +-window_frame=
                        +-WindowFrame(frame_unit=ROWS)
                          +-start_expr=
                          | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                          +-end_expr=
                            +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

# Window functions with expressions before and after the window function.
select 1 x, 2 y, 3 z, 4 value
|> set value = x+sum(y+1) OVER (partition by x+2 order by y+3),
       z = sum(z) OVER (),
       y = y + 1,
       x = sum(y) OVER () + sum(z) OVER ()
--
QueryStmt
+-output_column_list=
| +-$pipe_set.x#12 AS x [INT64]
| +-$pipe_set.y#9 AS y [INT64]
| +-$pipe_set.z#8 AS z [INT64]
| +-$pipe_set.value#6 AS value [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1, $query.y#2, $query.z#3, $query.value#4, $analytic.$analytic1#5, $analytic.z#7, $analytic.$analytic3#10, $analytic.$analytic4#11, $pipe_set.value#6, $pipe_set.z#8, $pipe_set.y#9, $pipe_set.x#12]
    +-expr_list=
    | +-value#6 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-ColumnRef(type=INT64, column=$query.x#1)
    | |   +-ColumnRef(type=INT64, column=$analytic.$analytic1#5)
    | +-z#8 := ColumnRef(type=INT64, column=$analytic.z#7)
    | +-y#9 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-ColumnRef(type=INT64, column=$query.y#2)
    | |   +-Literal(type=INT64, value=1)
    | +-x#12 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-ColumnRef(type=INT64, column=$analytic.$analytic3#10)
    |     +-ColumnRef(type=INT64, column=$analytic.$analytic4#11)
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$query.x#1, $query.y#2, $query.z#3, $query.value#4, $analytic.$analytic1#5, $analytic.z#7, $analytic.$analytic3#10, $analytic.$analytic4#11]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$query.x#1, $query.y#2, $query.z#3, $query.value#4, $partitionby.$partitionbycol1#13, $orderby.$orderbycol1#14]
        |   +-expr_list=
        |   | +-$partitionbycol1#13 :=
        |   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   | |   +-ColumnRef(type=INT64, column=$query.x#1)
        |   | |   +-Literal(type=INT64, value=2)
        |   | +-$orderbycol1#14 :=
        |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |     +-ColumnRef(type=INT64, column=$query.y#2)
        |   |     +-Literal(type=INT64, value=3)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=$query.[x#1, y#2, z#3, value#4]
        |       +-expr_list=
        |       | +-x#1 := Literal(type=INT64, value=1)
        |       | +-y#2 := Literal(type=INT64, value=2)
        |       | +-z#3 := Literal(type=INT64, value=3)
        |       | +-value#4 := Literal(type=INT64, value=4)
        |       +-input_scan=
        |         +-SingleRowScan
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-partition_by=
          | | +-WindowPartitioning
          | |   +-partition_by_list=
          | |     +-ColumnRef(type=INT64, column=$partitionby.$partitionbycol1#13)
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#14)
          | +-analytic_function_list=
          |   +-$analytic1#5 :=
          |     +-AnalyticFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |       +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
          |         +-ColumnRef(type=INT64, column=$query.y#2)
          |         +-Literal(type=INT64, value=1)
          |       +-window_frame=
          |         +-WindowFrame(frame_unit=RANGE)
          |           +-start_expr=
          |           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
          |           +-end_expr=
          |             +-WindowFrameExpr(boundary_type=CURRENT ROW)
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-z#7 :=
              | +-AnalyticFunctionCall(ZetaSQL:sum(INT64) -> INT64)
              |   +-ColumnRef(type=INT64, column=$query.z#3)
              |   +-window_frame=
              |     +-WindowFrame(frame_unit=ROWS)
              |       +-start_expr=
              |       | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
              |       +-end_expr=
              |         +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
              +-$analytic3#10 :=
              | +-AnalyticFunctionCall(ZetaSQL:sum(INT64) -> INT64)
              |   +-ColumnRef(type=INT64, column=$query.y#2)
              |   +-window_frame=
              |     +-WindowFrame(frame_unit=ROWS)
              |       +-start_expr=
              |       | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
              |       +-end_expr=
              |         +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
              +-$analytic4#11 :=
                +-AnalyticFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=$query.z#3)
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

# Columns computed in SET with window function that are never referenced.
from KeyValue
|> set value = count(*) over ()
|> select 123
--
QueryStmt
+-output_column_list=
| +-$pipe_select.$col1#5 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$pipe_select.$col1#5]
    +-expr_list=
    | +-$col1#5 := Literal(type=INT64, value=123)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$analytic.value#3, $pipe_set.value#4]
        +-expr_list=
        | +-value#4 := ColumnRef(type=INT64, column=$analytic.value#3)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[$analytic.value#3]
            +-input_scan=
            | +-TableScan(table=KeyValue)
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-analytic_function_list=
                  +-value#3 :=
                    +-AnalyticFunctionCall(ZetaSQL:$count_star() -> INT64)
                      +-window_frame=
                        +-WindowFrame(frame_unit=ROWS)
                          +-start_expr=
                          | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                          +-end_expr=
                            +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

from KeyValue
|> set value = sum(key) OVER w
--
ERROR: Cannot reference a named window in pipe SET clause [at 2:30]
|> set value = sum(key) OVER w
                             ^
==

# Try to use SET to update an outer correlated column.
from KeyValue
|> extend (
     select 1 x
     |> SET key = 5
    )
--
ERROR: Name in pipe SET is present but is not a column on the pipe input table; SET can only update columns: key [at 4:13]
     |> SET key = 5
            ^
==

# Try to use SET to update a correlated name that is ambiguous.
from KeyValue
|> extend key
|> extend (
     select 1 x
     |> SET key = 5
    )
--
ERROR: Name in pipe SET is ambiguous; SET can only update columns: key [at 5:13]
     |> SET key = 5
            ^
==

# Try to use SET to update a constant.
from KeyValue
|> SET key = TestConstantProto
|> SET TestConstantProto = 5
--
ERROR: Column name in pipe SET not found in input table: TestConstantProto [at 3:8]
|> SET TestConstantProto = 5
       ^
==

# If collation is enabled, collation propagates to output columns the same way
# for SELECT and SET.
# TODO Enable java support for collation.
[no_java]
[language_features=PIPES{{|,V_1_3_ANNOTATION_FRAMEWORK|,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT}}]
from CollatedTable
|> select string_ci, concat(string_ci, "xxx") as newcol1,
      null as newcol2
|> SET newcol2=concat(string_ci, "yyy")
--
ALTERNATION GROUPS:
    <empty>
    ,V_1_3_ANNOTATION_FRAMEWORK
--
QueryStmt
+-output_column_list=
| +-CollatedTable.string_ci#1{Collation:"und:ci"} AS string_ci [STRING]
| +-$pipe_select.newcol1#5 AS newcol1 [STRING]
| +-$pipe_set.newcol2#7 AS newcol2 [STRING]
+-query=
  +-ProjectScan
    +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, $pipe_select.newcol1#5, $pipe_select.newcol2#6, $pipe_set.newcol2#7]
    +-expr_list=
    | +-newcol2#7 :=
    |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |     +-ColumnRef(type=STRING, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     +-Literal(type=STRING, value="yyy")
    +-input_scan=
      +-ProjectScan
        +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, $pipe_select.newcol1#5, $pipe_select.newcol2#6]
        +-expr_list=
        | +-newcol1#5 :=
        | | +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
        | |   +-ColumnRef(type=STRING, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        | |   +-Literal(type=STRING, value="xxx")
        | +-newcol2#6 := Literal(type=INT64, value=NULL)
        +-input_scan=
          +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
--
ALTERNATION GROUP: ,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT
--
QueryStmt
+-output_column_list=
| +-CollatedTable.string_ci#1{Collation:"und:ci"} AS string_ci [STRING]
| +-$pipe_select.newcol1#5{Collation:"und:ci"} AS newcol1 [STRING]
| +-$pipe_set.newcol2#7{Collation:"und:ci"} AS newcol2 [STRING]
+-query=
  +-ProjectScan
    +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, $pipe_select.newcol1#5{Collation:"und:ci"}, $pipe_select.newcol2#6, $pipe_set.newcol2#7{Collation:"und:ci"}]
    +-expr_list=
    | +-newcol2#7 :=
    |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     +-Literal(type=STRING, value="yyy")
    +-input_scan=
      +-ProjectScan
        +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, $pipe_select.newcol1#5{Collation:"und:ci"}, $pipe_select.newcol2#6]
        +-expr_list=
        | +-newcol1#5 :=
        | | +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
        | |   +-type_annotation_map={Collation:"und:ci"}
        | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        | |   +-Literal(type=STRING, value="xxx")
        | +-newcol2#6 := Literal(type=INT64, value=NULL)
        +-input_scan=
          +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
==

# After SET on a column, the range variable still points to the
# original row.
FROM KeyValue kv
|> SET key = 5.0
|> SELECT key, kv.key, kv
--
QueryStmt
+-output_column_list=
| +-$pipe_set.key#3 AS key [DOUBLE]
| +-KeyValue.Key#1 AS key [INT64]
| +-$pipe_select.kv#5 AS kv [STRUCT<Key INT64, Value STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$pipe_set.key#3, KeyValue.Key#1, $pipe_select.kv#5]
    +-expr_list=
    | +-kv#5 :=
    |   +-MakeStruct
    |     +-type=STRUCT<Key INT64, Value STRING>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_set.key#3]
        +-expr_list=
        | +-key#3 := Literal(type=DOUBLE, value=5)
        +-input_scan=
          +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
==

# After adding a column and setting it, the range variable for a value table
# still points at the original value row.
FROM TestExtraValueTable vt
|> EXTEND str_value
|> SET str_value=1.0
|> SELECT str_value, vt.str_value
--
QueryStmt
+-output_column_list=
| +-$pipe_set.str_value#5 AS str_value [DOUBLE]
| +-$pipe_select.str_value#6 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$pipe_set.str_value#5, $pipe_select.str_value#6]
    +-expr_list=
    | +-str_value#6 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-ProjectScan
        +-column_list=[TestExtraValueTable.value#1, $pipe_extend.str_value#4, $pipe_set.str_value#5]
        +-expr_list=
        | +-str_value#5 := Literal(type=DOUBLE, value=1)
        +-input_scan=
          +-ProjectScan
            +-column_list=[TestExtraValueTable.value#1, $pipe_extend.str_value#4]
            +-expr_list=
            | +-str_value#4 :=
            |   +-GetProtoField
            |     +-type=ARRAY<STRING>
            |     +-expr=
            |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
            |     +-field_descriptor=str_value
            |     +-default_value=[]
            +-input_scan=
              +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias="vt")
