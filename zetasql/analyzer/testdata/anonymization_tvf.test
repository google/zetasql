# The TVFs in this test file have the following userid columns, as
# defined in the SampleCatalog.
#
# tvf_no_args - <no userid>
# tvf_one_relation_arg_with_fixed_output - <no userid>
# tvf_one_templated_arg_with_anonymization_uid - column_int64
# tvf_one_relation_arg_with_anonymization_uid - column_int64
# tvf_no_args_with_anonymization_uid - column_int64
# tvf_no_args_with_nested_anonymization_uid - user_info.int32_val1
# tvf_no_args_value_table_with_anonymization_uid - int32_val1
# tvf_no_args_value_table_with_nested_anonymization_uid - nested_value.nested_int64

[default language_features=ANONYMIZATION,TABLE_VALUED_FUNCTIONS]
[default enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with anonymization anon_count(* CLAMPED BETWEEN 0 AND 100)
from tvf_no_args();
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-84
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TVFScan(parse_location=71-82, tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(1) INT64, optional(1) INT64) -> INT64)
              +-parse_location=26-36
              +-Literal(parse_location=55-56, type=INT64, value=0)
              +-Literal(parse_location=61-64, type=INT64, value=100)
[REPLACED_LITERALS]
select with anonymization anon_count(* CLAMPED BETWEEN @_p0_INT64 AND @_p1_INT64)
from tvf_no_args();

Rewrite ERROR: A SELECT WITH ANONYMIZATION query must query at least one table or TVF containing user data [at 1:1]
select with anonymization anon_count(* CLAMPED BETWEEN 0 AND 100)
^
==

# Allow expression TVF arguments that don't reference other tables/tvfs
select with anonymization anon_count(*)
from tvf_one_templated_arg_with_anonymization_uid(
  (select cast(42 as bool) as bool_column))
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_templated_arg_with_anonymization_uid((ANY TYPE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   +-signature=(BOOL) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-expr=
        |         +-SubqueryExpr
        |           +-type=BOOL
        |           +-subquery_type=SCALAR
        |           +-subquery=
        |             +-ProjectScan
        |               +-column_list=[$expr_subquery.bool_column#1]
        |               +-expr_list=
        |               | +-bool_column#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |               +-input_scan=
        |                 +-SingleRowScan
        +-aggregate_list=
          +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TVFScan
        |   |   +-column_list=[tvf_one_templated_arg_with_anonymization_uid.column_int64#14]
        |   |   +-tvf=tvf_one_templated_arg_with_anonymization_uid((ANY TYPE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   |   +-signature=(BOOL) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   |   +-argument_list=
        |   |   | +-FunctionArgument
        |   |   |   +-expr=
        |   |   |     +-SubqueryExpr
        |   |   |       +-type=BOOL
        |   |   |       +-subquery_type=SCALAR
        |   |   |       +-subquery=
        |   |   |         +-ProjectScan
        |   |   |           +-column_list=[$expr_subquery.bool_column#1]
        |   |   |           +-expr_list=
        |   |   |           | +-bool_column#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |   |           +-input_scan=
        |   |   |             +-SingleRowScan
        |   |   +-column_index_list=[6]
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=tvf_one_templated_arg_with_anonymization_uid.column_int64#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | +-$k_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#20)
==

# TVF arguments that are subqueries can reference tables with userids.
select with anonymization anon_count(*)
from tvf_one_templated_arg_with_anonymization_uid(
  (select cast(42 as bool) as bool_column from SimpleTypesWithAnonymizationUid))
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#25 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#25]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#25]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_templated_arg_with_anonymization_uid((ANY TYPE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   +-signature=(BOOL) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-expr=
        |         +-SubqueryExpr
        |           +-type=BOOL
        |           +-subquery_type=SCALAR
        |           +-subquery=
        |             +-ProjectScan
        |               +-column_list=[$expr_subquery.bool_column#13]
        |               +-expr_list=
        |               | +-bool_column#13 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |               +-input_scan=
        |                 +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
          +-$agg1#25 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#25 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#25]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#25]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#28, $group_by.$uid#29]
        |   +-input_scan=
        |   | +-TVFScan
        |   |   +-column_list=[tvf_one_templated_arg_with_anonymization_uid.column_int64#26]
        |   |   +-tvf=tvf_one_templated_arg_with_anonymization_uid((ANY TYPE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   |   +-signature=(BOOL) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   |   +-argument_list=
        |   |   | +-FunctionArgument
        |   |   |   +-expr=
        |   |   |     +-SubqueryExpr
        |   |   |       +-type=BOOL
        |   |   |       +-subquery_type=SCALAR
        |   |   |       +-subquery=
        |   |   |         +-ProjectScan
        |   |   |           +-column_list=[$expr_subquery.bool_column#13]
        |   |   |           +-expr_list=
        |   |   |           | +-bool_column#13 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |   |           +-input_scan=
        |   |   |             +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |   |   +-column_index_list=[6]
        |   +-group_by_list=
        |   | +-$uid#29 := ColumnRef(type=INT64, column=tvf_one_templated_arg_with_anonymization_uid.column_int64#26)
        |   +-aggregate_list=
        |     +-$agg1_partial#28 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#25 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#28)
        | +-$k_threshold_col#32 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#32)
==

# TVF arguments that are subqueries can reference tables.
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_anonymization_uid(
  (select * from SimpleTypes))
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#30 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#30]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#30]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   +-signature=(TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18]
        |       |   +-input_scan=
        |       |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
        |       +-argument_column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18]
        +-aggregate_list=
          +-$agg1#30 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#30 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#30]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#30]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#33, $group_by.$uid#34]
        |   +-input_scan=
        |   | +-TVFScan
        |   |   +-column_list=[tvf_one_relation_arg_with_anonymization_uid.column_int64#31]
        |   |   +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   |   +-signature=(TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   |   +-argument_list=
        |   |   | +-FunctionArgument
        |   |   |   +-scan=
        |   |   |   | +-ProjectScan
        |   |   |   |   +-column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18]
        |   |   |   |   +-input_scan=
        |   |   |   |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
        |   |   |   +-argument_column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18]
        |   |   +-column_index_list=[6]
        |   +-group_by_list=
        |   | +-$uid#34 := ColumnRef(type=INT64, column=tvf_one_relation_arg_with_anonymization_uid.column_int64#31)
        |   +-aggregate_list=
        |     +-$agg1_partial#33 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#30 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#33)
        | +-$k_threshold_col#37 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#37)
==

# TVF arguments that are TABLE arguments are allowed.
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_anonymization_uid(TABLE SimpleTypes)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#30 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#30]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#30]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   +-signature=(TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
        |       +-argument_column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18]
        +-aggregate_list=
          +-$agg1#30 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#30 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#30]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#30]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#33, $group_by.$uid#34]
        |   +-input_scan=
        |   | +-TVFScan
        |   |   +-column_list=[tvf_one_relation_arg_with_anonymization_uid.column_int64#31]
        |   |   +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   |   +-signature=(TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   |   +-argument_list=
        |   |   | +-FunctionArgument
        |   |   |   +-scan=
        |   |   |   | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
        |   |   |   +-argument_column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18]
        |   |   +-column_index_list=[6]
        |   +-group_by_list=
        |   | +-$uid#34 := ColumnRef(type=INT64, column=tvf_one_relation_arg_with_anonymization_uid.column_int64#31)
        |   +-aggregate_list=
        |     +-$agg1_partial#33 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#30 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#33)
        | +-$k_threshold_col#37 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#37)
==

# TVF arguments that are subqueries can reference tvfs.
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_anonymization_uid(
  (select * from tvf_no_args()))
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#14 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#14]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#14]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   +-signature=(TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=tvf_no_args.[column_bool#1, column_bytes#2]
        |       |   +-input_scan=
        |       |     +-TVFScan(column_list=tvf_no_args.[column_bool#1, column_bytes#2], tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
        |       +-argument_column_list=tvf_no_args.[column_bool#1, column_bytes#2]
        +-aggregate_list=
          +-$agg1#14 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#14 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#14]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#17, $group_by.$uid#18]
        |   +-input_scan=
        |   | +-TVFScan
        |   |   +-column_list=[tvf_one_relation_arg_with_anonymization_uid.column_int64#15]
        |   |   +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   |   +-signature=(TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   |   +-argument_list=
        |   |   | +-FunctionArgument
        |   |   |   +-scan=
        |   |   |   | +-ProjectScan
        |   |   |   |   +-column_list=tvf_no_args.[column_bool#1, column_bytes#2]
        |   |   |   |   +-input_scan=
        |   |   |   |     +-TVFScan(column_list=tvf_no_args.[column_bool#1, column_bytes#2], tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
        |   |   |   +-argument_column_list=tvf_no_args.[column_bool#1, column_bytes#2]
        |   |   +-column_index_list=[6]
        |   +-group_by_list=
        |   | +-$uid#18 := ColumnRef(type=INT64, column=tvf_one_relation_arg_with_anonymization_uid.column_int64#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#17 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#17)
        | +-$k_threshold_col#21 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#21)
==

# TVF arguments that are subqueries can reference tvfs which themselves have
# userids.
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_anonymization_uid(
         (select * from tvf_one_relation_arg_with_anonymization_uid(
             (select * from tvf_no_args()))));
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#25 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#25]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#25]
        +-input_scan=
        | +-TVFScan
        |   +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   +-signature=(TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=tvf_one_relation_arg_with_anonymization_uid.[column_bool#3, column_bytes#4, column_date#5, column_double#6, column_float#7, column_int32#8, column_int64#9, column_string#10, column_time#11, column_uint32#12, column_uint64#13]
        |       |   +-input_scan=
        |       |     +-TVFScan
        |       |       +-column_list=tvf_one_relation_arg_with_anonymization_uid.[column_bool#3, column_bytes#4, column_date#5, column_double#6, column_float#7, column_int32#8, column_int64#9, column_string#10, column_time#11, column_uint32#12, column_uint64#13]
        |       |       +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |       |       +-signature=(TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |       |       +-argument_list=
        |       |       | +-FunctionArgument
        |       |       |   +-scan=
        |       |       |   | +-ProjectScan
        |       |       |   |   +-column_list=tvf_no_args.[column_bool#1, column_bytes#2]
        |       |       |   |   +-input_scan=
        |       |       |   |     +-TVFScan(column_list=tvf_no_args.[column_bool#1, column_bytes#2], tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
        |       |       |   +-argument_column_list=tvf_no_args.[column_bool#1, column_bytes#2]
        |       |       +-column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        |       +-argument_column_list=tvf_one_relation_arg_with_anonymization_uid.[column_bool#3, column_bytes#4, column_date#5, column_double#6, column_float#7, column_int32#8, column_int64#9, column_string#10, column_time#11, column_uint32#12, column_uint64#13]
        +-aggregate_list=
          +-$agg1#25 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#25 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#25]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#25]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#28, $group_by.$uid#29]
        |   +-input_scan=
        |   | +-TVFScan
        |   |   +-column_list=[tvf_one_relation_arg_with_anonymization_uid.column_int64#26]
        |   |   +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   |   +-signature=(TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   |   +-argument_list=
        |   |   | +-FunctionArgument
        |   |   |   +-scan=
        |   |   |   | +-ProjectScan
        |   |   |   |   +-column_list=tvf_one_relation_arg_with_anonymization_uid.[column_bool#3, column_bytes#4, column_date#5, column_double#6, column_float#7, column_int32#8, column_int64#9, column_string#10, column_time#11, column_uint32#12, column_uint64#13]
        |   |   |   |   +-input_scan=
        |   |   |   |     +-TVFScan
        |   |   |   |       +-column_list=tvf_one_relation_arg_with_anonymization_uid.[column_bool#3, column_bytes#4, column_date#5, column_double#6, column_float#7, column_int32#8, column_int64#9, column_string#10, column_time#11, column_uint32#12, column_uint64#13]
        |   |   |   |       +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   |   |   |       +-signature=(TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   |   |   |       +-argument_list=
        |   |   |   |       | +-FunctionArgument
        |   |   |   |       |   +-scan=
        |   |   |   |       |   | +-ProjectScan
        |   |   |   |       |   |   +-column_list=tvf_no_args.[column_bool#1, column_bytes#2]
        |   |   |   |       |   |   +-input_scan=
        |   |   |   |       |   |     +-TVFScan(column_list=tvf_no_args.[column_bool#1, column_bytes#2], tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
        |   |   |   |       |   +-argument_column_list=tvf_no_args.[column_bool#1, column_bytes#2]
        |   |   |   |       +-column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        |   |   |   +-argument_column_list=tvf_one_relation_arg_with_anonymization_uid.[column_bool#3, column_bytes#4, column_date#5, column_double#6, column_float#7, column_int32#8, column_int64#9, column_string#10, column_time#11, column_uint32#12, column_uint64#13]
        |   |   +-column_index_list=[6]
        |   +-group_by_list=
        |   | +-$uid#29 := ColumnRef(type=INT64, column=tvf_one_relation_arg_with_anonymization_uid.column_int64#26)
        |   +-aggregate_list=
        |     +-$agg1_partial#28 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#25 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#28)
        | +-$k_threshold_col#32 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#32)
==

# TVFs must have a userid or the query fails, even in an input table has a
# userid.
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_fixed_output(
  (select * from SimpleTypesWithAnonymizationUid))
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-135
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-TVFScan
        |   +-parse_location=45-83
        |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   +-signature=(TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, uid INT64, numeric NUMERIC>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-parse_location=88-133
        |       |   +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |       |   +-input_scan=
        |       |     +-TableScan(parse_location=102-133, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |       +-argument_column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        +-aggregate_list=
          +-$agg1#15 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)(parse_location=26-36)
[REPLACED_LITERALS]
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_fixed_output(
  (select * from SimpleTypesWithAnonymizationUid))

Rewrite ERROR: A SELECT WITH ANONYMIZATION query must query at least one table or TVF containing user data [at 1:1]
select with anonymization anon_count(*)
^
==

# TVFs must have their own userid or the query fails, even if an input TABLE
# argument has a userid.
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_fixed_output(
  TABLE SimpleTypesWithAnonymizationUid)
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-125
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-TVFScan
        |   +-parse_location=45-83
        |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   +-signature=(TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, uid INT64, numeric NUMERIC>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-TableScan(parse_location=93-124, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |       +-argument_column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        +-aggregate_list=
          +-$agg1#15 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)(parse_location=26-36)
[REPLACED_LITERALS]
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_fixed_output(
  TABLE SimpleTypesWithAnonymizationUid)

Rewrite ERROR: A SELECT WITH ANONYMIZATION query must query at least one table or TVF containing user data [at 1:1]
select with anonymization anon_count(*)
^
==

# The rewriter does not support anonymization queries as arguments
# to TVFs yet.
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_anonymization_uid(
  (select with anonymization anon_count(*) from SimpleTypesWithAnonymizationUid))
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#25 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-171
    +-column_list=[$aggregate.$agg1#25]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#25]
        +-input_scan=
        | +-TVFScan
        |   +-parse_location=45-88
        |   +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   +-signature=(TABLE<$col1 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-parse_location=93-169
        |       |   +-column_list=[$aggregate.$agg1#13]
        |       |   +-input_scan=
        |       |     +-AnonymizedAggregateScan
        |       |       +-column_list=[$aggregate.$agg1#13]
        |       |       +-input_scan=
        |       |       | +-TableScan(parse_location=138-169, table=SimpleTypesWithAnonymizationUid)
        |       |       +-aggregate_list=
        |       |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)(parse_location=119-129)
        |       +-argument_column_list=[$aggregate.$agg1#13]
        +-aggregate_list=
          +-$agg1#25 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)(parse_location=26-36)
[REPLACED_LITERALS]
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_anonymization_uid(
  (select with anonymization anon_count(*) from SimpleTypesWithAnonymizationUid))

Rewrite ERROR: TVF arguments do not support SELECT WITH ANONYMIZATION queries [at 3:4]
  (select with anonymization anon_count(*) from SimpleTypesWithAnonymizationU...
   ^
==

# Allow tables containing user data to be referenced in TVFs that are not child
# nodes of anonymization scans.
select with anonymization anon_count(*)
from SimpleTypesWithAnonymizationUid
union all
select count(*) from tvf_one_relation_arg_with_fixed_output(
  (select cast(42 as bool) as bool_column from SimpleTypesWithAnonymizationUid))
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#30 AS `$col1` [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#30]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.$agg1#13]
      | |   +-input_scan=
      | |     +-AnonymizedAggregateScan
      | |       +-column_list=[$aggregate.$agg1#13]
      | |       +-input_scan=
      | |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
      | |       +-aggregate_list=
      | |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)
      | +-output_column_list=[$aggregate.$agg1#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#29]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#29]
        |       +-input_scan=
        |       | +-TVFScan
        |       |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |       |   +-signature=(TABLE<bool_column BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |       |   +-argument_list=
        |       |     +-FunctionArgument
        |       |       +-scan=
        |       |       | +-ProjectScan
        |       |       |   +-column_list=[$subquery1.bool_column#26]
        |       |       |   +-expr_list=
        |       |       |   | +-bool_column#26 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |       |       |   +-input_scan=
        |       |       |     +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |       |       +-argument_column_list=[$subquery1.bool_column#26]
        |       +-aggregate_list=
        |         +-$agg1#29 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-output_column_list=[$aggregate.$agg1#29]

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$union_all.$col1#30 AS `$col1` [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#30]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.$agg1#13]
      | |   +-input_scan=
      | |     +-AnonymizedAggregateScan
      | |       +-column_list=[$aggregate.$agg1#13]
      | |       +-input_scan=
      | |       | +-AggregateScan
      | |       |   +-column_list=[$aggregate.$agg1_partial#33, $group_by.$uid#34]
      | |       |   +-input_scan=
      | |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#31], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
      | |       |   +-group_by_list=
      | |       |   | +-$uid#34 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#31)
      | |       |   +-aggregate_list=
      | |       |     +-$agg1_partial#33 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
      | |       +-aggregate_list=
      | |       | +-$agg1#13 :=
      | |       | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
      | |       | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#33)
      | |       | +-$k_threshold_col#37 :=
      | |       |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
      | |       |     +-Literal(type=INT64, value=1)
      | |       |     +-Literal(type=INT64, value=0)
      | |       |     +-Literal(type=INT64, value=1)
      | |       +-k_threshold_expr=
      | |         +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#37)
      | +-output_column_list=[$aggregate.$agg1#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#29]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#29]
        |       +-input_scan=
        |       | +-TVFScan
        |       |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |       |   +-signature=(TABLE<bool_column BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |       |   +-argument_list=
        |       |     +-FunctionArgument
        |       |       +-scan=
        |       |       | +-ProjectScan
        |       |       |   +-column_list=[$subquery1.bool_column#26]
        |       |       |   +-expr_list=
        |       |       |   | +-bool_column#26 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |       |       |   +-input_scan=
        |       |       |     +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |       |       +-argument_column_list=[$subquery1.bool_column#26]
        |       +-aggregate_list=
        |         +-$agg1#29 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-output_column_list=[$aggregate.$agg1#29]

[TableScan Groups]
{
  TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#31], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
}
==

# The rewriter does not support anonymization queries as arguments
# to TVFs yet.
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_anonymization_uid(
  (select with anonymization anon_count(*) from SimpleTypes))
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#31 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-151
    +-column_list=[$aggregate.$agg1#31]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#31]
        +-input_scan=
        | +-TVFScan
        |   +-parse_location=45-88
        |   +-tvf=tvf_one_relation_arg_with_anonymization_uid((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        |   +-signature=(TABLE<$col1 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>
        |   +-argument_list=
        |     +-FunctionArgument
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-parse_location=93-149
        |       |   +-column_list=[$aggregate.$agg1#19]
        |       |   +-input_scan=
        |       |     +-AnonymizedAggregateScan
        |       |       +-column_list=[$aggregate.$agg1#19]
        |       |       +-input_scan=
        |       |       | +-TableScan(parse_location=138-149, table=SimpleTypes)
        |       |       +-aggregate_list=
        |       |         +-$agg1#19 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)(parse_location=119-129)
        |       +-argument_column_list=[$aggregate.$agg1#19]
        +-aggregate_list=
          +-$agg1#31 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)(parse_location=26-36)
[REPLACED_LITERALS]
select with anonymization anon_count(*)
from tvf_one_relation_arg_with_anonymization_uid(
  (select with anonymization anon_count(*) from SimpleTypes))

Rewrite ERROR: TVF arguments do not support SELECT WITH ANONYMIZATION queries [at 3:4]
  (select with anonymization anon_count(*) from SimpleTypes))
   ^
==

# Valid TVF query that doesn't explicitly project the uid column
select with anonymization anon_count(*)
from tvf_no_args_with_anonymization_uid();
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#12 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#12]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#12]
        +-input_scan=
        | +-TVFScan(tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>)
        +-aggregate_list=
          +-$agg1#12 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#12 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#12]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#12]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#15, $group_by.$uid#16]
        |   +-input_scan=
        |   | +-TVFScan(column_list=[tvf_no_args_with_anonymization_uid.column_int64#13], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[6])
        |   +-group_by_list=
        |   | +-$uid#16 := ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#13)
        |   +-aggregate_list=
        |     +-$agg1_partial#15 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#12 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#15)
        | +-$k_threshold_col#19 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#19)
==

# Valid TVF query that doesn't explicitly project the uid column, but does
# project columns that occur positionally before and after it in the TVF result
# schema. This checks that the uid column is being inserted positionally.
select with anonymization
  column_int32, column_string, anon_count(*)
from tvf_no_args_with_anonymization_uid()
group by column_int32, column_string;
--
QueryStmt
+-output_column_list=
| +-$groupby.column_int32#13 AS column_int32 [INT32]
| +-$groupby.column_string#14 AS column_string [STRING]
| +-$aggregate.$agg1#12 AS `$col3` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.column_int32#13, $groupby.column_string#14, $aggregate.$agg1#12]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$groupby.column_int32#13, $groupby.column_string#14, $aggregate.$agg1#12]
        +-input_scan=
        | +-TVFScan(column_list=tvf_no_args_with_anonymization_uid.[column_int32#6, column_string#8], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[5, 7])
        +-group_by_list=
        | +-column_int32#13 := ColumnRef(type=INT32, column=tvf_no_args_with_anonymization_uid.column_int32#6)
        | +-column_string#14 := ColumnRef(type=STRING, column=tvf_no_args_with_anonymization_uid.column_string#8)
        +-aggregate_list=
          +-$agg1#12 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.column_int32#13 AS column_int32 [INT32]
| +-$groupby.column_string#14 AS column_string [STRING]
| +-$aggregate.$agg1#12 AS `$col3` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.column_int32#13, $groupby.column_string#14, $aggregate.$agg1#12]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$groupby.column_int32#13, $groupby.column_string#14, $aggregate.$agg1#12]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#17, $groupby.column_int32_partial#18, $groupby.column_string_partial#19, $group_by.$uid#20]
        |   +-input_scan=
        |   | +-TVFScan(column_list=tvf_no_args_with_anonymization_uid.[column_int32#6, column_int64#15, column_string#8], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[5, 6, 7])
        |   +-group_by_list=
        |   | +-column_int32_partial#18 := ColumnRef(type=INT32, column=tvf_no_args_with_anonymization_uid.column_int32#6)
        |   | +-column_string_partial#19 := ColumnRef(type=STRING, column=tvf_no_args_with_anonymization_uid.column_string#8)
        |   | +-$uid#20 := ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#17 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-group_by_list=
        | +-column_int32#13 := ColumnRef(type=INT32, column=$groupby.column_int32_partial#18)
        | +-column_string#14 := ColumnRef(type=STRING, column=$groupby.column_string_partial#19)
        +-aggregate_list=
        | +-$agg1#12 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#17)
        | +-$k_threshold_col#23 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#23)
==

# Valid TVF query explicitly projecting the uid column (which is named
# 'column_int64')
select with anonymization anon_sum(column_int64)
from tvf_no_args_with_anonymization_uid();
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#12 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#12]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#12]
        +-input_scan=
        | +-TVFScan(column_list=[tvf_no_args_with_anonymization_uid.column_int64#7], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[6])
        +-aggregate_list=
          +-$agg1#12 :=
            +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
              +-ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#7)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#12 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#12]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#12]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#14, $group_by.$uid#15]
        |   +-input_scan=
        |   | +-TVFScan(column_list=[tvf_no_args_with_anonymization_uid.column_int64#7], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[6])
        |   +-group_by_list=
        |   | +-$uid#15 := ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#7)
        |   +-aggregate_list=
        |     +-$agg1_partial#14 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#7)
        +-aggregate_list=
        | +-$agg1#12 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#14)
        | +-$k_threshold_col#18 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#18)
==

# Valid TVF containing user data joined with table containing user data
select with anonymization anon_count(*)
from tvf_no_args_with_anonymization_uid() a
inner join SimpleTypesWithAnonymizationUid b on a.column_int64 = b.uid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#24 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#24]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#24]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[tvf_no_args_with_anonymization_uid.column_int64#7, SimpleTypesWithAnonymizationUid.uid#22]
        |   +-left_scan=
        |   | +-TVFScan(column_list=[tvf_no_args_with_anonymization_uid.column_int64#7], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[6], alias="a")
        |   +-right_scan=
        |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#22], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias="b")
        |   +-join_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#7)
        |       +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#22)
        +-aggregate_list=
          +-$agg1#24 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#24 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#24]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#24]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#26, $group_by.$uid#27]
        |   +-input_scan=
        |   | +-JoinScan
        |   |   +-column_list=[tvf_no_args_with_anonymization_uid.column_int64#7, SimpleTypesWithAnonymizationUid.uid#22]
        |   |   +-left_scan=
        |   |   | +-TVFScan(column_list=[tvf_no_args_with_anonymization_uid.column_int64#7], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[6], alias="a")
        |   |   +-right_scan=
        |   |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#22], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias="b")
        |   |   +-join_expr=
        |   |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   |       +-ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#7)
        |   |       +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#22)
        |   +-group_by_list=
        |   | +-$uid#27 := ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#7)
        |   +-aggregate_list=
        |     +-$agg1_partial#26 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#24 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#26)
        | +-$k_threshold_col#30 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#30)

[TableScan Groups]
{
  TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#22], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias="b")
}
==

# TVF containing user data joined with table containing user data without
# explicit join on uid
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with anonymization anon_count(*)
from tvf_no_args_with_anonymization_uid() a
cross join SimpleTypesWithAnonymizationUid b;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#24 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-128
    +-column_list=[$aggregate.$agg1#24]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#24]
        +-input_scan=
        | +-JoinScan
        |   +-left_scan=
        |   | +-TVFScan(parse_location=45-79, tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, alias="a")
        |   +-right_scan=
        |     +-TableScan(parse_location=95-126, table=SimpleTypesWithAnonymizationUid, alias="b")
        +-aggregate_list=
          +-$agg1#24 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)(parse_location=26-36)
[REPLACED_LITERALS]
select with anonymization anon_count(*)
from tvf_no_args_with_anonymization_uid() a
cross join SimpleTypesWithAnonymizationUid b;

Rewrite ERROR: Joins between tables containing private data must explicitly join on the user id column in each table, add 'ON a.column_int64=b.uid' [at 1:1]
select with anonymization anon_count(*)
^
==

# Valid TVF containing user data joined with table containing non-user data
select with anonymization anon_count(*)
from tvf_no_args_with_anonymization_uid() a
cross join SimpleTypes b;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#30 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#30]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#30]
        +-input_scan=
        | +-JoinScan
        |   +-left_scan=
        |   | +-TVFScan(tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, alias="a")
        |   +-right_scan=
        |     +-TableScan(table=SimpleTypes, alias="b")
        +-aggregate_list=
          +-$agg1#30 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#30 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#30]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#30]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#33, $group_by.$uid#34]
        |   +-input_scan=
        |   | +-JoinScan
        |   |   +-column_list=[tvf_no_args_with_anonymization_uid.column_int64#31]
        |   |   +-left_scan=
        |   |   | +-TVFScan(column_list=[tvf_no_args_with_anonymization_uid.column_int64#31], tvf=tvf_no_args_with_anonymization_uid(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[6], alias="a")
        |   |   +-right_scan=
        |   |     +-TableScan(table=SimpleTypes, alias="b")
        |   +-group_by_list=
        |   | +-$uid#34 := ColumnRef(type=INT64, column=tvf_no_args_with_anonymization_uid.column_int64#31)
        |   +-aggregate_list=
        |     +-$agg1_partial#33 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#30 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#33)
        | +-$k_threshold_col#37 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#37)
==

# Valid TVF containing non-user data joined with table containing user data
select with anonymization anon_count(*)
from tvf_no_args() a
cross join SimpleTypesWithAnonymizationUid b;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-JoinScan
        |   +-left_scan=
        |   | +-TVFScan(tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, alias="a")
        |   +-right_scan=
        |     +-TableScan(table=SimpleTypesWithAnonymizationUid, alias="b")
        +-aggregate_list=
          +-$agg1#15 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $group_by.$uid#19]
        |   +-input_scan=
        |   | +-JoinScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.uid#16]
        |   |   +-left_scan=
        |   |   | +-TVFScan(tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, alias="a")
        |   |   +-right_scan=
        |   |     +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#16], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias="b")
        |   +-group_by_list=
        |   | +-$uid#19 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#16)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#15 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#18)
        | +-$k_threshold_col#22 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#22)

[TableScan Groups]
{
  TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#16], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias="b")
}
==

# TODO: Nested user IDs are not currently supported.
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with anonymization anon_count(*)
from tvf_no_args_with_nested_anonymization_uid();
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-88
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-TVFScan(parse_location=45-86, tvf=tvf_no_args_with_nested_anonymization_uid(() -> TABLE<user_info PROTO<zetasql_test__.TestExtraPB>>), signature=() -> TABLE<user_info PROTO<zetasql_test__.TestExtraPB>>)
        +-aggregate_list=
          +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)(parse_location=26-36)
[REPLACED_LITERALS]
select with anonymization anon_count(*)
from tvf_no_args_with_nested_anonymization_uid();

Rewrite ERROR: Nested user IDs are not currently supported for TVFs (in TVF tvf_no_args_with_nested_anonymization_uid) [at 2:6]
from tvf_no_args_with_nested_anonymization_uid();
     ^
==

# Fetching user IDs from a value table.
select with anonymization anon_count(*)
from tvf_no_args_value_table_with_anonymization_uid();
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-TVFScan(tvf=tvf_no_args_value_table_with_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>), signature=() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
        +-aggregate_list=
          +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#6, $group_by.$uid#7]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[tvf_no_args_value_table_with_anonymization_uid.$value#3, $project.$int32_val1#4]
        |   |   +-expr_list=
        |   |   | +-$int32_val1#4 :=
        |   |   |   +-GetProtoField
        |   |   |     +-type=INT32
        |   |   |     +-expr=
        |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_no_args_value_table_with_anonymization_uid.$value#3)
        |   |   |     +-field_descriptor=int32_val1
        |   |   |     +-default_value=0
        |   |   +-input_scan=
        |   |     +-TVFScan(column_list=[tvf_no_args_value_table_with_anonymization_uid.$value#3], tvf=tvf_no_args_value_table_with_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>), signature=() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>, column_index_list=[0])
        |   +-group_by_list=
        |   | +-$uid#7 := ColumnRef(type=INT32, column=$project.$int32_val1#4)
        |   +-aggregate_list=
        |     +-$agg1_partial#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#2 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#6)
        | +-$k_threshold_col#10 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#10)
==

# Fetching nested user IDs from a value table.
select with anonymization anon_count(*)
from tvf_no_args_value_table_with_nested_anonymization_uid();
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-TVFScan(tvf=tvf_no_args_value_table_with_nested_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>), signature=() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>)
        +-aggregate_list=
          +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#7, $group_by.$uid#8]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[tvf_no_args_value_table_with_nested_anonymization_uid.$value#3, $project.$nested_int64#5]
        |   |   +-expr_list=
        |   |   | +-$nested_int64#5 :=
        |   |   |   +-GetProtoField
        |   |   |     +-type=INT64
        |   |   |     +-expr=
        |   |   |     | +-GetProtoField
        |   |   |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
        |   |   |     |   +-expr=
        |   |   |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=tvf_no_args_value_table_with_nested_anonymization_uid.$value#3)
        |   |   |     |   +-field_descriptor=nested_value
        |   |   |     |   +-default_value=NULL
        |   |   |     +-field_descriptor=nested_int64
        |   |   |     +-default_value=88
        |   |   +-input_scan=
        |   |     +-TVFScan(column_list=[tvf_no_args_value_table_with_nested_anonymization_uid.$value#3], tvf=tvf_no_args_value_table_with_nested_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>), signature=() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>, column_index_list=[0])
        |   +-group_by_list=
        |   | +-$uid#8 := ColumnRef(type=INT64, column=$project.$nested_int64#5)
        |   +-aggregate_list=
        |     +-$agg1_partial#7 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#2 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#7)
        | +-$k_threshold_col#11 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#11)
==

# Selecting anon functions over and fetching nested user IDs from a value table.
select with anonymization anon_sum(nested_value.nested_int64),
                          anon_avg(nested_value.nested_int64),
                          anon_sum(int32_val)
    from tvf_no_args_value_table_with_nested_anonymization_uid();
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS `$col1` [INT64]
| +-$aggregate.$agg2#3 AS `$col2` [DOUBLE]
| +-$aggregate.$agg3#4 AS `$col3` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#2, $agg2#3, $agg3#4]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=$aggregate.[$agg1#2, $agg2#3, $agg3#4]
        +-input_scan=
        | +-TVFScan(column_list=[tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1], tvf=tvf_no_args_value_table_with_nested_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>), signature=() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#2 :=
          | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
          |   +-GetProtoField
          |     +-type=INT64
          |     +-expr=
          |     | +-GetProtoField
          |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
          |     |   +-expr=
          |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1)
          |     |   +-field_descriptor=nested_value
          |     |   +-default_value=NULL
          |     +-field_descriptor=nested_int64
          |     +-default_value=88
          +-$agg2#3 :=
          | +-AggregateFunctionCall(ZetaSQL:anon_avg(DOUBLE, optional(0) DOUBLE, optional(0) DOUBLE) -> DOUBLE)
          |   +-Cast(INT64 -> DOUBLE)
          |     +-GetProtoField
          |       +-type=INT64
          |       +-expr=
          |       | +-GetProtoField
          |       |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
          |       |   +-expr=
          |       |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1)
          |       |   +-field_descriptor=nested_value
          |       |   +-default_value=NULL
          |       +-field_descriptor=nested_int64
          |       +-default_value=88
          +-$agg3#4 :=
            +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
              +-Cast(INT32 -> INT64)
                +-GetProtoField
                  +-type=INT32
                  +-expr=
                  | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1)
                  +-field_descriptor=int32_val
                  +-default_value=77

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS `$col1` [INT64]
| +-$aggregate.$agg2#3 AS `$col2` [DOUBLE]
| +-$aggregate.$agg3#4 AS `$col3` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#2, $agg2#3, $agg3#4]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=$aggregate.[$agg1#2, $agg2#3, $agg3#4]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#8, $aggregate.$agg2_partial#10, $aggregate.$agg3_partial#12, $group_by.$uid#13]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1, $project.$nested_int64#6]
        |   |   +-expr_list=
        |   |   | +-$nested_int64#6 :=
        |   |   |   +-GetProtoField
        |   |   |     +-type=INT64
        |   |   |     +-expr=
        |   |   |     | +-GetProtoField
        |   |   |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
        |   |   |     |   +-expr=
        |   |   |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1)
        |   |   |     |   +-field_descriptor=nested_value
        |   |   |     |   +-default_value=NULL
        |   |   |     +-field_descriptor=nested_int64
        |   |   |     +-default_value=88
        |   |   +-input_scan=
        |   |     +-TVFScan(column_list=[tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1], tvf=tvf_no_args_value_table_with_nested_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>), signature=() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>, column_index_list=[0])
        |   +-group_by_list=
        |   | +-$uid#13 := ColumnRef(type=INT64, column=$project.$nested_int64#6)
        |   +-aggregate_list=
        |     +-$agg1_partial#8 :=
        |     | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |     |   +-GetProtoField
        |     |     +-type=INT64
        |     |     +-expr=
        |     |     | +-GetProtoField
        |     |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
        |     |     |   +-expr=
        |     |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1)
        |     |     |   +-field_descriptor=nested_value
        |     |     |   +-default_value=NULL
        |     |     +-field_descriptor=nested_int64
        |     |     +-default_value=88
        |     +-$agg2_partial#10 :=
        |     | +-AggregateFunctionCall(ZetaSQL:avg(DOUBLE) -> DOUBLE)
        |     |   +-Cast(INT64 -> DOUBLE)
        |     |     +-GetProtoField
        |     |       +-type=INT64
        |     |       +-expr=
        |     |       | +-GetProtoField
        |     |       |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
        |     |       |   +-expr=
        |     |       |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1)
        |     |       |   +-field_descriptor=nested_value
        |     |       |   +-default_value=NULL
        |     |       +-field_descriptor=nested_int64
        |     |       +-default_value=88
        |     +-$agg3_partial#12 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-Cast(INT32 -> INT64)
        |           +-GetProtoField
        |             +-type=INT32
        |             +-expr=
        |             | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1)
        |             +-field_descriptor=int32_val
        |             +-default_value=77
        +-aggregate_list=
        | +-$agg1#2 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#8)
        | +-$agg2#3 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_avg(DOUBLE, optional(0) DOUBLE, optional(0) DOUBLE) -> DOUBLE)
        | |   +-ColumnRef(type=DOUBLE, column=$aggregate.$agg2_partial#10)
        | +-$agg3#4 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg3_partial#12)
        | +-$k_threshold_col#18 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#18)
==

# The projected uid column is visible from the query and can be used.
select with anonymization anon_count(*)
from (select count(*), int32_val1
      from tvf_no_args_value_table_with_anonymization_uid()
      group by int32_val1);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#2, $groupby.int32_val1#3]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.int32_val1#3, $aggregate.$agg1#2]
        |       +-input_scan=
        |       | +-TVFScan(column_list=[tvf_no_args_value_table_with_anonymization_uid.$col0#1], tvf=tvf_no_args_value_table_with_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>), signature=() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>, column_index_list=[0])
        |       +-group_by_list=
        |       | +-int32_val1#3 :=
        |       |   +-GetProtoField
        |       |     +-type=INT32
        |       |     +-expr=
        |       |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_no_args_value_table_with_anonymization_uid.$col0#1)
        |       |     +-field_descriptor=int32_val1
        |       |     +-default_value=0
        |       +-aggregate_list=
        |         +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
          +-$agg1#4 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#7, $group_by.$uid#8]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#2, $groupby.int32_val1#3]
        |   |   +-input_scan=
        |   |     +-AggregateScan
        |   |       +-column_list=[$groupby.int32_val1#3, $aggregate.$agg1#2]
        |   |       +-input_scan=
        |   |       | +-ProjectScan
        |   |       |   +-column_list=[tvf_no_args_value_table_with_anonymization_uid.$col0#1, $project.$int32_val1#5]
        |   |       |   +-expr_list=
        |   |       |   | +-$int32_val1#5 :=
        |   |       |   |   +-GetProtoField
        |   |       |   |     +-type=INT32
        |   |       |   |     +-expr=
        |   |       |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_no_args_value_table_with_anonymization_uid.$col0#1)
        |   |       |   |     +-field_descriptor=int32_val1
        |   |       |   |     +-default_value=0
        |   |       |   +-input_scan=
        |   |       |     +-TVFScan(column_list=[tvf_no_args_value_table_with_anonymization_uid.$col0#1], tvf=tvf_no_args_value_table_with_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>), signature=() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>, column_index_list=[0])
        |   |       +-group_by_list=
        |   |       | +-int32_val1#3 := ColumnRef(type=INT32, column=$project.$int32_val1#5)
        |   |       +-aggregate_list=
        |   |         +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-group_by_list=
        |   | +-$uid#8 := ColumnRef(type=INT32, column=$groupby.int32_val1#3)
        |   +-aggregate_list=
        |     +-$agg1_partial#7 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#4 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#7)
        | +-$k_threshold_col#11 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#11)
==

# The projected uid column is visible from the query and can be used.
select with anonymization anon_count(*)
from (select count(*), int32_val1
      from (select int32_val1
            from tvf_no_args_value_table_with_anonymization_uid())
      group by int32_val1);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#3, $groupby.int32_val1#4]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.int32_val1#4, $aggregate.$agg1#3]
        |       +-input_scan=
        |       | +-ProjectScan
        |       |   +-column_list=[$subquery2.int32_val1#2]
        |       |   +-expr_list=
        |       |   | +-int32_val1#2 :=
        |       |   |   +-GetProtoField
        |       |   |     +-type=INT32
        |       |   |     +-expr=
        |       |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_no_args_value_table_with_anonymization_uid.$col0#1)
        |       |   |     +-field_descriptor=int32_val1
        |       |   |     +-default_value=0
        |       |   +-input_scan=
        |       |     +-TVFScan(column_list=[tvf_no_args_value_table_with_anonymization_uid.$col0#1], tvf=tvf_no_args_value_table_with_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>), signature=() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>, column_index_list=[0])
        |       +-group_by_list=
        |       | +-int32_val1#4 := ColumnRef(type=INT32, column=$subquery2.int32_val1#2)
        |       +-aggregate_list=
        |         +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
          +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#8, $group_by.$uid#9]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#3, $groupby.int32_val1#4]
        |   |   +-input_scan=
        |   |     +-AggregateScan
        |   |       +-column_list=[$groupby.int32_val1#4, $aggregate.$agg1#3]
        |   |       +-input_scan=
        |   |       | +-ProjectScan
        |   |       |   +-column_list=[$subquery2.int32_val1#2]
        |   |       |   +-expr_list=
        |   |       |   | +-int32_val1#2 := ColumnRef(type=INT32, column=$project.$int32_val1#6)
        |   |       |   +-input_scan=
        |   |       |     +-ProjectScan
        |   |       |       +-column_list=[tvf_no_args_value_table_with_anonymization_uid.$col0#1, $project.$int32_val1#6]
        |   |       |       +-expr_list=
        |   |       |       | +-$int32_val1#6 :=
        |   |       |       |   +-GetProtoField
        |   |       |       |     +-type=INT32
        |   |       |       |     +-expr=
        |   |       |       |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_no_args_value_table_with_anonymization_uid.$col0#1)
        |   |       |       |     +-field_descriptor=int32_val1
        |   |       |       |     +-default_value=0
        |   |       |       +-input_scan=
        |   |       |         +-TVFScan(column_list=[tvf_no_args_value_table_with_anonymization_uid.$col0#1], tvf=tvf_no_args_value_table_with_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>), signature=() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>, column_index_list=[0])
        |   |       +-group_by_list=
        |   |       | +-int32_val1#4 := ColumnRef(type=INT32, column=$subquery2.int32_val1#2)
        |   |       +-aggregate_list=
        |   |         +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-group_by_list=
        |   | +-$uid#9 := ColumnRef(type=INT32, column=$groupby.int32_val1#4)
        |   +-aggregate_list=
        |     +-$agg1_partial#8 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#5 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#8)
        | +-$k_threshold_col#12 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#12)
==

# Nested projected uid columns are visible from the query and can be used
select with anonymization anon_count(*)
from (select count(*), nested_value.nested_int64
      from tvf_no_args_value_table_with_nested_anonymization_uid()
      group by nested_value.nested_int64);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#2, $groupby.nested_int64#3]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.nested_int64#3, $aggregate.$agg1#2]
        |       +-input_scan=
        |       | +-TVFScan(column_list=[tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1], tvf=tvf_no_args_value_table_with_nested_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>), signature=() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>, column_index_list=[0])
        |       +-group_by_list=
        |       | +-nested_int64#3 :=
        |       |   +-GetProtoField
        |       |     +-type=INT64
        |       |     +-expr=
        |       |     | +-GetProtoField
        |       |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
        |       |     |   +-expr=
        |       |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1)
        |       |     |   +-field_descriptor=nested_value
        |       |     |   +-default_value=NULL
        |       |     +-field_descriptor=nested_int64
        |       |     +-default_value=88
        |       +-aggregate_list=
        |         +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
          +-$agg1#4 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#8, $group_by.$uid#9]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#2, $groupby.nested_int64#3]
        |   |   +-input_scan=
        |   |     +-AggregateScan
        |   |       +-column_list=[$groupby.nested_int64#3, $aggregate.$agg1#2]
        |   |       +-input_scan=
        |   |       | +-ProjectScan
        |   |       |   +-column_list=[tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1, $project.$nested_int64#6]
        |   |       |   +-expr_list=
        |   |       |   | +-$nested_int64#6 :=
        |   |       |   |   +-GetProtoField
        |   |       |   |     +-type=INT64
        |   |       |   |     +-expr=
        |   |       |   |     | +-GetProtoField
        |   |       |   |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
        |   |       |   |     |   +-expr=
        |   |       |   |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1)
        |   |       |   |     |   +-field_descriptor=nested_value
        |   |       |   |     |   +-default_value=NULL
        |   |       |   |     +-field_descriptor=nested_int64
        |   |       |   |     +-default_value=88
        |   |       |   +-input_scan=
        |   |       |     +-TVFScan(column_list=[tvf_no_args_value_table_with_nested_anonymization_uid.$col0#1], tvf=tvf_no_args_value_table_with_nested_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>), signature=() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>, column_index_list=[0])
        |   |       +-group_by_list=
        |   |       | +-nested_int64#3 := ColumnRef(type=INT64, column=$project.$nested_int64#6)
        |   |       +-aggregate_list=
        |   |         +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-group_by_list=
        |   | +-$uid#9 := ColumnRef(type=INT64, column=$groupby.nested_int64#3)
        |   +-aggregate_list=
        |     +-$agg1_partial#8 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#4 :=
        | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#8)
        | +-$k_threshold_col#12 :=
        |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=INT64, value=0)
        |     +-Literal(type=INT64, value=1)
        +-k_threshold_expr=
          +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#12)
==

# Value table uid column paths are correctly displayed in error messages.
select with anonymization anon_count(*)
from (select count(*)
      from tvf_no_args_value_table_with_anonymization_uid() as t);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#2]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#2]
        |       +-input_scan=
        |       | +-TVFScan(tvf=tvf_no_args_value_table_with_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>), signature=() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>, alias="t")
        |       +-aggregate_list=
        |         +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
          +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: Subqueries of anonymization queries must explicitly SELECT the userid column 't.int32_val1'
==

# Nested value table uid column paths are correctly displayed in error messages.
select with anonymization anon_count(*)
from (select count(*)
      from tvf_no_args_value_table_with_nested_anonymization_uid() as t);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#2]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#2]
        |       +-input_scan=
        |       | +-TVFScan(tvf=tvf_no_args_value_table_with_nested_anonymization_uid(() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>), signature=() -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>, alias="t")
        |       +-aggregate_list=
        |         +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
          +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: Subqueries of anonymization queries must explicitly SELECT the userid column 't.nested_value.nested_int64'
