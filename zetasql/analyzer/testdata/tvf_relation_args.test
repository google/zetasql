# Tests for resolving table-valued functions including relation arguments.
#
################################################################################
#
# Positive test cases
#
################################################################################
#
# A TVF accepts one relation argument. The relation argument has one column with
# an explicit alias. The result schema is hardcoded to return two columns of
# type bool and bytes (rather than passing through the schema of the input
# relation).
[default language_features=TABLE_VALUED_FUNCTIONS,TABLESAMPLE,TABLESAMPLE_FROM_TABLE_VALUED_FUNCTIONS,V_1_1_WITH_ON_SUBQUERY,FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES]
select * from tvf_one_relation_arg_with_fixed_output(
    (select cast(42 as bool) as bool_column))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<bool_column BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.bool_column#1]
        |   |   +-expr_list=
        |   |   | +-bool_column#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.bool_column#1]
        +-column_index_list=[0, 1]
==

# A TVF accepts one relation argument. The relation argument has one column with
# no explicit alias.
select * from tvf_one_relation_arg_with_fixed_output(
    (select cast(42 as bool)))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<$col1 BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.$col1#1]
        |   |   +-expr_list=
        |   |   | +-$col1#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.$col1#1]
        +-column_index_list=[0, 1]
==

# A TVF accepts one relation argument with one column. The TVF has an alias
# assigned to it and the enclosing query refers to this alias by name.
select mytvf, mytvf.column_bool, column_bool, *, mytvf.*
from tvf_one_relation_arg_with_fixed_output(
    (select cast(42 as bool))) as mytvf
--
QueryStmt
+-output_column_list=
| +-$query.mytvf#5 AS mytvf [STRUCT<column_bool BOOL, column_bytes BYTES>]
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#3 AS column_bytes [BYTES]
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$query.mytvf#5, tvf_one_relation_arg_with_fixed_output.column_bool#2, tvf_one_relation_arg_with_fixed_output.column_bool#2, tvf_one_relation_arg_with_fixed_output.column_bool#2, tvf_one_relation_arg_with_fixed_output.column_bytes#3, tvf_one_relation_arg_with_fixed_output.column_bool#2, tvf_one_relation_arg_with_fixed_output.column_bytes#3]
    +-expr_list=
    | +-mytvf#5 :=
    |   +-MakeStruct
    |     +-type=STRUCT<column_bool BOOL, column_bytes BYTES>
    |     +-field_list=
    |       +-ColumnRef(type=BOOL, column=tvf_one_relation_arg_with_fixed_output.column_bool#2)
    |       +-ColumnRef(type=BYTES, column=tvf_one_relation_arg_with_fixed_output.column_bytes#3)
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<$col1 BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.$col1#1]
        |   |   +-expr_list=
        |   |   | +-$col1#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.$col1#1]
        +-column_index_list=[0, 1]
        +-alias="mytvf"
==

# A TVF accepts one relation argument and sets the output schema to be equal to
# the input schema. The input relation specifies explicit aliases for some of
# the selected items.
select * from tvf_one_relation_arg_output_schema_is_input_schema(
    (select 1, 2 as y, 3 as z))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.$col1#4 AS `$col1` [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema.y#5 AS y [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema.z#6 AS z [INT64]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[$col1#4, y#5, z#6]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[$col1#4, y#5, z#6]
        +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<$col1 INT64, y INT64, z INT64>) -> TABLE<$col1 INT64, y INT64, z INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[$col1#1, y#2, z#3]
        |   |   +-expr_list=
        |   |   | +-$col1#1 := Literal(type=INT64, value=1)
        |   |   | +-y#2 := Literal(type=INT64, value=2)
        |   |   | +-z#3 := Literal(type=INT64, value=3)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[$col1#1, y#2, z#3]
        +-column_index_list=[0, 1, 2]
==

# A TVF accepts one relation argument. The input relation selects from a table.
select * from tvf_one_relation_arg_output_schema_is_input_schema(
    (select key as x, value as y, 3 as z from keyvalue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.x#4 AS x [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema.y#5 AS y [STRING]
| +-tvf_one_relation_arg_output_schema_is_input_schema.z#6 AS z [INT64]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[x#4, y#5, z#6]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[x#4, y#5, z#6]
        +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<x INT64, y STRING, z INT64>) -> TABLE<x INT64, y STRING, z INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $subquery1.z#3]
        |   |   +-expr_list=
        |   |   | +-z#3 := Literal(type=INT64, value=3)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=[KeyValue.Key#1, KeyValue.Value#2, $subquery1.z#3]
        +-column_index_list=[0, 1, 2]
==

# A TVF accepts one optional relation argument. The input relation selects from
# a table.
select * from tvf_one_optional_relation_arg_return_int64_value_table(
    (select key as x, value as y, 3 as z from keyvalue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_optional_relation_arg_return_int64_value_table.$col0#4 AS `$col0` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_one_optional_relation_arg_return_int64_value_table.$col0#4]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_one_optional_relation_arg_return_int64_value_table.$col0#4]
        +-tvf=tvf_one_optional_relation_arg_return_int64_value_table((optional ANY TABLE) -> TABLE<INT64>)
        +-signature=(TABLE<x INT64, y STRING, z INT64>) -> TABLE<INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $subquery1.z#3]
        |   |   +-expr_list=
        |   |   | +-z#3 := Literal(type=INT64, value=3)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=[KeyValue.Key#1, KeyValue.Value#2, $subquery1.z#3]
        +-column_index_list=[0]
==

# A TVF accepts one optional relation argument. The input doesn't have any
# argument.
select * from tvf_one_optional_relation_arg_return_int64_value_table()
--
QueryStmt
+-output_column_list=
| +-tvf_one_optional_relation_arg_return_int64_value_table.$col0#1 AS `$col0` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_one_optional_relation_arg_return_int64_value_table.$col0#1]
    +-input_scan=
      +-TVFScan(column_list=[tvf_one_optional_relation_arg_return_int64_value_table.$col0#1], tvf=tvf_one_optional_relation_arg_return_int64_value_table((optional ANY TABLE) -> TABLE<INT64>), signature=() -> TABLE<INT64>, column_index_list=[0])
==

select * from tvf_one_relation_arg_output_schema_is_input_schema(
    (select key as x, key as y, value from TwoIntegers))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.x#3 AS x [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema.y#4 AS y [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema.value#5 AS value [INT64]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[x#3, y#4, value#5]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[x#3, y#4, value#5]
        +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<x INT64, y INT64, value INT64>) -> TABLE<x INT64, y INT64, value INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=TwoIntegers.[key#1, key#1, value#2]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        |   +-argument_column_list=TwoIntegers.[key#1, key#1, value#2]
        +-column_index_list=[0, 1, 2]
==

# The query calls a TVF that forwards the input schema of a relation argument to
# the output schema, and also triggers a deprecation warning. The warning should
# be propagated. For more tests of propagation of deprecation warnings for TVFs,
# see tvf_scalar_args.test. We don't need a huge test suite for deprecation
# warnings from TVFs with a forwarded output schema because most of the code is
# shared with the case of TVFs with scalar arguments.
select * from tvf_one_relation_arg_output_schema_is_input_schema_deprecation(
    (select key as x, key as y, value from TwoIntegers))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema_deprecation.x#3 AS x [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema_deprecation.y#4 AS y [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema_deprecation.value#5 AS value [INT64]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_output_schema_is_input_schema_deprecation.[x#3, y#4, value#5]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_output_schema_is_input_schema_deprecation.[x#3, y#4, value#5]
        +-tvf=tvf_one_relation_arg_output_schema_is_input_schema_deprecation((ANY TABLE) -> ANY TABLE (1 deprecation warning))
        +-signature=(TABLE<x INT64, y INT64, value INT64>) -> TABLE<x INT64, y INT64, value INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=TwoIntegers.[key#1, key#1, value#2]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
        |   +-argument_column_list=TwoIntegers.[key#1, key#1, value#2]
        +-column_index_list=[0, 1, 2]


DEPRECATION WARNING:
Table-valued function tvf_one_relation_arg_output_schema_is_input_schema_deprecation triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 1:15]
select * from tvf_one_relation_arg_output_schema_is_input_schema_deprecation(
              ^
Operation <foo16> is deprecated [at module16.sqlm:26:36]
some caret string for foo_16
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }
==

# A TVF accepts one relation argument and one integer argument.
select * from tvf_one_relation_arg_output_schema_is_input_schema_plus_int64_arg(
    (select 1, 2, 3 from keyvalue), 64)
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema_plus_int64_arg.$col1#6 AS `$col1` [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema_plus_int64_arg.$col2#7 AS `$col2` [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema_plus_int64_arg.$col3#8 AS `$col3` [INT64]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_output_schema_is_input_schema_plus_int64_arg.[$col1#6, $col2#7, $col3#8]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_output_schema_is_input_schema_plus_int64_arg.[$col1#6, $col2#7, $col3#8]
        +-tvf=tvf_one_relation_arg_output_schema_is_input_schema_plus_int64_arg((ANY TABLE, INT64) -> ANY TABLE)
        +-signature=(TABLE<$col1 INT64, $col2 INT64, $col3 INT64>, literal INT64) -> TABLE<$col1 INT64, $col2 INT64, $col3 INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$subquery1.[$col1#3, $col2#4, $col3#5]
        | | |   +-expr_list=
        | | |   | +-$col1#3 := Literal(type=INT64, value=1)
        | | |   | +-$col2#4 := Literal(type=INT64, value=2)
        | | |   | +-$col3#5 := Literal(type=INT64, value=3)
        | | |   +-input_scan=
        | | |     +-TableScan(table=KeyValue)
        | | +-argument_column_list=$subquery1.[$col1#3, $col2#4, $col3#5]
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=64)
        +-column_index_list=[0, 1, 2]
==

# A TVF accepts one relation argument with many types in the SELECT list.
select * from tvf_one_relation_arg_with_fixed_output(
    (select cast(42 as int32) as column_int32,
            cast(42 as int64) as column_int64,
            cast(42 as uint32) as column_uint32,
            cast(42 as uint64) as column_uint64,
            cast(42 as float) as column_float,
            cast(42 as double) as column_double,
            cast("" as bytes) as column_bytes,
            "" as column_string))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#9 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#10 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#9, column_bytes#10]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#9, column_bytes#10]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<column_int32 INT32, column_int64 INT64, column_uint32 UINT32, column_uint64 UINT64, column_float FLOAT, column_double DOUBLE, column_bytes BYTES, column_string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[column_int32#1, column_int64#2, column_uint32#3, column_uint64#4, column_float#5, column_double#6, column_bytes#7, column_string#8]
        |   |   +-expr_list=
        |   |   | +-column_int32#1 := Literal(type=INT32, value=42, has_explicit_type=TRUE)
        |   |   | +-column_int64#2 := Literal(type=INT64, value=42, has_explicit_type=TRUE)
        |   |   | +-column_uint32#3 := Literal(type=UINT32, value=42, has_explicit_type=TRUE)
        |   |   | +-column_uint64#4 := Literal(type=UINT64, value=42, has_explicit_type=TRUE)
        |   |   | +-column_float#5 := Literal(type=FLOAT, value=42, has_explicit_type=TRUE)
        |   |   | +-column_double#6 := Literal(type=DOUBLE, value=42, has_explicit_type=TRUE)
        |   |   | +-column_bytes#7 := Literal(type=BYTES, value=b"", has_explicit_type=TRUE)
        |   |   | +-column_string#8 := Literal(type=STRING, value="")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[column_int32#1, column_int64#2, column_uint32#3, column_uint64#4, column_float#5, column_double#6, column_bytes#7, column_string#8]
        +-column_index_list=[0, 1]
==

# A TVF accepts one relation argument and returns a fixed schema. The relation
# argument selects a value table.
select * from tvf_one_relation_arg_with_fixed_output(
    (select as value Key from KeyValue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#3 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#3, column_bytes#4]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#1]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |   +-argument_column_list=[KeyValue.Key#1]
        +-column_index_list=[0, 1]
==

# A TVF accepts one relation argument and forwards the input schema to the
# output schema. The relation argument selects a value table.
select *
from tvf_one_relation_arg_output_schema_is_input_schema(
    (select as value Key from KeyValue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.$col0#3 AS `$col0` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.$col0#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.$col0#3]
        +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<INT64>) -> TABLE<INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#1]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |   +-argument_column_list=[KeyValue.Key#1]
        +-column_index_list=[0]
==

# A TVF relation argument selects a value table using 'select as value'.
select * from tvf_one_relation_arg_output_schema_is_input_schema(
    (select as value new zetasql_test__.EmptyMessage()))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.$col0#2 AS `$col0` [PROTO<zetasql_test__.EmptyMessage>]
+-query=
  +-ProjectScan
    +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.$col0#2]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.$col0#2]
        +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<PROTO<zetasql_test__.EmptyMessage>>) -> TABLE<PROTO<zetasql_test__.EmptyMessage>>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.$col1#1]
        |   |   +-expr_list=
        |   |   | +-$col1#1 := MakeProto(type=PROTO<zetasql_test__.EmptyMessage>)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.$col1#1]
        +-column_index_list=[0]
==

# A TVF relation argument selects a value table using 'select as <type>'.
select int64_key_1, int64_key_2, int32_val
from tvf_one_relation_arg_output_schema_is_input_schema(
    (select as zetasql_test__.KitchenSinkPB
      null int32_VAL, null int64_key_1, null int64_key_2, null float_val))
--
QueryStmt
+-output_column_list=
| +-$query.int64_key_1#7 AS int64_key_1 [INT64]
| +-$query.int64_key_2#8 AS int64_key_2 [INT64]
| +-$query.int32_val#9 AS int32_val [INT32]
+-query=
  +-ProjectScan
    +-column_list=$query.[int64_key_1#7, int64_key_2#8, int32_val#9]
    +-expr_list=
    | +-int64_key_1#7 :=
    | | +-GetProtoField
    | |   +-type=INT64
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=tvf_one_relation_arg_output_schema_is_input_schema.$col0#6)
    | |   +-field_descriptor=int64_key_1
    | +-int64_key_2#8 :=
    | | +-GetProtoField
    | |   +-type=INT64
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=tvf_one_relation_arg_output_schema_is_input_schema.$col0#6)
    | |   +-field_descriptor=int64_key_2
    | +-int32_val#9 :=
    |   +-GetProtoField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=tvf_one_relation_arg_output_schema_is_input_schema.$col0#6)
    |     +-field_descriptor=int32_val
    |     +-default_value=77
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.$col0#6]
        +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<PROTO<zetasql_test__.KitchenSinkPB>>) -> TABLE<PROTO<zetasql_test__.KitchenSinkPB>>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$make_proto.$proto#5]
        |   |   +-expr_list=
        |   |   | +-$proto#5 :=
        |   |   |   +-MakeProto
        |   |   |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
        |   |   |     +-field_list=
        |   |   |       +-int32_val := Literal(type=INT32, value=NULL)
        |   |   |       +-int64_key_1 := ColumnRef(type=INT64, column=$subquery1.int64_key_1#2)
        |   |   |       +-int64_key_2 := ColumnRef(type=INT64, column=$subquery1.int64_key_2#3)
        |   |   |       +-float_val := Literal(type=FLOAT, value=NULL)
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=$subquery1.[int32_VAL#1, int64_key_1#2, int64_key_2#3, float_val#4]
        |   |       +-expr_list=
        |   |       | +-int32_VAL#1 := Literal(type=INT64, value=NULL)
        |   |       | +-int64_key_1#2 := Literal(type=INT64, value=NULL)
        |   |       | +-int64_key_2#3 := Literal(type=INT64, value=NULL)
        |   |       | +-float_val#4 := Literal(type=INT64, value=NULL)
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-argument_column_list=[$make_proto.$proto#5]
        +-column_index_list=[0]
==

# A TVF accepts two relation arguments and returns a value table. The TVF has an
# alias assigned to it and the enclosing query refers to this alias by name.
select mytvf, '--', mytvf.int32_val1, '--', int32_val1, '--', mytvf.*, '--', *
from tvf_two_relation_args_return_proto_value_table(
    (select 1, 2), (select 3, 4)) as mytvf
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_return_proto_value_table.$col0#5 AS mytvf [PROTO<zetasql_test__.TestExtraPB>]
| +-$query.$col2#6 AS `$col2` [STRING]
| +-$query.int32_val1#7 AS int32_val1 [INT32]
| +-$query.$col4#8 AS `$col4` [STRING]
| +-$query.int32_val1#9 AS int32_val1 [INT32]
| +-$query.$col6#10 AS `$col6` [STRING]
| +-$query.int32_val1#11 AS int32_val1 [INT32]
| +-$query.int32_val2#12 AS int32_val2 [INT32]
| +-$query.str_value#13 AS str_value [ARRAY<STRING>]
| +-$query.$col8#14 AS `$col8` [STRING]
| +-$query.int32_val1#15 AS int32_val1 [INT32]
| +-$query.int32_val2#16 AS int32_val2 [INT32]
| +-$query.str_value#17 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#5, $query.$col2#6, $query.int32_val1#7, $query.$col4#8, $query.int32_val1#9, $query.$col6#10, $query.int32_val1#11, $query.int32_val2#12, $query.str_value#13, $query.$col8#14, $query.int32_val1#15, $query.int32_val2#16, $query.str_value#17]
    +-expr_list=
    | +-$col2#6 := Literal(type=STRING, value="--")
    | +-int32_val1#7 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-$col4#8 := Literal(type=STRING, value="--")
    | +-int32_val1#9 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-$col6#10 := Literal(type=STRING, value="--")
    | +-int32_val1#11 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-int32_val2#12 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#13 :=
    | | +-GetProtoField
    | |   +-type=ARRAY<STRING>
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
    | |   +-field_descriptor=str_value
    | |   +-default_value=[]
    | +-$col8#14 := Literal(type=STRING, value="--")
    | +-int32_val1#15 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-int32_val2#16 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#17 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#5]
        +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
        +-signature=(TABLE<$col1 INT64, $col2 INT64>, TABLE<$col1 INT64, $col2 INT64>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$subquery1.[$col1#1, $col2#2]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=INT64, value=1)
        | | |   | +-$col2#2 := Literal(type=INT64, value=2)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=$subquery1.[$col1#1, $col2#2]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery2.[$col1#3, $col2#4]
        |   |   +-expr_list=
        |   |   | +-$col1#3 := Literal(type=INT64, value=3)
        |   |   | +-$col2#4 := Literal(type=INT64, value=4)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery2.[$col1#3, $col2#4]
        +-column_index_list=[0]
        +-alias="mytvf"
==

# A TVF relation argument includes a table subquery.
SELECT
  a_1
FROM
  tvf_one_relation_arg_output_schema_is_input_schema((
    SELECT
      keyvalue_2.a_1 AS a_1
    FROM
      (
        SELECT
          KeyValue.Key AS a_1
        FROM
          KeyValue
      ) AS keyvalue_2
  )) AS tvfscan_3;
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.a_1#3 AS a_1 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.a_1#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.a_1#3]
        +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<a_1 INT64>) -> TABLE<a_1 INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#1]
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[KeyValue.Key#1]
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |   +-argument_column_list=[KeyValue.Key#1]
        +-column_index_list=[0]
        +-alias="tvfscan_3"
==

# A TVF accepts two relation arguments.
select column_bytes from tvf_two_relation_args((select 1, 2), (select 3, 4))
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args.column_bytes#6 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[tvf_two_relation_args.column_bytes#6]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_two_relation_args.column_bytes#6]
        +-tvf=tvf_two_relation_args((ANY TABLE, ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<$col1 INT64, $col2 INT64>, TABLE<$col1 INT64, $col2 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$subquery1.[$col1#1, $col2#2]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=INT64, value=1)
        | | |   | +-$col2#2 := Literal(type=INT64, value=2)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=$subquery1.[$col1#1, $col2#2]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery2.[$col1#3, $col2#4]
        |   |   +-expr_list=
        |   |   | +-$col1#3 := Literal(type=INT64, value=3)
        |   |   | +-$col2#4 := Literal(type=INT64, value=4)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery2.[$col1#3, $col2#4]
        +-column_index_list=[1]
==

# A TVF accepts two relation arguments and returns an int64 value table.
select * from tvf_two_relation_args_return_int64_value_table(
    (select 1, 2), (select 3, 4))
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_return_int64_value_table.$col0#5 AS `$col0` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_two_relation_args_return_int64_value_table.$col0#5]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_two_relation_args_return_int64_value_table.$col0#5]
        +-tvf=tvf_two_relation_args_return_int64_value_table((ANY TABLE, ANY TABLE) -> TABLE<INT64>)
        +-signature=(TABLE<$col1 INT64, $col2 INT64>, TABLE<$col1 INT64, $col2 INT64>) -> TABLE<INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$subquery1.[$col1#1, $col2#2]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=INT64, value=1)
        | | |   | +-$col2#2 := Literal(type=INT64, value=2)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=$subquery1.[$col1#1, $col2#2]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery2.[$col1#3, $col2#4]
        |   |   +-expr_list=
        |   |   | +-$col1#3 := Literal(type=INT64, value=3)
        |   |   | +-$col2#4 := Literal(type=INT64, value=4)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery2.[$col1#3, $col2#4]
        +-column_index_list=[0]
==

# A TVF accepts two relation arguments and returns a proto value table.
select t
from tvf_two_relation_args_return_proto_value_table(
    (select 1, 2), (select 3, 4)) t
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_return_proto_value_table.$col0#5 AS t [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#5]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#5]
        +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
        +-signature=(TABLE<$col1 INT64, $col2 INT64>, TABLE<$col1 INT64, $col2 INT64>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$subquery1.[$col1#1, $col2#2]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=INT64, value=1)
        | | |   | +-$col2#2 := Literal(type=INT64, value=2)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=$subquery1.[$col1#1, $col2#2]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery2.[$col1#3, $col2#4]
        |   |   +-expr_list=
        |   |   | +-$col1#3 := Literal(type=INT64, value=3)
        |   |   | +-$col2#4 := Literal(type=INT64, value=4)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery2.[$col1#3, $col2#4]
        +-column_index_list=[0]
        +-alias="t"
==

# A TVF accepts two relation arguments and returns a proto value table.
select int32_val1 from tvf_two_relation_args_return_proto_value_table(
    (select 1, 2), (select 3, 4))
--
QueryStmt
+-output_column_list=
| +-$query.int32_val1#6 AS int32_val1 [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.int32_val1#6]
    +-expr_list=
    | +-int32_val1#6 :=
    |   +-GetProtoField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
    |     +-field_descriptor=int32_val1
    |     +-default_value=0
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#5]
        +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
        +-signature=(TABLE<$col1 INT64, $col2 INT64>, TABLE<$col1 INT64, $col2 INT64>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$subquery1.[$col1#1, $col2#2]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=INT64, value=1)
        | | |   | +-$col2#2 := Literal(type=INT64, value=2)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=$subquery1.[$col1#1, $col2#2]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery2.[$col1#3, $col2#4]
        |   |   +-expr_list=
        |   |   | +-$col1#3 := Literal(type=INT64, value=3)
        |   |   | +-$col2#4 := Literal(type=INT64, value=4)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery2.[$col1#3, $col2#4]
        +-column_index_list=[0]
==

# This TVF accepts two input relation arguments and forwards the schema of the
# first relation to the TVF output schema.
select * from tvf_two_relation_args_output_schema_is_input_schema(
    (select 1, 2), (select 3, 4))
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_output_schema_is_input_schema.$col1#5 AS `$col1` [INT64]
| +-tvf_two_relation_args_output_schema_is_input_schema.$col2#6 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=tvf_two_relation_args_output_schema_is_input_schema.[$col1#5, $col2#6]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_two_relation_args_output_schema_is_input_schema.[$col1#5, $col2#6]
        +-tvf=tvf_two_relation_args_output_schema_is_input_schema((ANY TABLE, ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<$col1 INT64, $col2 INT64>, TABLE<$col1 INT64, $col2 INT64>) -> TABLE<$col1 INT64, $col2 INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$subquery1.[$col1#1, $col2#2]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=INT64, value=1)
        | | |   | +-$col2#2 := Literal(type=INT64, value=2)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=$subquery1.[$col1#1, $col2#2]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery2.[$col1#3, $col2#4]
        |   |   +-expr_list=
        |   |   | +-$col1#3 := Literal(type=INT64, value=3)
        |   |   | +-$col2#4 := Literal(type=INT64, value=4)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery2.[$col1#3, $col2#4]
        +-column_index_list=[0, 1]
==

# This TVF accepts two input relation arguments with the second one optional and
# forwards the schema of the first relation to the TVF output schema.
# The input only contains the first required relation argument.
select *
from tvf_two_relation_args_second_optional_output_schema_is_input_schema((
  select 1, 2))
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_second_optional_output_schema_is_input_schema.$col1#3 AS `$col1` [INT64]
| +-tvf_two_relation_args_second_optional_output_schema_is_input_schema.$col2#4 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=tvf_two_relation_args_second_optional_output_schema_is_input_schema.[$col1#3, $col2#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_two_relation_args_second_optional_output_schema_is_input_schema.[$col1#3, $col2#4]
        +-tvf=tvf_two_relation_args_second_optional_output_schema_is_input_schema((ANY TABLE, optional ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<$col1 INT64, $col2 INT64>) -> TABLE<$col1 INT64, $col2 INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[$col1#1, $col2#2]
        |   |   +-expr_list=
        |   |   | +-$col1#1 := Literal(type=INT64, value=1)
        |   |   | +-$col2#2 := Literal(type=INT64, value=2)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[$col1#1, $col2#2]
        +-column_index_list=[0, 1]
==

# This TVF accepts two input relation arguments with the second one optional and
# forwards the schema of the first relation to the TVF output schema.
# The input contains two relation arguments.
select *
from tvf_two_relation_args_second_optional_output_schema_is_input_schema((
  select 1, 2), (select 2, 3))
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_second_optional_output_schema_is_input_schema.$col1#5 AS `$col1` [INT64]
| +-tvf_two_relation_args_second_optional_output_schema_is_input_schema.$col2#6 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=tvf_two_relation_args_second_optional_output_schema_is_input_schema.[$col1#5, $col2#6]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_two_relation_args_second_optional_output_schema_is_input_schema.[$col1#5, $col2#6]
        +-tvf=tvf_two_relation_args_second_optional_output_schema_is_input_schema((ANY TABLE, optional ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<$col1 INT64, $col2 INT64>, TABLE<$col1 INT64, $col2 INT64>) -> TABLE<$col1 INT64, $col2 INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$subquery1.[$col1#1, $col2#2]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=INT64, value=1)
        | | |   | +-$col2#2 := Literal(type=INT64, value=2)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=$subquery1.[$col1#1, $col2#2]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery2.[$col1#3, $col2#4]
        |   |   +-expr_list=
        |   |   | +-$col1#3 := Literal(type=INT64, value=2)
        |   |   | +-$col2#4 := Literal(type=INT64, value=3)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery2.[$col1#3, $col2#4]
        +-column_index_list=[0, 1]
==

# This TVF accepts three inputs (model, relation and struct) to mock
# ML.EVALUATE.
# Java error:
# Model not found: onedoublemodel [at 2:9]
#   model onedoublemodel, (select 1, 2), struct("e" as string, 123 as int64))
#         ^
[no_java]
select * from tvf_model_evaluation_args(
  model onedoublemodel, (select 1, 2), struct("e" as string, 123 as int64))
--
QueryStmt
+-output_column_list=
| +-tvf_model_evaluation_args.column_bool#3 AS column_bool [BOOL]
| +-tvf_model_evaluation_args.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_model_evaluation_args.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_model_evaluation_args.[column_bool#3, column_bytes#4]
        +-tvf=tvf_model_evaluation_args((ANY MODEL, optional ANY TABLE, optional <struct>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(ANY MODEL, TABLE<$col1 INT64, $col2 INT64>, STRUCT<string STRING, int64 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-model=
        | |   +-Model(model=OneDoubleModel)
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$subquery1.[$col1#1, $col2#2]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=INT64, value=1)
        | | |   | +-$col2#2 := Literal(type=INT64, value=2)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=$subquery1.[$col1#1, $col2#2]
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRUCT<string STRING, int64 INT64>, value={string:"e", int64:123})
        +-column_index_list=[0, 1]
==

# This TVF accepts only one argument to mock ML.EVALUATE with only model name.
# Java error:
# Model not found: onedoublemodel [at 1:47]
# select * from tvf_model_evaluation_args(model onedoublemodel)
#                                               ^
[no_java]
select * from tvf_model_evaluation_args(model onedoublemodel)
--
QueryStmt
+-output_column_list=
| +-tvf_model_evaluation_args.column_bool#1 AS column_bool [BOOL]
| +-tvf_model_evaluation_args.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_model_evaluation_args.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_model_evaluation_args.[column_bool#1, column_bytes#2]
        +-tvf=tvf_model_evaluation_args((ANY MODEL, optional ANY TABLE, optional <struct>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(ANY MODEL) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-model=
        |     +-Model(model=OneDoubleModel)
        +-column_index_list=[0, 1]
==

# This TVF accepts two arguments with the second one as 'TABLE foo' clause.
# The second argument should be translated as a relation.
# Java error:
# Model not found: onedoublemodel [at 1:47]
# select * from tvf_model_evaluation_args(model onedoublemodel, table KeyValue)
#                                               ^
[no_java]
select * from tvf_model_evaluation_args(model onedoublemodel, table KeyValue)
--
QueryStmt
+-output_column_list=
| +-tvf_model_evaluation_args.column_bool#3 AS column_bool [BOOL]
| +-tvf_model_evaluation_args.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_model_evaluation_args.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_model_evaluation_args.[column_bool#3, column_bytes#4]
        +-tvf=tvf_model_evaluation_args((ANY MODEL, optional ANY TABLE, optional <struct>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(ANY MODEL, TABLE<Key INT64, Value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-model=
        | |   +-Model(model=OneDoubleModel)
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=KeyValue.[Key#1, Value#2]
        +-column_index_list=[0, 1]
==

# This TVF accepts two arguments with the second one as scalar subquery returns
# struct. The second argument should be translated as a relation.
# Java error:
# Model not found: onedoublemodel [at 1:47]
# select * from tvf_model_evaluation_args(model onedoublemodel,
#                                               ^
[no_java]
select * from tvf_model_evaluation_args(model onedoublemodel,
  (select struct("e" as string, 123 as int64)))
--
QueryStmt
+-output_column_list=
| +-tvf_model_evaluation_args.column_bool#2 AS column_bool [BOOL]
| +-tvf_model_evaluation_args.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_model_evaluation_args.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_model_evaluation_args.[column_bool#2, column_bytes#3]
        +-tvf=tvf_model_evaluation_args((ANY MODEL, optional ANY TABLE, optional <struct>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(ANY MODEL, TABLE<$col1 STRUCT<string STRING, int64 INT64>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-model=
        | |   +-Model(model=OneDoubleModel)
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.$col1#1]
        |   |   +-expr_list=
        |   |   | +-$col1#1 := Literal(type=STRUCT<string STRING, int64 INT64>, value={string:"e", int64:123})
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.$col1#1]
        +-column_index_list=[0, 1]
==

# Chain together two TVFs. The innermost TVF returns a fixed proto value table
# and the outer TVF forwards this value table to the final output schema. The
# outer TVF has an alias and the final query uses this alias to select a column
# from the value table.
select outertvf.int32_val1, '--', int32_val1
from tvf_one_relation_arg_output_schema_is_input_schema(
      (select innertvf.* from tvf_two_relation_args_return_proto_value_table(
          (select 1, 2), (select 3, 4)) innertvf)) outertvf
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.int32_val1#9 AS int32_val1 [INT32]
| +-$query.$col2#12 AS `$col2` [STRING]
| +-tvf_one_relation_arg_output_schema_is_input_schema.int32_val1#9 AS int32_val1 [INT32]
+-query=
  +-ProjectScan
    +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.int32_val1#9, $query.$col2#12, tvf_one_relation_arg_output_schema_is_input_schema.int32_val1#9]
    +-expr_list=
    | +-$col2#12 := Literal(type=STRING, value="--")
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.int32_val1#9]
        +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<int32_val1 INT32, int32_val2 INT32, str_value ARRAY<STRING>>) -> TABLE<int32_val1 INT32, int32_val2 INT32, str_value ARRAY<STRING>>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[int32_val1#6, int32_val2#7, str_value#8]
        |   |   +-expr_list=
        |   |   | +-int32_val1#6 :=
        |   |   | | +-GetProtoField
        |   |   | |   +-type=INT32
        |   |   | |   +-expr=
        |   |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
        |   |   | |   +-field_descriptor=int32_val1
        |   |   | |   +-default_value=0
        |   |   | +-int32_val2#7 :=
        |   |   | | +-GetProtoField
        |   |   | |   +-type=INT32
        |   |   | |   +-expr=
        |   |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
        |   |   | |   +-field_descriptor=int32_val2
        |   |   | |   +-default_value=0
        |   |   | +-str_value#8 :=
        |   |   |   +-GetProtoField
        |   |   |     +-type=ARRAY<STRING>
        |   |   |     +-expr=
        |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
        |   |   |     +-field_descriptor=str_value
        |   |   |     +-default_value=[]
        |   |   +-input_scan=
        |   |     +-TVFScan
        |   |       +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#5]
        |   |       +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
        |   |       +-signature=(TABLE<$col1 INT64, $col2 INT64>, TABLE<$col1 INT64, $col2 INT64>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
        |   |       +-argument_list=
        |   |       | +-FunctionArgument
        |   |       | | +-scan=
        |   |       | | | +-ProjectScan
        |   |       | | |   +-column_list=$subquery2.[$col1#1, $col2#2]
        |   |       | | |   +-expr_list=
        |   |       | | |   | +-$col1#1 := Literal(type=INT64, value=1)
        |   |       | | |   | +-$col2#2 := Literal(type=INT64, value=2)
        |   |       | | |   +-input_scan=
        |   |       | | |     +-SingleRowScan
        |   |       | | +-argument_column_list=$subquery2.[$col1#1, $col2#2]
        |   |       | +-FunctionArgument
        |   |       |   +-scan=
        |   |       |   | +-ProjectScan
        |   |       |   |   +-column_list=$subquery3.[$col1#3, $col2#4]
        |   |       |   |   +-expr_list=
        |   |       |   |   | +-$col1#3 := Literal(type=INT64, value=3)
        |   |       |   |   | +-$col2#4 := Literal(type=INT64, value=4)
        |   |       |   |   +-input_scan=
        |   |       |   |     +-SingleRowScan
        |   |       |   +-argument_column_list=$subquery3.[$col1#3, $col2#4]
        |   |       +-column_index_list=[0]
        |   |       +-alias="innertvf"
        |   +-argument_column_list=$subquery1.[int32_val1#6, int32_val2#7, str_value#8]
        +-column_index_list=[0]
        +-alias="outertvf"
==

# Chain together two TVFs. The innermost TVF returns a fixed proto value table
# and the outer TVF forwards this value table to the final output schema. The
# outer TVF has *no* alias and the final query selects a column from the value
# table.
select int32_val1
from tvf_one_relation_arg_output_schema_is_input_schema(
      (select * from tvf_two_relation_args_return_proto_value_table(
          (select 1, 2), (select 3, 4))))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.int32_val1#9 AS int32_val1 [INT32]
+-query=
  +-ProjectScan
    +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.int32_val1#9]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.int32_val1#9]
        +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<int32_val1 INT32, int32_val2 INT32, str_value ARRAY<STRING>>) -> TABLE<int32_val1 INT32, int32_val2 INT32, str_value ARRAY<STRING>>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[int32_val1#6, int32_val2#7, str_value#8]
        |   |   +-expr_list=
        |   |   | +-int32_val1#6 :=
        |   |   | | +-GetProtoField
        |   |   | |   +-type=INT32
        |   |   | |   +-expr=
        |   |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
        |   |   | |   +-field_descriptor=int32_val1
        |   |   | |   +-default_value=0
        |   |   | +-int32_val2#7 :=
        |   |   | | +-GetProtoField
        |   |   | |   +-type=INT32
        |   |   | |   +-expr=
        |   |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
        |   |   | |   +-field_descriptor=int32_val2
        |   |   | |   +-default_value=0
        |   |   | +-str_value#8 :=
        |   |   |   +-GetProtoField
        |   |   |     +-type=ARRAY<STRING>
        |   |   |     +-expr=
        |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#5)
        |   |   |     +-field_descriptor=str_value
        |   |   |     +-default_value=[]
        |   |   +-input_scan=
        |   |     +-TVFScan
        |   |       +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#5]
        |   |       +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
        |   |       +-signature=(TABLE<$col1 INT64, $col2 INT64>, TABLE<$col1 INT64, $col2 INT64>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
        |   |       +-argument_list=
        |   |       | +-FunctionArgument
        |   |       | | +-scan=
        |   |       | | | +-ProjectScan
        |   |       | | |   +-column_list=$subquery2.[$col1#1, $col2#2]
        |   |       | | |   +-expr_list=
        |   |       | | |   | +-$col1#1 := Literal(type=INT64, value=1)
        |   |       | | |   | +-$col2#2 := Literal(type=INT64, value=2)
        |   |       | | |   +-input_scan=
        |   |       | | |     +-SingleRowScan
        |   |       | | +-argument_column_list=$subquery2.[$col1#1, $col2#2]
        |   |       | +-FunctionArgument
        |   |       |   +-scan=
        |   |       |   | +-ProjectScan
        |   |       |   |   +-column_list=$subquery3.[$col1#3, $col2#4]
        |   |       |   |   +-expr_list=
        |   |       |   |   | +-$col1#3 := Literal(type=INT64, value=3)
        |   |       |   |   | +-$col2#4 := Literal(type=INT64, value=4)
        |   |       |   |   +-input_scan=
        |   |       |   |     +-SingleRowScan
        |   |       |   +-argument_column_list=$subquery3.[$col1#3, $col2#4]
        |   |       +-column_index_list=[0]
        |   +-argument_column_list=$subquery1.[int32_val1#6, int32_val2#7, str_value#8]
        +-column_index_list=[0]
==

# There is a join between two TVF calls.
select *
from tvf_one_relation_arg_output_schema_is_input_schema(
    (select as value x from unnest([1, 2, 3]) x)) tvf_left
join tvf_one_relation_arg_output_schema_is_input_schema(
    (select as value x from unnest([1, 3, 4]) x)) tvf_right
on (tvf_left = tvf_right)
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.$col0#2 AS tvf_left [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema.$col0#4 AS tvf_right [INT64]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[$col0#2, $col0#4]
    +-input_scan=
      +-JoinScan
        +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[$col0#2, $col0#4]
        +-left_scan=
        | +-TVFScan
        |   +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.$col0#2]
        |   +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
        |   +-signature=(TABLE<INT64>) -> TABLE<INT64>
        |   +-argument_list=
        |   | +-FunctionArgument
        |   |   +-scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$array.x#1]
        |   |   |   +-input_scan=
        |   |   |     +-ArrayScan
        |   |   |       +-column_list=[$array.x#1]
        |   |   |       +-array_expr=
        |   |   |       | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
        |   |   |       +-element_column=$array.x#1
        |   |   +-argument_column_list=[$array.x#1]
        |   +-column_index_list=[0]
        |   +-alias="tvf_left"
        +-right_scan=
        | +-TVFScan
        |   +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.$col0#4]
        |   +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
        |   +-signature=(TABLE<INT64>) -> TABLE<INT64>
        |   +-argument_list=
        |   | +-FunctionArgument
        |   |   +-scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$array.x#3]
        |   |   |   +-input_scan=
        |   |   |     +-ArrayScan
        |   |   |       +-column_list=[$array.x#3]
        |   |   |       +-array_expr=
        |   |   |       | +-Literal(type=ARRAY<INT64>, value=[1, 3, 4])
        |   |   |       +-element_column=$array.x#3
        |   |   +-argument_column_list=[$array.x#3]
        |   +-column_index_list=[0]
        |   +-alias="tvf_right"
        +-join_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=tvf_one_relation_arg_output_schema_is_input_schema.$col0#2)
            +-ColumnRef(type=INT64, column=tvf_one_relation_arg_output_schema_is_input_schema.$col0#4)
==

# The query calls a TVF that has one relation argument with a required schema
# of one int64 column and one string column.
select column_bool, column_bytes
from tvf_one_relation_arg_int64_string_input_columns(
    (select key + 1 as int64, value as string from keyvalue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#4 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#4, column_bytes#5]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#4, column_bytes#5]
        +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.int64#3, KeyValue.Value#2]
        |   |   +-expr_list=
        |   |   | +-int64#3 :=
        |   |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |   |     +-Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=[$subquery1.int64#3, KeyValue.Value#2]
        +-column_index_list=[0, 1]
==

# The query calls a TVF that has one relation argument with a required schema
# of one int64 column and one string column, and the provided columns are in a
# different order than the names of the columns listed in the required signature
# but the names match, so it is okay.
select column_bool, column_bytes
from tvf_one_relation_arg_int64_string_input_columns(
    (select value as string, key + 1 as int64 from keyvalue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#4 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#4, column_bytes#5]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#4, column_bytes#5]
        +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.int64#3, KeyValue.Value#2]
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[KeyValue.Value#2, $subquery1.int64#3]
        |   |       +-expr_list=
        |   |       | +-int64#3 :=
        |   |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |       |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |       |     +-Literal(type=INT64, value=1)
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=[$subquery1.int64#3, KeyValue.Value#2]
        +-column_index_list=[0, 1]
==

# The TVF required schema includes columns 'int64 INT64' and 'string STRING'.
# The query calls them in a different order and type coercion is required.
select column_bool, column_bytes
from tvf_one_relation_arg_int64_string_input_columns(
    (select value as string, cast(key + 1 as int32) as int64 from keyvalue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#5 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#6 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#5, column_bytes#6]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#5, column_bytes#6]
        +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery2.int64#4, KeyValue.Value#2]
        |   |   +-expr_list=
        |   |   | +-int64#4 :=
        |   |   |   +-Cast(INT32 -> INT64)
        |   |   |     +-ColumnRef(type=INT32, column=$subquery1.int64#3)
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[KeyValue.Value#2, $subquery1.int64#3]
        |   |       +-expr_list=
        |   |       | +-int64#3 :=
        |   |       |   +-Cast(INT64 -> INT32)
        |   |       |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |       |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |       |       +-Literal(type=INT64, value=1)
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=[$subquery2.int64#4, KeyValue.Value#2]
        +-column_index_list=[0, 1]
==

# The query calls a TVF that has one relation argument with a required schema
# of one int64 column and one string column, and the provided columns contain
# one extra column that is not specified in the signature, but that is okay.
select column_bool, column_bytes
from tvf_one_relation_arg_int64_string_input_columns(
    (select value as string, key + 1 as int64, 42 as extra_col from keyvalue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#5 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#6 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#5, column_bytes#6]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#5, column_bytes#6]
        +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.int64#3, KeyValue.Value#2]
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[KeyValue.Value#2, $subquery1.int64#3, $subquery1.extra_col#4]
        |   |       +-expr_list=
        |   |       | +-int64#3 :=
        |   |       | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |       | |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |       | |   +-Literal(type=INT64, value=1)
        |   |       | +-extra_col#4 := Literal(type=INT64, value=42)
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=[$subquery1.int64#3, KeyValue.Value#2]
        +-column_index_list=[0, 1]
==

# The query calls a TVF that has one relation argument with a required schema
# of one int64 column and one string column, and the provided columns contain
# one extra column that is not specified in the signature, and the extra column
# is in the middle of the select list for the relation argument.
select column_bool, column_bytes
from tvf_one_relation_arg_int64_string_input_columns(
    (select value as string, 42 as extra_col, key + 1 as int64 from keyvalue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#5 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#6 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#5, column_bytes#6]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#5, column_bytes#6]
        +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.int64#4, KeyValue.Value#2]
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[KeyValue.Value#2, $subquery1.extra_col#3, $subquery1.int64#4]
        |   |       +-expr_list=
        |   |       | +-extra_col#3 := Literal(type=INT64, value=42)
        |   |       | +-int64#4 :=
        |   |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |       |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |       |     +-Literal(type=INT64, value=1)
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=[$subquery1.int64#4, KeyValue.Value#2]
        +-column_index_list=[0, 1]
==

# The TVF required schema includes columns 'int64 INT64' and 'string STRING'.
# The query adds an extra input column and type coercion is required.
select column_bool, column_bytes
from tvf_one_relation_arg_int64_string_input_columns(
    (select value as string,
            cast(key + 1 as int32) as int64,
            42 as extra_col
     from keyvalue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#6 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#7 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#6, column_bytes#7]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#6, column_bytes#7]
        +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery2.int64#5, KeyValue.Value#2]
        |   |   +-expr_list=
        |   |   | +-int64#5 :=
        |   |   |   +-Cast(INT32 -> INT64)
        |   |   |     +-ColumnRef(type=INT32, column=$subquery1.int64#3)
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[KeyValue.Value#2, $subquery1.int64#3, $subquery1.extra_col#4]
        |   |       +-expr_list=
        |   |       | +-int64#3 :=
        |   |       | | +-Cast(INT64 -> INT32)
        |   |       | |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |       | |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |       | |     +-Literal(type=INT64, value=1)
        |   |       | +-extra_col#4 := Literal(type=INT64, value=42)
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=[$subquery2.int64#5, KeyValue.Value#2]
        +-column_index_list=[0, 1]
==

# The TVF required schema includes columns 'int64 INT64' and 'string STRING'.
# The query adds an extra input column and type coercion is required, and the
# extra column is in the middle of the select list for the relation argument.
select column_bool, column_bytes
from tvf_one_relation_arg_int64_string_input_columns(
    (select value as string,
            42 as extra_col,
            cast(key + 1 as int32) as int64
     from keyvalue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#6 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#7 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#6, column_bytes#7]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#6, column_bytes#7]
        +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery2.int64#5, KeyValue.Value#2]
        |   |   +-expr_list=
        |   |   | +-int64#5 :=
        |   |   |   +-Cast(INT32 -> INT64)
        |   |   |     +-ColumnRef(type=INT32, column=$subquery1.int64#4)
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[KeyValue.Value#2, $subquery1.extra_col#3, $subquery1.int64#4]
        |   |       +-expr_list=
        |   |       | +-extra_col#3 := Literal(type=INT64, value=42)
        |   |       | +-int64#4 :=
        |   |       |   +-Cast(INT64 -> INT32)
        |   |       |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |       |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |       |       +-Literal(type=INT64, value=1)
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=[$subquery2.int64#5, KeyValue.Value#2]
        +-column_index_list=[0, 1]
==

# The query calls a TVF that has one relation argument with a required schema of
# one int64 column and one string column. The provided schema has columns with
# the required names, but the query assigns new aliases to control which columns
# are passed into the TVF.
select column_bool, column_bytes
from tvf_one_relation_arg_int64_string_input_columns(
    (select string, string as int32, int32 as int64 from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#20 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#21 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#20, column_bytes#21]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#20, column_bytes#21]
        +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery2.int64#19, SimpleTypes.string#5]
        |   |   +-expr_list=
        |   |   | +-int64#19 :=
        |   |   |   +-Cast(INT32 -> INT64)
        |   |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=SimpleTypes.[string#5, string#5, int32#1]
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=SimpleTypes.[int32#1, string#5], table=SimpleTypes, column_index_list=[0, 4])
        |   +-argument_column_list=[$subquery2.int64#19, SimpleTypes.string#5]
        +-column_index_list=[0, 1]
==

# The query calls a TVF with three INT64-typed columns, and passes the same
# input column with different aliases for them all.
select column_bytes, column_bool
from tvf_one_relation_arg_three_int64_input_columns(
  (select int64 as int64a,
          int64 as int64b,
          int64 as int64c
   from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_three_int64_input_columns.column_bytes#20 AS column_bytes [BYTES]
| +-tvf_one_relation_arg_three_int64_input_columns.column_bool#19 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_three_int64_input_columns.[column_bytes#20, column_bool#19]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_three_int64_input_columns.[column_bool#19, column_bytes#20]
        +-tvf=tvf_one_relation_arg_three_int64_input_columns((TABLE<int64a INT64, int64b INT64, int64c INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64a INT64, int64b INT64, int64c INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=SimpleTypes.[int64#2, int64#2, int64#2]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        |   +-argument_column_list=SimpleTypes.[int64#2, int64#2, int64#2]
        +-column_index_list=[0, 1]
==

# The query calls a TVF with three INT64-typed columns, and passes the same
# input column with different aliases for them all, in a different order than
# the column names in the requested schema.
select column_bytes, column_bool
from tvf_one_relation_arg_three_int64_input_columns(
  (select int64 as int64c,
          int64 as int64b,
          int64 as int64a
   from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_three_int64_input_columns.column_bytes#20 AS column_bytes [BYTES]
| +-tvf_one_relation_arg_three_int64_input_columns.column_bool#19 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_three_int64_input_columns.[column_bytes#20, column_bool#19]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_three_int64_input_columns.[column_bool#19, column_bytes#20]
        +-tvf=tvf_one_relation_arg_three_int64_input_columns((TABLE<int64a INT64, int64b INT64, int64c INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64a INT64, int64b INT64, int64c INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=SimpleTypes.[int64#2, int64#2, int64#2]
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=SimpleTypes.[int64#2, int64#2, int64#2]
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        |   +-argument_column_list=SimpleTypes.[int64#2, int64#2, int64#2]
        +-column_index_list=[0, 1]
==

# The query calls a TVF with three INT64-typed columns, and passes the same
# input column with different aliases for them all, and type coercion is needed.
select column_bytes, column_bool
from tvf_one_relation_arg_three_int64_input_columns(
  (select int32 as int64a,
          int32 as int64b,
          int32 as int64c
   from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_three_int64_input_columns.column_bytes#23 AS column_bytes [BYTES]
| +-tvf_one_relation_arg_three_int64_input_columns.column_bool#22 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_three_int64_input_columns.[column_bytes#23, column_bool#22]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_three_int64_input_columns.[column_bool#22, column_bytes#23]
        +-tvf=tvf_one_relation_arg_three_int64_input_columns((TABLE<int64a INT64, int64b INT64, int64c INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64a INT64, int64b INT64, int64c INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery2.[int64a#19, int64b#20, int64c#21]
        |   |   +-expr_list=
        |   |   | +-int64a#19 :=
        |   |   | | +-Cast(INT32 -> INT64)
        |   |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
        |   |   | +-int64b#20 :=
        |   |   | | +-Cast(INT32 -> INT64)
        |   |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
        |   |   | +-int64c#21 :=
        |   |   |   +-Cast(INT32 -> INT64)
        |   |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=SimpleTypes.[int32#1, int32#1, int32#1]
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
        |   +-argument_column_list=$subquery2.[int64a#19, int64b#20, int64c#21]
        +-column_index_list=[0, 1]
==

# The query calls a TVF with three INT64-typed columns, and passes the same
# input column with different aliases for them all, and an extra column is
# dropped.
select column_bytes, column_bool
from tvf_one_relation_arg_three_int64_input_columns(
  (select int64 as int64a,
          int64 as int64b,
          int64 as int64c,
          42 as extra_col
   from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_three_int64_input_columns.column_bytes#21 AS column_bytes [BYTES]
| +-tvf_one_relation_arg_three_int64_input_columns.column_bool#20 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_three_int64_input_columns.[column_bytes#21, column_bool#20]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_three_int64_input_columns.[column_bool#20, column_bytes#21]
        +-tvf=tvf_one_relation_arg_three_int64_input_columns((TABLE<int64a INT64, int64b INT64, int64c INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64a INT64, int64b INT64, int64c INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=SimpleTypes.[int64#2, int64#2, int64#2]
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[SimpleTypes.int64#2, SimpleTypes.int64#2, SimpleTypes.int64#2, $subquery1.extra_col#19]
        |   |       +-expr_list=
        |   |       | +-extra_col#19 := Literal(type=INT64, value=42)
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        |   +-argument_column_list=SimpleTypes.[int64#2, int64#2, int64#2]
        +-column_index_list=[0, 1]
==

# The query calls a TVF with three INT64-typed columns, and passes the same
# input column with different aliases for them all, and an extra column from the
# middle of the SELECT list for the relation argument is dropped.
select column_bytes, column_bool
from tvf_one_relation_arg_three_int64_input_columns(
  (select int64 as int64a,
          42 as extra_col,
          int64 as int64b,
          int64 as int64c
   from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_three_int64_input_columns.column_bytes#21 AS column_bytes [BYTES]
| +-tvf_one_relation_arg_three_int64_input_columns.column_bool#20 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_three_int64_input_columns.[column_bytes#21, column_bool#20]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_three_int64_input_columns.[column_bool#20, column_bytes#21]
        +-tvf=tvf_one_relation_arg_three_int64_input_columns((TABLE<int64a INT64, int64b INT64, int64c INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64a INT64, int64b INT64, int64c INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=SimpleTypes.[int64#2, int64#2, int64#2]
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[SimpleTypes.int64#2, $subquery1.extra_col#19, SimpleTypes.int64#2, SimpleTypes.int64#2]
        |   |       +-expr_list=
        |   |       | +-extra_col#19 := Literal(type=INT64, value=42)
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        |   +-argument_column_list=SimpleTypes.[int64#2, int64#2, int64#2]
        +-column_index_list=[0, 1]
==

# The query calls a TVF with a relation argument with a required schema of many
# column types.
select column_bool, column_bytes
from tvf_one_relation_arg_required_input_schema_many_types(
    (select true as bool, bytes, `date`, double, float, int32, int64,
            'abc' as string, timestamp as time, uint32,
            uint64 from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_required_input_schema_many_types.column_bool#21 AS column_bool [BOOL]
| +-tvf_one_relation_arg_required_input_schema_many_types.column_bytes#22 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_required_input_schema_many_types.[column_bool#21, column_bytes#22]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_required_input_schema_many_types.[column_bool#21, column_bytes#22]
        +-tvf=tvf_one_relation_arg_required_input_schema_many_types((TABLE<bool BOOL, bytes BYTES, date DATE, double DOUBLE, float FLOAT, int32 INT32, int64 INT64, string STRING, time TIMESTAMP, uint32 UINT32, uint64 UINT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<bool BOOL, bytes BYTES, date DATE, double DOUBLE, float FLOAT, int32 INT32, int64 INT64, string STRING, time TIMESTAMP, uint32 UINT32, uint64 UINT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.bool#19, SimpleTypes.bytes#6, SimpleTypes.date#10, SimpleTypes.double#9, SimpleTypes.float#8, SimpleTypes.int32#1, SimpleTypes.int64#2, $subquery1.string#20, SimpleTypes.timestamp#15, SimpleTypes.uint32#3, SimpleTypes.uint64#4]
        |   |   +-expr_list=
        |   |   | +-bool#19 := Literal(type=BOOL, value=true)
        |   |   | +-string#20 := Literal(type=STRING, value="abc")
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, bytes#6, float#8, double#9, date#10, timestamp#15], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 5, 7, 8, 9, 14])
        |   +-argument_column_list=[$subquery1.bool#19, SimpleTypes.bytes#6, SimpleTypes.date#10, SimpleTypes.double#9, SimpleTypes.float#8, SimpleTypes.int32#1, SimpleTypes.int64#2, $subquery1.string#20, SimpleTypes.timestamp#15, SimpleTypes.uint32#3, SimpleTypes.uint64#4]
        +-column_index_list=[0, 1]
==

# The query calls a TVF that has one relation argument with a required schema
# of one int64 column and one string column. The input relation first column is
# of type int32, but this is coercible to int64 and so ZetaSQL successfully
# resolves the query.
select column_bool, column_bytes
from tvf_one_relation_arg_int64_string_input_columns(
    (select int32 as int64, string from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#20 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#21 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#20, column_bytes#21]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#20, column_bytes#21]
        +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery2.int64#19, SimpleTypes.string#5]
        |   |   +-expr_list=
        |   |   | +-int64#19 :=
        |   |   |   +-Cast(INT32 -> INT64)
        |   |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=SimpleTypes.[int32#1, string#5]
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=SimpleTypes.[int32#1, string#5], table=SimpleTypes, column_index_list=[0, 4])
        |   +-argument_column_list=[$subquery2.int64#19, SimpleTypes.string#5]
        +-column_index_list=[0, 1]
==

# The query calls a TVF that has one relation argument with a required schema
# of one int64 column and one string column. The input relation first column is
# of type uint32, but this coerces correctly.
select column_bool, column_bytes
from tvf_one_relation_arg_int64_string_input_columns(
    (select uint32 as int64, string from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#20 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#21 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#20, column_bytes#21]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#20, column_bytes#21]
        +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery2.int64#19, SimpleTypes.string#5]
        |   |   +-expr_list=
        |   |   | +-int64#19 :=
        |   |   |   +-Cast(UINT32 -> INT64)
        |   |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=SimpleTypes.[uint32#3, string#5]
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=SimpleTypes.[uint32#3, string#5], table=SimpleTypes, column_index_list=[2, 4])
        |   +-argument_column_list=[$subquery2.int64#19, SimpleTypes.string#5]
        +-column_index_list=[0, 1]
==

# The query calls a TVF that has two relation arguments with required schemas.
# Coercion is necessary for one of the relations but not the other.
select column_bool, column_bytes
from tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select uint32 as uint64, string from simpletypes),
    (select `date`, string from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bool#38 AS column_bool [BOOL]
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bytes#39 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#38, column_bytes#39]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#38, column_bytes#39]
        +-tvf=tvf_two_relation_args_uint64_string_and_date_string_input_columns((TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery3.uint64#37, SimpleTypes.string#5]
        | | |   +-expr_list=
        | | |   | +-uint64#37 :=
        | | |   |   +-Cast(UINT32 -> UINT64)
        | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
        | | |   +-input_scan=
        | | |     +-ProjectScan
        | | |       +-column_list=SimpleTypes.[uint32#3, string#5]
        | | |       +-input_scan=
        | | |         +-TableScan(column_list=SimpleTypes.[uint32#3, string#5], table=SimpleTypes, column_index_list=[2, 4])
        | | +-argument_column_list=[$subquery3.uint64#37, SimpleTypes.string#5]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=SimpleTypes.[date#28, string#23]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypes.[string#23, date#28], table=SimpleTypes, column_index_list=[4, 9])
        |   +-argument_column_list=SimpleTypes.[date#28, string#23]
        +-column_index_list=[0, 1]
==

# The query calls a TVF that has two relation arguments with required schemas.
# Column rearrangement is necessary for one of the relations but not the other.
select column_bool, column_bytes
from tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select string, uint64 from simpletypes),
    (select `date`, string from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bool#37 AS column_bool [BOOL]
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bytes#38 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#37, column_bytes#38]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#37, column_bytes#38]
        +-tvf=tvf_two_relation_args_uint64_string_and_date_string_input_columns((TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=SimpleTypes.[uint64#4, string#5]
        | | |   +-input_scan=
        | | |     +-ProjectScan
        | | |       +-column_list=SimpleTypes.[string#5, uint64#4]
        | | |       +-input_scan=
        | | |         +-TableScan(column_list=SimpleTypes.[uint64#4, string#5], table=SimpleTypes, column_index_list=[3, 4])
        | | +-argument_column_list=SimpleTypes.[uint64#4, string#5]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=SimpleTypes.[date#28, string#23]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypes.[string#23, date#28], table=SimpleTypes, column_index_list=[4, 9])
        |   +-argument_column_list=SimpleTypes.[date#28, string#23]
        +-column_index_list=[0, 1]
==

# The query calls a TVF that has two relation arguments with required schemas.
# Column rearrangement and type coercion are necessary for one of the relations
# but not the other.
select column_bool, column_bytes
from tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select string, uint32 as uint64 from simpletypes),
    (select `date`, string from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bool#38 AS column_bool [BOOL]
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bytes#39 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#38, column_bytes#39]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#38, column_bytes#39]
        +-tvf=tvf_two_relation_args_uint64_string_and_date_string_input_columns((TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery3.uint64#37, SimpleTypes.string#5]
        | | |   +-expr_list=
        | | |   | +-uint64#37 :=
        | | |   |   +-Cast(UINT32 -> UINT64)
        | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
        | | |   +-input_scan=
        | | |     +-ProjectScan
        | | |       +-column_list=SimpleTypes.[string#5, uint32#3]
        | | |       +-input_scan=
        | | |         +-TableScan(column_list=SimpleTypes.[uint32#3, string#5], table=SimpleTypes, column_index_list=[2, 4])
        | | +-argument_column_list=[$subquery3.uint64#37, SimpleTypes.string#5]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=SimpleTypes.[date#28, string#23]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypes.[string#23, date#28], table=SimpleTypes, column_index_list=[4, 9])
        |   +-argument_column_list=SimpleTypes.[date#28, string#23]
        +-column_index_list=[0, 1]
==

# The query calls a TVF that has two relation arguments with required schemas.
# Extra-column-dropping is necessary for one of the relations but not the other.
select column_bool, column_bytes
from tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select uint64, string, 42 as extra_col from simpletypes),
    (select `date`, string from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bool#38 AS column_bool [BOOL]
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bytes#39 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#38, column_bytes#39]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#38, column_bytes#39]
        +-tvf=tvf_two_relation_args_uint64_string_and_date_string_input_columns((TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=SimpleTypes.[uint64#4, string#5]
        | | |   +-input_scan=
        | | |     +-ProjectScan
        | | |       +-column_list=[SimpleTypes.uint64#4, SimpleTypes.string#5, $subquery1.extra_col#19]
        | | |       +-expr_list=
        | | |       | +-extra_col#19 := Literal(type=INT64, value=42)
        | | |       +-input_scan=
        | | |         +-TableScan(column_list=SimpleTypes.[uint64#4, string#5], table=SimpleTypes, column_index_list=[3, 4])
        | | +-argument_column_list=SimpleTypes.[uint64#4, string#5]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=SimpleTypes.[date#29, string#24]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypes.[string#24, date#29], table=SimpleTypes, column_index_list=[4, 9])
        |   +-argument_column_list=SimpleTypes.[date#29, string#24]
        +-column_index_list=[0, 1]
==

# The query calls a TVF that has two relation arguments with required schemas.
# Type coercion and extra-column-dropping are necessary for one of the relations
# but not the other.
select column_bool, column_bytes
from tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select uint32 as uint64, string, 42 as extra_col from simpletypes),
    (select `date`, string from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bool#39 AS column_bool [BOOL]
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bytes#40 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#39, column_bytes#40]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#39, column_bytes#40]
        +-tvf=tvf_two_relation_args_uint64_string_and_date_string_input_columns((TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery3.uint64#38, SimpleTypes.string#5]
        | | |   +-expr_list=
        | | |   | +-uint64#38 :=
        | | |   |   +-Cast(UINT32 -> UINT64)
        | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
        | | |   +-input_scan=
        | | |     +-ProjectScan
        | | |       +-column_list=[SimpleTypes.uint32#3, SimpleTypes.string#5, $subquery1.extra_col#19]
        | | |       +-expr_list=
        | | |       | +-extra_col#19 := Literal(type=INT64, value=42)
        | | |       +-input_scan=
        | | |         +-TableScan(column_list=SimpleTypes.[uint32#3, string#5], table=SimpleTypes, column_index_list=[2, 4])
        | | +-argument_column_list=[$subquery3.uint64#38, SimpleTypes.string#5]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=SimpleTypes.[date#29, string#24]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypes.[string#24, date#29], table=SimpleTypes, column_index_list=[4, 9])
        |   +-argument_column_list=SimpleTypes.[date#29, string#24]
        +-column_index_list=[0, 1]
==

# The query calls a TVF that has two relation arguments with required schemas.
# Type coercion, column rearrangement, and extra-column-dropping are necessary
# for one of the relations but not the other.
select column_bool, column_bytes
from tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select string, uint32 as uint64, 42 as extra_col from simpletypes),
    (select `date`, string from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bool#39 AS column_bool [BOOL]
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bytes#40 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#39, column_bytes#40]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#39, column_bytes#40]
        +-tvf=tvf_two_relation_args_uint64_string_and_date_string_input_columns((TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery3.uint64#38, SimpleTypes.string#5]
        | | |   +-expr_list=
        | | |   | +-uint64#38 :=
        | | |   |   +-Cast(UINT32 -> UINT64)
        | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
        | | |   +-input_scan=
        | | |     +-ProjectScan
        | | |       +-column_list=[SimpleTypes.string#5, SimpleTypes.uint32#3, $subquery1.extra_col#19]
        | | |       +-expr_list=
        | | |       | +-extra_col#19 := Literal(type=INT64, value=42)
        | | |       +-input_scan=
        | | |         +-TableScan(column_list=SimpleTypes.[uint32#3, string#5], table=SimpleTypes, column_index_list=[2, 4])
        | | +-argument_column_list=[$subquery3.uint64#38, SimpleTypes.string#5]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=SimpleTypes.[date#29, string#24]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypes.[string#24, date#29], table=SimpleTypes, column_index_list=[4, 9])
        |   +-argument_column_list=SimpleTypes.[date#29, string#24]
        +-column_index_list=[0, 1]
==

# The query calls a TVF that has two relation arguments with required schemas.
# Type coercion, column rearrangement, and/or extra-column-dropping are
# necessary for both relations.
select column_bool, column_bytes
from tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select string, uint32 as uint64, 42 as extra_col from simpletypes),
    (select string, `date`, 42 as extra_col from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bool#40 AS column_bool [BOOL]
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bytes#41 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#40, column_bytes#41]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#40, column_bytes#41]
        +-tvf=tvf_two_relation_args_uint64_string_and_date_string_input_columns((TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery3.uint64#39, SimpleTypes.string#5]
        | | |   +-expr_list=
        | | |   | +-uint64#39 :=
        | | |   |   +-Cast(UINT32 -> UINT64)
        | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
        | | |   +-input_scan=
        | | |     +-ProjectScan
        | | |       +-column_list=[SimpleTypes.string#5, SimpleTypes.uint32#3, $subquery1.extra_col#19]
        | | |       +-expr_list=
        | | |       | +-extra_col#19 := Literal(type=INT64, value=42)
        | | |       +-input_scan=
        | | |         +-TableScan(column_list=SimpleTypes.[uint32#3, string#5], table=SimpleTypes, column_index_list=[2, 4])
        | | +-argument_column_list=[$subquery3.uint64#39, SimpleTypes.string#5]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=SimpleTypes.[date#29, string#24]
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[SimpleTypes.string#24, SimpleTypes.date#29, $subquery2.extra_col#38]
        |   |       +-expr_list=
        |   |       | +-extra_col#38 := Literal(type=INT64, value=42)
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=SimpleTypes.[string#24, date#29], table=SimpleTypes, column_index_list=[4, 9])
        |   +-argument_column_list=SimpleTypes.[date#29, string#24]
        +-column_index_list=[0, 1]
==

# A TVF accepts one relation argument with a required int64 value table, and
# returns a fixed schema.
select * from tvf_one_relation_arg_int64_input_value_table(
    (select as value Key from KeyValue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_input_value_table.column_bool#3 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_input_value_table.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_int64_input_value_table.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_int64_input_value_table.[column_bool#3, column_bytes#4]
        +-tvf=tvf_one_relation_arg_int64_input_value_table((TABLE<INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#1]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |   +-argument_column_list=[KeyValue.Key#1]
        +-column_index_list=[0, 1]
==

# A TVF accepts one relation argument with a required int64 value table, and
# the query provides a non-value table with a single column of the required
# type. ZetaSQL accepts the query.
select * from tvf_one_relation_arg_int64_input_value_table(
    (select Key from KeyValue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_input_value_table.column_bool#3 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_input_value_table.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_int64_input_value_table.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_int64_input_value_table.[column_bool#3, column_bytes#4]
        +-tvf=tvf_one_relation_arg_int64_input_value_table((TABLE<INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<Key INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#1]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |   +-argument_column_list=[KeyValue.Key#1]
        +-column_index_list=[0, 1]
==

# A TVF accepts one relation argument with a required int64 value table, and
# forwards that relation's input schema to the TVF output schema. The query
# provides a non-value table with a single column of the required type, and
# selects from the column in the final enclosing SELECT statement. ZetaSQL
# accepts the query.
select Key from tvf_one_relation_arg_int64_input_value_table_forward_schema(
    (select Key from KeyValue))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_input_value_table_forward_schema.Key#3 AS Key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_one_relation_arg_int64_input_value_table_forward_schema.Key#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_one_relation_arg_int64_input_value_table_forward_schema.Key#3]
        +-tvf=tvf_one_relation_arg_int64_input_value_table_forward_schema((TABLE<INT64>) -> ANY TABLE)
        +-signature=(TABLE<Key INT64>) -> TABLE<Key INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#1]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |   +-argument_column_list=[KeyValue.Key#1]
        +-column_index_list=[0]
==

# A TVF accepts one relation argument with a required int64 value table, and
# the query includes a non-value table with a subquery alias.
# ZetaSQL accepts the query.
select Key from tvf_one_relation_arg_int64_input_value_table_forward_schema(
    (select Key from KeyValue)) as inputscan
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_input_value_table_forward_schema.Key#3 AS Key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_one_relation_arg_int64_input_value_table_forward_schema.Key#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_one_relation_arg_int64_input_value_table_forward_schema.Key#3]
        +-tvf=tvf_one_relation_arg_int64_input_value_table_forward_schema((TABLE<INT64>) -> ANY TABLE)
        +-signature=(TABLE<Key INT64>) -> TABLE<Key INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#1]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |   +-argument_column_list=[KeyValue.Key#1]
        +-column_index_list=[0]
        +-alias="inputscan"
==

# There are two chained TVFs. The innermost one returns a proto value table and
# the outermost one accepts one relation with a required schema of that same
# value table.
select *
from tvf_one_relation_arg_input_proto_value_table(
    (select as value mytvf from
    tvf_two_relation_args_return_proto_value_table(
        (select 1, 2), (select 3, 4)) as mytvf))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_input_proto_value_table.column_bool#6 AS column_bool [BOOL]
| +-tvf_one_relation_arg_input_proto_value_table.column_bytes#7 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_input_proto_value_table.[column_bool#6, column_bytes#7]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_input_proto_value_table.[column_bool#6, column_bytes#7]
        +-tvf=tvf_one_relation_arg_input_proto_value_table((TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#5]
        |   |   +-input_scan=
        |   |     +-TVFScan
        |   |       +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#5]
        |   |       +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
        |   |       +-signature=(TABLE<$col1 INT64, $col2 INT64>, TABLE<$col1 INT64, $col2 INT64>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
        |   |       +-argument_list=
        |   |       | +-FunctionArgument
        |   |       | | +-scan=
        |   |       | | | +-ProjectScan
        |   |       | | |   +-column_list=$subquery2.[$col1#1, $col2#2]
        |   |       | | |   +-expr_list=
        |   |       | | |   | +-$col1#1 := Literal(type=INT64, value=1)
        |   |       | | |   | +-$col2#2 := Literal(type=INT64, value=2)
        |   |       | | |   +-input_scan=
        |   |       | | |     +-SingleRowScan
        |   |       | | +-argument_column_list=$subquery2.[$col1#1, $col2#2]
        |   |       | +-FunctionArgument
        |   |       |   +-scan=
        |   |       |   | +-ProjectScan
        |   |       |   |   +-column_list=$subquery3.[$col1#3, $col2#4]
        |   |       |   |   +-expr_list=
        |   |       |   |   | +-$col1#3 := Literal(type=INT64, value=3)
        |   |       |   |   | +-$col2#4 := Literal(type=INT64, value=4)
        |   |       |   |   +-input_scan=
        |   |       |   |     +-SingleRowScan
        |   |       |   +-argument_column_list=$subquery3.[$col1#3, $col2#4]
        |   |       +-column_index_list=[0]
        |   |       +-alias="mytvf"
        |   +-argument_column_list=[tvf_two_relation_args_return_proto_value_table.$col0#5]
        +-column_index_list=[0, 1]
==

# A TVF accepts one relation argument with one enum column.
# The query passes a relation with the correct literal enum value.
select *
from tvf_one_relation_arg_one_enum_input_column(
    (select cast(1 AS `zetasql_test__.TestEnum`) as myenum))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_one_enum_input_column.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_one_enum_input_column.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_one_enum_input_column.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_one_enum_input_column.[column_bool#2, column_bytes#3]
        +-tvf=tvf_one_relation_arg_one_enum_input_column((TABLE<myenum ENUM<zetasql_test__.TestEnum>>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<myenum ENUM<zetasql_test__.TestEnum>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.myenum#1]
        |   |   +-expr_list=
        |   |   | +-myenum#1 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.myenum#1]
        +-column_index_list=[0, 1]
==

# A TVF accepts one relation argument with one enum column.
# The query passes a relation with a correct enum-valued column reference.
select *
from tvf_one_relation_arg_one_enum_input_column(
    (select * from (select cast(1 AS `zetasql_test__.TestEnum`) as myenum)))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_one_enum_input_column.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_one_enum_input_column.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_one_enum_input_column.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_one_enum_input_column.[column_bool#2, column_bytes#3]
        +-tvf=tvf_one_relation_arg_one_enum_input_column((TABLE<myenum ENUM<zetasql_test__.TestEnum>>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<myenum ENUM<zetasql_test__.TestEnum>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery2.myenum#1]
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[$subquery2.myenum#1]
        |   |       +-expr_list=
        |   |       | +-myenum#1 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-argument_column_list=[$subquery2.myenum#1]
        +-column_index_list=[0, 1]
==

# A TVF accepts one relation argument with one enum column.
# The query passes a relation with a correct enum-valued column reference.
# The enum has the same name but comes from a different descriptor pool.
select *
from tvf_one_relation_arg_one_enum_input_column(
    (select * from (
        select cast(1 AS alt_descriptor_pool.zetasql_test__.TestEnum)
        as myenum)))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_one_enum_input_column.column_bool#3 AS column_bool [BOOL]
| +-tvf_one_relation_arg_one_enum_input_column.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_one_enum_input_column.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_one_enum_input_column.[column_bool#3, column_bytes#4]
        +-tvf=tvf_one_relation_arg_one_enum_input_column((TABLE<myenum ENUM<zetasql_test__.TestEnum>>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<myenum ENUM<zetasql_test__.TestEnum>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery3.myenum#2]
        |   |   +-expr_list=
        |   |   | +-myenum#2 :=
        |   |   |   +-Cast(ENUM<zetasql_test__.TestEnum> -> ENUM<zetasql_test__.TestEnum>)
        |   |   |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=$subquery2.myenum#1)
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[$subquery2.myenum#1]
        |   |       +-input_scan=
        |   |         +-ProjectScan
        |   |           +-column_list=[$subquery2.myenum#1]
        |   |           +-expr_list=
        |   |           | +-myenum#1 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
        |   |           +-input_scan=
        |   |             +-SingleRowScan
        |   +-argument_column_list=[$subquery3.myenum#2]
        +-column_index_list=[0, 1]
==

# A TVF accepts one relation argument with one date column.
select *
from tvf_one_relation_arg_one_date_input_column(
    (select `date` as mydate from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_one_date_input_column.column_bool#19 AS column_bool [BOOL]
| +-tvf_one_relation_arg_one_date_input_column.column_bytes#20 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_one_date_input_column.[column_bool#19, column_bytes#20]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_one_date_input_column.[column_bool#19, column_bytes#20]
        +-tvf=tvf_one_relation_arg_one_date_input_column((TABLE<mydate DATE>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<mydate DATE>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypes.date#10]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[SimpleTypes.date#10], table=SimpleTypes, column_index_list=[9])
        |   +-argument_column_list=[SimpleTypes.date#10]
        +-column_index_list=[0, 1]
==

# A TVF accepts one relation argument. The relation argument refers to a range
# variable for a table reference in the enclosing query.
select (
    select as struct *
    from tvf_one_relation_arg_return_proto_value_table(
        (select * from i.structval)))
from (
    select [struct("e" as string, 123 as int64)] as structval) as i
--
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<int32_val1 INT32, int32_val2 INT32, str_value ARRAY<STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<int32_val1 INT32, int32_val2 INT32, str_value ARRAY<STRING>>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=ARRAY<STRUCT<string STRING, int64 INT64>>, column=i.structval#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<int32_val1 INT32, int32_val2 INT32, str_value ARRAY<STRING>>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT32, column=$expr_subquery.int32_val1#6)
    |         |       +-ColumnRef(type=INT32, column=$expr_subquery.int32_val2#7)
    |         |       +-ColumnRef(type=ARRAY<STRING>, column=$expr_subquery.str_value#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=$expr_subquery.[int32_val1#6, int32_val2#7, str_value#8]
    |             +-expr_list=
    |             | +-int32_val1#6 :=
    |             | | +-GetProtoField
    |             | |   +-type=INT32
    |             | |   +-expr=
    |             | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_one_relation_arg_return_proto_value_table.$col0#5)
    |             | |   +-field_descriptor=int32_val1
    |             | |   +-default_value=0
    |             | +-int32_val2#7 :=
    |             | | +-GetProtoField
    |             | |   +-type=INT32
    |             | |   +-expr=
    |             | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_one_relation_arg_return_proto_value_table.$col0#5)
    |             | |   +-field_descriptor=int32_val2
    |             | |   +-default_value=0
    |             | +-str_value#8 :=
    |             |   +-GetProtoField
    |             |     +-type=ARRAY<STRING>
    |             |     +-expr=
    |             |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_one_relation_arg_return_proto_value_table.$col0#5)
    |             |     +-field_descriptor=str_value
    |             |     +-default_value=[]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=[tvf_one_relation_arg_return_proto_value_table.$col0#5]
    |                 +-tvf=tvf_one_relation_arg_return_proto_value_table((TABLE<string STRING, int64 INT64>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
    |                 +-signature=(TABLE<string STRING, int64 INT64>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 |   +-scan=
    |                 |   | +-ProjectScan
    |                 |   |   +-column_list=$subquery1.[string#3, int64#4]
    |                 |   |   +-expr_list=
    |                 |   |   | +-string#3 :=
    |                 |   |   | | +-GetStructField
    |                 |   |   | |   +-type=STRING
    |                 |   |   | |   +-expr=
    |                 |   |   | |   | +-ColumnRef(type=STRUCT<string STRING, int64 INT64>, column=$array.structval#2)
    |                 |   |   | |   +-field_idx=0
    |                 |   |   | +-int64#4 :=
    |                 |   |   |   +-GetStructField
    |                 |   |   |     +-type=INT64
    |                 |   |   |     +-expr=
    |                 |   |   |     | +-ColumnRef(type=STRUCT<string STRING, int64 INT64>, column=$array.structval#2)
    |                 |   |   |     +-field_idx=1
    |                 |   |   +-input_scan=
    |                 |   |     +-ArrayScan
    |                 |   |       +-column_list=[$array.structval#2]
    |                 |   |       +-array_expr=
    |                 |   |       | +-ColumnRef(type=ARRAY<STRUCT<string STRING, int64 INT64>>, column=i.structval#1, is_correlated=TRUE)
    |                 |   |       +-element_column=$array.structval#2
    |                 |   +-argument_column_list=$subquery1.[string#3, int64#4]
    |                 +-column_index_list=[0]
    +-input_scan=
      +-ProjectScan
        +-column_list=[i.structval#1]
        +-expr_list=
        | +-structval#1 := Literal(type=ARRAY<STRUCT<string STRING, int64 INT64>>, value=[{string:"e", int64:123}])
        +-input_scan=
          +-SingleRowScan
==

# A TVF accepts one relation argument. The relation argument refers to a range
# variable for a table reference to its left in the FROM cluase via the lateral
# behavior of UNNEST.
select *
from (select [struct("e" as string, 123 as int64)] as structval) as i,
      unnest(array(select as struct *
                   from tvf_one_relation_arg_return_proto_value_table(
                       (select * from unnest(i.structval))))) as u
--
QueryStmt
+-output_column_list=
| +-i.structval#1 AS structval [ARRAY<STRUCT<string STRING, int64 INT64>>]
| +-$query.int32_val1#11 AS int32_val1 [INT32]
| +-$query.int32_val2#12 AS int32_val2 [INT32]
| +-$query.str_value#13 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[i.structval#1, $query.int32_val1#11, $query.int32_val2#12, $query.str_value#13]
    +-expr_list=
    | +-int32_val1#11 :=
    | | +-GetStructField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<int32_val1 INT32, int32_val2 INT32, str_value ARRAY<STRING>>, column=$array.u#10)
    | |   +-field_idx=0
    | +-int32_val2#12 :=
    | | +-GetStructField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<int32_val1 INT32, int32_val2 INT32, str_value ARRAY<STRING>>, column=$array.u#10)
    | |   +-field_idx=1
    | +-str_value#13 :=
    |   +-GetStructField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<int32_val1 INT32, int32_val2 INT32, str_value ARRAY<STRING>>, column=$array.u#10)
    |     +-field_idx=2
    +-input_scan=
      +-ArrayScan
        +-column_list=[i.structval#1, $array.u#10]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[i.structval#1]
        |   +-expr_list=
        |   | +-structval#1 := Literal(type=ARRAY<STRUCT<string STRING, int64 INT64>>, value=[{string:"e", int64:123}])
        |   +-input_scan=
        |     +-SingleRowScan
        +-array_expr=
        | +-SubqueryExpr
        |   +-type=ARRAY<STRUCT<int32_val1 INT32, int32_val2 INT32, str_value ARRAY<STRING>>>
        |   +-subquery_type=ARRAY
        |   +-parameter_list=
        |   | +-ColumnRef(type=ARRAY<STRUCT<string STRING, int64 INT64>>, column=i.structval#1)
        |   +-subquery=
        |     +-ProjectScan
        |       +-column_list=[$make_struct.$struct#9]
        |       +-expr_list=
        |       | +-$struct#9 :=
        |       |   +-MakeStruct
        |       |     +-type=STRUCT<int32_val1 INT32, int32_val2 INT32, str_value ARRAY<STRING>>
        |       |     +-field_list=
        |       |       +-ColumnRef(type=INT32, column=$expr_subquery.int32_val1#6)
        |       |       +-ColumnRef(type=INT32, column=$expr_subquery.int32_val2#7)
        |       |       +-ColumnRef(type=ARRAY<STRING>, column=$expr_subquery.str_value#8)
        |       +-input_scan=
        |         +-ProjectScan
        |           +-column_list=$expr_subquery.[int32_val1#6, int32_val2#7, str_value#8]
        |           +-expr_list=
        |           | +-int32_val1#6 :=
        |           | | +-GetProtoField
        |           | |   +-type=INT32
        |           | |   +-expr=
        |           | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_one_relation_arg_return_proto_value_table.$col0#5)
        |           | |   +-field_descriptor=int32_val1
        |           | |   +-default_value=0
        |           | +-int32_val2#7 :=
        |           | | +-GetProtoField
        |           | |   +-type=INT32
        |           | |   +-expr=
        |           | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_one_relation_arg_return_proto_value_table.$col0#5)
        |           | |   +-field_descriptor=int32_val2
        |           | |   +-default_value=0
        |           | +-str_value#8 :=
        |           |   +-GetProtoField
        |           |     +-type=ARRAY<STRING>
        |           |     +-expr=
        |           |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_one_relation_arg_return_proto_value_table.$col0#5)
        |           |     +-field_descriptor=str_value
        |           |     +-default_value=[]
        |           +-input_scan=
        |             +-TVFScan
        |               +-column_list=[tvf_one_relation_arg_return_proto_value_table.$col0#5]
        |               +-tvf=tvf_one_relation_arg_return_proto_value_table((TABLE<string STRING, int64 INT64>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
        |               +-signature=(TABLE<string STRING, int64 INT64>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
        |               +-argument_list=
        |               | +-FunctionArgument
        |               |   +-scan=
        |               |   | +-ProjectScan
        |               |   |   +-column_list=$subquery1.[string#3, int64#4]
        |               |   |   +-expr_list=
        |               |   |   | +-string#3 :=
        |               |   |   | | +-GetStructField
        |               |   |   | |   +-type=STRING
        |               |   |   | |   +-expr=
        |               |   |   | |   | +-ColumnRef(type=STRUCT<string STRING, int64 INT64>, column=$array.$unnest1#2)
        |               |   |   | |   +-field_idx=0
        |               |   |   | +-int64#4 :=
        |               |   |   |   +-GetStructField
        |               |   |   |     +-type=INT64
        |               |   |   |     +-expr=
        |               |   |   |     | +-ColumnRef(type=STRUCT<string STRING, int64 INT64>, column=$array.$unnest1#2)
        |               |   |   |     +-field_idx=1
        |               |   |   +-input_scan=
        |               |   |     +-ArrayScan
        |               |   |       +-column_list=[$array.$unnest1#2]
        |               |   |       +-array_expr=
        |               |   |       | +-ColumnRef(type=ARRAY<STRUCT<string STRING, int64 INT64>>, column=i.structval#1, is_correlated=TRUE)
        |               |   |       +-element_column=$array.$unnest1#2
        |               |   +-argument_column_list=$subquery1.[string#3, int64#4]
        |               +-column_index_list=[0]
        +-element_column=$array.u#10

==

# A TVF accepts one relation argument and one scalar argument. The scalar
# argument refers to a range variable for a table reference in the enclosing
# query.
select (
    select as struct *
    from tvf_one_relation_arg_one_int64_arg(
        (select 1, 2),
        (select * from i.val)))
from (
    select [123] as val) as i
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS `$col1` [STRUCT<column_bool BOOL, column_bytes BYTES>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8]
    +-expr_list=
    | +-$col1#8 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<column_bool BOOL, column_bytes BYTES>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=ARRAY<INT64>, column=i.val#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#7]
    |         +-expr_list=
    |         | +-$struct#7 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<column_bool BOOL, column_bytes BYTES>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=BOOL, column=tvf_one_relation_arg_one_int64_arg.column_bool#5)
    |         |       +-ColumnRef(type=BYTES, column=tvf_one_relation_arg_one_int64_arg.column_bytes#6)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=tvf_one_relation_arg_one_int64_arg.[column_bool#5, column_bytes#6]
    |             +-input_scan=
    |               +-TVFScan
    |                 +-column_list=tvf_one_relation_arg_one_int64_arg.[column_bool#5, column_bytes#6]
    |                 +-tvf=tvf_one_relation_arg_one_int64_arg((ANY TABLE, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    |                 +-signature=(TABLE<$col1 INT64, $col2 INT64>, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
    |                 +-argument_list=
    |                 | +-FunctionArgument
    |                 | | +-scan=
    |                 | | | +-ProjectScan
    |                 | | |   +-column_list=$subquery1.[$col1#2, $col2#3]
    |                 | | |   +-expr_list=
    |                 | | |   | +-$col1#2 := Literal(type=INT64, value=1)
    |                 | | |   | +-$col2#3 := Literal(type=INT64, value=2)
    |                 | | |   +-input_scan=
    |                 | | |     +-SingleRowScan
    |                 | | +-argument_column_list=$subquery1.[$col1#2, $col2#3]
    |                 | +-FunctionArgument
    |                 |   +-expr=
    |                 |     +-SubqueryExpr
    |                 |       +-type=INT64
    |                 |       +-subquery_type=SCALAR
    |                 |       +-parameter_list=
    |                 |       | +-ColumnRef(type=ARRAY<INT64>, column=i.val#1, is_correlated=TRUE)
    |                 |       +-subquery=
    |                 |         +-ProjectScan
    |                 |           +-column_list=[$array.val#4]
    |                 |           +-input_scan=
    |                 |             +-ArrayScan
    |                 |               +-column_list=[$array.val#4]
    |                 |               +-array_expr=
    |                 |               | +-ColumnRef(type=ARRAY<INT64>, column=i.val#1, is_correlated=TRUE)
    |                 |               +-element_column=$array.val#4
    |                 +-column_index_list=[0, 1]
    +-input_scan=
      +-ProjectScan
        +-column_list=[i.val#1]
        +-expr_list=
        | +-val#1 := Literal(type=ARRAY<INT64>, value=[123])
        +-input_scan=
          +-SingleRowScan
==

# "TABLE path" syntax for table-valued function arguments.
select * from tvf_one_relation_arg_with_fixed_output(table keyvalue)
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#3 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#3, column_bytes#4]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=KeyValue.[Key#1, Value#2]
        +-column_index_list=[0, 1]
==

# "TABLE path" syntax for table-valued function arguments, where the input table
# provides the "Key" and "Value" columns but the TVF only needs the column named
# "Key". The function signature allows this, matches the required column "Key"
# by name, and then simply prunes the extra "Value" column.
select * from tvf_key_input_column_extra_input_columns_allowed(table keyvalue)
--
QueryStmt
+-output_column_list=
| +-tvf_key_input_column_extra_input_columns_allowed.column_bool#3 AS column_bool [BOOL]
| +-tvf_key_input_column_extra_input_columns_allowed.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_key_input_column_extra_input_columns_allowed.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_key_input_column_extra_input_columns_allowed.[column_bool#3, column_bytes#4]
        +-tvf=tvf_key_input_column_extra_input_columns_allowed((TABLE<key INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<Key INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#1]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=[KeyValue.Key#1]
        +-column_index_list=[0, 1]
==

# "TABLE path" syntax for table-valued function arguments, with a value table.
select * from tvf_one_relation_arg_with_fixed_output(
    table TestStructValueTable)
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<STRUCT<a INT32, b STRING>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0])
        |   +-argument_column_list=[TestStructValueTable.value#1]
        +-column_index_list=[0, 1]
==

# "TABLE path" syntax for table-valued function arguments when the type of a
# provided column is not equal but coercible to the type of the required column
# with the same name.
select * from tvf_uint64_input_column_named_uint32(table simpletypes)
--
QueryStmt
+-output_column_list=
| +-tvf_uint64_input_column_named_uint32.column_bool#20 AS column_bool [BOOL]
| +-tvf_uint64_input_column_named_uint32.column_bytes#21 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_uint64_input_column_named_uint32.[column_bool#20, column_bytes#21]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_uint64_input_column_named_uint32.[column_bool#20, column_bytes#21]
        +-tvf=tvf_uint64_input_column_named_uint32((TABLE<uint32 UINT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<uint32 UINT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.uint32#19]
        |   |   +-expr_list=
        |   |   | +-uint32#19 :=
        |   |   |   +-Cast(UINT32 -> UINT64)
        |   |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
        |   +-argument_column_list=[$subquery1.uint32#19]
        +-column_index_list=[0, 1]
==

# "TABLE path" syntax for table-valued function arguments, with pseudo-columns.
# Schema:
#   EnumTable has two pseudo-columns, Filename and RowId.
select * from tvf_one_relation_arg_with_fixed_output(table EnumTable)
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#6 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#7 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#6, column_bytes#7]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#6, column_bytes#7]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<key INT32, TestEnum ENUM<zetasql_test__.TestEnum>, AnotherTestEnum ENUM<zetasql_test__.AnotherTestEnum>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3], table=EnumTable, column_index_list=[0, 1, 2])
        |   +-argument_column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3]
        +-column_index_list=[0, 1]
==

# "TABLE path" syntax for table-valued function arguments, with a value table.
# Schema:
#   TestExtraValueTable is a value table and has two pseudo-columns, Filename
#   and RowId.
select * from tvf_one_relation_arg_with_fixed_output(table TestExtraValueTable)
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#4 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        |   +-argument_column_list=[TestExtraValueTable.value#1]
        +-column_index_list=[0, 1]
==

# Call a TVF that expects a single column named "Key" of type INT64, and we pass
# EnumTable which has a column named "Key" of type INT32 plus some extra
# columns. ZetaSQL drops the extra columns and adds a type coercion.
select * from tvf_key_input_column_extra_input_columns_allowed(table EnumTable)
--
QueryStmt
+-output_column_list=
| +-tvf_key_input_column_extra_input_columns_allowed.column_bool#7 AS column_bool [BOOL]
| +-tvf_key_input_column_extra_input_columns_allowed.column_bytes#8 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_key_input_column_extra_input_columns_allowed.[column_bool#7, column_bytes#8]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_key_input_column_extra_input_columns_allowed.[column_bool#7, column_bytes#8]
        +-tvf=tvf_key_input_column_extra_input_columns_allowed((TABLE<key INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<key INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.key#6]
        |   |   +-expr_list=
        |   |   | +-key#6 :=
        |   |   |   +-Cast(INT32 -> INT64)
        |   |   |     +-ColumnRef(type=INT32, column=EnumTable.key#1)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3], table=EnumTable, column_index_list=[0, 1, 2])
        |   +-argument_column_list=[$subquery1.key#6]
        +-column_index_list=[0, 1]
==

# Call a TVF in a nested catalog. We use this to test name resolution during
# serialization/deserialization.
# Java error:
# java.lang.NullPointerException
#   at c.g.common.base.Preconditions.checkNotNull
#   at c.g.s.zetasql.resolvedast.DeserializationHelper.deserialize
#   at c.g.s.zetasql.resolvedast.ResolvedNodes$ResolvedTVFScan.<init>
#   at c.g.s.zetasql.resolvedast.ResolvedNodes$ResolvedTVFScan.deserialize
#   at c.g.s.zetasql.resolvedast.ResolvedNodes$ResolvedScan.deserialize
#   at c.g.s.zetasql.resolvedast.ResolvedNodes$ResolvedProjectScan.<init>
[no_java]
select * from nested_catalog.nested_tvf_one(table EnumTable)
--
QueryStmt
+-output_column_list=
| +-nested_catalog.nested_tvf_one.key#7 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[nested_catalog.nested_tvf_one.key#7]
    +-input_scan=
      +-TVFScan
        +-column_list=[nested_catalog.nested_tvf_one.key#7]
        +-tvf=nested_catalog.nested_tvf_one((TABLE<key INT64>) -> TABLE<key INT64>)
        +-signature=(TABLE<key INT64>) -> TABLE<key INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.key#6]
        |   |   +-expr_list=
        |   |   | +-key#6 :=
        |   |   |   +-Cast(INT32 -> INT64)
        |   |   |     +-ColumnRef(type=INT32, column=EnumTable.key#1)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3], table=EnumTable, column_index_list=[0, 1, 2])
        |   +-argument_column_list=[$subquery1.key#6]
        +-column_index_list=[0]
==

# Call a TVF in a nested catalog. We use this to test name resolution during
# serialization/deserialization.
# Java error:
# java.lang.NullPointerException
#   at c.g.common.base.Preconditions.checkNotNull
#   at c.g.s.zetasql.resolvedast.DeserializationHelper.deserialize
#   at c.g.s.zetasql.resolvedast.ResolvedNodes$ResolvedTVFScan.<init>
#   at c.g.s.zetasql.resolvedast.ResolvedNodes$ResolvedTVFScan.deserialize
#   at c.g.s.zetasql.resolvedast.ResolvedNodes$ResolvedScan.deserialize
#   at c.g.s.zetasql.resolvedast.ResolvedNodes$ResolvedProjectScan.<init>
[no_java]
select * from nested_catalog.nested_nested_catalog.nested_tvf_two(
    table EnumTable)
--
QueryStmt
+-output_column_list=
| +-nested_catalog.nested_nested_catalog.nested_tvf_two.key#7 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[nested_catalog.nested_nested_catalog.nested_tvf_two.key#7]
    +-input_scan=
      +-TVFScan
        +-column_list=[nested_catalog.nested_nested_catalog.nested_tvf_two.key#7]
        +-tvf=nested_catalog.nested_nested_catalog.nested_tvf_two((TABLE<key INT64>) -> TABLE<key INT64>)
        +-signature=(TABLE<key INT64>) -> TABLE<key INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.key#6]
        |   |   +-expr_list=
        |   |   | +-key#6 :=
        |   |   |   +-Cast(INT32 -> INT64)
        |   |   |     +-ColumnRef(type=INT32, column=EnumTable.key#1)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3], table=EnumTable, column_index_list=[0, 1, 2])
        |   +-argument_column_list=[$subquery1.key#6]
        +-column_index_list=[0]
==

# Call a TVF with a hint after the function call.
select * from tvf_one_relation_arg_with_fixed_output(
    (select cast(42 as bool) as bool_column)) @{key = 'value'}
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        +-hint_list=
        | +-key := Literal(type=STRING, value="value")
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<bool_column BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.bool_column#1]
        |   |   +-expr_list=
        |   |   | +-bool_column#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.bool_column#1]
        +-column_index_list=[0, 1]
==

# Call a simple valid templated SQL TVF. This exercises the code to declare SQL
# TVFs using the TemplatedSQLTVF class and add them to the catalog, then defer
# resolving these SQL bodies until the function is actually called later. In
# this case the function has no arguments, but the return type is templated.
select * from tvf_templated_select_one();
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_one.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_one.x#1]
    +-input_scan=
      +-TVFScan(column_list=[tvf_templated_select_one.x#1], tvf=tvf_templated_select_one(() -> ANY TABLE), signature=() -> TABLE<x INT64>, column_index_list=[0])

With Templated SQL TVF signature:
  tvf_templated_select_one() -> TABLE<x INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1]
    +-expr_list=
    | +-x#1 := Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

# Show a case where the same template resolves to two different signatures:
# part one.
select * from tvf_templated_select_any_scalar_arg("abc");
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_any_scalar_arg.x#1 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_any_scalar_arg.x#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_any_scalar_arg.x#1]
        +-tvf=tvf_templated_select_any_scalar_arg((ANY TYPE) -> ANY TABLE)
        +-signature=(literal STRING) -> TABLE<x STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="abc")
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_any_scalar_arg(literal STRING) -> TABLE<x STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1]
    +-expr_list=
    | +-x#1 := ArgumentRef(type=STRING, name="x")
    +-input_scan=
      +-SingleRowScan
==

# Show a case where the same template resolves to two different signatures:
# part two.
select * from tvf_templated_select_any_scalar_arg(true);
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_any_scalar_arg.x#1 AS x [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_any_scalar_arg.x#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_any_scalar_arg.x#1]
        +-tvf=tvf_templated_select_any_scalar_arg((ANY TYPE) -> ANY TABLE)
        +-signature=(literal BOOL) -> TABLE<x BOOL>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=BOOL, value=true)
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_any_scalar_arg(literal BOOL) -> TABLE<x BOOL>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1]
    +-expr_list=
    | +-x#1 := ArgumentRef(type=BOOL, name="x")
    +-input_scan=
      +-SingleRowScan
==

# Call a TVF with a valid templated SQL body that refers to a scalar argument.
select * from tvf_templated_select_int64_arg(42);
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_int64_arg.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_int64_arg.x#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_int64_arg.x#1]
        +-tvf=tvf_templated_select_int64_arg((INT64) -> ANY TABLE)
        +-signature=(literal INT64) -> TABLE<x INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=42)
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_int64_arg(literal INT64) -> TABLE<x INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1]
    +-expr_list=
    | +-x#1 := ArgumentRef(type=INT64, name="x")
    +-input_scan=
      +-SingleRowScan
==

# Call a TVF with a valid templated SQL body that refers to a relation argument.
select * from tvf_templated_select_relation_arg_using_column_names(
    (select key, value from keyvalue));
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_relation_arg_using_column_names.key#3 AS key [INT64]
| +-tvf_templated_select_relation_arg_using_column_names.value#4 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_select_relation_arg_using_column_names.[key#3, value#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_templated_select_relation_arg_using_column_names.[key#3, value#4]
        +-tvf=tvf_templated_select_relation_arg_using_column_names((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<key INT64, value STRING>) -> TABLE<key INT64, value STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=KeyValue.[Key#1, Value#2]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=KeyValue.[Key#1, Value#2]
        +-column_index_list=[0, 1]

With Templated SQL TVF signature:
  tvf_templated_select_relation_arg_using_column_names(TABLE<key INT64, value STRING>) -> TABLE<key INT64, value STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.key#1 AS key [INT64]
| +-t.value#2 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=t.[key#1, value#2]
    +-input_scan=
      +-RelationArgumentScan(column_list=t.[key#1, value#2], name="t")
==

# Call a TVF with a valid templated SQL body that refers to a relation argument.
# Same as the previous test, but provides the column names in a different order
# than the order they are used inside the stored SQL body.
select * from tvf_templated_select_relation_arg_using_column_names(
    (select value, key from keyvalue));
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_relation_arg_using_column_names.key#3 AS key [INT64]
| +-tvf_templated_select_relation_arg_using_column_names.value#4 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_select_relation_arg_using_column_names.[key#3, value#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_templated_select_relation_arg_using_column_names.[key#3, value#4]
        +-tvf=tvf_templated_select_relation_arg_using_column_names((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<value STRING, key INT64>) -> TABLE<key INT64, value STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=KeyValue.[Value#2, Key#1]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=KeyValue.[Value#2, Key#1]
        +-column_index_list=[0, 1]

With Templated SQL TVF signature:
  tvf_templated_select_relation_arg_using_column_names(TABLE<value STRING, key INT64>) -> TABLE<key INT64, value STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.key#2 AS key [INT64]
| +-t.value#1 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=t.[key#2, value#1]
    +-input_scan=
      +-RelationArgumentScan(column_list=t.[value#1, key#2], name="t")
==

# Call a TVF with an extra unused column in the relation argument. This extra
# column should be pruned from the resolved templated query.
select * from tvf_templated_select_relation_arg_using_column_names(
    (select value, key, 1 AS extra from keyvalue));
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_relation_arg_using_column_names.key#4 AS key [INT64]
| +-tvf_templated_select_relation_arg_using_column_names.value#5 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_select_relation_arg_using_column_names.[key#4, value#5]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_templated_select_relation_arg_using_column_names.[key#4, value#5]
        +-tvf=tvf_templated_select_relation_arg_using_column_names((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<value STRING, key INT64, extra INT64>) -> TABLE<key INT64, value STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Value#2, KeyValue.Key#1, $subquery1.extra#3]
        |   |   +-expr_list=
        |   |   | +-extra#3 := Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=[KeyValue.Value#2, KeyValue.Key#1, $subquery1.extra#3]
        +-column_index_list=[0, 1]

With Templated SQL TVF signature:
  tvf_templated_select_relation_arg_using_column_names(TABLE<value STRING, key INT64, extra INT64>) -> TABLE<key INT64, value STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.key#2 AS key [INT64]
| +-t.value#1 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=t.[key#2, value#1]
    +-input_scan=
      +-RelationArgumentScan(column_list=t.[value#1, key#2], name="t")
==

# Call a TVF with a valid templated SQL body that refers to a relation argument.
select * from tvf_templated_select_relation_arg_using_select_star(
    (select * from keyvalue));
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_relation_arg_using_select_star.Key#3 AS Key [INT64]
| +-tvf_templated_select_relation_arg_using_select_star.Value#4 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_select_relation_arg_using_select_star.[Key#3, Value#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_templated_select_relation_arg_using_select_star.[Key#3, Value#4]
        +-tvf=tvf_templated_select_relation_arg_using_select_star((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<Key INT64, Value STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=KeyValue.[Key#1, Value#2]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=KeyValue.[Key#1, Value#2]
        +-column_index_list=[0, 1]

With Templated SQL TVF signature:
  tvf_templated_select_relation_arg_using_select_star(TABLE<Key INT64, Value STRING>) -> TABLE<Key INT64, Value STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.Key#1 AS Key [INT64]
| +-t.Value#2 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=t.[Key#1, Value#2]
    +-input_scan=
      +-RelationArgumentScan(column_list=t.[Key#1, Value#2], name="t")
==

# Call a TVF with a valid templated SQL body that refers to a scalar integer
# argument and also a relation argument.
select * from tvf_templated_select_scalar_and_relation_args(
    42, (select * from keyvalue));
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_scalar_and_relation_args.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_scalar_and_relation_args.key#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_scalar_and_relation_args.key#3]
        +-tvf=tvf_templated_select_scalar_and_relation_args((INT64, TABLE<key INT64>) -> ANY TABLE)
        +-signature=(literal INT64, TABLE<Key INT64>) -> TABLE<key INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=42)
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#1]
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=KeyValue.[Key#1, Value#2]
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=[KeyValue.Key#1]
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_scalar_and_relation_args(literal INT64, TABLE<Key INT64>) -> TABLE<key INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.Key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[t.Key#1]
    +-input_scan=
      +-FilterScan
        +-column_list=[t.Key#1]
        +-input_scan=
        | +-RelationArgumentScan(column_list=[t.Key#1], name="t")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=t.Key#1)
            +-ArgumentRef(type=INT64, name="x")
==

# Call a TVF with a valid templated SQL body that refers to both a scalar
# argument of any type and a relation argument of any table.
select * from tvf_templated_any_scalar_and_relation_args(
    "2000-09-04", TABLE SimpleTypes);
--
QueryStmt
+-output_column_list=
| +-tvf_templated_any_scalar_and_relation_args.int32#19 AS int32 [INT32]
| +-tvf_templated_any_scalar_and_relation_args.int64#20 AS int64 [INT64]
| +-tvf_templated_any_scalar_and_relation_args.uint32#21 AS uint32 [UINT32]
| +-tvf_templated_any_scalar_and_relation_args.uint64#22 AS uint64 [UINT64]
| +-tvf_templated_any_scalar_and_relation_args.string#23 AS string [STRING]
| +-tvf_templated_any_scalar_and_relation_args.bytes#24 AS bytes [BYTES]
| +-tvf_templated_any_scalar_and_relation_args.bool#25 AS bool [BOOL]
| +-tvf_templated_any_scalar_and_relation_args.float#26 AS float [FLOAT]
| +-tvf_templated_any_scalar_and_relation_args.double#27 AS double [DOUBLE]
| +-tvf_templated_any_scalar_and_relation_args.date#28 AS date [DATE]
| +-tvf_templated_any_scalar_and_relation_args.timestamp_seconds#29 AS timestamp_seconds [TIMESTAMP]
| +-tvf_templated_any_scalar_and_relation_args.timestamp_millis#30 AS timestamp_millis [TIMESTAMP]
| +-tvf_templated_any_scalar_and_relation_args.timestamp_micros#31 AS timestamp_micros [TIMESTAMP]
| +-tvf_templated_any_scalar_and_relation_args.timestamp_nanos#32 AS timestamp_nanos [TIMESTAMP]
| +-tvf_templated_any_scalar_and_relation_args.timestamp#33 AS timestamp [TIMESTAMP]
| +-tvf_templated_any_scalar_and_relation_args.numeric#34 AS numeric [NUMERIC]
| +-tvf_templated_any_scalar_and_relation_args.bignumeric#35 AS bignumeric [BIGNUMERIC]
| +-tvf_templated_any_scalar_and_relation_args.json#36 AS json [JSON]
| +-tvf_templated_any_scalar_and_relation_args.s#37 AS s [STRING]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_any_scalar_and_relation_args.[int32#19, int64#20, uint32#21, uint64#22, string#23, bytes#24, bool#25, float#26, double#27, date#28, timestamp_seconds#29, timestamp_millis#30, timestamp_micros#31, timestamp_nanos#32, timestamp#33, numeric#34, bignumeric#35, json#36, s#37]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_templated_any_scalar_and_relation_args.[int32#19, int64#20, uint32#21, uint64#22, string#23, bytes#24, bool#25, float#26, double#27, date#28, timestamp_seconds#29, timestamp_millis#30, timestamp_micros#31, timestamp_nanos#32, timestamp#33, numeric#34, bignumeric#35, json#36, s#37]
        +-tvf=tvf_templated_any_scalar_and_relation_args((ANY TYPE, ANY TABLE) -> ANY TABLE)
        +-signature=(literal STRING, TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON>) -> TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON, s STRING>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="2000-09-04")
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
        |   +-argument_column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18]
        +-column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]

With Templated SQL TVF signature:
  tvf_templated_any_scalar_and_relation_args(literal STRING, TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON>) -> TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON, s STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.int32#1 AS int32 [INT32]
| +-t.int64#2 AS int64 [INT64]
| +-t.uint32#3 AS uint32 [UINT32]
| +-t.uint64#4 AS uint64 [UINT64]
| +-t.string#5 AS string [STRING]
| +-t.bytes#6 AS bytes [BYTES]
| +-t.bool#7 AS bool [BOOL]
| +-t.float#8 AS float [FLOAT]
| +-t.double#9 AS double [DOUBLE]
| +-t.date#10 AS date [DATE]
| +-t.timestamp_seconds#11 AS timestamp_seconds [TIMESTAMP]
| +-t.timestamp_millis#12 AS timestamp_millis [TIMESTAMP]
| +-t.timestamp_micros#13 AS timestamp_micros [TIMESTAMP]
| +-t.timestamp_nanos#14 AS timestamp_nanos [TIMESTAMP]
| +-t.timestamp#15 AS timestamp [TIMESTAMP]
| +-t.numeric#16 AS numeric [NUMERIC]
| +-t.bignumeric#17 AS bignumeric [BIGNUMERIC]
| +-t.json#18 AS json [JSON]
| +-$query.s#19 AS s [STRING]
+-query=
  +-ProjectScan
    +-column_list=[t.int32#1, t.int64#2, t.uint32#3, t.uint64#4, t.string#5, t.bytes#6, t.bool#7, t.float#8, t.double#9, t.date#10, t.timestamp_seconds#11, t.timestamp_millis#12, t.timestamp_micros#13, t.timestamp_nanos#14, t.timestamp#15, t.numeric#16, t.bignumeric#17, t.json#18, $query.s#19]
    +-expr_list=
    | +-s#19 := ArgumentRef(type=STRING, name="s")
    +-input_scan=
      +-RelationArgumentScan(column_list=t.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], name="t")
==

# Same as previous, but selecting a subset of columns
select uint32, int32, s, date, json, bool
from tvf_templated_any_scalar_and_relation_args(
    "2000-09-04", TABLE SimpleTypes);
--
QueryStmt
+-output_column_list=
| +-tvf_templated_any_scalar_and_relation_args.uint32#21 AS uint32 [UINT32]
| +-tvf_templated_any_scalar_and_relation_args.int32#19 AS int32 [INT32]
| +-tvf_templated_any_scalar_and_relation_args.s#37 AS s [STRING]
| +-tvf_templated_any_scalar_and_relation_args.date#28 AS date [DATE]
| +-tvf_templated_any_scalar_and_relation_args.json#36 AS json [JSON]
| +-tvf_templated_any_scalar_and_relation_args.bool#25 AS bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_any_scalar_and_relation_args.[uint32#21, int32#19, s#37, date#28, json#36, bool#25]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_templated_any_scalar_and_relation_args.[int32#19, uint32#21, bool#25, date#28, json#36, s#37]
        +-tvf=tvf_templated_any_scalar_and_relation_args((ANY TYPE, ANY TABLE) -> ANY TABLE)
        +-signature=(literal STRING, TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON>) -> TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON, s STRING>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="2000-09-04")
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
        |   +-argument_column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18]
        +-column_index_list=[0, 2, 6, 9, 17, 18]

With Templated SQL TVF signature:
  tvf_templated_any_scalar_and_relation_args(literal STRING, TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON>) -> TABLE<int32 INT32, int64 INT64, uint32 UINT32, uint64 UINT64, string STRING, bytes BYTES, bool BOOL, float FLOAT, double DOUBLE, date DATE, timestamp_seconds TIMESTAMP, timestamp_millis TIMESTAMP, timestamp_micros TIMESTAMP, timestamp_nanos TIMESTAMP, timestamp TIMESTAMP, numeric NUMERIC, bignumeric BIGNUMERIC, json JSON, s STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.int32#1 AS int32 [INT32]
| +-t.int64#2 AS int64 [INT64]
| +-t.uint32#3 AS uint32 [UINT32]
| +-t.uint64#4 AS uint64 [UINT64]
| +-t.string#5 AS string [STRING]
| +-t.bytes#6 AS bytes [BYTES]
| +-t.bool#7 AS bool [BOOL]
| +-t.float#8 AS float [FLOAT]
| +-t.double#9 AS double [DOUBLE]
| +-t.date#10 AS date [DATE]
| +-t.timestamp_seconds#11 AS timestamp_seconds [TIMESTAMP]
| +-t.timestamp_millis#12 AS timestamp_millis [TIMESTAMP]
| +-t.timestamp_micros#13 AS timestamp_micros [TIMESTAMP]
| +-t.timestamp_nanos#14 AS timestamp_nanos [TIMESTAMP]
| +-t.timestamp#15 AS timestamp [TIMESTAMP]
| +-t.numeric#16 AS numeric [NUMERIC]
| +-t.bignumeric#17 AS bignumeric [BIGNUMERIC]
| +-t.json#18 AS json [JSON]
| +-$query.s#19 AS s [STRING]
+-query=
  +-ProjectScan
    +-column_list=[t.int32#1, t.int64#2, t.uint32#3, t.uint64#4, t.string#5, t.bytes#6, t.bool#7, t.float#8, t.double#9, t.date#10, t.timestamp_seconds#11, t.timestamp_millis#12, t.timestamp_micros#13, t.timestamp_nanos#14, t.timestamp#15, t.numeric#16, t.bignumeric#17, t.json#18, $query.s#19]
    +-expr_list=
    | +-s#19 := ArgumentRef(type=STRING, name="s")
    +-input_scan=
      +-RelationArgumentScan(column_list=t.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], name="t")
==

# Call a TVF with a valid templated SQL body that refers to a scalar integer
# argument and also a relation argument.
select * from tvf_templated_scalar_date_and_relation_args(
    "2000-09-04", TABLE SimpleTypes);
--
QueryStmt
+-output_column_list=
| +-tvf_templated_scalar_date_and_relation_args.date#19 AS date [DATE]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_scalar_date_and_relation_args.date#19]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_scalar_date_and_relation_args.date#19]
        +-tvf=tvf_templated_scalar_date_and_relation_args((DATE, TABLE<date DATE>) -> ANY TABLE)
        +-signature=(literal DATE, TABLE<date DATE>) -> TABLE<date DATE>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=DATE, value=2000-09-04)
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypes.date#10]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
        |   +-argument_column_list=[SimpleTypes.date#10]
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_scalar_date_and_relation_args(literal DATE, TABLE<date DATE>) -> TABLE<date DATE>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.date#1 AS date [DATE]
+-query=
  +-ProjectScan
    +-column_list=[t.date#1]
    +-input_scan=
      +-FilterScan
        +-column_list=[t.date#1]
        +-input_scan=
        | +-RelationArgumentScan(column_list=[t.date#1], name="t")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$less(DATE, DATE) -> BOOL)
            +-ColumnRef(type=DATE, column=t.date#1)
            +-ArgumentRef(type=DATE, name="d")
==

# Call a TVF with a valid templated SQL body that refers to a scalar argument
# and a relation argument, with type coercions added for both arguments.
select * from tvf_templated_select_scalar_and_relation_args(
    (select int32 from simpletypes), (select int32 as key from simpletypes));
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_scalar_and_relation_args.key#38 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_scalar_and_relation_args.key#38]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_scalar_and_relation_args.key#38]
        +-tvf=tvf_templated_select_scalar_and_relation_args((INT64, TABLE<key INT64>) -> ANY TABLE)
        +-signature=(INT64, TABLE<key INT64>) -> TABLE<key INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Cast(INT32 -> INT64)
        | |     +-SubqueryExpr
        | |       +-type=INT32
        | |       +-subquery_type=SCALAR
        | |       +-subquery=
        | |         +-ProjectScan
        | |           +-column_list=[SimpleTypes.int32#1]
        | |           +-input_scan=
        | |             +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery2.key#37]
        |   |   +-expr_list=
        |   |   | +-key#37 :=
        |   |   |   +-Cast(INT32 -> INT64)
        |   |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#19)
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[SimpleTypes.int32#19]
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=[SimpleTypes.int32#19], table=SimpleTypes, column_index_list=[0])
        |   +-argument_column_list=[$subquery2.key#37]
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_scalar_and_relation_args(INT64, TABLE<key INT64>) -> TABLE<key INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[t.key#1]
    +-input_scan=
      +-FilterScan
        +-column_list=[t.key#1]
        +-input_scan=
        | +-RelationArgumentScan(column_list=[t.key#1], name="t")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=t.key#1)
            +-ArgumentRef(type=INT64, name="x")
==

# Call a TVF with a valid templated SQL body that refers to a relation argument
# using the TABLE clause.
select * from tvf_templated_select_relation_arg_and_catalog_table(
    table keyvalue);
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_relation_arg_and_catalog_table.Key#3 AS Key [INT64]
| +-tvf_templated_select_relation_arg_and_catalog_table.Value#4 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_select_relation_arg_and_catalog_table.[Key#3, Value#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_templated_select_relation_arg_and_catalog_table.[Key#3, Value#4]
        +-tvf=tvf_templated_select_relation_arg_and_catalog_table((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<Key INT64, Value STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=KeyValue.[Key#1, Value#2]
        +-column_index_list=[0, 1]

With Templated SQL TVF signature:
  tvf_templated_select_relation_arg_and_catalog_table(TABLE<Key INT64, Value STRING>) -> TABLE<Key INT64, Value STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$union_all.Key#5 AS Key [INT64]
| +-$union_all.Value#6 AS Value [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[Key#5, Value#6]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=t.[Key#1, Value#2]
      | |   +-input_scan=
      | |     +-RelationArgumentScan(column_list=t.[Key#1, Value#2], name="t")
      | +-output_column_list=t.[Key#1, Value#2]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=KeyValue.[Key#3, Value#4]
        |   +-input_scan=
        |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
        +-output_column_list=KeyValue.[Key#3, Value#4]
==

# Call a TVF with a valid templated SQL body that refers to two relation
# arguments.
select * from tvf_templated_select_two_relation_args(
    (select value, key from keyvalue),
    (select key from keyvalue))
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_two_relation_args.key#5 AS key [INT64]
| +-tvf_templated_select_two_relation_args.value#6 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_select_two_relation_args.[key#5, value#6]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_templated_select_two_relation_args.[key#5, value#6]
        +-tvf=tvf_templated_select_two_relation_args((ANY TABLE, ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<value STRING, key INT64>, TABLE<key INT64>) -> TABLE<key INT64, value STRING>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=KeyValue.[Value#2, Key#1]
        | | |   +-input_scan=
        | | |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        | | +-argument_column_list=KeyValue.[Value#2, Key#1]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#3]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0])
        |   +-argument_column_list=[KeyValue.Key#3]
        +-column_index_list=[0, 1]

With Templated SQL TVF signature:
  tvf_templated_select_two_relation_args(TABLE<value STRING, key INT64>, TABLE<key INT64>) -> TABLE<key INT64, value STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-w1.key#5 AS key [INT64]
| +-w1.value#4 AS value [STRING]
+-query=
  +-WithScan
    +-column_list=w1.[key#5, value#4]
    +-is_ordered=TRUE
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="w1"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=s.[value#1, key#2]
    | |     +-input_scan=
    | |       +-RelationArgumentScan(column_list=s.[value#1, key#2], name="s")
    | +-WithEntry
    |   +-with_query_name="w2"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t.key#3]
    |       +-input_scan=
    |         +-RelationArgumentScan(column_list=[t.key#3], name="t")
    +-query=
      +-LimitOffsetScan
        +-column_list=w1.[key#5, value#4]
        +-is_ordered=TRUE
        +-input_scan=
        | +-OrderByScan
        |   +-column_list=w1.[key#5, value#4]
        |   +-is_ordered=TRUE
        |   +-input_scan=
        |   | +-JoinScan
        |   |   +-column_list=[w1.value#4, w1.key#5, w2.key#6]
        |   |   +-left_scan=
        |   |   | +-WithRefScan(column_list=w1.[value#4, key#5], with_query_name="w1")
        |   |   +-right_scan=
        |   |   | +-WithRefScan(column_list=[w2.key#6], with_query_name="w2")
        |   |   +-join_expr=
        |   |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   |       +-ColumnRef(type=INT64, column=w1.key#5)
        |   |       +-ColumnRef(type=INT64, column=w2.key#6)
        |   +-order_by_item_list=
        |     +-OrderByItem
        |       +-column_ref=
        |         +-ColumnRef(type=INT64, column=w1.key#5)
        +-limit=
          +-Literal(type=INT64, value=1)
==

# Call a TVF passing a query parameter within a relation argument.
select * from tvf_one_relation_arg_with_fixed_output(
    (select @test_param_bool as bool_column))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<bool_column BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.bool_column#1]
        |   |   +-expr_list=
        |   |   | +-bool_column#1 := Parameter(type=BOOL, name="test_param_bool")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.bool_column#1]
        +-column_index_list=[0, 1]
==

# Call a TVF that expects an argument where the name contains '$'.
select * from tvf_templated_scalar_arg_plus_integer_accept_dollars_col_name(
    (select @test_param_bool as `$col1`))
--
QueryStmt
+-output_column_list=
| +-tvf_templated_scalar_arg_plus_integer_accept_dollars_col_name.x#2 AS x [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_scalar_arg_plus_integer_accept_dollars_col_name.x#2]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_scalar_arg_plus_integer_accept_dollars_col_name.x#2]
        +-tvf=tvf_templated_scalar_arg_plus_integer_accept_dollars_col_name((ANY TYPE) -> ANY TABLE)
        +-signature=(BOOL) -> TABLE<x BOOL>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-SubqueryExpr
        |       +-type=BOOL
        |       +-subquery_type=SCALAR
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$expr_subquery.$col1#1]
        |           +-expr_list=
        |           | +-$col1#1 := Parameter(type=BOOL, name="test_param_bool")
        |           +-input_scan=
        |             +-SingleRowScan
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_scalar_arg_plus_integer_accept_dollars_col_name(BOOL) -> TABLE<x BOOL>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1]
    +-expr_list=
    | +-x#1 := ArgumentRef(type=BOOL, name="$col1")
    +-input_scan=
      +-SingleRowScan
==

# Call a templated SQL TVF that calls another templated SQL TVF.
select * from tvf_call_tvf_templated_select_one();
--
QueryStmt
+-output_column_list=
| +-tvf_call_tvf_templated_select_one.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_call_tvf_templated_select_one.x#1]
    +-input_scan=
      +-TVFScan(column_list=[tvf_call_tvf_templated_select_one.x#1], tvf=tvf_call_tvf_templated_select_one(() -> ANY TABLE), signature=() -> TABLE<x INT64>, column_index_list=[0])

With Templated SQL TVF signature:
  tvf_call_tvf_templated_select_one() -> TABLE<x INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-tvf_templated_select_one.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_one.x#1]
    +-input_scan=
      +-TVFScan(column_list=[tvf_templated_select_one.x#1], tvf=tvf_templated_select_one(() -> ANY TABLE), signature=() -> TABLE<x INT64>, column_index_list=[0])

With Templated SQL TVF signature:
  tvf_templated_select_one() -> TABLE<x INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1]
    +-expr_list=
    | +-x#1 := Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

# Call a templated SQL TVF that calls another templated SQL TVF twice.
select * from tvf_call_tvf_templated_select_one_twice();
--
QueryStmt
+-output_column_list=
| +-tvf_call_tvf_templated_select_one_twice.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_call_tvf_templated_select_one_twice.x#1]
    +-input_scan=
      +-TVFScan(column_list=[tvf_call_tvf_templated_select_one_twice.x#1], tvf=tvf_call_tvf_templated_select_one_twice(() -> ANY TABLE), signature=() -> TABLE<x INT64>, column_index_list=[0])

With Templated SQL TVF signature:
  tvf_call_tvf_templated_select_one_twice() -> TABLE<x INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$union_all.x#3 AS x [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#3]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_templated_select_one.x#1]
      | |   +-input_scan=
      | |     +-TVFScan(column_list=[tvf_templated_select_one.x#1], tvf=tvf_templated_select_one(() -> ANY TABLE), signature=() -> TABLE<x INT64>, column_index_list=[0])
      | +-output_column_list=[tvf_templated_select_one.x#1]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[tvf_templated_select_one.x#2]
        |   +-input_scan=
        |     +-TVFScan(column_list=[tvf_templated_select_one.x#2], tvf=tvf_templated_select_one(() -> ANY TABLE), signature=() -> TABLE<x INT64>, column_index_list=[0])
        +-output_column_list=[tvf_templated_select_one.x#2]

With Templated SQL TVF signature:
  tvf_templated_select_one() -> TABLE<x INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1]
    +-expr_list=
    | +-x#1 := Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

# Call a templated SQL TVF that selects one field from a value table, using the
# TABLE keyword to provide the input table.
select * from tvf_templated_select_a(table TestStructValueTable)
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_a.a#2 AS a [INT32]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_a.a#2]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_a.a#2]
        +-tvf=tvf_templated_select_a((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<STRUCT<a INT32, b STRING>>) -> TABLE<a INT32>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0])
        |   +-argument_column_list=[TestStructValueTable.value#1]
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_a(TABLE<STRUCT<a INT32, b STRING>>) -> TABLE<a INT32>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.a#2 AS a [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.a#2]
    +-expr_list=
    | +-a#2 :=
    |   +-GetStructField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=x.$value_column#1)
    |     +-field_idx=0
    +-input_scan=
      +-RelationArgumentScan(column_list=[x.$value_column#1], name="x", is_value_table=TRUE)
==

# Call a templated SQL TVF that selects one field from a value table, using the
# TABLE keyword to provide the input table.
select * from tvf_templated_select_a(
    (select as value val from TestStructValueTable val))
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_a.a#2 AS a [INT32]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_a.a#2]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_a.a#2]
        +-tvf=tvf_templated_select_a((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<STRUCT<a INT32, b STRING>>) -> TABLE<a INT32>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[TestStructValueTable.value#1]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0], alias="val")
        |   +-argument_column_list=[TestStructValueTable.value#1]
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_a(TABLE<STRUCT<a INT32, b STRING>>) -> TABLE<a INT32>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.a#2 AS a [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.a#2]
    +-expr_list=
    | +-a#2 :=
    |   +-GetStructField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=x.$value_column#1)
    |     +-field_idx=0
    +-input_scan=
      +-RelationArgumentScan(column_list=[x.$value_column#1], name="x", is_value_table=TRUE)
==

# TVF call with "TABLE path(argument, ...)" syntax with a single nested relation
# argument that is not a value table.
select * from tvf_one_relation_arg_with_fixed_output(
    table tvf_one_relation_arg_with_fixed_output(
        (select cast(42 as bool))));
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#4 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        |   |   +-input_scan=
        |   |     +-TVFScan
        |   |       +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        |   |       +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   |       +-signature=(TABLE<$col1 BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   |       +-argument_list=
        |   |       | +-FunctionArgument
        |   |       |   +-scan=
        |   |       |   | +-ProjectScan
        |   |       |   |   +-column_list=[$subquery1.$col1#1]
        |   |       |   |   +-expr_list=
        |   |       |   |   | +-$col1#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |       |   |   +-input_scan=
        |   |       |   |     +-SingleRowScan
        |   |       |   +-argument_column_list=[$subquery1.$col1#1]
        |   |       +-column_index_list=[0, 1]
        |   +-argument_column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        +-column_index_list=[0, 1]
==

# TVF call with "TABLE path(argument, ...)" syntax with a single nested relation
# argument that uses the "TABLE path" syntax separately to refer to a table from
# the schema.
select * from tvf_one_relation_arg_with_fixed_output(
    table tvf_one_relation_arg_with_fixed_output(
        table KeyValue));
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#5 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#6 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#5, column_bytes#6]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#5, column_bytes#6]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#3, column_bytes#4]
        |   |   +-input_scan=
        |   |     +-TVFScan
        |   |       +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#3, column_bytes#4]
        |   |       +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   |       +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   |       +-argument_list=
        |   |       | +-FunctionArgument
        |   |       |   +-scan=
        |   |       |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   |       |   +-argument_column_list=KeyValue.[Key#1, Value#2]
        |   |       +-column_index_list=[0, 1]
        |   +-argument_column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#3, column_bytes#4]
        +-column_index_list=[0, 1]
==

# TVF call with "TABLE path(argument, ...)" syntax with a single nested relation
# argument that is a value table.
select * from tvf_one_relation_arg_with_fixed_output(
    table tvf_one_relation_arg_with_fixed_output(
        (select as value Key from KeyValue)));
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#5 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#6 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#5, column_bytes#6]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#5, column_bytes#6]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#3, column_bytes#4]
        |   |   +-input_scan=
        |   |     +-TVFScan
        |   |       +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#3, column_bytes#4]
        |   |       +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   |       +-signature=(TABLE<INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   |       +-argument_list=
        |   |       | +-FunctionArgument
        |   |       |   +-scan=
        |   |       |   | +-ProjectScan
        |   |       |   |   +-column_list=[KeyValue.Key#1]
        |   |       |   |   +-input_scan=
        |   |       |   |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |   |       |   +-argument_column_list=[KeyValue.Key#1]
        |   |       +-column_index_list=[0, 1]
        |   +-argument_column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#3, column_bytes#4]
        +-column_index_list=[0, 1]
==

# Double-nested TVF call with "TABLE path(argument, ...)" syntax.
select * from tvf_one_relation_arg_with_fixed_output(
    table tvf_one_relation_arg_with_fixed_output(
        table tvf_one_relation_arg_with_fixed_output(
            (select cast(42 as bool)))));
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#6 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#7 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#6, column_bytes#7]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#6, column_bytes#7]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
        |   |   +-input_scan=
        |   |     +-TVFScan
        |   |       +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
        |   |       +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   |       +-signature=(TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   |       +-argument_list=
        |   |       | +-FunctionArgument
        |   |       |   +-scan=
        |   |       |   | +-ProjectScan
        |   |       |   |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        |   |       |   |   +-input_scan=
        |   |       |   |     +-TVFScan
        |   |       |   |       +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        |   |       |   |       +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   |       |   |       +-signature=(TABLE<$col1 BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   |       |   |       +-argument_list=
        |   |       |   |       | +-FunctionArgument
        |   |       |   |       |   +-scan=
        |   |       |   |       |   | +-ProjectScan
        |   |       |   |       |   |   +-column_list=[$subquery1.$col1#1]
        |   |       |   |       |   |   +-expr_list=
        |   |       |   |       |   |   | +-$col1#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |       |   |       |   |   +-input_scan=
        |   |       |   |       |   |     +-SingleRowScan
        |   |       |   |       |   +-argument_column_list=[$subquery1.$col1#1]
        |   |       |   |       +-column_index_list=[0, 1]
        |   |       |   +-argument_column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        |   |       +-column_index_list=[0, 1]
        |   +-argument_column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
        +-column_index_list=[0, 1]
==

# TVF call with "TABLE path(argument, ...)" syntax with a templated TVF call
# with no nested arguments.
select * from tvf_one_relation_arg_with_fixed_output(
    table tvf_call_tvf_templated_select_one());
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<x INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[tvf_call_tvf_templated_select_one.x#1]
        |   |   +-input_scan=
        |   |     +-TVFScan(column_list=[tvf_call_tvf_templated_select_one.x#1], tvf=tvf_call_tvf_templated_select_one(() -> ANY TABLE), signature=() -> TABLE<x INT64>, column_index_list=[0])
        |   +-argument_column_list=[tvf_call_tvf_templated_select_one.x#1]
        +-column_index_list=[0, 1]

With Templated SQL TVF signature:
  tvf_call_tvf_templated_select_one() -> TABLE<x INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-tvf_templated_select_one.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_one.x#1]
    +-input_scan=
      +-TVFScan(column_list=[tvf_templated_select_one.x#1], tvf=tvf_templated_select_one(() -> ANY TABLE), signature=() -> TABLE<x INT64>, column_index_list=[0])

With Templated SQL TVF signature:
  tvf_templated_select_one() -> TABLE<x INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1]
    +-expr_list=
    | +-x#1 := Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

# TVF call with "TABLE path(argument, ...)" syntax for multiple relation
# arguments.
select mytvf, '--', mytvf.int32_val1, '--', int32_val1, '--', mytvf.*, '--', *
from tvf_two_relation_args_return_proto_value_table(
    table tvf_one_relation_arg_with_fixed_output(
        (select cast(42 as bool))),
    table tvf_one_relation_arg_with_fixed_output(
        (select cast(43 as bool)))) as mytvf;
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_return_proto_value_table.$col0#7 AS mytvf [PROTO<zetasql_test__.TestExtraPB>]
| +-$query.$col2#8 AS `$col2` [STRING]
| +-$query.int32_val1#9 AS int32_val1 [INT32]
| +-$query.$col4#10 AS `$col4` [STRING]
| +-$query.int32_val1#11 AS int32_val1 [INT32]
| +-$query.$col6#12 AS `$col6` [STRING]
| +-$query.int32_val1#13 AS int32_val1 [INT32]
| +-$query.int32_val2#14 AS int32_val2 [INT32]
| +-$query.str_value#15 AS str_value [ARRAY<STRING>]
| +-$query.$col8#16 AS `$col8` [STRING]
| +-$query.int32_val1#17 AS int32_val1 [INT32]
| +-$query.int32_val2#18 AS int32_val2 [INT32]
| +-$query.str_value#19 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#7, $query.$col2#8, $query.int32_val1#9, $query.$col4#10, $query.int32_val1#11, $query.$col6#12, $query.int32_val1#13, $query.int32_val2#14, $query.str_value#15, $query.$col8#16, $query.int32_val1#17, $query.int32_val2#18, $query.str_value#19]
    +-expr_list=
    | +-$col2#8 := Literal(type=STRING, value="--")
    | +-int32_val1#9 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#7)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-$col4#10 := Literal(type=STRING, value="--")
    | +-int32_val1#11 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#7)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-$col6#12 := Literal(type=STRING, value="--")
    | +-int32_val1#13 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#7)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-int32_val2#14 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#7)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#15 :=
    | | +-GetProtoField
    | |   +-type=ARRAY<STRING>
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#7)
    | |   +-field_descriptor=str_value
    | |   +-default_value=[]
    | +-$col8#16 := Literal(type=STRING, value="--")
    | +-int32_val1#17 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#7)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-int32_val2#18 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#7)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#19 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#7)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#7]
        +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
        +-signature=(TABLE<column_bool BOOL, column_bytes BYTES>, TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        | | |   +-input_scan=
        | | |     +-TVFScan
        | | |       +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        | | |       +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        | | |       +-signature=(TABLE<$col1 BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        | | |       +-argument_list=
        | | |       | +-FunctionArgument
        | | |       |   +-scan=
        | | |       |   | +-ProjectScan
        | | |       |   |   +-column_list=[$subquery1.$col1#1]
        | | |       |   |   +-expr_list=
        | | |       |   |   | +-$col1#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        | | |       |   |   +-input_scan=
        | | |       |   |     +-SingleRowScan
        | | |       |   +-argument_column_list=[$subquery1.$col1#1]
        | | |       +-column_index_list=[0, 1]
        | | +-argument_column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#5, column_bytes#6]
        |   |   +-input_scan=
        |   |     +-TVFScan
        |   |       +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#5, column_bytes#6]
        |   |       +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   |       +-signature=(TABLE<$col1 BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   |       +-argument_list=
        |   |       | +-FunctionArgument
        |   |       |   +-scan=
        |   |       |   | +-ProjectScan
        |   |       |   |   +-column_list=[$subquery2.$col1#4]
        |   |       |   |   +-expr_list=
        |   |       |   |   | +-$col1#4 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |       |   |   +-input_scan=
        |   |       |   |     +-SingleRowScan
        |   |       |   +-argument_column_list=[$subquery2.$col1#4]
        |   |       +-column_index_list=[0, 1]
        |   +-argument_column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#5, column_bytes#6]
        +-column_index_list=[0]
        +-alias="mytvf"
==

# TABLESAMPLE clause for TVF calls.
select * from tvf_one_relation_arg_with_fixed_output(
    (select cast(42 as bool) as bool_column))
tablesample reservoir (100 rows)
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-SampleScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        +-input_scan=
        | +-TVFScan
        |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   +-signature=(TABLE<bool_column BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   +-argument_list=
        |   | +-FunctionArgument
        |   |   +-scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$subquery1.bool_column#1]
        |   |   |   +-expr_list=
        |   |   |   | +-bool_column#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |   |   +-input_scan=
        |   |   |     +-SingleRowScan
        |   |   +-argument_column_list=[$subquery1.bool_column#1]
        |   +-column_index_list=[0, 1]
        +-method="reservoir"
        +-size=
        | +-Literal(type=INT64, value=100)
        +-unit=ROWS
==

# TABLESAMPLE clause for TVF calls with SYSTEM.
select * from tvf_one_relation_arg_with_fixed_output(
    (select cast(42 as bool) as bool_column))
tablesample system (100 rows)
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-SampleScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        +-input_scan=
        | +-TVFScan
        |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   +-signature=(TABLE<bool_column BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   +-argument_list=
        |   | +-FunctionArgument
        |   |   +-scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$subquery1.bool_column#1]
        |   |   |   +-expr_list=
        |   |   |   | +-bool_column#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |   |   +-input_scan=
        |   |   |     +-SingleRowScan
        |   |   +-argument_column_list=[$subquery1.bool_column#1]
        |   +-column_index_list=[0, 1]
        +-method="system"
        +-size=
        | +-Literal(type=INT64, value=100)
        +-unit=ROWS
==

# TABLESAMPLE clause for TVF calls with query parameter.
select * from tvf_one_relation_arg_with_fixed_output(
    (select cast(42 as bool) as bool_column))
tablesample reservoir (@test_param_int64 rows)
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-SampleScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        +-input_scan=
        | +-TVFScan
        |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   +-signature=(TABLE<bool_column BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   +-argument_list=
        |   | +-FunctionArgument
        |   |   +-scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$subquery1.bool_column#1]
        |   |   |   +-expr_list=
        |   |   |   | +-bool_column#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |   |   +-input_scan=
        |   |   |     +-SingleRowScan
        |   |   +-argument_column_list=[$subquery1.bool_column#1]
        |   +-column_index_list=[0, 1]
        +-method="reservoir"
        +-size=
        | +-Parameter(type=INT64, name="test_param_int64")
        +-unit=ROWS
==

# TABLESAMPLE clause for TVF calls with REPEATABLE option.
select * from tvf_one_relation_arg_with_fixed_output(
    (select cast(42 as bool) as bool_column))
tablesample reservoir (100 rows) repeatable(10)
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-SampleScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        +-input_scan=
        | +-TVFScan
        |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   +-signature=(TABLE<bool_column BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   +-argument_list=
        |   | +-FunctionArgument
        |   |   +-scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$subquery1.bool_column#1]
        |   |   |   +-expr_list=
        |   |   |   | +-bool_column#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |   |   +-input_scan=
        |   |   |     +-SingleRowScan
        |   |   +-argument_column_list=[$subquery1.bool_column#1]
        |   +-column_index_list=[0, 1]
        +-method="reservoir"
        +-size=
        | +-Literal(type=INT64, value=100)
        +-unit=ROWS
        +-repeatable_argument=
          +-Literal(type=INT64, value=10)
==

# TABLESAMPLE clause for TVF calls with PERCENT option.
select * from tvf_one_relation_arg_with_fixed_output(
    (select cast(42 as bool) as bool_column))
tablesample reservoir (0.1 percent) repeatable(10)
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-SampleScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        +-input_scan=
        | +-TVFScan
        |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
        |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |   +-signature=(TABLE<bool_column BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |   +-argument_list=
        |   | +-FunctionArgument
        |   |   +-scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$subquery1.bool_column#1]
        |   |   |   +-expr_list=
        |   |   |   | +-bool_column#1 := Literal(type=BOOL, value=true, has_explicit_type=TRUE)
        |   |   |   +-input_scan=
        |   |   |     +-SingleRowScan
        |   |   +-argument_column_list=[$subquery1.bool_column#1]
        |   +-column_index_list=[0, 1]
        +-method="reservoir"
        +-size=
        | +-Literal(type=DOUBLE, value=0.1)
        +-unit=PERCENT
        +-repeatable_argument=
          +-Literal(type=INT64, value=10)
==

# A TVF accepts one relation argument with one date column. A query passes a
# statement starting with a WITH clause for the relation argument.
select *
from tvf_one_relation_arg_one_date_input_column(
    (with w1 as (select `date` as mydate from simpletypes)
     select mydate from w1))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_one_date_input_column.column_bool#20 AS column_bool [BOOL]
| +-tvf_one_relation_arg_one_date_input_column.column_bytes#21 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_one_date_input_column.[column_bool#20, column_bytes#21]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_one_relation_arg_one_date_input_column.[column_bool#20, column_bytes#21]
        +-tvf=tvf_one_relation_arg_one_date_input_column((TABLE<mydate DATE>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<mydate DATE>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-WithScan
        |   |   +-column_list=[w1.mydate#19]
        |   |   +-with_entry_list=
        |   |   | +-WithEntry
        |   |   |   +-with_query_name="w1"
        |   |   |   +-with_subquery=
        |   |   |     +-ProjectScan
        |   |   |       +-column_list=[SimpleTypes.date#10]
        |   |   |       +-input_scan=
        |   |   |         +-TableScan(column_list=[SimpleTypes.date#10], table=SimpleTypes, column_index_list=[9])
        |   |   +-query=
        |   |     +-ProjectScan
        |   |       +-column_list=[w1.mydate#19]
        |   |       +-input_scan=
        |   |         +-WithRefScan(column_list=[w1.mydate#19], with_query_name="w1")
        |   +-argument_column_list=[w1.mydate#19]
        +-column_index_list=[0, 1]
==

# A TVF accepts one relation argument and sets the output schema to be equal to
# the input schema. A query calls the TVF passing a reference to the name of a
# WITH clause in the current scope.
with w as (select true as val)
select mytvf.column_bool
from tvf_one_relation_arg_with_fixed_output(table w) as mytvf
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#3 AS column_bool [BOOL]
+-query=
  +-WithScan
    +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#3]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="w"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[w.val#1]
    |       +-expr_list=
    |       | +-val#1 := Literal(type=BOOL, value=true)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#3]
        +-input_scan=
          +-TVFScan
            +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#3]
            +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
            +-signature=(TABLE<val BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
            +-argument_list=
            | +-FunctionArgument
            |   +-scan=
            |   | +-ProjectScan
            |   |   +-column_list=[w.val#2]
            |   |   +-input_scan=
            |   |     +-WithRefScan(column_list=[w.val#2], with_query_name="w")
            |   +-argument_column_list=[w.val#2]
            +-column_index_list=[0]
            +-alias="mytvf"
==

# A query calls a TVF passing a reference to a WITH clause that returns a value
# table.
with w as (select as value key from keyvalue)
select mytvf.column_bytes
from tvf_one_relation_arg_with_fixed_output(table w) as mytvf
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-WithScan
    +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bytes#5]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="w"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[KeyValue.Key#1]
    |       +-input_scan=
    |         +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-query=
      +-ProjectScan
        +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bytes#5]
        +-input_scan=
          +-TVFScan
            +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bytes#5]
            +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
            +-signature=(TABLE<INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
            +-argument_list=
            | +-FunctionArgument
            |   +-scan=
            |   | +-ProjectScan
            |   |   +-column_list=[w.$value_column#3]
            |   |   +-input_scan=
            |   |     +-WithRefScan(column_list=[w.$value_column#3], with_query_name="w")
            |   +-argument_column_list=[w.$value_column#3]
            +-column_index_list=[1]
            +-alias="mytvf"
==

# A query calls a TVF passing a reference to a WITH clause that returns a value
# table.
with w as (select t from TestStructValueTable t)
select mytvf.column_bool
from tvf_one_relation_arg_with_fixed_output(table w) as mytvf
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#3 AS column_bool [BOOL]
+-query=
  +-WithScan
    +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#3]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="w"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[TestStructValueTable.value#1]
    |       +-input_scan=
    |         +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0], alias="t")
    +-query=
      +-ProjectScan
        +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#3]
        +-input_scan=
          +-TVFScan
            +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#3]
            +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
            +-signature=(TABLE<t STRUCT<a INT32, b STRING>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
            +-argument_list=
            | +-FunctionArgument
            |   +-scan=
            |   | +-ProjectScan
            |   |   +-column_list=[w.t#2]
            |   |   +-input_scan=
            |   |     +-WithRefScan(column_list=[w.t#2], with_query_name="w")
            |   +-argument_column_list=[w.t#2]
            +-column_index_list=[0]
            +-alias="mytvf"
==

# A query calls a TVF passing a reference to a WITH clause that shadows a
# built-in table name.
with keyvalue as (select true as result)
select mytvf.column_bool
from tvf_one_relation_arg_with_fixed_output(table keyvalue) as mytvf
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#3 AS column_bool [BOOL]
+-query=
  +-WithScan
    +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#3]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="keyvalue"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[keyvalue.result#1]
    |       +-expr_list=
    |       | +-result#1 := Literal(type=BOOL, value=true)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#3]
        +-input_scan=
          +-TVFScan
            +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#3]
            +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
            +-signature=(TABLE<result BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
            +-argument_list=
            | +-FunctionArgument
            |   +-scan=
            |   | +-ProjectScan
            |   |   +-column_list=[keyvalue.result#2]
            |   |   +-input_scan=
            |   |     +-WithRefScan(column_list=[keyvalue.result#2], with_query_name="keyvalue")
            |   +-argument_column_list=[keyvalue.result#2]
            +-column_index_list=[0]
            +-alias="mytvf"
==

# The TVF is in a table subquery, and references a WITH clause from the
# enclosing query.
with w as (select key from keyvalue)
select * from (
    select * from tvf_one_relation_arg_with_fixed_output(table w))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#4 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-WithScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="w"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[KeyValue.Key#1]
    |       +-input_scan=
    |         +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-query=
      +-ProjectScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
        +-input_scan=
          +-ProjectScan
            +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
            +-input_scan=
              +-TVFScan
                +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
                +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                +-signature=(TABLE<key INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                +-argument_list=
                | +-FunctionArgument
                |   +-scan=
                |   | +-ProjectScan
                |   |   +-column_list=[w.key#3]
                |   |   +-input_scan=
                |   |     +-WithRefScan(column_list=[w.key#3], with_query_name="w")
                |   +-argument_column_list=[w.key#3]
                +-column_index_list=[0, 1]
==

# The TVF is in several nested levels of table subqueries, and references a
# WITH clause from the outermost enclosing query.
with w as (select key from keyvalue)
select * from (
    select * from (
        select * from (
            select * from (
                select * from tvf_one_relation_arg_with_fixed_output(
                    table w)))))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#4 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-WithScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="w"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[KeyValue.Key#1]
    |       +-input_scan=
    |         +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-query=
      +-ProjectScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
        +-input_scan=
          +-ProjectScan
            +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
            +-input_scan=
              +-ProjectScan
                +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
                +-input_scan=
                  +-ProjectScan
                    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
                    +-input_scan=
                      +-ProjectScan
                        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
                        +-input_scan=
                          +-TVFScan
                            +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
                            +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                            +-signature=(TABLE<key INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                            +-argument_list=
                            | +-FunctionArgument
                            |   +-scan=
                            |   | +-ProjectScan
                            |   |   +-column_list=[w.key#3]
                            |   |   +-input_scan=
                            |   |     +-WithRefScan(column_list=[w.key#3], with_query_name="w")
                            |   +-argument_column_list=[w.key#3]
                            +-column_index_list=[0, 1]
==

# The TVF is in a table subquery, and references a WITH clause from the same
# query.
select * from (
    with w as (select value from keyvalue)
    select * from tvf_one_relation_arg_with_fixed_output(table w))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#4 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
    +-input_scan=
      +-WithScan
        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="w"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=[KeyValue.Value#2]
        |       +-input_scan=
        |         +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
        +-query=
          +-ProjectScan
            +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
            +-input_scan=
              +-TVFScan
                +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
                +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                +-signature=(TABLE<value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                +-argument_list=
                | +-FunctionArgument
                |   +-scan=
                |   | +-ProjectScan
                |   |   +-column_list=[w.value#3]
                |   |   +-input_scan=
                |   |     +-WithRefScan(column_list=[w.value#3], with_query_name="w")
                |   +-argument_column_list=[w.value#3]
                +-column_index_list=[0, 1]
==

# The TVF is in a table subquery, and references a WITH clause from the same
# query as well as the enclosing query.
with w1 as (select key from keyvalue)
select * from (
    with w2 as (select value from keyvalue)
    select * from tvf_two_relation_args_return_proto_value_table(
        table w1, table w2))
--
QueryStmt
+-output_column_list=
| +-$subquery1.int32_val1#8 AS int32_val1 [INT32]
| +-$subquery1.int32_val2#9 AS int32_val2 [INT32]
| +-$subquery1.str_value#10 AS str_value [ARRAY<STRING>]
+-query=
  +-WithScan
    +-column_list=$subquery1.[int32_val1#8, int32_val2#9, str_value#10]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="w1"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[KeyValue.Key#1]
    |       +-input_scan=
    |         +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-query=
      +-ProjectScan
        +-column_list=$subquery1.[int32_val1#8, int32_val2#9, str_value#10]
        +-input_scan=
          +-WithScan
            +-column_list=$subquery1.[int32_val1#8, int32_val2#9, str_value#10]
            +-with_entry_list=
            | +-WithEntry
            |   +-with_query_name="w2"
            |   +-with_subquery=
            |     +-ProjectScan
            |       +-column_list=[KeyValue.Value#4]
            |       +-input_scan=
            |         +-TableScan(column_list=[KeyValue.Value#4], table=KeyValue, column_index_list=[1])
            +-query=
              +-ProjectScan
                +-column_list=$subquery1.[int32_val1#8, int32_val2#9, str_value#10]
                +-expr_list=
                | +-int32_val1#8 :=
                | | +-GetProtoField
                | |   +-type=INT32
                | |   +-expr=
                | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#7)
                | |   +-field_descriptor=int32_val1
                | |   +-default_value=0
                | +-int32_val2#9 :=
                | | +-GetProtoField
                | |   +-type=INT32
                | |   +-expr=
                | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#7)
                | |   +-field_descriptor=int32_val2
                | |   +-default_value=0
                | +-str_value#10 :=
                |   +-GetProtoField
                |     +-type=ARRAY<STRING>
                |     +-expr=
                |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_two_relation_args_return_proto_value_table.$col0#7)
                |     +-field_descriptor=str_value
                |     +-default_value=[]
                +-input_scan=
                  +-TVFScan
                    +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#7]
                    +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
                    +-signature=(TABLE<key INT64>, TABLE<value STRING>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
                    +-argument_list=
                    | +-FunctionArgument
                    | | +-scan=
                    | | | +-ProjectScan
                    | | |   +-column_list=[w1.key#5]
                    | | |   +-input_scan=
                    | | |     +-WithRefScan(column_list=[w1.key#5], with_query_name="w1")
                    | | +-argument_column_list=[w1.key#5]
                    | +-FunctionArgument
                    |   +-scan=
                    |   | +-ProjectScan
                    |   |   +-column_list=[w2.value#6]
                    |   |   +-input_scan=
                    |   |     +-WithRefScan(column_list=[w2.value#6], with_query_name="w2")
                    |   +-argument_column_list=[w2.value#6]
                    +-column_index_list=[0]
==

# The TVF is in an expression subquery, and references a WITH clause from the
# enclosing query.
with w as (select key from keyvalue)
select (select column_bytes
        from tvf_one_relation_arg_with_fixed_output(table w))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS `$col1` [BYTES]
+-query=
  +-WithScan
    +-column_list=[$query.$col1#6]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="w"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[KeyValue.Key#1]
    |       +-input_scan=
    |         +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-query=
      +-ProjectScan
        +-column_list=[$query.$col1#6]
        +-expr_list=
        | +-$col1#6 :=
        |   +-SubqueryExpr
        |     +-type=BYTES
        |     +-subquery_type=SCALAR
        |     +-subquery=
        |       +-ProjectScan
        |         +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bytes#5]
        |         +-input_scan=
        |           +-TVFScan
        |             +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bytes#5]
        |             +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |             +-signature=(TABLE<key INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |             +-argument_list=
        |             | +-FunctionArgument
        |             |   +-scan=
        |             |   | +-ProjectScan
        |             |   |   +-column_list=[w.key#3]
        |             |   |   +-input_scan=
        |             |   |     +-WithRefScan(column_list=[w.key#3], with_query_name="w")
        |             |   +-argument_column_list=[w.key#3]
        |             +-column_index_list=[1]
        +-input_scan=
          +-SingleRowScan
==

# The TVF is in an EXISTS subquery, and references a WITH clause from the
# enclosing query.
with w as (select key from keyvalue)
select * from keyvalue
where exists(select * from tvf_one_relation_arg_with_fixed_output(table w))
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#3 AS Key [INT64]
| +-KeyValue.Value#4 AS Value [STRING]
+-query=
  +-WithScan
    +-column_list=KeyValue.[Key#3, Value#4]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="w"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[KeyValue.Key#1]
    |       +-input_scan=
    |         +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-query=
      +-ProjectScan
        +-column_list=KeyValue.[Key#3, Value#4]
        +-input_scan=
          +-FilterScan
            +-column_list=KeyValue.[Key#3, Value#4]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
            +-filter_expr=
              +-SubqueryExpr
                +-type=BOOL
                +-subquery_type=EXISTS
                +-subquery=
                  +-ProjectScan
                    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#6, column_bytes#7]
                    +-input_scan=
                      +-TVFScan
                        +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#6, column_bytes#7]
                        +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                        +-signature=(TABLE<key INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                        +-argument_list=
                        | +-FunctionArgument
                        |   +-scan=
                        |   | +-ProjectScan
                        |   |   +-column_list=[w.key#5]
                        |   |   +-input_scan=
                        |   |     +-WithRefScan(column_list=[w.key#5], with_query_name="w")
                        |   +-argument_column_list=[w.key#5]
                        +-column_index_list=[0, 1]
==

with nested_catalog as (select true as val)
select mytvf.column_bool
from tvf_one_relation_arg_with_fixed_output(TABLE nested_catalog.KeyValue) as mytvf
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#4 AS column_bool [BOOL]
+-query=
  +-WithScan
    +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#4]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="nested_catalog"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[nested_catalog.val#1]
    |       +-expr_list=
    |       | +-val#1 := Literal(type=BOOL, value=true)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#4]
        +-input_scan=
          +-TVFScan
            +-column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#4]
            +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
            +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
            +-argument_list=
            | +-FunctionArgument
            |   +-scan=
            |   | +-TableScan(column_list=KeyValue.[Key#2, Value#3], table=KeyValue, column_index_list=[0, 1])
            |   +-argument_column_list=KeyValue.[Key#2, Value#3]
            +-column_index_list=[0]
            +-alias="mytvf"
==

# This tvf appends some columns to output schema. Check if a part of appended
# columns can be selected.
select mytvf.append_col_int64, mytvf.append_col_string
from tvf_append_columns((select 12 as key)) as mytvf
--
QueryStmt
+-output_column_list=
| +-tvf_append_columns.append_col_int64#3 AS append_col_int64 [INT64]
| +-tvf_append_columns.append_col_string#16 AS append_col_string [STRING]
+-query=
  +-ProjectScan
    +-column_list=tvf_append_columns.[append_col_int64#3, append_col_string#16]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_append_columns.[append_col_int64#3, append_col_string#16]
        +-tvf=tvf_append_columns((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<key INT64>) -> TABLE<key INT64, append_col_int64 INT64, append_col_int32 INT32, append_col_uint32 UINT32, append_col_uint64 UINT64, append_col_bytes BYTES, append_col_bool BOOL, append_col_float FLOAT, append_col_double DOUBLE, append_col_date DATE, append_col_timestamp TIMESTAMP, append_col_numeric NUMERIC, append_col_bignumeric BIGNUMERIC, append_col_json JSON, append_col_string STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.key#1]
        |   |   +-expr_list=
        |   |   | +-key#1 := Literal(type=INT64, value=12)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.key#1]
        +-column_index_list=[1, 14]
        +-alias="mytvf"
==

# This tvf appends some columns to output schema. Select all columns to
# check whether any appended column is missing.
select mytvf.append_col_int64, mytvf.append_col_string, mytvf.append_col_uint32,
mytvf.append_col_uint64, mytvf.append_col_int32, mytvf.append_col_bytes,
mytvf.append_col_bool, mytvf.append_col_float, mytvf.append_col_double,
mytvf.append_col_date, mytvf.append_col_timestamp, mytvf.append_col_numeric,
mytvf.append_col_bignumeric, mytvf.key
from tvf_append_columns((select 12 as key)) as mytvf
--
QueryStmt
+-output_column_list=
| +-tvf_append_columns.append_col_int64#3 AS append_col_int64 [INT64]
| +-tvf_append_columns.append_col_string#16 AS append_col_string [STRING]
| +-tvf_append_columns.append_col_uint32#5 AS append_col_uint32 [UINT32]
| +-tvf_append_columns.append_col_uint64#6 AS append_col_uint64 [UINT64]
| +-tvf_append_columns.append_col_int32#4 AS append_col_int32 [INT32]
| +-tvf_append_columns.append_col_bytes#7 AS append_col_bytes [BYTES]
| +-tvf_append_columns.append_col_bool#8 AS append_col_bool [BOOL]
| +-tvf_append_columns.append_col_float#9 AS append_col_float [FLOAT]
| +-tvf_append_columns.append_col_double#10 AS append_col_double [DOUBLE]
| +-tvf_append_columns.append_col_date#11 AS append_col_date [DATE]
| +-tvf_append_columns.append_col_timestamp#12 AS append_col_timestamp [TIMESTAMP]
| +-tvf_append_columns.append_col_numeric#13 AS append_col_numeric [NUMERIC]
| +-tvf_append_columns.append_col_bignumeric#14 AS append_col_bignumeric [BIGNUMERIC]
| +-tvf_append_columns.key#2 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=tvf_append_columns.[append_col_int64#3, append_col_string#16, append_col_uint32#5, append_col_uint64#6, append_col_int32#4, append_col_bytes#7, append_col_bool#8, append_col_float#9, append_col_double#10, append_col_date#11, append_col_timestamp#12, append_col_numeric#13, append_col_bignumeric#14, key#2]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_append_columns.[key#2, append_col_int64#3, append_col_int32#4, append_col_uint32#5, append_col_uint64#6, append_col_bytes#7, append_col_bool#8, append_col_float#9, append_col_double#10, append_col_date#11, append_col_timestamp#12, append_col_numeric#13, append_col_bignumeric#14, append_col_string#16]
        +-tvf=tvf_append_columns((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<key INT64>) -> TABLE<key INT64, append_col_int64 INT64, append_col_int32 INT32, append_col_uint32 UINT32, append_col_uint64 UINT64, append_col_bytes BYTES, append_col_bool BOOL, append_col_float FLOAT, append_col_double DOUBLE, append_col_date DATE, append_col_timestamp TIMESTAMP, append_col_numeric NUMERIC, append_col_bignumeric BIGNUMERIC, append_col_json JSON, append_col_string STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.key#1]
        |   |   +-expr_list=
        |   |   | +-key#1 := Literal(type=INT64, value=12)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.key#1]
        +-column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14]
        +-alias="mytvf"
==

# This tvf appends some columns to output schema. Select all columns to
# check whether any appended column is missing.
select *
from tvf_append_columns((select 12 as key));
--
QueryStmt
+-output_column_list=
| +-tvf_append_columns.key#2 AS key [INT64]
| +-tvf_append_columns.append_col_int64#3 AS append_col_int64 [INT64]
| +-tvf_append_columns.append_col_int32#4 AS append_col_int32 [INT32]
| +-tvf_append_columns.append_col_uint32#5 AS append_col_uint32 [UINT32]
| +-tvf_append_columns.append_col_uint64#6 AS append_col_uint64 [UINT64]
| +-tvf_append_columns.append_col_bytes#7 AS append_col_bytes [BYTES]
| +-tvf_append_columns.append_col_bool#8 AS append_col_bool [BOOL]
| +-tvf_append_columns.append_col_float#9 AS append_col_float [FLOAT]
| +-tvf_append_columns.append_col_double#10 AS append_col_double [DOUBLE]
| +-tvf_append_columns.append_col_date#11 AS append_col_date [DATE]
| +-tvf_append_columns.append_col_timestamp#12 AS append_col_timestamp [TIMESTAMP]
| +-tvf_append_columns.append_col_numeric#13 AS append_col_numeric [NUMERIC]
| +-tvf_append_columns.append_col_bignumeric#14 AS append_col_bignumeric [BIGNUMERIC]
| +-tvf_append_columns.append_col_json#15 AS append_col_json [JSON]
| +-tvf_append_columns.append_col_string#16 AS append_col_string [STRING]
+-query=
  +-ProjectScan
    +-column_list=tvf_append_columns.[key#2, append_col_int64#3, append_col_int32#4, append_col_uint32#5, append_col_uint64#6, append_col_bytes#7, append_col_bool#8, append_col_float#9, append_col_double#10, append_col_date#11, append_col_timestamp#12, append_col_numeric#13, append_col_bignumeric#14, append_col_json#15, append_col_string#16]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_append_columns.[key#2, append_col_int64#3, append_col_int32#4, append_col_uint32#5, append_col_uint64#6, append_col_bytes#7, append_col_bool#8, append_col_float#9, append_col_double#10, append_col_date#11, append_col_timestamp#12, append_col_numeric#13, append_col_bignumeric#14, append_col_json#15, append_col_string#16]
        +-tvf=tvf_append_columns((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<key INT64>) -> TABLE<key INT64, append_col_int64 INT64, append_col_int32 INT32, append_col_uint32 UINT32, append_col_uint64 UINT64, append_col_bytes BYTES, append_col_bool BOOL, append_col_float FLOAT, append_col_double DOUBLE, append_col_date DATE, append_col_timestamp TIMESTAMP, append_col_numeric NUMERIC, append_col_bignumeric BIGNUMERIC, append_col_json JSON, append_col_string STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.key#1]
        |   |   +-expr_list=
        |   |   | +-key#1 := Literal(type=INT64, value=12)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.key#1]
        +-column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
==

select * from tvf_append_no_column((select 12 as key));
--
QueryStmt
+-output_column_list=
| +-tvf_append_no_column.key#2 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_append_no_column.key#2]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_append_no_column.key#2]
        +-tvf=tvf_append_no_column((ANY TABLE) -> ANY TABLE)
        +-signature=(TABLE<key INT64>) -> TABLE<key INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.key#1]
        |   |   +-expr_list=
        |   |   | +-key#1 := Literal(type=INT64, value=12)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.key#1]
        +-column_index_list=[0]
==

# select columns from tvf when input table is templated.
select * from tvf_append_columns_any_relation_arg((select 1 as key))
--
QueryStmt
+-output_column_list=
| +-tvf_append_columns_any_relation_arg.key#2 AS key [INT64]
| +-tvf_append_columns_any_relation_arg.append_col_int32#3 AS append_col_int32 [INT32]
+-query=
  +-ProjectScan
    +-column_list=tvf_append_columns_any_relation_arg.[key#2, append_col_int32#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_append_columns_any_relation_arg.[key#2, append_col_int32#3]
        +-tvf=tvf_append_columns_any_relation_arg((ANY TABLE any_relation_arg) -> ANY TABLE)
        +-signature=(TABLE<key INT64>) -> TABLE<key INT64, append_col_int32 INT32>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.key#1]
        |   |   +-expr_list=
        |   |   | +-key#1 := Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.key#1]
        +-column_index_list=[0, 1]
==

# select columns from tvf when input table is templated and contains
# pseudo columns.
select * from tvf_append_columns_any_relation_arg(TABLE EnumTable)
--
QueryStmt
+-output_column_list=
| +-tvf_append_columns_any_relation_arg.key#6 AS key [INT32]
| +-tvf_append_columns_any_relation_arg.TestEnum#7 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-tvf_append_columns_any_relation_arg.AnotherTestEnum#8 AS AnotherTestEnum [ENUM<zetasql_test__.AnotherTestEnum>]
| +-tvf_append_columns_any_relation_arg.append_col_int32#9 AS append_col_int32 [INT32]
+-query=
  +-ProjectScan
    +-column_list=tvf_append_columns_any_relation_arg.[key#6, TestEnum#7, AnotherTestEnum#8, append_col_int32#9]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_append_columns_any_relation_arg.[key#6, TestEnum#7, AnotherTestEnum#8, append_col_int32#9]
        +-tvf=tvf_append_columns_any_relation_arg((ANY TABLE any_relation_arg) -> ANY TABLE)
        +-signature=(TABLE<key INT32, TestEnum ENUM<zetasql_test__.TestEnum>, AnotherTestEnum ENUM<zetasql_test__.AnotherTestEnum>>) -> TABLE<key INT32, TestEnum ENUM<zetasql_test__.TestEnum>, AnotherTestEnum ENUM<zetasql_test__.AnotherTestEnum>, append_col_int32 INT32>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3], table=EnumTable, column_index_list=[0, 1, 2])
        |   +-argument_column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3]
        +-column_index_list=[0, 1, 2, 3]
==

# This test illustrates the undesireable behavior from b/118904900. Both TVFs
# called by this have the same body: "select key from t where key < x". The TVF
# without the "no_schema" in its name has a schema specified for the table
# argument that does not include column 'x'. In all cases for that TVF, the 'x'
# path expression resolves to the scalar argument. The TVF with "no_schema" uses
# `ANY TABLE` instead of specifying a schema for the table argument. In that
# case, when the supplied subquery includes a column 'x' and the language
# feature FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES is off, the 'x' path
# expression is resolved to the column implied by scanning the table argument in
# the FROM clause. With FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES turned on,
# the 'x' path expression resolves to the scalar argument.
# When the argument table uses the column name 'y' instead, there is no
# difference.
[language_features={{TABLE_VALUED_FUNCTIONS|TABLE_VALUED_FUNCTIONS,FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES}}]
SELECT * FROM tvf_templated_select_scalar_and_relation_args{{|_no_schema}}(
    /*x=*/33, (SELECT 1 AS key, 2 as {{x|y}}));
--
ALTERNATION GROUPS:
    TABLE_VALUED_FUNCTIONS,,x
    TABLE_VALUED_FUNCTIONS,FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES,,x
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_scalar_and_relation_args.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_scalar_and_relation_args.key#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_scalar_and_relation_args.key#3]
        +-tvf=tvf_templated_select_scalar_and_relation_args((INT64, TABLE<key INT64>) -> ANY TABLE)
        +-signature=(literal INT64, TABLE<key INT64>) -> TABLE<key INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=33)
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.key#1]
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=$subquery1.[key#1, x#2]
        |   |       +-expr_list=
        |   |       | +-key#1 := Literal(type=INT64, value=1)
        |   |       | +-x#2 := Literal(type=INT64, value=2)
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-argument_column_list=[$subquery1.key#1]
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_scalar_and_relation_args(literal INT64, TABLE<key INT64>) -> TABLE<key INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[t.key#1]
    +-input_scan=
      +-FilterScan
        +-column_list=[t.key#1]
        +-input_scan=
        | +-RelationArgumentScan(column_list=[t.key#1], name="t")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=t.key#1)
            +-ArgumentRef(type=INT64, name="x")
--
ALTERNATION GROUPS:
    TABLE_VALUED_FUNCTIONS,,y
    TABLE_VALUED_FUNCTIONS,FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES,,y
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_scalar_and_relation_args.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_scalar_and_relation_args.key#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_scalar_and_relation_args.key#3]
        +-tvf=tvf_templated_select_scalar_and_relation_args((INT64, TABLE<key INT64>) -> ANY TABLE)
        +-signature=(literal INT64, TABLE<key INT64>) -> TABLE<key INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=33)
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.key#1]
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=$subquery1.[key#1, y#2]
        |   |       +-expr_list=
        |   |       | +-key#1 := Literal(type=INT64, value=1)
        |   |       | +-y#2 := Literal(type=INT64, value=2)
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-argument_column_list=[$subquery1.key#1]
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_scalar_and_relation_args(literal INT64, TABLE<key INT64>) -> TABLE<key INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[t.key#1]
    +-input_scan=
      +-FilterScan
        +-column_list=[t.key#1]
        +-input_scan=
        | +-RelationArgumentScan(column_list=[t.key#1], name="t")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=t.key#1)
            +-ArgumentRef(type=INT64, name="x")
--
ALTERNATION GROUP: TABLE_VALUED_FUNCTIONS,_no_schema,x
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_scalar_and_relation_args_no_schema.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_scalar_and_relation_args_no_schema.key#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_scalar_and_relation_args_no_schema.key#3]
        +-tvf=tvf_templated_select_scalar_and_relation_args_no_schema((INT64, ANY TABLE) -> ANY TABLE)
        +-signature=(literal INT64, TABLE<key INT64, x INT64>) -> TABLE<key INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=33)
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[key#1, x#2]
        |   |   +-expr_list=
        |   |   | +-key#1 := Literal(type=INT64, value=1)
        |   |   | +-x#2 := Literal(type=INT64, value=2)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[key#1, x#2]
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_scalar_and_relation_args_no_schema(literal INT64, TABLE<key INT64, x INT64>) -> TABLE<key INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[t.key#1]
    +-input_scan=
      +-FilterScan
        +-column_list=t.[key#1, x#2]
        +-input_scan=
        | +-RelationArgumentScan(column_list=t.[key#1, x#2], name="t")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=t.key#1)
            +-ColumnRef(type=INT64, column=t.x#2)
--
ALTERNATION GROUPS:
    TABLE_VALUED_FUNCTIONS,_no_schema,y
    TABLE_VALUED_FUNCTIONS,FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES,_no_schema,y
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_scalar_and_relation_args_no_schema.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_scalar_and_relation_args_no_schema.key#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_scalar_and_relation_args_no_schema.key#3]
        +-tvf=tvf_templated_select_scalar_and_relation_args_no_schema((INT64, ANY TABLE) -> ANY TABLE)
        +-signature=(literal INT64, TABLE<key INT64, y INT64>) -> TABLE<key INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=33)
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[key#1, y#2]
        |   |   +-expr_list=
        |   |   | +-key#1 := Literal(type=INT64, value=1)
        |   |   | +-y#2 := Literal(type=INT64, value=2)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[key#1, y#2]
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_scalar_and_relation_args_no_schema(literal INT64, TABLE<key INT64, y INT64>) -> TABLE<key INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[t.key#1]
    +-input_scan=
      +-FilterScan
        +-column_list=[t.key#1]
        +-input_scan=
        | +-RelationArgumentScan(column_list=[t.key#1], name="t")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=t.key#1)
            +-ArgumentRef(type=INT64, name="x")
--
ALTERNATION GROUP: TABLE_VALUED_FUNCTIONS,FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES,_no_schema,x
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_scalar_and_relation_args_no_schema.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_scalar_and_relation_args_no_schema.key#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_scalar_and_relation_args_no_schema.key#3]
        +-tvf=tvf_templated_select_scalar_and_relation_args_no_schema((INT64, ANY TABLE) -> ANY TABLE)
        +-signature=(literal INT64, TABLE<key INT64, x INT64>) -> TABLE<key INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=33)
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[key#1, x#2]
        |   |   +-expr_list=
        |   |   | +-key#1 := Literal(type=INT64, value=1)
        |   |   | +-x#2 := Literal(type=INT64, value=2)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[key#1, x#2]
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_scalar_and_relation_args_no_schema(literal INT64, TABLE<key INT64, x INT64>) -> TABLE<key INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[t.key#1]
    +-input_scan=
      +-FilterScan
        +-column_list=[t.key#1]
        +-input_scan=
        | +-RelationArgumentScan(column_list=[t.key#1], name="t")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=t.key#1)
            +-ArgumentRef(type=INT64, name="x")
==

# A function where the SELECT list path expression could resolve to a qualifed
# struct field (for an argument struct) or a qualified column name (for a table
# scanned in the FROM clause). The FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES
# language feature changes resolution from the column case to the struct field
# case when enabled.
[language_features={{TABLE_VALUED_FUNCTIONS|TABLE_VALUED_FUNCTIONS,FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES}}]
SELECT * FROM tvf_templated_with_struct_param(STRUCT(1 as y, "2" as z),
                                              (select 3 as {{y|a}}, "4" as z));
--
ALTERNATION GROUP: TABLE_VALUED_FUNCTIONS,y
--
QueryStmt
+-output_column_list=
| +-tvf_templated_with_struct_param.y#3 AS y [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_with_struct_param.y#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_with_struct_param.y#3]
        +-tvf=tvf_templated_with_struct_param((STRUCT<y INT64, z STRING>, ANY TABLE) -> ANY TABLE)
        +-signature=(STRUCT<y INT64, z STRING>, TABLE<y INT64, z STRING>) -> TABLE<y INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRUCT<y INT64, z STRING>, value={y:1, z:"2"})
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[y#1, z#2]
        |   |   +-expr_list=
        |   |   | +-y#1 := Literal(type=INT64, value=3)
        |   |   | +-z#2 := Literal(type=STRING, value="4")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[y#1, z#2]
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_with_struct_param(STRUCT<y INT64, z STRING>, TABLE<y INT64, z STRING>) -> TABLE<y INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.y#1 AS y [INT64]
+-query=
  +-ProjectScan
    +-column_list=[t.y#1]
    +-input_scan=
      +-RelationArgumentScan(column_list=[t.y#1], name="t")
--
ALTERNATION GROUP: TABLE_VALUED_FUNCTIONS,a
--
ERROR: Invalid table-valued function tvf_templated_with_struct_param [at 1:15]
SELECT * FROM tvf_templated_with_struct_param(STRUCT(1 as y, "2" as z),
              ^
Analysis of table-valued function tvf_templated_with_struct_param failed [at 1:10]
select x.y from t as x
         ^
Name y not found inside x [at 1:10]
select x.y from t as x
         ^
--
ALTERNATION GROUP: TABLE_VALUED_FUNCTIONS,FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES,y
--
QueryStmt
+-output_column_list=
| +-tvf_templated_with_struct_param.y#3 AS y [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_with_struct_param.y#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_with_struct_param.y#3]
        +-tvf=tvf_templated_with_struct_param((STRUCT<y INT64, z STRING>, ANY TABLE) -> ANY TABLE)
        +-signature=(STRUCT<y INT64, z STRING>, TABLE<y INT64, z STRING>) -> TABLE<y INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRUCT<y INT64, z STRING>, value={y:1, z:"2"})
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[y#1, z#2]
        |   |   +-expr_list=
        |   |   | +-y#1 := Literal(type=INT64, value=3)
        |   |   | +-z#2 := Literal(type=STRING, value="4")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[y#1, z#2]
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_with_struct_param(STRUCT<y INT64, z STRING>, TABLE<y INT64, z STRING>) -> TABLE<y INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.y#3 AS y [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.y#3]
    +-expr_list=
    | +-y#3 :=
    |   +-GetStructField
    |     +-type=INT64
    |     +-expr=
    |     | +-ArgumentRef(type=STRUCT<y INT64, z STRING>, name="x")
    |     +-field_idx=0
    +-input_scan=
      +-RelationArgumentScan(name="t")
--
ALTERNATION GROUP: TABLE_VALUED_FUNCTIONS,FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES,a
--
QueryStmt
+-output_column_list=
| +-tvf_templated_with_struct_param.y#3 AS y [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_with_struct_param.y#3]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_with_struct_param.y#3]
        +-tvf=tvf_templated_with_struct_param((STRUCT<y INT64, z STRING>, ANY TABLE) -> ANY TABLE)
        +-signature=(STRUCT<y INT64, z STRING>, TABLE<a INT64, z STRING>) -> TABLE<y INT64>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRUCT<y INT64, z STRING>, value={y:1, z:"2"})
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[a#1, z#2]
        |   |   +-expr_list=
        |   |   | +-a#1 := Literal(type=INT64, value=3)
        |   |   | +-z#2 := Literal(type=STRING, value="4")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[a#1, z#2]
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_with_struct_param(STRUCT<y INT64, z STRING>, TABLE<a INT64, z STRING>) -> TABLE<y INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.y#3 AS y [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.y#3]
    +-expr_list=
    | +-y#3 :=
    |   +-GetStructField
    |     +-type=INT64
    |     +-expr=
    |     | +-ArgumentRef(type=STRUCT<y INT64, z STRING>, name="x")
    |     +-field_idx=0
    +-input_scan=
      +-RelationArgumentScan(name="t")
==

# TVF alias can be used to unnest the array in the result schema.
with t as (select 7 a, [3, 4] b)
select *
from tvf_one_relation_arg_output_schema_is_input_schema(table t) t0, t0.b
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.a#5 AS a [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema.b#6 AS b [ARRAY<INT64>]
| +-$array.b#7 AS b [INT64]
+-query=
  +-WithScan
    +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.a#5, tvf_one_relation_arg_output_schema_is_input_schema.b#6, $array.b#7]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t.[a#1, b#2]
    |       +-expr_list=
    |       | +-a#1 := Literal(type=INT64, value=7)
    |       | +-b#2 := Literal(type=ARRAY<INT64>, value=[3, 4])
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.a#5, tvf_one_relation_arg_output_schema_is_input_schema.b#6, $array.b#7]
        +-input_scan=
          +-ArrayScan
            +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.a#5, tvf_one_relation_arg_output_schema_is_input_schema.b#6, $array.b#7]
            +-input_scan=
            | +-TVFScan
            |   +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[a#5, b#6]
            |   +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
            |   +-signature=(TABLE<a INT64, b ARRAY<INT64>>) -> TABLE<a INT64, b ARRAY<INT64>>
            |   +-argument_list=
            |   | +-FunctionArgument
            |   |   +-scan=
            |   |   | +-ProjectScan
            |   |   |   +-column_list=t.[a#3, b#4]
            |   |   |   +-input_scan=
            |   |   |     +-WithRefScan(column_list=t.[a#3, b#4], with_query_name="t")
            |   |   +-argument_column_list=t.[a#3, b#4]
            |   +-column_index_list=[0, 1]
            |   +-alias="t0"
            +-array_expr=
            | +-ColumnRef(type=ARRAY<INT64>, column=tvf_one_relation_arg_output_schema_is_input_schema.b#6)
            +-element_column=$array.b#7
==

# Test with a named optional table after other optional scalars.
select * from tvf_optional_scalars_named_table('foo', 'bar', (select 1))
--
QueryStmt
+-output_column_list=
| +-tvf_optional_scalars_named_table.column_bool#2 AS column_bool [BOOL]
| +-tvf_optional_scalars_named_table.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_optional_scalars_named_table.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_optional_scalars_named_table.[column_bool#2, column_bytes#3]
        +-tvf=tvf_optional_scalars_named_table((optional ANY TYPE, optional ANY TYPE, optional ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal STRING, literal STRING, TABLE<$col1 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="foo")
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="bar")
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.$col1#1]
        |   |   +-expr_list=
        |   |   | +-$col1#1 := Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.$col1#1]
        +-column_index_list=[0, 1]
==

# Test with a named optional table after other optional scalars.
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_optional_scalars_named_table('foo', 'bar', foobar=>(select 1))
--
QueryStmt
+-output_column_list=
| +-tvf_optional_scalars_named_table.column_bool#2 AS column_bool [BOOL]
| +-tvf_optional_scalars_named_table.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_optional_scalars_named_table.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_optional_scalars_named_table.[column_bool#2, column_bytes#3]
        +-tvf=tvf_optional_scalars_named_table((optional ANY TYPE, optional ANY TYPE, optional ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal STRING, literal STRING, TABLE<$col1 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="foo")
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="bar")
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.$col1#1]
        |   |   +-expr_list=
        |   |   | +-$col1#1 := Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.$col1#1]
        +-column_index_list=[0, 1]
==

# Test with a named optional table after other optional scalars.
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_optional_scalars_named_table(foobar=>(select 1))
--
QueryStmt
+-output_column_list=
| +-tvf_optional_scalars_named_table.column_bool#2 AS column_bool [BOOL]
| +-tvf_optional_scalars_named_table.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_optional_scalars_named_table.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_optional_scalars_named_table.[column_bool#2, column_bytes#3]
        +-tvf=tvf_optional_scalars_named_table((optional ANY TYPE, optional ANY TYPE, optional ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(null INT64, null INT64, TABLE<$col1 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=NULL)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=NULL)
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.$col1#1]
        |   |   +-expr_list=
        |   |   | +-$col1#1 := Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.$col1#1]
        +-column_index_list=[0, 1]
==

# Test with a named optional table after other optional scalars.
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_optional_scalars_named_table('foo')
--
QueryStmt
+-output_column_list=
| +-tvf_optional_scalars_named_table.column_bool#1 AS column_bool [BOOL]
| +-tvf_optional_scalars_named_table.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_optional_scalars_named_table.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_optional_scalars_named_table.[column_bool#1, column_bytes#2]
        +-tvf=tvf_optional_scalars_named_table((optional ANY TYPE, optional ANY TYPE, optional ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="foo")
        +-column_index_list=[0, 1]
==

# Test with a named optional table after other optional scalars.
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_table_optional_scalar_named_table((select 2), 'foo',
                                                    (select 1))
--
QueryStmt
+-output_column_list=
| +-tvf_table_optional_scalar_named_table.column_bool#3 AS column_bool [BOOL]
| +-tvf_table_optional_scalar_named_table.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_table_optional_scalar_named_table.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_table_optional_scalar_named_table.[column_bool#3, column_bytes#4]
        +-tvf=tvf_table_optional_scalar_named_table((ANY TABLE, optional ANY TYPE, optional ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<$col1 INT64>, literal STRING, TABLE<$col1 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery1.$col1#1]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=INT64, value=2)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery1.$col1#1]
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="foo")
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery2.$col1#2]
        |   |   +-expr_list=
        |   |   | +-$col1#2 := Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery2.$col1#2]
        +-column_index_list=[0, 1]
==

# Test with a named optional table after other optional scalars.
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_table_optional_scalar_named_table((select 2),
                                                    foobar=>(select 1))
--
QueryStmt
+-output_column_list=
| +-tvf_table_optional_scalar_named_table.column_bool#3 AS column_bool [BOOL]
| +-tvf_table_optional_scalar_named_table.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_table_optional_scalar_named_table.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_table_optional_scalar_named_table.[column_bool#3, column_bytes#4]
        +-tvf=tvf_table_optional_scalar_named_table((ANY TABLE, optional ANY TYPE, optional ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<$col1 INT64>, null INT64, TABLE<$col1 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery1.$col1#1]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=INT64, value=2)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery1.$col1#1]
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=NULL)
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery2.$col1#2]
        |   |   +-expr_list=
        |   |   | +-$col1#2 := Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery2.$col1#2]
        +-column_index_list=[0, 1]
==

# Test with a optional table before a mandatory named string with default value.
# TODO: SQLBuilder turned off due to lack of support for mandatory
# argument names.
[no_run_unparser]
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_optional_table_default_mandatory_string((select 'a'),
                                                          foobar=>(select 'b'))
--
QueryStmt
+-output_column_list=
| +-tvf_optional_table_default_mandatory_string.column_bool#3 AS column_bool [BOOL]
| +-tvf_optional_table_default_mandatory_string.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_optional_table_default_mandatory_string.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_optional_table_default_mandatory_string.[column_bool#3, column_bytes#4]
        +-tvf=tvf_optional_table_default_mandatory_string((optional ANY TABLE, optional STRING {default_value: "default"} foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<$col1 STRING>, STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery1.$col1#1]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=STRING, value="a")
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery1.$col1#1]
        | +-FunctionArgument
        |   +-expr=
        |     +-SubqueryExpr
        |       +-type=STRING
        |       +-subquery_type=SCALAR
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$expr_subquery.$col1#2]
        |           +-expr_list=
        |           | +-$col1#2 := Literal(type=STRING, value="b")
        |           +-input_scan=
        |             +-SingleRowScan
        +-column_index_list=[0, 1]
==

# Test with a optional table before a mandatory named string with default value.
# TODO: SQLBuilder turned off due to lack of support for mandatory
# argument names.
[no_run_unparser]
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_optional_table_default_mandatory_string((select 'a'))
--
QueryStmt
+-output_column_list=
| +-tvf_optional_table_default_mandatory_string.column_bool#2 AS column_bool [BOOL]
| +-tvf_optional_table_default_mandatory_string.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_optional_table_default_mandatory_string.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_optional_table_default_mandatory_string.[column_bool#2, column_bytes#3]
        +-tvf=tvf_optional_table_default_mandatory_string((optional ANY TABLE, optional STRING {default_value: "default"} foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<$col1 STRING>, literal STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery1.$col1#1]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=STRING, value="a")
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery1.$col1#1]
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="default")
        +-column_index_list=[0, 1]
==

# Test with a required, mandatory, optional and named tables.
# TODO: SQLBuilder turned off due to lack of support for mandatory
# argument names.
[no_run_unparser]
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_required_named_optional_required_tables((select '1'),
                                                          table2=>(select '2'),
                                                          table3=>(select '3'),
                                                          table4=>(select '4'))
--
QueryStmt
+-output_column_list=
| +-tvf_required_named_optional_required_tables.column_bool#5 AS column_bool [BOOL]
| +-tvf_required_named_optional_required_tables.column_bytes#6 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_required_named_optional_required_tables.[column_bool#5, column_bytes#6]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_required_named_optional_required_tables.[column_bool#5, column_bytes#6]
        +-tvf=tvf_required_named_optional_required_tables((ANY TABLE, ANY TABLE table2, optional ANY TABLE table3, optional ANY TABLE table4) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<$col1 STRING>, TABLE<$col1 STRING>, TABLE<$col1 STRING>, TABLE<$col1 STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery1.$col1#1]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=STRING, value="1")
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery1.$col1#1]
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery2.$col1#2]
        | | |   +-expr_list=
        | | |   | +-$col1#2 := Literal(type=STRING, value="2")
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery2.$col1#2]
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery3.$col1#3]
        | | |   +-expr_list=
        | | |   | +-$col1#3 := Literal(type=STRING, value="3")
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery3.$col1#3]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery4.$col1#4]
        |   |   +-expr_list=
        |   |   | +-$col1#4 := Literal(type=STRING, value="4")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery4.$col1#4]
        +-column_index_list=[0, 1]
==

# Test with a required, mandatory, optional and named tables.
# naming them in the wrong order, which should still work.
# TODO: SQLBuilder turned off due to lack of support for mandatory
# argument names.
[no_run_unparser]
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_required_named_optional_required_tables((select '1'),
                                                          table4=>(select '4'),
                                                          table3=>(select '3'),
                                                          table2=>(select '2'))
--
QueryStmt
+-output_column_list=
| +-tvf_required_named_optional_required_tables.column_bool#5 AS column_bool [BOOL]
| +-tvf_required_named_optional_required_tables.column_bytes#6 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_required_named_optional_required_tables.[column_bool#5, column_bytes#6]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_required_named_optional_required_tables.[column_bool#5, column_bytes#6]
        +-tvf=tvf_required_named_optional_required_tables((ANY TABLE, ANY TABLE table2, optional ANY TABLE table3, optional ANY TABLE table4) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<$col1 STRING>, TABLE<$col1 STRING>, TABLE<$col1 STRING>, TABLE<$col1 STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery1.$col1#1]
        | | |   +-expr_list=
        | | |   | +-$col1#1 := Literal(type=STRING, value="1")
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery1.$col1#1]
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery4.$col1#4]
        | | |   +-expr_list=
        | | |   | +-$col1#4 := Literal(type=STRING, value="2")
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery4.$col1#4]
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery3.$col1#3]
        | | |   +-expr_list=
        | | |   | +-$col1#3 := Literal(type=STRING, value="3")
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery3.$col1#3]
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery2.$col1#2]
        |   |   +-expr_list=
        |   |   | +-$col1#2 := Literal(type=STRING, value="4")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery2.$col1#2]
        +-column_index_list=[0, 1]
==

################################################################################
#
# Negative test cases
#
################################################################################
#
# A query attempts to call a TVF with one relation argument with one date
# column, but the user forgets to include separate parentheses for the subquery
# in the relation argument.
select *
from tvf_one_relation_arg_one_date_input_column(
    select `date` as mydate from simpletypes)
--
ERROR: Syntax error: Each subquery argument for table-valued function calls must be enclosed in parentheses. To fix this, replace SELECT... with (SELECT...) [at 3:5]
    select `date` as mydate from simpletypes)
    ^
==

# A TVF accepts one relation argument. The relation argument attempts to use a
# correlation reference to the enclosing query, but this is not allowed.
select 1 as x, 2 as y, (select column_int64, x, y
                        from tvf_one_relation_arg_with_fixed_output(
                            (select cast(42 as int64) as column_int64, x, y)))
--
ERROR: Unrecognized name: x [at 3:72]
                            (select cast(42 as int64) as column_int64, x, y)))
                                                                       ^
==

# A TVF accepts one relation argument. The relation argument attempts to refer
# to previous columns in the same FROM clause, but this is not allowed.
select column_int64
from (select 1 as x, 2 as y)
join tvf_one_relation_arg_with_fixed_output(
         (select cast(42 as int64) as column_int64, x, y))
on (true)
--
ERROR: Unrecognized name: x [at 4:53]
         (select cast(42 as int64) as column_int64, x, y))
                                                    ^
==

# A TVF accepts two relation arguments, but the query passes two scalar values
# instead.
select column_bytes from tvf_two_relation_args(1, 2)
--
ERROR: Table-valued function tvf_two_relation_args argument 1 must be a relation (i.e. table subquery) [at 1:48]
select column_bytes from tvf_two_relation_args(1, 2)
                                               ^
==

# A TVF accepts one relation argument, but the query passes a scalar argument
# instead.
select * from tvf_one_relation_arg_output_schema_is_input_schema("abc")
--
ERROR: Table-valued function tvf_one_relation_arg_output_schema_is_input_schema argument 1 must be a relation (i.e. table subquery) [at 1:66]
select * from tvf_one_relation_arg_output_schema_is_input_schema("abc")
                                                                 ^
==

# A TVF accepts one relation argument. The query attempts to pass an entire
# table by simply naming it, but this syntax is not supported.
select * from tvf_one_relation_arg_output_schema_is_input_schema(keyvalue)
--
ERROR: Table-valued function tvf_one_relation_arg_output_schema_is_input_schema argument 1 must be a relation (i.e. table subquery); if you meant to refer to table keyvalue then add the TABLE keyword before the table name (i.e. TABLE keyvalue) [at 1:66]
select * from tvf_one_relation_arg_output_schema_is_input_schema(keyvalue)
                                                                 ^
==

# A TVF accepts one relation argument and one scalar argument, but the query
# only passes one relation argument.
select column_bytes from tvf_one_relation_arg_one_int64_arg((select 1, 2))
--
ERROR: No matching signature for tvf_one_relation_arg_one_int64_arg for argument types: TABLE<$col1 INT64, $col2 INT64>. Supported signature: TVF_ONE_RELATION_ARG_ONE_INT64_ARG(TABLE, INT64) [at 1:26]
select column_bytes from tvf_one_relation_arg_one_int64_arg((select 1, 2))
                         ^
==

# A TVF accepts one relation argument and one scalar argument, but the query
# passes two relation arguments instead.
select column_bytes from tvf_one_relation_arg_one_int64_arg(
    (select 1, 2), (select 3, 4))
--
ERROR: Scalar subquery cannot have more than one column unless using SELECT AS STRUCT to build STRUCT values [at 2:20]
    (select 1, 2), (select 3, 4))
                   ^
==

# A TVF accepts one relation argument and one scalar argument, but the query
# passes two scalar arguments instead.
select column_bytes from tvf_one_relation_arg_one_int64_arg(
    array[1], 2)
--
ERROR: Table-valued function tvf_one_relation_arg_one_int64_arg argument 1 must be a relation (i.e. table subquery) [at 2:5]
    array[1], 2)
    ^
==

# A TVF accepts one relation argument and one scalar argument, but the query
# passes two scalar arguments instead.
select column_bytes from tvf_one_relation_arg_one_int64_arg(1, 2)
--
ERROR: Table-valued function tvf_one_relation_arg_one_int64_arg argument 1 must be a relation (i.e. table subquery) [at 1:61]
select column_bytes from tvf_one_relation_arg_one_int64_arg(1, 2)
                                                            ^
==

# A TVF accepts one relation argument and one scalar argument, but the query
# passes one relation argument and two scalar arguments instead.
select column_bytes from tvf_one_relation_arg_one_int64_arg(
    (select 1, 2), 3, 4)
--
ERROR: No matching signature for tvf_one_relation_arg_one_int64_arg for argument types: TABLE<$col1 INT64, $col2 INT64>, INT64, INT64. Supported signature: TVF_ONE_RELATION_ARG_ONE_INT64_ARG(TABLE, INT64) [at 1:26]
select column_bytes from tvf_one_relation_arg_one_int64_arg(
                         ^
==

# A TVF accepts one relation argument and final repeating int64 arguments,
# but the query passes two relation arguments instead.
select column_bytes from tvf_one_relation_arg_repeating_int64_args(
    (select 1, 2), (select 3, 4))
--
ERROR: Scalar subquery cannot have more than one column unless using SELECT AS STRUCT to build STRUCT values [at 2:20]
    (select 1, 2), (select 3, 4))
                   ^
==

# A TVF accepts one relation argument and final repeating int64 arguments,
# but the query passes scalar arguments instead.
select column_bytes from tvf_one_relation_arg_repeating_int64_args(1, 2, 3)
--
ERROR: Table-valued function tvf_one_relation_arg_repeating_int64_args argument 1 must be a relation (i.e. table subquery) [at 1:68]
select column_bytes from tvf_one_relation_arg_repeating_int64_args(1, 2, 3)
                                                                   ^
==

# A TVF accepts one relation argument and final repeating int64 arguments,
# but the query passes one relation argument and one string argument instead.
select column_bytes from tvf_one_relation_arg_repeating_int64_args(
    (select 1, 2), "abc")
--
ERROR: No matching signature for tvf_one_relation_arg_repeating_int64_args for argument types: TABLE<$col1 INT64, $col2 INT64>, STRING. Supported signature: TVF_ONE_RELATION_ARG_REPEATING_INT64_ARGS(TABLE, [INT64, ...]) [at 1:26]
select column_bytes from tvf_one_relation_arg_repeating_int64_args(
                         ^
==

# A TVF accepts one scalar argument and one relation argument, but the query
# passes one relation argument and one scalar argument instead.
select column_bytes from tvf_one_int64_arg_one_relation_arg(
    (select 1, 2), 3)
--
ERROR: Scalar subquery cannot have more than one column unless using SELECT AS STRUCT to build STRUCT values [at 2:5]
    (select 1, 2), 3)
    ^
==

# A TVF accepts one scalar argument and one relation argument, but the query
# passes two relation arguments instead.
select column_bytes from tvf_one_int64_arg_one_relation_arg(
    (select 1, 2), (select 3, 4))
--
ERROR: Scalar subquery cannot have more than one column unless using SELECT AS STRUCT to build STRUCT values [at 2:5]
    (select 1, 2), (select 3, 4))
    ^
==

# A TVF accepts one relation argument and repeating final scalar arguments of
# the same type, but the query passes one relation argument and two final
# arguments of different types instead.
select column_bytes from tvf_one_relation_arg_repeating_any_one_type_args(
    (select 1, 2), 3, "abc")
--
ERROR: No matching signature for tvf_one_relation_arg_repeating_any_one_type_args for argument types: TABLE<$col1 INT64, $col2 INT64>, INT64, STRING. Supported signature: TVF_ONE_RELATION_ARG_REPEATING_ANY_ONE_TYPE_ARGS(TABLE, [ANY, ...]) [at 1:26]
select column_bytes from tvf_one_relation_arg_repeating_any_one_type_args(
                         ^
==

# It should not be possible to refer to value tables by any other name than
# the fields present in the value.
select value from tvf_two_relation_args_return_proto_value_table(
    (select 1, 2), (select 3, 4))
--
ERROR: Unrecognized name: value [at 1:8]
select value from tvf_two_relation_args_return_proto_value_table(
       ^
==

# It should not be possible to refer to value tables by any other name than
# the fields present in the value.
select value from tvf_two_relation_args_return_int64_value_table(
    (select 1, 2), (select 3, 4))
--
ERROR: Unrecognized name: value [at 1:8]
select value from tvf_two_relation_args_return_int64_value_table(
       ^
==

# This TVF call includes a wrong argument type for the first argument.
select * from tvf_two_relation_args_output_schema_is_input_schema(
    'abc', (select 1, 2), (select 3, 4))
--
ERROR: Table-valued function tvf_two_relation_args_output_schema_is_input_schema argument 1 must be a relation (i.e. table subquery) [at 2:5]
    'abc', (select 1, 2), (select 3, 4))
    ^
==

# It is not possible to directly select the name of the single value column
# returned from a TVF that returns a value table.
select t.value_table_column
from tvf_two_relation_args_return_proto_value_table(
    (select 1, 2), (select 3, 4)) t
--
ERROR: Protocol buffer zetasql_test__.TestExtraPB does not have a field called value_table_column [at 1:10]
select t.value_table_column
         ^
==

# A TVF accepts one relation argument and one scalar argument.
# Calling it with an ARRAY subquery for the first argument generates an error.
select column_bytes from tvf_one_relation_arg_one_int64_arg(
    ARRAY(select 1), 42)
--
ERROR: Table-valued function tvf_one_relation_arg_one_int64_arg argument 1 must be a relation (i.e. table subquery) [at 2:5]
    ARRAY(select 1), 42)
    ^
==

# A TVF accepts one relation argument and one scalar argument.
# Calling it with an EXISTS subquery for the first argument generates an error.
select column_bytes from tvf_one_relation_arg_one_int64_arg(
    EXISTS(select 1), 42)
--

ERROR: Table-valued function tvf_one_relation_arg_one_int64_arg argument 1 must be a relation (i.e. table subquery) [at 2:5]
    EXISTS(select 1), 42)
    ^
==

# This TVF accepts only two arguments to mock ML.EVALUATE with model name and
# struct, which is not allowed.
# Model not found: onedoublemodel [at 1:47]
# select * from tvf_model_evaluation_args(model onedoublemodel, struct("e" as s...
#                                               ^
[no_java]
select * from tvf_model_evaluation_args(model onedoublemodel, struct("e" as string, 123 as int64))
--
ERROR: Table-valued function tvf_model_evaluation_args argument 2 must be a relation (i.e. table subquery) [at 1:63]
...tvf_model_evaluation_args(model onedoublemodel, struct("e" as string, 123 ...
                                                   ^
==

# The query calls a TVF that has one relation argument with a required schema
# of one int64 column and one string column, but the input relation actually
# includes only one column.
select column_bool, column_bytes
from tvf_one_relation_arg_int64_string_input_columns(
    (select key as int64 from keyvalue))
--
ERROR: Required column "string" not found in table passed as argument 1 of TVF_ONE_RELATION_ARG_INT64_STRING_INPUT_COLUMNS(TABLE<int64 INT64, string STRING>) [at 3:5]
    (select key as int64 from keyvalue))
    ^
==

# The query calls a TVF with the wrong number of columns for the first of two
# relation input arguments.
select column_bool, column_bytes
from tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select uint64 from simpletypes),
    (select `date`, string from simpletypes))
--
ERROR: Required column "string" not found in table passed as argument 1 of TVF_TWO_RELATION_ARGS_UINT64_STRING_AND_DATE_STRING_INPUT_COLUMNS(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) [at 3:5]
    (select uint64 from simpletypes),
    ^
==

# The query calls a TVF with the wrong number of columns for the second of two
# relation input arguments.
select column_bool, column_bytes
from tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select uint64, string from simpletypes),
    (select `date` from simpletypes))
--
ERROR: Required column "string" not found in table passed as argument 2 of TVF_TWO_RELATION_ARGS_UINT64_STRING_AND_DATE_STRING_INPUT_COLUMNS(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) [at 4:5]
    (select `date` from simpletypes))
    ^
==

# The query calls a TVF that has one relation argument with a required schema
# of one int64 column and one string column, but the input relation actually
# includes two string columns.
select column_bool, column_bytes
from tvf_one_relation_arg_int64_string_input_columns(
    (select string, string from simpletypes))
--
ERROR: Table-valued function does not allow duplicate input columns named "string" for argument 1 of TVF_ONE_RELATION_ARG_INT64_STRING_INPUT_COLUMNS(TABLE<int64 INT64, string STRING>) [at 3:5]
    (select string, string from simpletypes))
    ^
==

# The query calls a TVF with the wrong column type for the second of two relation
# input arguments.
select column_bool, column_bytes
from tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select uint64, string from simpletypes),
    (select true as uint64, string from simpletypes))
--
ERROR: Required column "date" not found in table passed as argument 2 of TVF_TWO_RELATION_ARGS_UINT64_STRING_AND_DATE_STRING_INPUT_COLUMNS(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) [at 4:5]
    (select true as uint64, string from simpletypes))
    ^
==

# The query calls a TVF with the wrong number of columns for the first of two
# relation input arguments and a wrong column type for the second input
# relation.
select column_bool, column_bytes
from tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select uint64 from simpletypes),
    (select true as date, string from simpletypes))
--
ERROR: Required column "string" not found in table passed as argument 1 of TVF_TWO_RELATION_ARGS_UINT64_STRING_AND_DATE_STRING_INPUT_COLUMNS(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) [at 3:5]
    (select uint64 from simpletypes),
    ^
==

# The query calls a TVF with the wrong number of columns for the second input relation.
select column_bool, column_bytes
from tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select 'abc' as uint64, string from simpletypes),
    (select `date` from simpletypes))
--
ERROR: Invalid type STRING for column "uint64 UINT64" of argument 1 of TVF_TWO_RELATION_ARGS_UINT64_STRING_AND_DATE_STRING_INPUT_COLUMNS(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) [at 3:5]
    (select 'abc' as uint64, string from simpletypes),
    ^
==

# A TVF accepts one relation argument with a required int64 value table, but the
# input relation contains more than one column.
select * from tvf_one_relation_arg_int64_input_value_table(
    (select key, key from KeyValue))
--
ERROR: Expected value table of type INT64 for argument 1 of TVF_ONE_RELATION_ARG_INT64_INPUT_VALUE_TABLE(TABLE<INT64>) [at 2:5]
    (select key, key from KeyValue))
    ^
==

# A TVF accepts one relation argument with a required int64 value table, but the
# input relation contains an invalid type.
select *
from tvf_one_relation_arg_input_proto_value_table(
    (select as value key from KeyValue))
--
ERROR: Invalid type INT64 for value table column with expected type "zetasql_test__.TestExtraPB" of argument 1 of TVF_ONE_RELATION_ARG_INPUT_PROTO_VALUE_TABLE(TABLE<zetasql_test__.TestExtraPB>) [at 3:5]
    (select as value key from KeyValue))
    ^
==

# A TVF accepts one relation argument with one enum column.
# The query passes a relation with the wrong enum value.
select *
from tvf_one_relation_arg_one_enum_input_column(
    (select cast(1 AS `zetasql_test__.AnotherTestEnum`) as myenum))
--
ERROR: Invalid type zetasql_test__.AnotherTestEnum for column "myenum zetasql_test__.TestEnum" of argument 1 of TVF_ONE_RELATION_ARG_ONE_ENUM_INPUT_COLUMN(TABLE<myenum zetasql_test__.TestEnum>) [at 3:5]
    (select cast(1 AS `zetasql_test__.AnotherTestEnum`) as myenum))
    ^
==

# The query calls a TVF with matching column names and types for two relations.
# The first column of the first relation has an expected name of "uint64" and
# type UINT64, but the query passes it a column of that name of type STRING
# instead.
select column_bool, column_bytes
from tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select 'abc' as uint64, string from simpletypes),
    (select `date`, string from simpletypes))
--
ERROR: Invalid type STRING for column "uint64 UINT64" of argument 1 of TVF_TWO_RELATION_ARGS_UINT64_STRING_AND_DATE_STRING_INPUT_COLUMNS(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) [at 3:5]
    (select 'abc' as uint64, string from simpletypes),
    ^
==

# A TVF accepts one relation argument with one enum column.
# The query passes a relation with a literal integer instead.
select *
from tvf_one_relation_arg_one_enum_input_column((select 1 as myenum))
--
ERROR: Invalid type INT64 for column "myenum zetasql_test__.TestEnum" of argument 1 of TVF_ONE_RELATION_ARG_ONE_ENUM_INPUT_COLUMN(TABLE<myenum zetasql_test__.TestEnum>) [at 2:49]
from tvf_one_relation_arg_one_enum_input_column((select 1 as myenum))
                                                ^
==

# A TVF accepts one relation argument with one enum column.
# The query passes a relation with an integer-valued column reference instead.
select *
from tvf_one_relation_arg_one_enum_input_column(
    (select * from (select 1 as myenum)))
--
ERROR: Invalid type INT64 for column "myenum zetasql_test__.TestEnum" of argument 1 of TVF_ONE_RELATION_ARG_ONE_ENUM_INPUT_COLUMN(TABLE<myenum zetasql_test__.TestEnum>) [at 3:5]
    (select * from (select 1 as myenum)))
    ^
==

# A TVF accepts one relation argument with one enum column.
# The query passes a relation with a literal string instead.
select *
from tvf_one_relation_arg_one_enum_input_column((select 'testenum1' as myenum))
--
ERROR: Invalid type STRING for column "myenum zetasql_test__.TestEnum" of argument 1 of TVF_ONE_RELATION_ARG_ONE_ENUM_INPUT_COLUMN(TABLE<myenum zetasql_test__.TestEnum>) [at 2:49]
from tvf_one_relation_arg_one_enum_input_column((select 'testenum1' as myenum))
                                                ^
==

# A TVF accepts one relation argument with one enum column.
# The query passes a relation with a string-valued column reference instead.
select *
from tvf_one_relation_arg_one_enum_input_column(
    (select * from (select 'testenum1' as myenum)))
--
ERROR: Invalid type STRING for column "myenum zetasql_test__.TestEnum" of argument 1 of TVF_ONE_RELATION_ARG_ONE_ENUM_INPUT_COLUMN(TABLE<myenum zetasql_test__.TestEnum>) [at 3:5]
    (select * from (select 'testenum1' as myenum)))
    ^
==

# A TVF accepts one relation argument with one date column.
# The query passes a literal string instead representing a valid date.
select *
from tvf_one_relation_arg_one_date_input_column(
    (select '2016-01-01' as mydate))
--
ERROR: Invalid type STRING for column "mydate DATE" of argument 1 of TVF_ONE_RELATION_ARG_ONE_DATE_INPUT_COLUMN(TABLE<mydate DATE>) [at 3:5]
    (select '2016-01-01' as mydate))
    ^
==

# A TVF accepts one relation argument with one date column.
# The query passes a literal string instead representing an invalid date.
select *
from tvf_one_relation_arg_one_date_input_column(
    (select '2016-01-01@abcdefg' as mydate))
--
ERROR: Invalid type STRING for column "mydate DATE" of argument 1 of TVF_ONE_RELATION_ARG_ONE_DATE_INPUT_COLUMN(TABLE<mydate DATE>) [at 3:5]
    (select '2016-01-01@abcdefg' as mydate))
    ^
==

# A TVF accepts one relation argument with one date column.
# The query passes a string-valued column reference instead.
select *
from tvf_one_relation_arg_one_date_input_column(
    (select * from (select '2016-01-01' as mydate)))
--
ERROR: Invalid type STRING for column "mydate DATE" of argument 1 of TVF_ONE_RELATION_ARG_ONE_DATE_INPUT_COLUMN(TABLE<mydate DATE>) [at 3:5]
    (select * from (select '2016-01-01' as mydate)))
    ^
==

# The query calls a TVF that has one relation argument with a required schema
# of *only* one int64 column and one string column. The provided columns repeat
# the first column name twice, so ZetaSQL rejects the query.
select column_bool, column_bytes
from tvf_one_relation_arg_only_int64_string_input_columns(
    (select value as string, value as string from keyvalue))
--
ERROR: Table-valued function does not allow duplicate input columns named "string" for argument 1 of TVF_ONE_RELATION_ARG_ONLY_INT64_STRING_INPUT_COLUMNS(TABLE<int64 INT64, string STRING>) [at 3:5]
    (select value as string, value as string from keyvalue))
    ^
==

# The query calls a TVF that has one relation argument with a required schema
# of *only* one int64 column and one string column. The provided columns contain
# one extra column that is not specified in the signature, so ZetaSQL rejects
# the query.
select column_bool, column_bytes
from tvf_one_relation_arg_only_int64_string_input_columns(
    (select value as string, key + 1 as int64, 42 as extra_col from keyvalue))
--

ERROR: Function does not allow extra input column named "extra_col" for argument 1 of TVF_ONE_RELATION_ARG_ONLY_INT64_STRING_INPUT_COLUMNS(TABLE<int64 INT64, string STRING>) [at 3:5]
    (select value as string, key + 1 as int64, 42 as extra_col from keyvalue))
    ^
==

# A TVF accepts one relation argument with one date column. A query attempts to
# pass a statement starting with a WITH clause for the relation argument, but
# ZetaSQL rejects this query.
[language_features=TABLE_VALUED_FUNCTIONS]
select *
from tvf_one_relation_arg_one_date_input_column(
    (with w1 as (select `date` as mydate from simpletypes)
     select mydate from w1))
--
ERROR: WITH is not supported on subqueries in this language version [at 3:6]
    (with w1 as (select `date` as mydate from simpletypes)
     ^
==

# A TVF accepts one relation argument with one date column. A query attempts to
# pass a statement starting with a WITH clause for the relation argument, and
# *also* forgets to enclose the subquery with parentheses. ZetaSQL returns a
# different error message in this case.
select *
from tvf_one_relation_arg_one_date_input_column(
    with w1 as (select `date` as mydate from simpletypes)
    select mydate from w1)
--
ERROR: Syntax error: Each subquery argument for table-valued function calls must be enclosed in parentheses. To fix this, replace WITH... with (WITH...) [at 3:5]
    with w1 as (select `date` as mydate from simpletypes)
    ^
==

# Invalid table for "TABLE path" syntax for table-valued function arguments.
select * from tvf_one_relation_arg_with_fixed_output(table badtable)
--
ERROR: Table not found: badtable; Did you mean abTable? [at 1:60]
select * from tvf_one_relation_arg_with_fixed_output(table badtable)
                                                           ^
==

# Missing "table" keyword, but "keyvalue" parses as a path expression: we reject
# this query during the resolving step.
select * from tvf_one_relation_arg_with_fixed_output(keyvalue)
--
ERROR: Table-valued function tvf_one_relation_arg_with_fixed_output argument 1 must be a relation (i.e. table subquery); if you meant to refer to table keyvalue then add the TABLE keyword before the table name (i.e. TABLE keyvalue) [at 1:54]
select * from tvf_one_relation_arg_with_fixed_output(keyvalue)
                                                     ^
==

# Missing table name, but "table" parses as a path expression: we reject this
# query during the resolving step.
select * from tvf_one_relation_arg_with_fixed_output(table)
--
ERROR: Table-valued function tvf_one_relation_arg_with_fixed_output argument 1 must be a relation (i.e. table subquery); if you meant to refer to table table then add the TABLE keyword before the table name (i.e. TABLE table) [at 1:54]
select * from tvf_one_relation_arg_with_fixed_output(table)
                                                     ^
==

# Call a TVF that requires a column named "Key", but pass it a table lacking
# that column using the TABLE clause.
select * from tvf_key_input_column_extra_input_columns_allowed(
    table simpletypes)
--
ERROR: Required column "key" not found in table passed as argument 1 of TVF_KEY_INPUT_COLUMN_EXTRA_INPUT_COLUMNS_ALLOWED(TABLE<key INT64>) [at 2:5]
    table simpletypes)
    ^
==

# Call a TVF that expects column names that happen to be pseudo-columns in the
# input table. ZetaSQL does not accept this call since the required columns
# must be explicit.
select * from tvf_key_filename_input_columns(table EnumTable)
--
ERROR: Required column "filename" not found in table passed as argument 1 of TVF_KEY_FILENAME_INPUT_COLUMNS(TABLE<key INT64, filename STRING>) [at 1:46]
select * from tvf_key_filename_input_columns(table EnumTable)
                                             ^
==

# Call a TVF that expects column names that happen to be pseudo-columns in the
# input table, which is a value table. ZetaSQL does not accept this call since
# the required columns must be explicit.
# Schema:
#   TestExtraValueTable is a value table and has two pseudo-columns, Filename
#   and RowId.
select * from tvf_filename_input_column_extra_input_columns_allowed(
    table TestExtraValueTable)
--
ERROR: Required column "filename" not found in table passed as argument 1 of TVF_FILENAME_INPUT_COLUMN_EXTRA_INPUT_COLUMNS_ALLOWED(TABLE<filename STRING>) [at 2:5]
    table TestExtraValueTable)
    ^
==

# The TVF contains a TABLE clause that attempts to reference a previous table
# alias in the query, but this is not allowed.
select * from keyvalue t1, tvf_one_relation_arg_with_fixed_output(table t1)
--
ERROR: Table not found: t1 [at 1:73]
select * from keyvalue t1, tvf_one_relation_arg_with_fixed_output(table t1)
                                                                        ^
==

# The TVF contains a TABLE clause that attempts to reference a table alias in
# the enclosing query, but this is not allowed.
select (select * from tvf_one_relation_arg_with_fixed_output(table t1))
from keyvalue t1
--
ERROR: Table not found: t1 (Unqualified identifiers in a FROM clause are always resolved as tables. Identifier t1 is in scope but unqualified names cannot be resolved here.) [at 1:68]
select (select * from tvf_one_relation_arg_with_fixed_output(table t1))
                                                                   ^
==

# The TVF contains a TABLE clause that attempts to reference an array column
# from a table alias in the enclosing query, but this is not allowed.
select (select * from tvf_one_relation_arg_with_fixed_output(table t1.int32array))
from complextypes t1
--
ERROR: Table not found: t1.int32array (Unqualified identifiers in a FROM clause are always resolved as tables. Identifier t1 is in scope but unqualified names cannot be resolved here.) [at 1:68]
...from tvf_one_relation_arg_with_fixed_output(table t1.int32array))
                                                     ^
==

# "TABLE path" syntax for table-valued function arguments, where the input
# table provides more columns than needed by the TVF. The function signature
# does not allow this and returns an error.
select * from tvf_key_input_column_extra_input_columns_banned(table keyvalue)
--
ERROR: Function does not allow extra input column named "Value" for argument 1 of TVF_KEY_INPUT_COLUMN_EXTRA_INPUT_COLUMNS_BANNED(TABLE<key INT64>) [at 1:63]
select * from tvf_key_input_column_extra_input_columns_banned(table keyvalue)
                                                              ^
==

# Call a templated SQL TVF with a parse error in the function body.
select * from tvf_templated_parse_error();
--
ERROR: Invalid table-valued function tvf_templated_parse_error [at 1:15]
select * from tvf_templated_parse_error();
              ^
Analysis of table-valued function tvf_templated_parse_error failed [at 1:1]
a b c d e
^
Syntax error: Unexpected identifier "a" [at 1:1]
a b c d e
^
==

# Call a templated SQL TVF with an analysis error in the function body.
select * from tvf_templated_analysis_error();
--
ERROR: Invalid table-valued function tvf_templated_analysis_error [at 1:15]
select * from tvf_templated_analysis_error();
              ^
Analysis of table-valued function tvf_templated_analysis_error failed [at 1:15]
select * from invalidtable
              ^
Table not found: invalidtable [at 1:15]
select * from invalidtable
              ^
==

# Call a templated TVF that refers to columns named "key" and "value", but
# providing only the former column name as input.
select * from tvf_templated_select_relation_arg_using_column_names(
    (select key from keyvalue));
--
ERROR: Invalid table-valued function tvf_templated_select_relation_arg_using_column_names [at 1:15]
select * from tvf_templated_select_relation_arg_using_column_names(
              ^
Analysis of table-valued function tvf_templated_select_relation_arg_using_column_names failed [at 1:13]
select key, value from t
            ^
Unrecognized name: value [at 1:13]
select key, value from t
            ^
==

# Call a templated TVF that refers to columns named "key" and "value", but
# passing a relation that refers to the columns in the wrong order.
select * from tvf_templated_select_relation_arg_and_catalog_table(
    (select value, key from keyvalue));
--
ERROR: Invalid table-valued function tvf_templated_select_relation_arg_and_catalog_table [at 1:15]
select * from tvf_templated_select_relation_arg_and_catalog_table(
              ^
Analysis of table-valued function tvf_templated_select_relation_arg_and_catalog_table failed [at 1:30]
(select * from t) union all (select * from keyvalue)
                             ^
Column 1 in UNION ALL has incompatible types: STRING, INT64 [at 1:30]
(select * from t) union all (select * from keyvalue)
                             ^
==

# Call a templated TVF that refers to a column named "key" from both input
# tables, but only one of the input tables actually contains that column.
select * from tvf_templated_select_two_relation_args(
    (select 1 as id),
    (select 1 as key));
--
ERROR: Invalid table-valued function tvf_templated_select_two_relation_args [at 1:15]
select * from tvf_templated_select_two_relation_args(
              ^
Analysis of table-valued function tvf_templated_select_two_relation_args failed [at 3:39]
select * from w1 inner join w2 using (key) order by key limit 1
                                      ^
Column key in USING clause not found on left side of join [at 3:39]
select * from w1 inner join w2 using (key) order by key limit 1
                                      ^
==

# Call a templated TVF that refers to a column named "key" from the input table
# but passing a table with a column named "value" instead.
select * from tvf_templated_select_scalar_and_relation_args(
    1,
    (select value from keyvalue));
--
ERROR: Required column "key" not found in table passed as argument 2 of TVF_TEMPLATED_SELECT_SCALAR_AND_RELATION_ARGS(INT64, TABLE<key INT64>) [at 3:5]
    (select value from keyvalue));
    ^
==

# Call a templated TVF that refers to a column named "key" from the input table
# with an expected integer value, but passing a table with a column with this
# name with a string value instead.
select * from tvf_templated_select_scalar_and_relation_args(
    1,
    (select 'a' as key));
--
ERROR: Invalid type STRING for column "key INT64" of argument 2 of TVF_TEMPLATED_SELECT_SCALAR_AND_RELATION_ARGS(INT64, TABLE<key INT64>) [at 3:5]
    (select 'a' as key));
    ^
==

# Call a simple templated SQL TVF with a missing output column name.
select * from tvf_templated_select_one_missing_col_name();
--
ERROR: Invalid table-valued function tvf_templated_select_one_missing_col_name [at 1:15]
select * from tvf_templated_select_one_missing_col_name();
              ^
Analysis of table-valued function tvf_templated_select_one_missing_col_name failed:
Function body is missing one or more explicit output column names
==

# Call a templated SQL TVF that performs addition on a scalar argument and an
# integer literal. We pass a string here, resulting in an analysis error when
# processing the SQL body because it is invalid to add an integer and a string.
select * from tvf_templated_scalar_arg_plus_integer('abc');
--
ERROR: Invalid table-valued function tvf_templated_scalar_arg_plus_integer [at 1:15]
select * from tvf_templated_scalar_arg_plus_integer('abc');
              ^
Analysis of table-valued function tvf_templated_scalar_arg_plus_integer failed [at 1:8]
select x + 42
       ^
No matching signature for operator + for argument types: STRING, INT64. Supported signatures: INT64 + INT64; UINT64 + UINT64; DOUBLE + DOUBLE [at 1:8]
select x + 42
       ^
==

# Call a TVF with a valid templated SQL body that performs concatenation on a
# scalar argument. The function signature accepts a single argument of any
# scalar type. We pass an integer argument here, resulting in an analysis error.
select * from tvf_templated_scalar_arg_concat_string(42);
--
ERROR: Invalid table-valued function tvf_templated_scalar_arg_concat_string [at 1:15]
select * from tvf_templated_scalar_arg_concat_string(42);
              ^
Analysis of table-valued function tvf_templated_scalar_arg_concat_string failed [at 1:8]
select concat(x, 'abc') as y
       ^
No matching signature for function CONCAT for argument types: INT64, STRING. Supported signatures: CONCAT(STRING, [STRING, ...]); CONCAT(BYTES, [BYTES, ...]) [at 1:8]
select concat(x, 'abc') as y
       ^
==

# Add a TVF with a valid templated SQL body that performs a proto field access
# on a scalar argument. The function signature accepts a single argument of any
# scalar type. We pass an integer argument here, resulting in an analysis error.
select * from tvf_templated_scalar_arg_proto_field_access(42);
--
ERROR: Invalid table-valued function tvf_templated_scalar_arg_proto_field_access [at 1:15]
select * from tvf_templated_scalar_arg_proto_field_access(42);
              ^
Analysis of table-valued function tvf_templated_scalar_arg_proto_field_access failed [at 1:10]
select x.int32_field as y
         ^
Cannot access field int32_field on a value with type INT64 [at 1:10]
select x.int32_field as y
         ^
==

# Call a templated SQL TVF where the function body is not a query.
select * from tvf_templated_function_body_not_query()
--
ERROR: Invalid table-valued function tvf_templated_function_body_not_query [at 1:15]
select * from tvf_templated_function_body_not_query()
              ^
Analysis of table-valued function tvf_templated_function_body_not_query failed:
SQL body is not a query
==

# Call a templated SQL TVF where the function body is empty.
select * from tvf_templated_function_body_empty()
--
ERROR: Invalid table-valued function tvf_templated_function_body_empty [at 1:15]
select * from tvf_templated_function_body_empty()
              ^
Analysis of table-valued function tvf_templated_function_body_empty failed [at 1:1]

^
Syntax error: Unexpected end of statement [at 1:1]
==

# Call a TVF with a valid templated SQL body that expects an integer argument,
# passing a string value instead.
select * from tvf_templated_select_int64_arg('aaa');
--
ERROR: No matching signature for tvf_templated_select_int64_arg for argument types: STRING. Supported signature: TVF_TEMPLATED_SELECT_INT64_ARG(INT64) [at 1:15]
select * from tvf_templated_select_int64_arg('aaa');
              ^
==

# Call a TVF that returns a table where a column name contains '$'.
select * from tvf_templated_scalar_arg_plus_integer_return_dollars_col_name(
    (select @test_param_bool as x))
--
ERROR: Invalid table-valued function tvf_templated_scalar_arg_plus_integer_return_dollars_col_name [at 1:15]
select * from tvf_templated_scalar_arg_plus_integer_return_dollars_col_name(
              ^
Analysis of table-valued function tvf_templated_scalar_arg_plus_integer_return_dollars_col_name failed:
Function body is missing one or more explicit output column names
==

# Call an invalid templated SQL TVF that is missing an output column name.
select * from tvf_templated_select_relation_arg_using_select_one(
    (select as value * from (select key as t from keyvalue)));
--
ERROR: Invalid table-valued function tvf_templated_select_relation_arg_using_select_one [at 1:15]
select * from tvf_templated_select_relation_arg_using_select_one(
              ^
Analysis of table-valued function tvf_templated_select_relation_arg_using_select_one failed:
Function body is missing one or more explicit output column names
==

# TVF call with "TABLE path(argument, ...)" syntax with an analysis error in the
# provided arguments. This statement parses correctly, but does not analyze.
# A TVF accepts one relation argument. The query attempts to pass an entire
# table by simply naming it, but this syntax is not supported.
select * from tvf_one_relation_arg_output_schema_is_input_schema(keyvalue)
--
ERROR: Table-valued function tvf_one_relation_arg_output_schema_is_input_schema argument 1 must be a relation (i.e. table subquery); if you meant to refer to table keyvalue then add the TABLE keyword before the table name (i.e. TABLE keyvalue) [at 1:66]
select * from tvf_one_relation_arg_output_schema_is_input_schema(keyvalue)
                                                                 ^
==

# TVF call with "TABLE path(argument, ...)" syntax but the provided arguments do
# not match the required list of TVF arguments as defined by the function
# signature.
select * from tvf_one_relation_arg_with_fixed_output(
    table tvf_two_relation_args(1, 2));
--
ERROR: Table-valued function tvf_two_relation_args argument 1 must be a relation (i.e. table subquery) [at 2:33]
    table tvf_two_relation_args(1, 2));
                                ^
==

# TABLESAMPLE clause for TVF calls with PERCENT option out of range.
select * from tvf_one_relation_arg_with_fixed_output(
    (select cast(42 as bool) as bool_column))
tablesample reservoir (101 percent) repeatable(10)
--
ERROR: PERCENT value must be in the range [0, 100] [at 3:24]
tablesample reservoir (101 percent) repeatable(10)
                       ^
==

# TABLESAMPLE clause for TVF calls with invalid number of rows.
select * from tvf_one_relation_arg_with_fixed_output(
    (select cast(42 as bool) as bool_column))
tablesample reservoir (0.1 rows) repeatable(10)
--
ERROR: ROWS expects an integer literal or parameter [at 3:24]
tablesample reservoir (0.1 rows) repeatable(10)
                       ^
==

# Resolver support for the TABLESAMPLE keyword after TVF calls is a protected
# language feature.
[language_features=TABLE_VALUED_FUNCTIONS]
select * from tvf_one_relation_arg_with_fixed_output(
    (select cast(42 as bool) as bool_column))
tablesample reservoir (100 rows) repeatable(10)
--
ERROR: TABLESAMPLE from table-valued function calls is not supported [at 3:1]
tablesample reservoir (100 rows) repeatable(10)
^
==

# A TVF accepts one relation argument and sets the output schema to be equal to
# the input schema. A query attempts to call the TVF passing a reference to the
# name of a WITH clause in the current scope, but forgets the TABLE clause.
with w as (select true as val)
select mytvf.column_bool
from tvf_one_relation_arg_with_fixed_output(w) as mytvf
--
ERROR: Table-valued function tvf_one_relation_arg_with_fixed_output argument 1 must be a relation (i.e. table subquery); if you meant to refer to table w then add the TABLE keyword before the table name (i.e. TABLE w) [at 3:45]
from tvf_one_relation_arg_with_fixed_output(w) as mytvf
                                            ^
==

# Test when extra column name is duplicated with input table column name.
select * from tvf_append_columns_any_relation_arg((select 1 as append_col_int32))
--
ERROR: Invalid table-valued function tvf_append_columns_any_relation_arg [at 1:15]
select * from tvf_append_columns_any_relation_arg((select 1 as append_col_int...
              ^
Column name is duplicated between extra column and input schema: append_col_int32
==

# Test when the first argument is not relation.
select * from tvf_append_columns_any_relation_arg(1)
--
ERROR: Table-valued function tvf_append_columns_any_relation_arg argument 1 ('any_relation_arg') must be a relation (i.e. table subquery) [at 1:51]
select * from tvf_append_columns_any_relation_arg(1)
                                                  ^
==

with nested_catalog as (select true as val)
select mytvf.column_bool
from tvf_one_relation_arg_with_fixed_output(nested_catalog.KeyValue) as mytvf
--
ERROR: Table-valued function tvf_one_relation_arg_with_fixed_output argument 1 must be a relation (i.e. table subquery); if you meant to refer to table nested_catalog.KeyValue then add the TABLE keyword before the table name (i.e. TABLE nested_catalog.KeyValue) [at 3:45]
from tvf_one_relation_arg_with_fixed_output(nested_catalog.KeyValue) as mytvf
                                            ^
==

# Test with a named optional table after other optional table.
# These aren't allowed because the optional table will get an untyped_null.
# TODO: Allow the optional table to be omitted. Same below.
# TODO: Fix this query since it should work. We should not inject a
# NULL for missing arguments without defaults.
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_optional_table_optional_scalar_named_table(foobar=>(select 1))
--
ERROR: No matching signature for tvf_optional_table_optional_scalar_named_table for argument types: NULL, NULL, TABLE<$col1 INT64>. Supported signature: TVF_OPTIONAL_TABLE_OPTIONAL_SCALAR_NAMED_TABLE([TABLE], [ANY], [TABLE]) [at 1:15]
select * from tvf_optional_table_optional_scalar_named_table(foobar=>(select 1))
              ^
==

# Test with multiple named optional tables.
# These aren't allowed because the optional table will get an untyped_null.
# TODO: Fix this query since it should work. We should not inject a
# NULL for missing arguments without defaults.
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_optional_scalar_named_tables(foobar=>(select 1))
--
ERROR: No matching signature for tvf_optional_scalar_named_tables for argument types: NULL, TABLE<$col1 INT64>, NULL. Supported signature: TVF_OPTIONAL_SCALAR_NAMED_TABLES([ANY], [TABLE], [TABLE]) [at 1:15]
select * from tvf_optional_scalar_named_tables(foobar=>(select 1))
              ^
==

# Test with named table after named struct.
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_named_struct_named_table(barfoo=>(select 1))
--
ERROR: No matching signature for tvf_named_struct_named_table for argument types: NULL, TABLE<$col1 INT64>. Supported signature: TVF_NAMED_STRUCT_NAMED_TABLE([STRUCT], [TABLE]) [at 1:15]
select * from tvf_named_struct_named_table(barfoo=>(select 1))
              ^
==

# Test with named table after named proto.
# TODO: Fix this query since it should work. We should not inject a
# NULL for missing arguments without defaults.
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_named_proto_named_table(barfoo=>(select 1))
--
ERROR: No matching signature for tvf_named_proto_named_table for argument types: NULL, TABLE<$col1 INT64>. Supported signature: TVF_NAMED_PROTO_NAMED_TABLE([PROTO], [TABLE]) [at 1:15]
select * from tvf_named_proto_named_table(barfoo=>(select 1))
              ^
==

# Test with a optional table before a mandatory named string with default value.
# Not passing anything, so the default value will force the relation param to
# receive a NULL, which won't work.
# TODO: Fix this query since it should work. We should not inject a
# NULL for missing arguments without defaults.
# TODO: SQLBuilder turned off due to lack of support for mandatory
# argument names.
[no_run_unparser]
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_optional_table_default_mandatory_string()
--
ERROR: No matching signature for tvf_optional_table_default_mandatory_string for argument types: NULL, STRING. Supported signature: TVF_OPTIONAL_TABLE_DEFAULT_MANDATORY_STRING([TABLE], [STRING]) [at 1:15]
select * from tvf_optional_table_default_mandatory_string()
              ^
==

# Test with a required, mandatory, optional and named tables.
# All the tables end up being required because whichever one isn't specified
# will get a NULL.
# TODO: Fix this query since it should work. We should not inject a
# NULL for missing arguments without defaults.
# TODO: SQLBuilder turned off due to lack of support for mandatory
# argument names.
[no_run_unparser]
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_required_named_optional_required_tables((select '1'),
                                                          table2=>(select '2'),
                                                          table3=>(select '3'))
--
ERROR: No matching signature for tvf_required_named_optional_required_tables for argument types: TABLE<$col1 STRING>, TABLE<$col1 STRING>, TABLE<$col1 STRING>, NULL. Supported signature: TVF_REQUIRED_NAMED_OPTIONAL_REQUIRED_TABLES(TABLE, TABLE, [TABLE], [TABLE]) [at 1:15]
select * from tvf_required_named_optional_required_tables((select '1'),
              ^
==

# Test with a required, mandatory, optional and named tables.
# All the tables end up being required because whichever one isn't specified
# will get a NULL.
# TODO: Fix this query since it should work. We should not inject a
# NULL for missing arguments without defaults.
# TODO: SQLBuilder turned off due to lack of support for mandatory
# argument names.
[no_run_unparser]
[language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS]
select * from tvf_required_named_optional_required_tables((select '1'),
                                                          table2=>(select '2'))
--
ERROR: No matching signature for tvf_required_named_optional_required_tables for argument types: TABLE<$col1 STRING>, TABLE<$col1 STRING>, NULL, NULL. Supported signature: TVF_REQUIRED_NAMED_OPTIONAL_REQUIRED_TABLES(TABLE, TABLE, [TABLE], [TABLE]) [at 1:15]
select * from tvf_required_named_optional_required_tables((select '1'),
              ^
