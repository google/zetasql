[default language_features=TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS,CREATE_TABLE_FUNCTION,TEMPLATE_FUNCTIONS,FUNCTION_ARGUMENTS_WITH_DEFAULTS,SQL_GRAPH_CALL,SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_TYPE,GROUP_BY_GRAPH_PATH]
[default no_show_sqlbuilder_output]

[language_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY]
select gt.* from
graph_table(aml
  match (x)
  CALL PER() tvf()
  return x
) gt
--
ERROR: CALL is not supported [at 4:3]
  CALL PER() tvf()
  ^
==

[language_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_CALL]
select gt.* from
graph_table(aml
  match (x)
  CALL PER() tvf()
  return x
) gt
--
ERROR: Table-valued functions are not supported [at 4:14]
  CALL PER() tvf()
             ^
==

select gt.* from
graph_table(aml
  match (x)
  CALL PER() sqrt()
  return x
) gt
--
ERROR: Table-valued function not found: sqrt [at 4:14]
  CALL PER() sqrt()
             ^
==

# Backticks make this a CALL to a tvf named `PER`(), without a PER clause.
select gt.* from
graph_table(aml
  match (x)
  CALL `PER`(1, 2)
  return x
) gt
--
ERROR: Table-valued function not found: `PER` [at 4:8]
  CALL `PER`(1, 2)
       ^
==


select gt.* from
graph_table(aml
  match (x)
  CALL PER(x) tvf_no_args(1,2)
  return x
) gt
--
ERROR: CALL PER() TVF must have an empty list of arguments [at 4:11]
  CALL PER(x) tvf_no_args(1,2)
          ^
==

# TODO: Improve the error message.
select gt.* from
graph_table(aml
  match (x)
  CALL PER() tvf_no_args()
  return x
) gt
--
ERROR: Table-valued function cannot be called with pipe CALL syntax because its signature does not include a table-typed argument; Supported signature: TVF_NO_ARGS() [at 4:14]
  CALL PER() tvf_no_args()
             ^
==

select gt.* from
graph_table(aml
  match (x)
  CALL PER() tvf_no_args(1,2)
  return x
) gt
--
ERROR: Table-valued function cannot be called with pipe CALL syntax because its signature does not include a table-typed argument; Supported signature: TVF_NO_ARGS() [at 4:14]
  CALL PER() tvf_no_args(1,2)
             ^
==

# Not allowed because the first table arg is a named-only arg.
select gt.* from
graph_table(aml
  match (x)
  CALL PER() tvf_two_named_only_tables()
  return x
) gt
--
ERROR: Table-valued function cannot be called with pipe CALL syntax because its first table-typed argument is a named-only argument; Supported signature: TVF_TWO_NAMED_ONLY_TABLES([table1 => TABLE], [table2 => TABLE]) [at 4:14]
  CALL PER() tvf_two_named_only_tables()
             ^
==

select gt.* from
graph_table(aml
  match (x)
  CALL PER() tvf_one_relation_arg_with_fixed_output((select true))
  return x
) gt
--
ERROR: No matching signature for tvf_one_relation_arg_with_fixed_output
  Argument types: TABLE<x GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, ...>> (from pipe input), BOOL
  Signature: TVF_ONE_RELATION_ARG_WITH_FIXED_OUTPUT(TABLE)
    Signature accepts at most 1 argument, found 2 arguments (including pipe input table) [at 4:14]
  CALL PER() tvf_one_relation_arg_with_fixed_output((select true))
             ^
==

# Simple TVF call, with a hint.
# Just for this case, showing SqlBuilder output for illustration.
[show_sqlbuilder_output]
select gt.* from
graph_table(aml
  match (x)
  RETURN LENGTH(x.name) > 10 AS b
  NEXT
  CALL PER() tvf_one_relation_arg_with_fixed_output() @{hint=1}
  return *
) gt
--
QueryStmt
+-output_column_list=
| +-$graph_table.column_bool#5 AS column_bool [BOOL]
| +-$graph_table.column_bytes#6 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=$graph_table.[column_bool#5, column_bytes#6]
    +-input_scan=
      +-GraphTableScan
        +-column_list=$graph_table.[column_bool#5, column_bytes#6]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=$graph_table.[column_bool#5, column_bytes#6]
            +-scan_list=
              +-GraphLinearScan
              | +-column_list=[$graph_table.b#2]
              | +-scan_list=
              |   +-GraphScan
              |   | +-column_list=[$element_table.x#1]
              |   | +-input_scan_list=
              |   | | +-GraphPathScan
              |   | |   +-column_list=[$element_table.x#1]
              |   | |   +-input_scan_list=
              |   | |   | +-GraphNodeScan
              |   | |   |   +-column_list=[$element_table.x#1]
              |   | |   |   +-label_expr=
              |   | |   |   | +-GraphLabelNaryExpr
              |   | |   |   |   +-op=OR
              |   | |   |   |   +-operand_list=
              |   | |   |   |     +-GraphWildCardLabel
              |   | |   |   |     +-GraphLabelNaryExpr
              |   | |   |   |       +-op=NOT
              |   | |   |   |       +-operand_list=
              |   | |   |   |         +-GraphWildCardLabel
              |   | |   |   +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
              |   | |   +-head=$element_table.x#1
              |   | |   +-tail=$element_table.x#1
              |   | +-input_scan=
              |   |   +-SingleRowScan
              |   +-ProjectScan
              |     +-column_list=[$graph_table.b#2]
              |     +-expr_list=
              |     | +-b#2 :=
              |     |   +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
              |     |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
              |     |     | +-GraphGetElementProperty
              |     |     |   +-type=STRING
              |     |     |   +-expr=
              |     |     |   | +-ColumnRef(type=GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=$element_table.x#1)
              |     |     |   +-property=name(STRING)
              |     |     +-Literal(type=INT64, value=10)
              |     +-input_scan=
              |       +-GraphRefScan(column_list=[$element_table.x#1])
              +-GraphLinearScan
                +-column_list=$graph_table.[column_bool#5, column_bytes#6]
                +-scan_list=
                  +-TVFScan
                  | +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#3, column_bytes#4]
                  | +-hint_list=
                  | | +-hint := Literal(type=INT64, value=1)
                  | +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                  | +-signature=(TABLE<b BOOL>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  | +-argument_list=
                  | | +-FunctionArgument
                  | |   +-scan=
                  | |   | +-GraphRefScan(column_list=[$graph_table.b#2])
                  | |   +-argument_column_list=[$graph_table.b#2]
                  | +-column_index_list=[0, 1]
                  | +-function_call_signature=(ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  +-ProjectScan
                    +-column_list=$graph_table.[column_bool#5, column_bytes#6]
                    +-expr_list=
                    | +-column_bool#5 := ColumnRef(type=BOOL, column=tvf_one_relation_arg_with_fixed_output.column_bool#3)
                    | +-column_bytes#6 := ColumnRef(type=BYTES, column=tvf_one_relation_arg_with_fixed_output.column_bytes#4)
                    +-input_scan=
                      +-GraphRefScan(column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#3, column_bytes#4])

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT
  aml_1.a_6 AS column_bool,
  aml_1.a_7 AS column_bytes
FROM
  GRAPH_TABLE(
    aml
    MATCH
      (a_2
      IS (% | ! %))
    RETURN
      (LENGTH(a_2.name)) > 10 AS a_3
    NEXT
    RETURN
      a_3 AS b
    NEXT
    CALL PER () TVF_ONE_RELATION_ARG_WITH_FIXED_OUTPUT() @{ hint = 1 } YIELD column_bool AS a_4, column_bytes AS a_5
    RETURN
      a_4 AS a_6,
      a_5 AS a_7
  ) AS aml_1;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
FROM
  GRAPH_TABLE(
    aml
    MATCH
      (a_2
      IS (% | ! %))
    RETURN
      (LENGTH(a_2.name)) > 10 AS a_3
    NEXT
    RETURN
      a_3 AS b
    NEXT
    CALL PER () TVF_ONE_RELATION_ARG_WITH_FIXED_OUTPUT() @{ hint = 1 } YIELD column_bool AS a_4, column_bytes AS a_5
    RETURN
      a_4 AS a_6,
      a_5 AS a_7
  ) AS aml_1
|> SELECT
     aml_1.a_6 AS column_bool,
     aml_1.a_7 AS column_bytes;
==

# Pass the wrong table type (int instead of bool) to test the error message.
select gt.* from
graph_table(aml
  match (x)
  RETURN LENGTH(x.name) AS i
  NEXT
  CALL PER() tvf_one_relation_arg_with_fixed_output(TABLE KeyValue)
  return *
) gt
--
ERROR: No matching signature for tvf_one_relation_arg_with_fixed_output
  Argument types: TABLE<i INT64> (from pipe input), TABLE<Key INT64, Value STRING>
  Signature: TVF_ONE_RELATION_ARG_WITH_FIXED_OUTPUT(TABLE)
    Signature accepts at most 1 argument, found 2 arguments (including pipe input table) [at 6:14]
  CALL PER() tvf_one_relation_arg_with_fixed_output(TABLE KeyValue)
             ^
==

# Passing a table schema through.
select gt.* from
graph_table(aml
  match (x)
  CALL PER() tvf_one_relation_arg_output_schema_is_input_schema()
  return x.name
) gt
--
QueryStmt
+-output_column_list=
| +-$graph_table.name#3 AS name [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.name#3]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.name#3]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.name#3]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.name#3]
                +-scan_list=
                  +-GraphScan
                  | +-column_list=[$element_table.x#1]
                  | +-input_scan_list=
                  | | +-GraphPathScan
                  | |   +-column_list=[$element_table.x#1]
                  | |   +-input_scan_list=
                  | |   | +-GraphNodeScan
                  | |   |   +-column_list=[$element_table.x#1]
                  | |   |   +-label_expr=
                  | |   |   | +-GraphLabelNaryExpr
                  | |   |   |   +-op=OR
                  | |   |   |   +-operand_list=
                  | |   |   |     +-GraphWildCardLabel
                  | |   |   |     +-GraphLabelNaryExpr
                  | |   |   |       +-op=NOT
                  | |   |   |       +-operand_list=
                  | |   |   |         +-GraphWildCardLabel
                  | |   |   +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
                  | |   +-head=$element_table.x#1
                  | |   +-tail=$element_table.x#1
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-TVFScan
                  | +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.x#2]
                  | +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
                  | +-signature=(TABLE<x GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>>) -> TABLE<x GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>>
                  | +-argument_list=
                  | | +-FunctionArgument
                  | |   +-scan=
                  | |   | +-GraphRefScan(column_list=[$element_table.x#1])
                  | |   +-argument_column_list=[$element_table.x#1]
                  | +-column_index_list=[0]
                  | +-function_call_signature=(ANY TABLE) -> ANY TABLE
                  +-ProjectScan
                    +-column_list=[$graph_table.name#3]
                    +-expr_list=
                    | +-name#3 :=
                    |   +-GraphGetElementProperty
                    |     +-type=STRING
                    |     +-expr=
                    |     | +-ColumnRef(type=GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=tvf_one_relation_arg_output_schema_is_input_schema.x#2)
                    |     +-property=name(STRING)
                    +-input_scan=
                      +-GraphRefScan(column_list=[tvf_one_relation_arg_output_schema_is_input_schema.x#2])
==

# Column access after pass-through TVF.
select gt.* from
graph_table(aml
  match (x)
  CALL PER() tvf_one_relation_arg_output_schema_is_input_schema()
  FILTER LENGTH(x.name) > 10
  RETURN x.name
) gt
--
QueryStmt
+-output_column_list=
| +-$graph_table.name#3 AS name [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.name#3]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.name#3]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.name#3]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.name#3]
                +-scan_list=
                  +-GraphScan
                  | +-column_list=[$element_table.x#1]
                  | +-input_scan_list=
                  | | +-GraphPathScan
                  | |   +-column_list=[$element_table.x#1]
                  | |   +-input_scan_list=
                  | |   | +-GraphNodeScan
                  | |   |   +-column_list=[$element_table.x#1]
                  | |   |   +-label_expr=
                  | |   |   | +-GraphLabelNaryExpr
                  | |   |   |   +-op=OR
                  | |   |   |   +-operand_list=
                  | |   |   |     +-GraphWildCardLabel
                  | |   |   |     +-GraphLabelNaryExpr
                  | |   |   |       +-op=NOT
                  | |   |   |       +-operand_list=
                  | |   |   |         +-GraphWildCardLabel
                  | |   |   +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
                  | |   +-head=$element_table.x#1
                  | |   +-tail=$element_table.x#1
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-TVFScan
                  | +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.x#2]
                  | +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
                  | +-signature=(TABLE<x GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>>) -> TABLE<x GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>>
                  | +-argument_list=
                  | | +-FunctionArgument
                  | |   +-scan=
                  | |   | +-GraphRefScan(column_list=[$element_table.x#1])
                  | |   +-argument_column_list=[$element_table.x#1]
                  | +-column_index_list=[0]
                  | +-function_call_signature=(ANY TABLE) -> ANY TABLE
                  +-FilterScan
                  | +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.x#2]
                  | +-input_scan=
                  | | +-GraphRefScan(column_list=[tvf_one_relation_arg_output_schema_is_input_schema.x#2])
                  | +-filter_expr=
                  |   +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
                  |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                  |     | +-GraphGetElementProperty
                  |     |   +-type=STRING
                  |     |   +-expr=
                  |     |   | +-ColumnRef(type=GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=tvf_one_relation_arg_output_schema_is_input_schema.x#2)
                  |     |   +-property=name(STRING)
                  |     +-Literal(type=INT64, value=10)
                  +-ProjectScan
                    +-column_list=[$graph_table.name#3]
                    +-expr_list=
                    | +-name#3 :=
                    |   +-GraphGetElementProperty
                    |     +-type=STRING
                    |     +-expr=
                    |     | +-ColumnRef(type=GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=tvf_one_relation_arg_output_schema_is_input_schema.x#2)
                    |     +-property=name(STRING)
                    +-input_scan=
                      +-GraphRefScan(column_list=[tvf_one_relation_arg_output_schema_is_input_schema.x#2])
==

select gt.* from
graph_table(aml
  match (x)
  RETURN x.name
  NEXT
  CALL PER() tvf_two_relation_args(TABLE KeyValue)
  return *
) gt
--
QueryStmt
+-output_column_list=
| +-$graph_table.column_bool#7 AS column_bool [BOOL]
| +-$graph_table.column_bytes#8 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=$graph_table.[column_bool#7, column_bytes#8]
    +-input_scan=
      +-GraphTableScan
        +-column_list=$graph_table.[column_bool#7, column_bytes#8]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=$graph_table.[column_bool#7, column_bytes#8]
            +-scan_list=
              +-GraphLinearScan
              | +-column_list=[$graph_table.name#2]
              | +-scan_list=
              |   +-GraphScan
              |   | +-column_list=[$element_table.x#1]
              |   | +-input_scan_list=
              |   | | +-GraphPathScan
              |   | |   +-column_list=[$element_table.x#1]
              |   | |   +-input_scan_list=
              |   | |   | +-GraphNodeScan
              |   | |   |   +-column_list=[$element_table.x#1]
              |   | |   |   +-label_expr=
              |   | |   |   | +-GraphLabelNaryExpr
              |   | |   |   |   +-op=OR
              |   | |   |   |   +-operand_list=
              |   | |   |   |     +-GraphWildCardLabel
              |   | |   |   |     +-GraphLabelNaryExpr
              |   | |   |   |       +-op=NOT
              |   | |   |   |       +-operand_list=
              |   | |   |   |         +-GraphWildCardLabel
              |   | |   |   +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
              |   | |   +-head=$element_table.x#1
              |   | |   +-tail=$element_table.x#1
              |   | +-input_scan=
              |   |   +-SingleRowScan
              |   +-ProjectScan
              |     +-column_list=[$graph_table.name#2]
              |     +-expr_list=
              |     | +-name#2 :=
              |     |   +-GraphGetElementProperty
              |     |     +-type=STRING
              |     |     +-expr=
              |     |     | +-ColumnRef(type=GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=$element_table.x#1)
              |     |     +-property=name(STRING)
              |     +-input_scan=
              |       +-GraphRefScan(column_list=[$element_table.x#1])
              +-GraphLinearScan
                +-column_list=$graph_table.[column_bool#7, column_bytes#8]
                +-scan_list=
                  +-TVFScan
                  | +-column_list=tvf_two_relation_args.[column_bool#5, column_bytes#6]
                  | +-tvf=tvf_two_relation_args((ANY TABLE, ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                  | +-signature=(TABLE<name STRING>, TABLE<Key INT64, Value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  | +-argument_list=
                  | | +-FunctionArgument
                  | | | +-scan=
                  | | | | +-GraphRefScan(column_list=[$graph_table.name#2])
                  | | | +-argument_column_list=[$graph_table.name#2]
                  | | +-FunctionArgument
                  | |   +-scan=
                  | |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
                  | |   +-argument_column_list=KeyValue.[Key#3, Value#4]
                  | +-column_index_list=[0, 1]
                  | +-function_call_signature=(ANY TABLE, ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  +-ProjectScan
                    +-column_list=$graph_table.[column_bool#7, column_bytes#8]
                    +-expr_list=
                    | +-column_bool#7 := ColumnRef(type=BOOL, column=tvf_two_relation_args.column_bool#5)
                    | +-column_bytes#8 := ColumnRef(type=BYTES, column=tvf_two_relation_args.column_bytes#6)
                    +-input_scan=
                      +-GraphRefScan(column_list=tvf_two_relation_args.[column_bool#5, column_bytes#6])
==

# Test with a MODEL
select gt.* from
graph_table(aml
  match (x)
  CALL PER() tvf_model_evaluation_args(model onedoublemodel)
  return *
) gt
--
QueryStmt
+-output_column_list=
| +-$graph_table.column_bool#4 AS column_bool [BOOL]
| +-$graph_table.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=$graph_table.[column_bool#4, column_bytes#5]
    +-input_scan=
      +-GraphTableScan
        +-column_list=$graph_table.[column_bool#4, column_bytes#5]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=$graph_table.[column_bool#4, column_bytes#5]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=$graph_table.[column_bool#4, column_bytes#5]
                +-scan_list=
                  +-GraphScan
                  | +-column_list=[$element_table.x#1]
                  | +-input_scan_list=
                  | | +-GraphPathScan
                  | |   +-column_list=[$element_table.x#1]
                  | |   +-input_scan_list=
                  | |   | +-GraphNodeScan
                  | |   |   +-column_list=[$element_table.x#1]
                  | |   |   +-label_expr=
                  | |   |   | +-GraphLabelNaryExpr
                  | |   |   |   +-op=OR
                  | |   |   |   +-operand_list=
                  | |   |   |     +-GraphWildCardLabel
                  | |   |   |     +-GraphLabelNaryExpr
                  | |   |   |       +-op=NOT
                  | |   |   |       +-operand_list=
                  | |   |   |         +-GraphWildCardLabel
                  | |   |   +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
                  | |   +-head=$element_table.x#1
                  | |   +-tail=$element_table.x#1
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-TVFScan
                  | +-column_list=tvf_model_evaluation_args.[column_bool#2, column_bytes#3]
                  | +-tvf=tvf_model_evaluation_args((ANY MODEL, optional ANY TABLE, optional <struct>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                  | +-signature=(ANY MODEL, TABLE<x GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  | +-argument_list=
                  | | +-FunctionArgument
                  | | | +-model=
                  | | |   +-Model(model=OneDoubleModel)
                  | | +-FunctionArgument
                  | |   +-scan=
                  | |   | +-GraphRefScan(column_list=[$element_table.x#1])
                  | |   +-argument_column_list=[$element_table.x#1]
                  | +-column_index_list=[0, 1]
                  | +-function_call_signature=(ANY MODEL, optional(1) ANY TABLE, optional <struct>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  +-ProjectScan
                    +-column_list=$graph_table.[column_bool#4, column_bytes#5]
                    +-expr_list=
                    | +-column_bool#4 := ColumnRef(type=BOOL, column=tvf_model_evaluation_args.column_bool#2)
                    | +-column_bytes#5 := ColumnRef(type=BYTES, column=tvf_model_evaluation_args.column_bytes#3)
                    +-input_scan=
                      +-GraphRefScan(column_list=tvf_model_evaluation_args.[column_bool#2, column_bytes#3])
==

select gt.* from
graph_table(aml
  match (x)
  CALL PER() tvf_model_optional_string_optional_table(model onedoublemodel)
  return *
) gt
--
ERROR: Table-valued function cannot be called with pipe CALL syntax because it has an optional argument before its first table-typed argument; Supported signature: TVF_MODEL_OPTIONAL_STRING_OPTIONAL_TABLE(MODEL, [STRING], [TABLE]) [at 4:14]
  CALL PER() tvf_model_optional_string_optional_table(model onedoublemodel)
             ^
==

# The table argument is optional but this is allowed because the
# arguments before it are positional.
select gt.* from
graph_table(aml
  match (x)
  CALL PER() tvf_model_optional_table_named_string_default(model onedoublemodel)
  return *
) gt
--
QueryStmt
+-output_column_list=
| +-$graph_table.column_bool#4 AS column_bool [BOOL]
| +-$graph_table.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=$graph_table.[column_bool#4, column_bytes#5]
    +-input_scan=
      +-GraphTableScan
        +-column_list=$graph_table.[column_bool#4, column_bytes#5]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=$graph_table.[column_bool#4, column_bytes#5]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=$graph_table.[column_bool#4, column_bytes#5]
                +-scan_list=
                  +-GraphScan
                  | +-column_list=[$element_table.x#1]
                  | +-input_scan_list=
                  | | +-GraphPathScan
                  | |   +-column_list=[$element_table.x#1]
                  | |   +-input_scan_list=
                  | |   | +-GraphNodeScan
                  | |   |   +-column_list=[$element_table.x#1]
                  | |   |   +-label_expr=
                  | |   |   | +-GraphLabelNaryExpr
                  | |   |   |   +-op=OR
                  | |   |   |   +-operand_list=
                  | |   |   |     +-GraphWildCardLabel
                  | |   |   |     +-GraphLabelNaryExpr
                  | |   |   |       +-op=NOT
                  | |   |   |       +-operand_list=
                  | |   |   |         +-GraphWildCardLabel
                  | |   |   +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
                  | |   +-head=$element_table.x#1
                  | |   +-tail=$element_table.x#1
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-TVFScan
                  | +-column_list=tvf_model_optional_table_named_string_default.[column_bool#2, column_bytes#3]
                  | +-tvf=tvf_model_optional_table_named_string_default((ANY MODEL, optional ANY TABLE, optional STRING {default_value: "default"} foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                  | +-signature=(ANY MODEL, TABLE<x GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>>, literal STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  | +-argument_list=
                  | | +-FunctionArgument
                  | | | +-model=
                  | | |   +-Model(model=OneDoubleModel)
                  | | +-FunctionArgument
                  | | | +-scan=
                  | | | | +-GraphRefScan(column_list=[$element_table.x#1])
                  | | | +-argument_column_list=[$element_table.x#1]
                  | | +-FunctionArgument
                  | |   +-expr=
                  | |     +-Literal(type=STRING, value="default")
                  | +-column_index_list=[0, 1]
                  | +-function_call_signature=(ANY MODEL, optional(1) ANY TABLE, optional(1) STRING foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  +-ProjectScan
                    +-column_list=$graph_table.[column_bool#4, column_bytes#5]
                    +-expr_list=
                    | +-column_bool#4 := ColumnRef(type=BOOL, column=tvf_model_optional_table_named_string_default.column_bool#2)
                    | +-column_bytes#5 := ColumnRef(type=BYTES, column=tvf_model_optional_table_named_string_default.column_bytes#3)
                    +-input_scan=
                      +-GraphRefScan(column_list=tvf_model_optional_table_named_string_default.[column_bool#2, column_bytes#3])
==

# This TVF expects TABLE<int64 `int64`, string `string`> with named columns.
select gt.* from
graph_table(aml
  match (x)
  RETURN x.syndicateId, x.balance
  NEXT
  CALL PER() tvf_one_relation_arg_int64_string_input_columns()
  return *
) gt
--
ERROR: Required column "int64" not found in table passed as argument 1 of TVF_ONE_RELATION_ARG_INT64_STRING_INPUT_COLUMNS(TABLE<int64 INT64, string STRING>) [at 6:14]
  CALL PER() tvf_one_relation_arg_int64_string_input_columns()
             ^
==

# Named column matching with out-of-order and extra columns.
select gt.* from
graph_table(aml
  match (x)
  # Note: LET is also keeping `x`
  LET y = null, string = "abc", xxx = true, int64 = 5
  CALL PER() tvf_one_relation_arg_int64_string_input_columns()
  return *
) gt
--
QueryStmt
+-output_column_list=
| +-$graph_table.column_bool#8 AS column_bool [BOOL]
| +-$graph_table.column_bytes#9 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=$graph_table.[column_bool#8, column_bytes#9]
    +-input_scan=
      +-GraphTableScan
        +-column_list=$graph_table.[column_bool#8, column_bytes#9]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=$graph_table.[column_bool#8, column_bytes#9]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=$graph_table.[column_bool#8, column_bytes#9]
                +-scan_list=
                  +-GraphScan
                  | +-column_list=[$element_table.x#1]
                  | +-input_scan_list=
                  | | +-GraphPathScan
                  | |   +-column_list=[$element_table.x#1]
                  | |   +-input_scan_list=
                  | |   | +-GraphNodeScan
                  | |   |   +-column_list=[$element_table.x#1]
                  | |   |   +-label_expr=
                  | |   |   | +-GraphLabelNaryExpr
                  | |   |   |   +-op=OR
                  | |   |   |   +-operand_list=
                  | |   |   |     +-GraphWildCardLabel
                  | |   |   |     +-GraphLabelNaryExpr
                  | |   |   |       +-op=NOT
                  | |   |   |       +-operand_list=
                  | |   |   |         +-GraphWildCardLabel
                  | |   |   +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
                  | |   +-head=$element_table.x#1
                  | |   +-tail=$element_table.x#1
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=[$element_table.x#1, $graph_table.string#3, $graph_table.int64#5]
                  | +-expr_list=
                  | | +-y#2 := Literal(type=INT64, value=NULL)
                  | | +-string#3 := Literal(type=STRING, value="abc")
                  | | +-xxx#4 := Literal(type=BOOL, value=true)
                  | | +-int64#5 := Literal(type=INT64, value=5)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$element_table.x#1])
                  +-TVFScan
                  | +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#6, column_bytes#7]
                  | +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                  | +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  | +-argument_list=
                  | | +-FunctionArgument
                  | |   +-scan=
                  | |   | +-ProjectScan
                  | |   |   +-column_list=$graph_table.[int64#5, string#3]
                  | |   |   +-input_scan=
                  | |   |     +-GraphRefScan(column_list=[$element_table.x#1, $graph_table.string#3, $graph_table.int64#5])
                  | |   +-argument_column_list=$graph_table.[int64#5, string#3]
                  | +-column_index_list=[0, 1]
                  | +-function_call_signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  +-ProjectScan
                    +-column_list=$graph_table.[column_bool#8, column_bytes#9]
                    +-expr_list=
                    | +-column_bool#8 := ColumnRef(type=BOOL, column=tvf_one_relation_arg_int64_string_input_columns.column_bool#6)
                    | +-column_bytes#9 := ColumnRef(type=BYTES, column=tvf_one_relation_arg_int64_string_input_columns.column_bytes#7)
                    +-input_scan=
                      +-GraphRefScan(column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#6, column_bytes#7])
==

# Expected value table input with non-value column input.
select gt.* from
graph_table(aml
  match (x)
  LET key = x.syndicateId
  CALL PER() tvf_one_relation_arg_int64_input_value_table()
  return *
) gt
--
ERROR: Expected value table of type INT64 for argument 1; got TABLE<x GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, key INT64> of TVF_ONE_RELATION_ARG_INT64_INPUT_VALUE_TABLE(TABLE<INT64>) [at 5:14]
  CALL PER() tvf_one_relation_arg_int64_input_value_table()
             ^
==

# Templated SQL TVF with two relations.
# GQL does not allow the TVF output to have two columns with duplicate names.
# Note: the TVF is `t1 JOIN t2 USING (key)` so it only duplicates `Value`
select gt.* from
graph_table(aml
  LET key = 1, value = 'a'
  CALL PER() tvf_templated_select_two_relation_args(table KeyValue)
  return key
) gt
--
ERROR: Duplicate column name in CALL PER() TVF output: Value [at 4:14]
  CALL PER() tvf_templated_select_two_relation_args(table KeyValue)
             ^
==

[prepare_database=db]
CREATE TABLE FUNCTION tvf_expects_any_table_returns_anonymous_column(t ANY TABLE)
RETURNS TABLE<INT64> AS SELECT 1
--
CreateTableFunctionStmt(name_path=tvf_expects_any_table_returns_anonymous_column, argument_name_list=[t], signature=(ANY TABLE t) -> TABLE<INT64>, has_explicit_return_schema=TRUE, language="SQL", code="SELECT 1", is_value_table=TRUE)
==

[default use_database=db]

# GQL does not allow the TVF output to have anonymous columns.
select gt.* from
graph_table(aml
  match (x)
  CALL PER() tvf_expects_any_table_returns_anonymous_column()
  return *
) gt
--
ERROR: Anonymous column name in CALL PER() TVF output [at 5:14]
  CALL PER() tvf_expects_any_table_returns_anonymous_column()
             ^
==

[prepare_database=db]
CREATE TABLE FUNCTION tvf_expect_a_b_c(t TABLE<a INT64, b STRING, c DOUBLE>)
RETURNS TABLE<z INT64>
--
CreateTableFunctionStmt(name_path=tvf_expect_a_b_c, argument_name_list=[t], signature=(TABLE<a INT64, b STRING, c DOUBLE> t) -> TABLE<z INT64>, has_explicit_return_schema=TRUE, language="UNDECLARED")
==

# This tests the code that rearranges and coerces columns in the input table to
# match the expected schema.  (Most tests above use ANY TABLE.)
select gt.* from
graph_table(aml
  LET x = 1, c = 10, y = 2, {{b|b_is_missing}} = CAST(NULL AS STRING), z = 3,
      a = CAST(20 AS {{string|int32}})
  CALL PER() tvf_expect_a_b_c()
  return *
) gt
--
ALTERNATION GROUPS:
    b,string
    b_is_missing,string
--
ERROR: Invalid type STRING for column "a INT64" of argument 1 of TVF_EXPECT_A_B_C(TABLE<a INT64, b STRING, c DOUBLE>) [at 5:14]
  CALL PER() tvf_expect_a_b_c()
             ^
--
ALTERNATION GROUP: b,int32
--
QueryStmt
+-output_column_list=
| +-$graph_table.z#10 AS z [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#10]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#10]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#10]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#10]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=$graph_table.[c#2, b#4, a#6]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=INT64, value=1)
                  | | +-c#2 := Literal(type=INT64, value=10)
                  | | +-y#3 := Literal(type=INT64, value=2)
                  | | +-b#4 := Literal(type=STRING, value=NULL, has_explicit_type=TRUE)
                  | | +-z#5 := Literal(type=INT64, value=3)
                  | | +-a#6 := Literal(type=INT32, value=20, has_explicit_type=TRUE)
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-TVFScan
                  | +-column_list=[tvf_expect_a_b_c.z#9]
                  | +-tvf=tvf_expect_a_b_c((TABLE<a INT64, b STRING, c DOUBLE> t) -> TABLE<z INT64>)
                  | +-signature=(TABLE<a INT64, b STRING, c DOUBLE>) -> TABLE<z INT64>
                  | +-argument_list=
                  | | +-FunctionArgument
                  | |   +-scan=
                  | |   | +-ProjectScan
                  | |   |   +-column_list=[$subquery1.a#7, $graph_table.b#4, $subquery1.c#8]
                  | |   |   +-expr_list=
                  | |   |   | +-a#7 :=
                  | |   |   | | +-Cast(INT32 -> INT64)
                  | |   |   | |   +-ColumnRef(type=INT32, column=$graph_table.a#6)
                  | |   |   | +-c#8 :=
                  | |   |   |   +-Cast(INT64 -> DOUBLE)
                  | |   |   |     +-ColumnRef(type=INT64, column=$graph_table.c#2)
                  | |   |   +-input_scan=
                  | |   |     +-GraphRefScan(column_list=$graph_table.[c#2, b#4, a#6])
                  | |   +-argument_column_list=[$subquery1.a#7, $graph_table.b#4, $subquery1.c#8]
                  | +-column_index_list=[0]
                  | +-function_call_signature=(TABLE<a INT64, b STRING, c DOUBLE> t) -> TABLE<z INT64>
                  +-ProjectScan
                    +-column_list=[$graph_table.z#10]
                    +-expr_list=
                    | +-z#10 := ColumnRef(type=INT64, column=tvf_expect_a_b_c.z#9)
                    +-input_scan=
                      +-GraphRefScan(column_list=[tvf_expect_a_b_c.z#9])
--
ALTERNATION GROUP: b_is_missing,int32
--
ERROR: Required column "b" not found in table passed as argument 1 of TVF_EXPECT_A_B_C(TABLE<a INT64, b STRING, c DOUBLE>) [at 5:14]
  CALL PER() tvf_expect_a_b_c()
             ^
==

# CALL PER() tvf() cannot accept arguments that are not from an outer scope.
select gt.* from
graph_table(aml
  LET x = 1
  CALL PER() tvf_one_relation_arg_output_schema_is_input_schema_plus_int64_arg(x)
  return *
) gt
--
ERROR: Name 'x', defined in the current scope, cannot be used as a TVF argument in a CALL PER() with an empty list [at 4:80]
...t_schema_is_input_schema_plus_int64_arg(x)
                                           ^
==

# CALL PER() tvf() cannot accept arguments that are not from an outer scope.
# It needs to be part of the paritioned list explicitly.
SELECT (
  select count(*)
  from graph_table(aml
    match (n)
    CALL PER() tvf_one_relation_arg_output_schema_is_input_schema_plus_int64_arg(x)
    return n.age
  ) gt
) FROM UNNEST([1, 2]) AS x
--
ERROR: Unrecognized name: x [at 5:82]
...t_schema_is_input_schema_plus_int64_arg(x)
                                           ^
==

# Same as above, but using names captured on an outer CALL statement.
# CALL PER() tvf() cannot accept arguments that are not from an outer scope.
# Names captured in an outer CALL statement count as outer scopes.
select gt.*
from graph_table(aml
  LET x = 1
  CALL (x) {
    match (n)
    CALL PER() tvf_one_relation_arg_output_schema_is_input_schema_plus_int64_arg(x)
    RETURN n.age
  }
  return x, age
) gt
--
ERROR: Unrecognized name: x [at 6:82]
...t_schema_is_input_schema_plus_int64_arg(x)
                                           ^
==

# CALL PER not yet supported on a Subquery
select gt.*
from graph_table(aml
  LET x = 1
  CALL PER() {
    MATCH (n)
    RETURN n.age
  }
  return *
) gt
--
ERROR: CALL PER on a subquery is not supported [at 4:14]
  CALL PER() {
             ^
==

# YIELD items must be identifiers only. Cannot be general expressions.
select gt.*
from graph_table(aml
  LET x = "a"
  CALL PER() tvf_one_relation_arg_with_fixed_output() YIELD {{column_bool OR column_bool|(column_bool)}} AS y
  return *
) gt
--
ALTERNATION GROUP: column_bool OR column_bool
--
ERROR: Syntax error: Unexpected keyword OR [at 4:73]
...g_with_fixed_output() YIELD column_bool OR column_bool AS y
                                           ^
--
ALTERNATION GROUP: (column_bool)
--
ERROR: Syntax error: Unexpected "(" [at 4:61]
  CALL PER() tvf_one_relation_arg_with_fixed_output() YIELD (column_bool) AS y
                                                            ^
==

# YIELD items may or may not have aliases.
select gt.*
from graph_table(aml
  LET x = 1
  CALL PER() tvf_one_relation_arg_with_fixed_output() YIELD column_bool{{| AS y}}
  return *
) gt
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$graph_table.column_bool#4 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.column_bool#4]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.column_bool#4]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.column_bool#4]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.column_bool#4]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=INT64, value=1)
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-TVFScan
                  | +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
                  | +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                  | +-signature=(TABLE<x INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  | +-argument_list=
                  | | +-FunctionArgument
                  | |   +-scan=
                  | |   | +-GraphRefScan(column_list=[$graph_table.x#1])
                  | |   +-argument_column_list=[$graph_table.x#1]
                  | +-column_index_list=[0, 1]
                  | +-function_call_signature=(ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  +-ProjectScan
                    +-column_list=[$graph_table.column_bool#4]
                    +-expr_list=
                    | +-column_bool#4 := ColumnRef(type=BOOL, column=tvf_one_relation_arg_with_fixed_output.column_bool#2)
                    +-input_scan=
                      +-GraphRefScan(column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#2])
--
ALTERNATION GROUP:  AS y
--
QueryStmt
+-output_column_list=
| +-$graph_table.y#4 AS y [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.y#4]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.y#4]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.y#4]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.y#4]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=INT64, value=1)
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-TVFScan
                  | +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
                  | +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                  | +-signature=(TABLE<x INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  | +-argument_list=
                  | | +-FunctionArgument
                  | |   +-scan=
                  | |   | +-GraphRefScan(column_list=[$graph_table.x#1])
                  | |   +-argument_column_list=[$graph_table.x#1]
                  | +-column_index_list=[0, 1]
                  | +-function_call_signature=(ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  +-ProjectScan
                    +-column_list=[$graph_table.y#4]
                    +-expr_list=
                    | +-y#4 := ColumnRef(type=BOOL, column=tvf_one_relation_arg_with_fixed_output.column_bool#2)
                    +-input_scan=
                      +-GraphRefScan(column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#2])
==

# YIELD is needed to avoid collisions.
# Here it's OK to reuse "column_bool" because CALL PER() with an empty list
# loses all columns from the input table.
select gt.*
from graph_table(aml
  LET column_bool = "a"
  CALL PER() tvf_one_relation_arg_with_fixed_output() YIELD column_bool
  return *
) gt
--
QueryStmt
+-output_column_list=
| +-$graph_table.column_bool#4 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.column_bool#4]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.column_bool#4]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.column_bool#4]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.column_bool#4]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.column_bool#1]
                  | +-expr_list=
                  | | +-column_bool#1 := Literal(type=STRING, value="a")
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-TVFScan
                  | +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#2, column_bytes#3]
                  | +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                  | +-signature=(TABLE<column_bool STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  | +-argument_list=
                  | | +-FunctionArgument
                  | |   +-scan=
                  | |   | +-GraphRefScan(column_list=[$graph_table.column_bool#1])
                  | |   +-argument_column_list=[$graph_table.column_bool#1]
                  | +-column_index_list=[0, 1]
                  | +-function_call_signature=(ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  +-ProjectScan
                    +-column_list=[$graph_table.column_bool#4]
                    +-expr_list=
                    | +-column_bool#4 := ColumnRef(type=BOOL, column=tvf_one_relation_arg_with_fixed_output.column_bool#2)
                    +-input_scan=
                      +-GraphRefScan(column_list=[tvf_one_relation_arg_with_fixed_output.column_bool#2])
==

# YIELD cannot list repeated names.
select gt.*
from graph_table(aml
  LET x = 1
  CALL PER() tvf_one_relation_arg_with_fixed_output() YIELD column_bool, {{column_bool|column_bytes AS column_bool}}
  return *
) gt
--
ALTERNATION GROUP: column_bool
--
ERROR: Name column_bool is already specified in the TVF output [at 4:74]
..._with_fixed_output() YIELD column_bool, column_bool
                                           ^
--
ALTERNATION GROUP: column_bytes AS column_bool
--
ERROR: Name column_bool is already specified in the TVF output [at 4:87]
...YIELD column_bool, column_bytes AS column_bool
                                   ^
==

# YIELD can only reference columns from the TVF's output.
SELECT (
  select count(*)
  from graph_table(aml
    LET inner_col = 1
    CALL PER() tvf_one_relation_arg_with_fixed_output() YIELD {{inner_col|outer_col}} AS y
    return *
  ) gt
) FROM (SELECT 1 AS outer_col)
--
ALTERNATION GROUP: inner_col
--
ERROR: Name inner_col not found in the TVF output [at 5:63]
    CALL PER() tvf_one_relation_arg_with_fixed_output() YIELD inner_col AS y
                                                              ^
--
ALTERNATION GROUP: outer_col
--
ERROR: Name outer_col not found in the TVF output [at 5:63]
    CALL PER() tvf_one_relation_arg_with_fixed_output() YIELD outer_col AS y
                                                              ^
==

# YIELD * is not supported.
select gt.*
from graph_table(aml
  LET column_bool = "a"
  CALL PER() tvf_one_relation_arg_with_fixed_output() YIELD *
  return *
) gt
--
ERROR: Syntax error: Unexpected "*" [at 4:61]
  CALL PER() tvf_one_relation_arg_with_fixed_output() YIELD *
                                                            ^
==

# Test that SqlBuilder with pipe syntax correctly handles a TVF with an explicit
# table argument. Here, the CALL is not partitioned, so no implicit table
# argument is passed.
select gt.*
from graph_table(aml
  LET x = 1
  CALL tvf_one_relation_arg_with_fixed_output((select * from KeyValue))
  return *
) gt
--
QueryStmt
+-output_column_list=
| +-$graph_table.x#6 AS x [INT64]
| +-$graph_table.column_bool#7 AS column_bool [BOOL]
| +-$graph_table.column_bytes#8 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=$graph_table.[x#6, column_bool#7, column_bytes#8]
    +-input_scan=
      +-GraphTableScan
        +-column_list=$graph_table.[x#6, column_bool#7, column_bytes#8]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=$graph_table.[x#6, column_bool#7, column_bytes#8]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=$graph_table.[x#6, column_bool#7, column_bytes#8]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=INT64, value=1)
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-GraphCallScan
                  | +-column_list=[$graph_table.x#1, tvf_one_relation_arg_with_fixed_output.column_bool#4, tvf_one_relation_arg_with_fixed_output.column_bytes#5]
                  | +-optional=FALSE
                  | +-subquery=
                  | | +-TVFScan
                  | |   +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
                  | |   +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                  | |   +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  | |   +-argument_list=
                  | |   | +-FunctionArgument
                  | |   |   +-scan=
                  | |   |   | +-ProjectScan
                  | |   |   |   +-column_list=KeyValue.[Key#2, Value#3]
                  | |   |   |   +-input_scan=
                  | |   |   |     +-TableScan(column_list=KeyValue.[Key#2, Value#3], table=KeyValue, column_index_list=[0, 1])
                  | |   |   +-argument_column_list=KeyValue.[Key#2, Value#3]
                  | |   +-column_index_list=[0, 1]
                  | |   +-function_call_signature=(ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                    +-column_list=$graph_table.[x#6, column_bool#7, column_bytes#8]
                    +-expr_list=
                    | +-x#6 := ColumnRef(type=INT64, column=$graph_table.x#1)
                    | +-column_bool#7 := ColumnRef(type=BOOL, column=tvf_one_relation_arg_with_fixed_output.column_bool#4)
                    | +-column_bytes#8 := ColumnRef(type=BYTES, column=tvf_one_relation_arg_with_fixed_output.column_bytes#5)
                    +-input_scan=
                      +-GraphRefScan(column_list=[$graph_table.x#1, tvf_one_relation_arg_with_fixed_output.column_bool#4, tvf_one_relation_arg_with_fixed_output.column_bytes#5])
==

# CALL PER() tvf as the first statment.
SELECT gt.* FROM
  graph_table(aml
    {{OPTIONAL|}} CALL PER() tvf_one_relation_arg_with_fixed_output()
    return 1 AS one
  ) gt
--
ALTERNATION GROUP: OPTIONAL
--
ERROR: OPTIONAL CALL is not supported on an input with no columns defined [at 3:5]
    OPTIONAL CALL PER() tvf_one_relation_arg_with_fixed_output()
    ^
--
ALTERNATION GROUP: <empty>
--
ERROR: The input table to a CALL PER() TVF must have at least one column [at 3:6]
     CALL PER() tvf_one_relation_arg_with_fixed_output()
     ^
