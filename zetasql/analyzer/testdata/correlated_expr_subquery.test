select (select Key), (select kv.key), (select kv.key + key),
       (select AS STRUCT kv.key, kv.value)
from KeyValue kv
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [INT64]
| +-$query.$col2#10 AS `$col2` [INT64]
| +-$query.$col3#11 AS `$col3` [INT64]
| +-$query.$col4#12 AS `$col4` [STRUCT<key INT64, value STRING>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#9, $col2#10, $col3#11, $col4#12]
    +-expr_list=
    | +-$col1#9 :=
    | | +-SubqueryExpr
    | |   +-type=INT64
    | |   +-subquery_type=SCALAR
    | |   +-parameter_list=
    | |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[$expr_subquery.Key#3]
    | |       +-expr_list=
    | |       | +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    | |       +-input_scan=
    | |         +-SingleRowScan
    | +-$col2#10 :=
    | | +-SubqueryExpr
    | |   +-type=INT64
    | |   +-subquery_type=SCALAR
    | |   +-parameter_list=
    | |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[$expr_subquery.key#4]
    | |       +-expr_list=
    | |       | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    | |       +-input_scan=
    | |         +-SingleRowScan
    | +-$col3#11 :=
    | | +-SubqueryExpr
    | |   +-type=INT64
    | |   +-subquery_type=SCALAR
    | |   +-parameter_list=
    | |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[$expr_subquery.$col1#5]
    | |       +-expr_list=
    | |       | +-$col1#5 :=
    | |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |       |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    | |       |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    | |       +-input_scan=
    | |         +-SingleRowScan
    | +-$col4#12 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<key INT64, value STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#8]
    |         +-expr_list=
    |         | +-$struct#8 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<key INT64, value STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=$expr_subquery.key#6)
    |         |       +-ColumnRef(type=STRING, column=$expr_subquery.value#7)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=$expr_subquery.[key#6, value#7]
    |             +-expr_list=
    |             | +-key#6 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |             | +-value#7 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
==

select (select AS STRUCT kv.*)
from KeyValue kv
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS `$col1` [STRUCT<Key INT64, Value STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<Key INT64, Value STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#5]
    |         +-expr_list=
    |         | +-$struct#5 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<Key INT64, Value STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=$expr_subquery.Key#3)
    |         |       +-ColumnRef(type=STRING, column=$expr_subquery.Value#4)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=$expr_subquery.[Key#3, Value#4]
    |             +-expr_list=
    |             | +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |             | +-Value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
==

select (select kv)
from KeyValue kv;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS `$col1` [STRUCT<Key INT64, Value STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<Key INT64, Value STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.kv#4]
    |         +-expr_list=
    |         | +-kv#4 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<Key INT64, Value STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         |       +-ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
==

# Doubly nested correlated subquery.
# The parameter has to be passed explicitly through the middle query, so the
# parameters show up as CorrelatedColumnRefs rather than ColumnRefs.
select (select (select AS STRUCT key, kv.value))
from KeyValue kv
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [STRUCT<key INT64, value STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<key INT64, value STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#6]
    |         +-expr_list=
    |         | +-$col1#6 :=
    |         |   +-SubqueryExpr
    |         |     +-type=STRUCT<key INT64, value STRING>
    |         |     +-subquery_type=SCALAR
    |         |     +-parameter_list=
    |         |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |         |     +-subquery=
    |         |       +-ProjectScan
    |         |         +-column_list=[$make_struct.$struct#5]
    |         |         +-expr_list=
    |         |         | +-$struct#5 :=
    |         |         |   +-MakeStruct
    |         |         |     +-type=STRUCT<key INT64, value STRING>
    |         |         |     +-field_list=
    |         |         |       +-ColumnRef(type=INT64, column=$expr_subquery.key#3)
    |         |         |       +-ColumnRef(type=STRING, column=$expr_subquery.value#4)
    |         |         +-input_scan=
    |         |           +-ProjectScan
    |         |             +-column_list=$expr_subquery.[key#3, value#4]
    |         |             +-expr_list=
    |         |             | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         |             | +-value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |         |             +-input_scan=
    |         |               +-SingleRowScan
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
==

# Scoping across multiply nested subqueries.
# The middle query is a correlated subquery that also has a table scan.
select value, (select AS STRUCT value, (select AS STRUCT value, kv1.key, kv2.key)
               from KeyValue kv2)
from KeyValue kv1
--
QueryStmt
+-output_column_list=
| +-KeyValue.Value#2 AS value [STRING]
| +-$query.$col2#11 AS `$col2` [STRUCT<value STRING, STRUCT<value STRING, key INT64, key INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Value#2, $query.$col2#11]
    +-expr_list=
    | +-$col2#11 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<value STRING, STRUCT<value STRING, key INT64, key INT64>>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#10]
    |         +-expr_list=
    |         | +-$struct#10 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<value STRING, STRUCT<value STRING, key INT64, key INT64>>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=STRING, column=KeyValue.Value#4)
    |         |       +-ColumnRef(type=STRUCT<value STRING, key INT64, key INT64>, column=$expr_subquery.$col2#9)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[KeyValue.Value#4, $expr_subquery.$col2#9]
    |             +-expr_list=
    |             | +-$col2#9 :=
    |             |   +-SubqueryExpr
    |             |     +-type=STRUCT<value STRING, key INT64, key INT64>
    |             |     +-subquery_type=SCALAR
    |             |     +-parameter_list=
    |             |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |             |     | +-ColumnRef(type=INT64, column=KeyValue.Key#3)
    |             |     | +-ColumnRef(type=STRING, column=KeyValue.Value#4)
    |             |     +-subquery=
    |             |       +-ProjectScan
    |             |         +-column_list=[$make_struct.$struct#8]
    |             |         +-expr_list=
    |             |         | +-$struct#8 :=
    |             |         |   +-MakeStruct
    |             |         |     +-type=STRUCT<value STRING, key INT64, key INT64>
    |             |         |     +-field_list=
    |             |         |       +-ColumnRef(type=STRING, column=$expr_subquery.value#5)
    |             |         |       +-ColumnRef(type=INT64, column=$expr_subquery.key#6)
    |             |         |       +-ColumnRef(type=INT64, column=$expr_subquery.key#7)
    |             |         +-input_scan=
    |             |           +-ProjectScan
    |             |             +-column_list=$expr_subquery.[value#5, key#6, key#7]
    |             |             +-expr_list=
    |             |             | +-value#5 := ColumnRef(type=STRING, column=KeyValue.Value#4, is_correlated=TRUE)
    |             |             | +-key#6 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |             |             | +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#3, is_correlated=TRUE)
    |             |             +-input_scan=
    |             |               +-SingleRowScan
    |             +-input_scan=
    |               +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv1")
==

select (select key)=4, ARRAY(select value)
from KeyValue
where (select AS STRUCT key,value).key = 5
  and EXISTS(select key)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [BOOL]
| +-$query.$col2#10 AS `$col2` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#9, $col2#10]
    +-expr_list=
    | +-$col1#9 :=
    | | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    | |   +-SubqueryExpr
    | |   | +-type=INT64
    | |   | +-subquery_type=SCALAR
    | |   | +-parameter_list=
    | |   | | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    | |   | +-subquery=
    | |   |   +-ProjectScan
    | |   |     +-column_list=[$expr_subquery.key#7]
    | |   |     +-expr_list=
    | |   |     | +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    | |   |     +-input_scan=
    | |   |       +-SingleRowScan
    | |   +-Literal(type=INT64, value=4)
    | +-$col2#10 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<STRING>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.value#8]
    |         +-expr_list=
    |         | +-value#8 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-FilterScan
        +-column_list=KeyValue.[Key#1, Value#2]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
            +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            | +-GetStructField
            | | +-type=INT64
            | | +-expr=
            | | | +-SubqueryExpr
            | | |   +-type=STRUCT<key INT64, value STRING>
            | | |   +-subquery_type=SCALAR
            | | |   +-parameter_list=
            | | |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            | | |   | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | | |   +-subquery=
            | | |     +-ProjectScan
            | | |       +-column_list=[$make_struct.$struct#5]
            | | |       +-expr_list=
            | | |       | +-$struct#5 :=
            | | |       |   +-MakeStruct
            | | |       |     +-type=STRUCT<key INT64, value STRING>
            | | |       |     +-field_list=
            | | |       |       +-ColumnRef(type=INT64, column=$expr_subquery.key#3)
            | | |       |       +-ColumnRef(type=STRING, column=$expr_subquery.value#4)
            | | |       +-input_scan=
            | | |         +-ProjectScan
            | | |           +-column_list=$expr_subquery.[key#3, value#4]
            | | |           +-expr_list=
            | | |           | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
            | | |           | +-value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
            | | |           +-input_scan=
            | | |             +-SingleRowScan
            | | +-field_idx=0
            | +-Literal(type=INT64, value=5)
            +-SubqueryExpr
              +-type=BOOL
              +-subquery_type=EXISTS
              +-parameter_list=
              | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-subquery=
                +-ProjectScan
                  +-column_list=[$expr_subquery.key#6]
                  +-expr_list=
                  | +-key#6 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
                  +-input_scan=
                    +-SingleRowScan
==

# GROUP BY and HAVING with expressions including scalar subqueries.
select (select key)
from KeyValue
group by 1, (select as struct key+key k2).k2
having SUM((select key))>0
--
QueryStmt
+-output_column_list=
| +-$groupby.$col1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.$col1#4]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.$col1#4, $aggregate.$agg1#9]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.$col1#4, $aggregate.$agg1#9]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |   +-group_by_list=
        |   | +-$col1#4 :=
        |   | | +-SubqueryExpr
        |   | |   +-type=INT64
        |   | |   +-subquery_type=SCALAR
        |   | |   +-parameter_list=
        |   | |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   | |   +-subquery=
        |   | |     +-ProjectScan
        |   | |       +-column_list=[$expr_subquery.key#3]
        |   | |       +-expr_list=
        |   | |       | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |   | |       +-input_scan=
        |   | |         +-SingleRowScan
        |   | +-k2#7 :=
        |   |   +-GetStructField
        |   |     +-type=INT64
        |   |     +-expr=
        |   |     | +-SubqueryExpr
        |   |     |   +-type=STRUCT<k2 INT64>
        |   |     |   +-subquery_type=SCALAR
        |   |     |   +-parameter_list=
        |   |     |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |     |   +-subquery=
        |   |     |     +-ProjectScan
        |   |     |       +-column_list=[$make_struct.$struct#6]
        |   |     |       +-expr_list=
        |   |     |       | +-$struct#6 :=
        |   |     |       |   +-MakeStruct
        |   |     |       |     +-type=STRUCT<k2 INT64>
        |   |     |       |     +-field_list=
        |   |     |       |       +-ColumnRef(type=INT64, column=$expr_subquery.k2#5)
        |   |     |       +-input_scan=
        |   |     |         +-ProjectScan
        |   |     |           +-column_list=[$expr_subquery.k2#5]
        |   |     |           +-expr_list=
        |   |     |           | +-k2#5 :=
        |   |     |           |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |     |           |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |   |     |           |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |   |     |           +-input_scan=
        |   |     |             +-SingleRowScan
        |   |     +-field_idx=0
        |   +-aggregate_list=
        |     +-$agg1#9 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-SubqueryExpr
        |           +-type=INT64
        |           +-subquery_type=SCALAR
        |           +-parameter_list=
        |           | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |           +-subquery=
        |             +-ProjectScan
        |               +-column_list=[$expr_subquery.key#8]
        |               +-expr_list=
        |               | +-key#8 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |               +-input_scan=
        |                 +-SingleRowScan
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=$aggregate.$agg1#9)
            +-Literal(type=INT64, value=0)
==

# We cannot see the aliases from the select clause inside a subquery in the
# where clause.
select key k2
from KeyValue
where (select key > 0) and (select k2 > 0)
--
ERROR: Unrecognized name: k2 [at 3:36]
where (select key > 0) and (select k2 > 0)
                                   ^
==

# We currently cannot see the aliases from the select clause inside a subquery
# in GROUP BY, but this should work once other alias references work there.
# TODO.
select key k2
from KeyValue
group by (select key), (select k2)
--
ERROR: Unrecognized name: k2 [at 3:32]
group by (select key), (select k2)
                               ^
==

select value
from KeyValue
order by (select key + 1)
--
QueryStmt
+-output_column_list=
| +-KeyValue.Value#2 AS value [STRING]
+-query=
  +-OrderByScan
    +-column_list=[KeyValue.Value#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#4]
    |   +-expr_list=
    |   | +-$orderbycol1#4 :=
    |   |   +-SubqueryExpr
    |   |     +-type=INT64
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$expr_subquery.$col1#3]
    |   |         +-expr_list=
    |   |         | +-$col1#3 :=
    |   |         |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |         |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |   |         |     +-Literal(type=INT64, value=1)
    |   |         +-input_scan=
    |   |           +-SingleRowScan
    |   +-input_scan=
    |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
==

# Using a correlated subquery to join to another table.
select *, ARRAY(select AS STRUCT * from KeyValue2 kv2 where kv2.key=kv1.key)
from KeyValue kv1
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-$query.$col2#6 AS `$col2` [ARRAY<STRUCT<Key INT64, Value2 STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $query.$col2#6]
    +-expr_list=
    | +-$col2#6 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<STRUCT<Key INT64, Value2 STRING>>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#5]
    |         +-expr_list=
    |         | +-$struct#5 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<Key INT64, Value2 STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=KeyValue2.Key#3)
    |         |       +-ColumnRef(type=STRING, column=KeyValue2.Value2#4)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=KeyValue2.[Key#3, Value2#4]
    |             +-input_scan=
    |               +-FilterScan
    |                 +-column_list=KeyValue2.[Key#3, Value2#4]
    |                 +-input_scan=
    |                 | +-TableScan(column_list=KeyValue2.[Key#3, Value2#4], table=KeyValue2, column_index_list=[0, 1], alias="kv2")
    |                 +-filter_expr=
    |                   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |                     +-ColumnRef(type=INT64, column=KeyValue2.Key#3)
    |                     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv1")
==

# Using a correlated subquery in the WHERE clause to find a maximal value.
select *
from KeyValue kv1
where kv1.key = (select max(kv2.key) from KeyValue kv2 where kv1.key = kv2.key)
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
      +-FilterScan
        +-column_list=KeyValue.[Key#1, Value#2]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv1")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-SubqueryExpr
              +-type=INT64
              +-subquery_type=SCALAR
              +-parameter_list=
              | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-subquery=
                +-ProjectScan
                  +-column_list=[$aggregate.$agg1#5]
                  +-input_scan=
                    +-AggregateScan
                      +-column_list=[$aggregate.$agg1#5]
                      +-input_scan=
                      | +-FilterScan
                      |   +-column_list=[KeyValue.Key#3]
                      |   +-input_scan=
                      |   | +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0], alias="kv2")
                      |   +-filter_expr=
                      |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                      |       +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
                      |       +-ColumnRef(type=INT64, column=KeyValue.Key#3)
                      +-aggregate_list=
                        +-$agg1#5 :=
                          +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                            +-ColumnRef(type=INT64, column=KeyValue.Key#3)
==

# This shows that correlated column references ARE NOT visible in JOIN USING.
select
  (select * from (select 3 aaa) join (select 4 ccc) using (aaa))
from (select 1 aaa, 2 bbb)
--
ERROR: Column aaa in USING clause not found on right side of join [at 2:60]
  (select * from (select 3 aaa) join (select 4 ccc) using (aaa))
                                                           ^
==

# This shows correlated column references ARE visible in JOIN ON.
select
  ARRAY(select ccc from (select 3 aaa) join (select 4 ccc) on aaa=bbb)
from (select 1 aaa, 2 bbb)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<INT64>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$subquery1.bbb#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$subquery3.ccc#4]
    |         +-input_scan=
    |           +-JoinScan
    |             +-column_list=[$subquery2.aaa#3, $subquery3.ccc#4]
    |             +-left_scan=
    |             | +-ProjectScan
    |             |   +-column_list=[$subquery2.aaa#3]
    |             |   +-expr_list=
    |             |   | +-aaa#3 := Literal(type=INT64, value=3)
    |             |   +-input_scan=
    |             |     +-SingleRowScan
    |             +-right_scan=
    |             | +-ProjectScan
    |             |   +-column_list=[$subquery3.ccc#4]
    |             |   +-expr_list=
    |             |   | +-ccc#4 := Literal(type=INT64, value=4)
    |             |   +-input_scan=
    |             |     +-SingleRowScan
    |             +-join_expr=
    |               +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |                 +-ColumnRef(type=INT64, column=$subquery2.aaa#3)
    |                 +-ColumnRef(type=INT64, column=$subquery1.bbb#2, is_correlated=TRUE)
    +-input_scan=
      +-ProjectScan
        +-column_list=$subquery1.[aaa#1, bbb#2]
        +-expr_list=
        | +-aaa#1 := Literal(type=INT64, value=1)
        | +-bbb#2 := Literal(type=INT64, value=2)
        +-input_scan=
          +-SingleRowScan
==

# This shows a correlated subquery in the ON clause.
select *
from KeyValue kv1 JOIN KeyValue kv2 ON (select kv1.key=kv2.key)
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Key#3 AS Key [INT64]
| +-KeyValue.Value#4 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    +-input_scan=
      +-JoinScan
        +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
        +-left_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv1")
        +-right_scan=
        | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
        +-join_expr=
          +-SubqueryExpr
            +-type=BOOL
            +-subquery_type=SCALAR
            +-parameter_list=
            | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            | +-ColumnRef(type=INT64, column=KeyValue.Key#3)
            +-subquery=
              +-ProjectScan
                +-column_list=[$expr_subquery.$col1#5]
                +-expr_list=
                | +-$col1#5 :=
                |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#3, is_correlated=TRUE)
                +-input_scan=
                  +-SingleRowScan
==

select (select count(*) from tt.KitchenSink.repeated_int32_val)
from TestTable tt
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$aggregate.$agg1#5]
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$aggregate.$agg1#5]
    |             +-input_scan=
    |             | +-ArrayScan
    |             |   +-array_expr=
    |             |   | +-GetProtoField
    |             |   |   +-type=ARRAY<INT32>
    |             |   |   +-expr=
    |             |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |             |   |   +-field_descriptor=repeated_int32_val
    |             |   |   +-default_value=[]
    |             |   +-element_column=$array.repeated_int32_val#4
    |             +-aggregate_list=
    |               +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
==

select (select AS STRUCT tt.TestEnum, dt from tt.KitchenSink.repeated_date dt)
from TestTable tt
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [STRUCT<TestEnum ENUM<zetasql_test__.TestEnum>, dt DATE>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<TestEnum ENUM<zetasql_test__.TestEnum>, dt DATE>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#2)
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#6]
    |         +-expr_list=
    |         | +-$struct#6 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<TestEnum ENUM<zetasql_test__.TestEnum>, dt DATE>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=$expr_subquery.TestEnum#5)
    |         |       +-ColumnRef(type=DATE, column=$array.dt#4)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$expr_subquery.TestEnum#5, $array.dt#4]
    |             +-expr_list=
    |             | +-TestEnum#5 := ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#2, is_correlated=TRUE)
    |             +-input_scan=
    |               +-ArrayScan
    |                 +-column_list=[$array.dt#4]
    |                 +-array_expr=
    |                 | +-GetProtoField
    |                 |   +-type=ARRAY<DATE>
    |                 |   +-expr=
    |                 |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |                 |   +-field_descriptor=repeated_date
    |                 |   +-default_value=[]
    |                 |   +-format=DATE
    |                 +-element_column=$array.dt#4
    +-input_scan=
      +-TableScan(column_list=TestTable.[TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[1, 2], alias="tt")
==

select (select count(*) from KeyValue, subq.values)
from (select key, array_agg(value) values from KeyValue group by 1) subq
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=ARRAY<STRING>, column=$aggregate.values#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$aggregate.$agg1#8]
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$aggregate.$agg1#8]
    |             +-input_scan=
    |             | +-ArrayScan
    |             |   +-input_scan=
    |             |   | +-TableScan(table=KeyValue)
    |             |   +-array_expr=
    |             |   | +-ColumnRef(type=ARRAY<STRING>, column=$aggregate.values#3, is_correlated=TRUE)
    |             |   +-element_column=$array.values#7
    |             +-aggregate_list=
    |               +-$agg1#8 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$groupby.key#4, $aggregate.values#3]
        +-input_scan=
          +-AggregateScan
            +-column_list=[$groupby.key#4, $aggregate.values#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-group_by_list=
            | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-aggregate_list=
              +-values#3 :=
                +-AggregateFunctionCall(ZetaSQL:array_agg(STRING) -> ARRAY<STRING>)
                  +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

select (select value)
from KeyValue kv
group by value
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-SubqueryExpr
    |     +-type=STRING
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=STRING, column=$groupby.value#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.value#5]
    |         +-expr_list=
    |         | +-value#5 := ColumnRef(type=STRING, column=$groupby.value#4, is_correlated=TRUE)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.value#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1], alias="kv")
        +-group_by_list=
          +-value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# Note that both references to 'value' in the subquery resolve to the
# correlated column reference.  The GROUP BY 'value' does *not* resolve
# to the SELECT list alias.
select
  ARRAY(select value from (select 1) group by value)
from KeyValue kv
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<STRING>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$groupby.value#4]
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$groupby.value#4]
    |             +-input_scan=
    |             | +-ProjectScan
    |             |   +-column_list=[$subquery1.$col1#3]
    |             |   +-expr_list=
    |             |   | +-$col1#3 := Literal(type=INT64, value=1)
    |             |   +-input_scan=
    |             |     +-SingleRowScan
    |             +-group_by_list=
    |               +-value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1], alias="kv")
==

# Note the behavor when referencing 'key' in the subquery's SELECT list.
# It resolves to the correlated column 'kv.key'.  In a previous
# implementation it used to resolve to the grouped version of 'key'.
select
  ARRAY(select key+1 from (select 1) group by key)
from KeyValue kv
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<INT64>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#5]
    |         +-expr_list=
    |         | +-$col1#5 :=
    |         |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |         |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         |     +-Literal(type=INT64, value=1)
    |         +-input_scan=
    |           +-AggregateScan
    |             +-input_scan=
    |             | +-ProjectScan
    |             |   +-column_list=[$subquery1.$col1#3]
    |             |   +-expr_list=
    |             |   | +-$col1#3 := Literal(type=INT64, value=1)
    |             |   +-input_scan=
    |             |     +-SingleRowScan
    |             +-group_by_list=
    |               +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
==

select count(*)
from (select count(*) x from KeyValue kv) T
where (select {{as value|}} {{T.|}}x as y from KeyValue GROUP BY {{T.|}}x) = 1
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#8 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#8]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#8]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[$aggregate.x#3]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.x#3]
        |   |   +-input_scan=
        |   |     +-AggregateScan
        |   |       +-column_list=[$aggregate.x#3]
        |   |       +-input_scan=
        |   |       | +-TableScan(table=KeyValue, alias="kv")
        |   |       +-aggregate_list=
        |   |         +-x#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-SubqueryExpr
        |       | +-type=INT64
        |       | +-subquery_type=SCALAR
        |       | +-parameter_list=
        |       | | +-ColumnRef(type=INT64, column=$aggregate.x#3)
        |       | +-subquery=
        |       |   +-ProjectScan
        |       |     +-column_list=[$expr_subquery.y#7]
        |       |     +-expr_list=
        |       |     | +-y#7 := ColumnRef(type=INT64, column=$aggregate.x#3, is_correlated=TRUE)
        |       |     +-input_scan=
        |       |       +-AggregateScan
        |       |         +-input_scan=
        |       |         | +-TableScan(table=KeyValue)
        |       |         +-group_by_list=
        |       |           +-x#6 := ColumnRef(type=INT64, column=$aggregate.x#3, is_correlated=TRUE)
        |       +-Literal(type=INT64, value=1)
        +-aggregate_list=
          +-$agg1#8 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

# Same test with value tables.
select count(*)
from (select count(*) x from TestStructValueTable tsvt) T
where (select {{T.|}}x as y from TestStructValueTable GROUP BY {{T.|}}x) = 1
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#6 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#6]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#6]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[$aggregate.x#2]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.x#2]
        |   |   +-input_scan=
        |   |     +-AggregateScan
        |   |       +-column_list=[$aggregate.x#2]
        |   |       +-input_scan=
        |   |       | +-TableScan(table=TestStructValueTable, alias="tsvt")
        |   |       +-aggregate_list=
        |   |         +-x#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-SubqueryExpr
        |       | +-type=INT64
        |       | +-subquery_type=SCALAR
        |       | +-parameter_list=
        |       | | +-ColumnRef(type=INT64, column=$aggregate.x#2)
        |       | +-subquery=
        |       |   +-ProjectScan
        |       |     +-column_list=[$expr_subquery.y#5]
        |       |     +-expr_list=
        |       |     | +-y#5 := ColumnRef(type=INT64, column=$aggregate.x#2, is_correlated=TRUE)
        |       |     +-input_scan=
        |       |       +-AggregateScan
        |       |         +-input_scan=
        |       |         | +-TableScan(table=TestStructValueTable)
        |       |         +-group_by_list=
        |       |           +-x#4 := ColumnRef(type=INT64, column=$aggregate.x#2, is_correlated=TRUE)
        |       +-Literal(type=INT64, value=1)
        +-aggregate_list=
          +-$agg1#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

select count(*)
from (select count(*) a from KeyValue kv) T
where (select count(*) + T.a from KeyValue) = 1
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#8 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#8]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#8]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[$aggregate.a#3]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.a#3]
        |   |   +-input_scan=
        |   |     +-AggregateScan
        |   |       +-column_list=[$aggregate.a#3]
        |   |       +-input_scan=
        |   |       | +-TableScan(table=KeyValue, alias="kv")
        |   |       +-aggregate_list=
        |   |         +-a#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-SubqueryExpr
        |       | +-type=INT64
        |       | +-subquery_type=SCALAR
        |       | +-parameter_list=
        |       | | +-ColumnRef(type=INT64, column=$aggregate.a#3)
        |       | +-subquery=
        |       |   +-ProjectScan
        |       |     +-column_list=[$expr_subquery.$col1#7]
        |       |     +-expr_list=
        |       |     | +-$col1#7 :=
        |       |     |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       |     |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        |       |     |     +-ColumnRef(type=INT64, column=$aggregate.a#3, is_correlated=TRUE)
        |       |     +-input_scan=
        |       |       +-AggregateScan
        |       |         +-column_list=[$aggregate.$agg1#6]
        |       |         +-input_scan=
        |       |         | +-TableScan(table=KeyValue)
        |       |         +-aggregate_list=
        |       |           +-$agg1#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |       +-Literal(type=INT64, value=1)
        +-aggregate_list=
          +-$agg1#8 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

select
  ARRAY(select sum(key) from (select 1))
from KeyValue kv
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<INT64>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$aggregate.$agg1#4]
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$aggregate.$agg1#4]
    |             +-input_scan=
    |             | +-ProjectScan
    |             |   +-column_list=[$subquery1.$col1#3]
    |             |   +-expr_list=
    |             |   | +-$col1#3 := Literal(type=INT64, value=1)
    |             |   +-input_scan=
    |             |     +-SingleRowScan
    |             +-aggregate_list=
    |               +-$agg1#4 :=
    |                 +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |                   +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
==

# A table subquery inside an expression subquery should be able to see a
# correlated column.
select
  ARRAY(select dt from (select dt from tt.KitchenSink.repeated_date dt))
from TestTable tt
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS `$col1` [ARRAY<DATE>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<DATE>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$array.dt#4]
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$array.dt#4]
    |             +-input_scan=
    |               +-ArrayScan
    |                 +-column_list=[$array.dt#4]
    |                 +-array_expr=
    |                 | +-GetProtoField
    |                 |   +-type=ARRAY<DATE>
    |                 |   +-expr=
    |                 |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |                 |   +-field_descriptor=repeated_date
    |                 |   +-default_value=[]
    |                 |   +-format=DATE
    |                 +-element_column=$array.dt#4
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
==

# A table subquery inside a table subquery inside an expression subquery
# inside an expression subquery, also with an expression subquery inside it.
select
  (select ARRAY(
    select dt from (
      select dt from (
        select dt, (select count(*) from tt.KitchenSink.repeated_date)
        from tt.KitchenSink.repeated_date dt))))
from TestTable tt
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [ARRAY<DATE>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<DATE>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#8]
    |         +-expr_list=
    |         | +-$col1#8 :=
    |         |   +-SubqueryExpr
    |         |     +-type=ARRAY<DATE>
    |         |     +-subquery_type=ARRAY
    |         |     +-parameter_list=
    |         |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |         |     +-subquery=
    |         |       +-ProjectScan
    |         |         +-column_list=[$array.dt#4]
    |         |         +-input_scan=
    |         |           +-ProjectScan
    |         |             +-column_list=[$array.dt#4]
    |         |             +-input_scan=
    |         |               +-ProjectScan
    |         |                 +-column_list=[$array.dt#4, $subquery2.$col2#7]
    |         |                 +-expr_list=
    |         |                 | +-$col2#7 :=
    |         |                 |   +-SubqueryExpr
    |         |                 |     +-type=INT64
    |         |                 |     +-subquery_type=SCALAR
    |         |                 |     +-parameter_list=
    |         |                 |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |         |                 |     +-subquery=
    |         |                 |       +-ProjectScan
    |         |                 |         +-column_list=[$aggregate.$agg1#6]
    |         |                 |         +-input_scan=
    |         |                 |           +-AggregateScan
    |         |                 |             +-column_list=[$aggregate.$agg1#6]
    |         |                 |             +-input_scan=
    |         |                 |             | +-ArrayScan
    |         |                 |             |   +-array_expr=
    |         |                 |             |   | +-GetProtoField
    |         |                 |             |   |   +-type=ARRAY<DATE>
    |         |                 |             |   |   +-expr=
    |         |                 |             |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |         |                 |             |   |   +-field_descriptor=repeated_date
    |         |                 |             |   |   +-default_value=[]
    |         |                 |             |   |   +-format=DATE
    |         |                 |             |   +-element_column=$array.repeated_date#5
    |         |                 |             +-aggregate_list=
    |         |                 |               +-$agg1#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    |         |                 +-input_scan=
    |         |                   +-ArrayScan
    |         |                     +-column_list=[$array.dt#4]
    |         |                     +-array_expr=
    |         |                     | +-GetProtoField
    |         |                     |   +-type=ARRAY<DATE>
    |         |                     |   +-expr=
    |         |                     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |         |                     |   +-field_descriptor=repeated_date
    |         |                     |   +-default_value=[]
    |         |                     |   +-format=DATE
    |         |                     +-element_column=$array.dt#4
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
==

# A complex case with multiple scans of nested arrays with correlated subqueries.
select
  (select sum(v.nested_int64)
   from tt.KitchenSink.nested_repeated_value v
   where exists (select v2 from v.nested_repeated_int64 v2 where v2 = (select count(*) from v.nested_repeated_int64)))
from TestTable tt
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$aggregate.$agg1#8]
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$aggregate.$agg1#8]
    |             +-input_scan=
    |             | +-FilterScan
    |             |   +-column_list=[$array.v#4]
    |             |   +-input_scan=
    |             |   | +-ArrayScan
    |             |   |   +-column_list=[$array.v#4]
    |             |   |   +-array_expr=
    |             |   |   | +-GetProtoField
    |             |   |   |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
    |             |   |   |   +-expr=
    |             |   |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |             |   |   |   +-field_descriptor=nested_repeated_value
    |             |   |   |   +-default_value=[]
    |             |   |   +-element_column=$array.v#4
    |             |   +-filter_expr=
    |             |     +-SubqueryExpr
    |             |       +-type=BOOL
    |             |       +-subquery_type=EXISTS
    |             |       +-parameter_list=
    |             |       | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.v#4)
    |             |       +-subquery=
    |             |         +-ProjectScan
    |             |           +-column_list=[$array.v2#5]
    |             |           +-input_scan=
    |             |             +-FilterScan
    |             |               +-column_list=[$array.v2#5]
    |             |               +-input_scan=
    |             |               | +-ArrayScan
    |             |               |   +-column_list=[$array.v2#5]
    |             |               |   +-array_expr=
    |             |               |   | +-GetProtoField
    |             |               |   |   +-type=ARRAY<INT64>
    |             |               |   |   +-expr=
    |             |               |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.v#4, is_correlated=TRUE)
    |             |               |   |   +-field_descriptor=nested_repeated_int64
    |             |               |   |   +-default_value=[]
    |             |               |   +-element_column=$array.v2#5
    |             |               +-filter_expr=
    |             |                 +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |             |                   +-ColumnRef(type=INT64, column=$array.v2#5)
    |             |                   +-SubqueryExpr
    |             |                     +-type=INT64
    |             |                     +-subquery_type=SCALAR
    |             |                     +-parameter_list=
    |             |                     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.v#4, is_correlated=TRUE)
    |             |                     +-subquery=
    |             |                       +-ProjectScan
    |             |                         +-column_list=[$aggregate.$agg1#7]
    |             |                         +-input_scan=
    |             |                           +-AggregateScan
    |             |                             +-column_list=[$aggregate.$agg1#7]
    |             |                             +-input_scan=
    |             |                             | +-ArrayScan
    |             |                             |   +-array_expr=
    |             |                             |   | +-GetProtoField
    |             |                             |   |   +-type=ARRAY<INT64>
    |             |                             |   |   +-expr=
    |             |                             |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.v#4, is_correlated=TRUE)
    |             |                             |   |   +-field_descriptor=nested_repeated_int64
    |             |                             |   |   +-default_value=[]
    |             |                             |   +-element_column=$array.nested_repeated_int64#6
    |             |                             +-aggregate_list=
    |             |                               +-$agg1#7 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    |             +-aggregate_list=
    |               +-$agg1#8 :=
    |                 +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |                   +-GetProtoField
    |                     +-type=INT64
    |                     +-expr=
    |                     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.v#4)
    |                     +-field_descriptor=nested_int64
    |                     +-default_value=88
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
==

# While resolving a subquery we override any global range variable with local
# range variable. So with "TestTable" in EXISTS subquery we are doing another
# scan of a second copy of TestTable.
select *
from TestTable
where EXISTS(select 1 from TestTable, TestTable.KitchenSink.repeated_int32_val)
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3]
    +-input_scan=
      +-FilterScan
        +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
        +-filter_expr=
          +-SubqueryExpr
            +-type=BOOL
            +-subquery_type=EXISTS
            +-subquery=
              +-ProjectScan
                +-column_list=[$expr_subquery.$col1#8]
                +-expr_list=
                | +-$col1#8 := Literal(type=INT64, value=1)
                +-input_scan=
                  +-ArrayScan
                    +-column_list=[TestTable.KitchenSink#6]
                    +-input_scan=
                    | +-TableScan(column_list=[TestTable.KitchenSink#6], table=TestTable, column_index_list=[2])
                    +-array_expr=
                    | +-GetProtoField
                    |   +-type=ARRAY<INT32>
                    |   +-expr=
                    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#6)
                    |   +-field_descriptor=repeated_int32_val
                    |   +-default_value=[]
                    +-element_column=$array.repeated_int32_val#7
==

# SELECT DISTINCT with ORDER BY in correlated subquery, but the SELECT list
# and ORDER BY do not have correlated references.
select EXISTS(select distinct v
              from tt.KitchenSink.repeated_int32_val v
              order by v)
from TestTable tt
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=EXISTS
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-subquery=
    |       +-OrderByScan
    |         +-column_list=[$distinct.v#5]
    |         +-input_scan=
    |         | +-AggregateScan
    |         |   +-column_list=[$distinct.v#5]
    |         |   +-input_scan=
    |         |   | +-ArrayScan
    |         |   |   +-column_list=[$array.v#4]
    |         |   |   +-array_expr=
    |         |   |   | +-GetProtoField
    |         |   |   |   +-type=ARRAY<INT32>
    |         |   |   |   +-expr=
    |         |   |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |         |   |   |   +-field_descriptor=repeated_int32_val
    |         |   |   |   +-default_value=[]
    |         |   |   +-element_column=$array.v#4
    |         |   +-group_by_list=
    |         |     +-v#5 := ColumnRef(type=INT32, column=$array.v#4)
    |         +-order_by_item_list=
    |           +-OrderByItem
    |             +-column_ref=
    |               +-ColumnRef(type=INT32, column=$distinct.v#5)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
==

# SELECT DISTINCT with ORDER BY, including a correlated column in the ORDER BY.
# This works because outer references are effectively constant for the
# subquery, so the correlated column is still 'visible' after
# DISTINCT.
select EXISTS(select distinct v
              from tt.KitchenSink.repeated_int32_val v
              order by v, tt.key)
from TestTable tt
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=EXISTS
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT32, column=TestTable.key#1)
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-subquery=
    |       +-OrderByScan
    |         +-column_list=[$distinct.v#5]
    |         +-input_scan=
    |         | +-ProjectScan
    |         |   +-column_list=[$distinct.v#5, $orderby.$orderbycol2#6]
    |         |   +-expr_list=
    |         |   | +-$orderbycol2#6 := ColumnRef(type=INT32, column=TestTable.key#1, is_correlated=TRUE)
    |         |   +-input_scan=
    |         |     +-AggregateScan
    |         |       +-column_list=[$distinct.v#5]
    |         |       +-input_scan=
    |         |       | +-ArrayScan
    |         |       |   +-column_list=[$array.v#4]
    |         |       |   +-array_expr=
    |         |       |   | +-GetProtoField
    |         |       |   |   +-type=ARRAY<INT32>
    |         |       |   |   +-expr=
    |         |       |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |         |       |   |   +-field_descriptor=repeated_int32_val
    |         |       |   |   +-default_value=[]
    |         |       |   +-element_column=$array.v#4
    |         |       +-group_by_list=
    |         |         +-v#5 := ColumnRef(type=INT32, column=$array.v#4)
    |         +-order_by_item_list=
    |           +-OrderByItem
    |           | +-column_ref=
    |           |   +-ColumnRef(type=INT32, column=$distinct.v#5)
    |           +-OrderByItem
    |             +-column_ref=
    |               +-ColumnRef(type=INT32, column=$orderby.$orderbycol2#6)
    +-input_scan=
      +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2], alias="tt")
==

# SELECT DISTINCT with ORDER BY for correlated column.
select EXISTS(select distinct tt.key
              from tt.KitchenSink.repeated_int32_val v
              order by tt.key)
from TestTable tt
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8]
    +-expr_list=
    | +-$col1#8 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=EXISTS
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT32, column=TestTable.key#1)
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-subquery=
    |       +-OrderByScan
    |         +-column_list=[$distinct.key#6]
    |         +-input_scan=
    |         | +-ProjectScan
    |         |   +-column_list=[$distinct.key#6, $orderby.$orderbycol1#7]
    |         |   +-expr_list=
    |         |   | +-$orderbycol1#7 := ColumnRef(type=INT32, column=TestTable.key#1, is_correlated=TRUE)
    |         |   +-input_scan=
    |         |     +-AggregateScan
    |         |       +-column_list=[$distinct.key#6]
    |         |       +-input_scan=
    |         |       | +-ProjectScan
    |         |       |   +-column_list=[$expr_subquery.key#5]
    |         |       |   +-expr_list=
    |         |       |   | +-key#5 := ColumnRef(type=INT32, column=TestTable.key#1, is_correlated=TRUE)
    |         |       |   +-input_scan=
    |         |       |     +-ArrayScan
    |         |       |       +-array_expr=
    |         |       |       | +-GetProtoField
    |         |       |       |   +-type=ARRAY<INT32>
    |         |       |       |   +-expr=
    |         |       |       |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |         |       |       |   +-field_descriptor=repeated_int32_val
    |         |       |       |   +-default_value=[]
    |         |       |       +-element_column=$array.v#4
    |         |       +-group_by_list=
    |         |         +-key#6 := ColumnRef(type=INT32, column=$expr_subquery.key#5)
    |         +-order_by_item_list=
    |           +-OrderByItem
    |             +-column_ref=
    |               +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#7)
    +-input_scan=
      +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2], alias="tt")
==

# SELECT DISTINCT with ORDER BY, where both the SELECT list and ORDER BY
# have one correlated column and one non-correlated column.
select EXISTS(select distinct v, tt.key
              from tt.KitchenSink.repeated_int32_val v
              order by v, tt.key)
from TestTable tt
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=EXISTS
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT32, column=TestTable.key#1)
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-subquery=
    |       +-OrderByScan
    |         +-column_list=$distinct.[v#6, key#7]
    |         +-input_scan=
    |         | +-ProjectScan
    |         |   +-column_list=[$distinct.v#6, $distinct.key#7, $orderby.$orderbycol2#8]
    |         |   +-expr_list=
    |         |   | +-$orderbycol2#8 := ColumnRef(type=INT32, column=TestTable.key#1, is_correlated=TRUE)
    |         |   +-input_scan=
    |         |     +-AggregateScan
    |         |       +-column_list=$distinct.[v#6, key#7]
    |         |       +-input_scan=
    |         |       | +-ProjectScan
    |         |       |   +-column_list=[$array.v#4, $expr_subquery.key#5]
    |         |       |   +-expr_list=
    |         |       |   | +-key#5 := ColumnRef(type=INT32, column=TestTable.key#1, is_correlated=TRUE)
    |         |       |   +-input_scan=
    |         |       |     +-ArrayScan
    |         |       |       +-column_list=[$array.v#4]
    |         |       |       +-array_expr=
    |         |       |       | +-GetProtoField
    |         |       |       |   +-type=ARRAY<INT32>
    |         |       |       |   +-expr=
    |         |       |       |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |         |       |       |   +-field_descriptor=repeated_int32_val
    |         |       |       |   +-default_value=[]
    |         |       |       +-element_column=$array.v#4
    |         |       +-group_by_list=
    |         |         +-v#6 := ColumnRef(type=INT32, column=$array.v#4)
    |         |         +-key#7 := ColumnRef(type=INT32, column=$expr_subquery.key#5)
    |         +-order_by_item_list=
    |           +-OrderByItem
    |           | +-column_ref=
    |           |   +-ColumnRef(type=INT32, column=$distinct.v#6)
    |           +-OrderByItem
    |             +-column_ref=
    |               +-ColumnRef(type=INT32, column=$orderby.$orderbycol2#8)
    +-input_scan=
      +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2], alias="tt")
==

# Same test as previous, but with SELECT list ordinals in the ORDER BY.
select EXISTS(select distinct v, tt.key
              from tt.KitchenSink.repeated_int32_val v
              order by 1, 2)
from TestTable tt
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8]
    +-expr_list=
    | +-$col1#8 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=EXISTS
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT32, column=TestTable.key#1)
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-subquery=
    |       +-OrderByScan
    |         +-column_list=$distinct.[v#6, key#7]
    |         +-input_scan=
    |         | +-AggregateScan
    |         |   +-column_list=$distinct.[v#6, key#7]
    |         |   +-input_scan=
    |         |   | +-ProjectScan
    |         |   |   +-column_list=[$array.v#4, $expr_subquery.key#5]
    |         |   |   +-expr_list=
    |         |   |   | +-key#5 := ColumnRef(type=INT32, column=TestTable.key#1, is_correlated=TRUE)
    |         |   |   +-input_scan=
    |         |   |     +-ArrayScan
    |         |   |       +-column_list=[$array.v#4]
    |         |   |       +-array_expr=
    |         |   |       | +-GetProtoField
    |         |   |       |   +-type=ARRAY<INT32>
    |         |   |       |   +-expr=
    |         |   |       |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
    |         |   |       |   +-field_descriptor=repeated_int32_val
    |         |   |       |   +-default_value=[]
    |         |   |       +-element_column=$array.v#4
    |         |   +-group_by_list=
    |         |     +-v#6 := ColumnRef(type=INT32, column=$array.v#4)
    |         |     +-key#7 := ColumnRef(type=INT32, column=$expr_subquery.key#5)
    |         +-order_by_item_list=
    |           +-OrderByItem
    |           | +-column_ref=
    |           |   +-ColumnRef(type=INT32, column=$distinct.v#6)
    |           +-OrderByItem
    |             +-column_ref=
    |               +-ColumnRef(type=INT32, column=$distinct.key#7)
    +-input_scan=
      +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2], alias="tt")
==

# This error test case is a simplified version of b/20920755 that originally
# failed with an internal error.  It should fail because we GROUP BY tt.key
# but reference tt.KitchenSink.repeated_int32_val in the SELECT list
# subquery, even though tt.KitchenSink.repeated_int32_val is not grouped in
# the main query so it is not visible post-GROUP BY.
select tt.key as key, IF(EXISTS(select *
                                from tt.KitchenSink.repeated_int32_val),
                         count(distinct(tt.key)),
                         0)
from TestTable tt
group by tt.key
--
ERROR: Correlated aliases referenced in the from clause must refer to arrays that are valid to access from the outer query, but tt refers to an array that is not valid to access after GROUP BY or DISTINCT in the outer query [at 2:38]
                                from tt.KitchenSink.repeated_int32_val),
                                     ^
==

# A test at the intersection of b/19439798 and b/20529177.  In particular,
# grouped versions of correlated range variable references should not
# get added to the correlated subquery parameter list.
select count(*)
from UNNEST(["a", "b", "c"]) ex
where (select ex from KeyValue GROUP BY ex order by ex) = 'a'
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[$array.ex#1]
        |   +-input_scan=
        |   | +-ArrayScan
        |   |   +-column_list=[$array.ex#1]
        |   |   +-array_expr=
        |   |   | +-Literal(type=ARRAY<STRING>, value=["a", "b", "c"])
        |   |   +-element_column=$array.ex#1
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
        |       +-SubqueryExpr
        |       | +-type=STRING
        |       | +-subquery_type=SCALAR
        |       | +-parameter_list=
        |       | | +-ColumnRef(type=STRING, column=$array.ex#1)
        |       | +-subquery=
        |       |   +-OrderByScan
        |       |     +-column_list=[$groupby.ex#4]
        |       |     +-input_scan=
        |       |     | +-AggregateScan
        |       |     |   +-column_list=[$groupby.ex#4]
        |       |     |   +-input_scan=
        |       |     |   | +-TableScan(table=KeyValue)
        |       |     |   +-group_by_list=
        |       |     |     +-ex#4 := ColumnRef(type=STRING, column=$array.ex#1, is_correlated=TRUE)
        |       |     +-order_by_item_list=
        |       |       +-OrderByItem
        |       |         +-column_ref=
        |       |           +-ColumnRef(type=STRING, column=$groupby.ex#4)
        |       +-Literal(type=STRING, value="a")
        +-aggregate_list=
          +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

select 3 as a, (select b)
from (select 4 as b)
--
QueryStmt
+-output_column_list=
| +-$query.a#3 AS a [INT64]
| +-$query.$col2#4 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[a#3, $col2#4]
    +-expr_list=
    | +-a#3 := Literal(type=INT64, value=3)
    | +-$col2#4 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$subquery1.b#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.b#2]
    |         +-expr_list=
    |         | +-b#2 := ColumnRef(type=INT64, column=$subquery1.b#1, is_correlated=TRUE)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-ProjectScan
        +-column_list=[$subquery1.b#1]
        +-expr_list=
        | +-b#1 := Literal(type=INT64, value=4)
        +-input_scan=
          +-SingleRowScan
==

# This was originally b/18277830, where we produced an invalid AST with
# an incorrect column reference.
select 3 as a, (select b)
from (select 4 as b)
group by a
--
ERROR: An expression references column b which is neither grouped nor aggregated [at 1:24]
select 3 as a, (select b)
                       ^
==

# Referencing 'a' in the SELECT list subquery instead of 'b' is not ok
# since a SELECT list alias is not visible to other expressions in the
# same SELECT list.
select 3 as a, (select a)
from (select 4 as b)
group by a
--
ERROR: Unrecognized name: a [at 1:24]
select 3 as a, (select a)
                       ^
==

select 3 as a, (select b)
from (select 4 as b)
group by b
--
QueryStmt
+-output_column_list=
| +-$query.a#4 AS a [INT64]
| +-$query.$col2#6 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[a#4, $col2#6]
    +-expr_list=
    | +-a#4 := Literal(type=INT64, value=3)
    | +-$col2#6 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.b#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.b#5]
    |         +-expr_list=
    |         | +-b#5 := ColumnRef(type=INT64, column=$groupby.b#3, is_correlated=TRUE)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.b#3]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$subquery1.b#1]
        |   +-expr_list=
        |   | +-b#1 := Literal(type=INT64, value=4)
        |   +-input_scan=
        |     +-SingleRowScan
        +-group_by_list=
          +-b#3 := ColumnRef(type=INT64, column=$subquery1.b#1)
==

# Correlated reference b is two levels out, with an intervening GROUP BY.
select 3 as a, (select (key, (select b)) from KeyValue group by key)
from (select 4 as b)
--
QueryStmt
+-output_column_list=
| +-$query.a#8 AS a [INT64]
| +-$query.$col2#9 AS `$col2` [STRUCT<INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=$query.[a#8, $col2#9]
    +-expr_list=
    | +-a#8 := Literal(type=INT64, value=3)
    | +-$col2#9 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<INT64, INT64>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$subquery1.b#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#7]
    |         +-expr_list=
    |         | +-$col1#7 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<INT64, INT64>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=$groupby.key#5)
    |         |       +-SubqueryExpr
    |         |         +-type=INT64
    |         |         +-subquery_type=SCALAR
    |         |         +-parameter_list=
    |         |         | +-ColumnRef(type=INT64, column=$subquery1.b#1, is_correlated=TRUE)
    |         |         +-subquery=
    |         |           +-ProjectScan
    |         |             +-column_list=[$expr_subquery.b#6]
    |         |             +-expr_list=
    |         |             | +-b#6 := ColumnRef(type=INT64, column=$subquery1.b#1, is_correlated=TRUE)
    |         |             +-input_scan=
    |         |               +-SingleRowScan
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$groupby.key#5]
    |             +-input_scan=
    |             | +-TableScan(column_list=[KeyValue.Key#2], table=KeyValue, column_index_list=[0])
    |             +-group_by_list=
    |               +-key#5 := ColumnRef(type=INT64, column=KeyValue.Key#2)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$subquery1.b#1]
        +-expr_list=
        | +-b#1 := Literal(type=INT64, value=4)
        +-input_scan=
          +-SingleRowScan
==

# This was originally b/19455767, ResolvedAST validation failure due to
# incorrect column reference.
SELECT (SELECT COUNT(*)
        FROM TestTable m1
        WHERE m1.key = m.key)
FROM TestTable m
WHERE m.key IN (1, 2)
GROUP BY m.TestEnum;
--
ERROR: WHERE clause expression references m.key which is neither grouped nor aggregated [at 3:24]
        WHERE m1.key = m.key)
                       ^
==

SELECT (SELECT COUNT(*)
        FROM TestStructValueTable m1
        WHERE m1.b = m.b)
FROM TestStructValueTable m
WHERE m.b IN ('test', 'test1')
GROUP BY m.a;
--
ERROR: WHERE clause expression references m.b which is neither grouped nor aggregated [at 3:22]
        WHERE m1.b = m.b)
                     ^
==

# Add GROUP BY in the inner query, for both the inner table column and
# the correlated column.
SELECT (SELECT COUNT(*)
        FROM TestStructValueTable m1
        WHERE m1.b = m.b
        GROUP BY m1.b{{|, m.b}})
FROM TestStructValueTable m
WHERE m.b IN ('test', 'test1')
GROUP BY m.a;
--
ERROR: WHERE clause expression references m.b which is neither grouped nor aggregated [at 3:22]
        WHERE m1.b = m.b
                     ^
==

SELECT (SELECT COUNT(*)
        FROM KeyValue
        WHERE key = m
        GROUP BY key, m)
FROM UNNEST([1, 2, 3]) m
GROUP BY m;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#13 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#13]
    +-expr_list=
    | +-$col1#13 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.m#7)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$aggregate.$agg1#10]
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$aggregate.$agg1#10]
    |             +-input_scan=
    |             | +-FilterScan
    |             |   +-column_list=[KeyValue.Key#8]
    |             |   +-input_scan=
    |             |   | +-TableScan(column_list=[KeyValue.Key#8], table=KeyValue, column_index_list=[0])
    |             |   +-filter_expr=
    |             |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |             |       +-ColumnRef(type=INT64, column=KeyValue.Key#8)
    |             |       +-ColumnRef(type=INT64, column=$groupby.m#7, is_correlated=TRUE)
    |             +-group_by_list=
    |             | +-key#11 := ColumnRef(type=INT64, column=KeyValue.Key#8)
    |             | +-m#12 := ColumnRef(type=INT64, column=$groupby.m#7, is_correlated=TRUE)
    |             +-aggregate_list=
    |               +-$agg1#10 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.m#7]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[$array.m#1]
        |   +-array_expr=
        |   | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
        |   +-element_column=$array.m#1
        +-group_by_list=
          +-m#7 := ColumnRef(type=INT64, column=$array.m#1)
==

# In the subquery, reference a correlated value table range variable in the
# SELECT, GROUP BY, and ORDER BY.
SELECT (SELECT as struct key, m + 2
        FROM KeyValue
        WHERE key = m
        GROUP BY key, m
        ORDER BY m + 1)
FROM Int32ValueTable m;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [STRUCT<key INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<key INT64, INT64>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT32, column=Int32ValueTable.value#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#8]
    |         +-expr_list=
    |         | +-$struct#8 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<key INT64, INT64>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=$groupby.key#4)
    |         |       +-ColumnRef(type=INT64, column=$expr_subquery.$col2#6)
    |         +-input_scan=
    |           +-OrderByScan
    |             +-column_list=[$groupby.key#4, $expr_subquery.$col2#6]
    |             +-is_ordered=TRUE
    |             +-input_scan=
    |             | +-ProjectScan
    |             |   +-column_list=[$groupby.key#4, $expr_subquery.$col2#6, $orderby.$orderbycol1#7]
    |             |   +-expr_list=
    |             |   | +-$orderbycol1#7 :=
    |             |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |             |   |     +-Cast(INT32 -> INT64)
    |             |   |     | +-ColumnRef(type=INT32, column=Int32ValueTable.value#1, is_correlated=TRUE)
    |             |   |     +-Literal(type=INT64, value=1)
    |             |   +-input_scan=
    |             |     +-ProjectScan
    |             |       +-column_list=[$groupby.key#4, $expr_subquery.$col2#6]
    |             |       +-expr_list=
    |             |       | +-$col2#6 :=
    |             |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |             |       |     +-Cast(INT32 -> INT64)
    |             |       |     | +-ColumnRef(type=INT32, column=Int32ValueTable.value#1, is_correlated=TRUE)
    |             |       |     +-Literal(type=INT64, value=2)
    |             |       +-input_scan=
    |             |         +-AggregateScan
    |             |           +-column_list=[$groupby.key#4]
    |             |           +-input_scan=
    |             |           | +-FilterScan
    |             |           |   +-column_list=[KeyValue.Key#2]
    |             |           |   +-input_scan=
    |             |           |   | +-TableScan(column_list=[KeyValue.Key#2], table=KeyValue, column_index_list=[0])
    |             |           |   +-filter_expr=
    |             |           |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |             |           |       +-ColumnRef(type=INT64, column=KeyValue.Key#2)
    |             |           |       +-Cast(INT32 -> INT64)
    |             |           |         +-ColumnRef(type=INT32, column=Int32ValueTable.value#1, is_correlated=TRUE)
    |             |           +-group_by_list=
    |             |             +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#2)
    |             |             +-m#5 := ColumnRef(type=INT32, column=Int32ValueTable.value#1, is_correlated=TRUE)
    |             +-order_by_item_list=
    |               +-OrderByItem
    |                 +-column_ref=
    |                   +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#7)
    +-input_scan=
      +-TableScan(column_list=[Int32ValueTable.value#1], table=Int32ValueTable, column_index_list=[0], alias="m")
==

# Correlated references are treated like constants inside the referencing
# subqueries.  If the subquery has grouping/aggregation, correlated
# references can be referenced even though they are not grouped or
# aggregated
select
(select sum(key) + t1.key
 from KeyValue t2
 where t2.value = t1.value)
from KeyValue t1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#6]
    |         +-expr_list=
    |         | +-$col1#6 :=
    |         |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |         |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#5)
    |         |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$aggregate.$agg1#5]
    |             +-input_scan=
    |             | +-FilterScan
    |             |   +-column_list=KeyValue.[Key#3, Value#4]
    |             |   +-input_scan=
    |             |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="t2")
    |             |   +-filter_expr=
    |             |     +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |             |       +-ColumnRef(type=STRING, column=KeyValue.Value#4)
    |             |       +-ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |             +-aggregate_list=
    |               +-$agg1#5 :=
    |                 +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |                   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t1")
==

select
(select as struct value, sum(key), t1.key, t1.value
 from KeyValue t2
 where t2.value = t1.value
 group by t2.value)
from KeyValue t1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<value STRING, INT64, key INT64, value STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<value STRING, INT64, key INT64, value STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<value STRING, INT64, key INT64, value STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=STRING, column=$groupby.value#6)
    |         |       +-ColumnRef(type=INT64, column=$aggregate.$agg1#5)
    |         |       +-ColumnRef(type=INT64, column=$expr_subquery.key#7)
    |         |       +-ColumnRef(type=STRING, column=$expr_subquery.value#8)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$groupby.value#6, $aggregate.$agg1#5, $expr_subquery.key#7, $expr_subquery.value#8]
    |             +-expr_list=
    |             | +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |             | +-value#8 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |             +-input_scan=
    |               +-AggregateScan
    |                 +-column_list=[$groupby.value#6, $aggregate.$agg1#5]
    |                 +-input_scan=
    |                 | +-FilterScan
    |                 |   +-column_list=KeyValue.[Key#3, Value#4]
    |                 |   +-input_scan=
    |                 |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="t2")
    |                 |   +-filter_expr=
    |                 |     +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |                 |       +-ColumnRef(type=STRING, column=KeyValue.Value#4)
    |                 |       +-ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |                 +-group_by_list=
    |                 | +-value#6 := ColumnRef(type=STRING, column=KeyValue.Value#4)
    |                 +-aggregate_list=
    |                   +-$agg1#5 :=
    |                     +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |                       +-ColumnRef(type=INT64, column=KeyValue.Key#3)
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t1")
==

# The correlated references to 'key' and 'value' are just simple identifiers,
# rather than t1.key and t1.value.
select
(select as struct x, string_agg(x), sum(key), key, value
 from UNNEST(['a','b','c']) x
 where x = t1.value
 group by x
 order by key)
from KeyValue t1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS `$col1` [STRUCT<x STRING, STRING, INT64, key INT64, value STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<x STRING, STRING, INT64, key INT64, value STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#9]
    |         +-expr_list=
    |         | +-$struct#9 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<x STRING, STRING, INT64, key INT64, value STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=STRING, column=$groupby.x#6)
    |         |       +-ColumnRef(type=STRING, column=$aggregate.$agg1#4)
    |         |       +-ColumnRef(type=INT64, column=$aggregate.$agg2#5)
    |         |       +-ColumnRef(type=INT64, column=$expr_subquery.key#7)
    |         |       +-ColumnRef(type=STRING, column=$expr_subquery.value#8)
    |         +-input_scan=
    |           +-OrderByScan
    |             +-column_list=[$groupby.x#6, $aggregate.$agg1#4, $aggregate.$agg2#5, $expr_subquery.key#7, $expr_subquery.value#8]
    |             +-is_ordered=TRUE
    |             +-input_scan=
    |             | +-ProjectScan
    |             |   +-column_list=[$groupby.x#6, $aggregate.$agg1#4, $aggregate.$agg2#5, $expr_subquery.key#7, $expr_subquery.value#8]
    |             |   +-expr_list=
    |             |   | +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |             |   | +-value#8 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |             |   +-input_scan=
    |             |     +-AggregateScan
    |             |       +-column_list=[$groupby.x#6, $aggregate.$agg1#4, $aggregate.$agg2#5]
    |             |       +-input_scan=
    |             |       | +-FilterScan
    |             |       |   +-column_list=[$array.x#3]
    |             |       |   +-input_scan=
    |             |       |   | +-ArrayScan
    |             |       |   |   +-column_list=[$array.x#3]
    |             |       |   |   +-array_expr=
    |             |       |   |   | +-Literal(type=ARRAY<STRING>, value=["a", "b", "c"])
    |             |       |   |   +-element_column=$array.x#3
    |             |       |   +-filter_expr=
    |             |       |     +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |             |       |       +-ColumnRef(type=STRING, column=$array.x#3)
    |             |       |       +-ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |             |       +-group_by_list=
    |             |       | +-x#6 := ColumnRef(type=STRING, column=$array.x#3)
    |             |       +-aggregate_list=
    |             |         +-$agg1#4 :=
    |             |         | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
    |             |         |   +-ColumnRef(type=STRING, column=$array.x#3)
    |             |         +-$agg2#5 :=
    |             |           +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |             |             +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |             +-order_by_item_list=
    |               +-OrderByItem
    |                 +-column_ref=
    |                   +-ColumnRef(type=INT64, column=$expr_subquery.key#7)
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t1")
==

# Tests that reference correlated path expressions.
SELECT (
  SELECT AS STRUCT {{t.|}}x, {{t.|}}x.z2
  FROM t.y
)
FROM (
  SELECT struct<z1 int32, z2 string>(1, "a") as x, [2] AS y
) t
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [STRUCT<x STRUCT<z1 INT32, z2 STRING>, z2 STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<x STRUCT<z1 INT32, z2 STRING>, z2 STRING>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=STRUCT<z1 INT32, z2 STRING>, column=t.x#1)
    |     | +-ColumnRef(type=ARRAY<INT64>, column=t.y#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#6]
    |         +-expr_list=
    |         | +-$struct#6 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<x STRUCT<z1 INT32, z2 STRING>, z2 STRING>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=STRUCT<z1 INT32, z2 STRING>, column=$expr_subquery.x#4)
    |         |       +-ColumnRef(type=STRING, column=$expr_subquery.z2#5)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=$expr_subquery.[x#4, z2#5]
    |             +-expr_list=
    |             | +-x#4 := ColumnRef(type=STRUCT<z1 INT32, z2 STRING>, column=t.x#1, is_correlated=TRUE)
    |             | +-z2#5 :=
    |             |   +-GetStructField
    |             |     +-type=STRING
    |             |     +-expr=
    |             |     | +-ColumnRef(type=STRUCT<z1 INT32, z2 STRING>, column=t.x#1, is_correlated=TRUE)
    |             |     +-field_idx=1
    |             +-input_scan=
    |               +-ArrayScan
    |                 +-array_expr=
    |                 | +-ColumnRef(type=ARRAY<INT64>, column=t.y#2, is_correlated=TRUE)
    |                 +-element_column=$array.y#3
    +-input_scan=
      +-ProjectScan
        +-column_list=t.[x#1, y#2]
        +-expr_list=
        | +-x#1 := Literal(type=STRUCT<z1 INT32, z2 STRING>, value={z1:1, z2:"a"}, has_explicit_type=TRUE)
        | +-y#2 := Literal(type=ARRAY<INT64>, value=[2])
        +-input_scan=
          +-SingleRowScan
==

SELECT (
  SELECT AS STRUCT {{ct.|}}KitchenSink.nested_value,
                   {{ct.|}}KitchenSink.nested_value.nested_int64
  FROM ct.Int32Array
)
FROM ComplexTypes ct
--
QueryStmt
+-output_column_list=
| +-$query.$col1#11 AS `$col1` [STRUCT<nested_value PROTO<zetasql_test__.KitchenSinkPB.Nested>, nested_int64 INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#11]
    +-expr_list=
    | +-$col1#11 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<nested_value PROTO<zetasql_test__.KitchenSinkPB.Nested>, nested_int64 INT64>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3)
    |     | +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#10]
    |         +-expr_list=
    |         | +-$struct#10 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<nested_value PROTO<zetasql_test__.KitchenSinkPB.Nested>, nested_int64 INT64>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$expr_subquery.nested_value#8)
    |         |       +-ColumnRef(type=INT64, column=$expr_subquery.nested_int64#9)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=$expr_subquery.[nested_value#8, nested_int64#9]
    |             +-expr_list=
    |             | +-nested_value#8 :=
    |             | | +-GetProtoField
    |             | |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |             | |   +-expr=
    |             | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3, is_correlated=TRUE)
    |             | |   +-field_descriptor=nested_value
    |             | |   +-default_value=NULL
    |             | +-nested_int64#9 :=
    |             |   +-GetProtoField
    |             |     +-type=INT64
    |             |     +-expr=
    |             |     | +-GetProtoField
    |             |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |             |     |   +-expr=
    |             |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3, is_correlated=TRUE)
    |             |     |   +-field_descriptor=nested_value
    |             |     |   +-default_value=NULL
    |             |     +-field_descriptor=nested_int64
    |             |     +-default_value=88
    |             +-input_scan=
    |               +-ArrayScan
    |                 +-array_expr=
    |                 | +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4, is_correlated=TRUE)
    |                 +-element_column=$array.Int32Array#7
    +-input_scan=
      +-TableScan(column_list=ComplexTypes.[KitchenSink#3, Int32Array#4], table=ComplexTypes, column_index_list=[2, 3], alias="ct")
==

SELECT (
  SELECT COALESCE(KitchenSink.nested_value{{.nested_int64|}})
  FROM ct.Int32Array
)
FROM ComplexTypes ct
--
ALTERNATION GROUP: .nested_int64
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3)
    |     | +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#8]
    |         +-expr_list=
    |         | +-$col1#8 :=
    |         |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) INT64) -> INT64)
    |         |     +-GetProtoField
    |         |       +-type=INT64
    |         |       +-expr=
    |         |       | +-GetProtoField
    |         |       |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |         |       |   +-expr=
    |         |       |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3, is_correlated=TRUE)
    |         |       |   +-field_descriptor=nested_value
    |         |       |   +-default_value=NULL
    |         |       +-field_descriptor=nested_int64
    |         |       +-default_value=88
    |         +-input_scan=
    |           +-ArrayScan
    |             +-array_expr=
    |             | +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4, is_correlated=TRUE)
    |             +-element_column=$array.Int32Array#7
    +-input_scan=
      +-TableScan(column_list=ComplexTypes.[KitchenSink#3, Int32Array#4], table=ComplexTypes, column_index_list=[2, 3], alias="ct")
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB.Nested>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3)
    |     | +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#8]
    |         +-expr_list=
    |         | +-$col1#8 :=
    |         |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB.Nested>) -> PROTO<zetasql_test__.KitchenSinkPB.Nested>)
    |         |     +-GetProtoField
    |         |       +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |         |       +-expr=
    |         |       | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3, is_correlated=TRUE)
    |         |       +-field_descriptor=nested_value
    |         |       +-default_value=NULL
    |         +-input_scan=
    |           +-ArrayScan
    |             +-array_expr=
    |             | +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4, is_correlated=TRUE)
    |             +-element_column=$array.Int32Array#7
    +-input_scan=
      +-TableScan(column_list=ComplexTypes.[KitchenSink#3, Int32Array#4], table=ComplexTypes, column_index_list=[2, 3], alias="ct")
==

SELECT (
  SELECT COALESCE(KitchenSink.nested_value).nested_int64
  FROM ct.Int32Array
)
FROM ComplexTypes ct
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3)
    |     | +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.nested_int64#8]
    |         +-expr_list=
    |         | +-nested_int64#8 :=
    |         |   +-GetProtoField
    |         |     +-type=INT64
    |         |     +-expr=
    |         |     | +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB.Nested>) -> PROTO<zetasql_test__.KitchenSinkPB.Nested>)
    |         |     |   +-GetProtoField
    |         |     |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |         |     |     +-expr=
    |         |     |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3, is_correlated=TRUE)
    |         |     |     +-field_descriptor=nested_value
    |         |     |     +-default_value=NULL
    |         |     +-field_descriptor=nested_int64
    |         |     +-default_value=88
    |         +-input_scan=
    |           +-ArrayScan
    |             +-array_expr=
    |             | +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4, is_correlated=TRUE)
    |             +-element_column=$array.Int32Array#7
    +-input_scan=
      +-TableScan(column_list=ComplexTypes.[KitchenSink#3, Int32Array#4], table=ComplexTypes, column_index_list=[2, 3], alias="ct")
==

SELECT (
  SELECT COALESCE(KitchenSink).nested_value{{|.nested_int64}}
  FROM ct.Int32Array
)
FROM ComplexTypes ct
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB.Nested>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3)
    |     | +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.nested_value#8]
    |         +-expr_list=
    |         | +-nested_value#8 :=
    |         |   +-GetProtoField
    |         |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |         |     +-expr=
    |         |     | +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |         |     |   +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3, is_correlated=TRUE)
    |         |     +-field_descriptor=nested_value
    |         |     +-default_value=NULL
    |         +-input_scan=
    |           +-ArrayScan
    |             +-array_expr=
    |             | +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4, is_correlated=TRUE)
    |             +-element_column=$array.Int32Array#7
    +-input_scan=
      +-TableScan(column_list=ComplexTypes.[KitchenSink#3, Int32Array#4], table=ComplexTypes, column_index_list=[2, 3], alias="ct")
--
ALTERNATION GROUP: .nested_int64
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3)
    |     | +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.nested_int64#8]
    |         +-expr_list=
    |         | +-nested_int64#8 :=
    |         |   +-GetProtoField
    |         |     +-type=INT64
    |         |     +-expr=
    |         |     | +-GetProtoField
    |         |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |         |     |   +-expr=
    |         |     |   | +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |         |     |   |   +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=ComplexTypes.KitchenSink#3, is_correlated=TRUE)
    |         |     |   +-field_descriptor=nested_value
    |         |     |   +-default_value=NULL
    |         |     +-field_descriptor=nested_int64
    |         |     +-default_value=88
    |         +-input_scan=
    |           +-ArrayScan
    |             +-array_expr=
    |             | +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4, is_correlated=TRUE)
    |             +-element_column=$array.Int32Array#7
    +-input_scan=
      +-TableScan(column_list=ComplexTypes.[KitchenSink#3, Int32Array#4], table=ComplexTypes, column_index_list=[2, 3], alias="ct")
==

SELECT *
FROM TestTable
WHERE EXISTS(SELECT v
             FROM KitchenSink.repeated_int32_val AS v
             WHERE v > 0);
--
ERROR: Aliases referenced in the from clause must refer to preceding scans, and cannot refer to columns on those scans. KitchenSink refers to a column and must be qualified with a table name. [at 4:19]
             FROM KitchenSink.repeated_int32_val AS v
                  ^
==

# Same query as previous, but explicitly UNNESTing the array works.
SELECT *
FROM TestTable
WHERE EXISTS(SELECT v
             FROM UNNEST(KitchenSink.repeated_int32_val) AS v
             WHERE v > 0);
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3]
    +-input_scan=
      +-FilterScan
        +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
        +-filter_expr=
          +-SubqueryExpr
            +-type=BOOL
            +-subquery_type=EXISTS
            +-parameter_list=
            | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            +-subquery=
              +-ProjectScan
                +-column_list=[$array.v#4]
                +-input_scan=
                  +-FilterScan
                    +-column_list=[$array.v#4]
                    +-input_scan=
                    | +-ArrayScan
                    |   +-column_list=[$array.v#4]
                    |   +-array_expr=
                    |   | +-GetProtoField
                    |   |   +-type=ARRAY<INT32>
                    |   |   +-expr=
                    |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
                    |   |   +-field_descriptor=repeated_int32_val
                    |   |   +-default_value=[]
                    |   +-element_column=$array.v#4
                    +-filter_expr=
                      +-FunctionCall(ZetaSQL:$greater(INT32, INT32) -> BOOL)
                        +-ColumnRef(type=INT32, column=$array.v#4)
                        +-Literal(type=INT32, value=0)
