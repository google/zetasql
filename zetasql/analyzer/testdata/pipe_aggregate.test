[default language_features=PIPES,GROUP_BY_ROLLUP,V_1_4_GROUPING_SETS,V_1_4_GROUPING_BUILTIN,V_1_1_SELECT_STAR_EXCEPT_REPLACE]
select 1 x, 2 y
|> AGGREGATE GROUP BY x, y
--
QueryStmt
+-output_column_list=
| +-$groupby.x#3 AS x [INT64]
| +-$groupby.y#4 AS y [INT64]
+-query=
  +-AggregateScan
    +-column_list=$groupby.[x#3, y#4]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=$query.[x#1, y#2]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-SingleRowScan
    +-group_by_list=
      +-x#3 := ColumnRef(type=INT64, column=$query.x#1)
      +-y#4 := ColumnRef(type=INT64, column=$query.y#2)
==

# We get an output column for each item in GROUP BY, even when they
# are duplicate expressions, and even when they get de-duplicated
# in group_by_list.
select 1 x, 2 y, struct(3 AS z) st
|> AGGREGATE GROUP BY x, y, x, x, st.z, (st).z, 1+x, 2+x, 1+x
--
QueryStmt
+-output_column_list=
| +-$groupby.x#4 AS x [INT64]
| +-$groupby.y#5 AS y [INT64]
| +-$groupby.x#4 AS x [INT64]
| +-$groupby.x#4 AS x [INT64]
| +-$groupby.z#6 AS z [INT64]
| +-$groupby.z#6 AS z [INT64]
| +-$groupby.$groupbycol4#7 AS `$groupbycol4` [INT64]
| +-$groupby.$groupbycol5#8 AS `$groupbycol5` [INT64]
| +-$groupby.$groupbycol6#9 AS `$groupbycol6` [INT64]
+-query=
  +-AggregateScan
    +-column_list=$groupby.[x#4, y#5, z#6, $groupbycol4#7, $groupbycol5#8, $groupbycol6#9]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=$query.[x#1, y#2, st#3]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   | +-st#3 := Literal(type=STRUCT<z INT64>, value={z:3})
    |   +-input_scan=
    |     +-SingleRowScan
    +-group_by_list=
      +-x#4 := ColumnRef(type=INT64, column=$query.x#1)
      +-y#5 := ColumnRef(type=INT64, column=$query.y#2)
      +-z#6 :=
      | +-GetStructField
      |   +-type=INT64
      |   +-expr=
      |   | +-ColumnRef(type=STRUCT<z INT64>, column=$query.st#3)
      |   +-field_idx=0
      +-$groupbycol4#7 :=
      | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
      |   +-Literal(type=INT64, value=1)
      |   +-ColumnRef(type=INT64, column=$query.x#1)
      +-$groupbycol5#8 :=
      | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
      |   +-Literal(type=INT64, value=2)
      |   +-ColumnRef(type=INT64, column=$query.x#1)
      +-$groupbycol6#9 :=
        +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
          +-Literal(type=INT64, value=1)
          +-ColumnRef(type=INT64, column=$query.x#1)
==

# We get an output column for each item in GROUP BY, even when they
# are duplicate expressions, and even when they get de-duplicated
# in group_by_list, including when x and t.x are the same column.
FROM (select 1 x, 2 y) AS t
|> AGGREGATE SUM(y), SUM(t.y) GROUP BY x, t.x
--
QueryStmt
+-output_column_list=
| +-$groupby.x#5 AS x [INT64]
| +-$groupby.x#5 AS x [INT64]
| +-$aggregate.$agg1#3 AS `$col1` [INT64]
| +-$aggregate.$agg2#4 AS `$col2` [INT64]
+-query=
  +-AggregateScan
    +-column_list=[$groupby.x#5, $aggregate.$agg1#3, $aggregate.$agg2#4]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=t.[x#1, y#2]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-SingleRowScan
    +-group_by_list=
    | +-x#5 := ColumnRef(type=INT64, column=t.x#1)
    +-aggregate_list=
      +-$agg1#3 :=
      | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
      |   +-ColumnRef(type=INT64, column=t.y#2)
      +-$agg2#4 :=
        +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          +-ColumnRef(type=INT64, column=t.y#2)
==

select 1 x, 2 y, 3 z
|> AGGREGATE
--
ERROR: Pipe AGGREGATE cannot have both an empty aggregate list and an empty GROUP BY [at 2:4]
|> AGGREGATE
   ^
==

select 1 x, 2 y, 3 z
|> AGGREGATE GROUP BY ()
--
ERROR: Pipe AGGREGATE cannot have both an empty aggregate list and an empty GROUP BY [at 2:4]
|> AGGREGATE GROUP BY ()
   ^
==

select 1 x, 2 y, 3 z
|> AGGREGATE GROUP BY (), ()
--
ERROR: Pipe AGGREGATE cannot have both an empty aggregate list and an empty GROUP BY [at 2:4]
|> AGGREGATE GROUP BY (), ()
   ^
==

select 1 x, 2 y, 3 z
|> AGGREGATE GROUP BY x, (), y
--
ERROR: GROUP BY () is only allowed when there are no other grouping items [at 2:26]
|> AGGREGATE GROUP BY x, (), y
                         ^
==

# Group by computed expressions.
# Aliases are inferred for expressions where possible.
select struct(1 AS x) s, 2 y, 3 z
|> AGGREGATE GROUP BY s.x, y+1, cast(y as string), struct(y).y
--
QueryStmt
+-output_column_list=
| +-$groupby.x#4 AS x [INT64]
| +-$groupby.$groupbycol2#5 AS `$groupbycol2` [INT64]
| +-$groupby.$groupbycol3#6 AS `$groupbycol3` [STRING]
| +-$groupby.y#7 AS y [INT64]
+-query=
  +-AggregateScan
    +-column_list=$groupby.[x#4, $groupbycol2#5, $groupbycol3#6, y#7]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=$query.[s#1, y#2, z#3]
    |   +-expr_list=
    |   | +-s#1 := Literal(type=STRUCT<x INT64>, value={x:1})
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   | +-z#3 := Literal(type=INT64, value=3)
    |   +-input_scan=
    |     +-SingleRowScan
    +-group_by_list=
      +-x#4 :=
      | +-GetStructField
      |   +-type=INT64
      |   +-expr=
      |   | +-ColumnRef(type=STRUCT<x INT64>, column=$query.s#1)
      |   +-field_idx=0
      +-$groupbycol2#5 :=
      | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
      |   +-ColumnRef(type=INT64, column=$query.y#2)
      |   +-Literal(type=INT64, value=1)
      +-$groupbycol3#6 :=
      | +-Cast(INT64 -> STRING)
      |   +-ColumnRef(type=INT64, column=$query.y#2)
      +-y#7 :=
        +-GetStructField
          +-type=INT64
          +-expr=
          | +-MakeStruct
          |   +-type=STRUCT<y INT64>
          |   +-field_list=
          |     +-ColumnRef(type=INT64, column=$query.y#2)
          +-field_idx=0
==

# Group by an expression on columns, some of which (y) aren't already grouped.
select 1 x, 2 y, 3 z
|> AGGREGATE GROUP BY x, x+y
--
QueryStmt
+-output_column_list=
| +-$groupby.x#4 AS x [INT64]
| +-$groupby.$groupbycol2#5 AS `$groupbycol2` [INT64]
+-query=
  +-AggregateScan
    +-column_list=$groupby.[x#4, $groupbycol2#5]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=$query.[x#1, y#2, z#3]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   | +-z#3 := Literal(type=INT64, value=3)
    |   +-input_scan=
    |     +-SingleRowScan
    +-group_by_list=
      +-x#4 := ColumnRef(type=INT64, column=$query.x#1)
      +-$groupbycol2#5 :=
        +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
          +-ColumnRef(type=INT64, column=$query.x#1)
          +-ColumnRef(type=INT64, column=$query.y#2)
==

# Group by an expression on columns, all of which are already grouped.
select 1 x, 2 y, 3 z
|> AGGREGATE GROUP BY x, y, x+y
--
QueryStmt
+-output_column_list=
| +-$groupby.x#4 AS x [INT64]
| +-$groupby.y#5 AS y [INT64]
| +-$groupby.$groupbycol3#6 AS `$groupbycol3` [INT64]
+-query=
  +-AggregateScan
    +-column_list=$groupby.[x#4, y#5, $groupbycol3#6]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=$query.[x#1, y#2, z#3]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   | +-z#3 := Literal(type=INT64, value=3)
    |   +-input_scan=
    |     +-SingleRowScan
    +-group_by_list=
      +-x#4 := ColumnRef(type=INT64, column=$query.x#1)
      +-y#5 := ColumnRef(type=INT64, column=$query.y#2)
      +-$groupbycol3#6 :=
        +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
          +-ColumnRef(type=INT64, column=$query.x#1)
          +-ColumnRef(type=INT64, column=$query.y#2)
==

select 1 x, 2 y, 3 z
|> AGGREGATE GROUP BY 1,2
--
ERROR: GROUP BY ordinal not allowed in pipe AGGREGATE [at 2:23]
|> AGGREGATE GROUP BY 1,2
                      ^
==

# Aggregates with empty group by.
select 1 x, 2 y
|> AGGREGATE count(*), sum(y) GROUP BY ()
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [INT64]
| +-$aggregate.$agg2#4 AS `$col2` [INT64]
+-query=
  +-AggregateScan
    +-column_list=$aggregate.[$agg1#3, $agg2#4]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=$query.[x#1, y#2]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-SingleRowScan
    +-aggregate_list=
      +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
      +-$agg2#4 :=
        +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          +-ColumnRef(type=INT64, column=$query.y#2)
==

# Aggregates with no group by.
select 1 x, 2 y
|> AGGREGATE count(*), sum(y)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [INT64]
| +-$aggregate.$agg2#4 AS `$col2` [INT64]
+-query=
  +-AggregateScan
    +-column_list=$aggregate.[$agg1#3, $agg2#4]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=$query.[x#1, y#2]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-SingleRowScan
    +-aggregate_list=
      +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
      +-$agg2#4 :=
        +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          +-ColumnRef(type=INT64, column=$query.y#2)
==

# Aggregates with expressions inside and outside the aggregate functions.
select 1 x, 2 y
|> AGGREGATE avg(x), 1+sum(y+2), sum(y)/count(x)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [DOUBLE]
| +-$aggregate.$col2#7 AS `$col2` [INT64]
| +-$aggregate.$col3#8 AS `$col3` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#3, $col2#7, $col3#8]
    +-expr_list=
    | +-$col2#7 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-Literal(type=INT64, value=1)
    | |   +-ColumnRef(type=INT64, column=$aggregate.$agg2#4)
    | +-$col3#8 :=
    |   +-FunctionCall(ZetaSQL:$divide(DOUBLE, DOUBLE) -> DOUBLE)
    |     +-Cast(INT64 -> DOUBLE)
    |     | +-ColumnRef(type=INT64, column=$aggregate.$agg3#5)
    |     +-Cast(INT64 -> DOUBLE)
    |       +-ColumnRef(type=INT64, column=$aggregate.$agg4#6)
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#3, $agg2#4, $agg3#5, $agg4#6]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$query.[x#1, y#2]
        |   +-expr_list=
        |   | +-x#1 := Literal(type=INT64, value=1)
        |   | +-y#2 := Literal(type=INT64, value=2)
        |   +-input_scan=
        |     +-SingleRowScan
        +-aggregate_list=
          +-$agg1#3 :=
          | +-AggregateFunctionCall(ZetaSQL:avg(INT64) -> DOUBLE)
          |   +-ColumnRef(type=INT64, column=$query.x#1)
          +-$agg2#4 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
          |     +-ColumnRef(type=INT64, column=$query.y#2)
          |     +-Literal(type=INT64, value=2)
          +-$agg3#5 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=$query.y#2)
          +-$agg4#6 :=
            +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=$query.x#1)
==


# Aliases in aggregate list, including inferred aliases.
select 1 x, struct(1 as f) sf
|> AGGREGATE count(*) cnt, sum(x) AS xx, any_value(sf).f
--
QueryStmt
+-output_column_list=
| +-$aggregate.cnt#3 AS cnt [INT64]
| +-$aggregate.xx#4 AS xx [INT64]
| +-$aggregate.f#6 AS f [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[cnt#3, xx#4, f#6]
    +-expr_list=
    | +-f#6 :=
    |   +-GetStructField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<f INT64>, column=$aggregate.$agg3#5)
    |     +-field_idx=0
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[cnt#3, xx#4, $agg3#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$query.[x#1, sf#2]
        |   +-expr_list=
        |   | +-x#1 := Literal(type=INT64, value=1)
        |   | +-sf#2 := Literal(type=STRUCT<f INT64>, value={f:1})
        |   +-input_scan=
        |     +-SingleRowScan
        +-aggregate_list=
          +-cnt#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
          +-xx#4 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=$query.x#1)
          +-$agg3#5 :=
            +-AggregateFunctionCall(ZetaSQL:any_value(STRUCT<f INT64>) -> STRUCT<f INT64>)
              +-ColumnRef(type=STRUCT<f INT64>, column=$query.sf#2)
==

# Aggregates and grouping with computed expressions in both.
select 1 x, 2 y
|> AGGREGATE 1+sum(x+2) GROUP BY y+2
--
QueryStmt
+-output_column_list=
| +-$groupby.$groupbycol1#4 AS `$groupbycol1` [INT64]
| +-$aggregate.$col1#5 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.$groupbycol1#4, $aggregate.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Literal(type=INT64, value=1)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#3)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.$groupbycol1#4, $aggregate.$agg1#3]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$query.[x#1, y#2]
        |   +-expr_list=
        |   | +-x#1 := Literal(type=INT64, value=1)
        |   | +-y#2 := Literal(type=INT64, value=2)
        |   +-input_scan=
        |     +-SingleRowScan
        +-group_by_list=
        | +-$groupbycol1#4 :=
        |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$query.y#2)
        |     +-Literal(type=INT64, value=2)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
              +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                +-ColumnRef(type=INT64, column=$query.x#1)
                +-Literal(type=INT64, value=2)
==

# Dot-star on the output of an aggregate, and with modifiers.
select 1 x, struct(1 as f, 2 as g) sf
|> AGGREGATE any_value(sf).*,
             any_value(sf).* except (f),
             any_value(sf).* replace ('abc' as g),
             any_value(sf).* except (f) replace (max(sf.g) as g),
--
QueryStmt
+-output_column_list=
| +-$aggregate.f#8 AS f [INT64]
| +-$aggregate.g#9 AS g [INT64]
| +-$aggregate.g#10 AS g [INT64]
| +-$aggregate.f#11 AS f [INT64]
| +-$aggregate.g#12 AS g [STRING]
| +-$aggregate.g#7 AS g [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[f#8, g#9, g#10, f#11, g#12, g#7]
    +-expr_list=
    | +-f#8 :=
    | | +-GetStructField
    | |   +-type=INT64
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<f INT64, g INT64>, column=$aggregate.$agg1#3)
    | |   +-field_idx=0
    | +-g#9 :=
    | | +-GetStructField
    | |   +-type=INT64
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<f INT64, g INT64>, column=$aggregate.$agg1#3)
    | |   +-field_idx=1
    | +-g#10 :=
    | | +-GetStructField
    | |   +-type=INT64
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<f INT64, g INT64>, column=$aggregate.$agg2#4)
    | |   +-field_idx=1
    | +-f#11 :=
    | | +-GetStructField
    | |   +-type=INT64
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<f INT64, g INT64>, column=$aggregate.$agg3#5)
    | |   +-field_idx=0
    | +-g#12 := Literal(type=STRING, value="abc")
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#3, $agg2#4, $agg3#5, $agg4#6, g#7]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$query.[x#1, sf#2]
        |   +-expr_list=
        |   | +-x#1 := Literal(type=INT64, value=1)
        |   | +-sf#2 := Literal(type=STRUCT<f INT64, g INT64>, value={f:1, g:2})
        |   +-input_scan=
        |     +-SingleRowScan
        +-aggregate_list=
          +-$agg1#3 :=
          | +-AggregateFunctionCall(ZetaSQL:any_value(STRUCT<f INT64, g INT64>) -> STRUCT<f INT64, g INT64>)
          |   +-ColumnRef(type=STRUCT<f INT64, g INT64>, column=$query.sf#2)
          +-$agg2#4 :=
          | +-AggregateFunctionCall(ZetaSQL:any_value(STRUCT<f INT64, g INT64>) -> STRUCT<f INT64, g INT64>)
          |   +-ColumnRef(type=STRUCT<f INT64, g INT64>, column=$query.sf#2)
          +-$agg3#5 :=
          | +-AggregateFunctionCall(ZetaSQL:any_value(STRUCT<f INT64, g INT64>) -> STRUCT<f INT64, g INT64>)
          |   +-ColumnRef(type=STRUCT<f INT64, g INT64>, column=$query.sf#2)
          +-$agg4#6 :=
          | +-AggregateFunctionCall(ZetaSQL:any_value(STRUCT<f INT64, g INT64>) -> STRUCT<f INT64, g INT64>)
          |   +-ColumnRef(type=STRUCT<f INT64, g INT64>, column=$query.sf#2)
          +-g#7 :=
            +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
              +-GetStructField
                +-type=INT64
                +-expr=
                | +-ColumnRef(type=STRUCT<f INT64, g INT64>, column=$query.sf#2)
                +-field_idx=1
==

# The usual errors for dot-star apply here.
select 1 x
|> AGGREGATE max(x).*
--
ERROR: Dot-star is not supported for type INT64 [at 2:14]
|> AGGREGATE max(x).*
             ^
==

select struct(1 as f, 2 as g) sf
|> AGGREGATE any_value(sf).* except (k)
--
ERROR: Column k in SELECT * EXCEPT list does not exist [at 2:38]
|> AGGREGATE any_value(sf).* except (k)
                                     ^
==

select struct(1 as f, 2 as g) sf
|> AGGREGATE any_value(sf).* replace (123 as k)
--
ERROR: Column k in SELECT * REPLACE list does not exist [at 2:46]
|> AGGREGATE any_value(sf).* replace (123 as k)
                                             ^
==

select struct(1 as f, 2 as g) sf
|> AGGREGATE any_value(sf).* except (f,g)
--
ERROR: SELECT * expands to zero columns after applying EXCEPT [at 2:14]
|> AGGREGATE any_value(sf).* except (f,g)
             ^
==

select struct() sf
|> AGGREGATE any_value(sf).*
--
ERROR: Star expansion is not allowed on a struct with zero fields [at 2:14]
|> AGGREGATE any_value(sf).*
             ^
==

select struct(1 as f, 2 as g) sf
|> AGGREGATE sf.*
--
ERROR: Pipe AGGREGATE cannot include non-aggregate expressions [at 2:14]
|> AGGREGATE sf.*
             ^
==

# REPLACE expression cannot be a non-aggregate expression.
select struct(1 as f, 2 as g) sf
|> AGGREGATE any_value(sf).* replace (1+sf.g as f)
--
ERROR: AGGREGATE list expression references sf.g which is not aggregated [at 2:41]
|> AGGREGATE any_value(sf).* replace (1+sf.g as f)
                                        ^
==

# Dot-star on a proto value table.
from TestExtraValueTable vt
|> AGGREGATE any_value(vt).* {{|except(int32_val2)}}
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$aggregate.int32_val1#5 AS int32_val1 [INT32]
| +-$aggregate.int32_val2#6 AS int32_val2 [INT32]
| +-$aggregate.str_value#7 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[int32_val1#5, int32_val2#6, str_value#7]
    +-expr_list=
    | +-int32_val1#5 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$aggregate.$agg1#4)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-int32_val2#6 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$aggregate.$agg1#4)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#7 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$aggregate.$agg1#4)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias="vt")
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:any_value(PROTO<zetasql_test__.TestExtraPB>) -> PROTO<zetasql_test__.TestExtraPB>)
              +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
--
ALTERNATION GROUP: except(int32_val2)
--
QueryStmt
+-output_column_list=
| +-$aggregate.int32_val1#5 AS int32_val1 [INT32]
| +-$aggregate.str_value#6 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[int32_val1#5, str_value#6]
    +-expr_list=
    | +-int32_val1#5 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$aggregate.$agg1#4)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-str_value#6 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$aggregate.$agg1#4)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias="vt")
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:any_value(PROTO<zetasql_test__.TestExtraPB>) -> PROTO<zetasql_test__.TestExtraPB>)
              +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
==

# GROUP BY ALL is not allowed.
# This is currently caught by the parser, but there is still an
# analyzer error for this, since parser implementation details may
# change to allow ALL through (which would give a better error).
select 1
|> AGGREGATE COUNT(*) GROUP BY ALL
--
ERROR: Syntax error: Unexpected keyword ALL [at 2:32]
|> AGGREGATE COUNT(*) GROUP BY ALL
                               ^
==

# Non-aggregate expressions not allowed.
select 1 x, 2 y
|> AGGREGATE sum(x), x{{| GROUP BY y}}
--
ALTERNATION GROUP: <empty>
--
ERROR: Pipe AGGREGATE cannot include non-aggregate expressions [at 2:22]
|> AGGREGATE sum(x), x
                     ^
--
ALTERNATION GROUP:  GROUP BY y
--
ERROR: Pipe AGGREGATE cannot include non-aggregate expressions [at 2:22]
|> AGGREGATE sum(x), x GROUP BY y
                     ^
==

# This error points at the whole expression, not the referenced column.
# It's not obvious that pointing at the column would be better.
# Note the more complex case with sum(x)+y below, where it is aggregate.
select 1 x, 2 y
|> AGGREGATE 1+x{{| GROUP BY y}}
--
ALTERNATION GROUP: <empty>
--
ERROR: Pipe AGGREGATE cannot include non-aggregate expressions [at 2:14]
|> AGGREGATE 1+x
             ^
--
ALTERNATION GROUP:  GROUP BY y
--
ERROR: Pipe AGGREGATE cannot include non-aggregate expressions [at 2:14]
|> AGGREGATE 1+x GROUP BY y
             ^
==

select 1 x
|> AGGREGATE ANY_VALUE(5), sqrt(15){{| GROUP BY y}}
--
ALTERNATION GROUP: <empty>
--
ERROR: Pipe AGGREGATE cannot include non-aggregate expressions [at 2:28]
|> AGGREGATE ANY_VALUE(5), sqrt(15)
                           ^
--
ALTERNATION GROUP:  GROUP BY y
--
ERROR: Pipe AGGREGATE cannot include non-aggregate expressions [at 2:28]
|> AGGREGATE ANY_VALUE(5), sqrt(15) GROUP BY y
                           ^
==

select 1 x
|> AGGREGATE x GROUP BY x
--
ERROR: Pipe AGGREGATE cannot include non-aggregate expressions [at 2:14]
|> AGGREGATE x GROUP BY x
             ^
==

select 1 x, 2 y, 3 z
|> AGGREGATE sum(x)+y{{| GROUP BY z}}
--
ALTERNATION GROUP: <empty>
--
ERROR: AGGREGATE list expression references column y which is not aggregated [at 2:21]
|> AGGREGATE sum(x)+y
                    ^
--
ALTERNATION GROUP:  GROUP BY z
--
ERROR: AGGREGATE list expression references column y which is not aggregated [at 2:21]
|> AGGREGATE sum(x)+y GROUP BY z
                    ^
==

select 1 x
|> AGGREGATE GROUP BY rand()
--
QueryStmt
+-output_column_list=
| +-$groupby.$groupbycol1#2 AS `$groupbycol1` [DOUBLE]
+-query=
  +-AggregateScan
    +-column_list=[$groupby.$groupbycol1#2]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$query.x#1]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   +-input_scan=
    |     +-SingleRowScan
    +-group_by_list=
      +-$groupbycol1#2 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
==

# Window functions not allowed.
[language_features=PIPES,ANALYTIC_FUNCTIONS]
select 1 x
|> AGGREGATE sum(x), 1 + sum(x) OVER ()
--
ERROR: Analytic function not allowed in pipe AGGREGATE [at 2:26]
|> AGGREGATE sum(x), 1 + sum(x) OVER ()
                         ^
==

# Hints in the GROUP BY make it into the AggregateScan.
select 1 x
|> AGGREGATE GROUP @{hint=1} BY x
--
QueryStmt
+-output_column_list=
| +-$groupby.x#2 AS x [INT64]
+-query=
  +-AggregateScan
    +-column_list=[$groupby.x#2]
    +-hint_list=
    | +-hint := Literal(type=INT64, value=1)
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$query.x#1]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   +-input_scan=
    |     +-SingleRowScan
    +-group_by_list=
      +-x#2 := ColumnRef(type=INT64, column=$query.x#1)
==

select 1 x, 2 y
|> AGGREGATE COUNT(*) GROUP BY ROLLUP(x,y)
--
QueryStmt
+-output_column_list=
| +-$groupby.x#4 AS x [INT64]
| +-$groupby.y#5 AS y [INT64]
| +-$aggregate.$agg1#3 AS `$col1` [INT64]
+-query=
  +-AggregateScan
    +-column_list=[$groupby.x#4, $groupby.y#5, $aggregate.$agg1#3]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=$query.[x#1, y#2]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-SingleRowScan
    +-group_by_list=
    | +-x#4 := ColumnRef(type=INT64, column=$query.x#1)
    | +-y#5 := ColumnRef(type=INT64, column=$query.y#2)
    +-aggregate_list=
    | +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    +-grouping_set_list=
      +-Rollup
        +-rollup_column_list=
          +-GroupingSetMultiColumn
          | +-column_list=
          |   +-ColumnRef(type=INT64, column=$groupby.x#4)
          +-GroupingSetMultiColumn
            +-column_list=
              +-ColumnRef(type=INT64, column=$groupby.y#5)
==

# ROLLUP with duplicate columns and with expressions.
# We get an output column for each unique item in the list.
select 1 x, 2 y
|> AGGREGATE COUNT(*) GROUP BY ROLLUP(x,x,y,x,x+y,x+y)
--
QueryStmt
+-output_column_list=
| +-$groupby.x#4 AS x [INT64]
| +-$groupby.y#5 AS y [INT64]
| +-$groupby.$groupbycol3#6 AS `$groupbycol3` [INT64]
| +-$aggregate.$agg1#3 AS `$col1` [INT64]
+-query=
  +-AggregateScan
    +-column_list=[$groupby.x#4, $groupby.y#5, $groupby.$groupbycol3#6, $aggregate.$agg1#3]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=$query.[x#1, y#2]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-SingleRowScan
    +-group_by_list=
    | +-x#4 := ColumnRef(type=INT64, column=$query.x#1)
    | +-y#5 := ColumnRef(type=INT64, column=$query.y#2)
    | +-$groupbycol3#6 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-ColumnRef(type=INT64, column=$query.x#1)
    |     +-ColumnRef(type=INT64, column=$query.y#2)
    +-aggregate_list=
    | +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    +-grouping_set_list=
      +-Rollup
        +-rollup_column_list=
          +-GroupingSetMultiColumn
          | +-column_list=
          |   +-ColumnRef(type=INT64, column=$groupby.x#4)
          +-GroupingSetMultiColumn
          | +-column_list=
          |   +-ColumnRef(type=INT64, column=$groupby.x#4)
          +-GroupingSetMultiColumn
          | +-column_list=
          |   +-ColumnRef(type=INT64, column=$groupby.y#5)
          +-GroupingSetMultiColumn
          | +-column_list=
          |   +-ColumnRef(type=INT64, column=$groupby.x#4)
          +-GroupingSetMultiColumn
          | +-column_list=
          |   +-ColumnRef(type=INT64, column=$groupby.$groupbycol3#6)
          +-GroupingSetMultiColumn
            +-column_list=
              +-ColumnRef(type=INT64, column=$groupby.$groupbycol3#6)
==

# For GROUPING SETS, we get an output column for each unique item.
select 1 x, 2 y
|> AGGREGATE COUNT(*) GROUP BY GROUPING SETS((), (x,y), (x), (x))
--
QueryStmt
+-output_column_list=
| +-$groupby.x#4 AS x [INT64]
| +-$groupby.y#5 AS y [INT64]
| +-$aggregate.$agg1#3 AS `$col1` [INT64]
+-query=
  +-AggregateScan
    +-column_list=[$groupby.x#4, $groupby.y#5, $aggregate.$agg1#3]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=$query.[x#1, y#2]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-SingleRowScan
    +-group_by_list=
    | +-x#4 := ColumnRef(type=INT64, column=$query.x#1)
    | +-y#5 := ColumnRef(type=INT64, column=$query.y#2)
    +-aggregate_list=
    | +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    +-grouping_set_list=
      +-GroupingSet
      +-GroupingSet
      | +-group_by_column_list=
      |   +-ColumnRef(type=INT64, column=$groupby.x#4)
      |   +-ColumnRef(type=INT64, column=$groupby.y#5)
      +-GroupingSet
      | +-group_by_column_list=
      |   +-ColumnRef(type=INT64, column=$groupby.x#4)
      +-GroupingSet
        +-group_by_column_list=
          +-ColumnRef(type=INT64, column=$groupby.x#4)
==

# This shows a complex GROUPING SET, and the GROUPING function.
select 1 x, 2 y, 3 z
|> AGGREGATE COUNT(*), GROUPING(x), GROUPING(x) AS g_x
   GROUP BY GROUPING SETS((x), ROLLUP(y,z), CUBE(x, z))
--
QueryStmt
+-output_column_list=
| +-$groupby.x#7 AS x [INT64]
| +-$groupby.y#8 AS y [INT64]
| +-$groupby.z#9 AS z [INT64]
| +-$aggregate.$agg1#4 AS `$col1` [INT64]
| +-$grouping_call.$grouping_call1#10 AS `$col2` [INT64]
| +-$grouping_call.$grouping_call2#11 AS g_x [INT64]
+-query=
  +-AggregateScan
    +-column_list=[$groupby.x#7, $groupby.y#8, $groupby.z#9, $aggregate.$agg1#4, $grouping_call.$grouping_call1#10, $grouping_call.$grouping_call2#11]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=$query.[x#1, y#2, z#3]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   | +-y#2 := Literal(type=INT64, value=2)
    |   | +-z#3 := Literal(type=INT64, value=3)
    |   +-input_scan=
    |     +-SingleRowScan
    +-group_by_list=
    | +-x#7 := ColumnRef(type=INT64, column=$query.x#1)
    | +-y#8 := ColumnRef(type=INT64, column=$query.y#2)
    | +-z#9 := ColumnRef(type=INT64, column=$query.z#3)
    +-aggregate_list=
    | +-$agg1#4 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    +-grouping_set_list=
    | +-GroupingSet
    | | +-group_by_column_list=
    | |   +-ColumnRef(type=INT64, column=$groupby.x#7)
    | +-Rollup
    | | +-rollup_column_list=
    | |   +-GroupingSetMultiColumn
    | |   | +-column_list=
    | |   |   +-ColumnRef(type=INT64, column=$groupby.y#8)
    | |   +-GroupingSetMultiColumn
    | |     +-column_list=
    | |       +-ColumnRef(type=INT64, column=$groupby.z#9)
    | +-Cube
    |   +-cube_column_list=
    |     +-GroupingSetMultiColumn
    |     | +-column_list=
    |     |   +-ColumnRef(type=INT64, column=$groupby.x#7)
    |     +-GroupingSetMultiColumn
    |       +-column_list=
    |         +-ColumnRef(type=INT64, column=$groupby.z#9)
    +-grouping_call_list=
      +-GroupingCall
      | +-group_by_column=
      | | +-ColumnRef(type=INT64, column=$groupby.x#7)
      | +-output_column=$grouping_call.$grouping_call1#10
      +-GroupingCall
        +-group_by_column=
        | +-ColumnRef(type=INT64, column=$groupby.x#7)
        +-output_column=$grouping_call.$grouping_call2#11
==

# Ordinals disallowed in ROLLUP
select 1 x, 2 y
|> AGGREGATE COUNT(*) GROUP BY ROLLUP(x,2)
--
ERROR: GROUP BY ordinal not allowed in pipe AGGREGATE [at 2:41]
|> AGGREGATE COUNT(*) GROUP BY ROLLUP(x,2)
                                        ^
==

# Ordinals disallowed in all forms in GROUPING SETS
select 1 x, 2 y
|> AGGREGATE COUNT(*) GROUP BY GROUPING SETS(
     {{1|(x,1)|CUBE(x,1)|ROLLUP(x,1)}}
   )
--
ALTERNATION GROUP: 1
--
ERROR: GROUP BY ordinal not allowed in pipe AGGREGATE [at 3:6]
     1
     ^
--
ALTERNATION GROUP: (x,1)
--
ERROR: GROUP BY ordinal not allowed in pipe AGGREGATE [at 3:9]
     (x,1)
        ^
--
ALTERNATION GROUP: CUBE(x,1)
--
ERROR: GROUP BY ordinal not allowed in pipe AGGREGATE [at 3:13]
     CUBE(x,1)
            ^
--
ALTERNATION GROUP: ROLLUP(x,1)
--
ERROR: GROUP BY ordinal not allowed in pipe AGGREGATE [at 3:15]
     ROLLUP(x,1)
              ^
==

select 1 x
|> AGGREGATE GROUP BY "abc"
--
ERROR: Cannot GROUP BY literal values [at 2:23]
|> AGGREGATE GROUP BY "abc"
                      ^
==

# Scoping: aggregate and group by expressions are resolving independently
# and not matched against each other.
select 1 x
|> AGGREGATE COUNT(x) GROUP BY x
--
QueryStmt
+-output_column_list=
| +-$groupby.x#3 AS x [INT64]
| +-$aggregate.$agg1#2 AS `$col1` [INT64]
+-query=
  +-AggregateScan
    +-column_list=[$groupby.x#3, $aggregate.$agg1#2]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$query.x#1]
    |   +-expr_list=
    |   | +-x#1 := Literal(type=INT64, value=1)
    |   +-input_scan=
    |     +-SingleRowScan
    +-group_by_list=
    | +-x#3 := ColumnRef(type=INT64, column=$query.x#1)
    +-aggregate_list=
      +-$agg1#2 :=
        +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
          +-ColumnRef(type=INT64, column=$query.x#1)
==

# Scoping: column referenced unaggregated in aggregate clause won't find the
# group by column.
select 1 x
|> AGGREGATE x GROUP BY x
--
ERROR: Pipe AGGREGATE cannot include non-aggregate expressions [at 2:14]
|> AGGREGATE x GROUP BY x
             ^
==

# Scoping: GROUP BY can't see a name introduced in aggregate list.
select 1 x
|> AGGREGATE COUNT(x) AS y GROUP BY y
--
ERROR: Unrecognized name: y [at 2:37]
|> AGGREGATE COUNT(x) AS y GROUP BY y
                                    ^
==

# Scoping: AGGREGATE list can't see a name introduced in GROUP BY.
select 1 x
|> AGGREGATE {{y|COUNT(y)}} GROUP BY STRUCT(2 AS y).y
--
ALTERNATION GROUP: y
--
ERROR: Unrecognized name: y [at 2:14]
|> AGGREGATE y GROUP BY STRUCT(2 AS y).y
             ^
--
ALTERNATION GROUP: COUNT(y)
--
ERROR: Unrecognized name: y [at 2:20]
|> AGGREGATE COUNT(y) GROUP BY STRUCT(2 AS y).y
                   ^
==

# Scoping: mixed aggregate and non-aggregate reference in the same expression,
# referencing columns that may also be grouped.
# (Including sum(x) bypasses check for non-aggregate expression.)
# These should all be errors.
select 1 x,2 y
|> AGGREGATE sum(x)+{{x|y}} GROUP BY {{x|y}}
--
ALTERNATION GROUP: x,x
--
ERROR: AGGREGATE list expression references column x which is not aggregated [at 2:21]
|> AGGREGATE sum(x)+x GROUP BY x
                    ^
--
ALTERNATION GROUP: x,y
--
ERROR: AGGREGATE list expression references column x which is not aggregated [at 2:21]
|> AGGREGATE sum(x)+x GROUP BY y
                    ^
--
ALTERNATION GROUP: y,x
--
ERROR: AGGREGATE list expression references column y which is not aggregated [at 2:21]
|> AGGREGATE sum(x)+y GROUP BY x
                    ^
--
ALTERNATION GROUP: y,y
--
ERROR: AGGREGATE list expression references column y which is not aggregated [at 2:21]
|> AGGREGATE sum(x)+y GROUP BY y
                    ^
==

select 1 x, 2 y
|> AGGREGATE sum(x+1),x+1 GROUP BY x+1
--
ERROR: Pipe AGGREGATE cannot include non-aggregate expressions [at 2:23]
|> AGGREGATE sum(x+1),x+1 GROUP BY x+1
                      ^
==

select 1 x
|> AGGREGATE sum(x) AS sum_x, sum(sum_x)
--
ERROR: Unrecognized name: sum_x [at 2:35]
|> AGGREGATE sum(x) AS sum_x, sum(sum_x)
                                  ^
==

select 1 x
|> AGGREGATE sum(x) AS sum_x, sum_x
--
ERROR: Unrecognized name: sum_x [at 2:31]
|> AGGREGATE sum(x) AS sum_x, sum_x
                              ^
==

select 1 x
|> AGGREGATE sum(sum(x)) AS sum_x
--
ERROR: Aggregations of aggregations are not allowed [at 2:14]
|> AGGREGATE sum(sum(x)) AS sum_x
             ^
==

# Test the output NameScope.  SELECT * shows the anonymous columns too.
select 1 x, 2 y, 3 z
|> AGGREGATE count(*), sum(x), sum(y) sum_y
   GROUP BY x,z,z+1
|> WHERE x=1
|> WHERE sum_y=2
|> SELECT *
--
QueryStmt
+-output_column_list=
| +-$groupby.x#7 AS x [INT64]
| +-$groupby.z#8 AS z [INT64]
| +-$groupby.$groupbycol3#9 AS `$groupbycol3` [INT64]
| +-$aggregate.$agg1#4 AS `$col1` [INT64]
| +-$aggregate.$agg2#5 AS `$col2` [INT64]
| +-$aggregate.sum_y#6 AS sum_y [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.x#7, $groupby.z#8, $groupby.$groupbycol3#9, $aggregate.$agg1#4, $aggregate.$agg2#5, $aggregate.sum_y#6]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.x#7, $groupby.z#8, $groupby.$groupbycol3#9, $aggregate.$agg1#4, $aggregate.$agg2#5, $aggregate.sum_y#6]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[$groupby.x#7, $groupby.z#8, $groupby.$groupbycol3#9, $aggregate.$agg1#4, $aggregate.$agg2#5, $aggregate.sum_y#6]
        |   +-input_scan=
        |   | +-AggregateScan
        |   |   +-column_list=[$groupby.x#7, $groupby.z#8, $groupby.$groupbycol3#9, $aggregate.$agg1#4, $aggregate.$agg2#5, $aggregate.sum_y#6]
        |   |   +-input_scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=$query.[x#1, y#2, z#3]
        |   |   |   +-expr_list=
        |   |   |   | +-x#1 := Literal(type=INT64, value=1)
        |   |   |   | +-y#2 := Literal(type=INT64, value=2)
        |   |   |   | +-z#3 := Literal(type=INT64, value=3)
        |   |   |   +-input_scan=
        |   |   |     +-SingleRowScan
        |   |   +-group_by_list=
        |   |   | +-x#7 := ColumnRef(type=INT64, column=$query.x#1)
        |   |   | +-z#8 := ColumnRef(type=INT64, column=$query.z#3)
        |   |   | +-$groupbycol3#9 :=
        |   |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |   |     +-ColumnRef(type=INT64, column=$query.z#3)
        |   |   |     +-Literal(type=INT64, value=1)
        |   |   +-aggregate_list=
        |   |     +-$agg1#4 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   |     +-$agg2#5 :=
        |   |     | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |   |     |   +-ColumnRef(type=INT64, column=$query.x#1)
        |   |     +-sum_y#6 :=
        |   |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |   |         +-ColumnRef(type=INT64, column=$query.y#2)
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$groupby.x#7)
        |       +-Literal(type=INT64, value=1)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=$aggregate.sum_y#6)
            +-Literal(type=INT64, value=2)
==

# Ambiguous name from duplicate GROUP BY item
select 1 x, 3 z
|> AGGREGATE count(*)
   GROUP BY x,z,x
|> WHERE x=1
--
ERROR: Column name x is ambiguous [at 4:10]
|> WHERE x=1
         ^
==

# Ambiguous name from two different GROUP BY columns with the same inferred
# alias.
select struct(1 AS x) s1, struct(2.0 AS x) s2
|> AGGREGATE
   GROUP BY s1.x, s2.x
|> WHERE x IS NOT NULL
--
ERROR: Column name x is ambiguous [at 4:10]
|> WHERE x IS NOT NULL
         ^
==

# Ambiguous name from AGGREGATE list vs GROUP BY
select 1 x, 2 y, 3 z
|> AGGREGATE count(*) AS c, sum(x) AS x
   GROUP BY x
|> WHERE c=1
|> WHERE x=1
--
ERROR: Column name x is ambiguous [at 5:10]
|> WHERE x=1
         ^
==

# Names coming from GROUPING SETS are de-duplicated and not ambiguous
select 1 x, '2' y, 3.0 z
|> AGGREGATE COUNT(*), GROUPING(x) AS g_x
   GROUP BY GROUPING SETS((x), (x,y), CUBE(x,z))
|> SELECT x, y, z, g_x
--
QueryStmt
+-output_column_list=
| +-$groupby.x#6 AS x [INT64]
| +-$groupby.y#7 AS y [STRING]
| +-$groupby.z#8 AS z [DOUBLE]
| +-$grouping_call.$grouping_call1#9 AS g_x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.x#6, $groupby.y#7, $groupby.z#8, $grouping_call.$grouping_call1#9]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.x#6, $groupby.y#7, $groupby.z#8, $aggregate.$agg1#4, $grouping_call.$grouping_call1#9]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$query.[x#1, y#2, z#3]
        |   +-expr_list=
        |   | +-x#1 := Literal(type=INT64, value=1)
        |   | +-y#2 := Literal(type=STRING, value="2")
        |   | +-z#3 := Literal(type=DOUBLE, value=3)
        |   +-input_scan=
        |     +-SingleRowScan
        +-group_by_list=
        | +-x#6 := ColumnRef(type=INT64, column=$query.x#1)
        | +-y#7 := ColumnRef(type=STRING, column=$query.y#2)
        | +-z#8 := ColumnRef(type=DOUBLE, column=$query.z#3)
        +-aggregate_list=
        | +-$agg1#4 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-grouping_set_list=
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=INT64, column=$groupby.x#6)
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=INT64, column=$groupby.x#6)
        | |   +-ColumnRef(type=STRING, column=$groupby.y#7)
        | +-Cube
        |   +-cube_column_list=
        |     +-GroupingSetMultiColumn
        |     | +-column_list=
        |     |   +-ColumnRef(type=INT64, column=$groupby.x#6)
        |     +-GroupingSetMultiColumn
        |       +-column_list=
        |         +-ColumnRef(type=DOUBLE, column=$groupby.z#8)
        +-grouping_call_list=
          +-GroupingCall
            +-group_by_column=
            | +-ColumnRef(type=INT64, column=$groupby.x#6)
            +-output_column=$grouping_call.$grouping_call1#9
==

# Chained aggregates
select 1 x, 2 y, 3 z
|> AGGREGATE sum(z) z
   GROUP BY x, y
|> AGGREGATE AVG(z) z
   GROUP BY x
|> AGGREGATE COUNT(DISTINCT z) c
--
QueryStmt
+-output_column_list=
| +-$aggregate.c#9 AS c [INT64]
+-query=
  +-AggregateScan
    +-column_list=[$aggregate.c#9]
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.x#8, $aggregate.z#7]
    |   +-input_scan=
    |   | +-AggregateScan
    |   |   +-column_list=[$groupby.x#5, $groupby.y#6, $aggregate.z#4]
    |   |   +-input_scan=
    |   |   | +-ProjectScan
    |   |   |   +-column_list=$query.[x#1, y#2, z#3]
    |   |   |   +-expr_list=
    |   |   |   | +-x#1 := Literal(type=INT64, value=1)
    |   |   |   | +-y#2 := Literal(type=INT64, value=2)
    |   |   |   | +-z#3 := Literal(type=INT64, value=3)
    |   |   |   +-input_scan=
    |   |   |     +-SingleRowScan
    |   |   +-group_by_list=
    |   |   | +-x#5 := ColumnRef(type=INT64, column=$query.x#1)
    |   |   | +-y#6 := ColumnRef(type=INT64, column=$query.y#2)
    |   |   +-aggregate_list=
    |   |     +-z#4 :=
    |   |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |   |         +-ColumnRef(type=INT64, column=$query.z#3)
    |   +-group_by_list=
    |   | +-x#8 := ColumnRef(type=INT64, column=$groupby.x#5)
    |   +-aggregate_list=
    |     +-z#7 :=
    |       +-AggregateFunctionCall(ZetaSQL:avg(INT64) -> DOUBLE)
    |         +-ColumnRef(type=INT64, column=$aggregate.z#4)
    +-aggregate_list=
      +-c#9 :=
        +-AggregateFunctionCall(ZetaSQL:count(DOUBLE) -> INT64)
          +-ColumnRef(type=DOUBLE, column=$aggregate.z#7)
          +-distinct=TRUE
==

# Aliases on the GROUP BY expressions.
from KeyValue
|> AGGREGATE GROUP BY key, key AS key2, key+1, key+2 AS key_plus_2
|> WHERE key2 = key_plus_2
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
| +-$groupby.key#3 AS key2 [INT64]
| +-$groupby.$groupbycol2#4 AS `$groupbycol2` [INT64]
| +-$groupby.key_plus_2#5 AS key_plus_2 [INT64]
+-query=
  +-FilterScan
    +-column_list=$groupby.[key#3, $groupbycol2#4, key_plus_2#5]
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=$groupby.[key#3, $groupbycol2#4, key_plus_2#5]
    |   +-input_scan=
    |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   +-group_by_list=
    |     +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-$groupbycol2#4 :=
    |     | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     |   +-Literal(type=INT64, value=1)
    |     +-key_plus_2#5 :=
    |       +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |         +-Literal(type=INT64, value=2)
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=$groupby.key#3)
        +-ColumnRef(type=INT64, column=$groupby.key_plus_2#5)
==

# Duplicate aliases on GROUP BY expressions, and against aggregate expressions.
from KeyValue
|> AGGREGATE count(*) AS x
   GROUP BY key, key+1 AS key, value AS x, value||'x' AS x
--
QueryStmt
+-output_column_list=
| +-$groupby.key#4 AS key [INT64]
| +-$groupby.key#5 AS key [INT64]
| +-$groupby.x#6 AS x [STRING]
| +-$groupby.x#7 AS x [STRING]
| +-$aggregate.x#3 AS x [INT64]
+-query=
  +-AggregateScan
    +-column_list=[$groupby.key#4, $groupby.key#5, $groupby.x#6, $groupby.x#7, $aggregate.x#3]
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-group_by_list=
    | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    | +-key#5 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    | |   +-Literal(type=INT64, value=1)
    | +-x#6 := ColumnRef(type=STRING, column=KeyValue.Value#2)
    | +-x#7 :=
    |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-Literal(type=STRING, value="x")
    +-aggregate_list=
      +-x#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

from KeyValue
|> AGGREGATE count(*) AS x
   GROUP BY key, key+1 AS key
|> where key=1
--
ERROR: Column name key is ambiguous [at 4:10]
|> where key=1
         ^
==

# Test a GROUP BY alias in regular syntax, with FEATURE_PIPES on or off.
[language_features={{PIPES|}}]
select COUNT(*)
from KeyValue
GROUP BY key AS alias
--
ALTERNATION GROUP: PIPES
--
ERROR: GROUP BY does not support aliases [at 3:14]
GROUP BY key AS alias
             ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Syntax error: GROUP BY does not support aliases [at 3:14]
GROUP BY key AS alias
             ^
==

# Collation propagation for pipe AGGREGATE, for both aggregate and grouping
# columns.
# TODO Enable java support for collation.
[no_java]
[language_features=PIPES{{|,V_1_3_ANNOTATION_FRAMEWORK|,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT}}]
from CollatedTable
|> AGGREGATE MAX(COALESCE(string_ci)) as max_ci
   GROUP BY COALESCE(string_ci) AS grouping_ci
--
ALTERNATION GROUPS:
    <empty>
    ,V_1_3_ANNOTATION_FRAMEWORK
--
QueryStmt
+-output_column_list=
| +-$groupby.grouping_ci#6 AS grouping_ci [STRING]
| +-$aggregate.max_ci#5 AS max_ci [STRING]
+-query=
  +-AggregateScan
    +-column_list=[$groupby.grouping_ci#6, $aggregate.max_ci#5]
    +-input_scan=
    | +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
    +-group_by_list=
    | +-grouping_ci#6 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) STRING) -> STRING)
    |     +-ColumnRef(type=STRING, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    +-aggregate_list=
      +-max_ci#5 :=
        +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
          +-FunctionCall(ZetaSQL:coalesce(repeated(1) STRING) -> STRING)
            +-ColumnRef(type=STRING, column=CollatedTable.string_ci#1{Collation:"und:ci"})
--
ALTERNATION GROUP: ,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT
--
QueryStmt
+-output_column_list=
| +-$groupby.grouping_ci#6{Collation:"und:ci"} AS grouping_ci [STRING]
| +-$aggregate.max_ci#5{Collation:"und:ci"} AS max_ci [STRING]
+-query=
  +-AggregateScan
    +-column_list=[$groupby.grouping_ci#6{Collation:"und:ci"}, $aggregate.max_ci#5{Collation:"und:ci"}]
    +-input_scan=
    | +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
    +-group_by_list=
    | +-grouping_ci#6 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) STRING) -> STRING)
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    +-collation_list=[und:ci]
    +-aggregate_list=
      +-max_ci#5 :=
        +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
          +-type_annotation_map={Collation:"und:ci"}
          +-FunctionCall(ZetaSQL:coalesce(repeated(1) STRING) -> STRING)
            +-type_annotation_map={Collation:"und:ci"}
            +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
          +-collation_list=[und:ci]
