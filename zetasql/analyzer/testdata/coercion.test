[default also_show_signature_mismatch_details]

[language_features={{|V_1_3_DATE_TIME_CONSTRUCTORS}}]
select date(@test_param_string);
--
ALTERNATION GROUP: <empty>

--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DATE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:date(TIMESTAMP, optional(0) STRING) -> DATE)
    |     +-Cast(STRING -> TIMESTAMP)
    |       +-Parameter(type=STRING, name="test_param_string")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: V_1_3_DATE_TIME_CONSTRUCTORS
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DATE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:date(STRING) -> DATE)
    |     +-Parameter(type=STRING, name="test_param_string")
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_3_DATE_TIME_CONSTRUCTORS}}]
select date("2019-08-01 21:00:00+00");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DATE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:date(TIMESTAMP, optional(0) STRING) -> DATE)
    |     +-Literal(type=TIMESTAMP, value=2019-08-01 21:00:00+00)
    +-input_scan=
      +-SingleRowScan

==

select 1 + cast(2 as int32) = cast(3 as int32);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     | +-Literal(type=INT64, value=1)
    |     | +-Literal(type=INT64, value=2, has_explicit_type=TRUE)
    |     +-Literal(type=INT64, value=3, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

select 0x1 + cast(2 as INT32) = CAST(3 as INT32);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     | +-Literal(type=INT64, value=1)
    |     | +-Literal(type=INT64, value=2, has_explicit_type=TRUE)
    |     +-Literal(type=INT64, value=3, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

select key + 1 from TestTable where key = 5;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Cast(INT32 -> INT64)
    |     | +-ColumnRef(type=INT32, column=TestTable.key#1)
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.key#1]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
            +-ColumnRef(type=INT32, column=TestTable.key#1)
            +-Literal(type=INT32, value=5)
==

# No coercion, INT64 literals remain unchanged.
select 1 + 0x2 = 3;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     | +-Literal(type=INT64, value=1)
    |     | +-Literal(type=INT64, value=2)
    |     +-Literal(type=INT64, value=3)
    +-input_scan=
      +-SingleRowScan
==

select int32 + 1, int64 + 1, uint32 + 1, uint64 + 1, float + 1, double + 1
from SimpleTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [INT64]
| +-$query.$col2#21 AS `$col2` [INT64]
| +-$query.$col3#22 AS `$col3` [UINT64]
| +-$query.$col4#23 AS `$col4` [UINT64]
| +-$query.$col5#24 AS `$col5` [DOUBLE]
| +-$query.$col6#25 AS `$col6` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#20, $col2#21, $col3#22, $col4#23, $col5#24, $col6#25]
    +-expr_list=
    | +-$col1#20 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-Cast(INT32 -> INT64)
    | |   | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | |   +-Literal(type=INT64, value=1)
    | +-$col2#21 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | |   +-Literal(type=INT64, value=1)
    | +-$col3#22 :=
    | | +-FunctionCall(ZetaSQL:$add(UINT64, UINT64) -> UINT64)
    | |   +-Cast(UINT32 -> UINT64)
    | |   | +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | |   +-Literal(type=UINT64, value=1)
    | +-$col4#23 :=
    | | +-FunctionCall(ZetaSQL:$add(UINT64, UINT64) -> UINT64)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | |   +-Literal(type=UINT64, value=1)
    | +-$col5#24 :=
    | | +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Cast(FLOAT -> DOUBLE)
    | |   | +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
    | |   +-Literal(type=DOUBLE, value=1)
    | +-$col6#25 :=
    |   +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
    |     +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
    |     +-Literal(type=DOUBLE, value=1)
    +-input_scan=
      +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, float#8, double#9], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 7, 8])
==

select 1 + '1';
--
ERROR: No matching signature for operator + for argument types: INT64, STRING. Supported signatures: INT64 + INT64; UINT64 + UINT64; DOUBLE + DOUBLE [at 1:8]
select 1 + '1';
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for operator +
  Argument types: INT64, STRING
  Signature: INT64 + INT64
    Argument 2: Unable to coerce type STRING to expected type INT64
  Signature: UINT64 + UINT64
    Argument 2: Unable to coerce type STRING to expected type UINT64
  Signature: DOUBLE + DOUBLE
    Argument 2: Unable to coerce type STRING to expected type DOUBLE [at 1:8]
select 1 + '1';
       ^
==

# NULL tests for simple types.
select if(true, NULL, bool),
       if(true, int32, NULL),
       if(true, int64, NULL),
       if(true, uint32, NULL),
       if(true, uint64, NULL),
       if(true, float, NULL),
       if(true, string, NULL),
       if(true, bytes, NULL),
       if(true, date, NULL),
       if(true, timestamp, NULL)
from SimpleTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [BOOL]
| +-$query.$col2#21 AS `$col2` [INT32]
| +-$query.$col3#22 AS `$col3` [INT64]
| +-$query.$col4#23 AS `$col4` [UINT32]
| +-$query.$col5#24 AS `$col5` [UINT64]
| +-$query.$col6#25 AS `$col6` [FLOAT]
| +-$query.$col7#26 AS `$col7` [STRING]
| +-$query.$col8#27 AS `$col8` [BYTES]
| +-$query.$col9#28 AS `$col9` [DATE]
| +-$query.$col10#29 AS `$col10` [TIMESTAMP]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#20, $col2#21, $col3#22, $col4#23, $col5#24, $col6#25, $col7#26, $col8#27, $col9#28, $col10#29]
    +-expr_list=
    | +-$col1#20 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BOOL, value=NULL)
    | |   +-ColumnRef(type=BOOL, column=SimpleTypes.bool#7)
    | +-$col2#21 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, INT32, INT32) -> INT32)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | |   +-Literal(type=INT32, value=NULL)
    | +-$col3#22 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | |   +-Literal(type=INT64, value=NULL)
    | +-$col4#23 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, UINT32, UINT32) -> UINT32)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | |   +-Literal(type=UINT32, value=NULL)
    | +-$col5#24 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, UINT64, UINT64) -> UINT64)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | |   +-Literal(type=UINT64, value=NULL)
    | +-$col6#25 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, FLOAT, FLOAT) -> FLOAT)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
    | |   +-Literal(type=FLOAT, value=NULL)
    | +-$col7#26 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, STRING, STRING) -> STRING)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col8#27 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BYTES, BYTES) -> BYTES)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
    | |   +-Literal(type=BYTES, value=NULL)
    | +-$col9#28 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DATE, DATE) -> DATE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
    | |   +-Literal(type=DATE, value=NULL)
    | +-$col10#29 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, TIMESTAMP, TIMESTAMP) -> TIMESTAMP)
    |     +-Literal(type=BOOL, value=true)
    |     +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
    |     +-Literal(type=TIMESTAMP, value=NULL)
    +-input_scan=
      +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, date#10, timestamp#15], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 9, 14])
==

# NULL tests for non-simple types.
select if(true, KitchenSink, NULL),
       if(true, KitchenSink.repeated_int32_val, NULL),
       if(true, KitchenSink.test_enum, NULL),
       if(true, KitchenSink.key_value, NULL),
       if(true, NULL, KitchenSink.key_value_array)
from TestTable;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
| +-$query.$col2#5 AS `$col2` [ARRAY<INT32>]
| +-$query.$col3#6 AS `$col3` [ENUM<zetasql_test__.TestEnum>]
| +-$query.$col4#7 AS `$col4` [PROTO<zetasql_test__.KeyValueStruct>]
| +-$query.$col5#8 AS `$col5` [ARRAY<PROTO<zetasql_test__.KeyValueStruct>>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#4, $col2#5, $col3#6, $col4#7, $col5#8]
    +-expr_list=
    | +-$col1#4 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, PROTO<zetasql_test__.KitchenSinkPB>, PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   +-Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value=NULL)
    | +-$col2#5 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<INT32>, ARRAY<INT32>) -> ARRAY<INT32>)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-GetProtoField
    | |   | +-type=ARRAY<INT32>
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=repeated_int32_val
    | |   | +-default_value=[]
    | |   +-Literal(type=ARRAY<INT32>, value=NULL)
    | +-$col3#6 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> ENUM<zetasql_test__.TestEnum>)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-GetProtoField
    | |   | +-type=ENUM<zetasql_test__.TestEnum>
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=test_enum
    | |   | +-default_value=TESTENUM0
    | |   +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=NULL)
    | +-$col4#7 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, PROTO<zetasql_test__.KeyValueStruct>, PROTO<zetasql_test__.KeyValueStruct>) -> PROTO<zetasql_test__.KeyValueStruct>)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-GetProtoField
    | |   | +-type=PROTO<zetasql_test__.KeyValueStruct>
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=key_value
    | |   | +-default_value=NULL
    | |   +-Literal(type=PROTO<zetasql_test__.KeyValueStruct>, value=NULL)
    | +-$col5#8 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<PROTO<zetasql_test__.KeyValueStruct>>, ARRAY<PROTO<zetasql_test__.KeyValueStruct>>) -> ARRAY<PROTO<zetasql_test__.KeyValueStruct>>)
    |     +-Literal(type=BOOL, value=true)
    |     +-Literal(type=ARRAY<PROTO<zetasql_test__.KeyValueStruct>>, value=NULL)
    |     +-GetProtoField
    |       +-type=ARRAY<PROTO<zetasql_test__.KeyValueStruct>>
    |       +-expr=
    |       | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |       +-field_descriptor=key_value_array
    |       +-default_value=[]
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# More interesting NULL coercion tests.
select array_length(cast(NULL as array<bool>))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:array_length(ARRAY<BOOL>) -> INT64)
    |     +-Literal(type=ARRAY<BOOL>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

select array_length(NULL)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:array_length(ARRAY<INT64>) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

select (cast(NULL as array<bool>))[offset(0)]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<BOOL>, INT64) -> BOOL)
    |     +-Literal(type=ARRAY<BOOL>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=INT64, value=0)
    +-input_scan=
      +-SingleRowScan
==

# Java test is implemented separatly at `testExtendedSubscriptFunction` in
# `javatests/com/google/zetasql/AnalyzerTest.java`
# See more context at b/186869835.
[no_java]
select NULL[offset(0)]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript_with_offset(STRING, INT64) -> STRING)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=INT64, value=0)
    +-input_scan=
      +-SingleRowScan
==

select fn_on_arbitrary_type_argument(NULL),
       fn_on_any_element_returns_array(NULL)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
| +-$query.$col2#2 AS `$col2` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(sample_functions:fn_on_arbitrary_type_argument(INT64) -> BOOL)
    | |   +-Literal(type=INT64, value=NULL)
    | +-$col2#2 :=
    |   +-FunctionCall(sample_functions:fn_on_any_element_returns_array(INT64) -> ARRAY<INT64>)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

select fn_on_any_array_returns_element(NULL)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_any_array_returns_element(ARRAY<INT64>) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

# For a function that takes any enum, proto, or struct, passing a NULL literal
# is not valid since we do not know what enum, struct, or proto type it actually is.
select fn_on_any_enum(NULL)
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_ANY_ENUM for argument types: NULL. Supported signature: FN_ON_ANY_ENUM(ENUM) [at 1:8]
select fn_on_any_enum(NULL)
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_ANY_ENUM
  Argument types: NULL
  Signature: FN_ON_ANY_ENUM(ENUM)
    Unable to determine type for untyped null for argument kind <enum> [at 1:8]
select fn_on_any_enum(NULL)
       ^
==

select fn_on_any_proto(NULL)
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_ANY_PROTO for argument types: NULL. Supported signature: FN_ON_ANY_PROTO(PROTO) [at 1:8]
select fn_on_any_proto(NULL)
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_ANY_PROTO
  Argument types: NULL
  Signature: FN_ON_ANY_PROTO(PROTO)
    Unable to determine type for untyped null for argument kind <proto> [at 1:8]
select fn_on_any_proto(NULL)
       ^
==

select fn_on_any_struct(NULL)
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_ANY_STRUCT for argument types: NULL. Supported signature: FN_ON_ANY_STRUCT(STRUCT) [at 1:8]
select fn_on_any_struct(NULL)
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_ANY_STRUCT
  Argument types: NULL
  Signature: FN_ON_ANY_STRUCT(STRUCT)
    Unable to determine type for untyped null for argument kind <struct> [at 1:8]
select fn_on_any_struct(NULL)
       ^
==

select if (true, `uint64`, 1)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [UINT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, UINT64, UINT64) -> UINT64)
    |     +-Literal(type=BOOL, value=true)
    |     +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    |     +-Literal(type=UINT64, value=1)
    +-input_scan=
      +-TableScan(column_list=[SimpleTypes.uint64#4], table=SimpleTypes, column_index_list=[3])
==

select if (true, `uint64`, -1)
from SimpleTypes
--
ERROR: Could not cast literal -1 to type UINT64 [at 1:28]
select if (true, `uint64`, -1)
                           ^
==

select true
  FROM TestTable
  WHERE KitchenSink.test_enum = 1 AND
        KitchenSink.test_enum = 'TESTENUM0' AND
        1 = KitchenSink.test_enum AND
        'TESTENUM0' = KitchenSink.test_enum;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=BOOL, value=true)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$and(BOOL, repeated(3) BOOL) -> BOOL)
            +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
            | +-GetProtoField
            | | +-type=ENUM<zetasql_test__.TestEnum>
            | | +-expr=
            | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | | +-field_descriptor=test_enum
            | | +-default_value=TESTENUM0
            | +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
            +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
            | +-GetProtoField
            | | +-type=ENUM<zetasql_test__.TestEnum>
            | | +-expr=
            | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | | +-field_descriptor=test_enum
            | | +-default_value=TESTENUM0
            | +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
            +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
            | +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
            | +-GetProtoField
            |   +-type=ENUM<zetasql_test__.TestEnum>
            |   +-expr=
            |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            |   +-field_descriptor=test_enum
            |   +-default_value=TESTENUM0
            +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
              +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
              +-GetProtoField
                +-type=ENUM<zetasql_test__.TestEnum>
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=test_enum
                +-default_value=TESTENUM0
==

# Comparing enum against out of range int64 literal (which can fit in an int32).
select 1 FROM TestTable WHERE KitchenSink.test_enum = 12345;
--
ERROR: Could not cast literal 12345 to type zetasql_test__.TestEnum [at 1:55]
select 1 FROM TestTable WHERE KitchenSink.test_enum = 12345;
                                                      ^
==

# Comparing enum against out of range int64 literal. This should fail before
# doing enum range check, as the given int64 wont fit into an int32 to carry
# the enum conversion.
select 1 FROM TestTable WHERE KitchenSink.test_enum = 123456890123;
--
ERROR: Could not cast literal 123456890123 to type zetasql_test__.TestEnum [at 1:55]
select 1 FROM TestTable WHERE KitchenSink.test_enum = 123456890123;
                                                      ^
==

select 1 FROM TestTable WHERE KitchenSink.test_enum = "a";
--
ERROR: Could not cast literal "a" to type zetasql_test__.TestEnum [at 1:55]
select 1 FROM TestTable WHERE KitchenSink.test_enum = "a";
                                                      ^
==

select 1 FROM TestTable WHERE KitchenSink.test_enum = NULL;
--
ERROR: Operands of = cannot be literal NULL [at 1:55]
select 1 FROM TestTable WHERE KitchenSink.test_enum = NULL;
                                                      ^
==

select 1 FROM TestTable WHERE KitchenSink.test_enum = KitchenSink.string_val;
--
ERROR: No matching signature for operator = for argument types: zetasql_test__.TestEnum, STRING. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 1:31]
select 1 FROM TestTable WHERE KitchenSink.test_enum = KitchenSink.string_val;
                              ^
--
Signature Mismatch Details:
ERROR: No matching signature for operator = for argument types: zetasql_test__.TestEnum, STRING
  Signature: T1 = T1
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {STRING, zetasql_test__.TestEnum}
  Signature: INT64 = UINT64
    Argument 1: Unable to coerce type zetasql_test__.TestEnum to expected type INT64
  Signature: UINT64 = INT64
    Argument 1: Unable to coerce type zetasql_test__.TestEnum to expected type UINT64 [at 1:31]
select 1 FROM TestTable WHERE KitchenSink.test_enum = KitchenSink.string_val;
                              ^
==

select 1 FROM TestTable WHERE KitchenSink.test_enum = KitchenSink.int64_val;
--
ERROR: No matching signature for operator = for argument types: zetasql_test__.TestEnum, INT64. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 1:31]
select 1 FROM TestTable WHERE KitchenSink.test_enum = KitchenSink.int64_val;
                              ^
--
Signature Mismatch Details:
ERROR: No matching signature for operator = for argument types: zetasql_test__.TestEnum, INT64
  Signature: T1 = T1
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, zetasql_test__.TestEnum}
  Signature: INT64 = UINT64
    Argument 1: Unable to coerce type zetasql_test__.TestEnum to expected type INT64
  Signature: UINT64 = INT64
    Argument 1: Unable to coerce type zetasql_test__.TestEnum to expected type UINT64 [at 1:31]
select 1 FROM TestTable WHERE KitchenSink.test_enum = KitchenSink.int64_val;
                              ^
==

select 1
  FROM TestTable
  WHERE CAST(KitchenSink.string_val AS `zetasql_test__.TestEnum`) =
        KitchenSink.test_enum;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
            +-Cast(STRING -> ENUM<zetasql_test__.TestEnum>)
            | +-GetProtoField
            |   +-type=STRING
            |   +-expr=
            |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            |   +-field_descriptor=string_val
            |   +-default_value="default_name"
            +-GetProtoField
              +-type=ENUM<zetasql_test__.TestEnum>
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              +-field_descriptor=test_enum
              +-default_value=TESTENUM0
==

select 1
  FROM TestTable
  WHERE KitchenSink.test_enum
        IN ('TESTENUM0',
            1,
            NULL,
            CAST(KitchenSink.string_val AS `zetasql_test__.TestEnum`),
            CAST(KitchenSink.int64_val AS `zetasql_test__.TestEnum`),
            CAST(1 AS `zetasql_test__.TestEnum`));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$in(ENUM<zetasql_test__.TestEnum>, repeated(6) ENUM<zetasql_test__.TestEnum>) -> BOOL)
            +-GetProtoField
            | +-type=ENUM<zetasql_test__.TestEnum>
            | +-expr=
            | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | +-field_descriptor=test_enum
            | +-default_value=TESTENUM0
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=NULL)
            +-Cast(STRING -> ENUM<zetasql_test__.TestEnum>)
            | +-GetProtoField
            |   +-type=STRING
            |   +-expr=
            |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            |   +-field_descriptor=string_val
            |   +-default_value="default_name"
            +-Cast(INT64 -> ENUM<zetasql_test__.TestEnum>)
            | +-GetProtoField
            |   +-type=INT64
            |   +-expr=
            |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            |   +-field_descriptor=int64_val
            |   +-default_value=0
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
==

select 1
  FROM TestTable
  WHERE KitchenSink.test_enum
        IN ('TESTENUM0', 'TESTENUM1', 'TESTENUM2', 'TESTENUM2147483647',
            0, 1, 2, 2147483647);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$in(ENUM<zetasql_test__.TestEnum>, repeated(8) ENUM<zetasql_test__.TestEnum>) -> BOOL)
            +-GetProtoField
            | +-type=ENUM<zetasql_test__.TestEnum>
            | +-expr=
            | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | +-field_descriptor=test_enum
            | +-default_value=TESTENUM0
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2147483647)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2147483647)
==

select 1
  FROM TestTable
  WHERE KitchenSink.test_enum
        IN ('TESTENUM0', 12345, 'INVALID_VALUE');
--
ERROR: Could not cast literal 12345 to type zetasql_test__.TestEnum [at 4:26]
        IN ('TESTENUM0', 12345, 'INVALID_VALUE');
                         ^
==

select 1
  FROM TestTable
  WHERE KitchenSink.test_enum IN (KitchenSink.string_val, 'TESTENUM0');
--
ERROR: No matching signature for operator IN for argument types ENUM<zetasql_test__.TestEnum> and {STRING, STRING} [at 3:31]
  WHERE KitchenSink.test_enum IN (KitchenSink.string_val, 'TESTENUM0');
                              ^
==

# Test supertyping of PROTO and STRING literal.  The STRING is implicitly
# cast to PROTO.
select if(false,
          KitchenSink,
          """int64_key_1: 1, int64_key_2: 2""")
from TestTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, PROTO<zetasql_test__.KitchenSinkPB>, PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     +-Literal(type=BOOL, value=false)
    |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={int64_key_1: 1 int64_key_2: 2})
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# Same test as previous, but the STRING literal is explicitly cast to STRING,
# and becomes a constant-folded STRING literal.  Supertyping of PROTO and
# constant-folded STRING literal does not work.
select if(false,
          KitchenSink,
          CAST("""int64_key_1: 1, int64_key_2: 2""" AS STRING))
from TestTable
--
ERROR: No matching signature for function IF for argument types: BOOL, zetasql_test__.KitchenSinkPB, STRING. Supported signature: IF(BOOL, ANY, ANY) [at 1:8]
select if(false,
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function IF
  Argument types: BOOL, zetasql_test__.KitchenSinkPB, STRING
  Signature: IF(BOOL, T1, T1)
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {STRING, zetasql_test__.KitchenSinkPB} [at 1:8]
select if(false,
       ^
==

# Test implicit supertyping of proto and string literal.  Fails since the
# string literal is not valid.
select if(false,
          KitchenSink,
          """int64_key_1: int64_key_2: 2""")
from TestTable
--
ERROR: Could not cast literal "int64_key_1: int64_key_2: 2" to type zetasql_test__.KitchenSinkPB (Error parsing proto: Expected integer, got: int64_key_2 [1:14]) [at 3:11]
          """int64_key_1: int64_key_2: 2""")
          ^
==

# Test supertyping of proto and bytes literal.
select if(false,
          KitchenSink,
          b"int64_key_1: 1, int64_key_2: 2")
from TestTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, PROTO<zetasql_test__.KitchenSinkPB>, PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     +-Literal(type=BOOL, value=false)
    |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={<unparseable>})
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# Supertyping two different protos does not work.
select if(false,
          KitchenSink,
          KitchenSink.nested_value)
from TestTable
--
ERROR: No matching signature for function IF for argument types: BOOL, zetasql_test__.KitchenSinkPB, zetasql_test__.KitchenSinkPB.Nested. Supported signature: IF(BOOL, ANY, ANY) [at 1:8]
select if(false,
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function IF
  Argument types: BOOL, zetasql_test__.KitchenSinkPB, zetasql_test__.KitchenSinkPB.Nested
  Signature: IF(BOOL, T1, T1)
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {zetasql_test__.KitchenSinkPB.Nested, zetasql_test__.KitchenSinkPB} [at 1:8]
select if(false,
       ^
==

# Supertyping proto and non-literal string does not work.
select if(false,
          KitchenSink,
          cast(KitchenSink as string))
from TestTable
--
ERROR: No matching signature for function IF for argument types: BOOL, zetasql_test__.KitchenSinkPB, STRING. Supported signature: IF(BOOL, ANY, ANY) [at 1:8]
select if(false,
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function IF
  Argument types: BOOL, zetasql_test__.KitchenSinkPB, STRING
  Signature: IF(BOOL, T1, T1)
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {STRING, zetasql_test__.KitchenSinkPB} [at 1:8]
select if(false,
       ^
==

# Supertyping proto and non-literal bytes does not work.
select if(false,
          KitchenSink,
          cast(KitchenSink as bytes))
from TestTable
--
ERROR: No matching signature for function IF for argument types: BOOL, zetasql_test__.KitchenSinkPB, BYTES. Supported signature: IF(BOOL, ANY, ANY) [at 1:8]
select if(false,
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function IF
  Argument types: BOOL, zetasql_test__.KitchenSinkPB, BYTES
  Signature: IF(BOOL, T1, T1)
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {BYTES, zetasql_test__.KitchenSinkPB} [at 1:8]
select if(false,
       ^
==

# Super-type three function arguments with different types with a literal or
# parameter in the first slot.
select coalesce(
  {{'int64_key_1:1 int64_key_2:2'|@test_param_string|@test_param_proto|KitchenSink}},
  coalesce(CAST('' as alt_descriptor_pool.zetasql_test__.KitchenSinkPB)),
  KitchenSink)
from TestTable
--
ALTERNATION GROUP: 'int64_key_1:1 int64_key_2:2'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(3) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     +-Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={int64_key_1: 1 int64_key_2: 2})
    |     +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     | +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     |   +-Literal(type=STRING, value="")
    |     +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
    |       +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
--
ALTERNATION GROUP: @test_param_string
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(3) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     | +-Parameter(type=STRING, name="test_param_string")
    |     +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     | +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     |   +-Literal(type=STRING, value="")
    |     +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
    |       +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
--
ALTERNATION GROUP: @test_param_proto
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(3) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     +-Parameter(type=PROTO<zetasql_test__.KitchenSinkPB>, name="test_param_proto")
    |     +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     | +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     |   +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     |     +-Literal(type=STRING, value="")
    |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
--
ALTERNATION GROUP: KitchenSink
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(3) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     | +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     |   +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     |     +-Literal(type=STRING, value="")
    |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# Super-type three union arguments with different types with a literal or
# param in the first slot.
select {{'int64_key_1:1 int64_key_2:2'|@test_param_string|@test_param_proto|KitchenSink}} from TestTable
union all
select coalesce(CAST('' as alt_descriptor_pool.zetasql_test__.KitchenSinkPB))
union all
select KitchenSink from TestTable
--
ALTERNATION GROUP: 'int64_key_1:1 int64_key_2:2'
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#9 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#9]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.$col1#10]
      | |   +-expr_list=
      | |   | +-$col1#10 := Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={int64_key_1: 1 int64_key_2: 2})
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$union_all1.$col1#4]
      | |       +-expr_list=
      | |       | +-$col1#4 := Literal(type=STRING, value="int64_key_1:1 int64_key_2:2")
      | |       +-input_scan=
      | |         +-TableScan(table=TestTable)
      | +-output_column_list=[$union_all1_cast.$col1#10]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2.$col1#5]
      | |   +-expr_list=
      | |   | +-$col1#5 :=
      | |   |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |     +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |       +-Literal(type=STRING, value="")
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=[$union_all2.$col1#5]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3_cast.KitchenSink#11]
        |   +-expr_list=
        |   | +-KitchenSink#11 :=
        |   |   +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
        |   |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#8)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[TestTable.KitchenSink#8]
        |       +-input_scan=
        |         +-TableScan(column_list=[TestTable.KitchenSink#8], table=TestTable, column_index_list=[2])
        +-output_column_list=[$union_all3_cast.KitchenSink#11]
--
ALTERNATION GROUP: @test_param_string
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#9 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#9]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.$col1#10]
      | |   +-expr_list=
      | |   | +-$col1#10 :=
      | |   |   +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |     +-ColumnRef(type=STRING, column=$union_all1.$col1#4)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$union_all1.$col1#4]
      | |       +-expr_list=
      | |       | +-$col1#4 := Parameter(type=STRING, name="test_param_string")
      | |       +-input_scan=
      | |         +-TableScan(table=TestTable)
      | +-output_column_list=[$union_all1_cast.$col1#10]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2.$col1#5]
      | |   +-expr_list=
      | |   | +-$col1#5 :=
      | |   |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |     +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |       +-Literal(type=STRING, value="")
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=[$union_all2.$col1#5]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3_cast.KitchenSink#11]
        |   +-expr_list=
        |   | +-KitchenSink#11 :=
        |   |   +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
        |   |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#8)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[TestTable.KitchenSink#8]
        |       +-input_scan=
        |         +-TableScan(column_list=[TestTable.KitchenSink#8], table=TestTable, column_index_list=[2])
        +-output_column_list=[$union_all3_cast.KitchenSink#11]
--
ALTERNATION GROUP: @test_param_proto
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#9 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#9]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1.$col1#4]
      | |   +-expr_list=
      | |   | +-$col1#4 := Parameter(type=PROTO<zetasql_test__.KitchenSinkPB>, name="test_param_proto")
      | |   +-input_scan=
      | |     +-TableScan(table=TestTable)
      | +-output_column_list=[$union_all1.$col1#4]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.$col1#10]
      | |   +-expr_list=
      | |   | +-$col1#10 :=
      | |   |   +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=$union_all2.$col1#5)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$union_all2.$col1#5]
      | |       +-expr_list=
      | |       | +-$col1#5 :=
      | |       |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |       |     +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |       |       +-Literal(type=STRING, value="")
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$union_all2_cast.$col1#10]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.KitchenSink#8]
        |   +-input_scan=
        |     +-TableScan(column_list=[TestTable.KitchenSink#8], table=TestTable, column_index_list=[2])
        +-output_column_list=[TestTable.KitchenSink#8]
--
ALTERNATION GROUP: KitchenSink
--
QueryStmt
+-output_column_list=
| +-$union_all.KitchenSink#8 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.KitchenSink#8]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[TestTable.KitchenSink#3]
      | |   +-input_scan=
      | |     +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
      | +-output_column_list=[TestTable.KitchenSink#3]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.$col1#9]
      | |   +-expr_list=
      | |   | +-$col1#9 :=
      | |   |   +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=$union_all2.$col1#4)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$union_all2.$col1#4]
      | |       +-expr_list=
      | |       | +-$col1#4 :=
      | |       |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |       |     +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |       |       +-Literal(type=STRING, value="")
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$union_all2_cast.$col1#9]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.KitchenSink#7]
        |   +-input_scan=
        |     +-TableScan(column_list=[TestTable.KitchenSink#7], table=TestTable, column_index_list=[2])
        +-output_column_list=[TestTable.KitchenSink#7]
==

select {{Array<int64>[]|Array<int32>[]|Array<string>[]}} union all select []
--
ALTERNATION GROUP: Array<int64>[]
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#3]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1.$col1#1]
      | |   +-expr_list=
      | |   | +-$col1#1 := Literal(type=ARRAY<INT64>, value=[], has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=[$union_all1.$col1#1]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2.$col1#2]
        |   +-expr_list=
        |   | +-$col1#2 := Literal(type=ARRAY<INT64>, value=[])
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=[$union_all2.$col1#2]
--
ALTERNATION GROUP: Array<int32>[]
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#3 AS `$col1` [ARRAY<INT32>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#3]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1.$col1#1]
      | |   +-expr_list=
      | |   | +-$col1#1 := Literal(type=ARRAY<INT32>, value=[], has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=[$union_all1.$col1#1]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2_cast.$col1#4]
        |   +-expr_list=
        |   | +-$col1#4 := Literal(type=ARRAY<INT32>, value=[])
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$union_all2.$col1#2]
        |       +-expr_list=
        |       | +-$col1#2 := Literal(type=ARRAY<INT64>, value=[])
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$union_all2_cast.$col1#4]
--
ALTERNATION GROUP: Array<string>[]
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#3 AS `$col1` [ARRAY<STRING>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#3]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1.$col1#1]
      | |   +-expr_list=
      | |   | +-$col1#1 := Literal(type=ARRAY<STRING>, value=[], has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=[$union_all1.$col1#1]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2_cast.$col1#4]
        |   +-expr_list=
        |   | +-$col1#4 := Literal(type=ARRAY<STRING>, value=[])
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$union_all2.$col1#2]
        |       +-expr_list=
        |       | +-$col1#2 := Literal(type=ARRAY<INT64>, value=[])
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$union_all2_cast.$col1#4]
==

select fn_on_any_array_returns_element(
    {{Array<int64>[]|Array<int32>[]|Array<string>[]|[]}})
--
ALTERNATION GROUP: Array<int64>[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_any_array_returns_element(ARRAY<INT64>) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: Array<int32>[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_any_array_returns_element(ARRAY<INT32>) -> INT32)
    |     +-Literal(type=ARRAY<INT32>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: Array<string>[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_any_array_returns_element(ARRAY<STRING>) -> STRING)
    |     +-Literal(type=ARRAY<STRING>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: []
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_any_array_returns_element(ARRAY<INT64>) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select fn_on_int32_array_returns_int32(
    {{ARRAY<int32>[]|ARRAY<int64>[]|ARRAY<string>[]|[]}})
--
ALTERNATION GROUP: ARRAY<int32>[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_int32_array_returns_int32(ARRAY<INT32>) -> INT32)
    |     +-Literal(type=ARRAY<INT32>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: ARRAY<int64>[]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<INT64>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 1:8]
select fn_on_int32_array_returns_int32(
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32
  Argument types: ARRAY<INT64>
  Signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>)
    Argument 1: Unable to coerce type ARRAY<INT64> to expected type ARRAY<INT32> [at 1:8]
select fn_on_int32_array_returns_int32(
       ^
--
ALTERNATION GROUP: ARRAY<string>[]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<STRING>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 1:8]
select fn_on_int32_array_returns_int32(
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32
  Argument types: ARRAY<STRING>
  Signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>)
    Argument 1: Unable to coerce type ARRAY<STRING> to expected type ARRAY<INT32> [at 1:8]
select fn_on_int32_array_returns_int32(
       ^
--
ALTERNATION GROUP: []
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_int32_array_returns_int32(ARRAY<INT32>) -> INT32)
    |     +-Literal(type=ARRAY<INT32>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select fn_on_int64_array_returns_int64(
    {{ARRAY<int64>[]|ARRAY<int32>[]|ARRAY<uint32>[]|[]}})
--
ALTERNATION GROUP: ARRAY<int64>[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_int64_array_returns_int64(ARRAY<INT64>) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: ARRAY<int32>[]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT64_ARRAY_RETURNS_INT64 for argument types: ARRAY<INT32>. Supported signature: FN_ON_INT64_ARRAY_RETURNS_INT64(ARRAY<INT64>) [at 1:8]
select fn_on_int64_array_returns_int64(
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT64_ARRAY_RETURNS_INT64
  Argument types: ARRAY<INT32>
  Signature: FN_ON_INT64_ARRAY_RETURNS_INT64(ARRAY<INT64>)
    Argument 1: Unable to coerce type ARRAY<INT32> to expected type ARRAY<INT64> [at 1:8]
select fn_on_int64_array_returns_int64(
       ^
--
ALTERNATION GROUP: ARRAY<uint32>[]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT64_ARRAY_RETURNS_INT64 for argument types: ARRAY<UINT32>. Supported signature: FN_ON_INT64_ARRAY_RETURNS_INT64(ARRAY<INT64>) [at 1:8]
select fn_on_int64_array_returns_int64(
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT64_ARRAY_RETURNS_INT64
  Argument types: ARRAY<UINT32>
  Signature: FN_ON_INT64_ARRAY_RETURNS_INT64(ARRAY<INT64>)
    Argument 1: Unable to coerce type ARRAY<UINT32> to expected type ARRAY<INT64> [at 1:8]
select fn_on_int64_array_returns_int64(
       ^
--
ALTERNATION GROUP: []
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_int64_array_returns_int64(ARRAY<INT64>) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select if(true, [1,2,3], [])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<INT64>, ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=BOOL, value=true)
    |     +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select ifnull(NULL, [])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:ifnull(ARRAY<INT64>, ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=ARRAY<INT64>, value=NULL)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select ifnull([], NULL)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:ifnull(ARRAY<INT64>, ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    |     +-Literal(type=ARRAY<INT64>, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

select ifnull([], [])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:ifnull(ARRAY<INT64>, ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select ifnull(CAST(NULL AS INT32), NULL)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:ifnull(INT32, INT32) -> INT32)
    |     +-Literal(type=INT32, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=INT32, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

select ifnull(ARRAY<INT32>[], [])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:ifnull(ARRAY<INT32>, ARRAY<INT32>) -> ARRAY<INT32>)
    |     +-Literal(type=ARRAY<INT32>, value=[], has_explicit_type=TRUE)
    |     +-Literal(type=ARRAY<INT32>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select (case when true then array<int32>[] else [] end)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$case_no_value(repeated(1) BOOL, repeated(1) ARRAY<INT32>, ARRAY<INT32>) -> ARRAY<INT32>)
    |     +-Literal(type=BOOL, value=true)
    |     +-Literal(type=ARRAY<INT32>, value=[], has_explicit_type=TRUE)
    |     +-Literal(type=ARRAY<INT32>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select coalesce({{NULL|[]}}, {{[]|NULL}})
--
ALTERNATION GROUP: NULL,[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=ARRAY<INT64>, value=NULL)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL,NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) INT64) -> INT64)
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: [],[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: [],NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    |     +-Literal(type=ARRAY<INT64>, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select KitchenSink.repeated_int32_val
from TestTable
where KitchenSink.repeated_int32_val = []
--
ALTERNATION GROUP: <empty>
--
ERROR: Equality is not defined for arguments of type ARRAY<INT32> [at 3:7]
where KitchenSink.repeated_int32_val = []
      ^
--
ALTERNATION GROUP: V_1_1_ARRAY_EQUALITY
--
QueryStmt
+-output_column_list=
| +-$query.repeated_int32_val#4 AS repeated_int32_val [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.repeated_int32_val#4]
    +-expr_list=
    | +-repeated_int32_val#4 :=
    |   +-GetProtoField
    |     +-type=ARRAY<INT32>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-field_descriptor=repeated_int32_val
    |     +-default_value=[]
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(ARRAY<INT32>, ARRAY<INT32>) -> BOOL)
            +-GetProtoField
            | +-type=ARRAY<INT32>
            | +-expr=
            | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | +-field_descriptor=repeated_int32_val
            | +-default_value=[]
            +-Literal(type=ARRAY<INT32>, value=[])
==

[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select KitchenSink.repeated_int32_val = KitchenSink.repeated_string_val
from TestTable
--
ERROR: No matching signature for operator = for argument types: ARRAY<INT32>, ARRAY<STRING>. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 1:8]
select KitchenSink.repeated_int32_val = KitchenSink.repeated_string_val
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for operator = for argument types: ARRAY<INT32>, ARRAY<STRING>
  Signature: T1 = T1
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {ARRAY<INT32>, ARRAY<STRING>}
  Signature: INT64 = UINT64
    Argument 1: Unable to coerce type ARRAY<INT32> to expected type INT64
  Signature: UINT64 = INT64
    Argument 1: Unable to coerce type ARRAY<INT32> to expected type UINT64 [at 1:8]
select KitchenSink.repeated_int32_val = KitchenSink.repeated_string_val
       ^
==

[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select KitchenSink.repeated_int32_val = KitchenSink.repeated_int64_val
from TestTable
--
ERROR: No matching signature for operator = for argument types: ARRAY<INT32>, ARRAY<INT64>. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 1:8]
select KitchenSink.repeated_int32_val = KitchenSink.repeated_int64_val
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for operator = for argument types: ARRAY<INT32>, ARRAY<INT64>
  Signature: T1 = T1
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {ARRAY<INT32>, ARRAY<INT64>}
  Signature: INT64 = UINT64
    Argument 1: Unable to coerce type ARRAY<INT32> to expected type INT64
  Signature: UINT64 = INT64
    Argument 1: Unable to coerce type ARRAY<INT32> to expected type UINT64 [at 1:8]
select KitchenSink.repeated_int32_val = KitchenSink.repeated_int64_val
       ^
==

# TODO: This should work when implicit array coercion is allowed.
[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select KitchenSink.repeated_int32_val = [1,2,3]
from TestTable
--
ERROR: No matching signature for operator = for argument types: ARRAY<INT32>, ARRAY<INT64>. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 1:8]
select KitchenSink.repeated_int32_val = [1,2,3]
       ^

--
Signature Mismatch Details:
ERROR: No matching signature for operator = for argument types: ARRAY<INT32>, ARRAY<INT64>
  Signature: T1 = T1
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {ARRAY<INT32>, ARRAY<INT64>}
  Signature: INT64 = UINT64
    Argument 1: Unable to coerce type ARRAY<INT32> to expected type INT64
  Signature: UINT64 = INT64
    Argument 1: Unable to coerce type ARRAY<INT32> to expected type UINT64 [at 1:8]
select KitchenSink.repeated_int32_val = [1,2,3]
       ^
==

# TODO: This should work when implicit array coercion is allowed.
[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select KitchenSink.repeated_int64_val = [null]
from TestTable
--

ALTERNATION GROUP: <empty>
--
ERROR: Equality is not defined for arguments of type ARRAY<INT64> [at 1:8]
select KitchenSink.repeated_int64_val = [null]
       ^
--
ALTERNATION GROUP: V_1_1_ARRAY_EQUALITY
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:$equal(ARRAY<INT64>, ARRAY<INT64>) -> BOOL)
    |     +-GetProtoField
    |     | +-type=ARRAY<INT64>
    |     | +-expr=
    |     | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     | +-field_descriptor=repeated_int64_val
    |     | +-default_value=[]
    |     +-Literal(type=ARRAY<INT64>, value=[NULL])
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# TODO: This should work when implicit array coercion is allowed.
[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select KitchenSink.repeated_string_val = [null]
from TestTable
--
ERROR: No matching signature for operator = for argument types: ARRAY<STRING>, ARRAY<INT64>. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 1:8]
select KitchenSink.repeated_string_val = [null]
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for operator = for argument types: ARRAY<STRING>, ARRAY<INT64>
  Signature: T1 = T1
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {ARRAY<STRING>, ARRAY<INT64>}
  Signature: INT64 = UINT64
    Argument 1: Unable to coerce type ARRAY<STRING> to expected type INT64
  Signature: UINT64 = INT64
    Argument 1: Unable to coerce type ARRAY<STRING> to expected type UINT64 [at 1:8]
select KitchenSink.repeated_string_val = [null]
       ^
==

[language_features=NUMERIC_TYPE]
SELECT if (true, 0.93, NUMERIC '0.94'),
       if (true, cast(0.93 as double), NUMERIC '0.94'),
       if (true, @test_param_double, NUMERIC '0.94'),
       if (true, 0.93 * 0.93, NUMERIC '0.94'),
       if (true, cast(0.93 as double), cast(0.94 as numeric)),
       if (true, 0.92, @test_param_numeric),
       if (true, cast(0.93 as double), @test_param_numeric),
       if (true, @test_param_double, @test_param_numeric),
       if (true, 0.93 * 0.93, @test_param_numeric)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [NUMERIC]
| +-$query.$col2#2 AS `$col2` [DOUBLE]
| +-$query.$col3#3 AS `$col3` [DOUBLE]
| +-$query.$col4#4 AS `$col4` [DOUBLE]
| +-$query.$col5#5 AS `$col5` [DOUBLE]
| +-$query.$col6#6 AS `$col6` [NUMERIC]
| +-$query.$col7#7 AS `$col7` [DOUBLE]
| +-$query.$col8#8 AS `$col8` [DOUBLE]
| +-$query.$col9#9 AS `$col9` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6, $col7#7, $col8#8, $col9#9]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, NUMERIC, NUMERIC) -> NUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=NUMERIC, value=0.93)
    | |   +-Literal(type=NUMERIC, value=0.94, has_explicit_type=TRUE)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Parameter(type=DOUBLE, name="test_param_double")
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col4#4 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
    | |   | +-Literal(type=DOUBLE, value=0.93, float_literal_id=3)
    | |   | +-Literal(type=DOUBLE, value=0.93, float_literal_id=4)
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col5#5 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col6#6 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, NUMERIC, NUMERIC) -> NUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=NUMERIC, value=0.92)
    | |   +-Parameter(type=NUMERIC, name="test_param_numeric")
    | +-$col7#7 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | |   +-Cast(NUMERIC -> DOUBLE)
    | |     +-Parameter(type=NUMERIC, name="test_param_numeric")
    | +-$col8#8 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Parameter(type=DOUBLE, name="test_param_double")
    | |   +-Cast(NUMERIC -> DOUBLE)
    | |     +-Parameter(type=NUMERIC, name="test_param_numeric")
    | +-$col9#9 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    |     +-Literal(type=BOOL, value=true)
    |     +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
    |     | +-Literal(type=DOUBLE, value=0.93, float_literal_id=9)
    |     | +-Literal(type=DOUBLE, value=0.93, float_literal_id=10)
    |     +-Cast(NUMERIC -> DOUBLE)
    |       +-Parameter(type=NUMERIC, name="test_param_numeric")
    +-input_scan=
      +-SingleRowScan
==

[language_features=NUMERIC_TYPE]
SELECT if (true, numeric_col, 0.93),
       if (true, numeric_col, cast(0.93 as double)),
       if (true, numeric_col, @test_param_double)
FROM NumericTypeTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [NUMERIC]
| +-$query.$col2#3 AS `$col2` [DOUBLE]
| +-$query.$col3#4 AS `$col3` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#2, $col2#3, $col3#4]
    +-expr_list=
    | +-$col1#2 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, NUMERIC, NUMERIC) -> NUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#1)
    | |   +-Literal(type=NUMERIC, value=0.93)
    | +-$col2#3 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Cast(NUMERIC -> DOUBLE)
    | |   | +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#1)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | +-$col3#4 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    |     +-Literal(type=BOOL, value=true)
    |     +-Cast(NUMERIC -> DOUBLE)
    |     | +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#1)
    |     +-Parameter(type=DOUBLE, name="test_param_double")
    +-input_scan=
      +-TableScan(column_list=[NumericTypeTable.numeric_col#1], table=NumericTypeTable, column_index_list=[0])
==

[language_features=NUMERIC_TYPE]
SELECT `int64` x FROM SimpleTypes
UNION ALL
SELECT numeric_col x FROM NumericTypeTable
UNION ALL
SELECT 0.93 x
--
QueryStmt
+-output_column_list=
| +-$union_all.x#22 AS x [NUMERIC]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#22]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#23]
      | |   +-expr_list=
      | |   | +-int64#23 :=
      | |   |   +-Cast(INT64 -> NUMERIC)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#23]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[NumericTypeTable.numeric_col#20]
      | |   +-input_scan=
      | |     +-TableScan(column_list=[NumericTypeTable.numeric_col#20], table=NumericTypeTable, column_index_list=[0])
      | +-output_column_list=[NumericTypeTable.numeric_col#20]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3_cast.x#24]
        |   +-expr_list=
        |   | +-x#24 := Literal(type=NUMERIC, value=0.93)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$union_all3.x#21]
        |       +-expr_list=
        |       | +-x#21 := Literal(type=DOUBLE, value=0.93, float_literal_id=1)
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$union_all3_cast.x#24]
==

[language_features=NUMERIC_TYPE]
SELECT `int64` x FROM SimpleTypes
UNION ALL
SELECT numeric_col x FROM NumericTypeTable
UNION ALL
SELECT CAST(0.93 AS DOUBLE) x
--
QueryStmt
+-output_column_list=
| +-$union_all.x#22 AS x [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#22]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#23]
      | |   +-expr_list=
      | |   | +-int64#23 :=
      | |   |   +-Cast(INT64 -> DOUBLE)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#23]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.numeric_col#24]
      | |   +-expr_list=
      | |   | +-numeric_col#24 :=
      | |   |   +-Cast(NUMERIC -> DOUBLE)
      | |   |     +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#20)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[NumericTypeTable.numeric_col#20]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[NumericTypeTable.numeric_col#20], table=NumericTypeTable, column_index_list=[0])
      | +-output_column_list=[$union_all2_cast.numeric_col#24]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3.x#21]
        |   +-expr_list=
        |   | +-x#21 := Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=[$union_all3.x#21]
==

[language_features=NUMERIC_TYPE]
SELECT `int64` x FROM SimpleTypes
UNION ALL
SELECT NUMERIC '1.23' x
UNION ALL
SELECT CAST(0.93 AS DOUBLE) x
--
QueryStmt
+-output_column_list=
| +-$union_all.x#22 AS x [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#22]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#23]
      | |   +-expr_list=
      | |   | +-int64#23 :=
      | |   |   +-Cast(INT64 -> DOUBLE)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#23]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.x#24]
      | |   +-expr_list=
      | |   | +-x#24 := Literal(type=DOUBLE, value=1.23, has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$union_all2.x#20]
      | |       +-expr_list=
      | |       | +-x#20 := Literal(type=NUMERIC, value=1.23, has_explicit_type=TRUE)
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$union_all2_cast.x#24]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3.x#21]
        |   +-expr_list=
        |   | +-x#21 := Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=[$union_all3.x#21]
==

# This test demonstrates that a direct cast of a floating point literal into a
# NUMERIC does not lose precision.
[language_features=NUMERIC_TYPE]
SELECT cast(99999999999999999999999999999.999999999 as NUMERIC),
       cast(-99999999999999999999999999999.999999999 as NUMERIC),
       cast(cast("99999999999999999999999999999.999999999" as DOUBLE) as NUMERIC),
       cast(cast("-99999999999999999999999999999.999999999" as DOUBLE) as NUMERIC),
       cast(x as NUMERIC)
FROM (SELECT 99999999999999999999999999999.999999999 x)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [NUMERIC]
| +-$query.$col2#3 AS `$col2` [NUMERIC]
| +-$query.$col3#4 AS `$col3` [NUMERIC]
| +-$query.$col4#5 AS `$col4` [NUMERIC]
| +-$query.$col5#6 AS `$col5` [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#2, $col2#3, $col3#4, $col4#5, $col5#6]
    +-expr_list=
    | +-$col1#2 := Literal(type=NUMERIC, value=99999999999999999999999999999.999999999, has_explicit_type=TRUE)
    | +-$col2#3 := Literal(type=NUMERIC, value=-99999999999999999999999999999.999999999, has_explicit_type=TRUE)
    | +-$col3#4 := Literal(type=NUMERIC, value=99999999999999991433150857216, has_explicit_type=TRUE)
    | +-$col4#5 := Literal(type=NUMERIC, value=-99999999999999991433150857216, has_explicit_type=TRUE)
    | +-$col5#6 :=
    |   +-Cast(DOUBLE -> NUMERIC)
    |     +-ColumnRef(type=DOUBLE, column=$subquery1.x#1)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$subquery1.x#1]
        +-expr_list=
        | +-x#1 := Literal(type=DOUBLE, value=1e+29, float_literal_id=1)
        +-input_scan=
          +-SingleRowScan
==

[language_features=NUMERIC_TYPE]
SELECT cast(123.12 as NUMERIC),
       cast(.456 as NUMERIC),
       cast(678. as NUMERIC),
       cast(-34.789 as NUMERIC),
       cast(1.1e5 as NUMERIC),
       cast(-2.2e-2 as NUMERIC),
       cast(0.0 as NUMERIC),
       cast(.1e10 as NUMERIC),
       cast(3.e10 as NUMERIC),
       cast(.4e-3 as NUMERIC),
       cast(-.5 as NUMERIC)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [NUMERIC]
| +-$query.$col2#2 AS `$col2` [NUMERIC]
| +-$query.$col3#3 AS `$col3` [NUMERIC]
| +-$query.$col4#4 AS `$col4` [NUMERIC]
| +-$query.$col5#5 AS `$col5` [NUMERIC]
| +-$query.$col6#6 AS `$col6` [NUMERIC]
| +-$query.$col7#7 AS `$col7` [NUMERIC]
| +-$query.$col8#8 AS `$col8` [NUMERIC]
| +-$query.$col9#9 AS `$col9` [NUMERIC]
| +-$query.$col10#10 AS `$col10` [NUMERIC]
| +-$query.$col11#11 AS `$col11` [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6, $col7#7, $col8#8, $col9#9, $col10#10, $col11#11]
    +-expr_list=
    | +-$col1#1 := Literal(type=NUMERIC, value=123.12, has_explicit_type=TRUE)
    | +-$col2#2 := Literal(type=NUMERIC, value=0.456, has_explicit_type=TRUE)
    | +-$col3#3 := Literal(type=NUMERIC, value=678, has_explicit_type=TRUE)
    | +-$col4#4 := Literal(type=NUMERIC, value=-34.789, has_explicit_type=TRUE)
    | +-$col5#5 := Literal(type=NUMERIC, value=110000, has_explicit_type=TRUE)
    | +-$col6#6 := Literal(type=NUMERIC, value=-0.022, has_explicit_type=TRUE)
    | +-$col7#7 := Literal(type=NUMERIC, value=0, has_explicit_type=TRUE)
    | +-$col8#8 := Literal(type=NUMERIC, value=1000000000, has_explicit_type=TRUE)
    | +-$col9#9 := Literal(type=NUMERIC, value=30000000000, has_explicit_type=TRUE)
    | +-$col10#10 := Literal(type=NUMERIC, value=0.0004, has_explicit_type=TRUE)
    | +-$col11#11 := Literal(type=NUMERIC, value=-0.5, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# BIGNUMERIC type coercion tests
[language_features=BIGNUMERIC_TYPE]
SELECT if (true, 0.93, BIGNUMERIC '0.94'),
       if (true, cast(0.93 as double), BIGNUMERIC '0.94'),
       if (true, @test_param_double, BIGNUMERIC '0.94'),
       if (true, 0.93 * 0.93, BIGNUMERIC '0.94'),
       if (true, cast(0.93 as double), cast(0.94 as BIGNUMERIC)),
       if (true, 0.92, @test_param_bignumeric),
       if (true, cast(0.93 as double), @test_param_bignumeric),
       if (true, @test_param_double, @test_param_bignumeric),
       if (true, 0.93 * 0.93, @test_param_bignumeric)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BIGNUMERIC]
| +-$query.$col2#2 AS `$col2` [DOUBLE]
| +-$query.$col3#3 AS `$col3` [DOUBLE]
| +-$query.$col4#4 AS `$col4` [DOUBLE]
| +-$query.$col5#5 AS `$col5` [DOUBLE]
| +-$query.$col6#6 AS `$col6` [BIGNUMERIC]
| +-$query.$col7#7 AS `$col7` [DOUBLE]
| +-$query.$col8#8 AS `$col8` [DOUBLE]
| +-$query.$col9#9 AS `$col9` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6, $col7#7, $col8#8, $col9#9]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.93)
    | |   +-Literal(type=BIGNUMERIC, value=0.94, has_explicit_type=TRUE)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Parameter(type=DOUBLE, name="test_param_double")
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col4#4 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
    | |   | +-Literal(type=DOUBLE, value=0.93, float_literal_id=3)
    | |   | +-Literal(type=DOUBLE, value=0.93, float_literal_id=4)
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col5#5 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col6#6 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.92)
    | |   +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    | +-$col7#7 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | |   +-Cast(BIGNUMERIC -> DOUBLE)
    | |     +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    | +-$col8#8 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Parameter(type=DOUBLE, name="test_param_double")
    | |   +-Cast(BIGNUMERIC -> DOUBLE)
    | |     +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    | +-$col9#9 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    |     +-Literal(type=BOOL, value=true)
    |     +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
    |     | +-Literal(type=DOUBLE, value=0.93, float_literal_id=9)
    |     | +-Literal(type=DOUBLE, value=0.93, float_literal_id=10)
    |     +-Cast(BIGNUMERIC -> DOUBLE)
    |       +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    +-input_scan=
      +-SingleRowScan
==

[language_features=BIGNUMERIC_TYPE,NUMERIC_TYPE]
SELECT if (true, NUMERIC '0.93', BIGNUMERIC '0.94'),
       if (true, cast(0.93 as NUMERIC), BIGNUMERIC '0.94'),
       if (true, @test_param_numeric, BIGNUMERIC '0.94'),
       if (true, cast(0.93 as NUMERIC), cast(0.94 as BIGNUMERIC)),
       if (true, NUMERIC '0.93', @test_param_bignumeric),
       if (true, cast(0.93 as NUMERIC), @test_param_bignumeric),
       if (true, @test_param_numeric, @test_param_bignumeric)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BIGNUMERIC]
| +-$query.$col2#2 AS `$col2` [BIGNUMERIC]
| +-$query.$col3#3 AS `$col3` [BIGNUMERIC]
| +-$query.$col4#4 AS `$col4` [BIGNUMERIC]
| +-$query.$col5#5 AS `$col5` [BIGNUMERIC]
| +-$query.$col6#6 AS `$col6` [BIGNUMERIC]
| +-$query.$col7#7 AS `$col7` [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6, $col7#7]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=BIGNUMERIC, value=0.94, has_explicit_type=TRUE)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=BIGNUMERIC, value=0.94, has_explicit_type=TRUE)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Cast(NUMERIC -> BIGNUMERIC)
    | |   | +-Parameter(type=NUMERIC, name="test_param_numeric")
    | |   +-Literal(type=BIGNUMERIC, value=0.94, has_explicit_type=TRUE)
    | +-$col4#4 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=BIGNUMERIC, value=0.94, has_explicit_type=TRUE)
    | +-$col5#5 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | |   +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    | +-$col6#6 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | |   +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    | +-$col7#7 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    |     +-Literal(type=BOOL, value=true)
    |     +-Cast(NUMERIC -> BIGNUMERIC)
    |     | +-Parameter(type=NUMERIC, name="test_param_numeric")
    |     +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    +-input_scan=
      +-SingleRowScan
==

[language_features=BIGNUMERIC_TYPE]
SELECT if (true, bignumeric_col, 0.93),
       if (true, bignumeric_col, cast(0.93 as double)),
       if (true, bignumeric_col, @test_param_double)
FROM BigNumericTypeTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [BIGNUMERIC]
| +-$query.$col2#3 AS `$col2` [DOUBLE]
| +-$query.$col3#4 AS `$col3` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#2, $col2#3, $col3#4]
    +-expr_list=
    | +-$col1#2 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=BIGNUMERIC, column=BigNumericTypeTable.bignumeric_col#1)
    | |   +-Literal(type=BIGNUMERIC, value=0.93)
    | +-$col2#3 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Cast(BIGNUMERIC -> DOUBLE)
    | |   | +-ColumnRef(type=BIGNUMERIC, column=BigNumericTypeTable.bignumeric_col#1)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | +-$col3#4 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    |     +-Literal(type=BOOL, value=true)
    |     +-Cast(BIGNUMERIC -> DOUBLE)
    |     | +-ColumnRef(type=BIGNUMERIC, column=BigNumericTypeTable.bignumeric_col#1)
    |     +-Parameter(type=DOUBLE, name="test_param_double")
    +-input_scan=
      +-TableScan(column_list=[BigNumericTypeTable.bignumeric_col#1], table=BigNumericTypeTable, column_index_list=[0])
==

[language_features=BIGNUMERIC_TYPE,NUMERIC_TYPE]
SELECT if (true, numeric_col, BIGNUMERIC '0.93'),
       if (true, numeric_col, cast(0.93 as BIGNUMERIC)),
       if (true, numeric_col, @test_param_bignumeric)
FROM NumericTypeTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [BIGNUMERIC]
| +-$query.$col2#3 AS `$col2` [BIGNUMERIC]
| +-$query.$col3#4 AS `$col3` [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#2, $col2#3, $col3#4]
    +-expr_list=
    | +-$col1#2 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Cast(NUMERIC -> BIGNUMERIC)
    | |   | +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#1)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | +-$col2#3 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Cast(NUMERIC -> BIGNUMERIC)
    | |   | +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#1)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | +-$col3#4 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    |     +-Literal(type=BOOL, value=true)
    |     +-Cast(NUMERIC -> BIGNUMERIC)
    |     | +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#1)
    |     +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    +-input_scan=
      +-TableScan(column_list=[NumericTypeTable.numeric_col#1], table=NumericTypeTable, column_index_list=[0])
==

[language_features=BIGNUMERIC_TYPE]
SELECT `int64` x FROM SimpleTypes
UNION ALL
SELECT bignumeric_col x FROM BigNumericTypeTable
UNION ALL
SELECT 0.93 x
--
QueryStmt
+-output_column_list=
| +-$union_all.x#22 AS x [BIGNUMERIC]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#22]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#23]
      | |   +-expr_list=
      | |   | +-int64#23 :=
      | |   |   +-Cast(INT64 -> BIGNUMERIC)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#23]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[BigNumericTypeTable.bignumeric_col#20]
      | |   +-input_scan=
      | |     +-TableScan(column_list=[BigNumericTypeTable.bignumeric_col#20], table=BigNumericTypeTable, column_index_list=[0])
      | +-output_column_list=[BigNumericTypeTable.bignumeric_col#20]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3_cast.x#24]
        |   +-expr_list=
        |   | +-x#24 := Literal(type=BIGNUMERIC, value=0.93)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$union_all3.x#21]
        |       +-expr_list=
        |       | +-x#21 := Literal(type=DOUBLE, value=0.93, float_literal_id=1)
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$union_all3_cast.x#24]
==

[language_features=BIGNUMERIC_TYPE]
SELECT `int64` x FROM SimpleTypes
UNION ALL
SELECT bignumeric_col x FROM BigNumericTypeTable
UNION ALL
SELECT CAST(0.93 AS DOUBLE) x
--
QueryStmt
+-output_column_list=
| +-$union_all.x#22 AS x [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#22]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#23]
      | |   +-expr_list=
      | |   | +-int64#23 :=
      | |   |   +-Cast(INT64 -> DOUBLE)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#23]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.bignumeric_col#24]
      | |   +-expr_list=
      | |   | +-bignumeric_col#24 :=
      | |   |   +-Cast(BIGNUMERIC -> DOUBLE)
      | |   |     +-ColumnRef(type=BIGNUMERIC, column=BigNumericTypeTable.bignumeric_col#20)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[BigNumericTypeTable.bignumeric_col#20]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[BigNumericTypeTable.bignumeric_col#20], table=BigNumericTypeTable, column_index_list=[0])
      | +-output_column_list=[$union_all2_cast.bignumeric_col#24]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3.x#21]
        |   +-expr_list=
        |   | +-x#21 := Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=[$union_all3.x#21]
==

[language_features=BIGNUMERIC_TYPE]
SELECT `int64` x FROM SimpleTypes
UNION ALL
SELECT BIGNUMERIC '1.23' x
UNION ALL
SELECT CAST(0.93 AS DOUBLE) x
--
QueryStmt
+-output_column_list=
| +-$union_all.x#22 AS x [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#22]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#23]
      | |   +-expr_list=
      | |   | +-int64#23 :=
      | |   |   +-Cast(INT64 -> DOUBLE)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#23]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.x#24]
      | |   +-expr_list=
      | |   | +-x#24 := Literal(type=DOUBLE, value=1.23, has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$union_all2.x#20]
      | |       +-expr_list=
      | |       | +-x#20 := Literal(type=BIGNUMERIC, value=1.23, has_explicit_type=TRUE)
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$union_all2_cast.x#24]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3.x#21]
        |   +-expr_list=
        |   | +-x#21 := Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=[$union_all3.x#21]
==

[language_features=BIGNUMERIC_TYPE,NUMERIC_TYPE]
SELECT `int64` x FROM SimpleTypes
UNION ALL
SELECT numeric_col x FROM NumericTypeTable
UNION ALL
SELECT BIGNUMERIC '0.93'
--
QueryStmt
+-output_column_list=
| +-$union_all.x#22 AS x [BIGNUMERIC]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#22]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#23]
      | |   +-expr_list=
      | |   | +-int64#23 :=
      | |   |   +-Cast(INT64 -> BIGNUMERIC)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#23]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.numeric_col#24]
      | |   +-expr_list=
      | |   | +-numeric_col#24 :=
      | |   |   +-Cast(NUMERIC -> BIGNUMERIC)
      | |   |     +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#20)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[NumericTypeTable.numeric_col#20]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[NumericTypeTable.numeric_col#20], table=NumericTypeTable, column_index_list=[0])
      | +-output_column_list=[$union_all2_cast.numeric_col#24]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3.$col1#21]
        |   +-expr_list=
        |   | +-$col1#21 := Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=[$union_all3.$col1#21]
==

# This test demonstrates that a direct cast of a floating point literal into a
# NUMERIC does not lose precision.
[language_features=BIGNUMERIC_TYPE]
SELECT cast(578960446186580977117854925043439539266.34992332820282019728792003956564819967 as BIGNUMERIC),
       cast(-578960446186580977117854925043439539266.34992332820282019728792003956564819968 as BIGNUMERIC),
       cast(cast("578960446186580977117854925043439539266.34992332820282019728792003956564819967" as DOUBLE) as BIGNUMERIC),
       cast(cast("-578960446186580977117854925043439539266.34992332820282019728792003956564819968" as DOUBLE) as BIGNUMERIC),
       cast(x as BIGNUMERIC)
FROM (SELECT 578960446186580977117854925043439539266.34992332820282019728792003956564819967 x)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [BIGNUMERIC]
| +-$query.$col2#3 AS `$col2` [BIGNUMERIC]
| +-$query.$col3#4 AS `$col3` [BIGNUMERIC]
| +-$query.$col4#5 AS `$col4` [BIGNUMERIC]
| +-$query.$col5#6 AS `$col5` [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#2, $col2#3, $col3#4, $col4#5, $col5#6]
    +-expr_list=
    | +-$col1#2 := Literal(type=BIGNUMERIC, value=578960446186580977117854925043439539266.34992332820282019728792003956564819967, has_explicit_type=TRUE)
    | +-$col2#3 := Literal(type=BIGNUMERIC, value=-578960446186580977117854925043439539266.34992332820282019728792003956564819968, has_explicit_type=TRUE)
    | +-$col3#4 := Literal(type=BIGNUMERIC, value=578960446186580955070694765308237840384, has_explicit_type=TRUE)
    | +-$col4#5 := Literal(type=BIGNUMERIC, value=-578960446186580955070694765308237840384, has_explicit_type=TRUE)
    | +-$col5#6 :=
    |   +-Cast(DOUBLE -> BIGNUMERIC)
    |     +-ColumnRef(type=DOUBLE, column=$subquery1.x#1)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$subquery1.x#1]
        +-expr_list=
        | +-x#1 := Literal(type=DOUBLE, value=5.7896044618658096e+38, float_literal_id=1)
        +-input_scan=
          +-SingleRowScan
==

[language_features=BIGNUMERIC_TYPE]
SELECT cast(123.12 as BIGNUMERIC),
       cast(.456 as BIGNUMERIC),
       cast(678. as BIGNUMERIC),
       cast(-34.789 as BIGNUMERIC),
       cast(1.1e5 as BIGNUMERIC),
       cast(-2.2e-2 as BIGNUMERIC),
       cast(0.0 as BIGNUMERIC),
       cast(.1e10 as BIGNUMERIC),
       cast(3.e10 as BIGNUMERIC),
       cast(.4e-3 as BIGNUMERIC),
       cast(-.5 as BIGNUMERIC)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BIGNUMERIC]
| +-$query.$col2#2 AS `$col2` [BIGNUMERIC]
| +-$query.$col3#3 AS `$col3` [BIGNUMERIC]
| +-$query.$col4#4 AS `$col4` [BIGNUMERIC]
| +-$query.$col5#5 AS `$col5` [BIGNUMERIC]
| +-$query.$col6#6 AS `$col6` [BIGNUMERIC]
| +-$query.$col7#7 AS `$col7` [BIGNUMERIC]
| +-$query.$col8#8 AS `$col8` [BIGNUMERIC]
| +-$query.$col9#9 AS `$col9` [BIGNUMERIC]
| +-$query.$col10#10 AS `$col10` [BIGNUMERIC]
| +-$query.$col11#11 AS `$col11` [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6, $col7#7, $col8#8, $col9#9, $col10#10, $col11#11]
    +-expr_list=
    | +-$col1#1 := Literal(type=BIGNUMERIC, value=123.12, has_explicit_type=TRUE)
    | +-$col2#2 := Literal(type=BIGNUMERIC, value=0.456, has_explicit_type=TRUE)
    | +-$col3#3 := Literal(type=BIGNUMERIC, value=678, has_explicit_type=TRUE)
    | +-$col4#4 := Literal(type=BIGNUMERIC, value=-34.789, has_explicit_type=TRUE)
    | +-$col5#5 := Literal(type=BIGNUMERIC, value=110000, has_explicit_type=TRUE)
    | +-$col6#6 := Literal(type=BIGNUMERIC, value=-0.022, has_explicit_type=TRUE)
    | +-$col7#7 := Literal(type=BIGNUMERIC, value=0, has_explicit_type=TRUE)
    | +-$col8#8 := Literal(type=BIGNUMERIC, value=1000000000, has_explicit_type=TRUE)
    | +-$col9#9 := Literal(type=BIGNUMERIC, value=30000000000, has_explicit_type=TRUE)
    | +-$col10#10 := Literal(type=BIGNUMERIC, value=0.0004, has_explicit_type=TRUE)
    | +-$col11#11 := Literal(type=BIGNUMERIC, value=-0.5, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select fn_on_int32_array_returns_int32(NULL)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_int32_array_returns_int32(ARRAY<INT32>) -> INT32)
    |     +-Literal(type=ARRAY<INT32>, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

# Implicit coercion of non-empty array literals is now supported. (Implicit
# coercion of empty array literals was always supported.)
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select [],
       [1, 2, 3],
       fn_on_int32_array_returns_int32([]),
       fn_on_int32_array_returns_int32([1, 2, 3])
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<INT64>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 4:8]
       fn_on_int32_array_returns_int32([1, 2, 3])
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32
  Argument types: ARRAY<INT64>
  Signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>)
    Argument 1: Unable to coerce type ARRAY<INT64> to expected type ARRAY<INT32> [at 4:8]
       fn_on_int32_array_returns_int32([1, 2, 3])
       ^
--
ALTERNATION GROUP: V_1_1_CAST_DIFFERENT_ARRAY_TYPES
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<INT64>]
| +-$query.$col2#2 AS `$col2` [ARRAY<INT64>]
| +-$query.$col3#3 AS `$col3` [INT32]
| +-$query.$col4#4 AS `$col4` [INT32]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4]
    +-expr_list=
    | +-$col1#1 := Literal(type=ARRAY<INT64>, value=[])
    | +-$col2#2 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    | +-$col3#3 :=
    | | +-FunctionCall(sample_functions:fn_on_int32_array_returns_int32(ARRAY<INT32>) -> INT32)
    | |   +-Literal(type=ARRAY<INT32>, value=[])
    | +-$col4#4 :=
    |   +-FunctionCall(sample_functions:fn_on_int32_array_returns_int32(ARRAY<INT32>) -> INT32)
    |     +-Literal(type=ARRAY<INT32>, value=[1, 2, 3])
    +-input_scan=
      +-SingleRowScan
==

# Of course, we don't allow implicit coercion of array literals with elements
# that are out of range for the destination element type.
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select fn_on_int32_array_returns_int32([1152921504606846976])
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<INT64>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 1:8]
select fn_on_int32_array_returns_int32([1152921504606846976])
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32
  Argument types: ARRAY<INT64>
  Signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>)
    Argument 1: Unable to coerce type ARRAY<INT64> to expected type ARRAY<INT32> [at 1:8]
select fn_on_int32_array_returns_int32([1152921504606846976])
       ^
--
ALTERNATION GROUP: V_1_1_CAST_DIFFERENT_ARRAY_TYPES
--
ERROR: Could not cast literal [1152921504606846976] to type ARRAY<INT32> [at 1:40]
select fn_on_int32_array_returns_int32([1152921504606846976])
                                       ^
==

# Due to runtime performance concerns, we don't support implicit coercion of
# array non-literals.
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select fn_on_int32_array_returns_int32(
         {{Int64Array|array_concat(Int64Array, Int64Array)}})
from ArrayTypes
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<INT64>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 1:8]
select fn_on_int32_array_returns_int32(
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32
  Argument types: ARRAY<INT64>
  Signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>)
    Argument 1: Unable to coerce type ARRAY<INT64> to expected type ARRAY<INT32> [at 1:8]
select fn_on_int32_array_returns_int32(
       ^
==

# For consistency with general expressions, we don't support implicit coercion
# of explicitly typed array literals either.
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select fn_on_int32_array_returns_int32(ARRAY<INT64>{{[1, 2, 3]|[]}})
--
ALTERNATION GROUPS:
    [1, 2, 3]
    V_1_1_CAST_DIFFERENT_ARRAY_TYPES,[1, 2, 3]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<INT64>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 1:8]
select fn_on_int32_array_returns_int32(ARRAY<INT64>[1, 2, 3])
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32
  Argument types: ARRAY<INT64>
  Signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>)
    Argument 1: Unable to coerce type ARRAY<INT64> to expected type ARRAY<INT32> [at 1:8]
select fn_on_int32_array_returns_int32(ARRAY<INT64>[1, 2, 3])
       ^
--
ALTERNATION GROUPS:
    []
    V_1_1_CAST_DIFFERENT_ARRAY_TYPES,[]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<INT64>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 1:8]
select fn_on_int32_array_returns_int32(ARRAY<INT64>[])
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32
  Argument types: ARRAY<INT64>
  Signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>)
    Argument 1: Unable to coerce type ARRAY<INT64> to expected type ARRAY<INT32> [at 1:8]
select fn_on_int32_array_returns_int32(ARRAY<INT64>[])
       ^
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
[product_mode=internal]
# Integers should coerce to opaque enums - it's not likely to
# be used much in practice, but it is part of the spec.  However
# this should _not_ be the case for product mode external, which
# doesn't have access to the underlying proto to determine the
# meaning of the integer.
#
SELECT ROUND(NUMERIC "1", 1, 1);
--

QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:round(NUMERIC, INT64, ENUM<ROUNDING_MODE>) -> NUMERIC)
    |     +-Literal(type=NUMERIC, value=1, has_explicit_type=TRUE)
    |     +-Literal(type=INT64, value=1)
    |     +-Literal(type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_AWAY_FROM_ZERO)
    +-input_scan=
      +-SingleRowScan
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE,V_1_4_DISABLE_FLOAT32]
[product_mode=external]

SELECT ROUND(NUMERIC "1", 1, 1);
--
ERROR: No matching signature for function ROUND for argument types: NUMERIC, INT64, INT64. Supported signatures: ROUND(FLOAT64); ROUND(NUMERIC); ROUND(FLOAT64, INT64); ROUND(NUMERIC, INT64); ROUND(NUMERIC, INT64, ROUNDING_MODE) [at 1:8]
SELECT ROUND(NUMERIC "1", 1, 1);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function ROUND
  Argument types: NUMERIC, INT64, INT64
  Signature: ROUND(FLOAT64)
    Signature accepts at most 1 argument, found 3 arguments
  Signature: ROUND(NUMERIC)
    Signature accepts at most 1 argument, found 3 arguments
  Signature: ROUND(FLOAT64, INT64)
    Signature accepts at most 2 arguments, found 3 arguments
  Signature: ROUND(NUMERIC, INT64)
    Signature accepts at most 2 arguments, found 3 arguments
  Signature: ROUND(NUMERIC, INT64, ROUNDING_MODE)
    Argument 3: Unable to coerce type INT64 to expected type ROUNDING_MODE [at 1:8]
SELECT ROUND(NUMERIC "1", 1, 1);
       ^
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
[product_mode=external]

SELECT ROUND(NUMERIC "1", 1, 1);
--
ERROR: No matching signature for function ROUND for argument types: NUMERIC, INT64, INT64. Supported signatures: ROUND(FLOAT); ROUND(FLOAT64); ROUND(NUMERIC); ROUND(FLOAT, INT64); ROUND(FLOAT64, INT64); ROUND(NUMERIC, INT64); ROUND(NUMERIC, INT64, ROUNDING_MODE) [at 1:8]
SELECT ROUND(NUMERIC "1", 1, 1);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function ROUND
  Argument types: NUMERIC, INT64, INT64
  Signature: ROUND(FLOAT)
    Signature accepts at most 1 argument, found 3 arguments
  Signature: ROUND(FLOAT64)
    Signature accepts at most 1 argument, found 3 arguments
  Signature: ROUND(NUMERIC)
    Signature accepts at most 1 argument, found 3 arguments
  Signature: ROUND(FLOAT, INT64)
    Signature accepts at most 2 arguments, found 3 arguments
  Signature: ROUND(FLOAT64, INT64)
    Signature accepts at most 2 arguments, found 3 arguments
  Signature: ROUND(NUMERIC, INT64)
    Signature accepts at most 2 arguments, found 3 arguments
  Signature: ROUND(NUMERIC, INT64, ROUNDING_MODE)
    Argument 3: Unable to coerce type INT64 to expected type ROUNDING_MODE [at 1:8]
SELECT ROUND(NUMERIC "1", 1, 1);
       ^
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
[product_mode={{internal|external}}]
select 1 = CAST(1 as ROUNDING_MODE),
       'ROUND_HALF_EVEN' = CAST(1 as ROUNDING_MODE)
--
ALTERNATION GROUP: internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
| +-$query.$col2#2 AS `$col2` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:$equal(ENUM<ROUNDING_MODE>, ENUM<ROUNDING_MODE>) -> BOOL)
    | |   +-Literal(type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_AWAY_FROM_ZERO)
    | |   +-Cast(INT64 -> ENUM<ROUNDING_MODE>)
    | |     +-Literal(type=INT64, value=1)
    | +-$col2#2 :=
    |   +-FunctionCall(ZetaSQL:$equal(ENUM<ROUNDING_MODE>, ENUM<ROUNDING_MODE>) -> BOOL)
    |     +-Literal(type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_EVEN)
    |     +-Cast(INT64 -> ENUM<ROUNDING_MODE>)
    |       +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: external
--
ERROR: Type not found: ROUNDING_MODE [at 1:22]
select 1 = CAST(1 as ROUNDING_MODE),
                     ^
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
[product_mode={{internal|external}}]
[no_java]
# TODO: Fix java
select STRUCT( nested_catalog.constant_rounding_mode) = struct(1)
--
ALTERNATION GROUP: internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$equal(STRUCT<constant_rounding_mode ENUM<ROUNDING_MODE>>, STRUCT<constant_rounding_mode ENUM<ROUNDING_MODE>>) -> BOOL)
    |     +-MakeStruct
    |     | +-type=STRUCT<constant_rounding_mode ENUM<ROUNDING_MODE>>
    |     | +-field_list=
    |     |   +-Constant(nested_catalog.constant_rounding_mode, type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_EVEN)
    |     +-Literal(type=STRUCT<constant_rounding_mode ENUM<ROUNDING_MODE>>, value={constant_rounding_mode:ROUND_HALF_AWAY_FROM_ZERO})
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: external
--
ERROR: No matching signature for operator = for argument types: STRUCT<constant_rounding_mode ROUNDING_MODE>, STRUCT<INT64>. Supported signature: ANY = ANY [at 2:8]
select STRUCT( nested_catalog.constant_rounding_mode) = struct(1)
       ^

--
Signature Mismatch Details:
ERROR: No matching signature for operator = for argument types: STRUCT<constant_rounding_mode ROUNDING_MODE>, STRUCT<INT64>
  Signature: T1 = T1
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {STRUCT<constant_rounding_mode ROUNDING_MODE>, STRUCT<INT64>} [at 2:8]
select STRUCT( nested_catalog.constant_rounding_mode) = struct(1)
       ^
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
[product_mode={{internal|external}}]
[no_java]
# TODO: Fix java
select nested_catalog.constant_rounding_mode in (1, 2)
--
ALTERNATION GROUP: internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in(ENUM<ROUNDING_MODE>, repeated(2) ENUM<ROUNDING_MODE>) -> BOOL)
    |     +-Constant(nested_catalog.constant_rounding_mode, type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_EVEN)
    |     +-Literal(type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_AWAY_FROM_ZERO)
    |     +-Literal(type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_EVEN)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: external
--
ERROR: No matching signature for operator IN for argument types ENUM<ROUNDING_MODE> and {INT64} [at 2:46]
select nested_catalog.constant_rounding_mode in (1, 2)
                                             ^

==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
# Types are not coercible with each other
select CAST(1 as `zetasql.functions.RoundingMode`) = CAST(1 as ROUNDING_MODE),
--
ERROR: No matching signature for operator = for argument types: zetasql.functions.RoundingMode, ROUNDING_MODE. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 2:8]
select CAST(1 as `zetasql.functions.RoundingMode`) = CAST(1 as ROUNDING_MODE),
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for operator = for argument types: zetasql.functions.RoundingMode, ROUNDING_MODE
  Signature: T1 = T1
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {ROUNDING_MODE, zetasql.functions.RoundingMode}
  Signature: INT64 = UINT64
    Argument 1: Unable to coerce type zetasql.functions.RoundingMode to expected type INT64
  Signature: UINT64 = INT64
    Argument 1: Unable to coerce type zetasql.functions.RoundingMode to expected type UINT64 [at 2:8]
select CAST(1 as `zetasql.functions.RoundingMode`) = CAST(1 as ROUNDING_MODE),
       ^
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
select CAST(1 as `zetasql.functions.RoundingMode`) = CAST(1 as ROUNDING_MODE)
--
ERROR: No matching signature for operator = for argument types: zetasql.functions.RoundingMode, ROUNDING_MODE. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64 [at 1:8]
select CAST(1 as `zetasql.functions.RoundingMode`) = CAST(1 as ROUNDING_MODE)
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for operator = for argument types: zetasql.functions.RoundingMode, ROUNDING_MODE
  Signature: T1 = T1
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {ROUNDING_MODE, zetasql.functions.RoundingMode}
  Signature: INT64 = UINT64
    Argument 1: Unable to coerce type zetasql.functions.RoundingMode to expected type INT64
  Signature: UINT64 = INT64
    Argument 1: Unable to coerce type zetasql.functions.RoundingMode to expected type UINT64 [at 1:8]
select CAST(1 as `zetasql.functions.RoundingMode`) = CAST(1 as ROUNDING_MODE)
       ^
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
# ROUNDING_MODE_UNSPECIFIED is marked invalid in ROUNDING_MODE (but not
# 'zetasql.functions.RoundingMode')
select 'ROUNDING_MODE_UNSPECIFIED' = CAST(1 as ROUNDING_MODE)
--
ERROR: Could not cast literal "ROUNDING_MODE_UNSPECIFIED" to type ROUNDING_MODE [at 3:8]
select 'ROUNDING_MODE_UNSPECIFIED' = CAST(1 as ROUNDING_MODE)
       ^
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
# 0 (ROUNDING_MODE_UNSPECIFIED) is marked invalid in ROUNDING_MODE.
select 0 = CAST(1 as ROUNDING_MODE)
--
ERROR: Could not cast literal 0 to type ROUNDING_MODE [at 2:8]
select 0 = CAST(1 as ROUNDING_MODE)
       ^
==

[language_features={{|V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
select bytes from SimpleTypes where bytes like '%abc%'
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: STRING LIKE STRING; BYTES LIKE BYTES [at 1:37]
select bytes from SimpleTypes where bytes like '%abc%'
                                    ^
--
Signature Mismatch Details:
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'
  Signature: STRING LIKE STRING
    Argument 1: Unable to coerce type BYTES to expected type STRING
  Signature: BYTES LIKE BYTES
    Argument 2: Unable to coerce type STRING to expected type BYTES [at 1:37]
select bytes from SimpleTypes where bytes like '%abc%'
                                    ^
--
ALTERNATION GROUP: V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES
--
QueryStmt
+-output_column_list=
| +-SimpleTypes.bytes#6 AS bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[SimpleTypes.bytes#6]
    +-input_scan=
      +-FilterScan
        +-column_list=[SimpleTypes.bytes#6]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.bytes#6], table=SimpleTypes, column_index_list=[5])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$like(BYTES, BYTES) -> BOOL)
            +-ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
            +-Literal(type=BYTES, value=b"%abc%")
==

[language_features=V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES]
select bytes from simpletypes where bytes like string;
--
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING. Supported signatures: STRING LIKE STRING; BYTES LIKE BYTES [at 1:37]
select bytes from simpletypes where bytes like string;
                                    ^
--
Signature Mismatch Details:
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING
  Signature: STRING LIKE STRING
    Argument 1: Unable to coerce type BYTES to expected type STRING
  Signature: BYTES LIKE BYTES
    Argument 2: Unable to coerce type STRING to expected type BYTES [at 1:37]
select bytes from simpletypes where bytes like string;
                                    ^
==

# The poop emoji is outside of the ASCII range [0, 127].
# Therefore, the implicit string -> bytes coercion does not succeed even though
# the language feature is enabled.
# Ideally, the error message here would be in line with other implicit casts,
# but we're not able to do this yet.
[language_features=V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES]
select bytes from SimpleTypes where bytes like '%\U0001F4A9%'
--
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'. Supported signatures: STRING LIKE STRING; BYTES LIKE BYTES [at 1:37]
select bytes from SimpleTypes where bytes like '%\U0001F4A9%'
                                    ^
--
Signature Mismatch Details:
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING. STRING and BYTES are different types that are not directly comparable. To write a BYTES literal, use a b-prefixed literal such as b'bytes value'
  Signature: STRING LIKE STRING
    Argument 1: Unable to coerce type BYTES to expected type STRING
  Signature: BYTES LIKE BYTES
    Argument 2: Unable to coerce type STRING to expected type BYTES [at 1:37]
select bytes from SimpleTypes where bytes like '%\U0001F4A9%'
                                    ^
==

[language_features={{|V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
select coalesce(b'abc', 'abc', NULL);
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for function COALESCE for argument types: BYTES, STRING, NULL. Supported signature: COALESCE([ANY, ...]) [at 1:8]
select coalesce(b'abc', 'abc', NULL);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function COALESCE
  Argument types: BYTES, STRING, NULL
  Signature: COALESCE([T1, ...])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {STRING, BYTES} [at 1:8]
select coalesce(b'abc', 'abc', NULL);
       ^
--
ALTERNATION GROUP: V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(3) BYTES) -> BYTES)
    |     +-Literal(type=BYTES, value=b"abc")
    |     +-Literal(type=BYTES, value=b"abc")
    |     +-Literal(type=BYTES, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

# coercion doesn't work for random expressions.
[language_features={{|V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
select bytes from SimpleTypes where bytes like CONCAT('a', 'b')
--
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING. Supported signatures: STRING LIKE STRING; BYTES LIKE BYTES [at 1:37]
select bytes from SimpleTypes where bytes like CONCAT('a', 'b')
                                    ^
--
Signature Mismatch Details:
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING
  Signature: STRING LIKE STRING
    Argument 1: Unable to coerce type BYTES to expected type STRING
  Signature: BYTES LIKE BYTES
    Argument 2: Unable to coerce type STRING to expected type BYTES [at 1:37]
select bytes from SimpleTypes where bytes like CONCAT('a', 'b')
                                    ^
==

# coercion doesn't work for string params.
[language_features={{|V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
select bytes from SimpleTypes where bytes like @test_param_string
--
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING. Supported signatures: STRING LIKE STRING; BYTES LIKE BYTES [at 1:37]
select bytes from SimpleTypes where bytes like @test_param_string
                                    ^
--
Signature Mismatch Details:
ERROR: No matching signature for operator LIKE for argument types: BYTES, STRING
  Signature: STRING LIKE STRING
    Argument 1: Unable to coerce type BYTES to expected type STRING
  Signature: BYTES LIKE BYTES
    Argument 2: Unable to coerce type STRING to expected type BYTES [at 1:37]
select bytes from SimpleTypes where bytes like @test_param_string
                                    ^
==

[language_features={{|V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
select fn_on_bytes('foo')
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_BYTES for argument types: STRING. Supported signature: FN_ON_BYTES(BYTES) [at 1:8]
select fn_on_bytes('foo')
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_BYTES
  Argument types: STRING
  Signature: FN_ON_BYTES(BYTES)
    Argument 1: Unable to coerce type STRING to expected type BYTES [at 1:8]
select fn_on_bytes('foo')
       ^
--
ALTERNATION GROUP: V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_bytes(BYTES) -> BOOL)
    |     +-Literal(type=BYTES, value=b"foo")
    +-input_scan=
      +-SingleRowScan
==

# STRING -> BYTES coercion should not affect overloaded functions with matching
# string signature.
[language_features={{|V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
select fn_overloaded_bytes_and_string('foo');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_overloaded_bytes_and_string(STRING) -> STRING)
    |     +-Literal(type=STRING, value="foo")
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
select fn_overloaded_bytes_and_string(b'foo');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_overloaded_bytes_and_string(BYTES) -> BYTES)
    |     +-Literal(type=BYTES, value=b"foo")
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
select fn_overloaded_bytes_and_date('2020-01-01');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_overloaded_bytes_and_date(DATE) -> BOOL)
    |     +-Literal(type=DATE, value=2020-01-01)
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
select fn_overloaded_bytes_and_timestamp('2020-01-01 15:30:00+00');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_overloaded_bytes_and_timestamp(TIMESTAMP) -> BOOL)
    |     +-Literal(type=TIMESTAMP, value=2020-01-01 15:30:00+00)
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_2_CIVIL_TIME{{|,V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
select fn_overloaded_bytes_and_time('12:30:00.45');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_overloaded_bytes_and_time(TIME) -> BOOL)
    |     +-Literal(type=TIME, value=12:30:00.450)
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_2_CIVIL_TIME{{|,V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
select fn_overloaded_bytes_and_datetime('2020-01-01 12:30:00.45');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_overloaded_bytes_and_datetime(DATETIME) -> BOOL)
    |     +-Literal(type=DATETIME, value=2020-01-01 12:30:00.450)
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
select fn_overloaded_bytes_and_enum('TESTENUM0');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_overloaded_bytes_and_enum(ENUM<zetasql_test__.TestEnum>) -> BOOL)
    |     +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
select fn_overloaded_bytes_and_proto('int64_key_1: 0 int64_key_2: 1');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_overloaded_bytes_and_proto(PROTO<zetasql_test__.KitchenSinkPB>) -> BOOL)
    |     +-Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={int64_key_1: 0 int64_key_2: 1})
    +-input_scan=
      +-SingleRowScan
==

# Coercion doesn't work for maps (yet).
[language_features=V_1_4_MAP_TYPE]
SELECT fn_on_int32_map_returns_int32(MAP_FROM_ARRAY({{ARRAY<STRUCT<INT32, INT32>>[(123, 456)]|[(123, 456)]|[("abc", 456)]}}));
--
ALTERNATION GROUP: ARRAY<STRUCT<INT32, INT32>>[(123, 456)]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_int32_map_returns_int32(MAP<INT32, INT32>) -> INT32)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<INT32, INT32>>) -> MAP<INT32, INT32>)
    |       +-Literal(type=ARRAY<STRUCT<INT32, INT32>>, value=[{123, 456}], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: [(123, 456)]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_MAP_RETURNS_INT32 for argument types: MAP<INT64, INT64>. Supported signature: FN_ON_INT32_MAP_RETURNS_INT32(MAP<INT32, INT32>) [at 1:8]
SELECT fn_on_int32_map_returns_int32(MAP_FROM_ARRAY([(123, 456)]));
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_MAP_RETURNS_INT32
  Argument types: MAP<INT64, INT64>
  Signature: FN_ON_INT32_MAP_RETURNS_INT32(MAP<INT32, INT32>)
    Argument 1: Unable to coerce type MAP<INT64, INT64> to expected type MAP<INT32, INT32> [at 1:8]
SELECT fn_on_int32_map_returns_int32(MAP_FROM_ARRAY([(123, 456)]));
       ^
--
ALTERNATION GROUP: [("abc", 456)]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_MAP_RETURNS_INT32 for argument types: MAP<STRING, INT64>. Supported signature: FN_ON_INT32_MAP_RETURNS_INT32(MAP<INT32, INT32>) [at 1:8]
SELECT fn_on_int32_map_returns_int32(MAP_FROM_ARRAY([("abc", 456)]));
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_MAP_RETURNS_INT32
  Argument types: MAP<STRING, INT64>
  Signature: FN_ON_INT32_MAP_RETURNS_INT32(MAP<INT32, INT32>)
    Argument 1: Unable to coerce type MAP<STRING, INT64> to expected type MAP<INT32, INT32> [at 1:8]
SELECT fn_on_int32_map_returns_int32(MAP_FROM_ARRAY([("abc", 456)]));
       ^
==

[language_features=V_1_4_MAP_TYPE]
SELECT fn_on_int64_map_returns_int64(MAP_FROM_ARRAY({{ARRAY<STRUCT<INT32, INT32>>[(123, 456)]|[(123, 456)]|[("abc", 456)]}}));
--
ALTERNATION GROUP: ARRAY<STRUCT<INT32, INT32>>[(123, 456)]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT64_MAP_RETURNS_INT64 for argument types: MAP<INT32, INT32>. Supported signature: FN_ON_INT64_MAP_RETURNS_INT64(MAP<INT64, INT64>) [at 1:8]
SELECT fn_on_int64_map_returns_int64(MAP_FROM_ARRAY(ARRAY<STRUCT<INT32, INT32...
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT64_MAP_RETURNS_INT64
  Argument types: MAP<INT32, INT32>
  Signature: FN_ON_INT64_MAP_RETURNS_INT64(MAP<INT64, INT64>)
    Argument 1: Unable to coerce type MAP<INT32, INT32> to expected type MAP<INT64, INT64> [at 1:8]
SELECT fn_on_int64_map_returns_int64(MAP_FROM_ARRAY(ARRAY<STRUCT<INT32, INT32...
       ^
--
ALTERNATION GROUP: [(123, 456)]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_int64_map_returns_int64(MAP<INT64, INT64>) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<INT64, INT64>>) -> MAP<INT64, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<INT64, INT64>>, value=[{123, 456}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: [("abc", 456)]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT64_MAP_RETURNS_INT64 for argument types: MAP<STRING, INT64>. Supported signature: FN_ON_INT64_MAP_RETURNS_INT64(MAP<INT64, INT64>) [at 1:8]
SELECT fn_on_int64_map_returns_int64(MAP_FROM_ARRAY([("abc", 456)]));
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT64_MAP_RETURNS_INT64
  Argument types: MAP<STRING, INT64>
  Signature: FN_ON_INT64_MAP_RETURNS_INT64(MAP<INT64, INT64>)
    Argument 1: Unable to coerce type MAP<STRING, INT64> to expected type MAP<INT64, INT64> [at 1:8]
SELECT fn_on_int64_map_returns_int64(MAP_FROM_ARRAY([("abc", 456)]));
       ^
==

[language_features=V_1_4_MAP_TYPE{{|,V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
SELECT fn_on_bytes_map_returns_bytes(MAP_FROM_ARRAY([(b"abc", b"def")]));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_bytes_map_returns_bytes(MAP<BYTES, BYTES>) -> BYTES)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<BYTES, BYTES>>) -> MAP<BYTES, BYTES>)
    |       +-Literal(type=ARRAY<STRUCT<BYTES, BYTES>>, value=[{b"abc", b"def"}])
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_4_MAP_TYPE{{|,V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
SELECT fn_on_bytes_map_returns_bytes(MAP_FROM_ARRAY([("abc", "def")]));
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_BYTES_MAP_RETURNS_BYTES for argument types: MAP<STRING, STRING>. Supported signature: FN_ON_BYTES_MAP_RETURNS_BYTES(MAP<BYTES, BYTES>) [at 1:8]
SELECT fn_on_bytes_map_returns_bytes(MAP_FROM_ARRAY([("abc", "def")]));
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_BYTES_MAP_RETURNS_BYTES
  Argument types: MAP<STRING, STRING>
  Signature: FN_ON_BYTES_MAP_RETURNS_BYTES(MAP<BYTES, BYTES>)
    Argument 1: Unable to coerce type MAP<STRING, STRING> to expected type MAP<BYTES, BYTES> [at 1:8]
SELECT fn_on_bytes_map_returns_bytes(MAP_FROM_ARRAY([("abc", "def")]));
       ^
==

[language_features=V_1_4_MAP_TYPE{{|,V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
SELECT fn_on_bytes_map_returns_bytes(MAP_FROM_ARRAY([(b"abc", "def")]));
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_BYTES_MAP_RETURNS_BYTES for argument types: MAP<BYTES, STRING>. Supported signature: FN_ON_BYTES_MAP_RETURNS_BYTES(MAP<BYTES, BYTES>) [at 1:8]
SELECT fn_on_bytes_map_returns_bytes(MAP_FROM_ARRAY([(b"abc", "def")]));
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_BYTES_MAP_RETURNS_BYTES
  Argument types: MAP<BYTES, STRING>
  Signature: FN_ON_BYTES_MAP_RETURNS_BYTES(MAP<BYTES, BYTES>)
    Argument 1: Unable to coerce type MAP<BYTES, STRING> to expected type MAP<BYTES, BYTES> [at 1:8]
SELECT fn_on_bytes_map_returns_bytes(MAP_FROM_ARRAY([(b"abc", "def")]));
       ^
==

[language_features=V_1_4_MAP_TYPE]
select (case when true then MAP_FROM_ARRAY(ARRAY<STRUCT<INT32, INT32>>[]) else MAP_FROM_ARRAY(ARRAY<STRUCT<INT64, INT64>>[]) end)
--
ERROR: No matching signature for operator CASE; all THEN/ELSE arguments must be coercible to a common type but found: MAP<INT32, INT32>, MAP<INT64, INT64>; actual argument types (WHEN THEN) ELSE: (BOOL MAP<INT32, INT32>) MAP<INT64, INT64> [at 1:9]
select (case when true then MAP_FROM_ARRAY(ARRAY<STRUCT<INT32, INT32>>[]) els...
        ^
==

[language_features=V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES]
select fn_on_bytes("foobar\U0001F4A9");
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_BYTES for argument types: STRING. Supported signature: FN_ON_BYTES(BYTES) [at 1:8]
select fn_on_bytes("foobar\U0001F4A9");
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_BYTES
  Argument types: STRING
  Signature: FN_ON_BYTES(BYTES)
    Argument 1: Unable to coerce type STRING to expected type BYTES [at 1:8]
select fn_on_bytes("foobar\U0001F4A9");
       ^
