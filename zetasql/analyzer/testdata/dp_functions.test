# Valid function calls
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy COUNT(string, contribution_bounds_per_group => (0, 1)), COUNT(*, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [INT64]
| +-$aggregate.$agg2#20 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#19, $agg2#20]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#19, $agg2#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#19 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(STRING, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          |   +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
          |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
          +-$agg2#20 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
==

# Invalid function call with extra argument
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy COUNT(string, 1.0, contribution_bounds_per_group => (0, 1)), COUNT(*, 1.0, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--


ERROR: Number of arguments does not match for aggregate operator COUNT. Supported signature: COUNT(ANY, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) [at 1:34]
select with differential_privacy COUNT(string, 1.0, contribution_bounds_per_g...
                                 ^
==

# Invalid function call with extra arguments
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy COUNT(string, 1.0, string, contriubtion_bounds_per_group => (0, 1)), COUNT(*, 1.0, string, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--

ERROR: Number of arguments does not match for aggregate operator COUNT. Supported signature: COUNT(ANY, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) [at 1:34]
select with differential_privacy COUNT(string, 1.0, string, contriubtion_boun...
                                 ^
==

# contriubtion_bounds_per_group is mandatory
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy COUNT(string, (0, 1)) from SimpleTypes
--

ERROR: Positional argument is invalid because this function restricts that this argument is referred to by name "contribution_bounds_per_group" only [at 1:48]
select with differential_privacy COUNT(string, (0, 1)) from SimpleTypes
                                               ^
==

# Reject COUNT() with no arguments
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy COUNT() from SimpleTypes
--

ERROR: Number of arguments does not match for aggregate operator COUNT. Supported signature: COUNT(ANY, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) [at 1:34]
select with differential_privacy COUNT() from SimpleTypes
                                 ^
==

# DISTINCT is not supported for COUNT()
[language_features=DISALLOW_GROUP_BY_FLOAT,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy COUNT(DISTINCT string, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--

ERROR: Aggregate operator COUNT does not support DISTINCT in arguments [at 1:34]
select with differential_privacy COUNT(DISTINCT string, contribution_bounds_p...
                                 ^
==

# Calling COUNT(*) without any optional arguments works.
[language_features=DISALLOW_GROUP_BY_FLOAT,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy COUNT(*) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
==

# Specify a non-constant expression for clamped bounds
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy COUNT(string, contribution_bounds_per_group => ({{0|int64}}, {{1|int64}})) from SimpleTypes
--
ALTERNATION GROUP: 0,1
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(STRING, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
--
ALTERNATION GROUPS:
    0,int64
    int64,1
    int64,int64
--


ERROR: Argument 'contribution_bounds_per_group' to COUNT must be a literal or query parameter [at 1:48]
select with differential_privacy COUNT(string, contribution_bounds_per_group ...
                                               ^
# COMMENT FROM MISSING PART


# COMMENT FROM MISSING PART


==

# Non-INT64 argument for clamp bounds.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy COUNT(*, contribution_bounds_per_group => ({{0|"abc"}}, {{1|"def"}})) from SimpleTypes
--
ALTERNATION GROUP: 0,1
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
--
ALTERNATION GROUP: 0,"def"
--


ERROR: No matching signature for aggregate operator COUNT(*) in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRUCT<INT64, STRING>. Supported signature: COUNT(* [, contribution_bounds_per_group => STRUCT<INT64, INT64>]) [at 1:34]
select with differential_privacy COUNT(*, contribution_bounds_per_group => (0...
                                 ^
--
ALTERNATION GROUP: "abc",1
--

ERROR: No matching signature for aggregate operator COUNT(*) in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRUCT<STRING, INT64>. Supported signature: COUNT(* [, contribution_bounds_per_group => STRUCT<INT64, INT64>]) [at 1:34]
select with differential_privacy COUNT(*, contribution_bounds_per_group => ("...
                                 ^
--
ALTERNATION GROUP: "abc","def"
--

ERROR: No matching signature for aggregate operator COUNT(*) in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRUCT<STRING, STRING>. Supported signature: COUNT(* [, contribution_bounds_per_group => STRUCT<INT64, INT64>]) [at 1:34]
select with differential_privacy COUNT(*, contribution_bounds_per_group => ("...
                                 ^
==

# Accept const parameter bounds
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy COUNT(*, contribution_bounds_per_group => (@test_param_int64, 6)) from SimpleTypes
--
ERROR: Argument 'contribution_bounds_per_group' to COUNT(*) must be a literal or query parameter [at 1:43]
select with differential_privacy COUNT(*, contribution_bounds_per_group => (@...
                                          ^
==

# Accept const parameter bounds
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy COUNT(*, contribution_bounds_per_group => @test_param_struct_two_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Parameter(type=STRUCT<INT64, INT64>, name="test_param_struct_two_int64")
==

# Support GROUP BY
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy COUNT(string, contribution_bounds_per_group => (0, 1)), COUNT(*, contribution_bounds_per_group => (0, 1)) from SimpleTypes
group by int64
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [INT64]
| +-$aggregate.$agg2#20 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#19, $agg2#20]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#19, $agg2#20]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, string#5], table=SimpleTypes, column_index_list=[1, 4])
        +-group_by_list=
        | +-int64#21 := ColumnRef(type=INT64, column=SimpleTypes.int64#2)
        +-aggregate_list=
          +-$agg1#19 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(STRING, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          |   +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
          |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
          +-$agg2#20 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
==

# SUM should reject exprs other than int64, uint64, double & numeric
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy SUM(string, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
ERROR: No matching signature for aggregate operator SUM in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRING, STRUCT<INT64, INT64>. Supported signatures: SUM(INT64, [contribution_bounds_per_group => STRUCT<INT64, INT64>]); SUM(UINT64, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]); SUM(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) [at 1:34]
select with differential_privacy SUM(string, contribution_bounds_per_group =>...
                                 ^
==

# AVG should reject exprs other than int64, uint64, double & numeric
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy AVG(string, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
ERROR: No matching signature for aggregate operator AVG in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRING, STRUCT<INT64, INT64>. Supported signature: AVG(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) [at 1:34]
select with differential_privacy AVG(string, contribution_bounds_per_group =>...
                                 ^
==

# Valid SUM function call
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy SUM(int64, contribution_bounds_per_group => (0, 1)), SUM(uint64, contribution_bounds_per_group => (0, 1)), SUM(double, contribution_bounds_per_group => (0, 1)),
SUM(numeric, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [INT64]
| +-$aggregate.$agg2#20 AS `$col2` [UINT64]
| +-$aggregate.$agg3#21 AS `$col3` [DOUBLE]
| +-$aggregate.$agg4#22 AS `$col4` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#19, $agg2#20, $agg3#21, $agg4#22]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#19, $agg2#20, $agg3#21, $agg4#22]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, uint64#4, double#9, numeric#16], table=SimpleTypes, column_index_list=[1, 3, 8, 15])
        +-aggregate_list=
          +-$agg1#19 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
          |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
          +-$agg2#20 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(UINT64, optional(1) STRUCT<UINT64, UINT64> contribution_bounds_per_group) -> UINT64)
          |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
          |   +-Literal(type=STRUCT<UINT64, UINT64>, value={0, 1})
          +-$agg3#21 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
          +-$agg4#22 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
              +-Cast(NUMERIC -> DOUBLE)
              | +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
==

# Valid AVG function call
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy AVG(int64, contribution_bounds_per_group => (0, 1)), AVG(uint64, contribution_bounds_per_group => (0, 1)), AVG(double, contribution_bounds_per_group => (0, 1)),
AVG(numeric, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [DOUBLE]
| +-$aggregate.$agg2#20 AS `$col2` [DOUBLE]
| +-$aggregate.$agg3#21 AS `$col3` [DOUBLE]
| +-$aggregate.$agg4#22 AS `$col4` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#19, $agg2#20, $agg3#21, $agg4#22]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#19, $agg2#20, $agg3#21, $agg4#22]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, uint64#4, double#9, numeric#16], table=SimpleTypes, column_index_list=[1, 3, 8, 15])
        +-aggregate_list=
          +-$agg1#19 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
          |   +-Cast(INT64 -> DOUBLE)
          |   | +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
          +-$agg2#20 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
          |   +-Cast(UINT64 -> DOUBLE)
          |   | +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
          +-$agg3#21 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
          +-$agg4#22 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
              +-Cast(NUMERIC -> DOUBLE)
              | +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
==

# HAVING modifier is currently disabled for ANON functions, this is because the
# SQL builder will append all present modifiers to the last argument.
# In the case of the contribution_bounds_per_group => (modifier this could potentially produce
# invalid syntax when performing an unparse.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,V_1_1_HAVING_IN_AGGREGATE]
select with differential_privacy SUM(int64 having max 1, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
ERROR: Syntax error: Expected ")" but got "," [at 1:56]
...with differential_privacy SUM(int64 having max 1, contribution_bounds_per_...
                                                   ^
==

# HAVING modifier is currently disabled for ANON functions, this is because the
# SQL builder will append all present modifiers to the last argument.
# In the case of the contribution_bounds_per_group => (modifier this could potentially produce
# invalid syntax when performing an unparse.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,V_1_1_HAVING_IN_AGGREGATE]
select with differential_privacy AVG(int64 having max 1, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
ERROR: Syntax error: Expected ")" but got "," [at 1:56]
...with differential_privacy AVG(int64 having max 1, contribution_bounds_per_...
                                                   ^
==

# Valid safe SUM function call
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,V_1_2_SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY safe.SUM(int64, contribution_bounds_per_group => (0, 1))
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall({SAFE_ERROR_MODE} ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
==

# DISTINCT is not supported for differential privacy aggregate functions
[language_features=DISALLOW_GROUP_BY_FLOAT,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy SUM(DISTINCT int32, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
ERROR: Aggregate operator SUM does not support DISTINCT in arguments [at 1:34]
select with differential_privacy SUM(DISTINCT int32, contribution_bounds_per_...
                                 ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE,V_1_2_SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY
SUM(numeric, contribution_bounds_per_group => (1.9, 3.5))
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.numeric#16], table=SimpleTypes, column_index_list=[15])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(NUMERIC, optional(1) STRUCT<NUMERIC, NUMERIC> contribution_bounds_per_group) -> NUMERIC)
              +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
              +-Literal(type=STRUCT<NUMERIC, NUMERIC>, value={1.9, 3.5})
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE,V_1_2_SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY
SUM(numeric, contribution_bounds_per_group => (0.999999999, 1.000000001))
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.numeric#16], table=SimpleTypes, column_index_list=[15])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(NUMERIC, optional(1) STRUCT<NUMERIC, NUMERIC> contribution_bounds_per_group) -> NUMERIC)
              +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
              +-Literal(type=STRUCT<NUMERIC, NUMERIC>, value={0.999999999, 1.000000001})
==

# Valid safe AVG function call
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,V_1_2_SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY safe.AVG(int64, contribution_bounds_per_group => (0, 1))
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall({SAFE_ERROR_MODE} ZetaSQL:$differential_privacy_avg(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
              +-Cast(INT64 -> DOUBLE)
              | +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
==

# DISTINCT is not supported for differential privacy aggregate functions
[language_features=DISALLOW_GROUP_BY_FLOAT,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
select with differential_privacy AVG(DISTINCT int32, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
ERROR: Aggregate operator AVG does not support DISTINCT in arguments [at 1:34]
select with differential_privacy AVG(DISTINCT int32, contribution_bounds_per_...
                                 ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE,V_1_2_SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY
AVG(numeric,  contribution_bounds_per_group => (0.999999999, 1.000000001))
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.numeric#16], table=SimpleTypes, column_index_list=[15])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(NUMERIC, optional(1) STRUCT<NUMERIC, NUMERIC> contribution_bounds_per_group) -> NUMERIC)
              +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
              +-Literal(type=STRUCT<NUMERIC, NUMERIC>, value={0.999999999, 1.000000001})
==

# VAR_POP(ARRAY<DOUBLE>) is an internal signature and cannot be used by
# users.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy VAR_POP(double_array)
from ArrayWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator VAR_POP in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: ARRAY<DOUBLE>. Supported signatures: VAR_POP(DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) [at 1:34]
select with differential_privacy VAR_POP(double_array)
                                 ^
==

# STDDEV_POP(ARRAY<DOUBLE>) is an internal signature and cannot be used by
# users.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy STDDEV_POP(double_array)
from ArrayWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator STDDEV_POP in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: ARRAY<DOUBLE>. Supported signatures: STDDEV_POP(DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) [at 1:34]
select with differential_privacy STDDEV_POP(double_array)
                                 ^
==

# PERCENTILE_CONT(ARRAY<DOUBLE>, DOUBLE) is an internal signature and
# cannot be used by users.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy PERCENTILE_CONT(double_array, 0.4)
from ArrayWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: ARRAY<DOUBLE>, DOUBLE. Supported signatures: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) [at 1:34]
select with differential_privacy PERCENTILE_CONT(double_array, 0.4)
                                 ^
==

# PERCENTILE_CONT(DOUBLE) is not supported because that percentile is not
# provided.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy PERCENTILE_CONT(double)
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE. Supported signatures: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) [at 1:34]
select with differential_privacy PERCENTILE_CONT(double)
                                 ^
==

# More than two arguments are not supported for PERCENTILE_CONT.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy PERCENTILE_CONT(double, double, double)
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE, DOUBLE, DOUBLE. Supported signatures: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) [at 1:34]
select with differential_privacy PERCENTILE_CONT(double, double, double)
                                 ^
==

# percentile must be in the range [0.0, 1.0]
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy PERCENTILE_CONT(double, 1.5)
from SimpleTypesWithAnonymizationUid;
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:58]
select with differential_privacy PERCENTILE_CONT(double, 1.5)
                                                         ^
==

# percentile must have two arguments.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy PERCENTILE_CONT(double, 1.5, 1.5)
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE, DOUBLE, DOUBLE. Supported signatures: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) [at 1:34]
select with differential_privacy PERCENTILE_CONT(double, 1.5, 1.5)
                                 ^
==

# percentile must have two arguments.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy PERCENTILE_CONT(double)
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE. Supported signatures: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) [at 1:34]
select with differential_privacy PERCENTILE_CONT(double)
                                 ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy
    PERCENTILE_CONT(int64, 0.4, 0.4, contribution_bounds_per_group => (2, 3))
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, DOUBLE, DOUBLE, STRUCT<INT64, INT64>. Supported signatures: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) [at 2:5]
    PERCENTILE_CONT(int64, 0.4, 0.4, contribution_bounds_per_group => (2, 3))
    ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy
    PERCENTILE_CONT(int64, contribution_bounds_per_group => (2, 3))
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, STRUCT<INT64, INT64>. Supported signatures: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) [at 2:5]
    PERCENTILE_CONT(int64, contribution_bounds_per_group => (2, 3))
    ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy
    PERCENTILE_CONT(int64, double, contribution_bounds_per_group => (2, 3))
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, DOUBLE, STRUCT<INT64, INT64>. Supported signatures: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) [at 2:5]
    PERCENTILE_CONT(int64, double, contribution_bounds_per_group => (2, 3))
    ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy
    PERCENTILE_CONT(int64, 0.4 contribution_bounds_per_group => (double, 3))
from SimpleTypesWithAnonymizationUid;
--

ERROR: Syntax error: Expected ")" but got identifier "contribution_bounds_per_group" [at 2:32]
    PERCENTILE_CONT(int64, 0.4 contribution_bounds_per_group => (double, 3))
                               ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy
    PERCENTILE_CONT(int64, 0.4 contribution_bounds_per_group => (2, double))
from SimpleTypesWithAnonymizationUid;
--

ERROR: Syntax error: Expected ")" but got identifier "contribution_bounds_per_group" [at 2:32]
    PERCENTILE_CONT(int64, 0.4 contribution_bounds_per_group => (2, double))
                               ^
==

# APPROX_QUANTILES(ARRAY<DOUBLE>, INT64) is an internal signature and
# cannot be used by users.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy APPROX_QUANTILES(double_array, 4)
from ArrayWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: ARRAY<DOUBLE>, INT64. Supported signatures: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) [at 1:34]
select with differential_privacy APPROX_QUANTILES(double_array, 4)
                                 ^
==

# APPROX_QUANTILES(DOUBLE) is not supported because APPROX_QUANTILES are not
# provided.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy APPROX_QUANTILES(double)
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE. Supported signatures: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) [at 1:34]
select with differential_privacy APPROX_QUANTILES(double)
                                 ^
==

# More than two arguments are not supported for APPROX_QUANTILES.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy APPROX_QUANTILES(double, int64, double)
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE, INT64, DOUBLE. Supported signatures: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) [at 1:34]
select with differential_privacy APPROX_QUANTILES(double, int64, double)
                                 ^
==

# APPROX_QUANTILES must be an int64
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy APPROX_QUANTILES(double, double)
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE, DOUBLE. Supported signatures: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) [at 1:34]
select with differential_privacy APPROX_QUANTILES(double, double)
                                 ^
==

# APPROX_QUANTILES requires explicit bounds
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy APPROX_QUANTILES(double, int64)
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE, INT64. Supported signatures: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) [at 1:34]
select with differential_privacy APPROX_QUANTILES(double, int64)
                                 ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy
    APPROX_QUANTILES(int64, 4, 0.4, contribution_bounds_per_group => (2, 3))
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, INT64, DOUBLE, STRUCT<INT64, INT64>. Supported signatures: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) [at 2:5]
    APPROX_QUANTILES(int64, 4, 0.4, contribution_bounds_per_group => (2, 3))
    ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy
    APPROX_QUANTILES(int64, contribution_bounds_per_group => (2, 3))
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, STRUCT<INT64, INT64>. Supported signatures: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) [at 2:5]
    APPROX_QUANTILES(int64, contribution_bounds_per_group => (2, 3))
    ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy
    APPROX_QUANTILES(int64, int64, contribution_bounds_per_group => (2, 3))
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, INT64, STRUCT<INT64, INT64>. Supported signatures: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) [at 2:5]
    APPROX_QUANTILES(int64, int64, contribution_bounds_per_group => (2, 3))
    ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy
    APPROX_QUANTILES(int64, 4, contribution_bounds_per_group => (double, 3))
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, INT64, STRUCT<DOUBLE, INT64>. Supported signatures: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) [at 2:5]
    APPROX_QUANTILES(int64, 4, contribution_bounds_per_group => (double, 3))
    ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy
    APPROX_QUANTILES(int64, 4, contribution_bounds_per_group => (2, double))
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, INT64, STRUCT<INT64, DOUBLE>. Supported signatures: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) [at 2:5]
    APPROX_QUANTILES(int64, 4, contribution_bounds_per_group => (2, double))
    ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE]
select with differential_privacy
    APPROX_QUANTILES(int64, @test_param_int64, contribution_bounds_per_group => (@test_param_double, @test_param_double))
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, INT64, STRUCT<DOUBLE, DOUBLE>. Supported signatures: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) [at 2:5]
    APPROX_QUANTILES(int64, @test_param_int64, contribution_bounds_per_group ...
    ^
==

[language_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,JSON_TYPE]
[no_enable_literal_replacement]
select with differential_privacy
    SUM(int64, report_format => "JSON") as s
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.s#13 AS s [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.s#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.s#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-s#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
==

[language_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,JSON_TYPE]
select with differential_privacy
    SUM(int64, report_format => "Invalid") as s
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator SUM in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, STRING. Supported signatures: SUM(INT64, [contribution_bounds_per_group => STRUCT<INT64, INT64>]); SUM(UINT64, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]); SUM(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]); SUM(INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="JSON"*/, [contribution_bounds_per_group => STRUCT<INT64, INT64>]); SUM(DOUBLE, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="JSON"*/, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]); SUM(UINT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="JSON"*/, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]); SUM(INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="PROTO"*/, [contribution_bounds_per_group => STRUCT<INT64, INT64>]); SUM(DOUBLE, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="PROTO"*/, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]); SUM(UINT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="PROTO"*/, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]) [at 2:5]
    SUM(int64, report_format => "Invalid") as s
    ^
==

[language_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,JSON_TYPE]
select with differential_privacy
    SUM(int64, report_format => @test_param_string) as s
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator SUM in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, STRING. Supported signatures: SUM(INT64, [contribution_bounds_per_group => STRUCT<INT64, INT64>]); SUM(UINT64, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]); SUM(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]); SUM(INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="JSON"*/, [contribution_bounds_per_group => STRUCT<INT64, INT64>]); SUM(DOUBLE, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="JSON"*/, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]); SUM(UINT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="JSON"*/, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]); SUM(INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="PROTO"*/, [contribution_bounds_per_group => STRUCT<INT64, INT64>]); SUM(DOUBLE, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="PROTO"*/, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]); SUM(UINT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="PROTO"*/, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]) [at 2:5]
    SUM(int64, report_format => @test_param_string) as s
    ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,JSON_TYPE]
select with differential_privacy
    SUM(int64, report_format => "JSON") as s
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator SUM in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, STRING. Supported signatures: SUM(INT64, [contribution_bounds_per_group => STRUCT<INT64, INT64>]); SUM(UINT64, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]); SUM(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) [at 2:5]
    SUM(int64, report_format => "JSON") as s
    ^
==

# Numeric sum with report is not implemented.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NUMERIC_TYPE,V_1_2_SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY
SUM(numeric,  report_format => "JSON")
FROM SimpleTypes
--

ERROR: No matching signature for aggregate operator SUM in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: NUMERIC, STRING. Supported signatures: SUM(INT64, [contribution_bounds_per_group => STRUCT<INT64, INT64>]); SUM(UINT64, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]); SUM(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]); SUM(NUMERIC, [contribution_bounds_per_group => STRUCT<NUMERIC, NUMERIC>]); SUM(INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="PROTO"*/, [contribution_bounds_per_group => STRUCT<INT64, INT64>]); SUM(DOUBLE, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="PROTO"*/, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]); SUM(UINT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="PROTO"*/, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]) [at 2:1]
SUM(numeric,  report_format => "JSON")
^
==

# Numeric avg with report is not implemented.
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NUMERIC_TYPE,V_1_2_SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY
AVG(numeric,  report_format => "JSON")
FROM SimpleTypes
--

ERROR: No matching signature for aggregate operator AVG in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: NUMERIC, STRING. Supported signatures: AVG(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]); AVG(NUMERIC, [contribution_bounds_per_group => STRUCT<NUMERIC, NUMERIC>]); AVG(DOUBLE, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="PROTO"*/, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) [at 2:1]
AVG(numeric,  report_format => "JSON")
^
