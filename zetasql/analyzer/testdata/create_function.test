[default language_features=TEMPLATE_FUNCTIONS]
create function myfunc() returns string;
--
ERROR: Function must specify LANGUAGE or have a SQL body in parentheses [at 1:1]
create function myfunc() returns string;
^
==

create function myfunc() returns string
as """body""";
--
ERROR: Function must specify LANGUAGE or have a SQL body in parentheses [at 1:1]
create function myfunc() returns string
^
==

# We don't allow explicit LANGUAGE SQL.
create function myfunc() returns string
language SQL
as """5""";
--
ERROR: To write SQL functions, omit the LANGUAGE clause and write the function body using 'AS (expression)' [at 2:10]
language SQL
         ^
==

create function myfunc() returns string
language SQL
as (5);
--
ERROR: Function cannot specify a LANGUAGE and include a SQL body [at 1:1]
create function myfunc() returns string
^
==

# Simple function name.
create function myfunc (  )
  returns string language testlang ;
--
CreateFunctionStmt(name_path=myfunc, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang")
==

# Qualified function name.
create function mypackage.myfunc (  )
  returns string language testlang ;
--
CreateFunctionStmt(name_path=mypackage.myfunc, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang")
==

# Test that deprecation warnings come out in both the resolved AST and in the
# analyzer warnings.
create function myfunc(msg zetasql_test__.SimpleProto3Message )
  returns int64 as (deprecation_warning()) ;
--
CreateFunctionStmt
+-name_path=myfunc
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[msg]
+-signature=(PROTO<zetasql_test__.SimpleProto3Message> msg) -> INT64 (1 deprecation warning)
+-language="SQL"
+-code="deprecation_warning()"
+-function_expression=
  +-FunctionCall(sample_functions:deprecation_warning() -> INT64)


DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:DEPRECATION_WARNING triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 2:21]
  returns int64 as (deprecation_warning()) ;
                    ^
Operation <foo1> is deprecated [at module1.sqlm:11:21]
some caret string for foo_1
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }
==

# A test with two deprecation warnings that are deduplicated.
create function myfunc(msg zetasql_test__.SimpleProto3Message )
  returns bool as (deprecation_warning() > deprecation_warning()) ;
--
CreateFunctionStmt
+-name_path=myfunc
+-has_explicit_return_type=TRUE
+-return_type=BOOL
+-argument_name_list=[msg]
+-signature=(PROTO<zetasql_test__.SimpleProto3Message> msg) -> BOOL (1 deprecation warning)
+-language="SQL"
+-code="deprecation_warning() > deprecation_warning()"
+-function_expression=
  +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    +-FunctionCall(sample_functions:deprecation_warning() -> INT64)
    +-FunctionCall(sample_functions:deprecation_warning() -> INT64)


DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:DEPRECATION_WARNING triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 2:20]
  returns bool as (deprecation_warning() > deprecation_warning()) ;
                   ^
Operation <foo1> is deprecated [at module1.sqlm:11:21]
some caret string for foo_1
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }
==

# A test with two different deprecation warnings.
create function myfunc( msg zetasql_test__.Proto3KitchenSink )
  returns bool as (deprecation_warning() > deprecation_warning2()) ;
--
CreateFunctionStmt
+-name_path=myfunc
+-has_explicit_return_type=TRUE
+-return_type=BOOL
+-argument_name_list=[msg]
+-signature=(PROTO<zetasql_test__.Proto3KitchenSink> msg) -> BOOL (2 deprecation warnings)
+-language="SQL"
+-code="deprecation_warning() > deprecation_warning2()"
+-function_expression=
  +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    +-FunctionCall(sample_functions:deprecation_warning() -> INT64)
    +-FunctionCall(sample_functions:deprecation_warning2() -> INT64)


DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:DEPRECATION_WARNING triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 2:20]
  returns bool as (deprecation_warning() > deprecation_warning2()) ;
                   ^
Operation <foo1> is deprecated [at module1.sqlm:11:21]
some caret string for foo_1
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:DEPRECATION_WARNING2 triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 2:44]
  returns bool as (deprecation_warning() > deprecation_warning2()) ;
                                           ^
Operation <foo2> is deprecated [at module2.sqlm:12:22]
some caret string for foo_2
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }
==

# The function calls another function that has a deprecation warning. The
# warning should propagate to this function.
create function myfunc( msg zetasql_test__.Proto3KitchenSink )
  returns int64 as (deprecation_warning()) ;
--
CreateFunctionStmt
+-name_path=myfunc
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[msg]
+-signature=(PROTO<zetasql_test__.Proto3KitchenSink> msg) -> INT64 (1 deprecation warning)
+-language="SQL"
+-code="deprecation_warning()"
+-function_expression=
  +-FunctionCall(sample_functions:deprecation_warning() -> INT64)


DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:DEPRECATION_WARNING triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 2:21]
  returns int64 as (deprecation_warning()) ;
                    ^
Operation <foo1> is deprecated [at module1.sqlm:11:21]
some caret string for foo_1
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }
==

# The function calls another function that has a deprecation warning, twice. The
# warning should propagate to this function, but should be de-duplicated.
create function myfunc( msg zetasql_test__.Proto3KitchenSink )
  returns int64 as (deprecation_warning() + deprecation_warning()) ;
--
CreateFunctionStmt
+-name_path=myfunc
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[msg]
+-signature=(PROTO<zetasql_test__.Proto3KitchenSink> msg) -> INT64 (1 deprecation warning)
+-language="SQL"
+-code="deprecation_warning() + deprecation_warning()"
+-function_expression=
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    +-FunctionCall(sample_functions:deprecation_warning() -> INT64)
    +-FunctionCall(sample_functions:deprecation_warning() -> INT64)


DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:DEPRECATION_WARNING triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 2:21]
  returns int64 as (deprecation_warning() + deprecation_warning()) ;
                    ^
Operation <foo1> is deprecated [at module1.sqlm:11:21]
some caret string for foo_1
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }
==

# The function calls a function that has two deprecation warnings of the same
# kind. The first warning should propagate to this function.
create function myfunc( msg zetasql_test__.Proto3KitchenSink )
  returns int64 as (two_deprecation_warnings_same_kind()) ;
--
CreateFunctionStmt
+-name_path=myfunc
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[msg]
+-signature=(PROTO<zetasql_test__.Proto3KitchenSink> msg) -> INT64 (1 deprecation warning)
+-language="SQL"
+-code="two_deprecation_warnings_same_kind()"
+-function_expression=
  +-FunctionCall(sample_functions:two_deprecation_warnings_same_kind() -> INT64)


DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:TWO_DEPRECATION_WARNINGS_SAME_KIND triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 2:21]
  returns int64 as (two_deprecation_warnings_same_kind()) ;
                    ^
Operation <foo2> is deprecated [at module2.sqlm:12:22]
some caret string for foo_2
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }
==

# The function calls a function that has two deprecation warnings with different
# kinds. Both should propagate to this function.
create function myfunc( msg zetasql_test__.Proto3KitchenSink )
  returns int64 as (two_deprecation_warnings()) ;
--
CreateFunctionStmt
+-name_path=myfunc
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[msg]
+-signature=(PROTO<zetasql_test__.Proto3KitchenSink> msg) -> INT64 (2 deprecation warnings)
+-language="SQL"
+-code="two_deprecation_warnings()"
+-function_expression=
  +-FunctionCall(sample_functions:two_deprecation_warnings() -> INT64)


DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:TWO_DEPRECATION_WARNINGS triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 2:21]
  returns int64 as (two_deprecation_warnings()) ;
                    ^
Operation <foo4> is deprecated [at module4.sqlm:14:24]
some caret string for foo_4
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:TWO_DEPRECATION_WARNINGS triggers a deprecation warning with kind DEPRECATED_FUNCTION_SIGNATURE [at 2:21]
  returns int64 as (two_deprecation_warnings()) ;
                    ^
Operation <foo5> is deprecated [at module5.sqlm:15:25]
some caret string for foo_5
                      ^
[zetasql.DeprecationWarning] { kind: DEPRECATED_FUNCTION_SIGNATURE }
==

# The function calls three functions. The first has one deprecation warning, the
# second has two deprecation warnings with the same kind, and the third has
# two deprecation warnings with different kinds. The result should have one
# deprecation warning for each function, using the first deprecation warning for
# each kind, for a total of 4 warnings.
create function myfunc( msg zetasql_test__.Proto3KitchenSink )
  returns int64 as
    (deprecation_warning() + two_deprecation_warnings_same_kind() +
     two_deprecation_warnings())
--
CreateFunctionStmt
+-name_path=myfunc
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[msg]
+-signature=(PROTO<zetasql_test__.Proto3KitchenSink> msg) -> INT64 (4 deprecation warnings)
+-language="SQL"
+-code="deprecation_warning() + two_deprecation_warnings_same_kind() +\n     two_deprecation_warnings()"
+-function_expression=
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | +-FunctionCall(sample_functions:deprecation_warning() -> INT64)
    | +-FunctionCall(sample_functions:two_deprecation_warnings_same_kind() -> INT64)
    +-FunctionCall(sample_functions:two_deprecation_warnings() -> INT64)


DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:DEPRECATION_WARNING triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 3:6]
    (deprecation_warning() + two_deprecation_warnings_same_kind() +
     ^
Operation <foo1> is deprecated [at module1.sqlm:11:21]
some caret string for foo_1
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:TWO_DEPRECATION_WARNINGS_SAME_KIND triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 3:30]
    (deprecation_warning() + two_deprecation_warnings_same_kind() +
                             ^
Operation <foo2> is deprecated [at module2.sqlm:12:22]
some caret string for foo_2
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:TWO_DEPRECATION_WARNINGS triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 4:6]
     two_deprecation_warnings())
     ^
Operation <foo4> is deprecated [at module4.sqlm:14:24]
some caret string for foo_4
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:TWO_DEPRECATION_WARNINGS triggers a deprecation warning with kind DEPRECATED_FUNCTION_SIGNATURE [at 4:6]
     two_deprecation_warnings())
     ^
Operation <foo5> is deprecated [at module5.sqlm:15:25]
some caret string for foo_5
                      ^
[zetasql.DeprecationWarning] { kind: DEPRECATED_FUNCTION_SIGNATURE }
==

# Same as the previous test, except each function is called twice. The
# deprecation warnings are de-duplicated, so there are still only 4 warnings.
create function myfunc( msg zetasql_test__.Proto3KitchenSink )
  returns int64 as
    (deprecation_warning() + deprecation_warning() +
     two_deprecation_warnings_same_kind() +
     two_deprecation_warnings_same_kind() +
     two_deprecation_warnings() + two_deprecation_warnings())
--
CreateFunctionStmt
+-name_path=myfunc
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[msg]
+-signature=(PROTO<zetasql_test__.Proto3KitchenSink> msg) -> INT64 (4 deprecation warnings)
+-language="SQL"
+-code="deprecation_warning() + deprecation_warning() +\n     two_deprecation_warnings_same_kind() +\n     two_deprecation_warnings_same_kind() +\n     two_deprecation_warnings() + two_deprecation_warnings()"
+-function_expression=
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | | | | +-FunctionCall(sample_functions:deprecation_warning() -> INT64)
    | | | | +-FunctionCall(sample_functions:deprecation_warning() -> INT64)
    | | | +-FunctionCall(sample_functions:two_deprecation_warnings_same_kind() -> INT64)
    | | +-FunctionCall(sample_functions:two_deprecation_warnings_same_kind() -> INT64)
    | +-FunctionCall(sample_functions:two_deprecation_warnings() -> INT64)
    +-FunctionCall(sample_functions:two_deprecation_warnings() -> INT64)


DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:DEPRECATION_WARNING triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 3:6]
    (deprecation_warning() + deprecation_warning() +
     ^
Operation <foo1> is deprecated [at module1.sqlm:11:21]
some caret string for foo_1
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:TWO_DEPRECATION_WARNINGS_SAME_KIND triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 4:6]
     two_deprecation_warnings_same_kind() +
     ^
Operation <foo2> is deprecated [at module2.sqlm:12:22]
some caret string for foo_2
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:TWO_DEPRECATION_WARNINGS triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 6:6]
     two_deprecation_warnings() + two_deprecation_warnings())
     ^
Operation <foo4> is deprecated [at module4.sqlm:14:24]
some caret string for foo_4
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:TWO_DEPRECATION_WARNINGS triggers a deprecation warning with kind DEPRECATED_FUNCTION_SIGNATURE [at 6:6]
     two_deprecation_warnings() + two_deprecation_warnings())
     ^
Operation <foo5> is deprecated [at module5.sqlm:15:25]
some caret string for foo_5
                      ^
[zetasql.DeprecationWarning] { kind: DEPRECATED_FUNCTION_SIGNATURE }
==

# Missing return type.
create function myfunc (  ) language testlang ;
--
ERROR: Non-SQL functions must specify a return type [at 1:1]
create function myfunc (  ) language testlang ;
^
==

# Temporary function.
create temporary function myfunc (  )
  returns string language testlang ;
--
CreateFunctionStmt(name_path=myfunc, create_scope=CREATE_TEMP, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang")
==

[statement_context={{|module}}]
create {{public|private}} function myfunc (  )
  returns string language testlang ;
--
ALTERNATION GROUP: public
--
ERROR: CREATE FUNCTION with PUBLIC or PRIVATE modifiers is not supported [at 1:1]
create public function myfunc (  )
^
--
ALTERNATION GROUP: private
--
ERROR: CREATE FUNCTION with PUBLIC or PRIVATE modifiers is not supported [at 1:1]
create private function myfunc (  )
^
--
ALTERNATION GROUP: module,public
--
CreateFunctionStmt(name_path=myfunc, create_scope=CREATE_PUBLIC, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang")
--
ALTERNATION GROUP: module,private
--
CreateFunctionStmt(name_path=myfunc, create_scope=CREATE_PRIVATE, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang")
==

# If not exists.
[statement_context={{|module}}]
create {{|public|private}} function if not exists myfunc (  )
  returns string language testlang ;
--
ALTERNATION GROUP: <empty>
--
CreateFunctionStmt(name_path=myfunc, create_mode=CREATE_IF_NOT_EXISTS, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang")
--
ALTERNATION GROUP: public
--
ERROR: CREATE FUNCTION with PUBLIC or PRIVATE modifiers is not supported [at 1:1]
create public function if not exists myfunc (  )
^
--
ALTERNATION GROUP: private
--
ERROR: CREATE FUNCTION with PUBLIC or PRIVATE modifiers is not supported [at 1:1]
create private function if not exists myfunc (  )
^
--
ALTERNATION GROUP: module,
--
ERROR: Modules do not support IF NOT EXISTS for CREATE FUNCTION [at 1:1]
create  function if not exists myfunc (  )
^
--
ALTERNATION GROUP: module,public
--
ERROR: Modules do not support IF NOT EXISTS for CREATE FUNCTION [at 1:1]
create public function if not exists myfunc (  )
^
--
ALTERNATION GROUP: module,private
--
ERROR: Modules do not support IF NOT EXISTS for CREATE FUNCTION [at 1:1]
create private function if not exists myfunc (  )
^
==

# Create or replace.
[statement_context={{|module}}]
create or replace {{|public|private}} function myfunc (  )
  returns string language testlang ;
--
ALTERNATION GROUP: <empty>
--
CreateFunctionStmt(name_path=myfunc, create_mode=CREATE_OR_REPLACE, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang")
--
ALTERNATION GROUP: public
--
ERROR: CREATE FUNCTION with PUBLIC or PRIVATE modifiers is not supported [at 1:1]
create or replace public function myfunc (  )
^
--
ALTERNATION GROUP: private
--
ERROR: CREATE FUNCTION with PUBLIC or PRIVATE modifiers is not supported [at 1:1]
create or replace private function myfunc (  )
^
--
ALTERNATION GROUP: module,
--
ERROR: Modules do not support CREATE OR REPLACE for CREATE FUNCTION [at 1:1]
create or replace  function myfunc (  )
^
--
ALTERNATION GROUP: module,public
--
ERROR: Modules do not support CREATE OR REPLACE for CREATE FUNCTION [at 1:1]
create or replace public function myfunc (  )
^
--
ALTERNATION GROUP: module,private
--
ERROR: Modules do not support CREATE OR REPLACE for CREATE FUNCTION [at 1:1]
create or replace private function myfunc (  )
^
==

# Determinism qualifiers
create function myfunc (  )
  returns string {{DETERMINISTIC|NOT DETERMINISTIC|IMMUTABLE|STABLE|VOLATILE|}} language testlang ;
--
ALTERNATION GROUP: DETERMINISTIC
--
CreateFunctionStmt(name_path=myfunc, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang", determinism_level=DETERMINISM_DETERMINISTIC)
--
ALTERNATION GROUP: NOT DETERMINISTIC
--
CreateFunctionStmt(name_path=myfunc, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang", determinism_level=DETERMINISM_NOT_DETERMINISTIC)
--
ALTERNATION GROUP: IMMUTABLE
--
CreateFunctionStmt(name_path=myfunc, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang", determinism_level=DETERMINISM_IMMUTABLE)
--
ALTERNATION GROUP: STABLE
--
CreateFunctionStmt(name_path=myfunc, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang", determinism_level=DETERMINISM_STABLE)
--
ALTERNATION GROUP: VOLATILE
--
CreateFunctionStmt(name_path=myfunc, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang", determinism_level=DETERMINISM_VOLATILE)
--
ALTERNATION GROUP: <empty>
--
CreateFunctionStmt(name_path=myfunc, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang")
==

# Temporary + If not exists.
create temporary function if not exists myfunc (  )
  returns string language testlang ;
--
CreateFunctionStmt(name_path=myfunc, create_scope=CREATE_TEMP, create_mode=CREATE_IF_NOT_EXISTS, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang")
==

# Temporary + Create or replace.
create or replace temporary function myfunc (  )
  returns string language testlang ;
--
CreateFunctionStmt(name_path=myfunc, create_scope=CREATE_TEMP, create_mode=CREATE_OR_REPLACE, has_explicit_return_type=TRUE, return_type=STRING, signature=() -> STRING, language="testlang")
==

# Struct return type.
create function mypackage.myfunc( param_a int32 )
  returns struct<x string, y boolean> language testlang ;
--
CreateFunctionStmt(name_path=mypackage.myfunc, has_explicit_return_type=TRUE, return_type=STRUCT<x STRING, y BOOL>, argument_name_list=[param_a], signature=(INT32 param_a) -> STRUCT<x STRING, y BOOL>, language="testlang")
==

# Struct return type (b/28942765).
CREATE TEMPORARY FUNCTION MakeStruct(x INT64, y STRING)
RETURNS STRUCT<x INT64, y STRING> AS (STRUCT(x + 5, SUBSTR(y, 0, 10)));
--
CreateFunctionStmt
+-name_path=MakeStruct
+-create_scope=CREATE_TEMP
+-has_explicit_return_type=TRUE
+-return_type=STRUCT<x INT64, y STRING>
+-argument_name_list=[x, y]
+-signature=(INT64 x, STRING y) -> STRUCT<x INT64, y STRING>
+-language="SQL"
+-code="STRUCT(x + 5, SUBSTR(y, 0, 10))"
+-function_expression=
  +-MakeStruct
    +-type=STRUCT<x INT64, y STRING>
    +-field_list=
      +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
      | +-ArgumentRef(type=INT64, name="x")
      | +-Literal(type=INT64, value=5)
      +-FunctionCall(ZetaSQL:substr(STRING, INT64, optional(1) INT64) -> STRING)
        +-ArgumentRef(type=STRING, name="y")
        +-Literal(type=INT64, value=0)
        +-Literal(type=INT64, value=10)
==

# Struct return type with field type coercion (b/28942765).
CREATE TEMPORARY FUNCTION MakeStruct(x INT64, y STRING)
RETURNS STRUCT<x INT64, y STRING> AS ({{STRUCT|}}(CAST(x AS INT32), y));
--
ALTERNATION GROUP: STRUCT
--
CreateFunctionStmt
+-name_path=MakeStruct
+-create_scope=CREATE_TEMP
+-has_explicit_return_type=TRUE
+-return_type=STRUCT<x INT64, y STRING>
+-argument_name_list=[x, y]
+-signature=(INT64 x, STRING y) -> STRUCT<x INT64, y STRING>
+-language="SQL"
+-code="STRUCT(CAST(x AS INT32), y)"
+-function_expression=
  +-MakeStruct
    +-type=STRUCT<x INT64, y STRING>
    +-field_list=
      +-Cast(INT32 -> INT64)
      | +-Cast(INT64 -> INT32)
      |   +-ArgumentRef(type=INT64, name="x")
      +-ArgumentRef(type=STRING, name="y")
--
ALTERNATION GROUP: <empty>
--
CreateFunctionStmt
+-name_path=MakeStruct
+-create_scope=CREATE_TEMP
+-has_explicit_return_type=TRUE
+-return_type=STRUCT<x INT64, y STRING>
+-argument_name_list=[x, y]
+-signature=(INT64 x, STRING y) -> STRUCT<x INT64, y STRING>
+-language="SQL"
+-code="(CAST(x AS INT32), y)"
+-function_expression=
  +-MakeStruct
    +-type=STRUCT<x INT64, y STRING>
    +-field_list=
      +-Cast(INT32 -> INT64)
      | +-Cast(INT64 -> INT32)
      |   +-ArgumentRef(type=INT64, name="x")
      +-ArgumentRef(type=STRING, name="y")
==

# Struct return type with field type coercion (b/28942765).
CREATE TEMPORARY FUNCTION StructFromLarger(first INT64, second INT64)
RETURNS STRUCT<x DOUBLE> AS
(IF(first > second, STRUCT(first), STRUCT(second)));
--
CreateFunctionStmt
+-name_path=StructFromLarger
+-create_scope=CREATE_TEMP
+-has_explicit_return_type=TRUE
+-return_type=STRUCT<x DOUBLE>
+-argument_name_list=[first, second]
+-signature=(INT64 first, INT64 second) -> STRUCT<x DOUBLE>
+-language="SQL"
+-code="IF(first > second, STRUCT(first), STRUCT(second))"
+-function_expression=
  +-Cast(STRUCT<first INT64> -> STRUCT<x DOUBLE>)
    +-FunctionCall(ZetaSQL:if(BOOL, STRUCT<first INT64>, STRUCT<first INT64>) -> STRUCT<first INT64>)
      +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
      | +-ArgumentRef(type=INT64, name="first")
      | +-ArgumentRef(type=INT64, name="second")
      +-MakeStruct
      | +-type=STRUCT<first INT64>
      | +-field_list=
      |   +-ArgumentRef(type=INT64, name="first")
      +-MakeStruct
        +-type=STRUCT<first INT64>
        +-field_list=
          +-ArgumentRef(type=INT64, name="second")
==

# Struct return type without possible coercion (b/28942765).
CREATE TEMPORARY FUNCTION MakeStruct(x INT64, y STRING)
RETURNS STRUCT<x INT64, y STRING> AS (STRUCT(3.14 AS x, b"foo" AS y));
--
ERROR: Function declared to return STRUCT<x INT64, y STRING> but the function body produces incompatible type STRUCT<x DOUBLE, y BYTES> [at 2:39]
RETURNS STRUCT<x INT64, y STRING> AS (STRUCT(3.14 AS x, b"foo" AS y));
                                      ^
==

# SQL function with sub-select.
CREATE TEMPORARY FUNCTION CountPositiveElements(arr ARRAY<INT64>)
RETURNS INT64 AS ((SELECT COUNT(*) FROM UNNEST(arr) AS x WHERE x > 0));
--
CreateFunctionStmt
+-name_path=CountPositiveElements
+-create_scope=CREATE_TEMP
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[arr]
+-signature=(ARRAY<INT64> arr) -> INT64
+-language="SQL"
+-code="(SELECT COUNT(*) FROM UNNEST(arr) AS x WHERE x > 0)"
+-function_expression=
  +-SubqueryExpr
    +-type=INT64
    +-subquery_type=SCALAR
    +-subquery=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
          +-AggregateScan
            +-column_list=[$aggregate.$agg1#2]
            +-input_scan=
            | +-FilterScan
            |   +-column_list=[$array.x#1]
            |   +-input_scan=
            |   | +-ArrayScan
            |   |   +-column_list=[$array.x#1]
            |   |   +-array_expr=
            |   |   | +-ArgumentRef(type=ARRAY<INT64>, name="arr")
            |   |   +-element_column=$array.x#1
            |   +-filter_expr=
            |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            |       +-ColumnRef(type=INT64, column=$array.x#1)
            |       +-Literal(type=INT64, value=0)
            +-aggregate_list=
              +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

# SQL function with aggregate (unsupported).
CREATE TEMPORARY FUNCTION SumTimesTwo(x INT64)
RETURNS INT64 AS (SUM(x * 2));
--
ERROR: Aggregate function SUM not allowed in SQL function body [at 2:19]
RETURNS INT64 AS (SUM(x * 2));
                  ^
==

# Multiple arguments including stuct and array types.
create function
  mypackage.myfunc( a int32, b struct<x string, y int32>, c array<boolean> )
  returns string language testlang ;
--
CreateFunctionStmt(name_path=mypackage.myfunc, has_explicit_return_type=TRUE, return_type=STRING, argument_name_list=[a, b, c], signature=(INT32 a, STRUCT<x STRING, y INT32> b, ARRAY<BOOL> c) -> STRING, language="testlang")
==

# Duplicate argument names
create function
  mypackage.myfunc( a int32, a struct<x string, y int32>)
  returns string language testlang ;
--
ERROR: Duplicate argument name a [at 2:30]
  mypackage.myfunc( a int32, a struct<x string, y int32>)
                             ^
==

# Duplicate argument names with mixed case spelling
create function
  mypackage.myfunc(DummYArG int32, duMMyARg string)
  returns string language testlang ;
--
ERROR: Duplicate argument name duMMyARg [at 2:36]
  mypackage.myfunc(DummYArG int32, duMMyARg string)
                                   ^
==

# Multi-line function body.
create function fn( s string )
returns string language testlang
as """ return
  "presto!" + s + '\n';
"""
--
CreateFunctionStmt(name_path=fn, has_explicit_return_type=TRUE, return_type=STRING, argument_name_list=[s], signature=(STRING s) -> STRING, language="testlang", code=" return\n  \"presto!\" + s + '\n';\n")
==

# Incorrect use of parentheses around the function body.
create function fn( s string )
returns string language testlang
as (""" return
  "presto!" + s + '\n';
""")
--
ERROR: Function body should not be enclosed in ( ) for non-SQL functions [at 3:4]
as (""" return
   ^
==

create function fn( s string )
returns string language testlang
as (1+2)
--
ERROR: Function cannot specify a LANGUAGE and include a SQL body [at 1:1]
create function fn( s string )
^
==

# Function with options.
create function fn( s string )
returns string language testlang as "return 'a';"
options ( a=b, bruce=lee, c=@test_param_string ) ;
--
CreateFunctionStmt
+-name_path=fn
+-has_explicit_return_type=TRUE
+-return_type=STRING
+-argument_name_list=[s]
+-signature=(STRING s) -> STRING
+-language="testlang"
+-code="return 'a';"
+-option_list=
  +-a := Literal(type=STRING, value="b")
  +-bruce := Literal(type=STRING, value="lee")
  +-c := Parameter(type=STRING, name="test_param_string")
==

# Function missing parameter names.
create function fn( a int32, string ) returns string
language testlang as "return 's';"
--
ERROR: Parameters in function declarations must include both name and type [at 1:30]
create function fn( a int32, string ) returns string
                             ^
==

# function declarations must specify names for parameters.
create function fn(my.path.s);
--
ERROR: Parameters in function declarations must include both name and type [at 1:20]
create function fn(my.path.s);
                   ^
==

# functions may use multi-element paths for parameter types. In this case,
# the type was not found.
create function fn(foo my.path.s);
--
ERROR: Type not found: my.path.s [at 1:24]
create function fn(foo my.path.s);
                       ^
==

# functions may use multi-element paths for parameter types.
create function fn(foo zetasql_test__.KeyValueStruct)
  returns string language testlang ;
--
CreateFunctionStmt(name_path=fn, has_explicit_return_type=TRUE, return_type=STRING, argument_name_list=[foo], signature=(PROTO<zetasql_test__.KeyValueStruct> foo) -> STRING, language="testlang")
==

# Scalar functions cannot accept table-valued arguments.
create function fn(s table<t string>)
returns string language testlang as "return 'a';"
options ( a=b, bruce=lee ) ;
--
ERROR: TABLE parameters are not allowed in CREATE FUNCTION statement [at 1:20]
create function fn(s table<t string>)
                   ^
==

# Scalar functions cannot return table-valued types.
create function fn(s string)
returns table;
--
ERROR: Type not found: table [at 2:9]
returns table;
        ^
==

# An initial test with AS alias, showing that the statement fails resolution
# if present.
create function fn(s string as T) returns string;
--
ERROR: Non-templated arguments in function declarations do not support type aliases [at 1:29]
create function fn(s string as T) returns string;
                            ^
==

create function fn(s ANY TYPE as T) returns string;
--
ERROR: Templated arguments with type aliases are not supported yet [at 1:31]
create function fn(s ANY TYPE as T) returns string;
                              ^
==

# ANY TYPE is supported when the function has a SQL body. ZetaSQL sets the
# language field to "SQL" and the "code" field to contain the SQL body in this
# case.
create function f(x any type) as (1);
--
CreateFunctionStmt(name_path=f, return_type=STRUCT<>, argument_name_list=[x], signature=(ANY TYPE x) -> ANY TYPE, language="SQL", code="1")
==

# Since the body is not resolved, deprecation warnings aren't propagated until
# the function is called.
create function f(x any type) as (deprecation_warning())
--
CreateFunctionStmt(name_path=f, return_type=STRUCT<>, argument_name_list=[x], signature=(ANY TYPE x) -> ANY TYPE, language="SQL", code="deprecation_warning()")
==

# Multiple arguments of type ANY TYPE.
create function f(x any type, y any type) as (1);
--
CreateFunctionStmt(name_path=f, return_type=STRUCT<>, argument_name_list=[x, y], signature=(ANY TYPE x, ANY TYPE y) -> ANY TYPE, language="SQL", code="1")
==

# The SQL body can refer to the names of function arguments of type ANY TYPE.
create function f(x any type, y int64) as (x + y);
--
CreateFunctionStmt(name_path=f, return_type=STRUCT<>, argument_name_list=[x, y], signature=(ANY TYPE x, INT64 y) -> ANY TYPE, language="SQL", code="x + y")
==

# ANY TYPE parameters are allowed with the RETURNS clause.
create function f(x any type, y int64)
  returns string
  as (cast(x + y as string));
--
CreateFunctionStmt(name_path=f, has_explicit_return_type=TRUE, return_type=STRING, argument_name_list=[x, y], signature=(ANY TYPE x, INT64 y) -> STRING, language="SQL", code="cast(x + y as string)")
==

# ANY TYPE parameters are not allowed with the LANGUAGE clause if no RETURNS
# clause is also present.
create function f(x any type)
  language testlang
    as """ return
      "presto!" + s + '\n';
    """
--
ERROR: Non-SQL functions must specify a return type [at 1:1]
create function f(x any type)
^
==

# ANY TYPE parameters are allowed with the LANGUAGE clause.
create function f(x any type)
  returns string language testlang
    as """ return
      "presto!" + s + '\n';
    """
--
CreateFunctionStmt(name_path=f, has_explicit_return_type=TRUE, return_type=STRING, argument_name_list=[x], signature=(ANY TYPE x) -> STRING, language="testlang", code=" return\n      \"presto!\" + s + '\n';\n    ")
==

# ANY TYPE parameters are allowed with CREATE OR REPLACE and the LANGUAGE
# clause.
create or replace function f(x any type)
  returns string language testlang
    as """ return
      "presto!" + s + '\n';
    """
--
CreateFunctionStmt(name_path=f, create_mode=CREATE_OR_REPLACE, has_explicit_return_type=TRUE, return_type=STRING, argument_name_list=[x], signature=(ANY TYPE x) -> STRING, language="testlang", code=" return\n      \"presto!\" + s + '\n';\n    ")
==

# ANY TYPE parameters are allowed with IF NOT EXISTS and the LANGUAGE
# clause.
create function if not exists f(x any type)
  returns string language testlang
    as """ return
      "presto!" + s + '\n';
    """
--
CreateFunctionStmt(name_path=f, create_mode=CREATE_IF_NOT_EXISTS, has_explicit_return_type=TRUE, return_type=STRING, argument_name_list=[x], signature=(ANY TYPE x) -> STRING, language="testlang", code=" return\n      \"presto!\" + s + '\n';\n    ")
==

# ANY TYPE parameters with type aliases are not supported yet.
create function f(x any type as type_alias, y type_alias);
--
ERROR: Templated arguments with type aliases are not supported yet [at 1:30]
create function f(x any type as type_alias, y type_alias);
                             ^
==

# A SQL body is not allowed with the LANGUAGE clause.
create function f(x any type, y int64)
  returns string language testlang
  as (x + y);
--
ERROR: Function cannot specify a LANGUAGE and include a SQL body [at 1:1]
create function f(x any type, y int64)
^
==

# ZetaSQL returns an error in the presence of ANY TYPE parameters if the
# language feature is disabled.
[language_features=]
create function f(x any type, y int64) as (x + y);
--
ERROR: Functions with templated arguments are not supported [at 1:21]
create function f(x any type, y int64) as (x + y);
                    ^
==

# We don't allow explicit LANGUAGE SQL.
create function myfunc()
  returns int64
  language SQL
    as """5""";
--
ERROR: To write SQL functions, omit the LANGUAGE clause and write the function body using 'AS (expression)' [at 3:12]
  language SQL
           ^
==

# ST_GeogFromText requires constant as second argument.
[language_features=GEOGRAPHY]
create function myfunc(a string, b boolean) as (st_geogfromtext(a, b));
--
ERROR: Argument 2 to ST_GEOGFROMTEXT must be a literal or query parameter [at 1:68]
create function myfunc(a string, b boolean) as (st_geogfromtext(a, b));
                                                                   ^
==

create {{PUBLIC|PRIVATE|TEMP|}} function fn() returns bool sql security {{INVOKER|DEFINER}} as (true);
--
ALTERNATION GROUP: PUBLIC,INVOKER
--
ERROR: CREATE FUNCTION with PUBLIC or PRIVATE modifiers is not supported [at 1:1]
create PUBLIC function fn() returns bool sql security INVOKER as (true);
^
--
ALTERNATION GROUP: PUBLIC,DEFINER
--
ERROR: CREATE FUNCTION with PUBLIC or PRIVATE modifiers is not supported [at 1:1]
create PUBLIC function fn() returns bool sql security DEFINER as (true);
^
--
ALTERNATION GROUP: PRIVATE,INVOKER
--
ERROR: CREATE FUNCTION with PUBLIC or PRIVATE modifiers is not supported [at 1:1]
create PRIVATE function fn() returns bool sql security INVOKER as (true);
^
--
ALTERNATION GROUP: PRIVATE,DEFINER
--
ERROR: CREATE FUNCTION with PUBLIC or PRIVATE modifiers is not supported [at 1:1]
create PRIVATE function fn() returns bool sql security DEFINER as (true);
^
--
ALTERNATION GROUP: TEMP,INVOKER
--
ERROR: SQL SECURITY clause is not supported on statements with the TEMP modifier. [at 1:1]
create TEMP function fn() returns bool sql security INVOKER as (true);
^
--
ALTERNATION GROUP: TEMP,DEFINER
--
ERROR: SQL SECURITY clause is not supported on statements with the TEMP modifier. [at 1:1]
create TEMP function fn() returns bool sql security DEFINER as (true);
^
--
ALTERNATION GROUP: INVOKER
--
CreateFunctionStmt
+-name_path=fn
+-has_explicit_return_type=TRUE
+-return_type=BOOL
+-signature=() -> BOOL
+-language="SQL"
+-code="true"
+-function_expression=
| +-Literal(type=BOOL, value=true)
+-sql_security=SQL_SECURITY_INVOKER
--
ALTERNATION GROUP: DEFINER
--
CreateFunctionStmt
+-name_path=fn
+-has_explicit_return_type=TRUE
+-return_type=BOOL
+-signature=() -> BOOL
+-language="SQL"
+-code="true"
+-function_expression=
| +-Literal(type=BOOL, value=true)
+-sql_security=SQL_SECURITY_DEFINER
==

# Query parameter is not allowed in function body
create function myfunc(a string)
as (CONCAT(a, @test_string_param));
--
ERROR: Query parameter is not allowed in the body of SQL function 'myfunc': @test_string_param [at 2:15]
as (CONCAT(a, @test_string_param));
              ^
==

# Query parameter is not allowed in templated function body
create function f(x any type)
as (concat(x, @test_string_param));
--
ERROR: Query parameter is not allowed in the body of SQL function 'f': @test_string_param [at 2:15]
as (concat(x, @test_string_param));
              ^
==

# RETURNS ANY TYPE for non-templated function
create function f(x int64)
returns ANY TYPE
AS (x + 1);
--
ERROR: Syntax error: Templated types are not allowed in the RETURNS clause [at 2:9]
returns ANY TYPE
        ^
==

create function f(x ANY TYPE)
returns ANY TYPE
AS (x);
--

ERROR: Syntax error: Templated types are not allowed in the RETURNS clause [at 2:9]
returns ANY TYPE
        ^
==

# Type parameters not supported
create function myfunc (  )
  returns string(10) language testlang ;
--
ERROR: Parameterized types are not supported in function signatures [at 2:17]
  returns string(10) language testlang ;
                ^
==

create function fn( a int32, b string(10) ) returns string
language testlang as "return 's';"
--
ERROR: Parameterized types are not supported in function arguments [at 1:38]
create function fn( a int32, b string(10) ) returns string
                                     ^
==

# Type with collation name is not supported
create function myfunc (  )
  returns string collate 'und:ci' language testlang ;
--
ERROR: Type with collation name is not supported in function signatures [at 2:18]
  returns string collate 'und:ci' language testlang ;
                 ^
==

create function fn( a int32, b string 'und:ci' ) returns string
language testlang as "return 's';"
--
ERROR: Syntax error: Expected ")" or "," but got string literal 'und:ci' [at 1:39]
create function fn( a int32, b string 'und:ci' ) returns string
                                      ^
