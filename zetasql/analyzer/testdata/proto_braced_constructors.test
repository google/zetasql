# Tests for resolving proto braced constructors.
#

[default language_features=V_1_3_BRACED_PROTO_CONSTRUCTORS,V_1_1_CAST_DIFFERENT_ARRAY_TYPES,V_1_2_PROTO_EXTENSIONS_WITH_NEW,V_1_1_WITH_ON_SUBQUERY,V_1_3_WITH_RECURSIVE]

[language_features=]
SELECT NEW zetasql_test__.TestExtraPB {}
--
ERROR: Braced constructors are not supported [at 1:39]
SELECT NEW zetasql_test__.TestExtraPB {}
                                      ^
==

[language_features=]
SELECT {}
--
ERROR: Braced constructors are not supported [at 1:8]
SELECT {}
       ^
==

SELECT NEW abc {}
--
ERROR: Type not found: abc [at 1:12]
SELECT NEW abc {}
           ^
==

SELECT NEW INT64{}
--
ERROR: Braced NEW constructors are not allowed for type INT64 [at 1:12]
SELECT NEW INT64{}
           ^
==

# The unparsed SQL uses the old syntax.
[show_unparsed]
SELECT NEW zetasql_test__.TestExtraPB {}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := MakeProto(type=PROTO<zetasql_test__.TestExtraPB>)
    +-input_scan=
      +-SingleRowScan

[UNPARSED_SQL]
SELECT
  NEW `zetasql_test__.TestExtraPB`() AS a_1;
==

# Error using braced constructors without an inferred type.
SELECT { abc: 1 }
--
ERROR: Unable to infer a type for braced constructor [at 1:8]
SELECT { abc: 1 }
       ^
==

# A simple field + string array example.
SELECT NEW zetasql_test__.TestExtraPB {int32_val2: 5
                                      str_value: ["abc", "def"]}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.TestExtraPB>
    |     +-field_list=
    |       +-int32_val2 := Literal(type=INT32, value=5)
    |       +-str_value := Literal(type=ARRAY<STRING>, value=["abc", "def"])
    +-input_scan=
      +-SingleRowScan
==

# An integer array example.
SELECT NEW zetasql_test__.KitchenSinkPB {
    int64_key_1: 1
    int64_key_2: 2
    repeated_int32_val: [1, 2]
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_1 := Literal(type=INT64, value=1)
    |       +-int64_key_2 := Literal(type=INT64, value=2)
    |       +-repeated_int32_val := Literal(type=ARRAY<INT32>, value=[1, 2])
    +-input_scan=
      +-SingleRowScan
==

# Nested sub-message example.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value {
    nested_int64: 10
  }
}
--

QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_1 := Literal(type=INT64, value=1)
    |       +-int64_key_2 := Literal(type=INT64, value=2)
    |       +-nested_value :=
    |         +-MakeProto
    |           +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |           +-field_list=
    |             +-nested_int64 := Literal(type=INT64, value=10)
    +-input_scan=
      +-SingleRowScan
==

# Nested repeated sub-message example.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_repeated_value: [{
    nested_int64: 10
    nested_repeated_int64: [100, 200]
  }, {
    nested_int64: 20
    nested_repeated_int64: [300, 400]
  }]
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_1 := Literal(type=INT64, value=1)
    |       +-int64_key_2 := Literal(type=INT64, value=2)
    |       +-nested_repeated_value :=
    |         +-FunctionCall(ZetaSQL:$make_array(repeated(2) PROTO<zetasql_test__.KitchenSinkPB.Nested>) -> ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>)
    |           +-MakeProto
    |           | +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |           | +-field_list=
    |           |   +-nested_int64 := Literal(type=INT64, value=10)
    |           |   +-nested_repeated_int64 := Literal(type=ARRAY<INT64>, value=[100, 200])
    |           +-MakeProto
    |             +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |             +-field_list=
    |               +-nested_int64 := Literal(type=INT64, value=20)
    |               +-nested_repeated_int64 := Literal(type=ARRAY<INT64>, value=[300, 400])
    +-input_scan=
      +-SingleRowScan
==

# Map fields example.
SELECT NEW zetasql_test__.MessageWithMapField {
  string_int32_map: [{
    key: "foo"
    value: 10
  }, {
    key: "bar"
    value: 20
  }]
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.MessageWithMapField>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.MessageWithMapField>
    |     +-field_list=
    |       +-string_int32_map :=
    |         +-FunctionCall(ZetaSQL:$make_array(repeated(2) PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>) -> ARRAY<PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>>)
    |           +-MakeProto
    |           | +-type=PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>
    |           | +-field_list=
    |           |   +-key := Literal(type=STRING, value="foo")
    |           |   +-value := Literal(type=INT32, value=10)
    |           +-MakeProto
    |             +-type=PROTO<zetasql_test__.MessageWithMapField.StringInt32MapEntry>
    |             +-field_list=
    |               +-key := Literal(type=STRING, value="bar")
    |               +-value := Literal(type=INT32, value=20)
    +-input_scan=
      +-SingleRowScan
==

# Extensions test.
SELECT NEW zetasql_test__.TestExtraPB {
     (zetasql_test__.TestExtraPBExtensionHolder.test_extra_proto_extension) {
         ext_value: [1]
     }
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.TestExtraPB>
    |     +-field_list=
    |       +-[zetasql_test__.TestExtraPBExtensionHolder.test_extra_proto_extension] :=
    |         +-MakeProto
    |           +-type=PROTO<zetasql_test__.TestExtraPBExtensionHolder>
    |           +-field_list=
    |             +-ext_value := Literal(type=ARRAY<INT32>, value=[1])
    +-input_scan=
      +-SingleRowScan
==

# Another example with extensions, this time with a regular field too.
SELECT NEW zetasql_test__.TestExtraPB {
    int32_val1: 5,
    (zetasql_test__.TestExtraPBExtensionHolder.test_extra_proto_extension) {
        ext_value: [1]
    }
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.TestExtraPB>
    |     +-field_list=
    |       +-int32_val1 := Literal(type=INT32, value=5)
    |       +-[zetasql_test__.TestExtraPBExtensionHolder.test_extra_proto_extension] :=
    |         +-MakeProto
    |           +-type=PROTO<zetasql_test__.TestExtraPBExtensionHolder>
    |           +-field_list=
    |             +-ext_value := Literal(type=ARRAY<INT32>, value=[1])
    +-input_scan=
      +-SingleRowScan
==

# Another example with extensions, this time with two other regular fields.
SELECT NEW zetasql_test__.TestExtraPB {
    str_value: ["foo"]
    int32_val1: 5,
    (zetasql_test__.TestExtraPBExtensionHolder.test_extra_proto_extension) {
        ext_value: [1]
    }
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.TestExtraPB>
    |     +-field_list=
    |       +-str_value := Literal(type=ARRAY<STRING>, value=["foo"])
    |       +-int32_val1 := Literal(type=INT32, value=5)
    |       +-[zetasql_test__.TestExtraPBExtensionHolder.test_extra_proto_extension] :=
    |         +-MakeProto
    |           +-type=PROTO<zetasql_test__.TestExtraPBExtensionHolder>
    |           +-field_list=
    |             +-ext_value := Literal(type=ARRAY<INT32>, value=[1])
    +-input_scan=
      +-SingleRowScan
==

# Missing extension field name. This error is detected by shared code that is
# more thoroughly tested by the examples in proto_extensions.test. Here we are
# just testing that the code for NEW handles errors from that shared code
# correctly.
SELECT NEW zetasql_test__.TestExtraPB {
    (zetasql_test__.TestExtraPBExtensionHolder) {
       ext_value: 1
    }
}
--
ERROR: Expected extension name of the form (MessageName.extension_field_name), but zetasql_test__.TestExtraPBExtensionHolder is a full message name.  Add the extension field name. [at 2:6]
    (zetasql_test__.TestExtraPBExtensionHolder) {
     ^
==

# Example using expression for the leaf values.
SELECT NEW zetasql_test__.TestExtraPB {int32_val1: coalesce(4)
                                      int32_val2: cast(4 as uint64)}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.TestExtraPB>
    |     +-field_list=
    |       +-int32_val1 :=
    |       | +-Cast(INT64 -> INT32)
    |       |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) INT64) -> INT64)
    |       |     +-Literal(type=INT64, value=4)
    |       +-int32_val2 := Literal(type=INT32, value=4, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Example using a sub-query.
SELECT NEW zetasql_test__.TestExtraPB {
  int32_val1: (SELECT key FROM TestTable)
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.TestExtraPB>
    |     +-field_list=
    |       +-int32_val1 :=
    |         +-SubqueryExpr
    |           +-type=INT32
    |           +-subquery_type=SCALAR
    |           +-subquery=
    |             +-ProjectScan
    |               +-column_list=[TestTable.key#1]
    |               +-input_scan=
    |                 +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
    +-input_scan=
      +-SingleRowScan
==

# Non-scalar subquery.
SELECT NEW zetasql_test__.TestExtraPB {
  int32_val1: (SELECT TestTable.* FROM TestTable)
}
--
ERROR: Scalar subquery cannot have more than one column unless using SELECT AS STRUCT to build STRUCT values [at 2:15]
  int32_val1: (SELECT TestTable.* FROM TestTable)
              ^
==

# Invalid field test.
SELECT NEW zetasql_test__.KitchenSinkPB {xxxxx: 5}
--
ERROR: Field 1 has name xxxxx which is not a field in proto zetasql_test__.KitchenSinkPB [at 1:42]
SELECT NEW zetasql_test__.KitchenSinkPB {xxxxx: 5}
                                         ^
==

# Filling proto fields from an external query.
SELECT NEW zetasql_test__.TestExtraPB {int32_val1: t.int32_val1
                                      int32_val2: t.int32_val2}
from (SELECT 1 int32_val1, 2 int32_val2) t
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.TestExtraPB>
    |     +-field_list=
    |       +-int32_val1 :=
    |       | +-Cast(INT64 -> INT32)
    |       |   +-ColumnRef(type=INT64, column=t.int32_val1#1)
    |       +-int32_val2 :=
    |         +-Cast(INT64 -> INT32)
    |           +-ColumnRef(type=INT64, column=t.int32_val2#2)
    +-input_scan=
      +-ProjectScan
        +-column_list=t.[int32_val1#1, int32_val2#2]
        +-expr_list=
        | +-int32_val1#1 := Literal(type=INT64, value=1)
        | +-int32_val2#2 := Literal(type=INT64, value=2)
        +-input_scan=
          +-SingleRowScan
==

# Mixing with aggregation.
# ANY_VALUE is necessary here because we don't detect it is the same
# expression as shows up in GROUP BY.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: ANY_VALUE(KitchenSink.int64_key_1)
  int64_key_2: ANY_VALUE(KitchenSink.int64_key_2)
  int64_val: count(*)
  uint64_val: sum(length(KitchenSink.string_val))
  repeated_string_val: array_agg(KitchenSink.string_val)}
from TestTable
group by KitchenSink.int64_key_1, KitchenSink.int64_key_2
--
QueryStmt
+-output_column_list=
| +-$query.$col1#11 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#11]
    +-expr_list=
    | +-$col1#11 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_1 := ColumnRef(type=INT64, column=$aggregate.$agg1#4)
    |       +-int64_key_2 := ColumnRef(type=INT64, column=$aggregate.$agg2#5)
    |       +-int64_val := ColumnRef(type=INT64, column=$aggregate.$agg3#6)
    |       +-uint64_val :=
    |       | +-Cast(INT64 -> UINT64)
    |       |   +-ColumnRef(type=INT64, column=$aggregate.$agg4#7)
    |       +-repeated_string_val := ColumnRef(type=ARRAY<STRING>, column=$aggregate.$agg5#8)
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#4, $agg2#5, $agg3#6, $agg4#7, $agg5#8]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-group_by_list=
        | +-int64_key_1#9 :=
        | | +-GetProtoField
        | |   +-type=INT64
        | |   +-expr=
        | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        | |   +-field_descriptor=int64_key_1
        | +-int64_key_2#10 :=
        |   +-GetProtoField
        |     +-type=INT64
        |     +-expr=
        |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |     +-field_descriptor=int64_key_2
        +-aggregate_list=
          +-$agg1#4 :=
          | +-AggregateFunctionCall(ZetaSQL:any_value(INT64) -> INT64)
          |   +-GetProtoField
          |     +-type=INT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int64_key_1
          +-$agg2#5 :=
          | +-AggregateFunctionCall(ZetaSQL:any_value(INT64) -> INT64)
          |   +-GetProtoField
          |     +-type=INT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int64_key_2
          +-$agg3#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
          +-$agg4#7 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
          |     +-GetProtoField
          |       +-type=STRING
          |       +-expr=
          |       | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |       +-field_descriptor=string_val
          |       +-default_value="default_name"
          +-$agg5#8 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(STRING) -> ARRAY<STRING>)
              +-GetProtoField
                +-type=STRING
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=string_val
                +-default_value="default_name"
==

# Mixing with other expressions.
SELECT 1 + NEW zetasql_test__.TestExtraPB {int32_val1: 5}.int32_val1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Literal(type=INT64, value=1)
    |     +-Cast(INT32 -> INT64)
    |       +-GetProtoField
    |         +-type=INT32
    |         +-expr=
    |         | +-MakeProto
    |         |   +-type=PROTO<zetasql_test__.TestExtraPB>
    |         |   +-field_list=
    |         |     +-int32_val1 := Literal(type=INT32, value=5)
    |         +-field_descriptor=int32_val1
    |         +-default_value=0
    +-input_scan=
      +-SingleRowScan
==

# Untyped constructor.
UPDATE TestTable SET KitchenSink = {
  int64_key_1: 1
  int64_key_2: 2
  test_enum: 'TESTENUM1'
}
WHERE TRUE;
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-column_access_list=WRITE
+-where_expr=
| +-Literal(type=BOOL, value=true)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    +-set_value=
      +-DMLValue
        +-value=
          +-MakeProto
            +-type=PROTO<zetasql_test__.KitchenSinkPB>
            +-field_list=
              +-int64_key_1 := Literal(type=INT64, value=1)
              +-int64_key_2 := Literal(type=INT64, value=2)
              +-test_enum := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
==

# Array constructor.
SELECT ARRAY<zetasql_test__.TestExtraPB>[{
    str_value: ["foo", "bar"]
  }, {
    str_value: ["baz"]
  }]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<PROTO<zetasql_test__.TestExtraPB>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$make_array(repeated(2) PROTO<zetasql_test__.TestExtraPB>) -> ARRAY<PROTO<zetasql_test__.TestExtraPB>>)
    |     +-MakeProto
    |     | +-type=PROTO<zetasql_test__.TestExtraPB>
    |     | +-field_list=
    |     |   +-str_value := Literal(type=ARRAY<STRING>, value=["foo", "bar"])
    |     +-MakeProto
    |       +-type=PROTO<zetasql_test__.TestExtraPB>
    |       +-field_list=
    |         +-str_value := Literal(type=ARRAY<STRING>, value=["baz"])
    +-input_scan=
      +-SingleRowScan
==

# Untyped array constructor.
UPDATE ArrayTypes SET ProtoArray = [{
    str_value: ["foo", "bar"] }, { str_value: ["baz"] }, NULL, {}]
WHERE TRUE;
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=[ArrayTypes.ProtoArray#15], table=ArrayTypes, column_index_list=[14])
+-column_access_list=WRITE
+-where_expr=
| +-Literal(type=BOOL, value=true)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=ARRAY<PROTO<zetasql_test__.TestExtraPB>>, column=ArrayTypes.ProtoArray#15)
    +-set_value=
      +-DMLValue
        +-value=
          +-FunctionCall(ZetaSQL:$make_array(repeated(4) PROTO<zetasql_test__.TestExtraPB>) -> ARRAY<PROTO<zetasql_test__.TestExtraPB>>)
            +-MakeProto
            | +-type=PROTO<zetasql_test__.TestExtraPB>
            | +-field_list=
            |   +-str_value := Literal(type=ARRAY<STRING>, value=["foo", "bar"])
            +-MakeProto
            | +-type=PROTO<zetasql_test__.TestExtraPB>
            | +-field_list=
            |   +-str_value := Literal(type=ARRAY<STRING>, value=["baz"])
            +-Literal(type=PROTO<zetasql_test__.TestExtraPB>, value=NULL)
            +-MakeProto(type=PROTO<zetasql_test__.TestExtraPB>)
==

# Non-array inferred type for array constructor, inferred type is ignored.
UPDATE TestTable SET KitchenSink = [{}]
WHERE TRUE;
--
ERROR: Unable to infer a type for braced constructor [at 1:37]
UPDATE TestTable SET KitchenSink = [{}]
                                    ^
==

# Non-array inferred type for array constructor, inferred type is ignored.
UPDATE TestTable SET KitchenSink = [1, 2]
WHERE TRUE;
--
ERROR: Value of type ARRAY<INT64> cannot be assigned to KitchenSink, which has type zetasql_test__.KitchenSinkPB [at 1:36]
UPDATE TestTable SET KitchenSink = [1, 2]
                                   ^
==

# Simple STRUCT constructor.
SELECT STRUCT<INT64, zetasql_test__.KitchenSinkPB>(1, { int64_key_1: 1 int64_key_2: 2 })
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<INT64, PROTO<zetasql_test__.KitchenSinkPB>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeStruct
    |     +-type=STRUCT<INT64, PROTO<zetasql_test__.KitchenSinkPB>>
    |     +-field_list=
    |       +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |       +-MakeProto
    |         +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |         +-field_list=
    |           +-int64_key_1 := Literal(type=INT64, value=1)
    |           +-int64_key_2 := Literal(type=INT64, value=2)
    +-input_scan=
      +-SingleRowScan
==

# Struct constructors with type specified in nested constructor.
UPDATE StructWithKitchenSinkTable SET s =
  STRUCT<zetasql_test__.KitchenSinkPB,
        STRUCT<zetasql_test__.KitchenSinkPB>>(
          { int64_key_1: 1 int64_key_2: 2 },
          STRUCT<zetasql_test__.KitchenSinkPB>(
            { int64_key_1: 10 int64_key_2: 20 }))
WHERE TRUE;
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=[StructWithKitchenSinkTable.s#2], table=StructWithKitchenSinkTable, column_index_list=[1])
+-column_access_list=WRITE
+-where_expr=
| +-Literal(type=BOOL, value=true)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>, s STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>, column=StructWithKitchenSinkTable.s#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-MakeStruct
            +-type=STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>, s STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>
            +-field_list=
              +-MakeProto
              | +-type=PROTO<zetasql_test__.KitchenSinkPB>
              | +-field_list=
              |   +-int64_key_1 := Literal(type=INT64, value=1)
              |   +-int64_key_2 := Literal(type=INT64, value=2)
              +-MakeStruct
                +-type=STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>
                +-field_list=
                  +-MakeProto
                    +-type=PROTO<zetasql_test__.KitchenSinkPB>
                    +-field_list=
                      +-int64_key_1 := Literal(type=INT64, value=10)
                      +-int64_key_2 := Literal(type=INT64, value=20)
==

# Struct constructors with type not specified in nested constructor, it is
# inferred from the STRUCT field definition.
UPDATE StructWithKitchenSinkTable SET s =
  STRUCT<zetasql_test__.KitchenSinkPB, STRUCT<zetasql_test__.KitchenSinkPB>>(
      { int64_key_1: 1 int64_key_2: 2 },
      STRUCT({ int64_key_1: 10 int64_key_2: 20 }))
WHERE TRUE;
--
[SAME AS PREVIOUS]
==

# Untyped nested struct constructor.
UPDATE StructWithKitchenSinkTable SET s = (
      { int64_key_1: 1 int64_key_2: 2 },
      STRUCT({ int64_key_1: 10 int64_key_2: 20 }))
WHERE TRUE;
--
[SAME AS PREVIOUS]
==

# Struct of array of struct.
UPDATE StructWithKitchenSinkTable SET t =
  STRUCT<INT64, ARRAY<STRUCT<zetasql_test__.KitchenSinkPB>>>(
    1,
    [STRUCT({ int64_key_1: 1 int64_key_2: 2 }),
     STRUCT({ int64_key_1: 10 int64_key_2: 20 })]
  )
WHERE TRUE;
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=[StructWithKitchenSinkTable.t#3], table=StructWithKitchenSinkTable, column_index_list=[2])
+-column_access_list=WRITE
+-where_expr=
| +-Literal(type=BOOL, value=true)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRUCT<a INT64, b ARRAY<STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>>, column=StructWithKitchenSinkTable.t#3)
    +-set_value=
      +-DMLValue
        +-value=
          +-MakeStruct
            +-type=STRUCT<a INT64, b ARRAY<STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>>
            +-field_list=
              +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
              +-Cast(ARRAY<STRUCT<PROTO<zetasql_test__.KitchenSinkPB>>> -> ARRAY<STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>)
                +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRUCT<PROTO<zetasql_test__.KitchenSinkPB>>) -> ARRAY<STRUCT<PROTO<zetasql_test__.KitchenSinkPB>>>)
                  +-MakeStruct
                  | +-type=STRUCT<PROTO<zetasql_test__.KitchenSinkPB>>
                  | +-field_list=
                  |   +-MakeProto
                  |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
                  |     +-field_list=
                  |       +-int64_key_1 := Literal(type=INT64, value=1)
                  |       +-int64_key_2 := Literal(type=INT64, value=2)
                  +-MakeStruct
                    +-type=STRUCT<PROTO<zetasql_test__.KitchenSinkPB>>
                    +-field_list=
                      +-MakeProto
                        +-type=PROTO<zetasql_test__.KitchenSinkPB>
                        +-field_list=
                          +-int64_key_1 := Literal(type=INT64, value=10)
                          +-int64_key_2 := Literal(type=INT64, value=20)
==

# Untyped struct of array of struct.
UPDATE StructWithKitchenSinkTable SET t = (
    1,
    [STRUCT({ int64_key_1: 1 int64_key_2: 2 }),
     STRUCT({ int64_key_1: 10 int64_key_2: 20 })]
  )
WHERE TRUE;
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=[StructWithKitchenSinkTable.t#3], table=StructWithKitchenSinkTable, column_index_list=[2])
+-column_access_list=WRITE
+-where_expr=
| +-Literal(type=BOOL, value=true)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRUCT<a INT64, b ARRAY<STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>>, column=StructWithKitchenSinkTable.t#3)
    +-set_value=
      +-DMLValue
        +-value=
          +-MakeStruct
            +-type=STRUCT<a INT64, b ARRAY<STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>>
            +-field_list=
              +-Literal(type=INT64, value=1)
              +-Cast(ARRAY<STRUCT<PROTO<zetasql_test__.KitchenSinkPB>>> -> ARRAY<STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>)
                +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRUCT<PROTO<zetasql_test__.KitchenSinkPB>>) -> ARRAY<STRUCT<PROTO<zetasql_test__.KitchenSinkPB>>>)
                  +-MakeStruct
                  | +-type=STRUCT<PROTO<zetasql_test__.KitchenSinkPB>>
                  | +-field_list=
                  |   +-MakeProto
                  |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
                  |     +-field_list=
                  |       +-int64_key_1 := Literal(type=INT64, value=1)
                  |       +-int64_key_2 := Literal(type=INT64, value=2)
                  +-MakeStruct
                    +-type=STRUCT<PROTO<zetasql_test__.KitchenSinkPB>>
                    +-field_list=
                      +-MakeProto
                        +-type=PROTO<zetasql_test__.KitchenSinkPB>
                        +-field_list=
                          +-int64_key_1 := Literal(type=INT64, value=10)
                          +-int64_key_2 := Literal(type=INT64, value=20)
==

# Inferred has too few elements for STRUCT constructor.
UPDATE StructWithKitchenSinkTable SET s = (
      { int64_key_1: 1 int64_key_2: 2 },
      STRUCT({ int64_key_1: 10 int64_key_2: 20 }),
      2, 3)
WHERE TRUE;
--
ERROR: Value of type STRUCT<zetasql_test__.KitchenSinkPB, STRUCT<zetasql_test__.KitchenSinkPB>, INT64, ...> cannot be assigned to s, which has type STRUCT<kitchen_sink zetasql_test__.KitchenSinkPB, s STRUCT<kitchen_sink zetasql_test__.KitchenSinkPB>> [at 1:43]
UPDATE StructWithKitchenSinkTable SET s = (
                                          ^
==

# Incompatible inferred type.
UPDATE StructWithKitchenSinkTable SET s = (
      2,
      STRUCT({ int64_key_1: 10 int64_key_2: 20 }))
WHERE TRUE;
--
ERROR: Value of type STRUCT<INT64, STRUCT<zetasql_test__.KitchenSinkPB>> cannot be assigned to s, which has type STRUCT<kitchen_sink zetasql_test__.KitchenSinkPB, s STRUCT<kitchen_sink zetasql_test__.KitchenSinkPB>> [at 1:43]
UPDATE StructWithKitchenSinkTable SET s = (
                                          ^
==

# Inferred type with struct containing proto.
UPDATE StructWithKitchenSinkTable SET s = (
  { kitchen_sink: {int64_key_1: 1, int64_key_2: 2 }, s:{kitchen_sink: {int64_key_1: 1, int64_key_2: 2 }}})
WHERE TRUE;
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=[StructWithKitchenSinkTable.s#2], table=StructWithKitchenSinkTable, column_index_list=[1])
+-column_access_list=WRITE
+-where_expr=
| +-Literal(type=BOOL, value=true)
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>, s STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>, column=StructWithKitchenSinkTable.s#2)
    +-set_value=
      +-DMLValue
        +-value=
          +-MakeStruct
            +-type=STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>, s STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>>
            +-field_list=
              +-MakeProto
              | +-type=PROTO<zetasql_test__.KitchenSinkPB>
              | +-field_list=
              |   +-int64_key_1 := Literal(type=INT64, value=1)
              |   +-int64_key_2 := Literal(type=INT64, value=2)
              +-MakeStruct
                +-type=STRUCT<kitchen_sink PROTO<zetasql_test__.KitchenSinkPB>>
                +-field_list=
                  +-MakeProto
                    +-type=PROTO<zetasql_test__.KitchenSinkPB>
                    +-field_list=
                      +-int64_key_1 := Literal(type=INT64, value=1)
                      +-int64_key_2 := Literal(type=INT64, value=2)
==

# Mixing old and new proto constructors.
SELECT NEW zetasql_test__.KitchenSinkPB (
  1 AS int64_key_1,
  2 AS int64_key_2,
  { nested_int64: 10 } AS nested_value
)
--

QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_1 := Literal(type=INT64, value=1)
    |       +-int64_key_2 := Literal(type=INT64, value=2)
    |       +-nested_value :=
    |         +-MakeProto
    |           +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |           +-field_list=
    |             +-nested_int64 := Literal(type=INT64, value=10)
    +-input_scan=
      +-SingleRowScan
==

# Infer the type of submessages in REPLACE_FIELDS.
[language_features=V_1_3_BRACED_PROTO_CONSTRUCTORS,V_1_3_REPLACE_FIELDS]
SELECT
  REPLACE_FIELDS(
    KitchenSink, { nested_int64: 1 } AS nested_value
  )
FROM TestTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-ReplaceField
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-replace_field_item_list=
    |       +-ReplaceFieldItem
    |         +-expr=
    |         | +-MakeProto
    |         |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |         |   +-field_list=
    |         |     +-nested_int64 := Literal(type=INT64, value=1)
    |         +-proto_field_path=nested_value
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# Infer the type of the lhs when trying to CAST braced constructors.
SELECT CAST( { nested_int64: 1 } AS zetasql_test__.KitchenSinkPB.Nested);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB.Nested>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |     +-field_list=
    |       +-nested_int64 := Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

# CAST works with arrays of protos as well.
SELECT CAST( [{ nested_int64: 10 }, { nested_int64: 20 }] AS ARRAY<zetasql_test__.KitchenSinkPB.Nested>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$make_array(repeated(2) PROTO<zetasql_test__.KitchenSinkPB.Nested>) -> ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>)
    |     +-MakeProto
    |     | +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |     | +-field_list=
    |     |   +-nested_int64 := Literal(type=INT64, value=10)
    |     +-MakeProto
    |       +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |       +-field_list=
    |         +-nested_int64 := Literal(type=INT64, value=20)
    +-input_scan=
      +-SingleRowScan
==

# Braced constructor type inferred in generated columns.
[language_features=V_1_3_BRACED_PROTO_CONSTRUCTORS,V_1_2_GENERATED_COLUMNS]
[no_enable_literal_replacement]
CREATE TABLE T (
  IntColumn INT32,
  ProtoColumn zetasql_test__.TestExtraPB AS ({int32_val1: IntColumn int32_val2: 5})
)
--
CreateTableStmt
+-name_path=T
+-column_definition_list=
  +-ColumnDefinition(name="IntColumn", type=INT32, column=T.IntColumn#1)
  +-ColumnDefinition
    +-name="ProtoColumn"
    +-type=PROTO<zetasql_test__.TestExtraPB>
    +-column=T.ProtoColumn#2
    +-generated_column_info=
      +-GeneratedColumnInfo
        +-expression=
          +-MakeProto
            +-type=PROTO<zetasql_test__.TestExtraPB>
            +-field_list=
              +-int32_val1 := ColumnRef(type=INT32, column=T.IntColumn#1)
              +-int32_val2 := Literal(type=INT32, value=5)
==

# Braced constructor types inferred in default column value.
[language_features=V_1_3_BRACED_PROTO_CONSTRUCTORS,V_1_3_COLUMN_DEFAULT_VALUE]
[no_enable_literal_replacement]
CREATE TABLE T (
  IntColumn INT32,
  ProtoColumn zetasql_test__.TestExtraPB DEFAULT {int32_val1: 3 int32_val2: 5}
)
--
CreateTableStmt
+-name_path=T
+-column_definition_list=
  +-ColumnDefinition(name="IntColumn", type=INT32, column=T.IntColumn#1)
  +-ColumnDefinition
    +-name="ProtoColumn"
    +-type=PROTO<zetasql_test__.TestExtraPB>
    +-column=T.ProtoColumn#2
    +-default_value=
      +-ColumnDefaultValue
        +-expression=
        | +-MakeProto
        |   +-type=PROTO<zetasql_test__.TestExtraPB>
        |   +-field_list=
        |     +-int32_val1 := Literal(type=INT32, value=3)
        |     +-int32_val2 := Literal(type=INT32, value=5)
        +-sql="{int32_val1: 3 int32_val2: 5}"
==

# Braced constructor type inferred in SQL function body.
CREATE FUNCTION myfunc (  ) RETURNS zetasql_test__.TestExtraPB AS ({int32_val1: 3 int32_val2: 5});
--
CreateFunctionStmt
+-name_path=myfunc
+-has_explicit_return_type=TRUE
+-return_type=PROTO<zetasql_test__.TestExtraPB>
+-signature=() -> PROTO<zetasql_test__.TestExtraPB>
+-language="SQL"
+-code="{int32_val1: 3 int32_val2: 5}"
+-function_expression=
  +-MakeProto
    +-type=PROTO<zetasql_test__.TestExtraPB>
    +-field_list=
      +-int32_val1 := Literal(type=INT32, value=3)
      +-int32_val2 := Literal(type=INT32, value=5)
==

# Braced constructor type without a return type in a SQL function body is an error.
CREATE FUNCTION myfunc (  ) AS ({int32_val1: 3 int32_val2: 5});
--
ERROR: Unable to infer a type for braced constructor [at 1:33]
CREATE FUNCTION myfunc (  ) AS ({int32_val1: 3 int32_val2: 5});
                                ^
==

# Braced constructor type inferred in aggregate SQL function body.
[language_features=V_1_3_BRACED_PROTO_CONSTRUCTORS,CREATE_AGGREGATE_FUNCTION,TEMPLATE_FUNCTIONS]
CREATE AGGREGATE FUNCTION myfunc (  ) RETURNS zetasql_test__.TestExtraPB AS ({int32_val1: 3 int32_val2: 5});
--
CreateFunctionStmt
+-name_path=myfunc
+-has_explicit_return_type=TRUE
+-return_type=PROTO<zetasql_test__.TestExtraPB>
+-signature=() -> PROTO<zetasql_test__.TestExtraPB>
+-is_aggregate=TRUE
+-language="SQL"
+-code="{int32_val1: 3 int32_val2: 5}"
+-function_expression=
  +-MakeProto
    +-type=PROTO<zetasql_test__.TestExtraPB>
    +-field_list=
      +-int32_val1 := Literal(type=INT32, value=3)
      +-int32_val2 := Literal(type=INT32, value=5)
==

# Braced constructor type without a return type in an aggregate SQL function body is an error.
[language_features=V_1_3_BRACED_PROTO_CONSTRUCTORS,CREATE_AGGREGATE_FUNCTION,TEMPLATE_FUNCTIONS]
CREATE AGGREGATE FUNCTION myfunc (  ) AS ({int32_val1: 3 int32_val2: 5});
--
ERROR: Unable to infer a type for braced constructor [at 1:43]
CREATE AGGREGATE FUNCTION myfunc (  ) AS ({int32_val1: 3 int32_val2: 5});
                                          ^
==

# Setting proto system variables works.
SET @@proto_system_variable = {int64_key_1: 1 int64_key_2: 2}
--
AssignmentStmt
+-target=
| +-SystemVariable(proto_system_variable, type=PROTO<zetasql_test__.KitchenSinkPB>)
+-expr=
  +-MakeProto
    +-type=PROTO<zetasql_test__.KitchenSinkPB>
    +-field_list=
      +-int64_key_1 := Literal(type=INT64, value=1)
      +-int64_key_2 := Literal(type=INT64, value=2)
==

# Inferring through a scalar subquery works for array and non-array types.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value: (SELECT { nested_int64: 5 })
  nested_repeated_value: (SELECT ARRAY[{ nested_int64: 6 },{ nested_int64: 7 }])
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_1 := Literal(type=INT64, value=1)
    |       +-int64_key_2 := Literal(type=INT64, value=2)
    |       +-nested_value :=
    |       | +-SubqueryExpr
    |       |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |       |   +-subquery_type=SCALAR
    |       |   +-subquery=
    |       |     +-ProjectScan
    |       |       +-column_list=[$expr_subquery.$col1#1]
    |       |       +-expr_list=
    |       |       | +-$col1#1 :=
    |       |       |   +-MakeProto
    |       |       |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |       |       |     +-field_list=
    |       |       |       +-nested_int64 := Literal(type=INT64, value=5)
    |       |       +-input_scan=
    |       |         +-SingleRowScan
    |       +-nested_repeated_value :=
    |         +-SubqueryExpr
    |           +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
    |           +-subquery_type=SCALAR
    |           +-subquery=
    |             +-ProjectScan
    |               +-column_list=[$expr_subquery.$col1#2]
    |               +-expr_list=
    |               | +-$col1#2 :=
    |               |   +-FunctionCall(ZetaSQL:$make_array(repeated(2) PROTO<zetasql_test__.KitchenSinkPB.Nested>) -> ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>)
    |               |     +-MakeProto
    |               |     | +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |               |     | +-field_list=
    |               |     |   +-nested_int64 := Literal(type=INT64, value=6)
    |               |     +-MakeProto
    |               |       +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |               |       +-field_list=
    |               |         +-nested_int64 := Literal(type=INT64, value=7)
    |               +-input_scan=
    |                 +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Inferring through a scalar subquery with the wrong type.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value: (SELECT 1)
}
--
ERROR: Could not store value with type INT64 into proto field zetasql_test__.KitchenSinkPB.nested_value which has SQL type zetasql_test__.KitchenSinkPB.Nested [at 4:3]
  nested_value: (SELECT 1)
  ^
==

# Inferring through a scalar subquery with the wrong protocol buffer type.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value: (SELECT { nested: 5 })
}
--
ERROR: Field 1 has name nested which is not a field in proto zetasql_test__.KitchenSinkPB.Nested [at 4:27]
  nested_value: (SELECT { nested: 5 })
                          ^
==

# Inferring through a scalar subquery with GROUP BY. Note this does not fail on
# type inference and if grouping by proto is supported will work.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value: (SELECT { nested_int64: 5 } FROM TestTable GROUP BY 1)
}
--
ERROR: Grouping by expressions of type PROTO is not allowed [at 4:69]
  nested_value: (SELECT { nested_int64: 5 } FROM TestTable GROUP BY 1)
                                                                    ^
==

# Recursively inferring through a scalar subquery works.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value: (SELECT (SELECT { nested_int64: 5 }))
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_1 := Literal(type=INT64, value=1)
    |       +-int64_key_2 := Literal(type=INT64, value=2)
    |       +-nested_value :=
    |         +-SubqueryExpr
    |           +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |           +-subquery_type=SCALAR
    |           +-subquery=
    |             +-ProjectScan
    |               +-column_list=[$expr_subquery.$col1#2]
    |               +-expr_list=
    |               | +-$col1#2 :=
    |               |   +-SubqueryExpr
    |               |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |               |     +-subquery_type=SCALAR
    |               |     +-subquery=
    |               |       +-ProjectScan
    |               |         +-column_list=[$expr_subquery.$col1#1]
    |               |         +-expr_list=
    |               |         | +-$col1#1 :=
    |               |         |   +-MakeProto
    |               |         |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |               |         |     +-field_list=
    |               |         |       +-nested_int64 := Literal(type=INT64, value=5)
    |               |         +-input_scan=
    |               |           +-SingleRowScan
    |               +-input_scan=
    |                 +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Inferring through an array subquery works.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_repeated_value: ARRAY(
        SELECT {} FROM UNNEST(GENERATE_ARRAY(1, 2))
  )
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_1 := Literal(type=INT64, value=1)
    |       +-int64_key_2 := Literal(type=INT64, value=2)
    |       +-nested_repeated_value :=
    |         +-SubqueryExpr
    |           +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
    |           +-subquery_type=ARRAY
    |           +-subquery=
    |             +-ProjectScan
    |               +-column_list=[$expr_subquery.$col1#2]
    |               +-expr_list=
    |               | +-$col1#2 := MakeProto(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>)
    |               +-input_scan=
    |                 +-ArrayScan
    |                   +-array_expr_list=
    |                   | +-FunctionCall(ZetaSQL:generate_array(INT64, INT64, optional(0) INT64) -> ARRAY<INT64>)
    |                   |   +-Literal(type=INT64, value=1)
    |                   |   +-Literal(type=INT64, value=2)
    |                   +-element_column_list=[$array.$unnest1#1]
    +-input_scan=
      +-SingleRowScan
==

# Inferring from the LHS to the RHS of an IN subquery works. We get an error
# because proto types are not comparable.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
} IN (SELECT {int64_key_1: 1 int64_key_2: 2} )
--
ERROR: Cannot execute IN subquery with uncomparable types zetasql_test__.KitchenSinkPB and zetasql_test__.KitchenSinkPB [at 1:8]
SELECT NEW zetasql_test__.KitchenSinkPB {
       ^
==

# Subquery type does not match inferred type.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value: (SELECT 1)
}
--
ERROR: Could not store value with type INT64 into proto field zetasql_test__.KitchenSinkPB.nested_value which has SQL type zetasql_test__.KitchenSinkPB.Nested [at 4:3]
  nested_value: (SELECT 1)
  ^
==

# Inferred type is not an array for an array subquery.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value: ARRAY(SELECT { nested_int64: 5 })
}
--
ERROR: Unable to infer a type for braced constructor [at 4:30]
  nested_value: ARRAY(SELECT { nested_int64: 5 })
                             ^
==

# Not inferring through a EXISTS query.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value: EXISTS(SELECT { nested_int64: 5 })
}
--
ERROR: Unable to infer a type for braced constructor [at 4:31]
  nested_value: EXISTS(SELECT { nested_int64: 5 })
                              ^
==

# Not inferring through a SELECT AS STRUCT query.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value: (SELECT AS STRUCT { nested_int64: 5 })
}
--
ERROR: Unable to infer a type for braced constructor [at 4:35]
  nested_value: (SELECT AS STRUCT { nested_int64: 5 })
                                  ^
==

# Not inferring through a SELECT AS PROTO query because of differing syntax.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value: (SELECT AS zetasql_test__.KitchenSinkPB { nested_int64: 5 })
}
--
ERROR: Unable to infer a type for braced constructor [at 4:57]
  nested_value: (SELECT AS zetasql_test__.KitchenSinkPB { nested_int64: 5 })
                                                        ^
==

# Inference doesn't work inside SELECT AS PROTO query.
SELECT AS zetasql_test__.KitchenSinkPB
  1 AS int64_key_1,
  2 AS int64_key_2,
  { nested_int64: 5 } AS nested_value
--
ERROR: Unable to infer a type for braced constructor [at 4:3]
  { nested_int64: 5 } AS nested_value
  ^
==

# Inferring through a subquery using WITH does inference only on the returned
# SELECT column and not any select in the WITH.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value: (WITH Foo AS (SELECT { nested_int64: 5 } AS x) SELECT Foo.x)
}
--
ERROR: Unable to infer a type for braced constructor [at 4:38]
  nested_value: (WITH Foo AS (SELECT { nested_int64: 5 } AS x) SELECT Foo.x)
                                     ^
==

# Inferring through a subquery using WITH working on first non-WITH SELECT
# column.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value: (WITH Foo AS (SELECT "foo" AS x) SELECT { nested_int64: 5 })
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_1 := Literal(type=INT64, value=1)
    |       +-int64_key_2 := Literal(type=INT64, value=2)
    |       +-nested_value :=
    |         +-SubqueryExpr
    |           +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |           +-subquery_type=SCALAR
    |           +-subquery=
    |             +-WithScan
    |               +-column_list=[$expr_subquery.$col1#2]
    |               +-with_entry_list=
    |               | +-WithEntry
    |               |   +-with_query_name="Foo"
    |               |   +-with_subquery=
    |               |     +-ProjectScan
    |               |       +-column_list=[Foo.x#1]
    |               |       +-expr_list=
    |               |       | +-x#1 := Literal(type=STRING, value="foo")
    |               |       +-input_scan=
    |               |         +-SingleRowScan
    |               +-query=
    |                 +-ProjectScan
    |                   +-column_list=[$expr_subquery.$col1#2]
    |                   +-expr_list=
    |                   | +-$col1#2 :=
    |                   |   +-MakeProto
    |                   |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |                   |     +-field_list=
    |                   |       +-nested_int64 := Literal(type=INT64, value=5)
    |                   +-input_scan=
    |                     +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Inferring through multiple WITH clauses.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_value: (WITH Foo AS (SELECT "foo" AS x) (WITH Bar AS (SELECT "bar" AS y) SELECT { nested_int64: 5 }))
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_1 := Literal(type=INT64, value=1)
    |       +-int64_key_2 := Literal(type=INT64, value=2)
    |       +-nested_value :=
    |         +-SubqueryExpr
    |           +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |           +-subquery_type=SCALAR
    |           +-subquery=
    |             +-WithScan
    |               +-column_list=[$expr_subquery.$col1#3]
    |               +-with_entry_list=
    |               | +-WithEntry
    |               |   +-with_query_name="Foo"
    |               |   +-with_subquery=
    |               |     +-ProjectScan
    |               |       +-column_list=[Foo.x#1]
    |               |       +-expr_list=
    |               |       | +-x#1 := Literal(type=STRING, value="foo")
    |               |       +-input_scan=
    |               |         +-SingleRowScan
    |               +-query=
    |                 +-WithScan
    |                   +-column_list=[$expr_subquery.$col1#3]
    |                   +-with_entry_list=
    |                   | +-WithEntry
    |                   |   +-with_query_name="Bar"
    |                   |   +-with_subquery=
    |                   |     +-ProjectScan
    |                   |       +-column_list=[Bar.y#2]
    |                   |       +-expr_list=
    |                   |       | +-y#2 := Literal(type=STRING, value="bar")
    |                   |       +-input_scan=
    |                   |         +-SingleRowScan
    |                   +-query=
    |                     +-ProjectScan
    |                       +-column_list=[$expr_subquery.$col1#3]
    |                       +-expr_list=
    |                       | +-$col1#3 :=
    |                       |   +-MakeProto
    |                       |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |                       |     +-field_list=
    |                       |       +-nested_int64 := Literal(type=INT64, value=5)
    |                       +-input_scan=
    |                         +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Inferring through a subquery which has UNION ALL.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 1
  int64_key_2: 2
  nested_repeated_value: ARRAY(SELECT { nested_int64: 5 } UNION ALL
                               SELECT { nested_int64: 6 })
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_1 := Literal(type=INT64, value=1)
    |       +-int64_key_2 := Literal(type=INT64, value=2)
    |       +-nested_repeated_value :=
    |         +-SubqueryExpr
    |           +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
    |           +-subquery_type=ARRAY
    |           +-subquery=
    |             +-SetOperationScan
    |               +-column_list=[$union_all.$col1#3]
    |               +-op_type=UNION_ALL
    |               +-input_item_list=
    |                 +-SetOperationItem
    |                 | +-scan=
    |                 | | +-ProjectScan
    |                 | |   +-column_list=[$union_all1.$col1#1]
    |                 | |   +-expr_list=
    |                 | |   | +-$col1#1 :=
    |                 | |   |   +-MakeProto
    |                 | |   |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |                 | |   |     +-field_list=
    |                 | |   |       +-nested_int64 := Literal(type=INT64, value=5)
    |                 | |   +-input_scan=
    |                 | |     +-SingleRowScan
    |                 | +-output_column_list=[$union_all1.$col1#1]
    |                 +-SetOperationItem
    |                   +-scan=
    |                   | +-ProjectScan
    |                   |   +-column_list=[$union_all2.$col1#2]
    |                   |   +-expr_list=
    |                   |   | +-$col1#2 :=
    |                   |   |   +-MakeProto
    |                   |   |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |                   |   |     +-field_list=
    |                   |   |       +-nested_int64 := Literal(type=INT64, value=6)
    |                   |   +-input_scan=
    |                   |     +-SingleRowScan
    |                   +-output_column_list=[$union_all2.$col1#2]
    +-input_scan=
      +-SingleRowScan
==

# The analyzer allows setting required fields to NULL, but the engine will
# give an error.
SELECT NEW zetasql_test__.KitchenSinkPB {int64_key_1: NULL int64_key_2: NULL}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_1 := Literal(type=INT64, value=NULL)
    |       +-int64_key_2 := Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

# The analyzer allows setting values of repeated fields to NULL, but the engine
# will give an error.
SELECT NEW zetasql_test__.KitchenSinkPB {
  int64_key_1: 10 int64_key_2: 20
  repeated_int64_val: [1, 2, NULL, 4]
}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_1 := Literal(type=INT64, value=10)
    |       +-int64_key_2 := Literal(type=INT64, value=20)
    |       +-repeated_int64_val := Literal(type=ARRAY<INT64>, value=[1, 2, NULL, 4])
    +-input_scan=
      +-SingleRowScan
==

# This is a valid query because int32_val is an optional field.
SELECT NEW zetasql_test__.KitchenSinkPB {
    int64_key_2: 1
    int64_key_1: 2
    int32_val: NULL}
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     +-field_list=
    |       +-int64_key_2 := Literal(type=INT64, value=1)
    |       +-int64_key_1 := Literal(type=INT64, value=2)
    |       +-int32_val := Literal(type=INT32, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

# Error using braced constructors without an inferred type.
SELECT ARRAY[{ str_value: ["foo", "bar"] }, { str_value: ["baz"] }]
--
ERROR: Unable to infer a type for braced constructor [at 1:14]
SELECT ARRAY[{ str_value: ["foo", "bar"] }, { str_value: ["baz"] }]
             ^
==

# Error using braced constructors for non-proto type.
SELECT ARRAY<INT64>[{ str_value: ["foo", "bar"] }, { str_value: ["baz"] }]
--
ERROR: Braced constructors are not allowed for type INT64 [at 1:21]
SELECT ARRAY<INT64>[{ str_value: ["foo", "bar"] }, { str_value: ["baz"] }]
                    ^
==

# Setting NUMERIC fields when the type is unsupported results in error.
SELECT NEW zetasql_test__.FieldFormatsProto { b_numeric: 6 }
--
ERROR: Proto field zetasql_test__.FieldFormatsProto.b_numeric has unsupported type NUMERIC [at 1:47]
SELECT NEW zetasql_test__.FieldFormatsProto { b_numeric: 6 }
                                              ^
==

# The inferred type is not propagated to sibling array elements.
SELECT ARRAY[
  NEW zetasql_test__.TestExtraPB{ str_value: ["foo", "bar"] },
  { str_value: ["baz"] }
]
--
ERROR: Unable to infer a type for braced constructor [at 3:3]
  { str_value: ["baz"] }
  ^
==

# Regression test against b/259000660.
# The templated TVF should be parsed with the V_1_3_BRACED_PROTO_CONSTRUCTORS
# enabled as well.
[language_features=V_1_3_BRACED_PROTO_CONSTRUCTORS,TABLE_VALUED_FUNCTIONS,CREATE_TABLE_FUNCTION,TEMPLATE_FUNCTIONS]
WITH
  T AS (
    SELECT CAST(v as INT32) v
    FROM UNNEST(GENERATE_ARRAY(2, 12)) AS v
  )
SELECT *
FROM templated_proto_braced_ctor_tvf(TABLE T)
ORDER BY dice_roll.int32_val1;
--
QueryStmt
+-output_column_list=
| +-templated_proto_braced_ctor_tvf.dice_roll#4 AS dice_roll [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-WithScan
    +-column_list=[templated_proto_braced_ctor_tvf.dice_roll#4]
    +-is_ordered=TRUE
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="T"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[T.v#2]
    |       +-expr_list=
    |       | +-v#2 :=
    |       |   +-Cast(INT64 -> INT32)
    |       |     +-ColumnRef(type=INT64, column=$array.v#1)
    |       +-input_scan=
    |         +-ArrayScan
    |           +-column_list=[$array.v#1]
    |           +-array_expr_list=
    |           | +-FunctionCall(ZetaSQL:generate_array(INT64, INT64, optional(0) INT64) -> ARRAY<INT64>)
    |           |   +-Literal(type=INT64, value=2)
    |           |   +-Literal(type=INT64, value=12)
    |           +-element_column_list=[$array.v#1]
    +-query=
      +-OrderByScan
        +-column_list=[templated_proto_braced_ctor_tvf.dice_roll#4]
        +-is_ordered=TRUE
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[templated_proto_braced_ctor_tvf.dice_roll#4, $orderby.$orderbycol1#5]
        |   +-expr_list=
        |   | +-$orderbycol1#5 :=
        |   |   +-GetProtoField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=templated_proto_braced_ctor_tvf.dice_roll#4)
        |   |     +-field_descriptor=int32_val1
        |   |     +-default_value=0
        |   +-input_scan=
        |     +-TVFScan
        |       +-column_list=[templated_proto_braced_ctor_tvf.dice_roll#4]
        |       +-tvf=templated_proto_braced_ctor_tvf((ANY TABLE) -> ANY TABLE)
        |       +-signature=(TABLE<v INT32>) -> TABLE<dice_roll PROTO<zetasql_test__.TestExtraPB>>
        |       +-argument_list=
        |       | +-FunctionArgument
        |       |   +-scan=
        |       |   | +-WithRefScan(column_list=[T.v#3], with_query_name="T")
        |       |   +-argument_column_list=[T.v#3]
        |       +-column_index_list=[0]
        +-order_by_item_list=
          +-OrderByItem
            +-column_ref=
              +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#5)

With Templated SQL TVF signature:
  templated_proto_braced_ctor_tvf(TABLE<v INT32>) -> TABLE<dice_roll PROTO<zetasql_test__.TestExtraPB>>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.dice_roll#2 AS dice_roll [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.dice_roll#2]
    +-expr_list=
    | +-dice_roll#2 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.TestExtraPB>
    |     +-field_list=
    |       +-int32_val1 := ColumnRef(type=INT32, column=T.v#1)
    +-input_scan=
      +-RelationArgumentScan(column_list=[T.v#1], name="T")
