[language_features=PIPES]
from keyvalue
|> recursive union all (
  |> extend 1
)
--
ERROR: Pipe RECURSIVE UNION is not supported [at 2:1]
|> recursive union all (
^
==

[language_features=PIPES]
from keyvalue
|> recursive union all (from keyvalue)
--
ERROR: Pipe RECURSIVE UNION is not supported [at 2:1]
|> recursive union all (from keyvalue)
^
==

[default language_features=PIPES,V_1_4_PIPE_RECURSIVE_UNION,V_1_3_WITH_RECURSIVE,PIPE_STATIC_DESCRIBE,V_1_1_WITH_ON_SUBQUERY,V_1_4_WITH_RECURSIVE_DEPTH_MODIFIER,PIPE_WITH]
from keyvalue
|> recursive union all (
  |> select key + 1 as key, value
  |> where key < 10
) AS t
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-FilterScan
        |   +-column_list=[$pipe_select.key#7, t.Value#6]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$pipe_select.key#7, t.Value#6]
        |   |   +-expr_list=
        |   |   | +-key#7 :=
        |   |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |   |     +-ColumnRef(type=INT64, column=t.Key#5)
        |   |   |     +-Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$pipe_select.key#7)
        |       +-Literal(type=INT64, value=10)
        +-output_column_list=[$pipe_select.key#7, t.Value#6]
==

from keyvalue
|> recursive union all by name (
  from t
) as t
--
ERROR: BY NAME for set operations is not supported [at 2:24]
|> recursive union all by name (
                       ^
==

from keyvalue
|> recursive {{intersect|except}}
  {{all|distinct}} (from t) AS t
--
ALTERNATION GROUPS:
    intersect,all
    intersect,distinct
--
ERROR: UNION is the only supported RECURSIVE set operator [at 2:14]
|> recursive intersect
             ^
--
ALTERNATION GROUPS:
    except,all
    except,distinct
--
ERROR: UNION is the only supported RECURSIVE set operator [at 2:14]
|> recursive except
             ^
==

# Basic pipe recursive union with alias. The resolver produces the same output
# for the subpipeline input and subquery input.
from keyvalue
|> select *
|> recursive union distinct (
  {{|from t}}
  |> where key = 1
) AS t
|> aggregate sum(key)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#7 AS `$col1` [INT64]
+-query=
  +-AggregateScan
    +-column_list=[$aggregate.$agg1#7]
    +-input_scan=
    | +-RecursiveScan
    |   +-column_list=$union_distinct.[Key#3, Value#4]
    |   +-op_type=UNION_DISTINCT
    |   +-non_recursive_term=
    |   | +-SetOperationItem
    |   |   +-scan=
    |   |   | +-ProjectScan
    |   |   |   +-column_list=KeyValue.[Key#1, Value#2]
    |   |   |   +-input_scan=
    |   |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-output_column_list=KeyValue.[Key#1, Value#2]
    |   +-recursive_term=
    |     +-SetOperationItem
    |       +-scan=
    |       | +-FilterScan
    |       |   +-column_list=t.[Key#5, Value#6]
    |       |   +-input_scan=
    |       |   | +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
    |       |   +-filter_expr=
    |       |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |       |       +-ColumnRef(type=INT64, column=t.Key#5)
    |       |       +-Literal(type=INT64, value=1)
    |       +-output_column_list=t.[Key#5, Value#6]
    +-aggregate_list=
      +-$agg1#7 :=
        +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          +-ColumnRef(type=INT64, column=$union_distinct.Key#3)
==

# Two pipe recursive unions in a row.
from keyvalue
|> recursive union distinct (
  {{from t|}}
  |> where key = 1
) as t
|> recursive union all (
  from keyvalue
  |> union all (from t)
  |> where key = 2
) as t
|> where t.key > 1
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#7 AS Key [INT64]
| +-$union_all.Value#8 AS Value [STRING]
+-query=
  +-FilterScan
    +-column_list=$union_all.[Key#7, Value#8]
    +-input_scan=
    | +-RecursiveScan
    |   +-column_list=$union_all.[Key#7, Value#8]
    |   +-op_type=UNION_ALL
    |   +-non_recursive_term=
    |   | +-SetOperationItem
    |   |   +-scan=
    |   |   | +-RecursiveScan
    |   |   |   +-column_list=$union_distinct.[Key#3, Value#4]
    |   |   |   +-op_type=UNION_DISTINCT
    |   |   |   +-non_recursive_term=
    |   |   |   | +-SetOperationItem
    |   |   |   |   +-scan=
    |   |   |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   |   |   +-output_column_list=KeyValue.[Key#1, Value#2]
    |   |   |   +-recursive_term=
    |   |   |     +-SetOperationItem
    |   |   |       +-scan=
    |   |   |       | +-FilterScan
    |   |   |       |   +-column_list=t.[Key#5, Value#6]
    |   |   |       |   +-input_scan=
    |   |   |       |   | +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
    |   |   |       |   +-filter_expr=
    |   |   |       |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   |   |       |       +-ColumnRef(type=INT64, column=t.Key#5)
    |   |   |       |       +-Literal(type=INT64, value=1)
    |   |   |       +-output_column_list=t.[Key#5, Value#6]
    |   |   +-output_column_list=$union_distinct.[Key#3, Value#4]
    |   +-recursive_term=
    |     +-SetOperationItem
    |       +-scan=
    |       | +-FilterScan
    |       |   +-column_list=$union_all.[Key#13, Value#14]
    |       |   +-input_scan=
    |       |   | +-SetOperationScan
    |       |   |   +-column_list=$union_all.[Key#13, Value#14]
    |       |   |   +-op_type=UNION_ALL
    |       |   |   +-input_item_list=
    |       |   |     +-SetOperationItem
    |       |   |     | +-scan=
    |       |   |     | | +-TableScan(column_list=KeyValue.[Key#9, Value#10], table=KeyValue, column_index_list=[0, 1])
    |       |   |     | +-output_column_list=KeyValue.[Key#9, Value#10]
    |       |   |     +-SetOperationItem
    |       |   |       +-scan=
    |       |   |       | +-RecursiveRefScan(column_list=t_1.[Key#11, Value#12])
    |       |   |       +-output_column_list=t_1.[Key#11, Value#12]
    |       |   +-filter_expr=
    |       |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |       |       +-ColumnRef(type=INT64, column=$union_all.Key#13)
    |       |       +-Literal(type=INT64, value=2)
    |       +-output_column_list=$union_all.[Key#13, Value#14]
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=$union_all.Key#7)
        +-Literal(type=INT64, value=1)
==

# Use static_describe to show what's visible after the RECURSIVE, and what's
# visible on FROM t inside it.
from keyvalue
|> recursive union all (
  {{from t|}}
  |> static_describe
) as t
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-StaticDescribeScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-describe_text=
    |   """
    |   NameList:
    |     Key INT64 $union_all.Key#3
    |     Value STRING $union_all.Value#4
    |   NameScope:
    |     Names:
    |       Key -> INT64 ($union_all.Key#3) (implicit)
    |       Value -> STRING ($union_all.Value#4) (implicit)
    |     Range variables:
    |       t -> RANGE_VARIABLE<Key,Value>
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=$union_all.[Key#3, Value#4]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-output_column_list=KeyValue.[Key#1, Value#2]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-StaticDescribeScan
            |   +-column_list=t.[Key#5, Value#6]
            |   +-describe_text=
            |   |   """
            |   |   NameList:
            |   |     Key INT64 t.Key#5
            |   |     Value STRING t.Value#6
            |   |   NameScope:
            |   |     Names:
            |   |       Key -> INT64 (t.Key#5) (implicit)
            |   |       Value -> STRING (t.Value#6) (implicit)
            |   |     Range variables:
            |   |       t -> RANGE_VARIABLE<Key,Value>
            |   |   """
            |   +-input_scan=
            |     +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
            +-output_column_list=t.[Key#5, Value#6]
==

# Different column numbers are not allowed.
from keyvalue
|> recursive union distinct (
  {{from t|}}
  |> select key, key, key
) AS t
--
ERROR: Queries in UNION DISTINCT have mismatched column count; pipe input table has 2 columns, pipe recursive term has 3 columns [at 2:29]
|> recursive union distinct (
                            ^
==

# Empty subpipeline as input.
from keyvalue
|> recursive union distinct (){{| as t}}
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$union_distinct.Key#3 AS Key [INT64]
| +-$union_distinct.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_distinct.[Key#3, Value#4]
    +-op_type=UNION_DISTINCT
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-RecursiveRefScan(column_list=$pipe_recursive_union.[Key#5, Value#6])
        +-output_column_list=$pipe_recursive_union.[Key#5, Value#6]
--
ALTERNATION GROUP:  as t
--
QueryStmt
+-output_column_list=
| +-$union_distinct.Key#3 AS Key [INT64]
| +-$union_distinct.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_distinct.[Key#3, Value#4]
    +-op_type=UNION_DISTINCT
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
        +-output_column_list=t.[Key#5, Value#6]
==

# Type mismatch.
from keyvalue
|> recursive union distinct (
  {{from t|}}
  |> select value, key
) as t
--
ERROR: Cannot coerce type (STRING) of column 1 in the recursive term to type (INT64) of column 1 in pipe input table [at 2:29]
|> recursive union distinct (
                            ^
==

# Subquery: Type coercion: int32 -> int64
from keyvalue
|> recursive union distinct (
  from simpletypes
  |> join t on true
  |> select int32, ""
) as t
--
QueryStmt
+-output_column_list=
| +-$union_distinct.Key#3 AS Key [INT64]
| +-$union_distinct.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_distinct.[Key#3, Value#4]
    +-op_type=UNION_DISTINCT
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_distinct2_cast.int32#27, $pipe_select.$col2#26]
        |   +-expr_list=
        |   | +-int32#27 :=
        |   |   +-Cast(INT32 -> INT64)
        |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#5)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[SimpleTypes.int32#5, $pipe_select.$col2#26]
        |       +-expr_list=
        |       | +-$col2#26 := Literal(type=STRING, value="")
        |       +-input_scan=
        |         +-JoinScan
        |           +-column_list=[SimpleTypes.int32#5, t.Key#24, t.Value#25]
        |           +-left_scan=
        |           | +-TableScan(column_list=[SimpleTypes.int32#5], table=SimpleTypes, column_index_list=[0])
        |           +-right_scan=
        |           | +-RecursiveRefScan(column_list=t.[Key#24, Value#25])
        |           +-join_expr=
        |             +-Literal(type=BOOL, value=true)
        +-output_column_list=[$union_distinct2_cast.int32#27, $pipe_select.$col2#26]
==

# Subpipeline: Type coercion: int32 -> int64
from keyvalue
|> recursive union distinct (
  |> inner join simpletypes on true
  |> select int32, ""
)
--
QueryStmt
+-output_column_list=
| +-$union_distinct.Key#3 AS Key [INT64]
| +-$union_distinct.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_distinct.[Key#3, Value#4]
    +-op_type=UNION_DISTINCT
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_distinct2_cast.int32#27, $pipe_select.$col2#26]
        |   +-expr_list=
        |   | +-int32#27 :=
        |   |   +-Cast(INT32 -> INT64)
        |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#7)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[SimpleTypes.int32#7, $pipe_select.$col2#26]
        |       +-expr_list=
        |       | +-$col2#26 := Literal(type=STRING, value="")
        |       +-input_scan=
        |         +-JoinScan
        |           +-column_list=[$pipe_recursive_union.Key#5, $pipe_recursive_union.Value#6, SimpleTypes.int32#7]
        |           +-left_scan=
        |           | +-RecursiveRefScan(column_list=$pipe_recursive_union.[Key#5, Value#6])
        |           +-right_scan=
        |           | +-TableScan(column_list=[SimpleTypes.int32#7], table=SimpleTypes, column_index_list=[0])
        |           +-join_expr=
        |             +-Literal(type=BOOL, value=true)
        +-output_column_list=[$union_distinct2_cast.int32#27, $pipe_select.$col2#26]
==

# Type coercion fails: cannot coerce int64 to int32.
select cast(1 as int32), "value"
|> recursive union distinct (
  {{from t|}}
  |> select cast(1 as int64), "value"
) as t
--
ERROR: Cannot coerce type (INT64) of column 1 in the recursive term to type (INT32) of column 1 in pipe input table [at 2:29]
|> recursive union distinct (
                            ^
==

# Subquery: Literal coercion: null -> string
from keyvalue
|> recursive union distinct (
  from simpletypes
  |> inner join t on true
  |> select 1, null
) as t
--
QueryStmt
+-output_column_list=
| +-$union_distinct.Key#3 AS Key [INT64]
| +-$union_distinct.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_distinct.[Key#3, Value#4]
    +-op_type=UNION_DISTINCT
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$pipe_select.$col1#26, $union_distinct2_cast.$col2#28]
        |   +-expr_list=
        |   | +-$col2#28 := Literal(type=STRING, value=NULL)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=$pipe_select.[$col1#26, $col2#27]
        |       +-expr_list=
        |       | +-$col1#26 := Literal(type=INT64, value=1)
        |       | +-$col2#27 := Literal(type=INT64, value=NULL)
        |       +-input_scan=
        |         +-JoinScan
        |           +-column_list=t.[Key#24, Value#25]
        |           +-left_scan=
        |           | +-TableScan(table=SimpleTypes)
        |           +-right_scan=
        |           | +-RecursiveRefScan(column_list=t.[Key#24, Value#25])
        |           +-join_expr=
        |             +-Literal(type=BOOL, value=true)
        +-output_column_list=[$pipe_select.$col1#26, $union_distinct2_cast.$col2#28]
==

# Subpipeline: Literal coercion: null -> string
from keyvalue
|> recursive union distinct (
  |> select 1, null
)
--
QueryStmt
+-output_column_list=
| +-$union_distinct.Key#3 AS Key [INT64]
| +-$union_distinct.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_distinct.[Key#3, Value#4]
    +-op_type=UNION_DISTINCT
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$pipe_select.$col1#7, $union_distinct2_cast.$col2#9]
        |   +-expr_list=
        |   | +-$col2#9 := Literal(type=STRING, value=NULL)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=$pipe_select.[$col1#7, $col2#8]
        |       +-expr_list=
        |       | +-$col1#7 := Literal(type=INT64, value=1)
        |       | +-$col2#8 := Literal(type=INT64, value=NULL)
        |       +-input_scan=
        |         +-RecursiveRefScan(column_list=$pipe_recursive_union.[Key#5, Value#6])
        +-output_column_list=[$pipe_select.$col1#7, $union_distinct2_cast.$col2#9]
==

# Subquery: The default type of null is INT64, and thus the coercion from string
# fails.
select null
|> recursive union distinct (
  from keyvalue
  |> inner join t on true
  |> select value
) as t
--
ERROR: Cannot coerce type (STRING) of column 1 in the recursive term to type (INT64) of column 1 in pipe input table [at 2:29]
|> recursive union distinct (
                            ^
==

# Subpipeline: The default type of null is INT64, and thus the coercion from
# string fails.
select null
|> recursive union distinct (
  |> inner join keyvalue on true
  |> select value
)
--
ERROR: Cannot coerce type (STRING) of column 1 in the recursive term to type (INT64) of column 1 in pipe input table [at 2:29]
|> recursive union distinct (
                            ^
==

# Subquery must reference the recursive union alias.
from keyvalue
|> recursive union all (
  from keyvalue
  |> where key = 1
) AS t
--
ERROR: Recursive union subquery must contain a reference to the recursive input table t [at 2:24]
|> recursive union all (
                       ^
==

# An output alias must be provided when the input is a subquery.
from keyvalue
|> recursive union distinct (
  from t
  |> where key = 1
)
--
ERROR: The subquery input of RECURSIVE UNION must have an alias [at 5:2]
)
 ^
==

# When using a subpipeline as input, it is ok that the pipe recursive union does
# not have an alias.
from keyvalue
|> recursive union distinct (
  |> where key = 1
)
--
QueryStmt
+-output_column_list=
| +-$union_distinct.Key#3 AS Key [INT64]
| +-$union_distinct.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_distinct.[Key#3, Value#4]
    +-op_type=UNION_DISTINCT
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-FilterScan
        |   +-column_list=$pipe_recursive_union.[Key#5, Value#6]
        |   +-input_scan=
        |   | +-RecursiveRefScan(column_list=$pipe_recursive_union.[Key#5, Value#6])
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$pipe_recursive_union.Key#5)
        |       +-Literal(type=INT64, value=1)
        +-output_column_list=$pipe_recursive_union.[Key#5, Value#6]
==

# Recursive depth modifier is not enabled.
[language_features=PIPES,V_1_4_PIPE_RECURSIVE_UNION]
from keyvalue
|> recursive union all with depth max 10 (
  {{from t|}}
){{| as t}}
--
ALTERNATION GROUP: from t,
--
ERROR: The subquery input of RECURSIVE UNION must have an alias [at 4:2]
)
 ^
--
ALTERNATION GROUPS:
    from t, as t
    <empty>
     as t
--
ERROR: Recursion depth modifier is not supported [at 2:24]
|> recursive union all with depth max 10 (
                       ^
==

# Depth is not visible inside the recursive term itself.
from keyvalue
|> recursive union all with depth max 10 (
  {{from t|}}
  |> where depth < 10
){{| as t}}
--
ALTERNATION GROUP: from t,
--
ERROR: The subquery input of RECURSIVE UNION must have an alias [at 5:2]
)
 ^
--
ALTERNATION GROUPS:
    from t, as t
    <empty>
     as t
--
ERROR: Unrecognized name: depth [at 4:12]
  |> where depth < 10
           ^
==

# Depth is added into the output range varible.
from keyvalue
|> recursive union all with depth (
  {{from t|}}
  |> static_describe
){{| as t}}
|> static_describe
--
ALTERNATION GROUP: from t,
--
ERROR: The subquery input of RECURSIVE UNION must have an alias [at 5:2]
)
 ^
--
ALTERNATION GROUPS:
    from t, as t
     as t
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
| +-$recursion_depth.depth#7 AS depth [INT64]
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.Key#3, $union_all.Value#4, $recursion_depth.depth#7]
    +-describe_text=
    |   """
    |   NameList:
    |     Key INT64 $union_all.Key#3
    |     Value STRING $union_all.Value#4
    |     depth INT64 $recursion_depth.depth#7
    |   NameScope:
    |     Names:
    |       Key -> INT64 ($union_all.Key#3) (implicit)
    |       Value -> STRING ($union_all.Value#4) (implicit)
    |       depth -> INT64 ($recursion_depth.depth#7)
    |     Range variables:
    |       t -> RANGE_VARIABLE<Key,Value,depth>
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.Key#3, $union_all.Value#4, $recursion_depth.depth#7]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-output_column_list=KeyValue.[Key#1, Value#2]
        +-recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=t.[Key#5, Value#6]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList:
        |   |   |     Key INT64 t.Key#5
        |   |   |     Value STRING t.Value#6
        |   |   |   NameScope:
        |   |   |     Names:
        |   |   |       Key -> INT64 (t.Key#5) (implicit)
        |   |   |       Value -> STRING (t.Value#6) (implicit)
        |   |   |     Range variables:
        |   |   |       t -> RANGE_VARIABLE<Key,Value>
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
        |   +-output_column_list=t.[Key#5, Value#6]
        +-recursion_depth_modifier=
          +-RecursionDepthModifier
            +-recursion_depth_column=
              +-ColumnHolder(column=$recursion_depth.depth#7)
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
| +-$recursion_depth.depth#7 AS depth [INT64]
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.Key#3, $union_all.Value#4, $recursion_depth.depth#7]
    +-describe_text=
    |   """
    |   NameList:
    |     Key INT64 $union_all.Key#3
    |     Value STRING $union_all.Value#4
    |     depth INT64 $recursion_depth.depth#7
    |   NameScope:
    |     Names:
    |       Key -> INT64 ($union_all.Key#3) (implicit)
    |       Value -> STRING ($union_all.Value#4) (implicit)
    |       depth -> INT64 ($recursion_depth.depth#7)
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.Key#3, $union_all.Value#4, $recursion_depth.depth#7]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-output_column_list=KeyValue.[Key#1, Value#2]
        +-recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=$pipe_recursive_union.[Key#5, Value#6]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList:
        |   |   |     Key INT64 $pipe_recursive_union.Key#5
        |   |   |     Value STRING $pipe_recursive_union.Value#6
        |   |   |   NameScope:
        |   |   |     Names:
        |   |   |       Key -> INT64 ($pipe_recursive_union.Key#5) (implicit)
        |   |   |       Value -> STRING ($pipe_recursive_union.Value#6) (implicit)
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-RecursiveRefScan(column_list=$pipe_recursive_union.[Key#5, Value#6])
        |   +-output_column_list=$pipe_recursive_union.[Key#5, Value#6]
        +-recursion_depth_modifier=
          +-RecursionDepthModifier
            +-recursion_depth_column=
              +-ColumnHolder(column=$recursion_depth.depth#7)
==

# With recursion depth modifier
from keyvalue
|> recursive union all with depth max 10 (
  {{from t|}}
){{| as t}}
|> select key, value, depth
--
ALTERNATION GROUP: from t,
--
ERROR: The subquery input of RECURSIVE UNION must have an alias [at 4:2]
)
 ^
--
ALTERNATION GROUPS:
    from t, as t
     as t
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS key [INT64]
| +-$union_all.Value#4 AS value [STRING]
| +-$recursion_depth.depth#7 AS depth [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$union_all.Key#3, $union_all.Value#4, $recursion_depth.depth#7]
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.Key#3, $union_all.Value#4, $recursion_depth.depth#7]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-output_column_list=KeyValue.[Key#1, Value#2]
        +-recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
        |   +-output_column_list=t.[Key#5, Value#6]
        +-recursion_depth_modifier=
          +-RecursionDepthModifier
            +-upper_bound=
            | +-Literal(type=INT64, value=10)
            +-recursion_depth_column=
              +-ColumnHolder(column=$recursion_depth.depth#7)
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS key [INT64]
| +-$union_all.Value#4 AS value [STRING]
| +-$recursion_depth.depth#7 AS depth [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$union_all.Key#3, $union_all.Value#4, $recursion_depth.depth#7]
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.Key#3, $union_all.Value#4, $recursion_depth.depth#7]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-output_column_list=KeyValue.[Key#1, Value#2]
        +-recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-RecursiveRefScan(column_list=$pipe_recursive_union.[Key#5, Value#6])
        |   +-output_column_list=$pipe_recursive_union.[Key#5, Value#6]
        +-recursion_depth_modifier=
          +-RecursionDepthModifier
            +-upper_bound=
            | +-Literal(type=INT64, value=10)
            +-recursion_depth_column=
              +-ColumnHolder(column=$recursion_depth.depth#7)
==

# With recursion depth modifier
from keyvalue
|> extend 1
|> recursive union distinct with depth AS depth_alias between 10 and 20 (
  {{from t|}}
){{| as t}}
|> select key, value, depth_alias
--
ALTERNATION GROUP: from t,
--
ERROR: The subquery input of RECURSIVE UNION must have an alias [at 5:2]
)
 ^
--
ALTERNATION GROUPS:
    from t, as t
     as t
--
QueryStmt
+-output_column_list=
| +-$union_distinct.Key#4 AS key [INT64]
| +-$union_distinct.Value#5 AS value [STRING]
| +-$recursion_depth.depth_alias#10 AS depth_alias [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$union_distinct.Key#4, $union_distinct.Value#5, $recursion_depth.depth_alias#10]
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_distinct.Key#4, $union_distinct.Value#5, $union_distinct.$col1#6, $recursion_depth.depth_alias#10]
        +-op_type=UNION_DISTINCT
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.$col1#3]
        |   |   +-expr_list=
        |   |   | +-$col1#3 := Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-output_column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.$col1#3]
        +-recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-RecursiveRefScan(column_list=t.[Key#7, Value#8, $col1#9])
        |   +-output_column_list=t.[Key#7, Value#8, $col1#9]
        +-recursion_depth_modifier=
          +-RecursionDepthModifier
            +-lower_bound=
            | +-Literal(type=INT64, value=10)
            +-upper_bound=
            | +-Literal(type=INT64, value=20)
            +-recursion_depth_column=
              +-ColumnHolder(column=$recursion_depth.depth_alias#10)
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$union_distinct.Key#4 AS key [INT64]
| +-$union_distinct.Value#5 AS value [STRING]
| +-$recursion_depth.depth_alias#10 AS depth_alias [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$union_distinct.Key#4, $union_distinct.Value#5, $recursion_depth.depth_alias#10]
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_distinct.Key#4, $union_distinct.Value#5, $union_distinct.$col1#6, $recursion_depth.depth_alias#10]
        +-op_type=UNION_DISTINCT
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.$col1#3]
        |   |   +-expr_list=
        |   |   | +-$col1#3 := Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-output_column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.$col1#3]
        +-recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-RecursiveRefScan(column_list=$pipe_recursive_union.[Key#7, Value#8, $col1#9])
        |   +-output_column_list=$pipe_recursive_union.[Key#7, Value#8, $col1#9]
        +-recursion_depth_modifier=
          +-RecursionDepthModifier
            +-lower_bound=
            | +-Literal(type=INT64, value=10)
            +-upper_bound=
            | +-Literal(type=INT64, value=20)
            +-recursion_depth_column=
              +-ColumnHolder(column=$recursion_depth.depth_alias#10)
==

# Value table is not allowed when depth modifier is present.
select as value 1
|> recursive union all with depth max 10 (
  {{from t|}}
){{| as t}}
--
ALTERNATION GROUP: from t,
--
ERROR: The subquery input of RECURSIVE UNION must have an alias [at 4:2]
)
 ^
--
ALTERNATION GROUPS:
    from t, as t
    <empty>
     as t
--
ERROR: WITH DEPTH modifier is not allowed when the recursive query produces a value table. [at 2:24]
|> recursive union all with depth max 10 (
                       ^
==

# Duplicate depth column names.
select 1 as depth
|> recursive union all with depth max 10 (
  {{from t|}}
){{| as t}}
|> select depth
--
ALTERNATION GROUP: from t,
--
ERROR: The subquery input of RECURSIVE UNION must have an alias [at 4:2]
)
 ^
--
ALTERNATION GROUPS:
    from t, as t
    <empty>
     as t
--
ERROR: WITH DEPTH modifier depth column is named 'depth' which collides with one of the existing names. [at 2:24]
|> recursive union all with depth max 10 (
                       ^
==

# Recursive union inside with recursive
with recursive t as (
  from keyvalue
  |> union distinct (
    from t
    |> recursive union all (
      {{from inner_alias|}}
    ) as inner_alias
  )
)
from t;
--
QueryStmt
+-output_column_list=
| +-t.Key#11 AS Key [INT64]
| +-t.Value#12 AS Value [STRING]
+-query=
  +-WithScan
    +-column_list=t.[Key#11, Value#12]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=$union_distinct.[Key#3, Value#4]
    |       +-op_type=UNION_DISTINCT
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |       |   +-output_column_list=KeyValue.[Key#1, Value#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-RecursiveScan
    |           |   +-column_list=$union_all.[Key#7, Value#8]
    |           |   +-op_type=UNION_ALL
    |           |   +-non_recursive_term=
    |           |   | +-SetOperationItem
    |           |   |   +-scan=
    |           |   |   | +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
    |           |   |   +-output_column_list=t.[Key#5, Value#6]
    |           |   +-recursive_term=
    |           |     +-SetOperationItem
    |           |       +-scan=
    |           |       | +-RecursiveRefScan(column_list=inner_alias.[Key#9, Value#10])
    |           |       +-output_column_list=inner_alias.[Key#9, Value#10]
    |           +-output_column_list=$union_all.[Key#7, Value#8]
    +-query=
    | +-WithRefScan(column_list=t.[Key#11, Value#12], with_query_name="t")
    +-recursive=TRUE
==

# Recursive union inside with recursive with the same alias. The regular name
# shadowing rule applies.
with recursive t as (
  from keyvalue
  |> union all (
    from t
    |> recursive union distinct (
      {{from t|}}
    ) as t
  )
)
from t;
--
QueryStmt
+-output_column_list=
| +-t.Key#11 AS Key [INT64]
| +-t.Value#12 AS Value [STRING]
+-query=
  +-WithScan
    +-column_list=t.[Key#11, Value#12]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=$union_all.[Key#3, Value#4]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |       |   +-output_column_list=KeyValue.[Key#1, Value#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-RecursiveScan
    |           |   +-column_list=$union_distinct.[Key#7, Value#8]
    |           |   +-op_type=UNION_DISTINCT
    |           |   +-non_recursive_term=
    |           |   | +-SetOperationItem
    |           |   |   +-scan=
    |           |   |   | +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
    |           |   |   +-output_column_list=t.[Key#5, Value#6]
    |           |   +-recursive_term=
    |           |     +-SetOperationItem
    |           |       +-scan=
    |           |       | +-RecursiveRefScan(column_list=t_1.[Key#9, Value#10])
    |           |       +-output_column_list=t_1.[Key#9, Value#10]
    |           +-output_column_list=$union_distinct.[Key#7, Value#8]
    +-query=
    | +-WithRefScan(column_list=t.[Key#11, Value#12], with_query_name="t")
    +-recursive=TRUE
==

# Input range variable is not visible inside the pipe recursive union.
from keyvalue
|> as input_table
|> recursive union all (
  from input_table
  |> union all (from t)
) as t
--
ERROR: Table not found: input_table; Did you mean EnumTable? [at 4:8]
  from input_table
       ^
==

# Input range variable is not visible inside the pipe recursive union.
from keyvalue
|> as input_table
|> recursive union distinct (
  {{from t|}}
  |> union all (from input_table)
) as t
--
ERROR: Table not found: input_table; Did you mean EnumTable? [at 5:22]
  |> union all (from input_table)
                     ^
==

# Input table does not work as a range variable in the pipe recursive union.
from keyvalue as input_table
|> recursive union all (
  {{from t|}}
  |> select {{input_table|input_table.key}}
) as t;
--
ALTERNATION GROUPS:
    from t,input_table
    input_table
--
ERROR: Unrecognized name: input_table [at 4:13]
  |> select input_table
            ^
--
ALTERNATION GROUPS:
    from t,input_table.key
    input_table.key
--
ERROR: Unrecognized name: input_table [at 4:13]
  |> select input_table.key
            ^
==

# Pseudo columns are not preserved by the pipe recursive union.
from enumtable
|> static_describe
|> recursive union all (
  {{from t|}}
  |> static_describe
) as t
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.key#6 AS key [INT32]
| +-$union_all.TestEnum#7 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-$union_all.AnotherTestEnum#8 AS AnotherTestEnum [ENUM<zetasql_test__.AnotherTestEnum>]
+-query=
  +-StaticDescribeScan
    +-column_list=$union_all.[key#6, TestEnum#7, AnotherTestEnum#8]
    +-describe_text=
    |   """
    |   NameList:
    |     key INT32 $union_all.key#6
    |     TestEnum zetasql_test__.TestEnum $union_all.TestEnum#7
    |     AnotherTestEnum zetasql_test__.AnotherTestEnum $union_all.AnotherTestEnum#8
    |   NameScope:
    |     Names:
    |       AnotherTestEnum -> zetasql_test__.AnotherTestEnum ($union_all.AnotherTestEnum#8) (implicit)
    |       TestEnum -> zetasql_test__.TestEnum ($union_all.TestEnum#7) (implicit)
    |       key -> INT32 ($union_all.key#6) (implicit)
    |     Range variables:
    |       t -> RANGE_VARIABLE<key,TestEnum,AnotherTestEnum>
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=$union_all.[key#6, TestEnum#7, AnotherTestEnum#8]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList:
        |   |   |     key INT32 EnumTable.key#1
        |   |   |     TestEnum zetasql_test__.TestEnum EnumTable.TestEnum#2
        |   |   |     AnotherTestEnum zetasql_test__.AnotherTestEnum EnumTable.AnotherTestEnum#3
        |   |   |   NameScope:
        |   |   |     Names:
        |   |   |       AnotherTestEnum -> zetasql_test__.AnotherTestEnum (EnumTable.AnotherTestEnum#3) (implicit)
        |   |   |       Filename -> STRING (EnumTable.Filename#4) (implicit) (pseudo-column)
        |   |   |       RowId -> BYTES (EnumTable.RowId#5) (implicit) (pseudo-column)
        |   |   |       TestEnum -> zetasql_test__.TestEnum (EnumTable.TestEnum#2) (implicit)
        |   |   |       key -> INT32 (EnumTable.key#1) (implicit)
        |   |   |     Range variables:
        |   |   |       enumtable -> RANGE_VARIABLE<key,TestEnum,AnotherTestEnum>
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3], table=EnumTable, column_index_list=[0, 1, 2])
        |   +-output_column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-StaticDescribeScan
            |   +-column_list=t.[key#9, TestEnum#10, AnotherTestEnum#11]
            |   +-describe_text=
            |   |   """
            |   |   NameList:
            |   |     key INT32 t.key#9
            |   |     TestEnum zetasql_test__.TestEnum t.TestEnum#10
            |   |     AnotherTestEnum zetasql_test__.AnotherTestEnum t.AnotherTestEnum#11
            |   |   NameScope:
            |   |     Names:
            |   |       AnotherTestEnum -> zetasql_test__.AnotherTestEnum (t.AnotherTestEnum#11) (implicit)
            |   |       TestEnum -> zetasql_test__.TestEnum (t.TestEnum#10) (implicit)
            |   |       key -> INT32 (t.key#9) (implicit)
            |   |     Range variables:
            |   |       t -> RANGE_VARIABLE<key,TestEnum,AnotherTestEnum>
            |   |   """
            |   +-input_scan=
            |     +-RecursiveRefScan(column_list=t.[key#9, TestEnum#10, AnotherTestEnum#11])
            +-output_column_list=t.[key#9, TestEnum#10, AnotherTestEnum#11]
==

# Pseudo columns are not preserved by the pipe recursive union.
from TestExtraValueTable AS input_table
|> where Filename = 'abc'
|> recursive union all (
  {{from t|}}
  |> select Filename
) as t;
--
ERROR: Unrecognized name: Filename [at 5:13]
  |> select Filename
            ^
==

# Subpipeline w/o alias: Pseudo columns are not preserved by the pipe recursive
# union.
from TestExtraValueTable
|> static_describe
|> recursive union all (
  |> static_describe
)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.TestExtraValueTable#4 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.TestExtraValueTable#4]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     TestExtraValueTable zetasql_test__.TestExtraPB $union_all.TestExtraValueTable#4 (value table)
    |   NameScope:
    |     Range variables:
    |       TestExtraValueTable -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       $union_all.TestExtraValueTable#4
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.TestExtraValueTable#4]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=[TestExtraValueTable.value#1]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList (is_value_table = true):
        |   |   |     TestExtraValueTable zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
        |   |   |   NameScope:
        |   |   |     Names:
        |   |   |       Filename -> STRING (TestExtraValueTable.Filename#2) (implicit) (pseudo-column)
        |   |   |       RowId -> BYTES (TestExtraValueTable.RowId#3) (implicit) (pseudo-column)
        |   |   |     Range variables:
        |   |   |       TestExtraValueTable -> RANGE_VARIABLE<$value>
        |   |   |     Value table columns:
        |   |   |       TestExtraValueTable.value#1
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        |   +-output_column_list=[TestExtraValueTable.value#1]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-StaticDescribeScan
            |   +-column_list=[$pipe_recursive_union.TestExtraValueTable#5]
            |   +-describe_text=
            |   |   """
            |   |   NameList (is_value_table = true):
            |   |     TestExtraValueTable zetasql_test__.TestExtraPB $pipe_recursive_union.TestExtraValueTable#5 (value table)
            |   |   NameScope:
            |   |     Range variables:
            |   |       TestExtraValueTable -> RANGE_VARIABLE<$value>
            |   |     Value table columns:
            |   |       $pipe_recursive_union.TestExtraValueTable#5
            |   |   """
            |   +-input_scan=
            |     +-RecursiveRefScan(column_list=[$pipe_recursive_union.TestExtraValueTable#5])
            +-output_column_list=[$pipe_recursive_union.TestExtraValueTable#5]
==

# Same as above but with explicit error.
from TestExtraValueTable
|> where Filename = 'abc'
|> recursive union all (
  |> where Filename = 'xyz'
)
--
ERROR: Unrecognized name: Filename [at 4:12]
  |> where Filename = 'xyz'
           ^
==

# The alias `t` is output, but the `|> union all (from t)` does not error
# because the identifier t is resolved as the name of the with recursive, not
# the output alias for pipe recursive union.
with recursive t as (
  from keyvalue
  |> recursive union all (
    {{from t|}}
  ) as t
  |> union all (from t)
)
from t
--
QueryStmt
+-output_column_list=
| +-t.Key#11 AS Key [INT64]
| +-t.Value#12 AS Value [STRING]
+-query=
  +-WithScan
    +-column_list=t.[Key#11, Value#12]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=$union_all.[Key#7, Value#8]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-RecursiveScan
    |       |   |   +-column_list=$union_all.[Key#3, Value#4]
    |       |   |   +-op_type=UNION_ALL
    |       |   |   +-non_recursive_term=
    |       |   |   | +-SetOperationItem
    |       |   |   |   +-scan=
    |       |   |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |       |   |   |   +-output_column_list=KeyValue.[Key#1, Value#2]
    |       |   |   +-recursive_term=
    |       |   |     +-SetOperationItem
    |       |   |       +-scan=
    |       |   |       | +-RecursiveRefScan(column_list=t_1.[Key#5, Value#6])
    |       |   |       +-output_column_list=t_1.[Key#5, Value#6]
    |       |   +-output_column_list=$union_all.[Key#3, Value#4]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-RecursiveRefScan(column_list=t.[Key#9, Value#10])
    |           +-output_column_list=t.[Key#9, Value#10]
    +-query=
    | +-WithRefScan(column_list=t.[Key#11, Value#12], with_query_name="t")
    +-recursive=TRUE
==

# Subquery input: Cannot reference the recursive term in the outer scope.
with recursive outer_alias as (
  from keyvalue
  |> union all (
    from outer_alias
    |> recursive union all (
      from outer_alias
      |> union all (from inner_alias)
    ) AS inner_alias
  )
)
from outer_alias;
--
ERROR: Table 'outer_alias' must not be recursively referenced from inside an inner recursive query [at 6:12]
      from outer_alias
           ^
==

# Subpipeline input: Cannot reference the recursive term in the outer scope.
with recursive outer_alias as (
  from keyvalue
  |> union all (
    from outer_alias
    |> recursive union all (
      |> union all (from outer_alias)
    )
  )
)
from outer_alias;
--
ERROR: Table 'outer_alias' must not be recursively referenced from inside an inner recursive query [at 6:26]
      |> union all (from outer_alias)
                         ^
==

# Subquery: with recursive used inside pipe recursive union.
from keyvalue
|> recursive union all (
  with recursive s as (
    from keyvalue
    |> union all (
      from s
    )
  )
  from s
  |> union all (from t)
) as t
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-WithScan
        |   +-column_list=$union_all.[Key#15, Value#16]
        |   +-with_entry_list=
        |   | +-WithEntry
        |   |   +-with_query_name="s"
        |   |   +-with_subquery=
        |   |     +-RecursiveScan
        |   |       +-column_list=$union_all.[Key#7, Value#8]
        |   |       +-op_type=UNION_ALL
        |   |       +-non_recursive_term=
        |   |       | +-SetOperationItem
        |   |       |   +-scan=
        |   |       |   | +-TableScan(column_list=KeyValue.[Key#5, Value#6], table=KeyValue, column_index_list=[0, 1])
        |   |       |   +-output_column_list=KeyValue.[Key#5, Value#6]
        |   |       +-recursive_term=
        |   |         +-SetOperationItem
        |   |           +-scan=
        |   |           | +-RecursiveRefScan(column_list=s.[Key#9, Value#10])
        |   |           +-output_column_list=s.[Key#9, Value#10]
        |   +-query=
        |   | +-SetOperationScan
        |   |   +-column_list=$union_all.[Key#15, Value#16]
        |   |   +-op_type=UNION_ALL
        |   |   +-input_item_list=
        |   |     +-SetOperationItem
        |   |     | +-scan=
        |   |     | | +-WithRefScan(column_list=s.[Key#11, Value#12], with_query_name="s")
        |   |     | +-output_column_list=s.[Key#11, Value#12]
        |   |     +-SetOperationItem
        |   |       +-scan=
        |   |       | +-RecursiveRefScan(column_list=t.[Key#13, Value#14])
        |   |       +-output_column_list=t.[Key#13, Value#14]
        |   +-recursive=TRUE
        +-output_column_list=$union_all.[Key#15, Value#16]
==

# Subpipeline: with recursive used inside pipe recursive union.
from keyvalue
|> recursive union all (
  |> union all (
    with recursive s as (
      from keyvalue
      |> union all (
        from s
      )
    )
    from s
  )
)
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-SetOperationScan
        |   +-column_list=$union_all.[Key#15, Value#16]
        |   +-op_type=UNION_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-RecursiveRefScan(column_list=$pipe_recursive_union.[Key#5, Value#6])
        |     | +-output_column_list=$pipe_recursive_union.[Key#5, Value#6]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-WithScan
        |       |   +-column_list=s.[Key#13, Value#14]
        |       |   +-with_entry_list=
        |       |   | +-WithEntry
        |       |   |   +-with_query_name="s"
        |       |   |   +-with_subquery=
        |       |   |     +-RecursiveScan
        |       |   |       +-column_list=$union_all.[Key#9, Value#10]
        |       |   |       +-op_type=UNION_ALL
        |       |   |       +-non_recursive_term=
        |       |   |       | +-SetOperationItem
        |       |   |       |   +-scan=
        |       |   |       |   | +-TableScan(column_list=KeyValue.[Key#7, Value#8], table=KeyValue, column_index_list=[0, 1])
        |       |   |       |   +-output_column_list=KeyValue.[Key#7, Value#8]
        |       |   |       +-recursive_term=
        |       |   |         +-SetOperationItem
        |       |   |           +-scan=
        |       |   |           | +-RecursiveRefScan(column_list=s.[Key#11, Value#12])
        |       |   |           +-output_column_list=s.[Key#11, Value#12]
        |       |   +-query=
        |       |   | +-WithRefScan(column_list=s.[Key#13, Value#14], with_query_name="s")
        |       |   +-recursive=TRUE
        |       +-output_column_list=s.[Key#13, Value#14]
        +-output_column_list=$union_all.[Key#15, Value#16]
==

# Subquery: with recursive used inside pipe recursive union with the same alias.
# Because the inner scope t shadows the outer scope t, the analyzer will
# complain that the recursive term does not reference itself.
from keyvalue
|> recursive union all (
  with recursive t as (
    from keyvalue
    |> union all (
      from t
    )
  )
  from t
  |> union all (from t)
) as t
--
ERROR: Recursive union subquery must contain a reference to the recursive input table t [at 2:24]
|> recursive union all (
                       ^
==

# Subpipeline: WITH RECURSIVE used inside pipe recursive union with the same
# alias. The "t" in the recursive term is the t defined in WITH RECURSIVE, not
# the t defined in the outer scope.
from keyvalue
|> recursive union all (
  |> union all (
    with recursive t as (
      select 1 as my_key, "my_value" as my_value
      |> union all (
        from t
      )
    )
    from t
    |> static_describe
  )
) as t
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-SetOperationScan
        |   +-column_list=$union_all.[Key#15, Value#16]
        |   +-op_type=UNION_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
        |     | +-output_column_list=t.[Key#5, Value#6]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-WithScan
        |       |   +-column_list=t_1.[my_key#13, my_value#14]
        |       |   +-with_entry_list=
        |       |   | +-WithEntry
        |       |   |   +-with_query_name="t_1"
        |       |   |   +-with_subquery=
        |       |   |     +-RecursiveScan
        |       |   |       +-column_list=$union_all.[my_key#9, my_value#10]
        |       |   |       +-op_type=UNION_ALL
        |       |   |       +-non_recursive_term=
        |       |   |       | +-SetOperationItem
        |       |   |       |   +-scan=
        |       |   |       |   | +-ProjectScan
        |       |   |       |   |   +-column_list=$union_all1.[my_key#7, my_value#8]
        |       |   |       |   |   +-expr_list=
        |       |   |       |   |   | +-my_key#7 := Literal(type=INT64, value=1)
        |       |   |       |   |   | +-my_value#8 := Literal(type=STRING, value="my_value")
        |       |   |       |   |   +-input_scan=
        |       |   |       |   |     +-SingleRowScan
        |       |   |       |   +-output_column_list=$union_all1.[my_key#7, my_value#8]
        |       |   |       +-recursive_term=
        |       |   |         +-SetOperationItem
        |       |   |           +-scan=
        |       |   |           | +-RecursiveRefScan(column_list=t_1.[my_key#11, my_value#12])
        |       |   |           +-output_column_list=t_1.[my_key#11, my_value#12]
        |       |   +-query=
        |       |   | +-StaticDescribeScan
        |       |   |   +-column_list=t_1.[my_key#13, my_value#14]
        |       |   |   +-describe_text=
        |       |   |   |   """
        |       |   |   |   NameList:
        |       |   |   |     my_key INT64 t_1.my_key#13
        |       |   |   |     my_value STRING t_1.my_value#14
        |       |   |   |   NameScope:
        |       |   |   |     Names:
        |       |   |   |       my_key -> INT64 (t_1.my_key#13)
        |       |   |   |       my_value -> STRING (t_1.my_value#14)
        |       |   |   |     Range variables:
        |       |   |   |       t -> RANGE_VARIABLE<my_key,my_value>
        |       |   |   |   """
        |       |   |   +-input_scan=
        |       |   |     +-WithRefScan(column_list=t_1.[my_key#13, my_value#14], with_query_name="t_1")
        |       |   +-recursive=TRUE
        |       +-output_column_list=t_1.[my_key#13, my_value#14]
        +-output_column_list=$union_all.[Key#15, Value#16]
==

# Subquery: with recursive used inside pipe recursive union. Cannot reference
# the recursive term in the outer scope.
from keyvalue
|> recursive union all (
  with recursive inner_alias as (
    from keyvalue
    |> union all (
      from outer_alias
      |> union all (from inner_alias)
    )
  )
  from inner_alias
  |> union all (from outer_alias)
) as outer_alias
--
ERROR: Table 'outer_alias' must not be recursively referenced from inside an inner recursive query [at 6:12]
      from outer_alias
           ^
==

# Subpipeline: with recursive used inside pipe recursive union. Cannot reference
# the recursive term in the outer scope.
from keyvalue
|> recursive union all (
  |> join (
    with recursive inner_alias as (
      from keyvalue
      |> union all (
        from outer_alias
        |> union all (from inner_alias)
      )
    )
    from inner_alias
  ) on true
) as outer_alias
--
ERROR: Referencing the recursive table alias inside a RECURSIVE UNION subpipeline is not allowed [at 7:14]
        from outer_alias
             ^
==

# Subquery: Non-recursive CTE inside the recursive union is not allowed to
# reference the recursive term.
from keyvalue
|> recursive union all (
  with inner_table as (
    from t
  )
  from t
) as t
--
ERROR: Table 't' must not be recursively referenced from inside an inner recursive query [at 4:10]
    from t
         ^
==

# Subpipeline input does not allow referencing the recursive term as scan.
from keyvalue
|> recursive union all (
  |> join t using (key)
  |> select key, t.value
) as t
--
ERROR: Referencing the recursive table alias inside a RECURSIVE UNION subpipeline is not allowed [at 3:11]
  |> join t using (key)
          ^
==

# The recursive reference can be used as a range variable for subpipeline.
from keyvalue
|> recursive union all (
  |> join keyvalue on (keyvalue.key = t.key)
  |> select t.key, t.value
) as t
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=t.[Key#5, Value#6]
        |   +-input_scan=
        |     +-JoinScan
        |       +-column_list=[t.Key#5, t.Value#6, KeyValue.Key#7]
        |       +-left_scan=
        |       | +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
        |       +-right_scan=
        |       | +-TableScan(column_list=[KeyValue.Key#7], table=KeyValue, column_index_list=[0])
        |       +-join_expr=
        |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |           +-ColumnRef(type=INT64, column=KeyValue.Key#7)
        |           +-ColumnRef(type=INT64, column=t.Key#5)
        +-output_column_list=t.[Key#5, Value#6]
==

# Subpipeline: Non-recursive CTE inside the recursive union is not allowed to
# reference the recursive term.
from keyvalue
|> recursive union all (
  |> union all (
    with inner_table as (
      from t
    )
    from inner_table
  )
) as t
--
ERROR: Referencing the recursive table alias inside a RECURSIVE UNION subpipeline is not allowed [at 5:12]
      from t
           ^
==

# Nested recursive union.
from keyvalue
|> recursive union all (
  {{from outer_alias|}}
  |> recursive union all (
    {{from inner_alias|}}
  ) AS inner_alias
) AS outer_alias
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-RecursiveScan
        |   +-column_list=$union_all.[Key#7, Value#8]
        |   +-op_type=UNION_ALL
        |   +-non_recursive_term=
        |   | +-SetOperationItem
        |   |   +-scan=
        |   |   | +-RecursiveRefScan(column_list=outer_alias.[Key#5, Value#6])
        |   |   +-output_column_list=outer_alias.[Key#5, Value#6]
        |   +-recursive_term=
        |     +-SetOperationItem
        |       +-scan=
        |       | +-RecursiveRefScan(column_list=inner_alias.[Key#9, Value#10])
        |       +-output_column_list=inner_alias.[Key#9, Value#10]
        +-output_column_list=$union_all.[Key#7, Value#8]
==

# Nested subpipeline recursive union with and without aliases.
from keyvalue
|> recursive union all (
  |> select key + 1 as key, value
  |> recursive union all (
    |> where key > 0
  ){{| as inner_alias}}
){{| as outer_alias}}
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-RecursiveScan
        |   +-column_list=$union_all.[key#8, value#9]
        |   +-op_type=UNION_ALL
        |   +-non_recursive_term=
        |   | +-SetOperationItem
        |   |   +-scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$pipe_select.key#7, $pipe_recursive_union.Value#6]
        |   |   |   +-expr_list=
        |   |   |   | +-key#7 :=
        |   |   |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |   |   |     +-ColumnRef(type=INT64, column=$pipe_recursive_union.Key#5)
        |   |   |   |     +-Literal(type=INT64, value=1)
        |   |   |   +-input_scan=
        |   |   |     +-RecursiveRefScan(column_list=$pipe_recursive_union.[Key#5, Value#6])
        |   |   +-output_column_list=[$pipe_select.key#7, $pipe_recursive_union.Value#6]
        |   +-recursive_term=
        |     +-SetOperationItem
        |       +-scan=
        |       | +-FilterScan
        |       |   +-column_list=$pipe_recursive_union_1.[key#10, value#11]
        |       |   +-input_scan=
        |       |   | +-RecursiveRefScan(column_list=$pipe_recursive_union_1.[key#10, value#11])
        |       |   +-filter_expr=
        |       |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |       |       +-ColumnRef(type=INT64, column=$pipe_recursive_union_1.key#10)
        |       |       +-Literal(type=INT64, value=0)
        |       +-output_column_list=$pipe_recursive_union_1.[key#10, value#11]
        +-output_column_list=$union_all.[key#8, value#9]
--
ALTERNATION GROUP:  as outer_alias
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-RecursiveScan
        |   +-column_list=$union_all.[key#8, value#9]
        |   +-op_type=UNION_ALL
        |   +-non_recursive_term=
        |   | +-SetOperationItem
        |   |   +-scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$pipe_select.key#7, outer_alias.Value#6]
        |   |   |   +-expr_list=
        |   |   |   | +-key#7 :=
        |   |   |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |   |   |     +-ColumnRef(type=INT64, column=outer_alias.Key#5)
        |   |   |   |     +-Literal(type=INT64, value=1)
        |   |   |   +-input_scan=
        |   |   |     +-RecursiveRefScan(column_list=outer_alias.[Key#5, Value#6])
        |   |   +-output_column_list=[$pipe_select.key#7, outer_alias.Value#6]
        |   +-recursive_term=
        |     +-SetOperationItem
        |       +-scan=
        |       | +-FilterScan
        |       |   +-column_list=$pipe_recursive_union.[key#10, value#11]
        |       |   +-input_scan=
        |       |   | +-RecursiveRefScan(column_list=$pipe_recursive_union.[key#10, value#11])
        |       |   +-filter_expr=
        |       |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |       |       +-ColumnRef(type=INT64, column=$pipe_recursive_union.key#10)
        |       |       +-Literal(type=INT64, value=0)
        |       +-output_column_list=$pipe_recursive_union.[key#10, value#11]
        +-output_column_list=$union_all.[key#8, value#9]
--
ALTERNATION GROUP:  as inner_alias,
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-RecursiveScan
        |   +-column_list=$union_all.[key#8, value#9]
        |   +-op_type=UNION_ALL
        |   +-non_recursive_term=
        |   | +-SetOperationItem
        |   |   +-scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$pipe_select.key#7, $pipe_recursive_union.Value#6]
        |   |   |   +-expr_list=
        |   |   |   | +-key#7 :=
        |   |   |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |   |   |     +-ColumnRef(type=INT64, column=$pipe_recursive_union.Key#5)
        |   |   |   |     +-Literal(type=INT64, value=1)
        |   |   |   +-input_scan=
        |   |   |     +-RecursiveRefScan(column_list=$pipe_recursive_union.[Key#5, Value#6])
        |   |   +-output_column_list=[$pipe_select.key#7, $pipe_recursive_union.Value#6]
        |   +-recursive_term=
        |     +-SetOperationItem
        |       +-scan=
        |       | +-FilterScan
        |       |   +-column_list=inner_alias.[key#10, value#11]
        |       |   +-input_scan=
        |       |   | +-RecursiveRefScan(column_list=inner_alias.[key#10, value#11])
        |       |   +-filter_expr=
        |       |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |       |       +-ColumnRef(type=INT64, column=inner_alias.key#10)
        |       |       +-Literal(type=INT64, value=0)
        |       +-output_column_list=inner_alias.[key#10, value#11]
        +-output_column_list=$union_all.[key#8, value#9]
--
ALTERNATION GROUP:  as inner_alias, as outer_alias
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-RecursiveScan
        |   +-column_list=$union_all.[key#8, value#9]
        |   +-op_type=UNION_ALL
        |   +-non_recursive_term=
        |   | +-SetOperationItem
        |   |   +-scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$pipe_select.key#7, outer_alias.Value#6]
        |   |   |   +-expr_list=
        |   |   |   | +-key#7 :=
        |   |   |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |   |   |     +-ColumnRef(type=INT64, column=outer_alias.Key#5)
        |   |   |   |     +-Literal(type=INT64, value=1)
        |   |   |   +-input_scan=
        |   |   |     +-RecursiveRefScan(column_list=outer_alias.[Key#5, Value#6])
        |   |   +-output_column_list=[$pipe_select.key#7, outer_alias.Value#6]
        |   +-recursive_term=
        |     +-SetOperationItem
        |       +-scan=
        |       | +-FilterScan
        |       |   +-column_list=inner_alias.[key#10, value#11]
        |       |   +-input_scan=
        |       |   | +-RecursiveRefScan(column_list=inner_alias.[key#10, value#11])
        |       |   +-filter_expr=
        |       |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |       |       +-ColumnRef(type=INT64, column=inner_alias.key#10)
        |       |       +-Literal(type=INT64, value=0)
        |       +-output_column_list=inner_alias.[key#10, value#11]
        +-output_column_list=$union_all.[key#8, value#9]
==

# Nested recursive union with the same alias. The regular name shadowing rule
# applies.
from keyvalue
|> recursive union all (
  {{from t|}}
  |> recursive union all (
    {{from t|}}
  ) as t
) AS t
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-RecursiveScan
        |   +-column_list=$union_all.[Key#7, Value#8]
        |   +-op_type=UNION_ALL
        |   +-non_recursive_term=
        |   | +-SetOperationItem
        |   |   +-scan=
        |   |   | +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
        |   |   +-output_column_list=t.[Key#5, Value#6]
        |   +-recursive_term=
        |     +-SetOperationItem
        |       +-scan=
        |       | +-RecursiveRefScan(column_list=t_1.[Key#9, Value#10])
        |       +-output_column_list=t_1.[Key#9, Value#10]
        +-output_column_list=$union_all.[Key#7, Value#8]
==

# Nested recursive union: Cannot reference the recursive term in the outer
# scope.
from keyvalue
|> recursive union all (
  {{from outer_alias|}}
  |> recursive union all (
    {{from inner_alias|}}
    |> union all (from outer_alias)
  ) AS inner_alias
) AS outer_alias
--
ALTERNATION GROUPS:
    from outer_alias,from inner_alias
    from outer_alias,
--
ERROR: Table 'outer_alias' must not be recursively referenced from inside an inner recursive query [at 6:24]
    |> union all (from outer_alias)
                       ^
--
ALTERNATION GROUPS:
    from inner_alias
    <empty>
--
ERROR: Referencing the recursive table alias inside a RECURSIVE UNION subpipeline is not allowed [at 6:24]
    |> union all (from outer_alias)
                       ^
==

# Multiple recursive references to the same recursive table are not allowed.
# For the subpipeline case, referencing the recursive table as scan is not
# allowed.
from keyvalue
|> recursive union all (
  {{from t|}}
  |> union all (from t)
) as t
--
ALTERNATION GROUP: from t
--
ERROR: Multiple recursive references to table 't' are not allowed [at 4:22]
  |> union all (from t)
                     ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Referencing the recursive table alias inside a RECURSIVE UNION subpipeline is not allowed [at 4:22]
  |> union all (from t)
                     ^
==

# The recursive reference is not the initial table scan (it's "from keyvalue").
# This can only happen when the input is a subquery.
from keyvalue
|> recursive union all (
  from keyvalue
  |> union all (from t)
) as t
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-SetOperationScan
        |   +-column_list=$union_all.[Key#9, Value#10]
        |   +-op_type=UNION_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-TableScan(column_list=KeyValue.[Key#5, Value#6], table=KeyValue, column_index_list=[0, 1])
        |     | +-output_column_list=KeyValue.[Key#5, Value#6]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-RecursiveRefScan(column_list=t.[Key#7, Value#8])
        |       +-output_column_list=t.[Key#7, Value#8]
        +-output_column_list=$union_all.[Key#9, Value#10]
==

from keyvalue
|> recursive union all (
  from keyvalue
  |> join t using (key)
  |> select key, CONCAT(keyvalue.value, t.value)
) as t
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[KeyValue.Key#5, $pipe_select.$col2#9]
        |   +-expr_list=
        |   | +-$col2#9 :=
        |   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
        |   |     +-ColumnRef(type=STRING, column=KeyValue.Value#6)
        |   |     +-ColumnRef(type=STRING, column=t.Value#8)
        |   +-input_scan=
        |     +-JoinScan
        |       +-column_list=[KeyValue.Key#5, KeyValue.Value#6, t.Key#7, t.Value#8]
        |       +-left_scan=
        |       | +-TableScan(column_list=KeyValue.[Key#5, Value#6], table=KeyValue, column_index_list=[0, 1])
        |       +-right_scan=
        |       | +-RecursiveRefScan(column_list=t.[Key#7, Value#8])
        |       +-join_expr=
        |       | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       |   +-ColumnRef(type=INT64, column=KeyValue.Key#5)
        |       |   +-ColumnRef(type=INT64, column=t.Key#7)
        |       +-has_using=TRUE
        +-output_column_list=[KeyValue.Key#5, $pipe_select.$col2#9]
==

# The alias is output as a range variable.
from keyvalue
|> recursive union all (
  {{from t|}}
) as t
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-StaticDescribeScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-describe_text=
    |   """
    |   NameList:
    |     Key INT64 $union_all.Key#3
    |     Value STRING $union_all.Value#4
    |   NameScope:
    |     Names:
    |       Key -> INT64 ($union_all.Key#3) (implicit)
    |       Value -> STRING ($union_all.Value#4) (implicit)
    |     Range variables:
    |       t -> RANGE_VARIABLE<Key,Value>
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=$union_all.[Key#3, Value#4]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-output_column_list=KeyValue.[Key#1, Value#2]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
            +-output_column_list=t.[Key#5, Value#6]
==

# The pipe recursive alias is also an input alias that can be referenced in the
# recursive term.
from keyvalue
|> select key,
|> recursive union all (
  {{from alias|}}
  |> INNER JOIN (FROM keyvalue) ON (alias.key = keyvalue.key)
  |> select alias.key
) AS alias
--
QueryStmt
+-output_column_list=
| +-$union_all.key#3 AS key [INT64]
+-query=
  +-RecursiveScan
    +-column_list=[$union_all.key#3]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[KeyValue.Key#1]
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   +-output_column_list=[KeyValue.Key#1]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[alias.key#4]
        |   +-input_scan=
        |     +-JoinScan
        |       +-column_list=[alias.key#4, KeyValue.Key#5]
        |       +-left_scan=
        |       | +-RecursiveRefScan(column_list=[alias.key#4])
        |       +-right_scan=
        |       | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0])
        |       +-join_expr=
        |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |           +-ColumnRef(type=INT64, column=alias.key#4)
        |           +-ColumnRef(type=INT64, column=KeyValue.Key#5)
        +-output_column_list=[alias.key#4]
==

# The "from t" in the recursive term is resolved as the recursive table, not the
# input table.
from keyvalue
|> as t
|> static_describe
|> recursive union all (
  {{from t|}}
  |> static_describe
) as t
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-StaticDescribeScan
    |   |   +-column_list=KeyValue.[Key#1, Value#2]
    |   |   +-describe_text=
    |   |   |   """
    |   |   |   NameList:
    |   |   |     Key INT64 KeyValue.Key#1
    |   |   |     Value STRING KeyValue.Value#2
    |   |   |   NameScope:
    |   |   |     Names:
    |   |   |       Key -> INT64 (KeyValue.Key#1) (implicit)
    |   |   |       Value -> STRING (KeyValue.Value#2) (implicit)
    |   |   |     Range variables:
    |   |   |       t -> RANGE_VARIABLE<Key,Value>
    |   |   |   """
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-StaticDescribeScan
        |   +-column_list=t.[Key#5, Value#6]
        |   +-describe_text=
        |   |   """
        |   |   NameList:
        |   |     Key INT64 t.Key#5
        |   |     Value STRING t.Value#6
        |   |   NameScope:
        |   |     Names:
        |   |       Key -> INT64 (t.Key#5) (implicit)
        |   |       Value -> STRING (t.Value#6) (implicit)
        |   |     Range variables:
        |   |       t -> RANGE_VARIABLE<Key,Value>
        |   |   """
        |   +-input_scan=
        |     +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
        +-output_column_list=t.[Key#5, Value#6]
==

# Correlated columns are not visible inside the recursive term.
select (
  select 1 as col
  |> recursive union all (
    {{from t|}}
    |> where col > key
  ) as t
  |> aggregate count(*)
)
from keyvalue
--
ERROR: Unrecognized name: key [at 5:20]
    |> where col > key
                   ^
==

# Correlated columns are allowed inside the base term of pipe recursive union.
# This is different from WITH RECURSIVE.
select (
  select key
  |> recursive union all (
    {{from t|}}
  ) as t
  |> aggregate count(*)
)
from keyvalue
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-subquery=
    |       +-AggregateScan
    |         +-column_list=[$aggregate.$agg1#6]
    |         +-input_scan=
    |         | +-RecursiveScan
    |         |   +-column_list=[$union_all.key#4]
    |         |   +-op_type=UNION_ALL
    |         |   +-non_recursive_term=
    |         |   | +-SetOperationItem
    |         |   |   +-scan=
    |         |   |   | +-ProjectScan
    |         |   |   |   +-column_list=[$expr_subquery.key#3]
    |         |   |   |   +-expr_list=
    |         |   |   |   | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         |   |   |   +-input_scan=
    |         |   |   |     +-SingleRowScan
    |         |   |   +-output_column_list=[$expr_subquery.key#3]
    |         |   +-recursive_term=
    |         |     +-SetOperationItem
    |         |       +-scan=
    |         |       | +-RecursiveRefScan(column_list=[t.key#5])
    |         |       +-output_column_list=[t.key#5]
    |         +-aggregate_list=
    |           +-$agg1#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
==

# Input is a value table and the output is also a value table.
from TestExtraValueTable
|> static_describe
|> recursive union all (
  {{from t|}}
  |> static_describe
) as t
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.TestExtraValueTable#4 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.TestExtraValueTable#4]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     t zetasql_test__.TestExtraPB $union_all.TestExtraValueTable#4 (value table)
    |   NameScope:
    |     Range variables:
    |       t -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       $union_all.TestExtraValueTable#4
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.TestExtraValueTable#4]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=[TestExtraValueTable.value#1]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList (is_value_table = true):
        |   |   |     TestExtraValueTable zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
        |   |   |   NameScope:
        |   |   |     Names:
        |   |   |       Filename -> STRING (TestExtraValueTable.Filename#2) (implicit) (pseudo-column)
        |   |   |       RowId -> BYTES (TestExtraValueTable.RowId#3) (implicit) (pseudo-column)
        |   |   |     Range variables:
        |   |   |       TestExtraValueTable -> RANGE_VARIABLE<$value>
        |   |   |     Value table columns:
        |   |   |       TestExtraValueTable.value#1
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        |   +-output_column_list=[TestExtraValueTable.value#1]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-StaticDescribeScan
            |   +-column_list=[t.t#5]
            |   +-describe_text=
            |   |   """
            |   |   NameList (is_value_table = true):
            |   |     t zetasql_test__.TestExtraPB t.t#5 (value table)
            |   |   NameScope:
            |   |     Range variables:
            |   |       t -> RANGE_VARIABLE<$value>
            |   |     Value table columns:
            |   |       t.t#5
            |   |   """
            |   +-input_scan=
            |     +-RecursiveRefScan(column_list=[t.t#5])
            +-output_column_list=[t.t#5]
==

# Subpipeline w/o alias: Input is a value table and the output is also a value
# table.
from TestExtraValueTable
|> static_describe
|> recursive union all (
  |> static_describe
)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.TestExtraValueTable#4 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.TestExtraValueTable#4]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     TestExtraValueTable zetasql_test__.TestExtraPB $union_all.TestExtraValueTable#4 (value table)
    |   NameScope:
    |     Range variables:
    |       TestExtraValueTable -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       $union_all.TestExtraValueTable#4
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.TestExtraValueTable#4]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=[TestExtraValueTable.value#1]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList (is_value_table = true):
        |   |   |     TestExtraValueTable zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
        |   |   |   NameScope:
        |   |   |     Names:
        |   |   |       Filename -> STRING (TestExtraValueTable.Filename#2) (implicit) (pseudo-column)
        |   |   |       RowId -> BYTES (TestExtraValueTable.RowId#3) (implicit) (pseudo-column)
        |   |   |     Range variables:
        |   |   |       TestExtraValueTable -> RANGE_VARIABLE<$value>
        |   |   |     Value table columns:
        |   |   |       TestExtraValueTable.value#1
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        |   +-output_column_list=[TestExtraValueTable.value#1]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-StaticDescribeScan
            |   +-column_list=[$pipe_recursive_union.TestExtraValueTable#5]
            |   +-describe_text=
            |   |   """
            |   |   NameList (is_value_table = true):
            |   |     TestExtraValueTable zetasql_test__.TestExtraPB $pipe_recursive_union.TestExtraValueTable#5 (value table)
            |   |   NameScope:
            |   |     Range variables:
            |   |       TestExtraValueTable -> RANGE_VARIABLE<$value>
            |   |     Value table columns:
            |   |       $pipe_recursive_union.TestExtraValueTable#5
            |   |   """
            |   +-input_scan=
            |     +-RecursiveRefScan(column_list=[$pipe_recursive_union.TestExtraValueTable#5])
            +-output_column_list=[$pipe_recursive_union.TestExtraValueTable#5]
==

# Input is a value table. The initial scan in the recursive term is not the
# recursive table. This can only happen when the recursive term is a subquery.
from TestExtraValueTable
|> static_describe
|> recursive union all (
  from TestExtraValueTable
  |> union all (
    from t
    |> static_describe
  )
) as t
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.TestExtraValueTable#4 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.TestExtraValueTable#4]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     t zetasql_test__.TestExtraPB $union_all.TestExtraValueTable#4 (value table)
    |   NameScope:
    |     Range variables:
    |       t -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       $union_all.TestExtraValueTable#4
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.TestExtraValueTable#4]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=[TestExtraValueTable.value#1]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList (is_value_table = true):
        |   |   |     TestExtraValueTable zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
        |   |   |   NameScope:
        |   |   |     Names:
        |   |   |       Filename -> STRING (TestExtraValueTable.Filename#2) (implicit) (pseudo-column)
        |   |   |       RowId -> BYTES (TestExtraValueTable.RowId#3) (implicit) (pseudo-column)
        |   |   |     Range variables:
        |   |   |       TestExtraValueTable -> RANGE_VARIABLE<$value>
        |   |   |     Value table columns:
        |   |   |       TestExtraValueTable.value#1
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        |   +-output_column_list=[TestExtraValueTable.value#1]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-SetOperationScan
            |   +-column_list=[$union_all.TestExtraValueTable#9]
            |   +-op_type=UNION_ALL
            |   +-input_item_list=
            |     +-SetOperationItem
            |     | +-scan=
            |     | | +-TableScan(column_list=[TestExtraValueTable.value#5], table=TestExtraValueTable, column_index_list=[0])
            |     | +-output_column_list=[TestExtraValueTable.value#5]
            |     +-SetOperationItem
            |       +-scan=
            |       | +-StaticDescribeScan
            |       |   +-column_list=[t.t#8]
            |       |   +-describe_text=
            |       |   |   """
            |       |   |   NameList (is_value_table = true):
            |       |   |     t zetasql_test__.TestExtraPB t.t#8 (value table)
            |       |   |   NameScope:
            |       |   |     Range variables:
            |       |   |       t -> RANGE_VARIABLE<$value>
            |       |   |     Value table columns:
            |       |   |       t.t#8
            |       |   |   """
            |       |   +-input_scan=
            |       |     +-RecursiveRefScan(column_list=[t.t#8])
            |       +-output_column_list=[t.t#8]
            +-output_column_list=[$union_all.TestExtraValueTable#9]
==

# The input is a value table and the recursive term is a non-value table. The
# output is a value table.
select as value 1
|> static_describe
|> recursive union all (
  {{from t|}}
  |> select 1 as col
  |> static_describe
) as t
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.$value_column#2 AS `$value` [INT64]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.$value_column#2]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     t INT64 $union_all.$value_column#2 (value table)
    |   NameScope:
    |     Range variables:
    |       t -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       $union_all.$value_column#2
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.$value_column#2]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=[$query.$col1#1]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList (is_value_table = true):
        |   |   |     <unnamed> INT64 $query.$col1#1 (value table)
        |   |   |   NameScope:
        |   |   |     Value table columns:
        |   |   |       $query.$col1#1
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[$query.$col1#1]
        |   |       +-expr_list=
        |   |       | +-$col1#1 := Literal(type=INT64, value=1)
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-output_column_list=[$query.$col1#1]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-StaticDescribeScan
            |   +-column_list=[$pipe_select.col#4]
            |   +-describe_text=
            |   |   """
            |   |   NameList:
            |   |     col INT64 $pipe_select.col#4
            |   |   NameScope:
            |   |     Names:
            |   |       col -> INT64 ($pipe_select.col#4)
            |   |   """
            |   +-input_scan=
            |     +-ProjectScan
            |       +-column_list=[$pipe_select.col#4]
            |       +-expr_list=
            |       | +-col#4 := Literal(type=INT64, value=1)
            |       +-input_scan=
            |         +-RecursiveRefScan(column_list=[t.t#3])
            +-output_column_list=[$pipe_select.col#4]
==

# Subpipeline w/o alias: The input is a value table and the recursive term is a
# non-value table. The output is a value table.
select as value 1
|> static_describe
|> recursive union all (
  |> select 1 as col
  |> static_describe
)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.$value_column#2 AS `$value_column` [INT64]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.$value_column#2]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     <unnamed> INT64 $union_all.$value_column#2 (value table)
    |   NameScope:
    |     Value table columns:
    |       $union_all.$value_column#2
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.$value_column#2]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=[$query.$col1#1]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList (is_value_table = true):
        |   |   |     <unnamed> INT64 $query.$col1#1 (value table)
        |   |   |   NameScope:
        |   |   |     Value table columns:
        |   |   |       $query.$col1#1
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[$query.$col1#1]
        |   |       +-expr_list=
        |   |       | +-$col1#1 := Literal(type=INT64, value=1)
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-output_column_list=[$query.$col1#1]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-StaticDescribeScan
            |   +-column_list=[$pipe_select.col#4]
            |   +-describe_text=
            |   |   """
            |   |   NameList:
            |   |     col INT64 $pipe_select.col#4
            |   |   NameScope:
            |   |     Names:
            |   |       col -> INT64 ($pipe_select.col#4)
            |   |   """
            |   +-input_scan=
            |     +-ProjectScan
            |       +-column_list=[$pipe_select.col#4]
            |       +-expr_list=
            |       | +-col#4 := Literal(type=INT64, value=1)
            |       +-input_scan=
            |         +-RecursiveRefScan(column_list=[$pipe_recursive_union.$value_column#3])
            +-output_column_list=[$pipe_select.col#4]
==

# With type coercion: the input is a value table and the recursive term is a
# non-value table. The output is a value table.
select as value cast(1 as int64)
|> recursive union all (
  {{from t|}}
  |> static_describe
  |> select cast(1 as int32) as col
) as t
--
QueryStmt
+-output_column_list=
| +-$union_all.$value_column#2 AS `$value` [INT64]
+-is_value_table=TRUE
+-query=
  +-RecursiveScan
    +-column_list=[$union_all.$value_column#2]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$query.$col1#1]
    |   |   +-expr_list=
    |   |   | +-$col1#1 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$query.$col1#1]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2_cast.col#5]
        |   +-expr_list=
        |   | +-col#5 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$pipe_select.col#4]
        |       +-expr_list=
        |       | +-col#4 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
        |       +-input_scan=
        |         +-StaticDescribeScan
        |           +-column_list=[t.t#3]
        |           +-describe_text=
        |           |   """
        |           |   NameList (is_value_table = true):
        |           |     t INT64 t.t#3 (value table)
        |           |   NameScope:
        |           |     Range variables:
        |           |       t -> RANGE_VARIABLE<$value>
        |           |     Value table columns:
        |           |       t.t#3
        |           |   """
        |           +-input_scan=
        |             +-RecursiveRefScan(column_list=[t.t#3])
        +-output_column_list=[$union_all2_cast.col#5]
==

# Similar to the one above but with subpipeline without alias.
select as value cast(1 as int64)
|> recursive union all (
  |> static_describe
  |> select cast(1 as int32) as col
)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.$value_column#2 AS `$value_column` [INT64]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.$value_column#2]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     <unnamed> INT64 $union_all.$value_column#2 (value table)
    |   NameScope:
    |     Value table columns:
    |       $union_all.$value_column#2
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.$value_column#2]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$query.$col1#1]
        |   |   +-expr_list=
        |   |   | +-$col1#1 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-output_column_list=[$query.$col1#1]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-ProjectScan
            |   +-column_list=[$union_all2_cast.col#5]
            |   +-expr_list=
            |   | +-col#5 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
            |   +-input_scan=
            |     +-ProjectScan
            |       +-column_list=[$pipe_select.col#4]
            |       +-expr_list=
            |       | +-col#4 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
            |       +-input_scan=
            |         +-StaticDescribeScan
            |           +-column_list=[$pipe_recursive_union.$value_column#3]
            |           +-describe_text=
            |           |   """
            |           |   NameList (is_value_table = true):
            |           |     <unnamed> INT64 $pipe_recursive_union.$value_column#3 (value table)
            |           |   NameScope:
            |           |     Value table columns:
            |           |       $pipe_recursive_union.$value_column#3
            |           |   """
            |           +-input_scan=
            |             +-RecursiveRefScan(column_list=[$pipe_recursive_union.$value_column#3])
            +-output_column_list=[$union_all2_cast.col#5]
==

# Cannot coerce int64 to int32.
select as value cast(1 as int32)
|> recursive union all (
  {{from t|}}
  |> select cast(1 as int64) as col
) as t
--
ERROR: Cannot coerce type (INT64) of column 1 in the recursive term to type (INT32) of column 1 in pipe input table [at 2:24]
|> recursive union all (
                       ^
==

# The input is not a value table and the recursive term is a value table. The
# output is not a value table.
select 1 as col
|> static_describe
|> recursive union all (
  {{from t|}}
  |> select as value 1
  |> static_describe
) as t
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.col#2 AS col [INT64]
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.col#2]
    +-describe_text=
    |   """
    |   NameList:
    |     col INT64 $union_all.col#2
    |   NameScope:
    |     Names:
    |       col -> INT64 ($union_all.col#2)
    |     Range variables:
    |       t -> RANGE_VARIABLE<col>
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.col#2]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=[$query.col#1]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList:
        |   |   |     col INT64 $query.col#1
        |   |   |   NameScope:
        |   |   |     Names:
        |   |   |       col -> INT64 ($query.col#1)
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[$query.col#1]
        |   |       +-expr_list=
        |   |       | +-col#1 := Literal(type=INT64, value=1)
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-output_column_list=[$query.col#1]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-StaticDescribeScan
            |   +-column_list=[$pipe_select.$col1#4]
            |   +-describe_text=
            |   |   """
            |   |   NameList (is_value_table = true):
            |   |     <unnamed> INT64 $pipe_select.$col1#4 (value table)
            |   |   NameScope:
            |   |     Value table columns:
            |   |       $pipe_select.$col1#4
            |   |   """
            |   +-input_scan=
            |     +-ProjectScan
            |       +-column_list=[$pipe_select.$col1#4]
            |       +-expr_list=
            |       | +-$col1#4 := Literal(type=INT64, value=1)
            |       +-input_scan=
            |         +-RecursiveRefScan(column_list=[t.col#3])
            +-output_column_list=[$pipe_select.$col1#4]
==

# Subpipeline without alias: The input is not a value table and the recursive
# term is a value table. The output is not a value table.
select 1 as col
|> recursive union all (
  |> static_describe
  |> select as value 1
  |> static_describe
)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.col#2 AS col [INT64]
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.col#2]
    +-describe_text=
    |   """
    |   NameList:
    |     col INT64 $union_all.col#2
    |   NameScope:
    |     Names:
    |       col -> INT64 ($union_all.col#2)
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.col#2]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$query.col#1]
        |   |   +-expr_list=
        |   |   | +-col#1 := Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-output_column_list=[$query.col#1]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-StaticDescribeScan
            |   +-column_list=[$pipe_select.$col1#4]
            |   +-describe_text=
            |   |   """
            |   |   NameList (is_value_table = true):
            |   |     <unnamed> INT64 $pipe_select.$col1#4 (value table)
            |   |   NameScope:
            |   |     Value table columns:
            |   |       $pipe_select.$col1#4
            |   |   """
            |   +-input_scan=
            |     +-ProjectScan
            |       +-column_list=[$pipe_select.$col1#4]
            |       +-expr_list=
            |       | +-$col1#4 := Literal(type=INT64, value=1)
            |       +-input_scan=
            |         +-StaticDescribeScan
            |           +-column_list=[$pipe_recursive_union.col#3]
            |           +-describe_text=
            |           |   """
            |           |   NameList:
            |           |     col INT64 $pipe_recursive_union.col#3
            |           |   NameScope:
            |           |     Names:
            |           |       col -> INT64 ($pipe_recursive_union.col#3)
            |           |   """
            |           +-input_scan=
            |             +-RecursiveRefScan(column_list=[$pipe_recursive_union.col#3])
            +-output_column_list=[$pipe_select.$col1#4]
==

# Similar to the one above but with type coercion.
select cast(1 as int64) as col
|> recursive union all (
  from t
  |> static_describe
  |> select as value cast(1 as int32)
) as t
--
QueryStmt
+-output_column_list=
| +-$union_all.col#2 AS col [INT64]
+-query=
  +-RecursiveScan
    +-column_list=[$union_all.col#2]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$query.col#1]
    |   |   +-expr_list=
    |   |   | +-col#1 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$query.col#1]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2_cast.$col1#5]
        |   +-expr_list=
        |   | +-$col1#5 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$pipe_select.$col1#4]
        |       +-expr_list=
        |       | +-$col1#4 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
        |       +-input_scan=
        |         +-StaticDescribeScan
        |           +-column_list=[t.col#3]
        |           +-describe_text=
        |           |   """
        |           |   NameList:
        |           |     col INT64 t.col#3
        |           |   NameScope:
        |           |     Names:
        |           |       col -> INT64 (t.col#3)
        |           |     Range variables:
        |           |       t -> RANGE_VARIABLE<col>
        |           |   """
        |           +-input_scan=
        |             +-RecursiveRefScan(column_list=[t.col#3])
        +-output_column_list=[$union_all2_cast.$col1#5]
==

# Cannot coerce int64 to int32.
select cast(1 as int32) as col
|> recursive union all (
  from t
  |> select as value cast(1 as int64)
) as t
--
ERROR: Cannot coerce type (INT64) of column 1 in the recursive term to type (INT32) of column 1 in pipe input table [at 2:24]
|> recursive union all (
                       ^
==

# Neither the output nor the RecursiveRefScan is ordered even though the input
# is.
from keyvalue
|> order by key
|> recursive union all (
  {{from t|}}
) as t
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-OrderByScan
    |   |   +-column_list=KeyValue.[Key#1, Value#2]
    |   |   +-is_ordered=TRUE
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-order_by_item_list=
    |   |     +-OrderByItem
    |   |       +-column_ref=
    |   |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
        +-output_column_list=t.[Key#5, Value#6]
==

# Subpipeline without alias: Neither the output nor the RecursiveRefScan is
# ordered even though the input is.
from keyvalue
|> order by key
|> recursive union all ()
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-OrderByScan
    |   |   +-column_list=KeyValue.[Key#1, Value#2]
    |   |   +-is_ordered=TRUE
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-order_by_item_list=
    |   |     +-OrderByItem
    |   |       +-column_ref=
    |   |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-RecursiveRefScan(column_list=$pipe_recursive_union.[Key#5, Value#6])
        +-output_column_list=$pipe_recursive_union.[Key#5, Value#6]
==

# TODO: b/370786791 - For the subpipeline case, the error message should not
# mention "subquery".
# The recursive term is not allowed to contain an ORDER BY clause.
from keyvalue
|> order by key
|> recursive union all (
  {{from t|}}
  |> order by key
) as t
--
ALTERNATION GROUP: from t
--
ERROR: A subquery containing a recursive reference must not contain an ORDER BY clause [at 4:8]
  from t
       ^
--
ALTERNATION GROUP: <empty>
--
ERROR: A subquery containing a recursive reference must not contain an ORDER BY clause [at 3:24]
|> recursive union all (
                       ^
==

# An error is reported when the usage of the implicit input to the subpipeline
# is invalid. Because the input to the subpipeline is implicit, the error
# location is set to the whole recursive term.
# TODO: b/370786791 - The error message should be updated to not include
# "subquery".
select 1 as col
|> recursive union all (
  |> aggregate sum(col) as col
)
--
ERROR: A subquery containing a recursive reference must not use DISTINCT, GROUP BY, or any aggregate function [at 2:24]
|> recursive union all (
                       ^
==

# Range variables in the outer scope cannot be referenced in the subpipeline.
from keyvalue
|> as t
|> recursive union all (
  |> select t.key + 1 as key, t.value as value
)
--
ERROR: Unrecognized name: t [at 4:13]
  |> select t.key + 1 as key, t.value as value
            ^
==

# Range variables in the outer scope cannot be referenced in the subpipeline.
from keyvalue as t1 join keyvalue as t2 using (key)
|> recursive union all (
   |> select t1.key, t2.value
)
--
ERROR: Unrecognized name: t1 [at 3:14]
   |> select t1.key, t2.value
             ^
==

# The existing range variables in the outer scope are still cleared even if the
# subpipelien input does not have an alias.
from keyvalue
as t
|> recursive union all (
  |> as a
)
|> inner join keyvalue on (t.key = keyvalue.key)
--
ERROR: Unrecognized name: t [at 6:28]
|> inner join keyvalue on (t.key = keyvalue.key)
                           ^
==

# The existing range variables inside the recursive term are cleared even if the
# subpipelien input does not have an alias.
from keyvalue
as t
|> recursive union all (
  |> as a
)
|> inner join keyvalue on (a.key = keyvalue.key)
--
ERROR: Unrecognized name: a [at 6:28]
|> inner join keyvalue on (a.key = keyvalue.key)
                           ^
==

# Mixed subpipeline and subquery and mixed aliases.
from keyvalue
|> recursive union all (
  from t
  |> recursive union all (
    |> where key > 0
  )
  |> recursive union all (
    {{from s|}}
    |> union all (from TestTable |> select 1 as key, "a" as value)
  ) as s
) as t
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-RecursiveScan
        |   +-column_list=$union_all.[Key#11, Value#12]
        |   +-op_type=UNION_ALL
        |   +-non_recursive_term=
        |   | +-SetOperationItem
        |   |   +-scan=
        |   |   | +-RecursiveScan
        |   |   |   +-column_list=$union_all.[Key#7, Value#8]
        |   |   |   +-op_type=UNION_ALL
        |   |   |   +-non_recursive_term=
        |   |   |   | +-SetOperationItem
        |   |   |   |   +-scan=
        |   |   |   |   | +-RecursiveRefScan(column_list=t.[Key#5, Value#6])
        |   |   |   |   +-output_column_list=t.[Key#5, Value#6]
        |   |   |   +-recursive_term=
        |   |   |     +-SetOperationItem
        |   |   |       +-scan=
        |   |   |       | +-FilterScan
        |   |   |       |   +-column_list=$pipe_recursive_union.[Key#9, Value#10]
        |   |   |       |   +-input_scan=
        |   |   |       |   | +-RecursiveRefScan(column_list=$pipe_recursive_union.[Key#9, Value#10])
        |   |   |       |   +-filter_expr=
        |   |   |       |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |   |   |       |       +-ColumnRef(type=INT64, column=$pipe_recursive_union.Key#9)
        |   |   |       |       +-Literal(type=INT64, value=0)
        |   |   |       +-output_column_list=$pipe_recursive_union.[Key#9, Value#10]
        |   |   +-output_column_list=$union_all.[Key#7, Value#8]
        |   +-recursive_term=
        |     +-SetOperationItem
        |       +-scan=
        |       | +-SetOperationScan
        |       |   +-column_list=$union_all.[Key#20, Value#21]
        |       |   +-op_type=UNION_ALL
        |       |   +-input_item_list=
        |       |     +-SetOperationItem
        |       |     | +-scan=
        |       |     | | +-RecursiveRefScan(column_list=s.[Key#13, Value#14])
        |       |     | +-output_column_list=s.[Key#13, Value#14]
        |       |     +-SetOperationItem
        |       |       +-scan=
        |       |       | +-ProjectScan
        |       |       |   +-column_list=$pipe_select.[key#18, value#19]
        |       |       |   +-expr_list=
        |       |       |   | +-key#18 := Literal(type=INT64, value=1)
        |       |       |   | +-value#19 := Literal(type=STRING, value="a")
        |       |       |   +-input_scan=
        |       |       |     +-TableScan(table=TestTable)
        |       |       +-output_column_list=$pipe_select.[key#18, value#19]
        |       +-output_column_list=$union_all.[Key#20, Value#21]
        +-output_column_list=$union_all.[Key#11, Value#12]
==

# Mixed subpipeline and subquery and mixed aliases.
from keyvalue
|> recursive union all (
  |> recursive union all (
    from t
    |> where key > 0
  ) as t
){{| as final_alias}}
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-RecursiveScan
        |   +-column_list=$union_all.[Key#7, Value#8]
        |   +-op_type=UNION_ALL
        |   +-non_recursive_term=
        |   | +-SetOperationItem
        |   |   +-scan=
        |   |   | +-RecursiveRefScan(column_list=$pipe_recursive_union.[Key#5, Value#6])
        |   |   +-output_column_list=$pipe_recursive_union.[Key#5, Value#6]
        |   +-recursive_term=
        |     +-SetOperationItem
        |       +-scan=
        |       | +-FilterScan
        |       |   +-column_list=t.[Key#9, Value#10]
        |       |   +-input_scan=
        |       |   | +-RecursiveRefScan(column_list=t.[Key#9, Value#10])
        |       |   +-filter_expr=
        |       |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |       |       +-ColumnRef(type=INT64, column=t.Key#9)
        |       |       +-Literal(type=INT64, value=0)
        |       +-output_column_list=t.[Key#9, Value#10]
        +-output_column_list=$union_all.[Key#7, Value#8]
--
ALTERNATION GROUP:  as final_alias
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-RecursiveScan
        |   +-column_list=$union_all.[Key#7, Value#8]
        |   +-op_type=UNION_ALL
        |   +-non_recursive_term=
        |   | +-SetOperationItem
        |   |   +-scan=
        |   |   | +-RecursiveRefScan(column_list=final_alias.[Key#5, Value#6])
        |   |   +-output_column_list=final_alias.[Key#5, Value#6]
        |   +-recursive_term=
        |     +-SetOperationItem
        |       +-scan=
        |       | +-FilterScan
        |       |   +-column_list=t.[Key#9, Value#10]
        |       |   +-input_scan=
        |       |   | +-RecursiveRefScan(column_list=t.[Key#9, Value#10])
        |       |   +-filter_expr=
        |       |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |       |       +-ColumnRef(type=INT64, column=t.Key#9)
        |       |       +-Literal(type=INT64, value=0)
        |       +-output_column_list=t.[Key#9, Value#10]
        +-output_column_list=$union_all.[Key#7, Value#8]
==

# Single input value table. The field f1 can be referenced directly but not
# through the value table alias vt1. This is because the recursive scan itself
# is a value table with the range variable `t`, not `vt1`.
from (select as value struct(1 as f1)) as vt1
|> static_describe
|> recursive union all (
  {{from t|}}
  |> static_describe
  |> select f1
  |> select struct(1)
  |> static_describe
) as t
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.vt1#2 AS `$value` [STRUCT<f1 INT64>]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.vt1#2]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     t STRUCT<f1 INT64> $union_all.vt1#2 (value table)
    |   NameScope:
    |     Range variables:
    |       t -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       $union_all.vt1#2
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.vt1#2]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=[vt1.$col1#1]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList (is_value_table = true):
        |   |   |     vt1 STRUCT<f1 INT64> vt1.$col1#1 (value table)
        |   |   |   NameScope:
        |   |   |     Range variables:
        |   |   |       vt1 -> RANGE_VARIABLE<$value>
        |   |   |     Value table columns:
        |   |   |       vt1.$col1#1
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[vt1.$col1#1]
        |   |       +-expr_list=
        |   |       | +-$col1#1 := Literal(type=STRUCT<f1 INT64>, value={f1:1})
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-output_column_list=[vt1.$col1#1]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-ProjectScan
            |   +-column_list=[$union_all2_cast.$col1#6]
            |   +-expr_list=
            |   | +-$col1#6 :=
            |   |   +-Cast(STRUCT<INT64> -> STRUCT<f1 INT64>)
            |   |     +-ColumnRef(type=STRUCT<INT64>, column=$pipe_select.$col1#5)
            |   +-input_scan=
            |     +-StaticDescribeScan
            |       +-column_list=[$pipe_select.$col1#5]
            |       +-describe_text=
            |       |   """
            |       |   NameList:
            |       |     <unnamed> STRUCT<INT64> $pipe_select.$col1#5
            |       |   NameScope:
            |       |   """
            |       +-input_scan=
            |         +-ProjectScan
            |           +-column_list=[$pipe_select.$col1#5]
            |           +-expr_list=
            |           | +-$col1#5 := Literal(type=STRUCT<INT64>, value={1})
            |           +-input_scan=
            |             +-ProjectScan
            |               +-column_list=[$pipe_select.f1#4]
            |               +-expr_list=
            |               | +-f1#4 :=
            |               |   +-GetStructField
            |               |     +-type=INT64
            |               |     +-expr=
            |               |     | +-ColumnRef(type=STRUCT<f1 INT64>, column=t.t#3)
            |               |     +-field_idx=0
            |               +-input_scan=
            |                 +-StaticDescribeScan
            |                   +-column_list=[t.t#3]
            |                   +-describe_text=
            |                   |   """
            |                   |   NameList (is_value_table = true):
            |                   |     t STRUCT<f1 INT64> t.t#3 (value table)
            |                   |   NameScope:
            |                   |     Range variables:
            |                   |       t -> RANGE_VARIABLE<$value>
            |                   |     Value table columns:
            |                   |       t.t#3
            |                   |   """
            |                   +-input_scan=
            |                     +-RecursiveRefScan(column_list=[t.t#3])
            +-output_column_list=[$union_all2_cast.$col1#6]
==

# Single input value table. The field f1 can be referenced directly but not
# through the value table alias vt1.
# The difference between this test and the previous one is that the recursive
# union does not have an alias. The output scan will have a range variable with
# the same name `vt1`.
from (select as value struct(1 as f1)) as vt1
|> static_describe
|> recursive union all (
  |> static_describe
  |> select f1
  |> select struct(1)
  |> static_describe
)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.vt1#2 AS `$value` [STRUCT<f1 INT64>]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.vt1#2]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     vt1 STRUCT<f1 INT64> $union_all.vt1#2 (value table)
    |   NameScope:
    |     Range variables:
    |       vt1 -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       $union_all.vt1#2
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.vt1#2]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=[vt1.$col1#1]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList (is_value_table = true):
        |   |   |     vt1 STRUCT<f1 INT64> vt1.$col1#1 (value table)
        |   |   |   NameScope:
        |   |   |     Range variables:
        |   |   |       vt1 -> RANGE_VARIABLE<$value>
        |   |   |     Value table columns:
        |   |   |       vt1.$col1#1
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[vt1.$col1#1]
        |   |       +-expr_list=
        |   |       | +-$col1#1 := Literal(type=STRUCT<f1 INT64>, value={f1:1})
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-output_column_list=[vt1.$col1#1]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-ProjectScan
            |   +-column_list=[$union_all2_cast.$col1#6]
            |   +-expr_list=
            |   | +-$col1#6 :=
            |   |   +-Cast(STRUCT<INT64> -> STRUCT<f1 INT64>)
            |   |     +-ColumnRef(type=STRUCT<INT64>, column=$pipe_select.$col1#5)
            |   +-input_scan=
            |     +-StaticDescribeScan
            |       +-column_list=[$pipe_select.$col1#5]
            |       +-describe_text=
            |       |   """
            |       |   NameList:
            |       |     <unnamed> STRUCT<INT64> $pipe_select.$col1#5
            |       |   NameScope:
            |       |   """
            |       +-input_scan=
            |         +-ProjectScan
            |           +-column_list=[$pipe_select.$col1#5]
            |           +-expr_list=
            |           | +-$col1#5 := Literal(type=STRUCT<INT64>, value={1})
            |           +-input_scan=
            |             +-ProjectScan
            |               +-column_list=[$pipe_select.f1#4]
            |               +-expr_list=
            |               | +-f1#4 :=
            |               |   +-GetStructField
            |               |     +-type=INT64
            |               |     +-expr=
            |               |     | +-ColumnRef(type=STRUCT<f1 INT64>, column=$pipe_recursive_union.vt1#3)
            |               |     +-field_idx=0
            |               +-input_scan=
            |                 +-StaticDescribeScan
            |                   +-column_list=[$pipe_recursive_union.vt1#3]
            |                   +-describe_text=
            |                   |   """
            |                   |   NameList (is_value_table = true):
            |                   |     vt1 STRUCT<f1 INT64> $pipe_recursive_union.vt1#3 (value table)
            |                   |   NameScope:
            |                   |     Range variables:
            |                   |       vt1 -> RANGE_VARIABLE<$value>
            |                   |     Value table columns:
            |                   |       $pipe_recursive_union.vt1#3
            |                   |   """
            |                   +-input_scan=
            |                     +-RecursiveRefScan(column_list=[$pipe_recursive_union.vt1#3])
            +-output_column_list=[$union_all2_cast.$col1#6]
==

# The negative test case demonstrating that f1 cannot be referenced through
# vt1
from (select as value struct(1 as f1)) as vt1
|> recursive union all (
  {{from t|}}
  |> select vt1.f1
  |> select struct(1)
) as t
--
ERROR: Unrecognized name: vt1 [at 4:13]
  |> select vt1.f1
            ^
==

# When the recursive union does not have an alias, the output scan has a range
# variable with the same name `vt1`, so the reference `vt1.f1` becomes valid
# inside the recursive term.
from (select as value struct(1 as f1)) as vt1
|> static_describe
|> recursive union all (
  |> static_describe
  |> select vt1.f1
  |> select struct(1)
  |> static_describe
)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.vt1#2 AS `$value` [STRUCT<f1 INT64>]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.vt1#2]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     vt1 STRUCT<f1 INT64> $union_all.vt1#2 (value table)
    |   NameScope:
    |     Range variables:
    |       vt1 -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       $union_all.vt1#2
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=[$union_all.vt1#2]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=[vt1.$col1#1]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList (is_value_table = true):
        |   |   |     vt1 STRUCT<f1 INT64> vt1.$col1#1 (value table)
        |   |   |   NameScope:
        |   |   |     Range variables:
        |   |   |       vt1 -> RANGE_VARIABLE<$value>
        |   |   |     Value table columns:
        |   |   |       vt1.$col1#1
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[vt1.$col1#1]
        |   |       +-expr_list=
        |   |       | +-$col1#1 := Literal(type=STRUCT<f1 INT64>, value={f1:1})
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-output_column_list=[vt1.$col1#1]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-ProjectScan
            |   +-column_list=[$union_all2_cast.$col1#6]
            |   +-expr_list=
            |   | +-$col1#6 :=
            |   |   +-Cast(STRUCT<INT64> -> STRUCT<f1 INT64>)
            |   |     +-ColumnRef(type=STRUCT<INT64>, column=$pipe_select.$col1#5)
            |   +-input_scan=
            |     +-StaticDescribeScan
            |       +-column_list=[$pipe_select.$col1#5]
            |       +-describe_text=
            |       |   """
            |       |   NameList:
            |       |     <unnamed> STRUCT<INT64> $pipe_select.$col1#5
            |       |   NameScope:
            |       |   """
            |       +-input_scan=
            |         +-ProjectScan
            |           +-column_list=[$pipe_select.$col1#5]
            |           +-expr_list=
            |           | +-$col1#5 := Literal(type=STRUCT<INT64>, value={1})
            |           +-input_scan=
            |             +-ProjectScan
            |               +-column_list=[$pipe_select.f1#4]
            |               +-expr_list=
            |               | +-f1#4 :=
            |               |   +-GetStructField
            |               |     +-type=INT64
            |               |     +-expr=
            |               |     | +-ColumnRef(type=STRUCT<f1 INT64>, column=$pipe_recursive_union.vt1#3)
            |               |     +-field_idx=0
            |               +-input_scan=
            |                 +-StaticDescribeScan
            |                   +-column_list=[$pipe_recursive_union.vt1#3]
            |                   +-describe_text=
            |                   |   """
            |                   |   NameList (is_value_table = true):
            |                   |     vt1 STRUCT<f1 INT64> $pipe_recursive_union.vt1#3 (value table)
            |                   |   NameScope:
            |                   |     Range variables:
            |                   |       vt1 -> RANGE_VARIABLE<$value>
            |                   |     Value table columns:
            |                   |       $pipe_recursive_union.vt1#3
            |                   |   """
            |                   +-input_scan=
            |                     +-RecursiveRefScan(column_list=[$pipe_recursive_union.vt1#3])
            +-output_column_list=[$union_all2_cast.$col1#6]
==

# Multiple value tables as the pipe input table. The recursive scan is not a
# value table, so unlike the single value table case, the fields `f1` and
# `int32_val1` cannot be referenced directly. However, they can be referenced
# through vt1 and vt2 because they are the columns of the recursive scan.
from (select as value struct(1 as f1)) as vt1,
     TestExtraValueTable as vt2
|> static_describe
|> recursive union all (
  {{from t|}}
  |> static_describe
  |> select vt1.f1, vt2.int32_val1
  |> select struct(1), cast(null as zetasql_test__.TestExtraPB)
  |> static_describe
) as t
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.vt1#5 AS vt1 [STRUCT<f1 INT64>]
| +-$union_all.vt2#6 AS vt2 [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-StaticDescribeScan
    +-column_list=$union_all.[vt1#5, vt2#6]
    +-describe_text=
    |   """
    |   NameList:
    |     vt1 STRUCT<f1 INT64> $union_all.vt1#5
    |     vt2 zetasql_test__.TestExtraPB $union_all.vt2#6
    |   NameScope:
    |     Names:
    |       vt1 -> STRUCT<f1 INT64> ($union_all.vt1#5) (implicit)
    |       vt2 -> zetasql_test__.TestExtraPB ($union_all.vt2#6) (implicit)
    |     Range variables:
    |       t -> RANGE_VARIABLE<vt1,vt2>
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=$union_all.[vt1#5, vt2#6]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=[vt1.$col1#1, TestExtraValueTable.value#2]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList:
        |   |   |     vt1 STRUCT<f1 INT64> vt1.$col1#1 (value table)
        |   |   |     vt2 zetasql_test__.TestExtraPB TestExtraValueTable.value#2 (value table)
        |   |   |   NameScope:
        |   |   |     Names:
        |   |   |       Filename -> STRING (TestExtraValueTable.Filename#3) (implicit) (pseudo-column)
        |   |   |       RowId -> BYTES (TestExtraValueTable.RowId#4) (implicit) (pseudo-column)
        |   |   |     Range variables:
        |   |   |       vt1 -> RANGE_VARIABLE<$value>
        |   |   |       vt2 -> RANGE_VARIABLE<$value>
        |   |   |     Value table columns:
        |   |   |       vt1.$col1#1
        |   |   |       TestExtraValueTable.value#2
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-JoinScan
        |   |       +-column_list=[vt1.$col1#1, TestExtraValueTable.value#2]
        |   |       +-left_scan=
        |   |       | +-ProjectScan
        |   |       |   +-column_list=[vt1.$col1#1]
        |   |       |   +-expr_list=
        |   |       |   | +-$col1#1 := Literal(type=STRUCT<f1 INT64>, value={f1:1})
        |   |       |   +-input_scan=
        |   |       |     +-SingleRowScan
        |   |       +-right_scan=
        |   |         +-TableScan(column_list=[TestExtraValueTable.value#2], table=TestExtraValueTable, column_index_list=[0], alias="vt2")
        |   +-output_column_list=[vt1.$col1#1, TestExtraValueTable.value#2]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-ProjectScan
            |   +-column_list=[$union_all2_cast.$col1#13, $pipe_select.$col2#12]
            |   +-expr_list=
            |   | +-$col1#13 :=
            |   |   +-Cast(STRUCT<INT64> -> STRUCT<f1 INT64>)
            |   |     +-ColumnRef(type=STRUCT<INT64>, column=$pipe_select.$col1#11)
            |   +-input_scan=
            |     +-StaticDescribeScan
            |       +-column_list=$pipe_select.[$col1#11, $col2#12]
            |       +-describe_text=
            |       |   """
            |       |   NameList:
            |       |     <unnamed> STRUCT<INT64> $pipe_select.$col1#11
            |       |     <unnamed> zetasql_test__.TestExtraPB $pipe_select.$col2#12
            |       |   NameScope:
            |       |   """
            |       +-input_scan=
            |         +-ProjectScan
            |           +-column_list=$pipe_select.[$col1#11, $col2#12]
            |           +-expr_list=
            |           | +-$col1#11 := Literal(type=STRUCT<INT64>, value={1})
            |           | +-$col2#12 := Literal(type=PROTO<zetasql_test__.TestExtraPB>, value=NULL, has_explicit_type=TRUE)
            |           +-input_scan=
            |             +-ProjectScan
            |               +-column_list=$pipe_select.[f1#9, int32_val1#10]
            |               +-expr_list=
            |               | +-f1#9 :=
            |               | | +-GetStructField
            |               | |   +-type=INT64
            |               | |   +-expr=
            |               | |   | +-ColumnRef(type=STRUCT<f1 INT64>, column=t.vt1#7)
            |               | |   +-field_idx=0
            |               | +-int32_val1#10 :=
            |               |   +-GetProtoField
            |               |     +-type=INT32
            |               |     +-expr=
            |               |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=t.vt2#8)
            |               |     +-field_descriptor=int32_val1
            |               |     +-default_value=0
            |               +-input_scan=
            |                 +-StaticDescribeScan
            |                   +-column_list=t.[vt1#7, vt2#8]
            |                   +-describe_text=
            |                   |   """
            |                   |   NameList:
            |                   |     vt1 STRUCT<f1 INT64> t.vt1#7
            |                   |     vt2 zetasql_test__.TestExtraPB t.vt2#8
            |                   |   NameScope:
            |                   |     Names:
            |                   |       vt1 -> STRUCT<f1 INT64> (t.vt1#7) (implicit)
            |                   |       vt2 -> zetasql_test__.TestExtraPB (t.vt2#8) (implicit)
            |                   |     Range variables:
            |                   |       t -> RANGE_VARIABLE<vt1,vt2>
            |                   |   """
            |                   +-input_scan=
            |                     +-RecursiveRefScan(column_list=t.[vt1#7, vt2#8])
            +-output_column_list=[$union_all2_cast.$col1#13, $pipe_select.$col2#12]
==

# Multiple value tables as the pipe input table. The fields f1 and f2
# can be referenced through vt1 and vt2.
# The difference between this test and the previous one is that the recursive
# term does not have an alias.
from (select as value struct(1 as f1)) as vt1,
     TestExtraValueTable as vt2
|> static_describe
|> recursive union all (
  |> static_describe
  |> select vt1.f1, vt2.int32_val1
  |> select struct(1), cast(null as zetasql_test__.TestExtraPB)
  |> static_describe
)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.vt1#5 AS vt1 [STRUCT<f1 INT64>]
| +-$union_all.vt2#6 AS vt2 [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-StaticDescribeScan
    +-column_list=$union_all.[vt1#5, vt2#6]
    +-describe_text=
    |   """
    |   NameList:
    |     vt1 STRUCT<f1 INT64> $union_all.vt1#5
    |     vt2 zetasql_test__.TestExtraPB $union_all.vt2#6
    |   NameScope:
    |     Names:
    |       vt1 -> STRUCT<f1 INT64> ($union_all.vt1#5) (implicit)
    |       vt2 -> zetasql_test__.TestExtraPB ($union_all.vt2#6) (implicit)
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=$union_all.[vt1#5, vt2#6]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=[vt1.$col1#1, TestExtraValueTable.value#2]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList:
        |   |   |     vt1 STRUCT<f1 INT64> vt1.$col1#1 (value table)
        |   |   |     vt2 zetasql_test__.TestExtraPB TestExtraValueTable.value#2 (value table)
        |   |   |   NameScope:
        |   |   |     Names:
        |   |   |       Filename -> STRING (TestExtraValueTable.Filename#3) (implicit) (pseudo-column)
        |   |   |       RowId -> BYTES (TestExtraValueTable.RowId#4) (implicit) (pseudo-column)
        |   |   |     Range variables:
        |   |   |       vt1 -> RANGE_VARIABLE<$value>
        |   |   |       vt2 -> RANGE_VARIABLE<$value>
        |   |   |     Value table columns:
        |   |   |       vt1.$col1#1
        |   |   |       TestExtraValueTable.value#2
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-JoinScan
        |   |       +-column_list=[vt1.$col1#1, TestExtraValueTable.value#2]
        |   |       +-left_scan=
        |   |       | +-ProjectScan
        |   |       |   +-column_list=[vt1.$col1#1]
        |   |       |   +-expr_list=
        |   |       |   | +-$col1#1 := Literal(type=STRUCT<f1 INT64>, value={f1:1})
        |   |       |   +-input_scan=
        |   |       |     +-SingleRowScan
        |   |       +-right_scan=
        |   |         +-TableScan(column_list=[TestExtraValueTable.value#2], table=TestExtraValueTable, column_index_list=[0], alias="vt2")
        |   +-output_column_list=[vt1.$col1#1, TestExtraValueTable.value#2]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-ProjectScan
            |   +-column_list=[$union_all2_cast.$col1#13, $pipe_select.$col2#12]
            |   +-expr_list=
            |   | +-$col1#13 :=
            |   |   +-Cast(STRUCT<INT64> -> STRUCT<f1 INT64>)
            |   |     +-ColumnRef(type=STRUCT<INT64>, column=$pipe_select.$col1#11)
            |   +-input_scan=
            |     +-StaticDescribeScan
            |       +-column_list=$pipe_select.[$col1#11, $col2#12]
            |       +-describe_text=
            |       |   """
            |       |   NameList:
            |       |     <unnamed> STRUCT<INT64> $pipe_select.$col1#11
            |       |     <unnamed> zetasql_test__.TestExtraPB $pipe_select.$col2#12
            |       |   NameScope:
            |       |   """
            |       +-input_scan=
            |         +-ProjectScan
            |           +-column_list=$pipe_select.[$col1#11, $col2#12]
            |           +-expr_list=
            |           | +-$col1#11 := Literal(type=STRUCT<INT64>, value={1})
            |           | +-$col2#12 := Literal(type=PROTO<zetasql_test__.TestExtraPB>, value=NULL, has_explicit_type=TRUE)
            |           +-input_scan=
            |             +-ProjectScan
            |               +-column_list=$pipe_select.[f1#9, int32_val1#10]
            |               +-expr_list=
            |               | +-f1#9 :=
            |               | | +-GetStructField
            |               | |   +-type=INT64
            |               | |   +-expr=
            |               | |   | +-ColumnRef(type=STRUCT<f1 INT64>, column=$pipe_recursive_union.vt1#7)
            |               | |   +-field_idx=0
            |               | +-int32_val1#10 :=
            |               |   +-GetProtoField
            |               |     +-type=INT32
            |               |     +-expr=
            |               |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$pipe_recursive_union.vt2#8)
            |               |     +-field_descriptor=int32_val1
            |               |     +-default_value=0
            |               +-input_scan=
            |                 +-StaticDescribeScan
            |                   +-column_list=$pipe_recursive_union.[vt1#7, vt2#8]
            |                   +-describe_text=
            |                   |   """
            |                   |   NameList:
            |                   |     vt1 STRUCT<f1 INT64> $pipe_recursive_union.vt1#7
            |                   |     vt2 zetasql_test__.TestExtraPB $pipe_recursive_union.vt2#8
            |                   |   NameScope:
            |                   |     Names:
            |                   |       vt1 -> STRUCT<f1 INT64> ($pipe_recursive_union.vt1#7) (implicit)
            |                   |       vt2 -> zetasql_test__.TestExtraPB ($pipe_recursive_union.vt2#8) (implicit)
            |                   |   """
            |                   +-input_scan=
            |                     +-RecursiveRefScan(column_list=$pipe_recursive_union.[vt1#7, vt2#8])
            +-output_column_list=[$union_all2_cast.$col1#13, $pipe_select.$col2#12]
==

# The negative test case demonstrating that neither f1 nor f2 can be referenced
# directly in the recursive term.
from (select as value struct(1 as f1)) as vt1,
     (select as value struct(2 as f2)) as vt2
|> recursive union all (
  {{from t|}}
  |> select f1, f2
  |> select struct(1), struct(2)
) as t
--
ERROR: Unrecognized name: f1 [at 5:13]
  |> select f1, f2
            ^
==

# Because the input is not a value table anymore, even if the recursive term
# does not have an alias, the fields f1 and f2 still cannot be referenced
# directly.
from (select as value struct(1 as f1)) as vt1,
     (select as value struct(2 as f2)) as vt2
|> recursive union all (
  |> select f1, f2
  |> select struct(1), struct(2)
)
--
ERROR: Unrecognized name: f1 [at 4:13]
  |> select f1, f2
            ^
==

# Overlapping column names and range variables produced by JOIN USING.
# Note that none of the input range variables are visible on the recursive table
# or on the output table.
from keyvalue as t1 join keyvalue as t2 using (key)
|> static_describe
|> recursive union all (
  {{|from t}}
  |> static_describe
) as t
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.key#5 AS key [INT64]
| +-$union_all.Value#6 AS Value [STRING]
| +-$union_all.Value#7 AS Value [STRING]
+-query=
  +-StaticDescribeScan
    +-column_list=$union_all.[key#5, Value#6, Value#7]
    +-describe_text=
    |   """
    |   NameList:
    |     key INT64 $union_all.key#5
    |     Value STRING $union_all.Value#6
    |     Value STRING $union_all.Value#7
    |   NameScope:
    |     Names:
    |       Value -> ambiguous
    |       key -> INT64 ($union_all.key#5)
    |     Range variables:
    |       t -> RANGE_VARIABLE<key,Value,Value>
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=$union_all.[key#5, Value#6, Value#7]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList:
        |   |   |     key INT64 KeyValue.Key#1
        |   |   |     Value STRING KeyValue.Value#2
        |   |   |     Value STRING KeyValue.Value#4
        |   |   |   NameScope:
        |   |   |     Names:
        |   |   |       Value -> ambiguous
        |   |   |       key -> INT64 (KeyValue.Key#1)
        |   |   |     Range variables:
        |   |   |       t1 -> RANGE_VARIABLE<Key,Value>
        |   |   |       t2 -> RANGE_VARIABLE<Key,Value>
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-JoinScan
        |   |       +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
        |   |       +-left_scan=
        |   |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t1")
        |   |       +-right_scan=
        |   |       | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="t2")
        |   |       +-join_expr=
        |   |       | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   |       |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |       |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        |   |       +-has_using=TRUE
        |   +-output_column_list=KeyValue.[Key#1, Value#2, Value#4]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-StaticDescribeScan
            |   +-column_list=t.[key#8, Value#9, Value#10]
            |   +-describe_text=
            |   |   """
            |   |   NameList:
            |   |     key INT64 t.key#8
            |   |     Value STRING t.Value#9
            |   |     Value STRING t.Value#10
            |   |   NameScope:
            |   |     Names:
            |   |       Value -> ambiguous
            |   |       key -> INT64 (t.key#8)
            |   |     Range variables:
            |   |       t -> RANGE_VARIABLE<key,Value,Value>
            |   |   """
            |   +-input_scan=
            |     +-RecursiveRefScan(column_list=t.[key#8, Value#9, Value#10])
            +-output_column_list=t.[key#8, Value#9, Value#10]
==

# Overlapping column names and range variables produced by JOIN USING.
# Note that none of the input range variables are visible on the recursive table
# or on the output table.
from keyvalue as t1 join keyvalue as t2 using (key)
|> static_describe
|> recursive union all (
  |> static_describe
  |> select 1, "", ""
  |> static_describe
)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.key#5 AS key [INT64]
| +-$union_all.Value#6 AS Value [STRING]
| +-$union_all.Value#7 AS Value [STRING]
+-query=
  +-StaticDescribeScan
    +-column_list=$union_all.[key#5, Value#6, Value#7]
    +-describe_text=
    |   """
    |   NameList:
    |     key INT64 $union_all.key#5
    |     Value STRING $union_all.Value#6
    |     Value STRING $union_all.Value#7
    |   NameScope:
    |     Names:
    |       Value -> ambiguous
    |       key -> INT64 ($union_all.key#5)
    |   """
    +-input_scan=
      +-RecursiveScan
        +-column_list=$union_all.[key#5, Value#6, Value#7]
        +-op_type=UNION_ALL
        +-non_recursive_term=
        | +-SetOperationItem
        |   +-scan=
        |   | +-StaticDescribeScan
        |   |   +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
        |   |   +-describe_text=
        |   |   |   """
        |   |   |   NameList:
        |   |   |     key INT64 KeyValue.Key#1
        |   |   |     Value STRING KeyValue.Value#2
        |   |   |     Value STRING KeyValue.Value#4
        |   |   |   NameScope:
        |   |   |     Names:
        |   |   |       Value -> ambiguous
        |   |   |       key -> INT64 (KeyValue.Key#1)
        |   |   |     Range variables:
        |   |   |       t1 -> RANGE_VARIABLE<Key,Value>
        |   |   |       t2 -> RANGE_VARIABLE<Key,Value>
        |   |   |   """
        |   |   +-input_scan=
        |   |     +-JoinScan
        |   |       +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
        |   |       +-left_scan=
        |   |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t1")
        |   |       +-right_scan=
        |   |       | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="t2")
        |   |       +-join_expr=
        |   |       | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   |       |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |       |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        |   |       +-has_using=TRUE
        |   +-output_column_list=KeyValue.[Key#1, Value#2, Value#4]
        +-recursive_term=
          +-SetOperationItem
            +-scan=
            | +-StaticDescribeScan
            |   +-column_list=$pipe_select.[$col1#11, $col2#12, $col3#13]
            |   +-describe_text=
            |   |   """
            |   |   NameList:
            |   |     <unnamed> INT64 $pipe_select.$col1#11
            |   |     <unnamed> STRING $pipe_select.$col2#12
            |   |     <unnamed> STRING $pipe_select.$col3#13
            |   |   NameScope:
            |   |   """
            |   +-input_scan=
            |     +-ProjectScan
            |       +-column_list=$pipe_select.[$col1#11, $col2#12, $col3#13]
            |       +-expr_list=
            |       | +-$col1#11 := Literal(type=INT64, value=1)
            |       | +-$col2#12 := Literal(type=STRING, value="")
            |       | +-$col3#13 := Literal(type=STRING, value="")
            |       +-input_scan=
            |         +-StaticDescribeScan
            |           +-column_list=$pipe_recursive_union.[key#8, Value#9, Value#10]
            |           +-describe_text=
            |           |   """
            |           |   NameList:
            |           |     key INT64 $pipe_recursive_union.key#8
            |           |     Value STRING $pipe_recursive_union.Value#9
            |           |     Value STRING $pipe_recursive_union.Value#10
            |           |   NameScope:
            |           |     Names:
            |           |       Value -> ambiguous
            |           |       key -> INT64 ($pipe_recursive_union.key#8)
            |           |   """
            |           +-input_scan=
            |             +-RecursiveRefScan(column_list=$pipe_recursive_union.[key#8, Value#9, Value#10])
            +-output_column_list=$pipe_select.[$col1#11, $col2#12, $col3#13]
==

# Non-groupable columns are not allowed for union distinct.
select struct("a", "b")
|> recursive union distinct (
  {{|from t}}
){{| as t}}
--
ALTERNATION GROUPS:
    <empty>
     as t
    from t, as t
--
ERROR: Column 1 in UNION DISTINCT has type that does not support set operation comparisons: STRUCT [at 2:29]
|> recursive union distinct (
                            ^
--
ALTERNATION GROUP: from t,
--
ERROR: The subquery input of RECURSIVE UNION must have an alias [at 4:2]
)
 ^
==

# Pipe recursive union does not have access to the names of the previous scope.
from unnest([1, 2, 3]) as number
|> recursive union all (
  {{from t|}}
  |> select number
) as t
--
ERROR: Unrecognized name: number [at 4:13]
  |> select number
            ^
==

# Because no alias is assigned, the default name of the value table is the same
# as the input, which is number. Therefore, in this query, |> select number
# does not error - it references the `number` column in the recursive scan.
from unnest([1, 2, 3]) as number
|> recursive union all (
  |> static_describe
  |> select number
)
--
QueryStmt
+-output_column_list=
| +-$union_all.number#2 AS `$value` [INT64]
+-is_value_table=TRUE
+-query=
  +-RecursiveScan
    +-column_list=[$union_all.number#2]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-ArrayScan
    |   |   +-column_list=[$array.number#1]
    |   |   +-array_expr_list=
    |   |   | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |   |   +-element_column_list=[$array.number#1]
    |   +-output_column_list=[$array.number#1]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$pipe_recursive_union.number#3]
        |   +-input_scan=
        |     +-StaticDescribeScan
        |       +-column_list=[$pipe_recursive_union.number#3]
        |       +-describe_text=
        |       |   """
        |       |   NameList (is_value_table = true):
        |       |     number INT64 $pipe_recursive_union.number#3 (value table)
        |       |   NameScope:
        |       |     Range variables:
        |       |       number -> RANGE_VARIABLE<$value>
        |       |     Value table columns:
        |       |       $pipe_recursive_union.number#3
        |       |   """
        |       +-input_scan=
        |         +-RecursiveRefScan(column_list=[$pipe_recursive_union.number#3])
        +-output_column_list=[$pipe_recursive_union.number#3]
==

# Use WITH inside RECURSIVE UNION.
FROM KeyValue kv
|> RECURSIVE UNION ALL (
     WITH t2 AS (select 123 key)
     FROM rec
     |> JOIN t2 USING (key)
   ) AS rec
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-WithScan
        |   +-column_list=[rec.Key#6, rec.Value#7, t2.key#8]
        |   +-with_entry_list=
        |   | +-WithEntry
        |   |   +-with_query_name="t2"
        |   |   +-with_subquery=
        |   |     +-ProjectScan
        |   |       +-column_list=[t2.key#5]
        |   |       +-expr_list=
        |   |       | +-key#5 := Literal(type=INT64, value=123)
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-query=
        |     +-JoinScan
        |       +-column_list=[rec.Key#6, rec.Value#7, t2.key#8]
        |       +-left_scan=
        |       | +-RecursiveRefScan(column_list=rec.[Key#6, Value#7])
        |       +-right_scan=
        |       | +-WithRefScan(column_list=[t2.key#8], with_query_name="t2")
        |       +-join_expr=
        |       | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       |   +-ColumnRef(type=INT64, column=rec.Key#6)
        |       |   +-ColumnRef(type=INT64, column=t2.key#8)
        |       +-has_using=TRUE
        +-output_column_list=rec.[Key#6, Value#7]
==

# Use pipe WITH inside RECURSIVE UNION.
FROM KeyValue kv
|> RECURSIVE UNION ALL (
     |> WITH t2 AS (select 123 key)
     |> JOIN t2 USING (key)
   ) AS rec
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#3 AS Key [INT64]
| +-$union_all.Value#4 AS Value [STRING]
+-query=
  +-RecursiveScan
    +-column_list=$union_all.[Key#3, Value#4]
    +-op_type=UNION_ALL
    +-non_recursive_term=
    | +-SetOperationItem
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
    |   +-output_column_list=KeyValue.[Key#1, Value#2]
    +-recursive_term=
      +-SetOperationItem
        +-scan=
        | +-WithScan
        |   +-column_list=[rec.Key#5, rec.Value#6, t2.key#8]
        |   +-with_entry_list=
        |   | +-WithEntry
        |   |   +-with_query_name="t2"
        |   |   +-with_subquery=
        |   |     +-ProjectScan
        |   |       +-column_list=[t2.key#7]
        |   |       +-expr_list=
        |   |       | +-key#7 := Literal(type=INT64, value=123)
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-query=
        |     +-JoinScan
        |       +-column_list=[rec.Key#5, rec.Value#6, t2.key#8]
        |       +-left_scan=
        |       | +-RecursiveRefScan(column_list=rec.[Key#5, Value#6])
        |       +-right_scan=
        |       | +-WithRefScan(column_list=[t2.key#8], with_query_name="t2")
        |       +-join_expr=
        |       | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       |   +-ColumnRef(type=INT64, column=rec.Key#5)
        |       |   +-ColumnRef(type=INT64, column=t2.key#8)
        |       +-has_using=TRUE
        +-output_column_list=rec.[Key#5, Value#6]
==

# Use WITH inside RECURSIVE UNION, trying to reference the recursive table.
FROM KeyValue kv
|> RECURSIVE UNION ALL (
     WITH t2 AS (FROM rec)
     FROM rec
     |> JOIN t2 USING (key)
   ) AS rec
--
ERROR: Table 'rec' must not be recursively referenced from inside an inner recursive query [at 3:23]
     WITH t2 AS (FROM rec)
                      ^
==

# Use pipe WITH inside RECURSIVE UNION, trying to reference the recursive table.
FROM KeyValue kv
|> RECURSIVE UNION ALL (
     |> WITH t2 AS (FROM rec)
     |> JOIN t2 USING (key)
   ) AS rec
--
ERROR: Referencing the recursive table alias inside a RECURSIVE UNION subpipeline is not allowed [at 3:26]
     |> WITH t2 AS (FROM rec)
                         ^
