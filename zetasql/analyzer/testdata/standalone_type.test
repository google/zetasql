# This file includes tests for parsing type names outside of queries.
[default mode=type]
[default no_run_unparser]

int32
--
INT32
==

/* comment */ int64 # comment
--
INT64
==

string with bad suffix
--
ERROR: Syntax error: Expected end of input but got keyword WITH [at 1:8]
string with bad suffix
       ^
==

5
--
ERROR: Syntax error: Unexpected integer literal "5" [at 1:1]
5
^
==

xxx
--
ERROR: Type not found: xxx [at 1:1]
xxx
^
==

string
--
STRING
==

STRING
--
STRING
==

ByTeS
--
BYTES
==

date
--
DATE
==

timestamp
--
TIMESTAMP
==

[language_features={{PARAMETERIZED_TYPES}}]
timestamp(3)
--
ERROR: TIMESTAMP does not support type parameters [at 1:10]
timestamp(3)
         ^
==

[language_features={{PARAMETERIZED_TYPES}}]
struct<string>(3)
--
ERROR: STRUCT<STRING> type cannot have type parameters by itself, it can only have type parameters on its struct fields [at 1:15]
struct<string>(3)
              ^
==

[language_features={{PARAMETERIZED_TYPES}}]
array<string>(3)
--
ERROR: ARRAY<STRING> type cannot have type parameters by itself, it can only have type parameters on its element type [at 1:14]
array<string>(3)
             ^
==

[language_features={{PARAMETERIZED_TYPES}}]
invalid(2)
--
ERROR: Type not found: invalid [at 1:1]
invalid(2)
^
==

[language_features={{PARAMETERIZED_TYPES}}]
invalid1.invalid2(3)
--
ERROR: Type not found: invalid1.invalid2 [at 1:1]
invalid1.invalid2(3)
^
==

[language_features={{PARAMETERIZED_TYPES}}]
STRING.invalid(3)
--
ERROR: Type not found: STRING.invalid [at 1:1]
STRING.invalid(3)
^
==

[language_features={{PARAMETERIZED_TYPES}}]
invalid1(2).invalid3(4)
--
ERROR: Syntax error: Expected end of input but got "." [at 1:12]
invalid1(2).invalid3(4)
           ^
==

[language_features={{PARAMETERIZED_TYPES}}]
string
--
STRING
==

[language_features={{PARAMETERIZED_TYPES}}]
string(5)
--
STRING(5)
==

[language_features={{PARAMETERIZED_TYPES}}]
string(MAX)
--
STRING(MAX)
==

[language_features={{PARAMETERIZED_TYPES}}]
string(0)
--
ERROR: STRING length must be greater than 0 [at 1:7]
string(0)
      ^
==

[language_features={{PARAMETERIZED_TYPES}}]
string(-9)
--
ERROR: Syntax error: Unexpected "-" [at 1:8]
string(-9)
       ^
==

[language_features={{PARAMETERIZED_TYPES}}]
string("MAX")
--
ERROR: STRING length parameter must be an integer or MAX keyword [at 1:7]
string("MAX")
      ^
==

[language_features={{PARAMETERIZED_TYPES}}]
string("hello")
--
ERROR: STRING length parameter must be an integer or MAX keyword [at 1:7]
string("hello")
      ^
==

[language_features={{PARAMETERIZED_TYPES}}]
string(DATE "mm/dd/yyy")
--
ERROR: Syntax error: Unexpected keyword DATE [at 1:8]
string(DATE "mm/dd/yyy")
       ^
==

[language_features={{PARAMETERIZED_TYPES}}]
string(1, 2)
--
ERROR: STRING type can only have one parameter. Found 2 parameters [at 1:7]
string(1, 2)
      ^
==

[language_features={{PARAMETERIZED_TYPES}}]
bytes(MAX)
--
BYTES(MAX)
==

[language_features={{PARAMETERIZED_TYPES}}]
bytes(500)
--
BYTES(500)
==

[language_features={{PARAMETERIZED_TYPES}}]
BYTES(b"there")
--
ERROR: BYTES length parameter must be an integer or MAX keyword [at 1:6]
BYTES(b"there")
     ^
==

[language_features={{PARAMETERIZED_TYPES}}]
float64(1)
--
ERROR: DOUBLE does not support type parameters [at 1:8]
float64(1)
       ^
==

[language_features={{PARAMETERIZED_TYPES}}]
float64(1.2)
--
ERROR: DOUBLE does not support type parameters [at 1:8]
float64(1.2)
       ^
==

[language_features={{PARAMETERIZED_TYPES}}]
string(1.2)
--
ERROR: STRING length parameter must be an integer or MAX keyword [at 1:7]
string(1.2)
      ^
==

[language_features={{PARAMETERIZED_TYPES}}]
string(true)
--
ERROR: STRING length parameter must be an integer or MAX keyword [at 1:7]
string(true)
      ^
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE}}]
numeric(4)
--
NUMERIC(4, 0)
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE}}]
numeric(6, 2)
--
NUMERIC(6, 2)
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE}}]
numeric(1, 2, 3)
--
ERROR: NUMERIC type can only have 1 or 2 parameters. Found 3 parameters [at 1:8]
numeric(1, 2, 3)
       ^
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE}}]
numeric()
--
ERROR: Syntax error: Unexpected ")" [at 1:9]
numeric()
        ^
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE}}]
numeric(MAX, 2)
--
ERROR: NUMERIC precision must be an integer [at 1:8]
numeric(MAX, 2)
       ^
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE}}]
numeric(MAX)
--
ERROR: NUMERIC precision must be an integer [at 1:8]
numeric(MAX)
       ^
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE}}]
numeric("hello")
--
ERROR: NUMERIC precision must be an integer [at 1:8]
numeric("hello")
       ^
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE}}]
numeric(30)
--
ERROR: In NUMERIC(P), P must be between 1 and 29 [at 1:8]
numeric(30)
       ^
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE}}]
numeric(1, 9)
--
ERROR: In NUMERIC(P, 9), P must be between 9 and 38 [at 1:8]
numeric(1, 9)
       ^
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE}}]
numeric(12, 10)
--
ERROR: In NUMERIC(P, S), S must be between 0 and 9 [at 1:8]
numeric(12, 10)
       ^
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE}}]
numeric(10.2)
--
ERROR: NUMERIC precision must be an integer [at 1:8]
numeric(10.2)
       ^
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE}}]
NUMERIC(NUMERIC 10)
--
ERROR: Syntax error: Unexpected keyword NUMERIC [at 1:9]
NUMERIC(NUMERIC 10)
        ^
==

[language_features={{PARAMETERIZED_TYPES,BIGNUMERIC_TYPE}}]
bignumeric(6)
--
BIGNUMERIC(6, 0)
==

[language_features={{PARAMETERIZED_TYPES,BIGNUMERIC_TYPE}}]
bignumeric(6, 2)
--
BIGNUMERIC(6, 2)
==

[language_features={{PARAMETERIZED_TYPES,BIGNUMERIC_TYPE}}]
bignumeric(MAX)
--
BIGNUMERIC(MAX, 0)
==

[language_features={{PARAMETERIZED_TYPES,BIGNUMERIC_TYPE}}]
bignumeric(MAX, 1)
--
BIGNUMERIC(MAX, 1)
==

[language_features={{PARAMETERIZED_TYPES,BIGNUMERIC_TYPE}}]
bignumeric(1, 2, 3)
--
ERROR: BIGNUMERIC type can only have 1 or 2 parameters. Found 3 parameters [at 1:11]
bignumeric(1, 2, 3)
          ^
==

[language_features={{PARAMETERIZED_TYPES,BIGNUMERIC_TYPE}}]
bignumeric(39)
--
ERROR: In BIGNUMERIC(P), P must be between 1 and 38 [at 1:11]
bignumeric(39)
          ^
==

[language_features={{PARAMETERIZED_TYPES,BIGNUMERIC_TYPE}}]
bignumeric(1, 9)
--
ERROR: In BIGNUMERIC(P, 9), P must be between 9 and 47 [at 1:11]
bignumeric(1, 9)
          ^
==

[language_features={{PARAMETERIZED_TYPES,BIGNUMERIC_TYPE}}]
bignumeric(40, 39)
--
ERROR: In BIGNUMERIC(P, S), S must be between 0 and 38 [at 1:11]
bignumeric(40, 39)
          ^
==

[language_features={{PARAMETERIZED_TYPES,BIGNUMERIC_TYPE}}]
bignumeric(MAX, 39)
--
ERROR: In BIGNUMERIC(P, S), S must be between 0 and 38 [at 1:11]
bignumeric(MAX, 39)
          ^
==

[language_features={{PARAMETERIZED_TYPES,BIGNUMERIC_TYPE}}]
bignumeric("hello")
--
ERROR: BIGNUMERIC precision must be an integer or MAX keyword [at 1:11]
bignumeric("hello")
          ^
==

[language_features={{PARAMETERIZED_TYPES}}]
array<string(10)>
--
ARRAY<STRING(10)>
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE}}]
array<struct<array<numeric(4, 1)>, array<string(10)>, int32>>
--
ARRAY<STRUCT<ARRAY<NUMERIC(4, 1)>, ARRAY<STRING(10)>, INT32>>
==

[language_features={{PARAMETERIZED_TYPES,NUMERIC_TYPE,BIGNUMERIC_TYPE}}]
struct<struct<array<numeric(4, 1)>, array<string(10)>, int32, bignumeric(MAX, 2), int64>>
--
STRUCT<STRUCT<ARRAY<NUMERIC(4, 1)>, ARRAY<STRING(10)>, INT32, BIGNUMERIC(MAX, 2), INT64>>
==

string collate 'und:ci'
--
ERROR: Type with collation name is not supported [at 1:8]
string collate 'und:ci'
       ^
==

struct<string collate 'und:ci'>
--
ERROR: Type with collation name is not supported [at 1:15]
struct<string collate 'und:ci'>
              ^
==

struct<string> collate 'und:ci'
--
ERROR: Type with collation name is not supported [at 1:16]
struct<string> collate 'und:ci'
               ^
==

array<string collate 'und:ci'>
--
ERROR: Type with collation name is not supported [at 1:14]
array<string collate 'und:ci'>
             ^
==

array<string> collate 'und:ci'
--
ERROR: Type with collation name is not supported [at 1:15]
array<string> collate 'und:ci'
              ^
==

[language_features={{V_1_2_CIVIL_TIME|}}]
time
--
ALTERNATION GROUP: V_1_2_CIVIL_TIME
--
TIME
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: time [at 1:1]
time
^
==

[language_features={{V_1_2_CIVIL_TIME|}}]
datetime
--
ALTERNATION GROUP: V_1_2_CIVIL_TIME
--
DATETIME
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: datetime [at 1:1]
datetime
^
==

[language_features={{GEOGRAPHY|}}]
geography
--
ALTERNATION GROUP: GEOGRAPHY
--
GEOGRAPHY
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: geography [at 1:1]
geography
^
==

[language_features={{NUMERIC_TYPE|}}]
numeric
--
ALTERNATION GROUP: NUMERIC_TYPE
--
NUMERIC
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: numeric [at 1:1]
numeric
^
==

[language_features={{NUMERIC_TYPE|}}]
array<numeric>
--
ALTERNATION GROUP: NUMERIC_TYPE
--
ARRAY<NUMERIC>
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: numeric [at 1:7]
array<numeric>
      ^
==

[language_features={{|NUMERIC_TYPE|V_1_3_DECIMAL_ALIAS|NUMERIC_TYPE,V_1_3_DECIMAL_ALIAS}}]
decimal
--
ALTERNATION GROUPS:
    <empty>
    NUMERIC_TYPE
    V_1_3_DECIMAL_ALIAS
--
ERROR: Type not found: decimal [at 1:1]
decimal
^
--
ALTERNATION GROUP: NUMERIC_TYPE,V_1_3_DECIMAL_ALIAS
--
NUMERIC
==

[language_features={{|NUMERIC_TYPE|V_1_3_DECIMAL_ALIAS|NUMERIC_TYPE,V_1_3_DECIMAL_ALIAS}}]
array<decimal>
--
ALTERNATION GROUPS:
    <empty>
    NUMERIC_TYPE
    V_1_3_DECIMAL_ALIAS
--
ERROR: Type not found: decimal [at 1:7]
array<decimal>
      ^
--
ALTERNATION GROUP: NUMERIC_TYPE,V_1_3_DECIMAL_ALIAS
--
ARRAY<NUMERIC>
==

[language_features={{BIGNUMERIC_TYPE|}}]
bignumeric
--
ALTERNATION GROUP: BIGNUMERIC_TYPE
--
BIGNUMERIC
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: bignumeric [at 1:1]
bignumeric
^
==

[language_features={{BIGNUMERIC_TYPE|}}]
array<bignumeric>
--
ALTERNATION GROUP: BIGNUMERIC_TYPE
--
ARRAY<BIGNUMERIC>
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: bignumeric [at 1:7]
array<bignumeric>
      ^
==

[language_features={{|BIGNUMERIC_TYPE|V_1_3_DECIMAL_ALIAS|BIGNUMERIC_TYPE,V_1_3_DECIMAL_ALIAS}}]
bigdecimal
--
ALTERNATION GROUPS:
    <empty>
    BIGNUMERIC_TYPE
    V_1_3_DECIMAL_ALIAS
--
ERROR: Type not found: bigdecimal [at 1:1]
bigdecimal
^
--
ALTERNATION GROUP: BIGNUMERIC_TYPE,V_1_3_DECIMAL_ALIAS
--
BIGNUMERIC
==

[language_features={{|BIGNUMERIC_TYPE|V_1_3_DECIMAL_ALIAS|BIGNUMERIC_TYPE,V_1_3_DECIMAL_ALIAS}}]
array<bigdecimal>
--
ALTERNATION GROUPS:
    <empty>
    BIGNUMERIC_TYPE
    V_1_3_DECIMAL_ALIAS
--
ERROR: Type not found: bigdecimal [at 1:7]
array<bigdecimal>
      ^
--
ALTERNATION GROUP: BIGNUMERIC_TYPE,V_1_3_DECIMAL_ALIAS
--
ARRAY<BIGNUMERIC>
==

[language_features={{JSON_TYPE|}}]
json
--
ALTERNATION GROUP: JSON_TYPE
--
JSON
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: json [at 1:1]
json
^
==

array<int32>
--
ARRAY<INT32>
==

array<bool>
--
ARRAY<BOOL>
==

int32
--
INT32
==

{{bool|boolean}}
--
BOOL
==

int64
--
INT64
==

struct<>
--
STRUCT<>
==

struct<int32>
--
STRUCT<INT32>
==

struct<bool, date, uint32>
--
STRUCT<BOOL, DATE, UINT32>
==

struct<b bool, bool, d bool, b bool>
--
STRUCT<b BOOL, BOOL, d BOOL, b BOOL>
==

struct<bool bool>
--
STRUCT<bool BOOL>
==

struct<`Name with spaces` uint64>
--
STRUCT<`Name with spaces` UINT64>
==

array<array<int32>>
--
ERROR: Arrays of arrays are not supported [at 1:1]
array<array<int32>>
^
==

array<struct<array<int32>, array_of_date array<date>, int32>>
--
ARRAY<STRUCT<ARRAY<INT32>, array_of_date ARRAY<DATE>, INT32>>
==

struct<
  struct<x int32>,
  struct<y int64>
>
--
STRUCT<STRUCT<x INT32>, STRUCT<y INT64>>
==

`zetasql_test__.TestEnum`
--
`zetasql_test__.TestEnum`
==

# Proto enums work as paths or as quoted fullnames.
zetasql_test__.TestEnum
--
`zetasql_test__.TestEnum`
==

`zetasql_test__.TestEnum`
--
`zetasql_test__.TestEnum`
==

`zetasql_test__.KeyValueStruct`
--
`zetasql_test__.KeyValueStruct`
==

# Protos  work as paths or as quoted fullnames.
zetasql_test__.KeyValueStruct
--
`zetasql_test__.KeyValueStruct`
==

`zetasql_test__.KeyValueStruct`
--
`zetasql_test__.KeyValueStruct`
==

zetasql_test__.KitchenSinkPB.Nested
--
`zetasql_test__.KitchenSinkPB.Nested`
==

`zetasql_test__.KitchenSinkPB.Nested`
--
`zetasql_test__.KitchenSinkPB.Nested`
==

zetasql_test__.`KitchenSinkPB.Nested`
--
ERROR: Type not found: zetasql_test__.`KitchenSinkPB.Nested` [at 1:1]
zetasql_test__.`KitchenSinkPB.Nested`
^
==

`zetasql_test__.KitchenSinkPB`.Nested
--
ERROR: Type not found: `zetasql_test__.KitchenSinkPB`.Nested [at 1:1]
`zetasql_test__.KitchenSinkPB`.Nested
^
==


# Proto and enum type names are case sensitive.
`zetasql_test__.keyVALUESTRUCT`
--
ERROR: Type not found: `zetasql_test__.keyVALUESTRUCT` [at 1:1]
`zetasql_test__.keyVALUESTRUCT`
^
==

# Proto and enum type names are case sensitive.
`zetasql_test__.TESTenum`
--
ERROR: Type not found: `zetasql_test__.TESTenum` [at 1:1]
`zetasql_test__.TESTenum`
^
==

`zetasql_test__.TestOptionalFields.Nested`
--
`zetasql_test__.TestOptionalFields.Nested`
==

ARRAY<zetasql_test__.TestEnum>
--
ARRAY<`zetasql_test__.TestEnum`>
==

STRUCT<`zetasql_test__.TestEnum`, f2 zetasql_test__.KeyValueStruct>
--
STRUCT<`zetasql_test__.TestEnum`, f2 `zetasql_test__.KeyValueStruct`>
==

nested_catalog.`zetasql_test__.TestEnum`
--
`zetasql_test__.TestEnum`
==

nested_catalog.`zetasql_test__.KitchenSinkPB`
--
`zetasql_test__.KitchenSinkPB`
==

# Path is a catalog and then a proto name as a path.
nested_catalog.zetasql_test__.KitchenSinkPB
--
`zetasql_test__.KitchenSinkPB`
==

nested_catalog.`zetasql_test__.KitchenSinkPB`
--
`zetasql_test__.KitchenSinkPB`
==

# Catalog name cannot be part of the proto fullname as a single identifier.
`nested_catalog.zetasql_test__.KitchenSinkPB`
--
ERROR: Type not found: `nested_catalog.zetasql_test__.KitchenSinkPB` [at 1:1]
`nested_catalog.zetasql_test__.KitchenSinkPB`
^
==

bad.type.name
--
ERROR: Type not found: bad.type.name [at 1:1]
bad.type.name
^
==

nested_catalog.bad.type.name
--
ERROR: Type not found: nested_catalog.bad.type.name [at 1:1]
nested_catalog.bad.type.name
^
==

nested_catalog.`bad.type.name`
--
ERROR: Type not found: nested_catalog.`bad.type.name` [at 1:1]
nested_catalog.`bad.type.name`
^
==

recursive_catalog.recursive_catalog.bad.type.name
--
ERROR: Type not found: recursive_catalog.recursive_catalog.bad.type.name [at 1:1]
recursive_catalog.recursive_catalog.bad.type.name
^
