# Tests for VECTOR_SEARCH TVF.
#
[default language_features=MAXIMUM,+VECTOR_SEARCH_TVF]
[default no_enable_literal_replacement]
# Disable literal replacement for VECTOR_SEARCH_TVF because arguments like
# column_to_search, query_column_to_search, and distance_type must be constant
# string literals.

# The test catalog contains:
# base_table(id INT64, embedding ARRAY<DOUBLE>, string_col STRING)
# query_table(id INT64, query_embedding ARRAY<DOUBLE>, embedding ARRAY<DOUBLE>)
# base_table_wrong_type(id INT64, embedding ARRAY<STRING>)

# Basic call with positional arguments
SELECT * FROM vector_search(TABLE base_table, 'embedding', TABLE query_table, 'query_embedding')
--
QueryStmt
+-output_column_list=
| +-vector_search.query#7 AS query [STRUCT<id INT64, query_embedding ARRAY<DOUBLE>, embedding ARRAY<DOUBLE>>]
| +-vector_search.base#8 AS base [STRUCT<id INT64, embedding ARRAY<DOUBLE>, string_col STRING>]
| +-vector_search.distance#9 AS distance [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=vector_search.[query#7, base#8, distance#9]
    +-input_scan=
      +-TVFScan
        +-column_list=vector_search.[query#7, base#8, distance#9]
        +-tvf=ZetaSQL:vector_search((ANY TABLE, STRING {must_be_constant: true} column_to_search, ANY TABLE, optional STRING {must_be_constant: true} query_column_to_search, optional INT64 {default_value: 10} top_k, optional STRING {must_be_constant: true, default_value: "EUCLIDEAN"} distance_type, optional DOUBLE {default_value: NULL} max_distance, optional STRING {must_be_constant: true, default_value: "{}"} options) -> ANY TABLE)
        +-signature=(TABLE<id INT64, embedding ARRAY<DOUBLE>, string_col STRING>, literal STRING, TABLE<id INT64, query_embedding ARRAY<DOUBLE>, embedding ARRAY<DOUBLE>>, literal STRING, literal INT64, literal STRING, null DOUBLE, literal STRING) -> TABLE<query STRUCT<id INT64, query_embedding ARRAY<DOUBLE>, embedding ARRAY<DOUBLE>>, base STRUCT<id INT64, embedding ARRAY<DOUBLE>, string_col STRING>, distance DOUBLE>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-TableScan(column_list=base_table.[id#1, embedding#2, string_col#3], table=base_table, column_index_list=[0, 1, 2])
        | | +-argument_column_list=base_table.[id#1, embedding#2, string_col#3]
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="embedding")
        | +-FunctionArgument
        | | +-scan=
        | | | +-TableScan(column_list=query_table.[id#4, query_embedding#5, embedding#6], table=query_table, column_index_list=[0, 1, 2])
        | | +-argument_column_list=query_table.[id#4, query_embedding#5, embedding#6]
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="query_embedding")
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=10)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="EUCLIDEAN")
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=DOUBLE, value=NULL)
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="{}")
        +-column_index_list=[0, 1, 2]
        +-function_call_signature=(ANY TABLE, STRING column_to_search, ANY TABLE, optional(1) STRING query_column_to_search, optional(1) INT64 top_k, optional(1) STRING distance_type, optional(1) DOUBLE max_distance, optional(1) STRING options) -> ANY TABLE
==

# Call with all arguments
SELECT * FROM vector_search(
  TABLE base_table,
  'embedding',
  TABLE query_table,
  'query_embedding',
  top_k => 5,
  distance_type => 'COSINE',
  max_distance => 0.8,
  options => '{"key1": 1, "key2": 2}'
)
--
QueryStmt
+-output_column_list=
| +-vector_search.query#7 AS query [STRUCT<id INT64, query_embedding ARRAY<DOUBLE>, embedding ARRAY<DOUBLE>>]
| +-vector_search.base#8 AS base [STRUCT<id INT64, embedding ARRAY<DOUBLE>, string_col STRING>]
| +-vector_search.distance#9 AS distance [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=vector_search.[query#7, base#8, distance#9]
    +-input_scan=
      +-TVFScan
        +-column_list=vector_search.[query#7, base#8, distance#9]
        +-tvf=ZetaSQL:vector_search((ANY TABLE, STRING {must_be_constant: true} column_to_search, ANY TABLE, optional STRING {must_be_constant: true} query_column_to_search, optional INT64 {default_value: 10} top_k, optional STRING {must_be_constant: true, default_value: "EUCLIDEAN"} distance_type, optional DOUBLE {default_value: NULL} max_distance, optional STRING {must_be_constant: true, default_value: "{}"} options) -> ANY TABLE)
        +-signature=(TABLE<id INT64, embedding ARRAY<DOUBLE>, string_col STRING>, literal STRING, TABLE<id INT64, query_embedding ARRAY<DOUBLE>, embedding ARRAY<DOUBLE>>, literal STRING, literal INT64, literal STRING, literal DOUBLE, literal STRING) -> TABLE<query STRUCT<id INT64, query_embedding ARRAY<DOUBLE>, embedding ARRAY<DOUBLE>>, base STRUCT<id INT64, embedding ARRAY<DOUBLE>, string_col STRING>, distance DOUBLE>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-TableScan(column_list=base_table.[id#1, embedding#2, string_col#3], table=base_table, column_index_list=[0, 1, 2])
        | | +-argument_column_list=base_table.[id#1, embedding#2, string_col#3]
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="embedding")
        | +-FunctionArgument
        | | +-scan=
        | | | +-TableScan(column_list=query_table.[id#4, query_embedding#5, embedding#6], table=query_table, column_index_list=[0, 1, 2])
        | | +-argument_column_list=query_table.[id#4, query_embedding#5, embedding#6]
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="query_embedding")
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=5)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="COSINE")
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=DOUBLE, value=0.8, float_literal_id=1)
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value='{"key1": 1, "key2": 2}')
        +-column_index_list=[0, 1, 2]
        +-function_call_signature=(ANY TABLE, STRING column_to_search, ANY TABLE, optional(1) STRING query_column_to_search, optional(1) INT64 top_k, optional(1) STRING distance_type, optional(1) DOUBLE max_distance, optional(1) STRING options) -> ANY TABLE
==

# query table as SELECT query
SELECT * FROM vector_search(
  TABLE base_table,
  'embedding',
  (SELECT query_embedding FROM query_table),
  'query_embedding',
  top_k => 5,
  distance_type => 'COSINE',
  max_distance => 0.8,
  options => '{}'
)
--
QueryStmt
+-output_column_list=
| +-vector_search.query#7 AS query [STRUCT<query_embedding ARRAY<DOUBLE>>]
| +-vector_search.base#8 AS base [STRUCT<id INT64, embedding ARRAY<DOUBLE>, string_col STRING>]
| +-vector_search.distance#9 AS distance [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=vector_search.[query#7, base#8, distance#9]
    +-input_scan=
      +-TVFScan
        +-column_list=vector_search.[query#7, base#8, distance#9]
        +-tvf=ZetaSQL:vector_search((ANY TABLE, STRING {must_be_constant: true} column_to_search, ANY TABLE, optional STRING {must_be_constant: true} query_column_to_search, optional INT64 {default_value: 10} top_k, optional STRING {must_be_constant: true, default_value: "EUCLIDEAN"} distance_type, optional DOUBLE {default_value: NULL} max_distance, optional STRING {must_be_constant: true, default_value: "{}"} options) -> ANY TABLE)
        +-signature=(TABLE<id INT64, embedding ARRAY<DOUBLE>, string_col STRING>, literal STRING, TABLE<query_embedding ARRAY<DOUBLE>>, literal STRING, literal INT64, literal STRING, literal DOUBLE, literal STRING) -> TABLE<query STRUCT<query_embedding ARRAY<DOUBLE>>, base STRUCT<id INT64, embedding ARRAY<DOUBLE>, string_col STRING>, distance DOUBLE>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-TableScan(column_list=base_table.[id#1, embedding#2, string_col#3], table=base_table, column_index_list=[0, 1, 2])
        | | +-argument_column_list=base_table.[id#1, embedding#2, string_col#3]
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="embedding")
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[query_table.query_embedding#5]
        | | |   +-input_scan=
        | | |     +-TableScan(column_list=[query_table.query_embedding#5], table=query_table, column_index_list=[1])
        | | +-argument_column_list=[query_table.query_embedding#5]
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="query_embedding")
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=5)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="COSINE")
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=DOUBLE, value=0.8, float_literal_id=1)
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="{}")
        +-column_index_list=[0, 1, 2]
        +-function_call_signature=(ANY TABLE, STRING column_to_search, ANY TABLE, optional(1) STRING query_column_to_search, optional(1) INT64 top_k, optional(1) STRING distance_type, optional(1) DOUBLE max_distance, optional(1) STRING options) -> ANY TABLE
==

# implicit query_column_to_search
SELECT * FROM vector_search(TABLE base_table, 'embedding', TABLE query_table)
--
QueryStmt
+-output_column_list=
| +-vector_search.query#7 AS query [STRUCT<id INT64, query_embedding ARRAY<DOUBLE>, embedding ARRAY<DOUBLE>>]
| +-vector_search.base#8 AS base [STRUCT<id INT64, embedding ARRAY<DOUBLE>, string_col STRING>]
| +-vector_search.distance#9 AS distance [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=vector_search.[query#7, base#8, distance#9]
    +-input_scan=
      +-TVFScan
        +-column_list=vector_search.[query#7, base#8, distance#9]
        +-tvf=ZetaSQL:vector_search((ANY TABLE, STRING {must_be_constant: true} column_to_search, ANY TABLE, optional STRING {must_be_constant: true} query_column_to_search, optional INT64 {default_value: 10} top_k, optional STRING {must_be_constant: true, default_value: "EUCLIDEAN"} distance_type, optional DOUBLE {default_value: NULL} max_distance, optional STRING {must_be_constant: true, default_value: "{}"} options) -> ANY TABLE)
        +-signature=(TABLE<id INT64, embedding ARRAY<DOUBLE>, string_col STRING>, literal STRING, TABLE<id INT64, query_embedding ARRAY<DOUBLE>, embedding ARRAY<DOUBLE>>, null STRING, literal INT64, literal STRING, null DOUBLE, literal STRING) -> TABLE<query STRUCT<id INT64, query_embedding ARRAY<DOUBLE>, embedding ARRAY<DOUBLE>>, base STRUCT<id INT64, embedding ARRAY<DOUBLE>, string_col STRING>, distance DOUBLE>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-TableScan(column_list=base_table.[id#1, embedding#2, string_col#3], table=base_table, column_index_list=[0, 1, 2])
        | | +-argument_column_list=base_table.[id#1, embedding#2, string_col#3]
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="embedding")
        | +-FunctionArgument
        | | +-scan=
        | | | +-TableScan(column_list=query_table.[id#4, query_embedding#5, embedding#6], table=query_table, column_index_list=[0, 1, 2])
        | | +-argument_column_list=query_table.[id#4, query_embedding#5, embedding#6]
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value=NULL)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=10)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="EUCLIDEAN")
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=DOUBLE, value=NULL)
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="{}")
        +-column_index_list=[0, 1, 2]
        +-function_call_signature=(ANY TABLE, STRING column_to_search, ANY TABLE, optional(1) STRING query_column_to_search, optional(1) INT64 top_k, optional(1) STRING distance_type, optional(1) DOUBLE max_distance, optional(1) STRING options) -> ANY TABLE
==

# options argument is a JSON literal
SELECT * FROM vector_search(TABLE base_table, 'embedding', TABLE query_table, options => IFNULL(NULL, JSON '{"key1": 1, "key2": 2}'))
--
ERROR: No matching signature for vector_search
  Argument types: TABLE<id INT64, embedding ARRAY<DOUBLE>, string_col STRING>, STRING, TABLE<id INT64, query_embedding ARRAY<DOUBLE>, embedding ARRAY<DOUBLE>>, STRING, INT64, STRING, DOUBLE, JSON
  Signature: VECTOR_SEARCH(TABLE, column_to_search => STRING, TABLE, [query_column_to_search => STRING], [top_k => INT64], [distance_type => STRING], [max_distance => DOUBLE], [options => STRING])
    Argument 8: Unable to coerce type JSON to expected type STRING [at 1:15]
SELECT * FROM vector_search(TABLE base_table, 'embedding', TABLE query_table,...
              ^
==

# options argument is not a valid JSON-formatted STRING literal
SELECT * FROM vector_search(TABLE base_table, 'embedding', TABLE query_table, options => CAST(1 AS STRING))
--
ERROR: `options` Argument of vector_search TVF must be a valid JSON-formatted string literal [at 1:15]
SELECT * FROM vector_search(TABLE base_table, 'embedding', TABLE query_table,...
              ^
==

# column_to_search does not exist
SELECT * FROM vector_search(TABLE base_table, 'non_existent_col', TABLE query_table, 'query_embedding')
--
ERROR: Unrecognized name: non_existent_col in table TABLE<id INT64, embedding ARRAY<DOUBLE>, string_col STRING> [at 1:15]
SELECT * FROM vector_search(TABLE base_table, 'non_existent_col', TABLE query...
              ^
==

# column_to_search is not ARRAY<DOUBLE>
SELECT * FROM vector_search(TABLE base_table_wrong_type, 'embedding', TABLE query_table, 'query_embedding')
--
ERROR: The column specified by the `column_to_search` argument of vector_search TVF must be an array of doubles [at 1:15]
SELECT * FROM vector_search(TABLE base_table_wrong_type, 'embedding', TABLE q...
              ^
==

# query_column_to_search does not exist
SELECT * FROM vector_search(TABLE base_table, 'embedding', TABLE query_table, 'non_existent_col')
--
ERROR: Unrecognized name: non_existent_col in table TABLE<id INT64, query_embedding ARRAY<DOUBLE>, embedding ARRAY<DOUBLE>> [at 1:15]
SELECT * FROM vector_search(TABLE base_table, 'embedding', TABLE query_table,...
              ^
==

# query_column_to_search is not ARRAY<DOUBLE>
SELECT * FROM vector_search(TABLE base_table, 'embedding', TABLE base_table_wrong_type, 'embedding')
--
ERROR: The column specified by the `query_column_to_search` argument of vector_search TVF must be an array of doubles [at 1:15]
SELECT * FROM vector_search(TABLE base_table, 'embedding', TABLE base_table_w...
              ^
==

# Invalid distance_type value
SELECT * FROM vector_search(
  TABLE base_table,
  'embedding',
  TABLE query_table,
  'query_embedding',
  distance_type => 'MANHATTAN'
)
--
ERROR: `distance_type` argument of vector_search TVF must be set to one of COSINE or DOT_PRODUCT or EUCLIDEAN [at 1:15]
SELECT * FROM vector_search(
              ^
==

# Invalid options value
SELECT * FROM vector_search(
  TABLE base_table,
  'embedding',
  TABLE query_table,
  'query_embedding',
  options => 'invalid_json'
)
--
ERROR: `options` Argument of vector_search TVF must be a valid JSON-formatted string literal [at 1:15]
SELECT * FROM vector_search(
              ^
==

[language_features=MAXIMUM]
# VECTOR_SEARCH_TVF language feature disabled
SELECT * FROM vector_search(TABLE base_table, 'embedding', TABLE query_table, 'query_embedding')
--
ERROR: Table-valued function not found: vector_search [at 2:15]
SELECT * FROM vector_search(TABLE base_table, 'embedding', TABLE query_table,...
              ^
