delete from T
--
DeleteStatement [0-13] [delete from T]
  PathExpression [12-13] [T]
    Identifier(T) [12-13] [T]
--
DELETE T
==

delete x.T where true
--
DeleteStatement [0-21] [delete x.T where true]
  PathExpression [7-10] [x.T]
    Identifier(x) [7-8] [x]
    Identifier(T) [9-10] [T]
  BooleanLiteral(true) [17-21] [true]
--
DELETE x.T
WHERE
  true
==

# The resolver will fail on this because WITH OFFSET is not allowed in
# top-level DELETE statements, but it does parse.
delete T with offset AS offset where true
--
DeleteStatement [0-41] [delete T with...where true]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  WithOffset [9-30] [with offset AS offset]
    Alias [21-30] [AS offset]
      Identifier(offset) [24-30] [offset]
  BooleanLiteral(true) [37-41] [true]
--
DELETE T WITH OFFSET AS offset
WHERE
  true
==

delete a.b.c
where c=y
assert_rows_modified 10
--
DeleteStatement [0-46] [delete a.b..._rows_modified 10]
  PathExpression [7-12] [a.b.c]
    Identifier(a) [7-8] [a]
    Identifier(b) [9-10] [b]
    Identifier(c) [11-12] [c]
  BinaryExpression(=) [19-22] [c=y]
    PathExpression [19-20] [c]
      Identifier(c) [19-20] [c]
    PathExpression [21-22] [y]
      Identifier(y) [21-22] [y]
  AssertRowsModified [23-46] [assert_rows_modified 10]
    IntLiteral(10) [44-46] [10]
--
DELETE a.b.c
WHERE
  c = y
ASSERT_ROWS_MODIFIED 10
==

delete T
assert_rows_modified {{0|cast(0 as int32)|@param1|cast(@param1 as int64)}}
--
ALTERNATION GROUP: 0
--
DeleteStatement [0-31] [delete T assert_r...modified 0]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  AssertRowsModified [9-31] [assert_rows_modified 0]
    IntLiteral(0) [30-31] [0]
--
DELETE T
ASSERT_ROWS_MODIFIED 0
--
ALTERNATION GROUP: cast(0 as int32)
--
DeleteStatement [0-46] [delete T assert_r...as int32)]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  AssertRowsModified [9-46] [assert_rows_modif...as int32)]
    CastExpression [30-46] [cast(0 as int32)]
      IntLiteral(0) [35-36] [0]
      SimpleType [40-45] [int32]
        PathExpression [40-45] [int32]
          Identifier(int32) [40-45] [int32]
--
DELETE T
ASSERT_ROWS_MODIFIED CAST(0 AS int32)
--
ALTERNATION GROUP: @param1
--
DeleteStatement [0-37] [delete T assert_r...ed @param1]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  AssertRowsModified [9-37] [assert_rows_modified @param1]
    ParameterExpr [30-37] [@param1]
      Identifier(param1) [31-37] [param1]
--
DELETE T
ASSERT_ROWS_MODIFIED @param1
--
ALTERNATION GROUP: cast(@param1 as int64)
--
DeleteStatement [0-52] [delete T assert_r...as int64)]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  AssertRowsModified [9-52] [assert_rows_modif...as int64)]
    CastExpression [30-52] [cast(@param1 as int64)]
      ParameterExpr [35-42] [@param1]
        Identifier(param1) [36-42] [param1]
      SimpleType [46-51] [int64]
        PathExpression [46-51] [int64]
          Identifier(int64) [46-51] [int64]
--
DELETE T
ASSERT_ROWS_MODIFIED CAST(@param1 AS int64)
==

delete T
assert_rows_modified {{0|cast(0 as int32)|@@sysvar|cast(@@sysvar as int64)}}
--
ALTERNATION GROUP: 0
--
DeleteStatement [0-31] [delete T assert_r...modified 0]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  AssertRowsModified [9-31] [assert_rows_modified 0]
    IntLiteral(0) [30-31] [0]
--
DELETE T
ASSERT_ROWS_MODIFIED 0
--
ALTERNATION GROUP: cast(0 as int32)
--
DeleteStatement [0-46] [delete T assert_r...as int32)]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  AssertRowsModified [9-46] [assert_rows_modif...as int32)]
    CastExpression [30-46] [cast(0 as int32)]
      IntLiteral(0) [35-36] [0]
      SimpleType [40-45] [int32]
        PathExpression [40-45] [int32]
          Identifier(int32) [40-45] [int32]
--
DELETE T
ASSERT_ROWS_MODIFIED CAST(0 AS int32)
--
ALTERNATION GROUP: @@sysvar
--
DeleteStatement [0-38] [delete T assert_r...d @@sysvar]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  AssertRowsModified [9-38] [assert_rows_modified @@sysvar]
    SystemVariableExpr [30-38] [@@sysvar]
      PathExpression [32-38] [sysvar]
        Identifier(sysvar) [32-38] [sysvar]
--
DELETE T
ASSERT_ROWS_MODIFIED @@sysvar
--
ALTERNATION GROUP: cast(@@sysvar as int64)
--
DeleteStatement [0-53] [delete T assert_r...as int64)]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  AssertRowsModified [9-53] [assert_rows_modif...as int64)]
    CastExpression [30-53] [cast(@@sysvar as int64)]
      SystemVariableExpr [35-43] [@@sysvar]
        PathExpression [37-43] [sysvar]
          Identifier(sysvar) [37-43] [sysvar]
      SimpleType [47-52] [int64]
        PathExpression [47-52] [int64]
          Identifier(int64) [47-52] [int64]
--
DELETE T
ASSERT_ROWS_MODIFIED CAST(@@sysvar AS int64)
==

delete T
assert_rows_modified cast(cast(0 as int32) as int64)
--
ERROR: Syntax error: Expected "@" or "@@" or integer literal but got keyword CAST [at 2:27]
assert_rows_modified cast(cast(0 as int32) as int64)
                          ^
==

delete T
assert_rows_modified -1
--
ERROR: Syntax error: Unexpected "-" [at 2:22]
assert_rows_modified -1
                     ^
==

delete T
where 1+(select count(*) from T2)=5
assert_rows_modified @row_count
--
DeleteStatement [0-76] [delete T where...@row_count]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  BinaryExpression(=) [15-44] [1+(select count(*) from T2)=5]
    BinaryExpression(+) [15-42] [1+(select count(*) from T2)]
      IntLiteral(1) [15-16] [1]
      ExpressionSubquery [17-42] [(select count(*) from T2)]
        Query [18-41] [select count(*) from T2]
          Select [18-41] [select count(*) from T2]
            SelectList [25-33] [count(*)]
              SelectColumn [25-33] [count(*)]
                FunctionCall [25-33] [count(*)]
                  PathExpression [25-30] [count]
                    Identifier(count) [25-30] [count]
                  Star(*) [31-32] [*]
            FromClause [34-41] [from T2]
              TablePathExpression [39-41] [T2]
                PathExpression [39-41] [T2]
                  Identifier(T2) [39-41] [T2]
    IntLiteral(5) [43-44] [5]
  AssertRowsModified [45-76] [assert_rows_modif...@row_count]
    ParameterExpr [66-76] [@row_count]
      Identifier(row_count) [67-76] [row_count]
--
DELETE T
WHERE
  1 + (
    SELECT
      count(*)
    FROM
      T2
  ) = 5
ASSERT_ROWS_MODIFIED @row_count
==

delete T
assert_rows_modified x
--
ERROR: Syntax error: Unexpected identifier "x" [at 2:22]
assert_rows_modified x
                     ^
==

delete T
assert_rows_modified 1+2
--
ERROR: Syntax error: Expected end of input but got "+" [at 2:23]
assert_rows_modified 1+2
                      ^
==

delete T
where
assert_rows_modified 5
--
ERROR: Syntax error: Unexpected keyword ASSERT_ROWS_MODIFIED [at 3:1]
assert_rows_modified 5
^
==

delete T
where true
assert_rows_modified
--
ERROR: Syntax error: Unexpected end of statement [at 3:21]
assert_rows_modified
                    ^
==

delete T
where true
assert rows modified 5
--
ERROR: Syntax error: Expected end of input but got keyword ASSERT [at 3:1]
assert rows modified 5
^
==

delete T
assert rows
--
ERROR: Syntax error: Expected end of input but got keyword ROWS [at 2:8]
assert rows
       ^
==

delete T
where true
assert
--
ERROR: Syntax error: Expected end of input but got keyword ASSERT [at 3:1]
assert
^
==

delete
where true
--
ERROR: Syntax error: Unexpected keyword WHERE [at 2:1]
where true
^
==

# The resolver will fail on this because the target involves a generalized
# field access, but it does parse.
delete T.(a.b).c where true
--
DeleteStatement [0-27] [delete T.(a.b).c where true]
  DotIdentifier [7-16] [T.(a.b).c]
    DotGeneralizedField [7-14] [T.(a.b)]
      PathExpression [7-8] [T]
        Identifier(T) [7-8] [T]
      PathExpression [10-13] [a.b]
        Identifier(a) [10-11] [a]
        Identifier(b) [12-13] [b]
    Identifier(c) [15-16] [c]
  BooleanLiteral(true) [23-27] [true]
--
DELETE T.(a.b).c
WHERE
  true
==

# The resolver will fail on this because the target involves [], but it does
# parse.
delete T.a[0].b where true
--
DeleteStatement [0-26] [delete T.a[0].b where true]
  DotIdentifier [7-15] [T.a[0].b]
    ArrayElement [7-13] [T.a[0]]
      PathExpression [7-10] [T.a]
        Identifier(T) [7-8] [T]
        Identifier(a) [9-10] [a]
      Location [10-11] [[]
      IntLiteral(0) [11-12] [0]
    Identifier(b) [14-15] [b]
  BooleanLiteral(true) [22-26] [true]
--
DELETE T.a[0].b
WHERE
  true
==

[no_test_get_parse_tokens]
[language_features={{|V_1_3_ALLOW_DASHES_IN_TABLE_NAME}}]
delete db-1-2.T where true
--
ALTERNATION GROUP: <empty>
--
ERROR: Syntax error: Table name contains '-' character. It needs to be quoted: `db-1-2.T` [at 1:8]
delete db-1-2.T where true
       ^
--
ALTERNATION GROUP: V_1_3_ALLOW_DASHES_IN_TABLE_NAME
--
DeleteStatement [0-26] [delete db-1-2.T where true]
  PathExpression [7-15] [db-1-2.T]
    Identifier(`db-1-2`) [7-15] [db-1-2.T]
    Identifier(T) [7-15] [db-1-2.T]
  BooleanLiteral(true) [22-26] [true]
--
DELETE `db-1-2`.T
WHERE
  true
==

insert into T
values (1)
--
InsertStatement [0-24] [insert into T values (1)]
  PathExpression [12-13] [T]
    Identifier(T) [12-13] [T]
  InsertValuesRowList [14-24] [values (1)]
    InsertValuesRow [21-24] [(1)]
      IntLiteral(1) [22-23] [1]
--
INSERT INTO T
VALUES
  (1)
==

# Duplicate OR IGNORE/REPLACE/UPDATE. In the case where the second instance
# is REPLACE or UPDATE it is interpreted as a table name, because REPLACE
# and UPDATE are non-reserved keywords. When the second instance is IGNORE,
# then it is a keyword and it is treated as a duplicate.
INSERT {{OR|}} {{IGNORE|REPLACE|UPDATE}} {{OR|}} {{IGNORE|REPLACE|UPDATE}}
--
ALTERNATION GROUP: OR,IGNORE,OR,IGNORE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:18]
INSERT OR IGNORE OR IGNORE
                 ^
--
ALTERNATION GROUP: OR,IGNORE,OR,REPLACE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:18]
INSERT OR IGNORE OR REPLACE
                 ^
--
ALTERNATION GROUP: OR,IGNORE,OR,UPDATE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:18]
INSERT OR IGNORE OR UPDATE
                 ^
--
ALTERNATION GROUP: OR,IGNORE,,IGNORE
--
ERROR: Syntax error: Unexpected keyword IGNORE [at 1:19]
INSERT OR IGNORE  IGNORE
                  ^
--
ALTERNATION GROUP: OR,IGNORE,,REPLACE
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:26]
INSERT OR IGNORE  REPLACE
                         ^
--
ALTERNATION GROUP: OR,IGNORE,,UPDATE
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:25]
INSERT OR IGNORE  UPDATE
                        ^
--
ALTERNATION GROUP: OR,REPLACE,OR,IGNORE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:19]
INSERT OR REPLACE OR IGNORE
                  ^
--
ALTERNATION GROUP: OR,REPLACE,OR,REPLACE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:19]
INSERT OR REPLACE OR REPLACE
                  ^
--
ALTERNATION GROUP: OR,REPLACE,OR,UPDATE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:19]
INSERT OR REPLACE OR UPDATE
                  ^
--
ALTERNATION GROUP: OR,REPLACE,,IGNORE
--
ERROR: Syntax error: Unexpected keyword IGNORE [at 1:20]
INSERT OR REPLACE  IGNORE
                   ^
--
ALTERNATION GROUP: OR,REPLACE,,REPLACE
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:27]
INSERT OR REPLACE  REPLACE
                          ^
--
ALTERNATION GROUP: OR,REPLACE,,UPDATE
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:26]
INSERT OR REPLACE  UPDATE
                         ^
--
ALTERNATION GROUP: OR,UPDATE,OR,IGNORE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:18]
INSERT OR UPDATE OR IGNORE
                 ^
--
ALTERNATION GROUP: OR,UPDATE,OR,REPLACE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:18]
INSERT OR UPDATE OR REPLACE
                 ^
--
ALTERNATION GROUP: OR,UPDATE,OR,UPDATE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:18]
INSERT OR UPDATE OR UPDATE
                 ^
--
ALTERNATION GROUP: OR,UPDATE,,IGNORE
--
ERROR: Syntax error: Unexpected keyword IGNORE [at 1:19]
INSERT OR UPDATE  IGNORE
                  ^
--
ALTERNATION GROUP: OR,UPDATE,,REPLACE
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:26]
INSERT OR UPDATE  REPLACE
                         ^
--
ALTERNATION GROUP: OR,UPDATE,,UPDATE
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:25]
INSERT OR UPDATE  UPDATE
                        ^
--
ALTERNATION GROUP: IGNORE,OR,IGNORE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:16]
INSERT  IGNORE OR IGNORE
               ^
--
ALTERNATION GROUP: IGNORE,OR,REPLACE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:16]
INSERT  IGNORE OR REPLACE
               ^
--
ALTERNATION GROUP: IGNORE,OR,UPDATE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:16]
INSERT  IGNORE OR UPDATE
               ^
--
ALTERNATION GROUP: IGNORE,,IGNORE
--
ERROR: Syntax error: Unexpected keyword IGNORE [at 1:17]
INSERT  IGNORE  IGNORE
                ^
--
ALTERNATION GROUP: IGNORE,,REPLACE
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:24]
INSERT  IGNORE  REPLACE
                       ^
--
ALTERNATION GROUP: IGNORE,,UPDATE
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:23]
INSERT  IGNORE  UPDATE
                      ^
--
ALTERNATION GROUP: REPLACE,OR,IGNORE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:17]
INSERT  REPLACE OR IGNORE
                ^
--
ALTERNATION GROUP: REPLACE,OR,REPLACE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:17]
INSERT  REPLACE OR REPLACE
                ^
--
ALTERNATION GROUP: REPLACE,OR,UPDATE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:17]
INSERT  REPLACE OR UPDATE
                ^
--
ALTERNATION GROUP: REPLACE,,IGNORE
--
ERROR: Syntax error: Unexpected keyword IGNORE [at 1:18]
INSERT  REPLACE  IGNORE
                 ^
--
ALTERNATION GROUP: REPLACE,,REPLACE
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:25]
INSERT  REPLACE  REPLACE
                        ^
--
ALTERNATION GROUP: REPLACE,,UPDATE
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:24]
INSERT  REPLACE  UPDATE
                       ^
--
ALTERNATION GROUP: UPDATE,OR,IGNORE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:16]
INSERT  UPDATE OR IGNORE
               ^
--
ALTERNATION GROUP: UPDATE,OR,REPLACE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:16]
INSERT  UPDATE OR REPLACE
               ^
--
ALTERNATION GROUP: UPDATE,OR,UPDATE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:16]
INSERT  UPDATE OR UPDATE
               ^
--
ALTERNATION GROUP: UPDATE,,IGNORE
--
ERROR: Syntax error: Unexpected keyword IGNORE [at 1:17]
INSERT  UPDATE  IGNORE
                ^
--
ALTERNATION GROUP: UPDATE,,REPLACE
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:24]
INSERT  UPDATE  REPLACE
                       ^
--
ALTERNATION GROUP: UPDATE,,UPDATE
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:23]
INSERT  UPDATE  UPDATE
                      ^
==

# Duplicate.
INSERT {{INTO|}} mytable {{INTO|}} mytable
--
ALTERNATION GROUP: INTO,INTO
--
ERROR: Syntax error: Unexpected INSERT target name [at 1:21]
INSERT INTO mytable INTO mytable
                    ^
--
ALTERNATION GROUP: INTO,
--
ERROR: Syntax error: INSERT target cannot have an alias [at 1:22]
INSERT INTO mytable  mytable
                     ^
--
ALTERNATION GROUP: INTO
--
ERROR: Syntax error: Unexpected INSERT target name [at 1:17]
INSERT  mytable INTO mytable
                ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Syntax error: INSERT target cannot have an alias [at 1:18]
INSERT  mytable  mytable
                 ^
==

# Duplicate.
INSERT INTO mytable (c1, c2) (c1, c2)
--
ERROR: Syntax error: Unexpected column list [at 1:30]
INSERT INTO mytable (c1, c2) (c1, c2)
                             ^
==

# Duplicate.
INSERT INTO mytable VALUES (a, b) VALUES (a, b)
--
ERROR: Syntax error: Unexpected VALUES list [at 1:35]
INSERT INTO mytable VALUES (a, b) VALUES (a, b)
                                  ^
==

# Wrong order for OR IGNORE/REPLACE/UPDATE.
INSERT INTO mytable {{(c1, c2)|}}{{VALUES (a, b)|}} {{OR|}} {{IGNORE|REPLACE|UPDATE}}
--
ALTERNATION GROUP: (c1, c2),VALUES (a, b),OR,IGNORE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:43]
INSERT INTO mytable (c1, c2)VALUES (a, b) OR IGNORE
                                          ^
--
ALTERNATION GROUP: (c1, c2),VALUES (a, b),OR,REPLACE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:43]
INSERT INTO mytable (c1, c2)VALUES (a, b) OR REPLACE
                                          ^
--
ALTERNATION GROUP: (c1, c2),VALUES (a, b),OR,UPDATE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:43]
INSERT INTO mytable (c1, c2)VALUES (a, b) OR UPDATE
                                          ^
--
ALTERNATION GROUP: (c1, c2),VALUES (a, b),,IGNORE
--
ERROR: Syntax error: Unexpected keyword IGNORE [at 1:44]
INSERT INTO mytable (c1, c2)VALUES (a, b)  IGNORE
                                           ^
--
ALTERNATION GROUP: (c1, c2),VALUES (a, b),,REPLACE
--
ERROR: Syntax error: Unexpected INSERT target name [at 1:44]
INSERT INTO mytable (c1, c2)VALUES (a, b)  REPLACE
                                           ^
--
ALTERNATION GROUP: (c1, c2),VALUES (a, b),,UPDATE
--
ERROR: Syntax error: Unexpected INSERT target name [at 1:44]
INSERT INTO mytable (c1, c2)VALUES (a, b)  UPDATE
                                           ^
--
ALTERNATION GROUP: (c1, c2),,OR,IGNORE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:30]
INSERT INTO mytable (c1, c2) OR IGNORE
                             ^
--
ALTERNATION GROUP: (c1, c2),,OR,REPLACE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:30]
INSERT INTO mytable (c1, c2) OR REPLACE
                             ^
--
ALTERNATION GROUP: (c1, c2),,OR,UPDATE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:30]
INSERT INTO mytable (c1, c2) OR UPDATE
                             ^
--
ALTERNATION GROUP: (c1, c2),,,IGNORE
--
ERROR: Syntax error: Unexpected keyword IGNORE [at 1:31]
INSERT INTO mytable (c1, c2)  IGNORE
                              ^
--
ALTERNATION GROUP: (c1, c2),,,REPLACE
--
ERROR: Syntax error: Unexpected INSERT target name [at 1:31]
INSERT INTO mytable (c1, c2)  REPLACE
                              ^
--
ALTERNATION GROUP: (c1, c2),,,UPDATE
--
ERROR: Syntax error: Unexpected INSERT target name [at 1:31]
INSERT INTO mytable (c1, c2)  UPDATE
                              ^
--
ALTERNATION GROUP: VALUES (a, b),OR,IGNORE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:35]
INSERT INTO mytable VALUES (a, b) OR IGNORE
                                  ^
--
ALTERNATION GROUP: VALUES (a, b),OR,REPLACE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:35]
INSERT INTO mytable VALUES (a, b) OR REPLACE
                                  ^
--
ALTERNATION GROUP: VALUES (a, b),OR,UPDATE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:35]
INSERT INTO mytable VALUES (a, b) OR UPDATE
                                  ^
--
ALTERNATION GROUP: VALUES (a, b),,IGNORE
--
ERROR: Syntax error: Unexpected keyword IGNORE [at 1:36]
INSERT INTO mytable VALUES (a, b)  IGNORE
                                   ^
--
ALTERNATION GROUP: VALUES (a, b),,REPLACE
--
ERROR: Syntax error: Unexpected INSERT target name [at 1:36]
INSERT INTO mytable VALUES (a, b)  REPLACE
                                   ^
--
ALTERNATION GROUP: VALUES (a, b),,UPDATE
--
ERROR: Syntax error: Unexpected INSERT target name [at 1:36]
INSERT INTO mytable VALUES (a, b)  UPDATE
                                   ^
--
ALTERNATION GROUP: OR,IGNORE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:22]
INSERT INTO mytable  OR IGNORE
                     ^
--
ALTERNATION GROUP: OR,REPLACE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:22]
INSERT INTO mytable  OR REPLACE
                     ^
--
ALTERNATION GROUP: OR,UPDATE
--
ERROR: Syntax error: Unexpected keyword OR [at 1:22]
INSERT INTO mytable  OR UPDATE
                     ^
--
ALTERNATION GROUP: IGNORE
--
ERROR: Syntax error: Unexpected keyword IGNORE [at 1:23]
INSERT INTO mytable   IGNORE
                      ^
--
ALTERNATION GROUP: REPLACE
--
ERROR: Syntax error: INSERT target cannot have an alias [at 1:23]
INSERT INTO mytable   REPLACE
                      ^
--
ALTERNATION GROUP: UPDATE
--
ERROR: Syntax error: INSERT target cannot have an alias [at 1:23]
INSERT INTO mytable   UPDATE
                      ^
==

# Wrong order for column list.
INSERT (c1, c2) INTO mytable
--
ERROR: Syntax error: Expecting INSERT target name [at 1:8]
INSERT (c1, c2) INTO mytable
       ^
==

# Wrong order for VALUES clause.
INSERT VALUES (a, b) {{INTO|}} mytable
--
ALTERNATION GROUP: INTO
--
ERROR: Syntax error: Unexpected INSERT target name [at 1:22]
INSERT VALUES (a, b) INTO mytable
                     ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Syntax error: Unexpected INSERT target name [at 1:23]
INSERT VALUES (a, b)  mytable
                      ^
==

# Wrong order for VALUES clause, missing table.
INSERT VALUES (a, b) (c1, c2)
--
ERROR: Syntax error: Unexpected column list [at 1:22]
INSERT VALUES (a, b) (c1, c2)
                     ^
==

insert {{or|}} ignore {{into|}} {{c.T|values}} {{(c1, c2)|}}
values (5,6), ('abc')
assert_rows_modified 5
--
ALTERNATION GROUP: or,into,c.T,(c1, c2)
--
InsertStatement(insert_mode=IGNORE) [0-79] [insert or...rt_rows_modified 5]
  PathExpression [22-25] [c.T]
    Identifier(c) [22-23] [c]
    Identifier(T) [24-25] [T]
  ColumnList [26-34] [(c1, c2)]
    Identifier(c1) [27-29] [c1]
    Identifier(c2) [31-33] [c2]
  InsertValuesRowList [35-56] [values (5,6), ('abc')]
    InsertValuesRow [42-47] [(5,6)]
      IntLiteral(5) [43-44] [5]
      IntLiteral(6) [45-46] [6]
    InsertValuesRow [49-56] [('abc')]
      StringLiteral('abc') [50-55] ['abc']
  AssertRowsModified [57-79] [assert_rows_modified 5]
    IntLiteral(5) [78-79] [5]
--
INSERT OR IGNORE INTO c.T(c1, c2)
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: or,into,c.T,
--
InsertStatement(insert_mode=IGNORE) [0-71] [insert or...rt_rows_modified 5]
  PathExpression [22-25] [c.T]
    Identifier(c) [22-23] [c]
    Identifier(T) [24-25] [T]
  InsertValuesRowList [27-48] [values (5,6), ('abc')]
    InsertValuesRow [34-39] [(5,6)]
      IntLiteral(5) [35-36] [5]
      IntLiteral(6) [37-38] [6]
    InsertValuesRow [41-48] [('abc')]
      StringLiteral('abc') [42-47] ['abc']
  AssertRowsModified [49-71] [assert_rows_modified 5]
    IntLiteral(5) [70-71] [5]
--
INSERT OR IGNORE INTO c.T
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: or,into,values,(c1, c2)
--
InsertStatement(insert_mode=IGNORE) [0-82] [insert or...rt_rows_modified 5]
  PathExpression [22-28] [values]
    Identifier(values) [22-28] [values]
  ColumnList [29-37] [(c1, c2)]
    Identifier(c1) [30-32] [c1]
    Identifier(c2) [34-36] [c2]
  InsertValuesRowList [38-59] [values (5,6), ('abc')]
    InsertValuesRow [45-50] [(5,6)]
      IntLiteral(5) [46-47] [5]
      IntLiteral(6) [48-49] [6]
    InsertValuesRow [52-59] [('abc')]
      StringLiteral('abc') [53-58] ['abc']
  AssertRowsModified [60-82] [assert_rows_modified 5]
    IntLiteral(5) [81-82] [5]
--
INSERT OR IGNORE INTO values(c1, c2)
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: or,into,values,
--
InsertStatement(insert_mode=IGNORE) [0-74] [insert or...rt_rows_modified 5]
  PathExpression [22-28] [values]
    Identifier(values) [22-28] [values]
  InsertValuesRowList [30-51] [values (5,6), ('abc')]
    InsertValuesRow [37-42] [(5,6)]
      IntLiteral(5) [38-39] [5]
      IntLiteral(6) [40-41] [6]
    InsertValuesRow [44-51] [('abc')]
      StringLiteral('abc') [45-50] ['abc']
  AssertRowsModified [52-74] [assert_rows_modified 5]
    IntLiteral(5) [73-74] [5]
--
INSERT OR IGNORE INTO values
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: or,,c.T,(c1, c2)
--
InsertStatement(insert_mode=IGNORE) [0-75] [insert or...rt_rows_modified 5]
  PathExpression [18-21] [c.T]
    Identifier(c) [18-19] [c]
    Identifier(T) [20-21] [T]
  ColumnList [22-30] [(c1, c2)]
    Identifier(c1) [23-25] [c1]
    Identifier(c2) [27-29] [c2]
  InsertValuesRowList [31-52] [values (5,6), ('abc')]
    InsertValuesRow [38-43] [(5,6)]
      IntLiteral(5) [39-40] [5]
      IntLiteral(6) [41-42] [6]
    InsertValuesRow [45-52] [('abc')]
      StringLiteral('abc') [46-51] ['abc']
  AssertRowsModified [53-75] [assert_rows_modified 5]
    IntLiteral(5) [74-75] [5]
--
INSERT OR IGNORE INTO c.T(c1, c2)
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: or,,c.T,
--
InsertStatement(insert_mode=IGNORE) [0-67] [insert or...rt_rows_modified 5]
  PathExpression [18-21] [c.T]
    Identifier(c) [18-19] [c]
    Identifier(T) [20-21] [T]
  InsertValuesRowList [23-44] [values (5,6), ('abc')]
    InsertValuesRow [30-35] [(5,6)]
      IntLiteral(5) [31-32] [5]
      IntLiteral(6) [33-34] [6]
    InsertValuesRow [37-44] [('abc')]
      StringLiteral('abc') [38-43] ['abc']
  AssertRowsModified [45-67] [assert_rows_modified 5]
    IntLiteral(5) [66-67] [5]
--
INSERT OR IGNORE INTO c.T
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: or,,values,(c1, c2)
--
InsertStatement(insert_mode=IGNORE) [0-78] [insert or...rt_rows_modified 5]
  PathExpression [18-24] [values]
    Identifier(values) [18-24] [values]
  ColumnList [25-33] [(c1, c2)]
    Identifier(c1) [26-28] [c1]
    Identifier(c2) [30-32] [c2]
  InsertValuesRowList [34-55] [values (5,6), ('abc')]
    InsertValuesRow [41-46] [(5,6)]
      IntLiteral(5) [42-43] [5]
      IntLiteral(6) [44-45] [6]
    InsertValuesRow [48-55] [('abc')]
      StringLiteral('abc') [49-54] ['abc']
  AssertRowsModified [56-78] [assert_rows_modified 5]
    IntLiteral(5) [77-78] [5]
--
INSERT OR IGNORE INTO values(c1, c2)
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: or,,values,
--
InsertStatement(insert_mode=IGNORE) [0-70] [insert or...rt_rows_modified 5]
  PathExpression [18-24] [values]
    Identifier(values) [18-24] [values]
  InsertValuesRowList [26-47] [values (5,6), ('abc')]
    InsertValuesRow [33-38] [(5,6)]
      IntLiteral(5) [34-35] [5]
      IntLiteral(6) [36-37] [6]
    InsertValuesRow [40-47] [('abc')]
      StringLiteral('abc') [41-46] ['abc']
  AssertRowsModified [48-70] [assert_rows_modified 5]
    IntLiteral(5) [69-70] [5]
--
INSERT OR IGNORE INTO values
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: into,c.T,(c1, c2)
--
InsertStatement(insert_mode=IGNORE) [0-77] [insert  ignore...ws_modified 5]
  PathExpression [20-23] [c.T]
    Identifier(c) [20-21] [c]
    Identifier(T) [22-23] [T]
  ColumnList [24-32] [(c1, c2)]
    Identifier(c1) [25-27] [c1]
    Identifier(c2) [29-31] [c2]
  InsertValuesRowList [33-54] [values (5,6), ('abc')]
    InsertValuesRow [40-45] [(5,6)]
      IntLiteral(5) [41-42] [5]
      IntLiteral(6) [43-44] [6]
    InsertValuesRow [47-54] [('abc')]
      StringLiteral('abc') [48-53] ['abc']
  AssertRowsModified [55-77] [assert_rows_modified 5]
    IntLiteral(5) [76-77] [5]
--
INSERT OR IGNORE INTO c.T(c1, c2)
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: into,c.T,
--
InsertStatement(insert_mode=IGNORE) [0-69] [insert  ignore...ws_modified 5]
  PathExpression [20-23] [c.T]
    Identifier(c) [20-21] [c]
    Identifier(T) [22-23] [T]
  InsertValuesRowList [25-46] [values (5,6), ('abc')]
    InsertValuesRow [32-37] [(5,6)]
      IntLiteral(5) [33-34] [5]
      IntLiteral(6) [35-36] [6]
    InsertValuesRow [39-46] [('abc')]
      StringLiteral('abc') [40-45] ['abc']
  AssertRowsModified [47-69] [assert_rows_modified 5]
    IntLiteral(5) [68-69] [5]
--
INSERT OR IGNORE INTO c.T
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: into,values,(c1, c2)
--
InsertStatement(insert_mode=IGNORE) [0-80] [insert  ignore...ws_modified 5]
  PathExpression [20-26] [values]
    Identifier(values) [20-26] [values]
  ColumnList [27-35] [(c1, c2)]
    Identifier(c1) [28-30] [c1]
    Identifier(c2) [32-34] [c2]
  InsertValuesRowList [36-57] [values (5,6), ('abc')]
    InsertValuesRow [43-48] [(5,6)]
      IntLiteral(5) [44-45] [5]
      IntLiteral(6) [46-47] [6]
    InsertValuesRow [50-57] [('abc')]
      StringLiteral('abc') [51-56] ['abc']
  AssertRowsModified [58-80] [assert_rows_modified 5]
    IntLiteral(5) [79-80] [5]
--
INSERT OR IGNORE INTO values(c1, c2)
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: into,values,
--
InsertStatement(insert_mode=IGNORE) [0-72] [insert  ignore...ws_modified 5]
  PathExpression [20-26] [values]
    Identifier(values) [20-26] [values]
  InsertValuesRowList [28-49] [values (5,6), ('abc')]
    InsertValuesRow [35-40] [(5,6)]
      IntLiteral(5) [36-37] [5]
      IntLiteral(6) [38-39] [6]
    InsertValuesRow [42-49] [('abc')]
      StringLiteral('abc') [43-48] ['abc']
  AssertRowsModified [50-72] [assert_rows_modified 5]
    IntLiteral(5) [71-72] [5]
--
INSERT OR IGNORE INTO values
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: c.T,(c1, c2)
--
InsertStatement(insert_mode=IGNORE) [0-73] [insert  ignore...ws_modified 5]
  PathExpression [16-19] [c.T]
    Identifier(c) [16-17] [c]
    Identifier(T) [18-19] [T]
  ColumnList [20-28] [(c1, c2)]
    Identifier(c1) [21-23] [c1]
    Identifier(c2) [25-27] [c2]
  InsertValuesRowList [29-50] [values (5,6), ('abc')]
    InsertValuesRow [36-41] [(5,6)]
      IntLiteral(5) [37-38] [5]
      IntLiteral(6) [39-40] [6]
    InsertValuesRow [43-50] [('abc')]
      StringLiteral('abc') [44-49] ['abc']
  AssertRowsModified [51-73] [assert_rows_modified 5]
    IntLiteral(5) [72-73] [5]
--
INSERT OR IGNORE INTO c.T(c1, c2)
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: c.T,
--
InsertStatement(insert_mode=IGNORE) [0-65] [insert  ignore...ws_modified 5]
  PathExpression [16-19] [c.T]
    Identifier(c) [16-17] [c]
    Identifier(T) [18-19] [T]
  InsertValuesRowList [21-42] [values (5,6), ('abc')]
    InsertValuesRow [28-33] [(5,6)]
      IntLiteral(5) [29-30] [5]
      IntLiteral(6) [31-32] [6]
    InsertValuesRow [35-42] [('abc')]
      StringLiteral('abc') [36-41] ['abc']
  AssertRowsModified [43-65] [assert_rows_modified 5]
    IntLiteral(5) [64-65] [5]
--
INSERT OR IGNORE INTO c.T
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: values,(c1, c2)
--
InsertStatement(insert_mode=IGNORE) [0-76] [insert  ignore...ws_modified 5]
  PathExpression [16-22] [values]
    Identifier(values) [16-22] [values]
  ColumnList [23-31] [(c1, c2)]
    Identifier(c1) [24-26] [c1]
    Identifier(c2) [28-30] [c2]
  InsertValuesRowList [32-53] [values (5,6), ('abc')]
    InsertValuesRow [39-44] [(5,6)]
      IntLiteral(5) [40-41] [5]
      IntLiteral(6) [42-43] [6]
    InsertValuesRow [46-53] [('abc')]
      StringLiteral('abc') [47-52] ['abc']
  AssertRowsModified [54-76] [assert_rows_modified 5]
    IntLiteral(5) [75-76] [5]
--
INSERT OR IGNORE INTO values(c1, c2)
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
--
ALTERNATION GROUP: values,
--
InsertStatement(insert_mode=IGNORE) [0-68] [insert  ignore...ws_modified 5]
  PathExpression [16-22] [values]
    Identifier(values) [16-22] [values]
  InsertValuesRowList [24-45] [values (5,6), ('abc')]
    InsertValuesRow [31-36] [(5,6)]
      IntLiteral(5) [32-33] [5]
      IntLiteral(6) [34-35] [6]
    InsertValuesRow [38-45] [('abc')]
      StringLiteral('abc') [39-44] ['abc']
  AssertRowsModified [46-68] [assert_rows_modified 5]
    IntLiteral(5) [67-68] [5]
--
INSERT OR IGNORE INTO values
VALUES
  (5, 6),
  ('abc')
ASSERT_ROWS_MODIFIED 5
==

# Test all combinations of missing and present parts.
# The insert_mode is never treated as a table name, although the tests below
# show that those can be valid table names after INTO.
insert{{ or|}}{{| ignore| replace| update}}{{ into|}}{{ T|}}
select 1
--
ALTERNATION GROUP:  or,, into, T
--
ERROR: Syntax error: Expected keyword IGNORE or keyword REPLACE or keyword UPDATE but got keyword INTO [at 1:11]
insert or into T
          ^
--
ALTERNATION GROUP:  or,, into,
--
ERROR: Syntax error: Expected keyword IGNORE or keyword REPLACE or keyword UPDATE but got keyword INTO [at 1:11]
insert or into
          ^
--
ALTERNATION GROUP:  or,,, T
--
ERROR: Syntax error: Expected keyword IGNORE or keyword REPLACE or keyword UPDATE but got identifier "T" [at 1:11]
insert or T
          ^
--
ALTERNATION GROUP:  or,,,
--
ERROR: Syntax error: Expected keyword IGNORE or keyword REPLACE or keyword UPDATE but got keyword SELECT [at 2:1]
select 1
^
--
ALTERNATION GROUP:  or, ignore, into, T
--
InsertStatement(insert_mode=IGNORE) [0-32] [insert or...T select 1]
  PathExpression [22-23] [T]
    Identifier(T) [22-23] [T]
  Query [24-32] [select 1]
    Select [24-32] [select 1]
      SelectList [31-32] [1]
        SelectColumn [31-32] [1]
          IntLiteral(1) [31-32] [1]
--
INSERT OR IGNORE INTO T
SELECT
  1
--
ALTERNATION GROUPS:
     or, ignore, into,
     or, replace, into,
     or, update, into,
     into,
     ignore, into,
     replace, into,
     update, into,
--
ERROR: Syntax error: Unexpected keyword SELECT [at 2:1]
select 1
^
--
ALTERNATION GROUP:  or, ignore,, T
--
InsertStatement(insert_mode=IGNORE) [0-27] [insert or ignore T select 1]
  PathExpression [17-18] [T]
    Identifier(T) [17-18] [T]
  Query [19-27] [select 1]
    Select [19-27] [select 1]
      SelectList [26-27] [1]
        SelectColumn [26-27] [1]
          IntLiteral(1) [26-27] [1]
--
INSERT OR IGNORE INTO T
SELECT
  1
--
ALTERNATION GROUPS:
     or, ignore,,
     or, replace,,
     or, update,,
    <empty>
     ignore,,
     replace,,
     update,,
--
ERROR: Syntax error: Expecting INSERT target name [at 2:1]
select 1
^
--
ALTERNATION GROUP:  or, replace, into, T
--
InsertStatement(insert_mode=REPLACE) [0-33] [insert or...T select 1]
  PathExpression [23-24] [T]
    Identifier(T) [23-24] [T]
  Query [25-33] [select 1]
    Select [25-33] [select 1]
      SelectList [32-33] [1]
        SelectColumn [32-33] [1]
          IntLiteral(1) [32-33] [1]
--
INSERT OR REPLACE INTO T
SELECT
  1
--
ALTERNATION GROUP:  or, replace,, T
--
InsertStatement(insert_mode=REPLACE) [0-28] [insert or replace T select 1]
  PathExpression [18-19] [T]
    Identifier(T) [18-19] [T]
  Query [20-28] [select 1]
    Select [20-28] [select 1]
      SelectList [27-28] [1]
        SelectColumn [27-28] [1]
          IntLiteral(1) [27-28] [1]
--
INSERT OR REPLACE INTO T
SELECT
  1
--
ALTERNATION GROUP:  or, update, into, T
--
InsertStatement(insert_mode=UPDATE) [0-32] [insert or...T select 1]
  PathExpression [22-23] [T]
    Identifier(T) [22-23] [T]
  Query [24-32] [select 1]
    Select [24-32] [select 1]
      SelectList [31-32] [1]
        SelectColumn [31-32] [1]
          IntLiteral(1) [31-32] [1]
--
INSERT OR UPDATE INTO T
SELECT
  1
--
ALTERNATION GROUP:  or, update,, T
--
InsertStatement(insert_mode=UPDATE) [0-27] [insert or update T select 1]
  PathExpression [17-18] [T]
    Identifier(T) [17-18] [T]
  Query [19-27] [select 1]
    Select [19-27] [select 1]
      SelectList [26-27] [1]
        SelectColumn [26-27] [1]
          IntLiteral(1) [26-27] [1]
--
INSERT OR UPDATE INTO T
SELECT
  1
--
ALTERNATION GROUP:  into, T
--
InsertStatement [0-22] [insert into T select 1]
  PathExpression [12-13] [T]
    Identifier(T) [12-13] [T]
  Query [14-22] [select 1]
    Select [14-22] [select 1]
      SelectList [21-22] [1]
        SelectColumn [21-22] [1]
          IntLiteral(1) [21-22] [1]
--
INSERT INTO T
SELECT
  1
--
ALTERNATION GROUP:  T
--
InsertStatement [0-17] [insert T select 1]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Query [9-17] [select 1]
    Select [9-17] [select 1]
      SelectList [16-17] [1]
        SelectColumn [16-17] [1]
          IntLiteral(1) [16-17] [1]
--
INSERT INTO T
SELECT
  1
--
ALTERNATION GROUP:  ignore, into, T
--
InsertStatement(insert_mode=IGNORE) [0-29] [insert ignore into T select 1]
  PathExpression [19-20] [T]
    Identifier(T) [19-20] [T]
  Query [21-29] [select 1]
    Select [21-29] [select 1]
      SelectList [28-29] [1]
        SelectColumn [28-29] [1]
          IntLiteral(1) [28-29] [1]
--
INSERT OR IGNORE INTO T
SELECT
  1
--
ALTERNATION GROUP:  ignore,, T
--
InsertStatement(insert_mode=IGNORE) [0-24] [insert ignore T select 1]
  PathExpression [14-15] [T]
    Identifier(T) [14-15] [T]
  Query [16-24] [select 1]
    Select [16-24] [select 1]
      SelectList [23-24] [1]
        SelectColumn [23-24] [1]
          IntLiteral(1) [23-24] [1]
--
INSERT OR IGNORE INTO T
SELECT
  1
--
ALTERNATION GROUP:  replace, into, T
--
InsertStatement(insert_mode=REPLACE) [0-30] [insert replace into T select 1]
  PathExpression [20-21] [T]
    Identifier(T) [20-21] [T]
  Query [22-30] [select 1]
    Select [22-30] [select 1]
      SelectList [29-30] [1]
        SelectColumn [29-30] [1]
          IntLiteral(1) [29-30] [1]
--
INSERT OR REPLACE INTO T
SELECT
  1
--
ALTERNATION GROUP:  replace,, T
--
InsertStatement(insert_mode=REPLACE) [0-25] [insert replace T select 1]
  PathExpression [15-16] [T]
    Identifier(T) [15-16] [T]
  Query [17-25] [select 1]
    Select [17-25] [select 1]
      SelectList [24-25] [1]
        SelectColumn [24-25] [1]
          IntLiteral(1) [24-25] [1]
--
INSERT OR REPLACE INTO T
SELECT
  1
--
ALTERNATION GROUP:  update, into, T
--
InsertStatement(insert_mode=UPDATE) [0-29] [insert update into T select 1]
  PathExpression [19-20] [T]
    Identifier(T) [19-20] [T]
  Query [21-29] [select 1]
    Select [21-29] [select 1]
      SelectList [28-29] [1]
        SelectColumn [28-29] [1]
          IntLiteral(1) [28-29] [1]
--
INSERT OR UPDATE INTO T
SELECT
  1
--
ALTERNATION GROUP:  update,, T
--
InsertStatement(insert_mode=UPDATE) [0-24] [insert update T select 1]
  PathExpression [14-15] [T]
    Identifier(T) [14-15] [T]
  Query [16-24] [select 1]
    Select [16-24] [select 1]
      SelectList [23-24] [1]
        SelectColumn [23-24] [1]
          IntLiteral(1) [23-24] [1]
--
INSERT OR UPDATE INTO T
SELECT
  1
==

# After "values", the Bison parser parses the list as a values list, even if the
# "values" is really a table name, which means that the list should be
# interpreted as a column list.
INSERT values (a, b)
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:21]
INSERT values (a, b)
                    ^
==

INSERT values values (a, b)
--
InsertStatement [0-27] [INSERT values values (a, b)]
  PathExpression [7-13] [values]
    Identifier(values) [7-13] [values]
  InsertValuesRowList [14-27] [values (a, b)]
    InsertValuesRow [21-27] [(a, b)]
      PathExpression [22-23] [a]
        Identifier(a) [22-23] [a]
      PathExpression [25-26] [b]
        Identifier(b) [25-26] [b]
--
INSERT INTO values
VALUES
  (a, b)
==

INSERT mytable values (a, b)
--
InsertStatement [0-28] [INSERT mytable values (a, b)]
  PathExpression [7-14] [mytable]
    Identifier(mytable) [7-14] [mytable]
  InsertValuesRowList [15-28] [values (a, b)]
    InsertValuesRow [22-28] [(a, b)]
      PathExpression [23-24] [a]
        Identifier(a) [23-24] [a]
      PathExpression [26-27] [b]
        Identifier(b) [26-27] [b]
--
INSERT INTO mytable
VALUES
  (a, b)
==

INSERT values mytable (a, b)
--
ERROR: Syntax error: INSERT target cannot have an alias [at 1:15]
INSERT values mytable (a, b)
              ^
==

# Bad column list (values is a table name here).
INSERT values (1, 3)
--
ERROR: Syntax error: Expected column name [at 1:16]
INSERT values (1, 3)
               ^
==

# After "values", the Bison parser parses the list as a values list, even if
# the "values" is really a table name, which means that the list should be
# interpreted as a column list. In this test case multiple column lists are
# given, which parses correctly but is then rejected when the list is
# reinterpreted as a column list.
INSERT values (a, b), (c, d)
--
ERROR: Syntax error: Unexpected multiple column lists [at 1:23]
INSERT values (a, b), (c, d)
                      ^
==

# Same as the previous test case, but the first column list doesn't parse as a
# column list.
INSERT values (1, 3), (c, d)
--
ERROR: Syntax error: Expected column name [at 1:16]
INSERT values (1, 3), (c, d)
               ^
==

# Column list after "values" (which is a table name here) that includes the
# "default" keyword. It is still a keyword, so it can't be included in the
# column name list without escaping..
INSERT values (a, default) values (1, 3)
--
ERROR: Syntax error: Expected column name, got keyword DEFAULT [at 1:19]
INSERT values (a, default) values (1, 3)
                  ^
==

# Using "default" as a column name works fine with escaping.
INSERT values (a, `default`) values (1, 3)
--
InsertStatement [0-42] [INSERT values...values (1, 3)]
  PathExpression [7-13] [values]
    Identifier(values) [7-13] [values]
  ColumnList [14-28] [(a, `default`)]
    Identifier(a) [15-16] [a]
    Identifier(`default`) [18-27] [`default`]
  InsertValuesRowList [29-42] [values (1, 3)]
    InsertValuesRow [36-42] [(1, 3)]
      IntLiteral(1) [37-38] [1]
      IntLiteral(3) [40-41] [3]
--
INSERT INTO values(a, `default`)
VALUES
  (1, 3)
==

insert or ignore {{into|}} replace
select 1
--
ALTERNATION GROUP: into
--
InsertStatement(insert_mode=IGNORE) [0-38] [insert or...replace select 1]
  PathExpression [22-29] [replace]
    Identifier(`replace`) [22-29] [replace]
  Query [30-38] [select 1]
    Select [30-38] [select 1]
      SelectList [37-38] [1]
        SelectColumn [37-38] [1]
          IntLiteral(1) [37-38] [1]
--
INSERT OR IGNORE INTO `replace`
SELECT
  1
--
ALTERNATION GROUP: <empty>
--
InsertStatement(insert_mode=IGNORE) [0-34] [insert or...replace select 1]
  PathExpression [18-25] [replace]
    Identifier(`replace`) [18-25] [replace]
  Query [26-34] [select 1]
    Select [26-34] [select 1]
      SelectList [33-34] [1]
        SelectColumn [33-34] [1]
          IntLiteral(1) [33-34] [1]
--
INSERT OR IGNORE INTO `replace`
SELECT
  1
==

insert into insert
select 1
--
InsertStatement [0-27] [insert into insert select 1]
  PathExpression [12-18] [insert]
    Identifier(insert) [12-18] [insert]
  Query [19-27] [select 1]
    Select [19-27] [select 1]
      SelectList [26-27] [1]
        SelectColumn [26-27] [1]
          IntLiteral(1) [26-27] [1]
--
INSERT INTO insert
SELECT
  1
==

# IGNORE is a reserved keyword.
insert into ignore
select 1
--
ERROR: Syntax error: Unexpected keyword IGNORE [at 1:13]
insert into ignore
            ^
==

insert into replace
select 1
--
InsertStatement [0-28] [insert into replace select 1]
  PathExpression [12-19] [replace]
    Identifier(`replace`) [12-19] [replace]
  Query [20-28] [select 1]
    Select [20-28] [select 1]
      SelectList [27-28] [1]
        SelectColumn [27-28] [1]
          IntLiteral(1) [27-28] [1]
--
INSERT INTO `replace`
SELECT
  1
==

insert into T (c1)
with q1 as (select 1)
select * from q1
assert_rows_modified @row_count
--
InsertStatement [0-89] [insert into...@row_count]
  PathExpression [12-13] [T]
    Identifier(T) [12-13] [T]
  ColumnList [14-18] [(c1)]
    Identifier(c1) [15-17] [c1]
  Query [19-57] [with q1 as...* from q1]
    WithClause [19-40] [with q1 as (select 1)]
      WithClauseEntry [24-40] [q1 as (select 1)]
        Identifier(q1) [24-26] [q1]
        Query [31-39] [select 1]
          Select [31-39] [select 1]
            SelectList [38-39] [1]
              SelectColumn [38-39] [1]
                IntLiteral(1) [38-39] [1]
    Select [41-57] [select * from q1]
      SelectList [48-49] [*]
        SelectColumn [48-49] [*]
          Star(*) [48-49] [*]
      FromClause [50-57] [from q1]
        TablePathExpression [55-57] [q1]
          PathExpression [55-57] [q1]
            Identifier(q1) [55-57] [q1]
  AssertRowsModified [58-89] [assert_rows_modif...@row_count]
    ParameterExpr [79-89] [@row_count]
      Identifier(row_count) [80-89] [row_count]
--
INSERT INTO T(c1)
WITH
  q1 AS (
    SELECT
      1
  )
SELECT
  *
FROM
  q1
ASSERT_ROWS_MODIFIED @row_count
==

insert into T
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:14]
insert into T
             ^
==

insert into T (c1,c2)
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:22]
insert into T (c1,c2)
                     ^
==

insert into T (c1,c2)
assert_rows_modified 10
--
ERROR: Syntax error: Expecting VALUES list or query [at 2:1]
assert_rows_modified 10
^
==

insert into T ()
select 1
--
ERROR: Syntax error: Unexpected ")" [at 1:16]
insert into T ()
               ^
==

insert into T
values ()
--
ERROR: Syntax error: Unexpected ")" [at 2:9]
values ()
        ^
==

insert into T
values ((1,2), (select 1))
--
InsertStatement [0-40] [insert into...select 1))]
  PathExpression [12-13] [T]
    Identifier(T) [12-13] [T]
  InsertValuesRowList [14-40] [values ((1,2), (select 1))]
    InsertValuesRow [21-40] [((1,2), (select 1))]
      StructConstructorWithParens [22-27] [(1,2)]
        IntLiteral(1) [23-24] [1]
        IntLiteral(2) [25-26] [2]
      ExpressionSubquery [29-39] [(select 1)]
        Query [30-38] [select 1]
          Select [30-38] [select 1]
            SelectList [37-38] [1]
              SelectColumn [37-38] [1]
                IntLiteral(1) [37-38] [1]
--
INSERT INTO T
VALUES
  ((1, 2), (
      SELECT
        1
    ))
==

insert into T
values (1,2), (select 1)
--
ERROR: Syntax error: Unexpected keyword SELECT [at 2:16]
values (1,2), (select 1)
               ^
==

insert into T
values (1,2), ((select 1))
--
InsertStatement [0-40] [insert into...select 1))]
  PathExpression [12-13] [T]
    Identifier(T) [12-13] [T]
  InsertValuesRowList [14-40] [values (1,2), ((select 1))]
    InsertValuesRow [21-26] [(1,2)]
      IntLiteral(1) [22-23] [1]
      IntLiteral(2) [24-25] [2]
    InsertValuesRow [28-40] [((select 1))]
      ExpressionSubquery [29-39] [(select 1)]
        Query [30-38] [select 1]
          Select [30-38] [select 1]
            SelectList [37-38] [1]
              SelectColumn [37-38] [1]
                IntLiteral(1) [37-38] [1]
--
INSERT INTO T
VALUES
  (1, 2),
  ((
      SELECT
        1
    ))
==

# WITH with no column_list.
insert T
with q1 as (select 1)
select * from q1
--
InsertStatement [0-47] [insert T with...* from q1]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Query [9-47] [with q1 as...* from q1]
    WithClause [9-30] [with q1 as (select 1)]
      WithClauseEntry [14-30] [q1 as (select 1)]
        Identifier(q1) [14-16] [q1]
        Query [21-29] [select 1]
          Select [21-29] [select 1]
            SelectList [28-29] [1]
              SelectColumn [28-29] [1]
                IntLiteral(1) [28-29] [1]
    Select [31-47] [select * from q1]
      SelectList [38-39] [*]
        SelectColumn [38-39] [*]
          Star(*) [38-39] [*]
      FromClause [40-47] [from q1]
        TablePathExpression [45-47] [q1]
          PathExpression [45-47] [q1]
            Identifier(q1) [45-47] [q1]
--
INSERT INTO T
WITH
  q1 AS (
    SELECT
      1
  )
SELECT
  *
FROM
  q1
==

insert or replace into T
select * from q1
union all
select * from q2
order by x
limit 5
assert_rows_modified 0
--
InsertStatement(insert_mode=REPLACE) [0-110] [insert or...rt_rows_modified 0]
  PathExpression [23-24] [T]
    Identifier(T) [23-24] [T]
  Query [25-87] [select * from...x limit 5]
    SetOperation(UNION ALL) [25-68] [select * from...* from q2]
      Select [25-41] [select * from q1]
        SelectList [32-33] [*]
          SelectColumn [32-33] [*]
            Star(*) [32-33] [*]
        FromClause [34-41] [from q1]
          TablePathExpression [39-41] [q1]
            PathExpression [39-41] [q1]
              Identifier(q1) [39-41] [q1]
      Select [52-68] [select * from q2]
        SelectList [59-60] [*]
          SelectColumn [59-60] [*]
            Star(*) [59-60] [*]
        FromClause [61-68] [from q2]
          TablePathExpression [66-68] [q2]
            PathExpression [66-68] [q2]
              Identifier(q2) [66-68] [q2]
    OrderBy [69-79] [order by x]
      OrderingExpression(ASC) [78-79] [x]
        PathExpression [78-79] [x]
          Identifier(x) [78-79] [x]
    LimitOffset [80-87] [limit 5]
      IntLiteral(5) [86-87] [5]
  AssertRowsModified [88-110] [assert_rows_modified 0]
    IntLiteral(0) [109-110] [0]
--
INSERT OR REPLACE INTO T
SELECT
  *
FROM
  q1
UNION ALL
SELECT
  *
FROM
  q2
ORDER BY x
LIMIT 5
ASSERT_ROWS_MODIFIED 0
==

insert into T (c1,c2)
values (1+2, f(), null, default),
       (default, (select x from y))
--
InsertStatement [0-91] [insert into...x from y))]
  PathExpression [12-13] [T]
    Identifier(T) [12-13] [T]
  ColumnList [14-21] [(c1,c2)]
    Identifier(c1) [15-17] [c1]
    Identifier(c2) [18-20] [c2]
  InsertValuesRowList [22-91] [values (1+...x from y))]
    InsertValuesRow [29-54] [(1+2, f(), null, default)]
      BinaryExpression(+) [30-33] [1+2]
        IntLiteral(1) [30-31] [1]
        IntLiteral(2) [32-33] [2]
      FunctionCall [35-38] [f()]
        PathExpression [35-36] [f]
          Identifier(f) [35-36] [f]
      NullLiteral(null) [40-44] [null]
      DefaultLiteral [46-53] [default]
    InsertValuesRow [63-91] [(default, (select x from y))]
      DefaultLiteral [64-71] [default]
      ExpressionSubquery [73-90] [(select x from y)]
        Query [74-89] [select x from y]
          Select [74-89] [select x from y]
            SelectList [81-82] [x]
              SelectColumn [81-82] [x]
                PathExpression [81-82] [x]
                  Identifier(x) [81-82] [x]
            FromClause [83-89] [from y]
              TablePathExpression [88-89] [y]
                PathExpression [88-89] [y]
                  Identifier(y) [88-89] [y]
--
INSERT INTO T(c1, c2)
VALUES
  (1 + 2, f(), null, DEFAULT),
  (DEFAULT, (
      SELECT
        x
      FROM
        y
    ))
==

insert into c1.T (c1.c2)
--
ERROR: Syntax error: Expected ")" or "," but got "." [at 1:21]
insert into c1.T (c1.c2)
                    ^
==

insert into (select 1)
--
ERROR: Syntax error: Unexpected "(" [at 1:13]
insert into (select 1)
            ^
==

insert into T
values (1,2)
select 5
--
ERROR: Syntax error: Unexpected query [at 3:1]
select 5
^
==

insert into T
select 5
values (1,2)
--
ERROR: Syntax error: Expected end of input but got "(" [at 3:8]
values (1,2)
       ^
==

# Parenthesized query without a column_list.  This exercises the special
# case in insert_statement().
insert into T
(select 5)
--
InsertStatement [0-24] [insert into T (select 5)]
  PathExpression [12-13] [T]
    Identifier(T) [12-13] [T]
  Query [14-24] [(select 5)]
    Query [15-23] [select 5]
      Select [15-23] [select 5]
        SelectList [22-23] [5]
          SelectColumn [22-23] [5]
            IntLiteral(5) [22-23] [5]
--
INSERT INTO T
(
SELECT
  5
)
==

# Double-parenthesized query without a column_list.
insert into T
((select 1) union all (select 2))
--
InsertStatement [0-47] [insert into...select 2))]
  PathExpression [12-13] [T]
    Identifier(T) [12-13] [T]
  Query [14-47] [((select 1...select 2))]
    Query [15-46] [(select 1)...(select 2)]
      SetOperation(UNION ALL) [15-46] [(select 1)...(select 2)]
        Query [16-24] [select 1]
          Select [16-24] [select 1]
            SelectList [23-24] [1]
              SelectColumn [23-24] [1]
                IntLiteral(1) [23-24] [1]
        Query [37-45] [select 2]
          Select [37-45] [select 2]
            SelectList [44-45] [2]
              SelectColumn [44-45] [2]
                IntLiteral(2) [44-45] [2]
--
INSERT INTO T
((
SELECT
  1
) UNION ALL(
SELECT
  2
))
==

insert into T (c1, c2)
(select 5, 7) union all select 8,9
--
InsertStatement [0-57] [insert into...select 8,9]
  PathExpression [12-13] [T]
    Identifier(T) [12-13] [T]
  ColumnList [14-22] [(c1, c2)]
    Identifier(c1) [15-17] [c1]
    Identifier(c2) [19-21] [c2]
  Query [23-57] [(select 5,...select 8,9]
    SetOperation(UNION ALL) [23-57] [(select 5,...select 8,9]
      Query [24-35] [select 5, 7]
        Select [24-35] [select 5, 7]
          SelectList [31-35] [5, 7]
            SelectColumn [31-32] [5]
              IntLiteral(5) [31-32] [5]
            SelectColumn [34-35] [7]
              IntLiteral(7) [34-35] [7]
      Select [47-57] [select 8,9]
        SelectList [54-57] [8,9]
          SelectColumn [54-55] [8]
            IntLiteral(8) [54-55] [8]
          SelectColumn [56-57] [9]
            IntLiteral(9) [56-57] [9]
--
INSERT INTO T(c1, c2)
(
SELECT
  5,
  7
) UNION ALL
SELECT
  8,
  9
==

insert into T (c1, c2) (c3)
--
ERROR: Syntax error: Unexpected column list [at 1:24]
insert into T (c1, c2) (c3)
                       ^
==

# The resolver will fail on this because the target involves a generalized
# field access, but it does parse.
insert into T.(a.b).c VALUES (1)
--
InsertStatement [0-32] [insert into...VALUES (1)]
  DotIdentifier [12-21] [T.(a.b).c]
    DotGeneralizedField [12-19] [T.(a.b)]
      PathExpression [12-13] [T]
        Identifier(T) [12-13] [T]
      PathExpression [15-18] [a.b]
        Identifier(a) [15-16] [a]
        Identifier(b) [17-18] [b]
    Identifier(c) [20-21] [c]
  InsertValuesRowList [22-32] [VALUES (1)]
    InsertValuesRow [29-32] [(1)]
      IntLiteral(1) [30-31] [1]
--
INSERT INTO T.(a.b).c
VALUES
  (1)
==

# The resolver will fail on this because the target involves a generalized
# field access, but it does parse.
insert into T.a[0].b VALUES(1)
--
InsertStatement [0-30] [insert into T.a[0].b VALUES(1)]
  DotIdentifier [12-20] [T.a[0].b]
    ArrayElement [12-18] [T.a[0]]
      PathExpression [12-15] [T.a]
        Identifier(T) [12-13] [T]
        Identifier(a) [14-15] [a]
      Location [15-16] [[]
      IntLiteral(0) [16-17] [0]
    Identifier(b) [19-20] [b]
  InsertValuesRowList [21-30] [VALUES(1)]
    InsertValuesRow [27-30] [(1)]
      IntLiteral(1) [28-29] [1]
--
INSERT INTO T.a[0].b
VALUES
  (1)
==

update T
set x=y
--
UpdateStatement [0-16] [update T set x=y]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-16] [x=y]
    UpdateItem [13-16] [x=y]
      UpdateSetValue [13-16] [x=y]
        PathExpression [13-14] [x]
          Identifier(x) [13-14] [x]
        PathExpression [15-16] [y]
          Identifier(y) [15-16] [y]
--
UPDATE T
SET
  x = y
==

# The resolver will fail on this because WITH OFFSET is not allowed in
# top-level UPDATE statements, but it does parse.
update T with offset AS offset set x = y
--
UpdateStatement [0-40] [update T with...set x = y]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  WithOffset [9-30] [with offset AS offset]
    Alias [21-30] [AS offset]
      Identifier(offset) [24-30] [offset]
  UpdateItemList [35-40] [x = y]
    UpdateItem [35-40] [x = y]
      UpdateSetValue [35-40] [x = y]
        PathExpression [35-36] [x]
          Identifier(x) [35-36] [x]
        PathExpression [39-40] [y]
          Identifier(y) [39-40] [y]
--
UPDATE T WITH OFFSET AS offset
SET
  x = y
==

# The resolver will fail on this because the target involves a generalized
# field access, but it does parse.
update T.(a.b).c set x = y
--
UpdateStatement [0-26] [update T.(a.b).c set x = y]
  DotIdentifier [7-16] [T.(a.b).c]
    DotGeneralizedField [7-14] [T.(a.b)]
      PathExpression [7-8] [T]
        Identifier(T) [7-8] [T]
      PathExpression [10-13] [a.b]
        Identifier(a) [10-11] [a]
        Identifier(b) [12-13] [b]
    Identifier(c) [15-16] [c]
  UpdateItemList [21-26] [x = y]
    UpdateItem [21-26] [x = y]
      UpdateSetValue [21-26] [x = y]
        PathExpression [21-22] [x]
          Identifier(x) [21-22] [x]
        PathExpression [25-26] [y]
          Identifier(y) [25-26] [y]
--
UPDATE T.(a.b).c
SET
  x = y
==

# The resolver will fail on this because the target involves [], but it does
# parse.
update T.a[0].b set x = y
--
UpdateStatement [0-25] [update T.a[0].b set x = y]
  DotIdentifier [7-15] [T.a[0].b]
    ArrayElement [7-13] [T.a[0]]
      PathExpression [7-10] [T.a]
        Identifier(T) [7-8] [T]
        Identifier(a) [9-10] [a]
      Location [10-11] [[]
      IntLiteral(0) [11-12] [0]
    Identifier(b) [14-15] [b]
  UpdateItemList [20-25] [x = y]
    UpdateItem [20-25] [x = y]
      UpdateSetValue [20-25] [x = y]
        PathExpression [20-21] [x]
          Identifier(x) [20-21] [x]
        PathExpression [24-25] [y]
          Identifier(y) [24-25] [y]
--
UPDATE T.a[0].b
SET
  x = y
==

update T
set id.(path.to.extension) = 5
--
UpdateStatement [0-39] [update T set...extension) = 5]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-39] [id.(path.to.extension) = 5]
    UpdateItem [13-39] [id.(path.to.extension) = 5]
      UpdateSetValue [13-39] [id.(path.to.extension) = 5]
        DotGeneralizedField [13-35] [id.(path.to.extension)]
          PathExpression [13-15] [id]
            Identifier(id) [13-15] [id]
          PathExpression [17-34] [path.to.extension]
            Identifier(path) [17-21] [path]
            Identifier(`to`) [22-24] [to]
            Identifier(extension) [25-34] [extension]
        IntLiteral(5) [38-39] [5]
--
UPDATE T
SET
  id.(path.`to`.extension) = 5
==

update T
set id.(path.to.extension) = DEFAULT
--
UpdateStatement [0-45] [update T set...= DEFAULT]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-45] [id.(path.to...= DEFAULT]
    UpdateItem [13-45] [id.(path.to...= DEFAULT]
      UpdateSetValue [13-45] [id.(path.to...= DEFAULT]
        DotGeneralizedField [13-35] [id.(path.to.extension)]
          PathExpression [13-15] [id]
            Identifier(id) [13-15] [id]
          PathExpression [17-34] [path.to.extension]
            Identifier(path) [17-21] [path]
            Identifier(`to`) [22-24] [to]
            Identifier(extension) [25-34] [extension]
        DefaultLiteral [38-45] [DEFAULT]
--
UPDATE T
SET
  id.(path.`to`.extension) = DEFAULT
==

update T
set id[0] = DEFAULT
--
UpdateStatement [0-28] [update T set id[0] = DEFAULT]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-28] [id[0] = DEFAULT]
    UpdateItem [13-28] [id[0] = DEFAULT]
      UpdateSetValue [13-28] [id[0] = DEFAULT]
        ArrayElement [13-18] [id[0]]
          PathExpression [13-15] [id]
            Identifier(id) [13-15] [id]
          Location [15-16] [[]
          IntLiteral(0) [16-17] [0]
        DefaultLiteral [21-28] [DEFAULT]
--
UPDATE T
SET
  id[0] = DEFAULT
==

update T
set id1.id2.(path.to.extension) = 5
--
UpdateStatement [0-44] [update T set...extension) = 5]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-44] [id1.id2.(path...extension) = 5]
    UpdateItem [13-44] [id1.id2.(path...extension) = 5]
      UpdateSetValue [13-44] [id1.id2.(path...extension) = 5]
        DotGeneralizedField [13-40] [id1.id2.(path.to.extension)]
          PathExpression [13-20] [id1.id2]
            Identifier(id1) [13-16] [id1]
            Identifier(id2) [17-20] [id2]
          PathExpression [22-39] [path.to.extension]
            Identifier(path) [22-26] [path]
            Identifier(`to`) [27-29] [to]
            Identifier(extension) [30-39] [extension]
        IntLiteral(5) [43-44] [5]
--
UPDATE T
SET
  id1.id2.(path.`to`.extension) = 5
==

update T
set id1.(id2).(id3) = 5
--
UpdateStatement [0-32] [update T set....(id3) = 5]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-32] [id1.(id2).(id3) = 5]
    UpdateItem [13-32] [id1.(id2).(id3) = 5]
      UpdateSetValue [13-32] [id1.(id2).(id3) = 5]
        DotGeneralizedField [13-28] [id1.(id2).(id3)]
          DotGeneralizedField [13-22] [id1.(id2)]
            PathExpression [13-16] [id1]
              Identifier(id1) [13-16] [id1]
            PathExpression [18-21] [id2]
              Identifier(id2) [18-21] [id2]
          PathExpression [24-27] [id3]
            Identifier(id3) [24-27] [id3]
        IntLiteral(5) [31-32] [5]
--
UPDATE T
SET
  id1.(id2).(id3) = 5
==

update T
set id1.(a.b.c).(d.e.f).id2.(g.h.i).id3.id4 = 5
--
UpdateStatement [0-56] [update T set...id3.id4 = 5]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-56] [id1.(a.b.c...id3.id4 = 5]
    UpdateItem [13-56] [id1.(a.b.c...id3.id4 = 5]
      UpdateSetValue [13-56] [id1.(a.b.c...id3.id4 = 5]
        DotIdentifier [13-52] [id1.(a.b.c...i).id3.id4]
          DotIdentifier [13-48] [id1.(a.b.c...g.h.i).id3]
            DotGeneralizedField [13-44] [id1.(a.b.c...id2.(g.h.i)]
              DotIdentifier [13-36] [id1.(a.b.c).(d.e.f).id2]
                DotGeneralizedField [13-32] [id1.(a.b.c).(d.e.f)]
                  DotGeneralizedField [13-24] [id1.(a.b.c)]
                    PathExpression [13-16] [id1]
                      Identifier(id1) [13-16] [id1]
                    PathExpression [18-23] [a.b.c]
                      Identifier(a) [18-19] [a]
                      Identifier(b) [20-21] [b]
                      Identifier(c) [22-23] [c]
                  PathExpression [26-31] [d.e.f]
                    Identifier(d) [26-27] [d]
                    Identifier(e) [28-29] [e]
                    Identifier(f) [30-31] [f]
                Identifier(id2) [33-36] [id2]
              PathExpression [38-43] [g.h.i]
                Identifier(g) [38-39] [g]
                Identifier(h) [40-41] [h]
                Identifier(i) [42-43] [i]
            Identifier(id3) [45-48] [id3]
          Identifier(id4) [49-52] [id4]
        IntLiteral(5) [55-56] [5]
--
UPDATE T
SET
  id1.(a.b.c).(d.e.f).id2.(g.h.i).id3.id4 = 5
==

update T set id1[0] = 5
--
UpdateStatement [0-23] [update T set id1[0] = 5]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-23] [id1[0] = 5]
    UpdateItem [13-23] [id1[0] = 5]
      UpdateSetValue [13-23] [id1[0] = 5]
        ArrayElement [13-19] [id1[0]]
          PathExpression [13-16] [id1]
            Identifier(id1) [13-16] [id1]
          Location [16-17] [[]
          IntLiteral(0) [17-18] [0]
        IntLiteral(5) [22-23] [5]
--
UPDATE T
SET
  id1[0] = 5
==

update T set id1[0].(a.b.c).id1.(d.e.f)[1].id3 = 5
--
UpdateStatement [0-50] [update T set...1].id3 = 5]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-50] [id1[0].(a....1].id3 = 5]
    UpdateItem [13-50] [id1[0].(a....1].id3 = 5]
      UpdateSetValue [13-50] [id1[0].(a....1].id3 = 5]
        DotIdentifier [13-46] [id1[0].(a.....f)[1].id3]
          ArrayElement [13-42] [id1[0].(a.b.c).id1.(d.e.f)[1]]
            DotGeneralizedField [13-39] [id1[0].(a.b.c).id1.(d.e.f)]
              DotIdentifier [13-31] [id1[0].(a.b.c).id1]
                DotGeneralizedField [13-27] [id1[0].(a.b.c)]
                  ArrayElement [13-19] [id1[0]]
                    PathExpression [13-16] [id1]
                      Identifier(id1) [13-16] [id1]
                    Location [16-17] [[]
                    IntLiteral(0) [17-18] [0]
                  PathExpression [21-26] [a.b.c]
                    Identifier(a) [21-22] [a]
                    Identifier(b) [23-24] [b]
                    Identifier(c) [25-26] [c]
                Identifier(id1) [28-31] [id1]
              PathExpression [33-38] [d.e.f]
                Identifier(d) [33-34] [d]
                Identifier(e) [35-36] [e]
                Identifier(f) [37-38] [f]
            Location [39-40] [[]
            IntLiteral(1) [40-41] [1]
          Identifier(id3) [43-46] [id3]
        IntLiteral(5) [49-50] [5]
--
UPDATE T
SET
  id1[0].(a.b.c).id1.(d.e.f)[1].id3 = 5
==

# This parses, but in practice it will never resolve because ZetaSQL does not
# support arrays of arrays.
update T set id1[0][1] = 5
--
UpdateStatement [0-26] [update T set id1[0][1] = 5]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-26] [id1[0][1] = 5]
    UpdateItem [13-26] [id1[0][1] = 5]
      UpdateSetValue [13-26] [id1[0][1] = 5]
        ArrayElement [13-22] [id1[0][1]]
          ArrayElement [13-19] [id1[0]]
            PathExpression [13-16] [id1]
              Identifier(id1) [13-16] [id1]
            Location [16-17] [[]
            IntLiteral(0) [17-18] [0]
          Location [19-20] [[]
          IntLiteral(1) [20-21] [1]
        IntLiteral(5) [25-26] [5]
--
UPDATE T
SET
  id1[0][1] = 5
==

# We don't support parsing generalized paths that begin with a parenthesized
# component because it creates ambiguity in the grammar with nested INSERTS.
update T
set (a.b.c) = 5
--
ERROR: Syntax error: Expected keyword DELETE or keyword INSERT or keyword UPDATE but got identifier "a" [at 2:6]
set (a.b.c) = 5
     ^
==

update T
set (a.b.c)[0] = 5
--
ERROR: Syntax error: Expected keyword DELETE or keyword INSERT or keyword UPDATE but got identifier "a" [at 2:6]
set (a.b.c)[0] = 5
     ^
==

update T
set (a.b.c).d = 5
--
ERROR: Syntax error: Expected keyword DELETE or keyword INSERT or keyword UPDATE but got identifier "a" [at 2:6]
set (a.b.c).d = 5
     ^
==

update T
set (a.b.c).d[0] = 5
--
ERROR: Syntax error: Expected keyword DELETE or keyword INSERT or keyword UPDATE but got identifier "a" [at 2:6]
set (a.b.c).d[0] = 5
     ^
==

update T
--
ERROR: Syntax error: Unexpected end of statement [at 1:9]
update T
        ^
==

update c.T
set x=y, a.b.c=1+(select count(*) from t2)
where zzz+yyy=55
assert_rows_modified @row_count
--
UpdateStatement [0-102] [update c.T...@row_count]
  PathExpression [7-10] [c.T]
    Identifier(c) [7-8] [c]
    Identifier(T) [9-10] [T]
  UpdateItemList [15-53] [x=y, a.b.c...) from t2)]
    UpdateItem [15-18] [x=y]
      UpdateSetValue [15-18] [x=y]
        PathExpression [15-16] [x]
          Identifier(x) [15-16] [x]
        PathExpression [17-18] [y]
          Identifier(y) [17-18] [y]
    UpdateItem [20-53] [a.b.c=1+(select...) from t2)]
      UpdateSetValue [20-53] [a.b.c=1+(select...) from t2)]
        PathExpression [20-25] [a.b.c]
          Identifier(a) [20-21] [a]
          Identifier(b) [22-23] [b]
          Identifier(c) [24-25] [c]
        BinaryExpression(+) [26-53] [1+(select count(*) from t2)]
          IntLiteral(1) [26-27] [1]
          ExpressionSubquery [28-53] [(select count(*) from t2)]
            Query [29-52] [select count(*) from t2]
              Select [29-52] [select count(*) from t2]
                SelectList [36-44] [count(*)]
                  SelectColumn [36-44] [count(*)]
                    FunctionCall [36-44] [count(*)]
                      PathExpression [36-41] [count]
                        Identifier(count) [36-41] [count]
                      Star(*) [42-43] [*]
                FromClause [45-52] [from t2]
                  TablePathExpression [50-52] [t2]
                    PathExpression [50-52] [t2]
                      Identifier(t2) [50-52] [t2]
  BinaryExpression(=) [60-70] [zzz+yyy=55]
    BinaryExpression(+) [60-67] [zzz+yyy]
      PathExpression [60-63] [zzz]
        Identifier(zzz) [60-63] [zzz]
      PathExpression [64-67] [yyy]
        Identifier(yyy) [64-67] [yyy]
    IntLiteral(55) [68-70] [55]
  AssertRowsModified [71-102] [assert_rows_modif...@row_count]
    ParameterExpr [92-102] [@row_count]
      Identifier(row_count) [93-102] [row_count]
--
UPDATE c.T
SET
  x = y,
  a.b.c = 1 + (
    SELECT
      count(*)
    FROM
      t2
  )
WHERE
  zzz + yyy = 55
ASSERT_ROWS_MODIFIED @row_count
==

update T
where true
set x=y
--
ERROR: Syntax error: Unexpected keyword WHERE [at 2:1]
where true
^
==

update T
set x=null, y=default, z=z
--
UpdateStatement [0-35] [update T set...default, z=z]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-35] [x=null, y=default, z=z]
    UpdateItem [13-19] [x=null]
      UpdateSetValue [13-19] [x=null]
        PathExpression [13-14] [x]
          Identifier(x) [13-14] [x]
        NullLiteral(null) [15-19] [null]
    UpdateItem [21-30] [y=default]
      UpdateSetValue [21-30] [y=default]
        PathExpression [21-22] [y]
          Identifier(y) [21-22] [y]
        DefaultLiteral [23-30] [default]
    UpdateItem [32-35] [z=z]
      UpdateSetValue [32-35] [z=z]
        PathExpression [32-33] [z]
          Identifier(z) [32-33] [z]
        PathExpression [34-35] [z]
          Identifier(z) [34-35] [z]
--
UPDATE T
SET
  x = null,
  y = DEFAULT,
  z = z
==

update T
set x=default+1
--

ERROR: Syntax error: Expected end of input but got "+" [at 2:14]
set x=default+1
             ^
==

update T
set default=y
--
ERROR: Syntax error: Unexpected keyword DEFAULT [at 2:5]
set default=y
    ^
==

update T
where true
--
ERROR: Syntax error: Unexpected keyword WHERE [at 2:1]
where true
^
==

update T
set
where true
--
ERROR: Syntax error: Unexpected keyword WHERE [at 3:1]
where true
^
==

update T
set a=1
set b=2
--
ERROR: Syntax error: Expected end of input but got keyword SET [at 3:1]
set b=2
^
==

update T
set a=1,
set b=2
--
ERROR: Syntax error: Unexpected keyword SET [at 3:1]
set b=2
^
==

# Missing table name.  SET is a reserved keyword.
update set x=y
--
ERROR: Syntax error: Unexpected keyword SET [at 1:8]
update set x=y
       ^
==

# SET is a reserved keyword and cannot be used as a table name.
update Set
SET x=y
--
ERROR: Syntax error: Unexpected keyword SET [at 1:8]
update Set
       ^
==

# SET is a reserved keyword and cannot be used as a table alias.
update T SET
SET x=y
--
ERROR: Syntax error: Unexpected keyword SET [at 2:1]
SET x=y
^
==

# SET is a reserved keyword and cannot be used as an identifier.
update T SET set = 5
--
ERROR: Syntax error: Unexpected keyword SET [at 1:14]
update T SET set = 5
             ^
==

[no_test_get_parse_tokens]
[language_features={{|V_1_3_ALLOW_DASHES_IN_TABLE_NAME}}]
update a-100.b.c
set x=y
--
ALTERNATION GROUP: <empty>
--
ERROR: Syntax error: Table name contains '-' character. It needs to be quoted: `a-100.b.c` [at 1:8]
update a-100.b.c
       ^
--
ALTERNATION GROUP: V_1_3_ALLOW_DASHES_IN_TABLE_NAME
--
UpdateStatement [0-24] [update a-100.b.c set x=y]
  PathExpression [7-16] [a-100.b.c]
    Identifier(`a-100`) [7-14] [a-100.b]
    Identifier(b) [7-14] [a-100.b]
    Identifier(c) [15-16] [c]
  UpdateItemList [21-24] [x=y]
    UpdateItem [21-24] [x=y]
      UpdateSetValue [21-24] [x=y]
        PathExpression [21-22] [x]
          Identifier(x) [21-22] [x]
        PathExpression [23-24] [y]
          Identifier(y) [23-24] [y]
--
UPDATE `a-100`.b.c
SET
  x = y
==

# Delete statement with a table alias.
DELETE T {{AS|}} a
WHERE a.x=1
--
ALTERNATION GROUP: AS
--
DeleteStatement [0-25] [DELETE T AS a WHERE a.x=1]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Alias [9-13] [AS a]
    Identifier(a) [12-13] [a]
  BinaryExpression(=) [20-25] [a.x=1]
    PathExpression [20-23] [a.x]
      Identifier(a) [20-21] [a]
      Identifier(x) [22-23] [x]
    IntLiteral(1) [24-25] [1]
--
DELETE T AS a
WHERE
  a.x = 1
--
ALTERNATION GROUP: <empty>
--
DeleteStatement [0-23] [DELETE T  a WHERE a.x=1]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Alias [10-11] [a]
    Identifier(a) [10-11] [a]
  BinaryExpression(=) [18-23] [a.x=1]
    PathExpression [18-21] [a.x]
      Identifier(a) [18-19] [a]
      Identifier(x) [20-21] [x]
    IntLiteral(1) [22-23] [1]
--
DELETE T AS a
WHERE
  a.x = 1
==

# Update statement with a table alias.
UPDATE T {{AS|}} a SET a.x=1
--
ALTERNATION GROUP: AS
--
UpdateStatement [0-23] [UPDATE T AS a SET a.x=1]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Alias [9-13] [AS a]
    Identifier(a) [12-13] [a]
  UpdateItemList [18-23] [a.x=1]
    UpdateItem [18-23] [a.x=1]
      UpdateSetValue [18-23] [a.x=1]
        PathExpression [18-21] [a.x]
          Identifier(a) [18-19] [a]
          Identifier(x) [20-21] [x]
        IntLiteral(1) [22-23] [1]
--
UPDATE T AS a
SET
  a.x = 1
--
ALTERNATION GROUP: <empty>
--
UpdateStatement [0-21] [UPDATE T  a SET a.x=1]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Alias [10-11] [a]
    Identifier(a) [10-11] [a]
  UpdateItemList [16-21] [a.x=1]
    UpdateItem [16-21] [a.x=1]
      UpdateSetValue [16-21] [a.x=1]
        PathExpression [16-19] [a.x]
          Identifier(a) [16-17] [a]
          Identifier(x) [18-19] [x]
        IntLiteral(1) [20-21] [1]
--
UPDATE T AS a
SET
  a.x = 1
==

# Insert statement does not support table alias.
INSERT T {{AS|}} a VALUES (5)
--
ALTERNATION GROUP: AS
--
ERROR: Syntax error: Expecting VALUES list or query [at 1:9]
INSERT T AS a VALUES (5)
        ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Syntax error: INSERT target cannot have an alias [at 1:11]
INSERT T  a VALUES (5)
          ^
==

# Nested DML statements.
update T
set x=y,
    (delete x),
    (insert y.z values (5)),
    (update a set b=c),
    z=default
--
UpdateStatement [0-100] [update T set...z=default]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-100] [x=y,     (...z=default]
    UpdateItem [13-16] [x=y]
      UpdateSetValue [13-16] [x=y]
        PathExpression [13-14] [x]
          Identifier(x) [13-14] [x]
        PathExpression [15-16] [y]
          Identifier(y) [15-16] [y]
    UpdateItem [22-32] [(delete x)]
      DeleteStatement [23-31] [delete x]
        PathExpression [30-31] [x]
          Identifier(x) [30-31] [x]
    UpdateItem [38-61] [(insert y.z values (5))]
      InsertStatement [39-60] [insert y.z values (5)]
        PathExpression [46-49] [y.z]
          Identifier(y) [46-47] [y]
          Identifier(z) [48-49] [z]
        InsertValuesRowList [50-60] [values (5)]
          InsertValuesRow [57-60] [(5)]
            IntLiteral(5) [58-59] [5]
    UpdateItem [67-85] [(update a set b=c)]
      UpdateStatement [68-84] [update a set b=c]
        PathExpression [75-76] [a]
          Identifier(a) [75-76] [a]
        UpdateItemList [81-84] [b=c]
          UpdateItem [81-84] [b=c]
            UpdateSetValue [81-84] [b=c]
              PathExpression [81-82] [b]
                Identifier(b) [81-82] [b]
              PathExpression [83-84] [c]
                Identifier(c) [83-84] [c]
    UpdateItem [91-100] [z=default]
      UpdateSetValue [91-100] [z=default]
        PathExpression [91-92] [z]
          Identifier(z) [91-92] [z]
        DefaultLiteral [93-100] [default]
--
UPDATE T
SET
  x = y,
  (
    DELETE x
  ),
  (
    INSERT INTO y.z
    VALUES
      (5)
  ),
  (
    UPDATE a
    SET
      b = c
  ),
  z = DEFAULT
==

# Nested DML statements with generalized path targets.
update T
set (delete a.(b.c)),
    (insert d.(e.f) values (5)),
    (update a.(b.c) set d = 10)
--
UpdateStatement [0-95] [update T set...set d = 10)]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-95] [(delete a....set d = 10)]
    UpdateItem [13-29] [(delete a.(b.c))]
      DeleteStatement [14-28] [delete a.(b.c)]
        DotGeneralizedField [21-28] [a.(b.c)]
          PathExpression [21-22] [a]
            Identifier(a) [21-22] [a]
          PathExpression [24-27] [b.c]
            Identifier(b) [24-25] [b]
            Identifier(c) [26-27] [c]
    UpdateItem [35-62] [(insert d.(e.f) values (5))]
      InsertStatement [36-61] [insert d.(e.f) values (5)]
        DotGeneralizedField [43-50] [d.(e.f)]
          PathExpression [43-44] [d]
            Identifier(d) [43-44] [d]
          PathExpression [46-49] [e.f]
            Identifier(e) [46-47] [e]
            Identifier(f) [48-49] [f]
        InsertValuesRowList [51-61] [values (5)]
          InsertValuesRow [58-61] [(5)]
            IntLiteral(5) [59-60] [5]
    UpdateItem [68-95] [(update a.(b.c) set d = 10)]
      UpdateStatement [69-94] [update a.(b.c) set d = 10]
        DotGeneralizedField [76-83] [a.(b.c)]
          PathExpression [76-77] [a]
            Identifier(a) [76-77] [a]
          PathExpression [79-82] [b.c]
            Identifier(b) [79-80] [b]
            Identifier(c) [81-82] [c]
        UpdateItemList [88-94] [d = 10]
          UpdateItem [88-94] [d = 10]
            UpdateSetValue [88-94] [d = 10]
              PathExpression [88-89] [d]
                Identifier(d) [88-89] [d]
              IntLiteral(10) [92-94] [10]
--
UPDATE T
SET
  (
    DELETE a.(b.c)
  ),
  (
    INSERT INTO d.(e.f)
    VALUES
      (5)
  ),
  (
    UPDATE a.(b.c)
    SET
      d = 10
  )
==

# Another set of nested DML statements with generalized path targets, this time
# with a generalized field access in the middle.
update T
set (delete a.(b.c).x),
    (insert d.(e.f).y values (5)),
    (update a.(b.c).x set d = 10)
--
UpdateStatement [0-101] [update T set...set d = 10)]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-101] [(delete a....set d = 10)]
    UpdateItem [13-31] [(delete a.(b.c).x)]
      DeleteStatement [14-30] [delete a.(b.c).x]
        DotIdentifier [21-30] [a.(b.c).x]
          DotGeneralizedField [21-28] [a.(b.c)]
            PathExpression [21-22] [a]
              Identifier(a) [21-22] [a]
            PathExpression [24-27] [b.c]
              Identifier(b) [24-25] [b]
              Identifier(c) [26-27] [c]
          Identifier(x) [29-30] [x]
    UpdateItem [37-66] [(insert d.(e.f).y values (5))]
      InsertStatement [38-65] [insert d.(e.f).y values (5)]
        DotIdentifier [45-54] [d.(e.f).y]
          DotGeneralizedField [45-52] [d.(e.f)]
            PathExpression [45-46] [d]
              Identifier(d) [45-46] [d]
            PathExpression [48-51] [e.f]
              Identifier(e) [48-49] [e]
              Identifier(f) [50-51] [f]
          Identifier(y) [53-54] [y]
        InsertValuesRowList [55-65] [values (5)]
          InsertValuesRow [62-65] [(5)]
            IntLiteral(5) [63-64] [5]
    UpdateItem [72-101] [(update a.(b.c).x set d = 10)]
      UpdateStatement [73-100] [update a.(b.c).x set d = 10]
        DotIdentifier [80-89] [a.(b.c).x]
          DotGeneralizedField [80-87] [a.(b.c)]
            PathExpression [80-81] [a]
              Identifier(a) [80-81] [a]
            PathExpression [83-86] [b.c]
              Identifier(b) [83-84] [b]
              Identifier(c) [85-86] [c]
          Identifier(x) [88-89] [x]
        UpdateItemList [94-100] [d = 10]
          UpdateItem [94-100] [d = 10]
            UpdateSetValue [94-100] [d = 10]
              PathExpression [94-95] [d]
                Identifier(d) [94-95] [d]
              IntLiteral(10) [98-100] [10]
--
UPDATE T
SET
  (
    DELETE a.(b.c).x
  ),
  (
    INSERT INTO d.(e.f).y
    VALUES
      (5)
  ),
  (
    UPDATE a.(b.c).x
    SET
      d = 10
  )
==

# Nested DML statements with generalized path targets involving array element
# modifications. These parse but the resolver doesn't allow array element
# modifications in the targets of nested DML statements.
update T
set (delete a.(b.c)[0].d),
    (insert d.(e.f)[1] values (5)),
    (update a[2].(b.c) set d = 10)
--
UpdateStatement [0-106] [update T set...set d = 10)]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-106] [(delete a....set d = 10)]
    UpdateItem [13-34] [(delete a.(b.c)[0].d)]
      DeleteStatement [14-33] [delete a.(b.c)[0].d]
        DotIdentifier [21-33] [a.(b.c)[0].d]
          ArrayElement [21-31] [a.(b.c)[0]]
            DotGeneralizedField [21-28] [a.(b.c)]
              PathExpression [21-22] [a]
                Identifier(a) [21-22] [a]
              PathExpression [24-27] [b.c]
                Identifier(b) [24-25] [b]
                Identifier(c) [26-27] [c]
            Location [28-29] [[]
            IntLiteral(0) [29-30] [0]
          Identifier(d) [32-33] [d]
    UpdateItem [40-70] [(insert d.(e.f)[1] values (5))]
      InsertStatement [41-69] [insert d.(e.f)[1] values (5)]
        ArrayElement [48-58] [d.(e.f)[1]]
          DotGeneralizedField [48-55] [d.(e.f)]
            PathExpression [48-49] [d]
              Identifier(d) [48-49] [d]
            PathExpression [51-54] [e.f]
              Identifier(e) [51-52] [e]
              Identifier(f) [53-54] [f]
          Location [55-56] [[]
          IntLiteral(1) [56-57] [1]
        InsertValuesRowList [59-69] [values (5)]
          InsertValuesRow [66-69] [(5)]
            IntLiteral(5) [67-68] [5]
    UpdateItem [76-106] [(update a[2].(b.c) set d = 10)]
      UpdateStatement [77-105] [update a[2].(b.c) set d = 10]
        DotGeneralizedField [84-94] [a[2].(b.c)]
          ArrayElement [84-88] [a[2]]
            PathExpression [84-85] [a]
              Identifier(a) [84-85] [a]
            Location [85-86] [[]
            IntLiteral(2) [86-87] [2]
          PathExpression [90-93] [b.c]
            Identifier(b) [90-91] [b]
            Identifier(c) [92-93] [c]
        UpdateItemList [99-105] [d = 10]
          UpdateItem [99-105] [d = 10]
            UpdateSetValue [99-105] [d = 10]
              PathExpression [99-100] [d]
                Identifier(d) [99-100] [d]
              IntLiteral(10) [103-105] [10]
--
UPDATE T
SET
  (
    DELETE a.(b.c)[0].d
  ),
  (
    INSERT INTO d.(e.f)[1]
    VALUES
      (5)
  ),
  (
    UPDATE a[2].(b.c)
    SET
      d = 10
  )
==

# Nested DML statement with alias.
update T {{AS|}} a
set a.x=y,
    (delete a.x {{AS|}} na where na.x=1),
    (update a.x {{AS|}} na set na.x=1),
    (insert a.x values (5))
--
ALTERNATION GROUP: AS,AS,AS
--
UpdateStatement [0-124] [update T AS...values (5))]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Alias [9-13] [AS a]
    Identifier(a) [12-13] [a]
  UpdateItemList [18-124] [a.x=y,...values (5))]
    UpdateItem [18-23] [a.x=y]
      UpdateSetValue [18-23] [a.x=y]
        PathExpression [18-21] [a.x]
          Identifier(a) [18-19] [a]
          Identifier(x) [20-21] [x]
        PathExpression [22-23] [y]
          Identifier(y) [22-23] [y]
    UpdateItem [29-60] [(delete a....where na.x=1)]
      DeleteStatement [30-59] [delete a.x AS na where na.x=1]
        PathExpression [37-40] [a.x]
          Identifier(a) [37-38] [a]
          Identifier(x) [39-40] [x]
        Alias [41-46] [AS na]
          Identifier(na) [44-46] [na]
        BinaryExpression(=) [53-59] [na.x=1]
          PathExpression [53-57] [na.x]
            Identifier(na) [53-55] [na]
            Identifier(x) [56-57] [x]
          IntLiteral(1) [58-59] [1]
    UpdateItem [66-95] [(update a.x AS na set na.x=1)]
      UpdateStatement [67-94] [update a.x AS na set na.x=1]
        PathExpression [74-77] [a.x]
          Identifier(a) [74-75] [a]
          Identifier(x) [76-77] [x]
        Alias [78-83] [AS na]
          Identifier(na) [81-83] [na]
        UpdateItemList [88-94] [na.x=1]
          UpdateItem [88-94] [na.x=1]
            UpdateSetValue [88-94] [na.x=1]
              PathExpression [88-92] [na.x]
                Identifier(na) [88-90] [na]
                Identifier(x) [91-92] [x]
              IntLiteral(1) [93-94] [1]
    UpdateItem [101-124] [(insert a.x values (5))]
      InsertStatement [102-123] [insert a.x values (5)]
        PathExpression [109-112] [a.x]
          Identifier(a) [109-110] [a]
          Identifier(x) [111-112] [x]
        InsertValuesRowList [113-123] [values (5)]
          InsertValuesRow [120-123] [(5)]
            IntLiteral(5) [121-122] [5]
--
UPDATE T AS a
SET
  a.x = y,
  (
    DELETE a.x AS na
    WHERE
      na.x = 1
  ),
  (
    UPDATE a.x AS na
    SET
      na.x = 1
  ),
  (
    INSERT INTO a.x
    VALUES
      (5)
  )
--
ALTERNATION GROUP: AS,AS,
--
UpdateStatement [0-122] [update T AS...values (5))]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Alias [9-13] [AS a]
    Identifier(a) [12-13] [a]
  UpdateItemList [18-122] [a.x=y,...values (5))]
    UpdateItem [18-23] [a.x=y]
      UpdateSetValue [18-23] [a.x=y]
        PathExpression [18-21] [a.x]
          Identifier(a) [18-19] [a]
          Identifier(x) [20-21] [x]
        PathExpression [22-23] [y]
          Identifier(y) [22-23] [y]
    UpdateItem [29-60] [(delete a....where na.x=1)]
      DeleteStatement [30-59] [delete a.x AS na where na.x=1]
        PathExpression [37-40] [a.x]
          Identifier(a) [37-38] [a]
          Identifier(x) [39-40] [x]
        Alias [41-46] [AS na]
          Identifier(na) [44-46] [na]
        BinaryExpression(=) [53-59] [na.x=1]
          PathExpression [53-57] [na.x]
            Identifier(na) [53-55] [na]
            Identifier(x) [56-57] [x]
          IntLiteral(1) [58-59] [1]
    UpdateItem [66-93] [(update a.x  na set na.x=1)]
      UpdateStatement [67-92] [update a.x  na set na.x=1]
        PathExpression [74-77] [a.x]
          Identifier(a) [74-75] [a]
          Identifier(x) [76-77] [x]
        Alias [79-81] [na]
          Identifier(na) [79-81] [na]
        UpdateItemList [86-92] [na.x=1]
          UpdateItem [86-92] [na.x=1]
            UpdateSetValue [86-92] [na.x=1]
              PathExpression [86-90] [na.x]
                Identifier(na) [86-88] [na]
                Identifier(x) [89-90] [x]
              IntLiteral(1) [91-92] [1]
    UpdateItem [99-122] [(insert a.x values (5))]
      InsertStatement [100-121] [insert a.x values (5)]
        PathExpression [107-110] [a.x]
          Identifier(a) [107-108] [a]
          Identifier(x) [109-110] [x]
        InsertValuesRowList [111-121] [values (5)]
          InsertValuesRow [118-121] [(5)]
            IntLiteral(5) [119-120] [5]
--
UPDATE T AS a
SET
  a.x = y,
  (
    DELETE a.x AS na
    WHERE
      na.x = 1
  ),
  (
    UPDATE a.x AS na
    SET
      na.x = 1
  ),
  (
    INSERT INTO a.x
    VALUES
      (5)
  )
--
ALTERNATION GROUP: AS,,AS
--
UpdateStatement [0-122] [update T AS...values (5))]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Alias [9-13] [AS a]
    Identifier(a) [12-13] [a]
  UpdateItemList [18-122] [a.x=y,...values (5))]
    UpdateItem [18-23] [a.x=y]
      UpdateSetValue [18-23] [a.x=y]
        PathExpression [18-21] [a.x]
          Identifier(a) [18-19] [a]
          Identifier(x) [20-21] [x]
        PathExpression [22-23] [y]
          Identifier(y) [22-23] [y]
    UpdateItem [29-58] [(delete a.x  na where na.x=1)]
      DeleteStatement [30-57] [delete a.x  na where na.x=1]
        PathExpression [37-40] [a.x]
          Identifier(a) [37-38] [a]
          Identifier(x) [39-40] [x]
        Alias [42-44] [na]
          Identifier(na) [42-44] [na]
        BinaryExpression(=) [51-57] [na.x=1]
          PathExpression [51-55] [na.x]
            Identifier(na) [51-53] [na]
            Identifier(x) [54-55] [x]
          IntLiteral(1) [56-57] [1]
    UpdateItem [64-93] [(update a.x AS na set na.x=1)]
      UpdateStatement [65-92] [update a.x AS na set na.x=1]
        PathExpression [72-75] [a.x]
          Identifier(a) [72-73] [a]
          Identifier(x) [74-75] [x]
        Alias [76-81] [AS na]
          Identifier(na) [79-81] [na]
        UpdateItemList [86-92] [na.x=1]
          UpdateItem [86-92] [na.x=1]
            UpdateSetValue [86-92] [na.x=1]
              PathExpression [86-90] [na.x]
                Identifier(na) [86-88] [na]
                Identifier(x) [89-90] [x]
              IntLiteral(1) [91-92] [1]
    UpdateItem [99-122] [(insert a.x values (5))]
      InsertStatement [100-121] [insert a.x values (5)]
        PathExpression [107-110] [a.x]
          Identifier(a) [107-108] [a]
          Identifier(x) [109-110] [x]
        InsertValuesRowList [111-121] [values (5)]
          InsertValuesRow [118-121] [(5)]
            IntLiteral(5) [119-120] [5]
--
UPDATE T AS a
SET
  a.x = y,
  (
    DELETE a.x AS na
    WHERE
      na.x = 1
  ),
  (
    UPDATE a.x AS na
    SET
      na.x = 1
  ),
  (
    INSERT INTO a.x
    VALUES
      (5)
  )
--
ALTERNATION GROUP: AS,,
--
UpdateStatement [0-120] [update T AS...values (5))]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Alias [9-13] [AS a]
    Identifier(a) [12-13] [a]
  UpdateItemList [18-120] [a.x=y,...values (5))]
    UpdateItem [18-23] [a.x=y]
      UpdateSetValue [18-23] [a.x=y]
        PathExpression [18-21] [a.x]
          Identifier(a) [18-19] [a]
          Identifier(x) [20-21] [x]
        PathExpression [22-23] [y]
          Identifier(y) [22-23] [y]
    UpdateItem [29-58] [(delete a.x  na where na.x=1)]
      DeleteStatement [30-57] [delete a.x  na where na.x=1]
        PathExpression [37-40] [a.x]
          Identifier(a) [37-38] [a]
          Identifier(x) [39-40] [x]
        Alias [42-44] [na]
          Identifier(na) [42-44] [na]
        BinaryExpression(=) [51-57] [na.x=1]
          PathExpression [51-55] [na.x]
            Identifier(na) [51-53] [na]
            Identifier(x) [54-55] [x]
          IntLiteral(1) [56-57] [1]
    UpdateItem [64-91] [(update a.x  na set na.x=1)]
      UpdateStatement [65-90] [update a.x  na set na.x=1]
        PathExpression [72-75] [a.x]
          Identifier(a) [72-73] [a]
          Identifier(x) [74-75] [x]
        Alias [77-79] [na]
          Identifier(na) [77-79] [na]
        UpdateItemList [84-90] [na.x=1]
          UpdateItem [84-90] [na.x=1]
            UpdateSetValue [84-90] [na.x=1]
              PathExpression [84-88] [na.x]
                Identifier(na) [84-86] [na]
                Identifier(x) [87-88] [x]
              IntLiteral(1) [89-90] [1]
    UpdateItem [97-120] [(insert a.x values (5))]
      InsertStatement [98-119] [insert a.x values (5)]
        PathExpression [105-108] [a.x]
          Identifier(a) [105-106] [a]
          Identifier(x) [107-108] [x]
        InsertValuesRowList [109-119] [values (5)]
          InsertValuesRow [116-119] [(5)]
            IntLiteral(5) [117-118] [5]
--
UPDATE T AS a
SET
  a.x = y,
  (
    DELETE a.x AS na
    WHERE
      na.x = 1
  ),
  (
    UPDATE a.x AS na
    SET
      na.x = 1
  ),
  (
    INSERT INTO a.x
    VALUES
      (5)
  )
--
ALTERNATION GROUP: AS,AS
--
UpdateStatement [0-122] [update T...values (5))]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Alias [10-11] [a]
    Identifier(a) [10-11] [a]
  UpdateItemList [16-122] [a.x=y,...values (5))]
    UpdateItem [16-21] [a.x=y]
      UpdateSetValue [16-21] [a.x=y]
        PathExpression [16-19] [a.x]
          Identifier(a) [16-17] [a]
          Identifier(x) [18-19] [x]
        PathExpression [20-21] [y]
          Identifier(y) [20-21] [y]
    UpdateItem [27-58] [(delete a....where na.x=1)]
      DeleteStatement [28-57] [delete a.x AS na where na.x=1]
        PathExpression [35-38] [a.x]
          Identifier(a) [35-36] [a]
          Identifier(x) [37-38] [x]
        Alias [39-44] [AS na]
          Identifier(na) [42-44] [na]
        BinaryExpression(=) [51-57] [na.x=1]
          PathExpression [51-55] [na.x]
            Identifier(na) [51-53] [na]
            Identifier(x) [54-55] [x]
          IntLiteral(1) [56-57] [1]
    UpdateItem [64-93] [(update a.x AS na set na.x=1)]
      UpdateStatement [65-92] [update a.x AS na set na.x=1]
        PathExpression [72-75] [a.x]
          Identifier(a) [72-73] [a]
          Identifier(x) [74-75] [x]
        Alias [76-81] [AS na]
          Identifier(na) [79-81] [na]
        UpdateItemList [86-92] [na.x=1]
          UpdateItem [86-92] [na.x=1]
            UpdateSetValue [86-92] [na.x=1]
              PathExpression [86-90] [na.x]
                Identifier(na) [86-88] [na]
                Identifier(x) [89-90] [x]
              IntLiteral(1) [91-92] [1]
    UpdateItem [99-122] [(insert a.x values (5))]
      InsertStatement [100-121] [insert a.x values (5)]
        PathExpression [107-110] [a.x]
          Identifier(a) [107-108] [a]
          Identifier(x) [109-110] [x]
        InsertValuesRowList [111-121] [values (5)]
          InsertValuesRow [118-121] [(5)]
            IntLiteral(5) [119-120] [5]
--
UPDATE T AS a
SET
  a.x = y,
  (
    DELETE a.x AS na
    WHERE
      na.x = 1
  ),
  (
    UPDATE a.x AS na
    SET
      na.x = 1
  ),
  (
    INSERT INTO a.x
    VALUES
      (5)
  )
--
ALTERNATION GROUP: AS,
--
UpdateStatement [0-120] [update T...values (5))]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Alias [10-11] [a]
    Identifier(a) [10-11] [a]
  UpdateItemList [16-120] [a.x=y,...values (5))]
    UpdateItem [16-21] [a.x=y]
      UpdateSetValue [16-21] [a.x=y]
        PathExpression [16-19] [a.x]
          Identifier(a) [16-17] [a]
          Identifier(x) [18-19] [x]
        PathExpression [20-21] [y]
          Identifier(y) [20-21] [y]
    UpdateItem [27-58] [(delete a....where na.x=1)]
      DeleteStatement [28-57] [delete a.x AS na where na.x=1]
        PathExpression [35-38] [a.x]
          Identifier(a) [35-36] [a]
          Identifier(x) [37-38] [x]
        Alias [39-44] [AS na]
          Identifier(na) [42-44] [na]
        BinaryExpression(=) [51-57] [na.x=1]
          PathExpression [51-55] [na.x]
            Identifier(na) [51-53] [na]
            Identifier(x) [54-55] [x]
          IntLiteral(1) [56-57] [1]
    UpdateItem [64-91] [(update a.x  na set na.x=1)]
      UpdateStatement [65-90] [update a.x  na set na.x=1]
        PathExpression [72-75] [a.x]
          Identifier(a) [72-73] [a]
          Identifier(x) [74-75] [x]
        Alias [77-79] [na]
          Identifier(na) [77-79] [na]
        UpdateItemList [84-90] [na.x=1]
          UpdateItem [84-90] [na.x=1]
            UpdateSetValue [84-90] [na.x=1]
              PathExpression [84-88] [na.x]
                Identifier(na) [84-86] [na]
                Identifier(x) [87-88] [x]
              IntLiteral(1) [89-90] [1]
    UpdateItem [97-120] [(insert a.x values (5))]
      InsertStatement [98-119] [insert a.x values (5)]
        PathExpression [105-108] [a.x]
          Identifier(a) [105-106] [a]
          Identifier(x) [107-108] [x]
        InsertValuesRowList [109-119] [values (5)]
          InsertValuesRow [116-119] [(5)]
            IntLiteral(5) [117-118] [5]
--
UPDATE T AS a
SET
  a.x = y,
  (
    DELETE a.x AS na
    WHERE
      na.x = 1
  ),
  (
    UPDATE a.x AS na
    SET
      na.x = 1
  ),
  (
    INSERT INTO a.x
    VALUES
      (5)
  )
--
ALTERNATION GROUP: AS
--
UpdateStatement [0-120] [update T...values (5))]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Alias [10-11] [a]
    Identifier(a) [10-11] [a]
  UpdateItemList [16-120] [a.x=y,...values (5))]
    UpdateItem [16-21] [a.x=y]
      UpdateSetValue [16-21] [a.x=y]
        PathExpression [16-19] [a.x]
          Identifier(a) [16-17] [a]
          Identifier(x) [18-19] [x]
        PathExpression [20-21] [y]
          Identifier(y) [20-21] [y]
    UpdateItem [27-56] [(delete a.x  na where na.x=1)]
      DeleteStatement [28-55] [delete a.x  na where na.x=1]
        PathExpression [35-38] [a.x]
          Identifier(a) [35-36] [a]
          Identifier(x) [37-38] [x]
        Alias [40-42] [na]
          Identifier(na) [40-42] [na]
        BinaryExpression(=) [49-55] [na.x=1]
          PathExpression [49-53] [na.x]
            Identifier(na) [49-51] [na]
            Identifier(x) [52-53] [x]
          IntLiteral(1) [54-55] [1]
    UpdateItem [62-91] [(update a.x AS na set na.x=1)]
      UpdateStatement [63-90] [update a.x AS na set na.x=1]
        PathExpression [70-73] [a.x]
          Identifier(a) [70-71] [a]
          Identifier(x) [72-73] [x]
        Alias [74-79] [AS na]
          Identifier(na) [77-79] [na]
        UpdateItemList [84-90] [na.x=1]
          UpdateItem [84-90] [na.x=1]
            UpdateSetValue [84-90] [na.x=1]
              PathExpression [84-88] [na.x]
                Identifier(na) [84-86] [na]
                Identifier(x) [87-88] [x]
              IntLiteral(1) [89-90] [1]
    UpdateItem [97-120] [(insert a.x values (5))]
      InsertStatement [98-119] [insert a.x values (5)]
        PathExpression [105-108] [a.x]
          Identifier(a) [105-106] [a]
          Identifier(x) [107-108] [x]
        InsertValuesRowList [109-119] [values (5)]
          InsertValuesRow [116-119] [(5)]
            IntLiteral(5) [117-118] [5]
--
UPDATE T AS a
SET
  a.x = y,
  (
    DELETE a.x AS na
    WHERE
      na.x = 1
  ),
  (
    UPDATE a.x AS na
    SET
      na.x = 1
  ),
  (
    INSERT INTO a.x
    VALUES
      (5)
  )
--
ALTERNATION GROUP: <empty>
--
UpdateStatement [0-118] [update T...values (5))]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  Alias [10-11] [a]
    Identifier(a) [10-11] [a]
  UpdateItemList [16-118] [a.x=y,...values (5))]
    UpdateItem [16-21] [a.x=y]
      UpdateSetValue [16-21] [a.x=y]
        PathExpression [16-19] [a.x]
          Identifier(a) [16-17] [a]
          Identifier(x) [18-19] [x]
        PathExpression [20-21] [y]
          Identifier(y) [20-21] [y]
    UpdateItem [27-56] [(delete a.x  na where na.x=1)]
      DeleteStatement [28-55] [delete a.x  na where na.x=1]
        PathExpression [35-38] [a.x]
          Identifier(a) [35-36] [a]
          Identifier(x) [37-38] [x]
        Alias [40-42] [na]
          Identifier(na) [40-42] [na]
        BinaryExpression(=) [49-55] [na.x=1]
          PathExpression [49-53] [na.x]
            Identifier(na) [49-51] [na]
            Identifier(x) [52-53] [x]
          IntLiteral(1) [54-55] [1]
    UpdateItem [62-89] [(update a.x  na set na.x=1)]
      UpdateStatement [63-88] [update a.x  na set na.x=1]
        PathExpression [70-73] [a.x]
          Identifier(a) [70-71] [a]
          Identifier(x) [72-73] [x]
        Alias [75-77] [na]
          Identifier(na) [75-77] [na]
        UpdateItemList [82-88] [na.x=1]
          UpdateItem [82-88] [na.x=1]
            UpdateSetValue [82-88] [na.x=1]
              PathExpression [82-86] [na.x]
                Identifier(na) [82-84] [na]
                Identifier(x) [85-86] [x]
              IntLiteral(1) [87-88] [1]
    UpdateItem [95-118] [(insert a.x values (5))]
      InsertStatement [96-117] [insert a.x values (5)]
        PathExpression [103-106] [a.x]
          Identifier(a) [103-104] [a]
          Identifier(x) [105-106] [x]
        InsertValuesRowList [107-117] [values (5)]
          InsertValuesRow [114-117] [(5)]
            IntLiteral(5) [115-116] [5]
--
UPDATE T AS a
SET
  a.x = y,
  (
    DELETE a.x AS na
    WHERE
      na.x = 1
  ),
  (
    UPDATE a.x AS na
    SET
      na.x = 1
  ),
  (
    INSERT INTO a.x
    VALUES
      (5)
  )
==

# Nested insert statemnent does not support table alias.
update T a
set (insert a.x {{AS|}} na values (5))
--
ALTERNATION GROUP: AS
--
ERROR: Syntax error: Expecting VALUES list or query [at 2:16]
set (insert a.x AS na values (5))
               ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Syntax error: INSERT target cannot have an alias [at 2:18]
set (insert a.x  na values (5))
                 ^
==

# Nested update with offset.
update T set
  (update a with offset {{|as}} {{|offset|foo}}
   set x = y
   where offset = 0)
where true
--
ALTERNATION GROUP: <empty>
--
UpdateStatement [0-83] [update T set...where true]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [15-72] [(update a...offset = 0)]
    UpdateItem [15-72] [(update a...offset = 0)]
      UpdateStatement [16-71] [update a with...offset = 0]
        PathExpression [23-24] [a]
          Identifier(a) [23-24] [a]
        WithOffset [25-36] [with offset]
        UpdateItemList [46-51] [x = y]
          UpdateItem [46-51] [x = y]
            UpdateSetValue [46-51] [x = y]
              PathExpression [46-47] [x]
                Identifier(x) [46-47] [x]
              PathExpression [50-51] [y]
                Identifier(y) [50-51] [y]
        BinaryExpression(=) [61-71] [offset = 0]
          PathExpression [61-67] [offset]
            Identifier(offset) [61-67] [offset]
          IntLiteral(0) [70-71] [0]
  BooleanLiteral(true) [79-83] [true]
--
UPDATE T
SET
  (
    UPDATE a WITH OFFSET
    SET
      x = y
    WHERE
      offset = 0
  )
WHERE
  true
--
ALTERNATION GROUP: offset
--
UpdateStatement [0-89] [update T set...where true]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [15-78] [(update a...offset = 0)]
    UpdateItem [15-78] [(update a...offset = 0)]
      UpdateStatement [16-77] [update a with...offset = 0]
        PathExpression [23-24] [a]
          Identifier(a) [23-24] [a]
        WithOffset [25-44] [with offset  offset]
          Alias [38-44] [offset]
            Identifier(offset) [38-44] [offset]
        UpdateItemList [52-57] [x = y]
          UpdateItem [52-57] [x = y]
            UpdateSetValue [52-57] [x = y]
              PathExpression [52-53] [x]
                Identifier(x) [52-53] [x]
              PathExpression [56-57] [y]
                Identifier(y) [56-57] [y]
        BinaryExpression(=) [67-77] [offset = 0]
          PathExpression [67-73] [offset]
            Identifier(offset) [67-73] [offset]
          IntLiteral(0) [76-77] [0]
  BooleanLiteral(true) [85-89] [true]
--
UPDATE T
SET
  (
    UPDATE a WITH OFFSET AS offset
    SET
      x = y
    WHERE
      offset = 0
  )
WHERE
  true
--
ALTERNATION GROUP: foo
--
UpdateStatement [0-86] [update T set...where true]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [15-75] [(update a...offset = 0)]
    UpdateItem [15-75] [(update a...offset = 0)]
      UpdateStatement [16-74] [update a with...offset = 0]
        PathExpression [23-24] [a]
          Identifier(a) [23-24] [a]
        WithOffset [25-41] [with offset  foo]
          Alias [38-41] [foo]
            Identifier(foo) [38-41] [foo]
        UpdateItemList [49-54] [x = y]
          UpdateItem [49-54] [x = y]
            UpdateSetValue [49-54] [x = y]
              PathExpression [49-50] [x]
                Identifier(x) [49-50] [x]
              PathExpression [53-54] [y]
                Identifier(y) [53-54] [y]
        BinaryExpression(=) [64-74] [offset = 0]
          PathExpression [64-70] [offset]
            Identifier(offset) [64-70] [offset]
          IntLiteral(0) [73-74] [0]
  BooleanLiteral(true) [82-86] [true]
--
UPDATE T
SET
  (
    UPDATE a WITH OFFSET AS foo
    SET
      x = y
    WHERE
      offset = 0
  )
WHERE
  true
--
ALTERNATION GROUP: as,
--
ERROR: Syntax error: Unexpected keyword SET [at 3:4]
   set x = y
   ^
--
ALTERNATION GROUP: as,offset
--
UpdateStatement [0-91] [update T set...where true]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [15-80] [(update a...offset = 0)]
    UpdateItem [15-80] [(update a...offset = 0)]
      UpdateStatement [16-79] [update a with...offset = 0]
        PathExpression [23-24] [a]
          Identifier(a) [23-24] [a]
        WithOffset [25-46] [with offset as offset]
          Alias [37-46] [as offset]
            Identifier(offset) [40-46] [offset]
        UpdateItemList [54-59] [x = y]
          UpdateItem [54-59] [x = y]
            UpdateSetValue [54-59] [x = y]
              PathExpression [54-55] [x]
                Identifier(x) [54-55] [x]
              PathExpression [58-59] [y]
                Identifier(y) [58-59] [y]
        BinaryExpression(=) [69-79] [offset = 0]
          PathExpression [69-75] [offset]
            Identifier(offset) [69-75] [offset]
          IntLiteral(0) [78-79] [0]
  BooleanLiteral(true) [87-91] [true]
--
UPDATE T
SET
  (
    UPDATE a WITH OFFSET AS offset
    SET
      x = y
    WHERE
      offset = 0
  )
WHERE
  true
--
ALTERNATION GROUP: as,foo
--
UpdateStatement [0-88] [update T set...where true]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [15-77] [(update a...offset = 0)]
    UpdateItem [15-77] [(update a...offset = 0)]
      UpdateStatement [16-76] [update a with...offset = 0]
        PathExpression [23-24] [a]
          Identifier(a) [23-24] [a]
        WithOffset [25-43] [with offset as foo]
          Alias [37-43] [as foo]
            Identifier(foo) [40-43] [foo]
        UpdateItemList [51-56] [x = y]
          UpdateItem [51-56] [x = y]
            UpdateSetValue [51-56] [x = y]
              PathExpression [51-52] [x]
                Identifier(x) [51-52] [x]
              PathExpression [55-56] [y]
                Identifier(y) [55-56] [y]
        BinaryExpression(=) [66-76] [offset = 0]
          PathExpression [66-72] [offset]
            Identifier(offset) [66-72] [offset]
          IntLiteral(0) [75-76] [0]
  BooleanLiteral(true) [84-88] [true]
--
UPDATE T
SET
  (
    UPDATE a WITH OFFSET AS foo
    SET
      x = y
    WHERE
      offset = 0
  )
WHERE
  true
==

# Nested delete with offset.
update T set
  (delete a with offset {{|as}} {{|offset|foo}} where true)
where true
--
ALTERNATION GROUP: <empty>
--
UpdateStatement [0-61] [update T set...where true]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [15-50] [(delete a...where true)]
    UpdateItem [15-50] [(delete a...where true)]
      DeleteStatement [16-49] [delete a with...where true]
        PathExpression [23-24] [a]
          Identifier(a) [23-24] [a]
        WithOffset [25-36] [with offset]
        BooleanLiteral(true) [45-49] [true]
  BooleanLiteral(true) [57-61] [true]
--
UPDATE T
SET
  (
    DELETE a WITH OFFSET
    WHERE
      true
  )
WHERE
  true
--
ALTERNATION GROUP: offset
--
UpdateStatement [0-67] [update T set...where true]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [15-56] [(delete a...where true)]
    UpdateItem [15-56] [(delete a...where true)]
      DeleteStatement [16-55] [delete a with...where true]
        PathExpression [23-24] [a]
          Identifier(a) [23-24] [a]
        WithOffset [25-44] [with offset  offset]
          Alias [38-44] [offset]
            Identifier(offset) [38-44] [offset]
        BooleanLiteral(true) [51-55] [true]
  BooleanLiteral(true) [63-67] [true]
--
UPDATE T
SET
  (
    DELETE a WITH OFFSET AS offset
    WHERE
      true
  )
WHERE
  true
--
ALTERNATION GROUP: foo
--
UpdateStatement [0-64] [update T set...where true]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [15-53] [(delete a...where true)]
    UpdateItem [15-53] [(delete a...where true)]
      DeleteStatement [16-52] [delete a with...where true]
        PathExpression [23-24] [a]
          Identifier(a) [23-24] [a]
        WithOffset [25-41] [with offset  foo]
          Alias [38-41] [foo]
            Identifier(foo) [38-41] [foo]
        BooleanLiteral(true) [48-52] [true]
  BooleanLiteral(true) [60-64] [true]
--
UPDATE T
SET
  (
    DELETE a WITH OFFSET AS foo
    WHERE
      true
  )
WHERE
  true
--
ALTERNATION GROUP: as,
--
ERROR: Syntax error: Unexpected keyword WHERE [at 2:29]
  (delete a with offset as  where true)
                            ^
--
ALTERNATION GROUP: as,offset
--
UpdateStatement [0-69] [update T set...where true]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [15-58] [(delete a...where true)]
    UpdateItem [15-58] [(delete a...where true)]
      DeleteStatement [16-57] [delete a with...where true]
        PathExpression [23-24] [a]
          Identifier(a) [23-24] [a]
        WithOffset [25-46] [with offset as offset]
          Alias [37-46] [as offset]
            Identifier(offset) [40-46] [offset]
        BooleanLiteral(true) [53-57] [true]
  BooleanLiteral(true) [65-69] [true]
--
UPDATE T
SET
  (
    DELETE a WITH OFFSET AS offset
    WHERE
      true
  )
WHERE
  true
--
ALTERNATION GROUP: as,foo
--
UpdateStatement [0-66] [update T set...where true]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [15-55] [(delete a...where true)]
    UpdateItem [15-55] [(delete a...where true)]
      DeleteStatement [16-54] [delete a with...where true]
        PathExpression [23-24] [a]
          Identifier(a) [23-24] [a]
        WithOffset [25-43] [with offset as foo]
          Alias [37-43] [as foo]
            Identifier(foo) [40-43] [foo]
        BooleanLiteral(true) [50-54] [true]
  BooleanLiteral(true) [62-66] [true]
--
UPDATE T
SET
  (
    DELETE a WITH OFFSET AS foo
    WHERE
      true
  )
WHERE
  true
==

# Multiple levels of nested UPDATEs.
update T
set (update c1.c2
     set (update c3
          set (delete from c4
               where false
               assert_rows_modified 5)
          where true
          assert_rows_modified 4)
     where false
     assert_rows_modified 3)
where true
assert_rows_modified 2
--
UpdateStatement [0-277] [update T set...rows_modified 2]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-243] [(update c1..._rows_modified 3)]
    UpdateItem [13-243] [(update c1..._rows_modified 3)]
      UpdateStatement [14-242] [update c1....t_rows_modified 3]
        PathExpression [21-26] [c1.c2]
          Identifier(c1) [21-23] [c1]
          Identifier(c2) [24-26] [c2]
        UpdateItemList [36-197] [(update c3..._rows_modified 4)]
          UpdateItem [36-197] [(update c3..._rows_modified 4)]
            UpdateStatement [37-196] [update c3...rt_rows_modified 4]
              PathExpression [44-46] [c3]
                Identifier(c3) [44-46] [c3]
              UpdateItemList [61-142] [(delete from...ows_modified 5)]
                UpdateItem [61-142] [(delete from...ows_modified 5)]
                  DeleteStatement [62-141] [delete from..._rows_modified 5]
                    PathExpression [74-76] [c4]
                      Identifier(c4) [74-76] [c4]
                    BooleanLiteral(false) [98-103] [false]
                    AssertRowsModified [119-141] [assert_rows_modified 5]
                      IntLiteral(5) [140-141] [5]
              BooleanLiteral(true) [159-163] [true]
              AssertRowsModified [174-196] [assert_rows_modified 4]
                IntLiteral(4) [195-196] [4]
        BooleanLiteral(false) [209-214] [false]
        AssertRowsModified [220-242] [assert_rows_modified 3]
          IntLiteral(3) [241-242] [3]
  BooleanLiteral(true) [250-254] [true]
  AssertRowsModified [255-277] [assert_rows_modified 2]
    IntLiteral(2) [276-277] [2]
--
UPDATE T
SET
  (
    UPDATE c1.c2
    SET
      (
        UPDATE c3
        SET
          (
            DELETE c4
            WHERE
              false
            ASSERT_ROWS_MODIFIED 5
          )
        WHERE
          true
        ASSERT_ROWS_MODIFIED 4
      )
    WHERE
      false
    ASSERT_ROWS_MODIFIED 3
  )
WHERE
  true
ASSERT_ROWS_MODIFIED 2
==

# Hints work on outer statements but not inner.  (We could add this.)
@{a=b} delete from t1
--
HintedStatement [0-21] [@{a=b} delete from t1]
  Hint [0-6] [@{a=b}]
    HintEntry [2-5] [a=b]
      Identifier(a) [2-3] [a]
      PathExpression [4-5] [b]
        Identifier(b) [4-5] [b]
  DeleteStatement [7-21] [delete from t1]
    PathExpression [19-21] [t1]
      Identifier(t1) [19-21] [t1]
--
@{ a = b }
DELETE t1
==

@{c=d} update t1
       set (       delete from t2),
           (@{e=f} delete from t3)
--
ERROR: Syntax error: Expected keyword DELETE or keyword INSERT or keyword UPDATE but got "@" [at 3:13]
           (@{e=f} delete from t3)
            ^
==

@{a=b} insert into t1 values (null)
--
HintedStatement [0-35] [@{a=b} insert...values (null)]
  Hint [0-6] [@{a=b}]
    HintEntry [2-5] [a=b]
      Identifier(a) [2-3] [a]
      PathExpression [4-5] [b]
        Identifier(b) [4-5] [b]
  InsertStatement [7-35] [insert into t1 values (null)]
    PathExpression [19-21] [t1]
      Identifier(t1) [19-21] [t1]
    InsertValuesRowList [22-35] [values (null)]
      InsertValuesRow [29-35] [(null)]
        NullLiteral(null) [30-34] [null]
--
@{ a = b }
INSERT INTO t1
VALUES
  (null)
==

[no_test_get_parse_tokens]
[language_features={{|V_1_3_ALLOW_DASHES_IN_TABLE_NAME}}]
insert into project-987654321.a.b values (1)
--
ALTERNATION GROUP: <empty>
--
ERROR: Syntax error: Table name contains '-' character. It needs to be quoted: `project-987654321.a.b` [at 1:13]
insert into project-987654321.a.b values (1)
            ^
--
ALTERNATION GROUP: V_1_3_ALLOW_DASHES_IN_TABLE_NAME
--
InsertStatement [0-44] [insert into...values (1)]
  PathExpression [12-33] [project-987654321.a.b]
    Identifier(`project-987654321`) [12-31] [project-987654321.a]
    Identifier(a) [12-31] [project-987654321.a]
    Identifier(b) [32-33] [b]
  InsertValuesRowList [34-44] [values (1)]
    InsertValuesRow [41-44] [(1)]
      IntLiteral(1) [42-43] [1]
--
INSERT INTO `project-987654321`.a.b
VALUES
  (1)
==

UPDATE T
SET x = T1.y
FROM T1
WHERE T.a = T1.b
--
UpdateStatement [0-46] [UPDATE T SET...T.a = T1.b]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-21] [x = T1.y]
    UpdateItem [13-21] [x = T1.y]
      UpdateSetValue [13-21] [x = T1.y]
        PathExpression [13-14] [x]
          Identifier(x) [13-14] [x]
        PathExpression [17-21] [T1.y]
          Identifier(T1) [17-19] [T1]
          Identifier(y) [20-21] [y]
  FromClause [22-29] [FROM T1]
    TablePathExpression [27-29] [T1]
      PathExpression [27-29] [T1]
        Identifier(T1) [27-29] [T1]
  BinaryExpression(=) [36-46] [T.a = T1.b]
    PathExpression [36-39] [T.a]
      Identifier(T) [36-37] [T]
      Identifier(a) [38-39] [a]
    PathExpression [42-46] [T1.b]
      Identifier(T1) [42-44] [T1]
      Identifier(b) [45-46] [b]
--
UPDATE T
SET
  x = T1.y
FROM
  T1
WHERE
  T.a = T1.b
==

UPDATE T
SET x = T2.c
FROM T1 JOIN T2 ON T1.x = T2.y
WHERE T.a < T1.b
--
UpdateStatement [0-69] [UPDATE T SET...T.a < T1.b]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-21] [x = T2.c]
    UpdateItem [13-21] [x = T2.c]
      UpdateSetValue [13-21] [x = T2.c]
        PathExpression [13-14] [x]
          Identifier(x) [13-14] [x]
        PathExpression [17-21] [T2.c]
          Identifier(T2) [17-19] [T2]
          Identifier(c) [20-21] [c]
  FromClause [22-52] [FROM T1 JOIN T2 ON T1.x = T2.y]
    Join [27-52] [T1 JOIN T2 ON T1.x = T2.y]
      TablePathExpression [27-29] [T1]
        PathExpression [27-29] [T1]
          Identifier(T1) [27-29] [T1]
      Location [30-34] [JOIN]
      TablePathExpression [35-37] [T2]
        PathExpression [35-37] [T2]
          Identifier(T2) [35-37] [T2]
      OnClause [38-52] [ON T1.x = T2.y]
        BinaryExpression(=) [41-52] [T1.x = T2.y]
          PathExpression [41-45] [T1.x]
            Identifier(T1) [41-43] [T1]
            Identifier(x) [44-45] [x]
          PathExpression [48-52] [T2.y]
            Identifier(T2) [48-50] [T2]
            Identifier(y) [51-52] [y]
  BinaryExpression(<) [59-69] [T.a < T1.b]
    PathExpression [59-62] [T.a]
      Identifier(T) [59-60] [T]
      Identifier(a) [61-62] [a]
    PathExpression [65-69] [T1.b]
      Identifier(T1) [65-67] [T1]
      Identifier(b) [68-69] [b]
--
UPDATE T
SET
  x = T2.c
FROM
  T1
  JOIN
  T2
  ON T1.x = T2.y
WHERE
  T.a < T1.b
==

UPDATE T
SET x = T2.c
FROM T1, T2
WHERE T.a < T1.b
--
UpdateStatement [0-50] [UPDATE T SET...T.a < T1.b]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-21] [x = T2.c]
    UpdateItem [13-21] [x = T2.c]
      UpdateSetValue [13-21] [x = T2.c]
        PathExpression [13-14] [x]
          Identifier(x) [13-14] [x]
        PathExpression [17-21] [T2.c]
          Identifier(T2) [17-19] [T2]
          Identifier(c) [20-21] [c]
  FromClause [22-33] [FROM T1, T2]
    Join(COMMA) [27-33] [T1, T2]
      TablePathExpression [27-29] [T1]
        PathExpression [27-29] [T1]
          Identifier(T1) [27-29] [T1]
      Location [29-30] [,]
      TablePathExpression [31-33] [T2]
        PathExpression [31-33] [T2]
          Identifier(T2) [31-33] [T2]
  BinaryExpression(<) [40-50] [T.a < T1.b]
    PathExpression [40-43] [T.a]
      Identifier(T) [40-41] [T]
      Identifier(a) [42-43] [a]
    PathExpression [46-50] [T1.b]
      Identifier(T1) [46-48] [T1]
      Identifier(b) [49-50] [b]
--
UPDATE T
SET
  x = T2.c
FROM
  T1,
  T2
WHERE
  T.a < T1.b
==

UPDATE T SET x = 1
FROM (T1 JOIN T2) JOIN T3
WHERE true
--
UpdateStatement [0-55] [UPDATE T SET...WHERE true]
  PathExpression [7-8] [T]
    Identifier(T) [7-8] [T]
  UpdateItemList [13-18] [x = 1]
    UpdateItem [13-18] [x = 1]
      UpdateSetValue [13-18] [x = 1]
        PathExpression [13-14] [x]
          Identifier(x) [13-14] [x]
        IntLiteral(1) [17-18] [1]
  FromClause [19-44] [FROM (T1 JOIN T2) JOIN T3]
    Join [24-44] [(T1 JOIN T2) JOIN T3]
      ParenthesizedJoin [24-36] [(T1 JOIN T2)]
        Join [25-35] [T1 JOIN T2]
          TablePathExpression [25-27] [T1]
            PathExpression [25-27] [T1]
              Identifier(T1) [25-27] [T1]
          Location [28-32] [JOIN]
          TablePathExpression [33-35] [T2]
            PathExpression [33-35] [T2]
              Identifier(T2) [33-35] [T2]
      Location [37-41] [JOIN]
      TablePathExpression [42-44] [T3]
        PathExpression [42-44] [T3]
          Identifier(T3) [42-44] [T3]
  BooleanLiteral(true) [51-55] [true]
--
UPDATE T
SET
  x = 1
FROM
  (
    T1
    JOIN
    T2
  )
  JOIN
  T3
WHERE
  true

==

# Only has WHEN MATCHED clause
MERGE INTO T
USING S
ON t1 = s1
WHEN MATCHED AND T.T1 = 5 THEN
UPDATE SET T1 = T1 + 10, T2 = T.T1 + S.C1
--
MergeStatement [0-104] [MERGE INTO....T1 + S.C1]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-104] [WHEN MATCHED....T1 + S.C1]
    MergeWhenClause(match_type=MATCHED) [32-104] [WHEN MATCHED....T1 + S.C1]
      BinaryExpression(=) [49-57] [T.T1 = 5]
        PathExpression [49-53] [T.T1]
          Identifier(T) [49-50] [T]
          Identifier(T1) [51-53] [T1]
        IntLiteral(5) [56-57] [5]
      MergeAction(UPDATE) [63-104] [UPDATE SET....T1 + S.C1]
        UpdateItemList [74-104] [T1 = T1 + 10, T2 = T.T1 + S.C1]
          UpdateItem [74-86] [T1 = T1 + 10]
            UpdateSetValue [74-86] [T1 = T1 + 10]
              PathExpression [74-76] [T1]
                Identifier(T1) [74-76] [T1]
              BinaryExpression(+) [79-86] [T1 + 10]
                PathExpression [79-81] [T1]
                  Identifier(T1) [79-81] [T1]
                IntLiteral(10) [84-86] [10]
          UpdateItem [88-104] [T2 = T.T1 + S.C1]
            UpdateSetValue [88-104] [T2 = T.T1 + S.C1]
              PathExpression [88-90] [T2]
                Identifier(T2) [88-90] [T2]
              BinaryExpression(+) [93-104] [T.T1 + S.C1]
                PathExpression [93-97] [T.T1]
                  Identifier(T) [93-94] [T]
                  Identifier(T1) [95-97] [T1]
                PathExpression [100-104] [S.C1]
                  Identifier(S) [100-101] [S]
                  Identifier(C1) [102-104] [C1]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN MATCHED AND T.T1 = 5 THEN
  UPDATE
  SET
    T1 = T1 + 10,
    T2 = T.T1 + S.C1
==

# Verify that we can use generalized paths with SET
MERGE INTO T
USING S
ON t1 = s1
WHEN MATCHED AND T.T1 = 5 THEN
UPDATE SET T1.(foo.bar) = T1.(foo.bar) + 10, T2 = T.T1 + S.C1
--
MergeStatement [0-124] [MERGE INTO....T1 + S.C1]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-124] [WHEN MATCHED....T1 + S.C1]
    MergeWhenClause(match_type=MATCHED) [32-124] [WHEN MATCHED....T1 + S.C1]
      BinaryExpression(=) [49-57] [T.T1 = 5]
        PathExpression [49-53] [T.T1]
          Identifier(T) [49-50] [T]
          Identifier(T1) [51-53] [T1]
        IntLiteral(5) [56-57] [5]
      MergeAction(UPDATE) [63-124] [UPDATE SET....T1 + S.C1]
        UpdateItemList [74-124] [T1.(foo.bar....T1 + S.C1]
          UpdateItem [74-106] [T1.(foo.bar....bar) + 10]
            UpdateSetValue [74-106] [T1.(foo.bar....bar) + 10]
              DotGeneralizedField [74-86] [T1.(foo.bar)]
                PathExpression [74-76] [T1]
                  Identifier(T1) [74-76] [T1]
                PathExpression [78-85] [foo.bar]
                  Identifier(foo) [78-81] [foo]
                  Identifier(bar) [82-85] [bar]
              BinaryExpression(+) [89-106] [T1.(foo.bar) + 10]
                DotGeneralizedField [89-101] [T1.(foo.bar)]
                  PathExpression [89-91] [T1]
                    Identifier(T1) [89-91] [T1]
                  PathExpression [93-100] [foo.bar]
                    Identifier(foo) [93-96] [foo]
                    Identifier(bar) [97-100] [bar]
                IntLiteral(10) [104-106] [10]
          UpdateItem [108-124] [T2 = T.T1 + S.C1]
            UpdateSetValue [108-124] [T2 = T.T1 + S.C1]
              PathExpression [108-110] [T2]
                Identifier(T2) [108-110] [T2]
              BinaryExpression(+) [113-124] [T.T1 + S.C1]
                PathExpression [113-117] [T.T1]
                  Identifier(T) [113-114] [T]
                  Identifier(T1) [115-117] [T1]
                PathExpression [120-124] [S.C1]
                  Identifier(S) [120-121] [S]
                  Identifier(C1) [122-124] [C1]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN MATCHED AND T.T1 = 5 THEN
  UPDATE
  SET
    T1.(foo.bar) = T1.(foo.bar) + 10,
    T2 = T.T1 + S.C1
==

# Only has (implicit) NOT MATCHED BY TARGET clause
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED THEN
INSERT(t1, t2, t3) VALUES(10, S.C3, S.C1 + S.C2)
--
MergeStatement [0-102] [MERGE INTO...C1 + S.C2)]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-102] [WHEN NOT MATCHED...C1 + S.C2)]
    MergeWhenClause(match_type=NOT_MATCHED_BY_TARGET) [32-102] [WHEN NOT MATCHED...C1 + S.C2)]
      MergeAction(INSERT) [54-102] [INSERT(t1,...C1 + S.C2)]
        ColumnList [60-72] [(t1, t2, t3)]
          Identifier(t1) [61-63] [t1]
          Identifier(t2) [65-67] [t2]
          Identifier(t3) [69-71] [t3]
        InsertValuesRow [79-102] [(10, S.C3, S.C1 + S.C2)]
          IntLiteral(10) [80-82] [10]
          PathExpression [84-88] [S.C3]
            Identifier(S) [84-85] [S]
            Identifier(C3) [86-88] [C3]
          BinaryExpression(+) [90-101] [S.C1 + S.C2]
            PathExpression [90-94] [S.C1]
              Identifier(S) [90-91] [S]
              Identifier(C1) [92-94] [C1]
            PathExpression [97-101] [S.C2]
              Identifier(S) [97-98] [S]
              Identifier(C2) [99-101] [C2]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY TARGET THEN
  INSERT(t1, t2, t3)
  VALUES
    (10, S.C3, S.C1 + S.C2)
==

# Only has NOT MATCHED BY SOURCE clause
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY SOURCE THEN
DELETE
--
MergeStatement [0-70] [MERGE INTO...THEN DELETE]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-70] [WHEN NOT MATCHED...THEN DELETE]
    MergeWhenClause(match_type=NOT_MATCHED_BY_SOURCE) [32-70] [WHEN NOT MATCHED...THEN DELETE]
      MergeAction(DELETE) [64-70] [DELETE]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY SOURCE THEN
  DELETE
==

# Has MATCHED & NOT MATCHED BY TARGET clauses.
MERGE INTO T
USING S
ON t1 = s1
WHEN MATCHED AND T.T1 = 5 THEN
UPDATE SET T1 = T1 + 10, T2 = T.T1 + S.C1
WHEN NOT MATCHED THEN
INSERT(t1, t2, t3) VALUES(10, S.C3, S.C1 + S.C2)
--
MergeStatement [0-175] [MERGE INTO...C1 + S.C2)]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-175] [WHEN MATCHED...C1 + S.C2)]
    MergeWhenClause(match_type=MATCHED) [32-104] [WHEN MATCHED....T1 + S.C1]
      BinaryExpression(=) [49-57] [T.T1 = 5]
        PathExpression [49-53] [T.T1]
          Identifier(T) [49-50] [T]
          Identifier(T1) [51-53] [T1]
        IntLiteral(5) [56-57] [5]
      MergeAction(UPDATE) [63-104] [UPDATE SET....T1 + S.C1]
        UpdateItemList [74-104] [T1 = T1 + 10, T2 = T.T1 + S.C1]
          UpdateItem [74-86] [T1 = T1 + 10]
            UpdateSetValue [74-86] [T1 = T1 + 10]
              PathExpression [74-76] [T1]
                Identifier(T1) [74-76] [T1]
              BinaryExpression(+) [79-86] [T1 + 10]
                PathExpression [79-81] [T1]
                  Identifier(T1) [79-81] [T1]
                IntLiteral(10) [84-86] [10]
          UpdateItem [88-104] [T2 = T.T1 + S.C1]
            UpdateSetValue [88-104] [T2 = T.T1 + S.C1]
              PathExpression [88-90] [T2]
                Identifier(T2) [88-90] [T2]
              BinaryExpression(+) [93-104] [T.T1 + S.C1]
                PathExpression [93-97] [T.T1]
                  Identifier(T) [93-94] [T]
                  Identifier(T1) [95-97] [T1]
                PathExpression [100-104] [S.C1]
                  Identifier(S) [100-101] [S]
                  Identifier(C1) [102-104] [C1]
    MergeWhenClause(match_type=NOT_MATCHED_BY_TARGET) [105-175] [WHEN NOT MATCHED...C1 + S.C2)]
      MergeAction(INSERT) [127-175] [INSERT(t1,...C1 + S.C2)]
        ColumnList [133-145] [(t1, t2, t3)]
          Identifier(t1) [134-136] [t1]
          Identifier(t2) [138-140] [t2]
          Identifier(t3) [142-144] [t3]
        InsertValuesRow [152-175] [(10, S.C3, S.C1 + S.C2)]
          IntLiteral(10) [153-155] [10]
          PathExpression [157-161] [S.C3]
            Identifier(S) [157-158] [S]
            Identifier(C3) [159-161] [C3]
          BinaryExpression(+) [163-174] [S.C1 + S.C2]
            PathExpression [163-167] [S.C1]
              Identifier(S) [163-164] [S]
              Identifier(C1) [165-167] [C1]
            PathExpression [170-174] [S.C2]
              Identifier(S) [170-171] [S]
              Identifier(C2) [172-174] [C2]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN MATCHED AND T.T1 = 5 THEN
  UPDATE
  SET
    T1 = T1 + 10,
    T2 = T.T1 + S.C1
WHEN NOT MATCHED BY TARGET THEN
  INSERT(t1, t2, t3)
  VALUES
    (10, S.C3, S.C1 + S.C2)
==

# Has MATCHED & NOT MATCHED BY SOURCE clauses.
MERGE INTO T
USING S
ON t1 = s1
WHEN MATCHED AND T.T1 = 5 THEN
UPDATE SET T1 = T1 + 10, T2 = T.T1 + S.C1
WHEN NOT MATCHED BY SOURCE THEN
DELETE
--
MergeStatement [0-143] [MERGE INTO...THEN DELETE]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-143] [WHEN MATCHED...THEN DELETE]
    MergeWhenClause(match_type=MATCHED) [32-104] [WHEN MATCHED....T1 + S.C1]
      BinaryExpression(=) [49-57] [T.T1 = 5]
        PathExpression [49-53] [T.T1]
          Identifier(T) [49-50] [T]
          Identifier(T1) [51-53] [T1]
        IntLiteral(5) [56-57] [5]
      MergeAction(UPDATE) [63-104] [UPDATE SET....T1 + S.C1]
        UpdateItemList [74-104] [T1 = T1 + 10, T2 = T.T1 + S.C1]
          UpdateItem [74-86] [T1 = T1 + 10]
            UpdateSetValue [74-86] [T1 = T1 + 10]
              PathExpression [74-76] [T1]
                Identifier(T1) [74-76] [T1]
              BinaryExpression(+) [79-86] [T1 + 10]
                PathExpression [79-81] [T1]
                  Identifier(T1) [79-81] [T1]
                IntLiteral(10) [84-86] [10]
          UpdateItem [88-104] [T2 = T.T1 + S.C1]
            UpdateSetValue [88-104] [T2 = T.T1 + S.C1]
              PathExpression [88-90] [T2]
                Identifier(T2) [88-90] [T2]
              BinaryExpression(+) [93-104] [T.T1 + S.C1]
                PathExpression [93-97] [T.T1]
                  Identifier(T) [93-94] [T]
                  Identifier(T1) [95-97] [T1]
                PathExpression [100-104] [S.C1]
                  Identifier(S) [100-101] [S]
                  Identifier(C1) [102-104] [C1]
    MergeWhenClause(match_type=NOT_MATCHED_BY_SOURCE) [105-143] [WHEN NOT MATCHED...THEN DELETE]
      MergeAction(DELETE) [137-143] [DELETE]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN MATCHED AND T.T1 = 5 THEN
  UPDATE
  SET
    T1 = T1 + 10,
    T2 = T.T1 + S.C1
WHEN NOT MATCHED BY SOURCE THEN
  DELETE
==

# Has NOT MATCHED BY SOURCE & TARGET clauses.
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED THEN
INSERT(t1, t2, t3) VALUES(10, S.C3, S.C1 + S.C2)
WHEN NOT MATCHED BY SOURCE THEN
DELETE
--
MergeStatement [0-141] [MERGE INTO...THEN DELETE]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-141] [WHEN NOT MATCHED...THEN DELETE]
    MergeWhenClause(match_type=NOT_MATCHED_BY_TARGET) [32-102] [WHEN NOT MATCHED...C1 + S.C2)]
      MergeAction(INSERT) [54-102] [INSERT(t1,...C1 + S.C2)]
        ColumnList [60-72] [(t1, t2, t3)]
          Identifier(t1) [61-63] [t1]
          Identifier(t2) [65-67] [t2]
          Identifier(t3) [69-71] [t3]
        InsertValuesRow [79-102] [(10, S.C3, S.C1 + S.C2)]
          IntLiteral(10) [80-82] [10]
          PathExpression [84-88] [S.C3]
            Identifier(S) [84-85] [S]
            Identifier(C3) [86-88] [C3]
          BinaryExpression(+) [90-101] [S.C1 + S.C2]
            PathExpression [90-94] [S.C1]
              Identifier(S) [90-91] [S]
              Identifier(C1) [92-94] [C1]
            PathExpression [97-101] [S.C2]
              Identifier(S) [97-98] [S]
              Identifier(C2) [99-101] [C2]
    MergeWhenClause(match_type=NOT_MATCHED_BY_SOURCE) [103-141] [WHEN NOT MATCHED...THEN DELETE]
      MergeAction(DELETE) [135-141] [DELETE]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY TARGET THEN
  INSERT(t1, t2, t3)
  VALUES
    (10, S.C3, S.C1 + S.C2)
WHEN NOT MATCHED BY SOURCE THEN
  DELETE
==

# Has all three clauses.
MERGE INTO T
USING S
ON t1 = s1
WHEN MATCHED AND T.T1 = 5 THEN
UPDATE SET T1 = T1 + 10, T2 = T.T1 + S.C1
WHEN NOT MATCHED THEN
INSERT(t1, t2, t3) VALUES(10, S.C3, S.C1 + S.C2)
WHEN NOT MATCHED BY SOURCE THEN
DELETE
--
MergeStatement [0-214] [MERGE INTO...THEN DELETE]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-214] [WHEN MATCHED...THEN DELETE]
    MergeWhenClause(match_type=MATCHED) [32-104] [WHEN MATCHED....T1 + S.C1]
      BinaryExpression(=) [49-57] [T.T1 = 5]
        PathExpression [49-53] [T.T1]
          Identifier(T) [49-50] [T]
          Identifier(T1) [51-53] [T1]
        IntLiteral(5) [56-57] [5]
      MergeAction(UPDATE) [63-104] [UPDATE SET....T1 + S.C1]
        UpdateItemList [74-104] [T1 = T1 + 10, T2 = T.T1 + S.C1]
          UpdateItem [74-86] [T1 = T1 + 10]
            UpdateSetValue [74-86] [T1 = T1 + 10]
              PathExpression [74-76] [T1]
                Identifier(T1) [74-76] [T1]
              BinaryExpression(+) [79-86] [T1 + 10]
                PathExpression [79-81] [T1]
                  Identifier(T1) [79-81] [T1]
                IntLiteral(10) [84-86] [10]
          UpdateItem [88-104] [T2 = T.T1 + S.C1]
            UpdateSetValue [88-104] [T2 = T.T1 + S.C1]
              PathExpression [88-90] [T2]
                Identifier(T2) [88-90] [T2]
              BinaryExpression(+) [93-104] [T.T1 + S.C1]
                PathExpression [93-97] [T.T1]
                  Identifier(T) [93-94] [T]
                  Identifier(T1) [95-97] [T1]
                PathExpression [100-104] [S.C1]
                  Identifier(S) [100-101] [S]
                  Identifier(C1) [102-104] [C1]
    MergeWhenClause(match_type=NOT_MATCHED_BY_TARGET) [105-175] [WHEN NOT MATCHED...C1 + S.C2)]
      MergeAction(INSERT) [127-175] [INSERT(t1,...C1 + S.C2)]
        ColumnList [133-145] [(t1, t2, t3)]
          Identifier(t1) [134-136] [t1]
          Identifier(t2) [138-140] [t2]
          Identifier(t3) [142-144] [t3]
        InsertValuesRow [152-175] [(10, S.C3, S.C1 + S.C2)]
          IntLiteral(10) [153-155] [10]
          PathExpression [157-161] [S.C3]
            Identifier(S) [157-158] [S]
            Identifier(C3) [159-161] [C3]
          BinaryExpression(+) [163-174] [S.C1 + S.C2]
            PathExpression [163-167] [S.C1]
              Identifier(S) [163-164] [S]
              Identifier(C1) [165-167] [C1]
            PathExpression [170-174] [S.C2]
              Identifier(S) [170-171] [S]
              Identifier(C2) [172-174] [C2]
    MergeWhenClause(match_type=NOT_MATCHED_BY_SOURCE) [176-214] [WHEN NOT MATCHED...THEN DELETE]
      MergeAction(DELETE) [208-214] [DELETE]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN MATCHED AND T.T1 = 5 THEN
  UPDATE
  SET
    T1 = T1 + 10,
    T2 = T.T1 + S.C1
WHEN NOT MATCHED BY TARGET THEN
  INSERT(t1, t2, t3)
  VALUES
    (10, S.C3, S.C1 + S.C2)
WHEN NOT MATCHED BY SOURCE THEN
  DELETE
==

MERGE INTO T
USING S
ON T.t1 = S.s1
WHEN NOT MATCHED BY TARGET AND s1 > 10 THEN
INSERT(t1) VALUES(10)
--
MergeStatement [0-101] [MERGE INTO...VALUES(10)]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-35] [T.t1 = S.s1]
    PathExpression [24-28] [T.t1]
      Identifier(T) [24-25] [T]
      Identifier(t1) [26-28] [t1]
    PathExpression [31-35] [S.s1]
      Identifier(S) [31-32] [S]
      Identifier(s1) [33-35] [s1]
  MergeWhenClauseList [36-101] [WHEN NOT MATCHED...VALUES(10)]
    MergeWhenClause(match_type=NOT_MATCHED_BY_TARGET) [36-101] [WHEN NOT MATCHED...VALUES(10)]
      BinaryExpression(>) [67-74] [s1 > 10]
        PathExpression [67-69] [s1]
          Identifier(s1) [67-69] [s1]
        IntLiteral(10) [72-74] [10]
      MergeAction(INSERT) [80-101] [INSERT(t1) VALUES(10)]
        ColumnList [86-90] [(t1)]
          Identifier(t1) [87-89] [t1]
        InsertValuesRow [97-101] [(10)]
          IntLiteral(10) [98-100] [10]
--
MERGE INTO T
USING S
ON T.t1 = S.s1
WHEN NOT MATCHED BY TARGET AND s1 > 10 THEN
  INSERT(t1)
  VALUES
    (10)
==

MERGE T
USING S
ON T.t1 = S.s1
WHEN NOT MATCHED THEN
INSERT(t1) VALUES(10)
--
MergeStatement [0-74] [MERGE T USING...VALUES(10)]
  PathExpression [6-7] [T]
    Identifier(T) [6-7] [T]
  TablePathExpression [14-15] [S]
    PathExpression [14-15] [S]
      Identifier(S) [14-15] [S]
  BinaryExpression(=) [19-30] [T.t1 = S.s1]
    PathExpression [19-23] [T.t1]
      Identifier(T) [19-20] [T]
      Identifier(t1) [21-23] [t1]
    PathExpression [26-30] [S.s1]
      Identifier(S) [26-27] [S]
      Identifier(s1) [28-30] [s1]
  MergeWhenClauseList [31-74] [WHEN NOT MATCHED...VALUES(10)]
    MergeWhenClause(match_type=NOT_MATCHED_BY_TARGET) [31-74] [WHEN NOT MATCHED...VALUES(10)]
      MergeAction(INSERT) [53-74] [INSERT(t1) VALUES(10)]
        ColumnList [59-63] [(t1)]
          Identifier(t1) [60-62] [t1]
        InsertValuesRow [70-74] [(10)]
          IntLiteral(10) [71-73] [10]
--
MERGE INTO T
USING S
ON T.t1 = S.s1
WHEN NOT MATCHED BY TARGET THEN
  INSERT(t1)
  VALUES
    (10)
==

# Using subquery as source table.
MERGE INTO T
USING (SELECT * FROM Y JOIN Z ON Y.C1 = Z.C1) AS S
ON t1 = s1
WHEN NOT MATCHED AND S.C2 = 20 THEN
INSERT(t1, t2, t3) VALUES(10, S.C3, S.C1 + S.C2)

--
MergeStatement [0-159] [MERGE INTO...C1 + S.C2)]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TableSubquery [19-63] [(SELECT *...Z.C1) AS S]
    Query [20-57] [SELECT * FROM....C1 = Z.C1]
      Select [20-57] [SELECT * FROM....C1 = Z.C1]
        SelectList [27-28] [*]
          SelectColumn [27-28] [*]
            Star(*) [27-28] [*]
        FromClause [29-57] [FROM Y JOIN Z ON Y.C1 = Z.C1]
          Join [34-57] [Y JOIN Z ON Y.C1 = Z.C1]
            TablePathExpression [34-35] [Y]
              PathExpression [34-35] [Y]
                Identifier(Y) [34-35] [Y]
            Location [36-40] [JOIN]
            TablePathExpression [41-42] [Z]
              PathExpression [41-42] [Z]
                Identifier(Z) [41-42] [Z]
            OnClause [43-57] [ON Y.C1 = Z.C1]
              BinaryExpression(=) [46-57] [Y.C1 = Z.C1]
                PathExpression [46-50] [Y.C1]
                  Identifier(Y) [46-47] [Y]
                  Identifier(C1) [48-50] [C1]
                PathExpression [53-57] [Z.C1]
                  Identifier(Z) [53-54] [Z]
                  Identifier(C1) [55-57] [C1]
    Alias [59-63] [AS S]
      Identifier(S) [62-63] [S]
  BinaryExpression(=) [67-74] [t1 = s1]
    PathExpression [67-69] [t1]
      Identifier(t1) [67-69] [t1]
    PathExpression [72-74] [s1]
      Identifier(s1) [72-74] [s1]
  MergeWhenClauseList [75-159] [WHEN NOT MATCHED...C1 + S.C2)]
    MergeWhenClause(match_type=NOT_MATCHED_BY_TARGET) [75-159] [WHEN NOT MATCHED...C1 + S.C2)]
      BinaryExpression(=) [96-105] [S.C2 = 20]
        PathExpression [96-100] [S.C2]
          Identifier(S) [96-97] [S]
          Identifier(C2) [98-100] [C2]
        IntLiteral(20) [103-105] [20]
      MergeAction(INSERT) [111-159] [INSERT(t1,...C1 + S.C2)]
        ColumnList [117-129] [(t1, t2, t3)]
          Identifier(t1) [118-120] [t1]
          Identifier(t2) [122-124] [t2]
          Identifier(t3) [126-128] [t3]
        InsertValuesRow [136-159] [(10, S.C3, S.C1 + S.C2)]
          IntLiteral(10) [137-139] [10]
          PathExpression [141-145] [S.C3]
            Identifier(S) [141-142] [S]
            Identifier(C3) [143-145] [C3]
          BinaryExpression(+) [147-158] [S.C1 + S.C2]
            PathExpression [147-151] [S.C1]
              Identifier(S) [147-148] [S]
              Identifier(C1) [149-151] [C1]
            PathExpression [154-158] [S.C2]
              Identifier(S) [154-155] [S]
              Identifier(C2) [156-158] [C2]
--
MERGE INTO T
USING
(
  SELECT
    *
  FROM
    Y
    JOIN
    Z
    ON Y.C1 = Z.C1
) AS S
ON t1 = s1
WHEN NOT MATCHED BY TARGET AND S.C2 = 20 THEN
  INSERT(t1, t2, t3)
  VALUES
    (10, S.C3, S.C1 + S.C2)
==

# Has multiple WHEN NOT MATCHED BY TARGET clauses.
MERGE T AS X
USING S
ON X.t1 = S.s1
WHEN NOT MATCHED AND S.C1 > 100 THEN
INSERT(t1) VALUES(S.C2)
WHEN NOT MATCHED AND S.C1 > 50 THEN
INSERT(t1) VALUES(S.C2 * 10)
WHEN NOT MATCHED THEN
INSERT(t1) VALUES(S.C2 * 100)
--
MergeStatement [0-213] [MERGE T AS....C2 * 100)]
  PathExpression [6-7] [T]
    Identifier(T) [6-7] [T]
  Alias [8-12] [AS X]
    Identifier(X) [11-12] [X]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-35] [X.t1 = S.s1]
    PathExpression [24-28] [X.t1]
      Identifier(X) [24-25] [X]
      Identifier(t1) [26-28] [t1]
    PathExpression [31-35] [S.s1]
      Identifier(S) [31-32] [S]
      Identifier(s1) [33-35] [s1]
  MergeWhenClauseList [36-213] [WHEN NOT MATCHED....C2 * 100)]
    MergeWhenClause(match_type=NOT_MATCHED_BY_TARGET) [36-96] [WHEN NOT MATCHED...ALUES(S.C2)]
      BinaryExpression(>) [57-67] [S.C1 > 100]
        PathExpression [57-61] [S.C1]
          Identifier(S) [57-58] [S]
          Identifier(C1) [59-61] [C1]
        IntLiteral(100) [64-67] [100]
      MergeAction(INSERT) [73-96] [INSERT(t1) VALUES(S.C2)]
        ColumnList [79-83] [(t1)]
          Identifier(t1) [80-82] [t1]
        InsertValuesRow [90-96] [(S.C2)]
          PathExpression [91-95] [S.C2]
            Identifier(S) [91-92] [S]
            Identifier(C2) [93-95] [C2]
    MergeWhenClause(match_type=NOT_MATCHED_BY_TARGET) [97-161] [WHEN NOT MATCHED...S.C2 * 10)]
      BinaryExpression(>) [118-127] [S.C1 > 50]
        PathExpression [118-122] [S.C1]
          Identifier(S) [118-119] [S]
          Identifier(C1) [120-122] [C1]
        IntLiteral(50) [125-127] [50]
      MergeAction(INSERT) [133-161] [INSERT(t1) VALUES(S.C2 * 10)]
        ColumnList [139-143] [(t1)]
          Identifier(t1) [140-142] [t1]
        InsertValuesRow [150-161] [(S.C2 * 10)]
          BinaryExpression(*) [151-160] [S.C2 * 10]
            PathExpression [151-155] [S.C2]
              Identifier(S) [151-152] [S]
              Identifier(C2) [153-155] [C2]
            IntLiteral(10) [158-160] [10]
    MergeWhenClause(match_type=NOT_MATCHED_BY_TARGET) [162-213] [WHEN NOT MATCHED....C2 * 100)]
      MergeAction(INSERT) [184-213] [INSERT(t1) VALUES(S.C2 * 100)]
        ColumnList [190-194] [(t1)]
          Identifier(t1) [191-193] [t1]
        InsertValuesRow [201-213] [(S.C2 * 100)]
          BinaryExpression(*) [202-212] [S.C2 * 100]
            PathExpression [202-206] [S.C2]
              Identifier(S) [202-203] [S]
              Identifier(C2) [204-206] [C2]
            IntLiteral(100) [209-212] [100]
--
MERGE INTO T AS X
USING S
ON X.t1 = S.s1
WHEN NOT MATCHED BY TARGET AND S.C1 > 100 THEN
  INSERT(t1)
  VALUES
    (S.C2)
WHEN NOT MATCHED BY TARGET AND S.C1 > 50 THEN
  INSERT(t1)
  VALUES
    (S.C2 * 10)
WHEN NOT MATCHED BY TARGET THEN
  INSERT(t1)
  VALUES
    (S.C2 * 100)
==

# More than 1 same type clauses together with other clause type.
MERGE INTO T
USING (SELECT * FROM Y JOIN Z ON Y.C1 = Z.C1) AS S
ON t1 = s1
WHEN MATCHED AND T.T1 = 5 AND S.C3 < 0 THEN
UPDATE SET T1 = T1 + 10, T2 = T.T1 + S.C1
WHEN MATCHED THEN
DELETE
WHEN NOT MATCHED AND S.C2 = 20 THEN
INSERT(t1, t2, t3) VALUES(10, S.C3, S.C1 + S.C2)
--
MergeStatement [0-270] [MERGE INTO...C1 + S.C2)]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TableSubquery [19-63] [(SELECT *...Z.C1) AS S]
    Query [20-57] [SELECT * FROM....C1 = Z.C1]
      Select [20-57] [SELECT * FROM....C1 = Z.C1]
        SelectList [27-28] [*]
          SelectColumn [27-28] [*]
            Star(*) [27-28] [*]
        FromClause [29-57] [FROM Y JOIN Z ON Y.C1 = Z.C1]
          Join [34-57] [Y JOIN Z ON Y.C1 = Z.C1]
            TablePathExpression [34-35] [Y]
              PathExpression [34-35] [Y]
                Identifier(Y) [34-35] [Y]
            Location [36-40] [JOIN]
            TablePathExpression [41-42] [Z]
              PathExpression [41-42] [Z]
                Identifier(Z) [41-42] [Z]
            OnClause [43-57] [ON Y.C1 = Z.C1]
              BinaryExpression(=) [46-57] [Y.C1 = Z.C1]
                PathExpression [46-50] [Y.C1]
                  Identifier(Y) [46-47] [Y]
                  Identifier(C1) [48-50] [C1]
                PathExpression [53-57] [Z.C1]
                  Identifier(Z) [53-54] [Z]
                  Identifier(C1) [55-57] [C1]
    Alias [59-63] [AS S]
      Identifier(S) [62-63] [S]
  BinaryExpression(=) [67-74] [t1 = s1]
    PathExpression [67-69] [t1]
      Identifier(t1) [67-69] [t1]
    PathExpression [72-74] [s1]
      Identifier(s1) [72-74] [s1]
  MergeWhenClauseList [75-270] [WHEN MATCHED...C1 + S.C2)]
    MergeWhenClause(match_type=MATCHED) [75-160] [WHEN MATCHED....T1 + S.C1]
      AndExpr [92-113] [T.T1 = 5 AND S.C3 < 0]
        BinaryExpression(=) [92-100] [T.T1 = 5]
          PathExpression [92-96] [T.T1]
            Identifier(T) [92-93] [T]
            Identifier(T1) [94-96] [T1]
          IntLiteral(5) [99-100] [5]
        BinaryExpression(<) [105-113] [S.C3 < 0]
          PathExpression [105-109] [S.C3]
            Identifier(S) [105-106] [S]
            Identifier(C3) [107-109] [C3]
          IntLiteral(0) [112-113] [0]
      MergeAction(UPDATE) [119-160] [UPDATE SET....T1 + S.C1]
        UpdateItemList [130-160] [T1 = T1 + 10, T2 = T.T1 + S.C1]
          UpdateItem [130-142] [T1 = T1 + 10]
            UpdateSetValue [130-142] [T1 = T1 + 10]
              PathExpression [130-132] [T1]
                Identifier(T1) [130-132] [T1]
              BinaryExpression(+) [135-142] [T1 + 10]
                PathExpression [135-137] [T1]
                  Identifier(T1) [135-137] [T1]
                IntLiteral(10) [140-142] [10]
          UpdateItem [144-160] [T2 = T.T1 + S.C1]
            UpdateSetValue [144-160] [T2 = T.T1 + S.C1]
              PathExpression [144-146] [T2]
                Identifier(T2) [144-146] [T2]
              BinaryExpression(+) [149-160] [T.T1 + S.C1]
                PathExpression [149-153] [T.T1]
                  Identifier(T) [149-150] [T]
                  Identifier(T1) [151-153] [T1]
                PathExpression [156-160] [S.C1]
                  Identifier(S) [156-157] [S]
                  Identifier(C1) [158-160] [C1]
    MergeWhenClause(match_type=MATCHED) [161-185] [WHEN MATCHED THEN DELETE]
      MergeAction(DELETE) [179-185] [DELETE]
    MergeWhenClause(match_type=NOT_MATCHED_BY_TARGET) [186-270] [WHEN NOT MATCHED...C1 + S.C2)]
      BinaryExpression(=) [207-216] [S.C2 = 20]
        PathExpression [207-211] [S.C2]
          Identifier(S) [207-208] [S]
          Identifier(C2) [209-211] [C2]
        IntLiteral(20) [214-216] [20]
      MergeAction(INSERT) [222-270] [INSERT(t1,...C1 + S.C2)]
        ColumnList [228-240] [(t1, t2, t3)]
          Identifier(t1) [229-231] [t1]
          Identifier(t2) [233-235] [t2]
          Identifier(t3) [237-239] [t3]
        InsertValuesRow [247-270] [(10, S.C3, S.C1 + S.C2)]
          IntLiteral(10) [248-250] [10]
          PathExpression [252-256] [S.C3]
            Identifier(S) [252-253] [S]
            Identifier(C3) [254-256] [C3]
          BinaryExpression(+) [258-269] [S.C1 + S.C2]
            PathExpression [258-262] [S.C1]
              Identifier(S) [258-259] [S]
              Identifier(C1) [260-262] [C1]
            PathExpression [265-269] [S.C2]
              Identifier(S) [265-266] [S]
              Identifier(C2) [267-269] [C2]
--
MERGE INTO T
USING
(
  SELECT
    *
  FROM
    Y
    JOIN
    Z
    ON Y.C1 = Z.C1
) AS S
ON t1 = s1
WHEN MATCHED AND T.T1 = 5 AND S.C3 < 0 THEN
  UPDATE
  SET
    T1 = T1 + 10,
    T2 = T.T1 + S.C1
WHEN MATCHED THEN
  DELETE
WHEN NOT MATCHED BY TARGET AND S.C2 = 20 THEN
  INSERT(t1, t2, t3)
  VALUES
    (10, S.C3, S.C1 + S.C2)
==

# Missing target table
MERGE
USING S
ON C1 = S1
WHEN MATCHED THEN
DELETE
--
ERROR: Syntax error: Unexpected keyword USING [at 2:1]
USING S
^
==

# Missing USING clause
MERGE INTO T
ON C1 = S1
WHEN MATCHED THEN
DELETE
--
ERROR: Syntax error: Unexpected keyword ON [at 2:1]
ON C1 = S1
^
==

# Missing merge condition
MERGE INTO T
USING S
WHEN MATCHED THEN
DELETE
--
ERROR: Syntax error: Expected keyword ON but got keyword WHEN [at 3:1]
WHEN MATCHED THEN
^
==

# Missing WHEN ... THEN clause.
MERGE INTO T
USING S
ON t1 = s1
--
ERROR: Syntax error: Expected keyword WHEN but got end of statement [at 3:11]
ON t1 = s1
          ^
==

# Does not support JOIN for source table
MERGE INTO T
USING Y JOIN Z ON Y.C1 = Z.C1
ON t1 = s1
WHEN NOT MATCHED THEN
INSERT(t1) VALUES(10)
--
ERROR: Syntax error: Expected keyword ON but got keyword JOIN [at 2:9]
USING Y JOIN Z ON Y.C1 = Z.C1
        ^
==

# Does not support parenthesized joins for source table
MERGE INTO T
USING (Y JOIN Z ON Y.C1 = Z.C1)
ON t1 = s1
WHEN MATCHED THEN
DELETE
--
ERROR: Syntax error: Expected "(" or keyword SELECT or keyword WITH but got identifier "Y" [at 2:8]
USING (Y JOIN Z ON Y.C1 = Z.C1)
       ^
==

# Does not support TVF
MERGE INTO T
USING mytvf()
ON t1 = s1
WHEN MATCHED THEN
DELETE
--
ERROR: Syntax error: Expected keyword ON but got "(" [at 2:12]
USING mytvf()
           ^
==

# This and following cases are allowed in parser, but will be disabled by
# resolver. According to spec, only some of the actions are allowed for each
# type of WHEN clause as following,
#
#          | MATCHED | NOT_MATCHED_BY_SOURCE | NOT_MATCHED_BY_TARGET
#   INSERT |    N    |           N           |           Y
#   UPDATE |    Y    |           Y           |           N
#   DELETE |    Y    |           Y           |           N
MERGE INTO T
USING S
ON t1 = s1
WHEN MATCHED THEN
  INSERT(t1) VALUES(10)
--
MergeStatement [0-73] [MERGE INTO...VALUES(10)]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-73] [WHEN MATCHED...VALUES(10)]
    MergeWhenClause(match_type=MATCHED) [32-73] [WHEN MATCHED...VALUES(10)]
      MergeAction(INSERT) [52-73] [INSERT(t1) VALUES(10)]
        ColumnList [58-62] [(t1)]
          Identifier(t1) [59-61] [t1]
        InsertValuesRow [69-73] [(10)]
          IntLiteral(10) [70-72] [10]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN MATCHED THEN
  INSERT(t1)
  VALUES
    (10)
==

# This is allowed in parser, but will be disabled by resolver.
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED THEN
  DELETE
--
MergeStatement [0-62] [MERGE INTO...THEN   DELETE]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-62] [WHEN NOT MATCHED THEN   DELETE]
    MergeWhenClause(match_type=NOT_MATCHED_BY_TARGET) [32-62] [WHEN NOT MATCHED THEN   DELETE]
      MergeAction(DELETE) [56-62] [DELETE]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY TARGET THEN
  DELETE
==

# This is allowed in parser, but will be disabled by resolver.
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED THEN
  UPDATE SET t1 = 10
--
MergeStatement [0-74] [MERGE INTO...SET t1 = 10]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-74] [WHEN NOT MATCHED...SET t1 = 10]
    MergeWhenClause(match_type=NOT_MATCHED_BY_TARGET) [32-74] [WHEN NOT MATCHED...SET t1 = 10]
      MergeAction(UPDATE) [56-74] [UPDATE SET t1 = 10]
        UpdateItemList [67-74] [t1 = 10]
          UpdateItem [67-74] [t1 = 10]
            UpdateSetValue [67-74] [t1 = 10]
              PathExpression [67-69] [t1]
                Identifier(t1) [67-69] [t1]
              IntLiteral(10) [72-74] [10]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY TARGET THEN
  UPDATE
  SET
    t1 = 10
==

# This is allowed in parser, but will be disabled by resolver.
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY SOURCE THEN
  INSERT(t1) VALUES(s2)
--
MergeStatement [0-87] [MERGE INTO...VALUES(s2)]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-87] [WHEN NOT MATCHED...VALUES(s2)]
    MergeWhenClause(match_type=NOT_MATCHED_BY_SOURCE) [32-87] [WHEN NOT MATCHED...VALUES(s2)]
      MergeAction(INSERT) [66-87] [INSERT(t1) VALUES(s2)]
        ColumnList [72-76] [(t1)]
          Identifier(t1) [73-75] [t1]
        InsertValuesRow [83-87] [(s2)]
          PathExpression [84-86] [s2]
            Identifier(s2) [84-86] [s2]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY SOURCE THEN
  INSERT(t1)
  VALUES
    (s2)

==

# Omit insert column list
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY SOURCE THEN
  INSERT VALUES(s2)
--
MergeStatement [0-83] [MERGE INTO...VALUES(s2)]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-83] [WHEN NOT MATCHED...VALUES(s2)]
    MergeWhenClause(match_type=NOT_MATCHED_BY_SOURCE) [32-83] [WHEN NOT MATCHED...VALUES(s2)]
      MergeAction(INSERT) [66-83] [INSERT VALUES(s2)]
        InsertValuesRow [79-83] [(s2)]
          PathExpression [80-82] [s2]
            Identifier(s2) [80-82] [s2]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY SOURCE THEN
  INSERT
  VALUES
    (s2)
==

# Omit insert value list
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY SOURCE THEN
  INSERT(t1) ROW
--
MergeStatement [0-80] [MERGE INTO...INSERT(t1) ROW]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-80] [WHEN NOT MATCHED...ERT(t1) ROW]
    MergeWhenClause(match_type=NOT_MATCHED_BY_SOURCE) [32-80] [WHEN NOT MATCHED...ERT(t1) ROW]
      MergeAction(INSERT) [66-80] [INSERT(t1) ROW]
        ColumnList [72-76] [(t1)]
          Identifier(t1) [73-75] [t1]
        InsertValuesRow [77-80] [ROW]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY SOURCE THEN
  INSERT(t1)
  ROW
==

# Omit both insert column and value lists
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY SOURCE THEN
  INSERT ROW
--
MergeStatement [0-76] [MERGE INTO...INSERT ROW]
  PathExpression [11-12] [T]
    Identifier(T) [11-12] [T]
  TablePathExpression [19-20] [S]
    PathExpression [19-20] [S]
      Identifier(S) [19-20] [S]
  BinaryExpression(=) [24-31] [t1 = s1]
    PathExpression [24-26] [t1]
      Identifier(t1) [24-26] [t1]
    PathExpression [29-31] [s1]
      Identifier(s1) [29-31] [s1]
  MergeWhenClauseList [32-76] [WHEN NOT MATCHED...INSERT ROW]
    MergeWhenClause(match_type=NOT_MATCHED_BY_SOURCE) [32-76] [WHEN NOT MATCHED...INSERT ROW]
      MergeAction(INSERT) [66-76] [INSERT ROW]
        InsertValuesRow [73-76] [ROW]
--
MERGE INTO T
USING S
ON t1 = s1
WHEN NOT MATCHED BY SOURCE THEN
  INSERT
  ROW
==

[no_test_get_parse_tokens]
[language_features={{|V_1_3_ALLOW_DASHES_IN_TABLE_NAME}}]
MERGE INTO my-project-123.a.t
USING project-789-abc.b.s
ON t1 = s1
WHEN NOT MATCHED BY SOURCE THEN INSERT ROW
--
ALTERNATION GROUP: <empty>
--
ERROR: Syntax error: Table name contains '-' character. It needs to be quoted: `my-project-123.a.t` [at 1:12]
MERGE INTO my-project-123.a.t
           ^
--
ALTERNATION GROUP: V_1_3_ALLOW_DASHES_IN_TABLE_NAME
--
MergeStatement [0-109] [MERGE INTO...INSERT ROW]
  PathExpression [11-29] [my-project-123.a.t]
    Identifier(`my-project-123`) [11-27] [my-project-123.a]
    Identifier(a) [11-27] [my-project-123.a]
    Identifier(t) [28-29] [t]
  TablePathExpression [36-55] [project-789-abc.b.s]
    PathExpression [36-55] [project-789-abc.b.s]
      Identifier(`project-789-abc`) [36-51] [project-789-abc]
      Identifier(b) [52-53] [b]
      Identifier(s) [54-55] [s]
  BinaryExpression(=) [59-66] [t1 = s1]
    PathExpression [59-61] [t1]
      Identifier(t1) [59-61] [t1]
    PathExpression [64-66] [s1]
      Identifier(s1) [64-66] [s1]
  MergeWhenClauseList [67-109] [WHEN NOT MATCHED...INSERT ROW]
    MergeWhenClause(match_type=NOT_MATCHED_BY_SOURCE) [67-109] [WHEN NOT MATCHED...INSERT ROW]
      MergeAction(INSERT) [99-109] [INSERT ROW]
        InsertValuesRow [106-109] [ROW]
--
MERGE INTO `my-project-123`.a.t
USING `project-789-abc`.b.s
ON t1 = s1
WHEN NOT MATCHED BY SOURCE THEN
  INSERT
  ROW
