[load_proto_files=zetasql/testdata/test_schema.proto]
[load_proto_names=zetasql_test__.TestNullabilityInnerPB, zetasql_test__.KitchenSinkPB]
[prepare_database]
CREATE TABLE TableAllNull AS
SELECT CAST(1 as int64) as row_id,
       CAST(NULL AS bool) as bool_val, CAST(NULL AS double) as double_val,
       CAST(NULL AS float) as float_val, CAST(NULL AS uint32) as uint32_val,
       CAST(NULL AS int32) as int32_val, CAST(NULL AS uint64) as uint64_val,
       CAST(NULL AS int64) as int64_val, CAST(NULL AS string) as str_val,
       CAST(NULL AS BYTES) as bytes_val, CAST(NULL AS DATE) as date_val,
       CAST(NULL AS TIMESTAMP) as timestamp_val
--
ARRAY<STRUCT<
        row_id INT64,
        bool_val BOOL,
        double_val DOUBLE,
        float_val FLOAT,
        uint32_val UINT32,
        int32_val INT32,
        uint64_val UINT64,
        int64_val INT64,
        str_val STRING,
        bytes_val BYTES,
        date_val DATE,
        timestamp_val TIMESTAMP
      >>[
  {1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}
]
==
[prepare_database]
CREATE TABLE TableOneValue AS
SELECT CAST(1 as int64) as row_id,
       CAST(true AS bool) as bool_val, CAST(1 AS double) as double_val,
       CAST(1 AS float) as float_val, CAST(1 AS uint32) as uint32_val,
       CAST(1 AS int32) as int32_val, CAST(1 AS uint64) as uint64_val,
       CAST(1 AS int64) as int64_val, CAST("1" AS string) as str_val,
       CAST("1" AS BYTES) as bytes_val, CAST('2001-01-01' AS DATE) as date_val,
       CAST('2001-01-01 00:00:00 UTC' AS TIMESTAMP) as timestamp_val
--
ARRAY<STRUCT<
        row_id INT64,
        bool_val BOOL,
        double_val DOUBLE,
        float_val FLOAT,
        uint32_val UINT32,
        int32_val INT32,
        uint64_val UINT64,
        int64_val INT64,
        str_val STRING,
        bytes_val BYTES,
        date_val DATE,
        timestamp_val TIMESTAMP
      >>
[{
   1,
   true,
   1,
   1,
   1,
   1,
   1,
   1,
   "1",
   b"1",
   2001-01-01,
   2001-01-01 00:00:00+00
 }]
==
[prepare_database]
CREATE TABLE TableAllTypes AS
SELECT CAST(1 AS int64) as row_id,
       CAST(true AS bool) as bool_val,
       CAST(-1 AS int32) as int32_val,
       CAST(-1 AS int64) as int64_val,
       CAST(1 AS uint32) as uint32_val,
       CAST(1 AS uint64) as uint64_val,
       CAST(0.125 AS float) as float_val,
       CAST(0.125 AS double) as double_val,
       CAST("1" AS string) as str_val,
       CAST("1" AS BYTES) as bytes_val,
       CAST('2014-01-01' AS DATE) as date_val,
       TIMESTAMP '2014-01-01 00:00:01 UTC' as timestamp_val
UNION ALL
SELECT CAST(2 AS int64) as row_id,
       CAST(true AS bool) as bool_val,
       CAST(-1 AS int32) as int32_val,
       CAST(-1 AS int64) as int64_val,
       CAST(1 AS uint32) as uint32_val,
       CAST(1 AS uint64) as uint64_val,
       CAST("NaN" AS float) as float_val,
       CAST("+Inf" AS double) as double_val,
       CAST("1" AS string) as str_val,
       CAST("1" AS BYTES) as bytes_val,
       CAST('2014-01-01' AS DATE) as date_val,
       TIMESTAMP '2014-01-01 00:00:01 UTC' as timestamp_val
UNION ALL
SELECT CAST(3 AS int64) as row_id,
       CAST(true AS bool) as bool_val,
       CAST(-1 AS int32) as int32_val,
       CAST(-1 AS int64) as int64_val,
       CAST(1 AS uint32) as uint32_val,
       CAST(1 AS uint64) as uint64_val,
       CAST("+Inf" AS float) as float_val,
       CAST("-Inf" AS double) as double_val,
       CAST("1" AS string) as str_val,
       CAST("1" AS BYTES) as bytes_val,
       CAST('2014-01-01' AS DATE) as date_val,
       TIMESTAMP '2014-01-01 00:00:01 UTC' as timestamp_val
UNION ALL
SELECT CAST(4 AS int64) as row_id,
       CAST(false AS bool) as bool_val,
       CAST(-2 AS int32) as int32_val,
       CAST(-2 AS int64) as int64_val,
       CAST(2 AS uint32) as uint32_val,
       CAST(2 AS uint64) as uint64_val,
       CAST(0.25 AS float) as float_val,
       CAST(pow(0.1, 324) AS double) as double_val, #positive 0 of type double
       CAST("2" AS string) as str_val,
       CAST("2" AS BYTES) as bytes_val,
       CAST('2014-01-02' AS DATE) as date_val,
       TIMESTAMP '2014-01-02 00:00:02 UTC' as timestamp_val
UNION ALL
SELECT CAST(5 AS int64) as row_id,
       CAST(false AS bool) as bool_val,
       CAST(-2 AS int32) as int32_val,
       CAST(-2 AS int64) as int64_val,
       CAST(2 AS uint32) as uint32_val,
       CAST(2 AS uint64) as uint64_val,
       CAST("-Inf" AS float) as float_val,
       CAST(0.25 AS double) as double_val,
       CAST("2" AS string) as str_val,
       CAST("2" AS BYTES) as bytes_val,
       CAST('2014-01-02' AS DATE) as date_val,
       TIMESTAMP '2014-01-02 00:00:02 UTC' as timestamp_val
UNION ALL
SELECT CAST(6 AS int64) as row_id,
       CAST(true AS bool) as bool_val,
       CAST(-3 AS int32) as int32_val,
       CAST(-3 AS int64) as int64_val,
       CAST(3 AS uint32) as uint32_val,
       CAST(3 AS uint64) as uint64_val,
       CAST(0.375 AS float) as float_val,
       CAST(0.375 AS double) as double_val,
       CAST("3" AS string) as str_val,
       CAST("3" AS BYTES) as bytes_val,
       CAST('2014-01-03' AS DATE) as date_val,
       TIMESTAMP '2014-01-03 00:00:03 UTC' as timestamp_val
UNION ALL
SELECT CAST(7 AS int64) as row_id,
       CAST(false AS bool) as bool_val,
       CAST(-4 AS int32) as int32_val,
       CAST(-4 AS int64) as int64_val,
       CAST(4 AS uint32) as uint32_val,
       CAST(4 AS uint64) as uint64_val,
       CAST(0.5 AS float) as float_val,
       CAST(0.5 AS double) as double_val,
       CAST("4" AS string) as str_val,
       CAST("4" AS BYTES) as bytes_val,
       CAST('2014-01-04' AS DATE) as date_val,
       TIMESTAMP '2014-01-04 00:00:04 UTC' as timestamp_val
UNION ALL
SELECT CAST(8 AS int64) as row_id,
       CAST(NULL AS bool) as bool_val,
       CAST(NULL AS int32) as int32_val,
       CAST(NULL AS int64) as int64_val,
       CAST(NULL AS uint32) as uint32_val,
       CAST(NULL AS uint64) as uint64_val,
       CAST(NULL AS float) as float_val,
       CAST(NULL AS double) as double_val,
       CAST(NULL AS string) as str_val,
       CAST(NULL AS BYTES) as bytes_val,
       CAST(NULL AS DATE) as date_val,
       CAST(NULL AS TIMESTAMP) as timestamp_val
UNION ALL
SELECT CAST(9 AS int64) as row_id,
       CAST(NULL AS bool) as bool_val,
       CAST(NULL AS int32) as int32_val,
       CAST(NULL AS int64) as int64_val,
       CAST(NULL AS uint32) as uint32_val,
       CAST(NULL AS uint64) as uint64_val,
       CAST(-pow(0.1, 46) AS float) as float_val, #negative 0 of type float
       CAST("NaN" AS double) as double_val,
       CAST(NULL AS string) as str_val,
       CAST(NULL AS BYTES) as bytes_val,
       CAST(NULL AS DATE) as date_val,
       CAST(NULL AS TIMESTAMP) as timestamp_val
UNION ALL
SELECT CAST(10 AS int64) as row_id,
       CAST(true AS bool) as bool_val,
       CAST(1 AS int32) as int32_val,
       CAST(1 AS int64) as int64_val,
       CAST(11 AS uint32) as uint32_val,
       CAST(11 AS uint64) as uint64_val,
       CAST(0.625 AS float) as float_val,
       CAST(0.625 AS double) as double_val,
       CAST("6" AS string) as str_val,
       CAST("7" AS BYTES) as bytes_val,
       CAST('2014-01-08' AS DATE) as date_val,
       TIMESTAMP '2014-01-07 00:00:01 UTC' as timestamp_val
UNION ALL
SELECT CAST(11 AS int64) as row_id,
       CAST(false AS bool) as bool_val,
       CAST(5 AS int32) as int32_val,
       CAST(3 AS int64) as int64_val,
       CAST(11 AS uint32) as uint32_val,
       CAST(8 AS uint64) as uint64_val,
       CAST(-0.125 AS float) as float_val,
       CAST(-0.125 AS double) as double_val,
       CAST("123" AS string) as str_val,
       CAST("123" AS BYTES) as bytes_val,
       CAST('2014-02-01' AS DATE) as date_val,
       TIMESTAMP '2014-03-01 00:00:01 UTC' as timestamp_val
UNION ALL
SELECT CAST(12 AS int64) as row_id,
       CAST(false AS bool) as bool_val,
       CAST(2 AS int32) as int32_val,
       CAST(16 AS int64) as int64_val,
       CAST(5 AS uint32) as uint32_val,
       CAST(9 AS uint64) as uint64_val,
       CAST(0.75 AS float) as float_val,
       CAST(-0.25 AS double) as double_val,
       CAST("24" AS string) as str_val,
       CAST("22" AS BYTES) as bytes_val,
       CAST('2014-02-02' AS DATE) as date_val,
       TIMESTAMP '2014-03-02 00:00:02 UTC' as timestamp_val
UNION ALL
SELECT CAST(13 AS int64) as row_id,
       CAST(false AS bool) as bool_val,
       CAST(9 AS int32) as int32_val,
       CAST(9 AS int64) as int64_val,
       CAST(4 AS uint32) as uint32_val,
       CAST(8 AS uint64) as uint64_val,
       CAST(-0.25 AS float) as float_val,
       CAST(-0.75 AS double) as double_val,
       CAST("222" AS string) as str_val,
       CAST("234" AS BYTES) as bytes_val,
       CAST('2014-05-02' AS DATE) as date_val,
       TIMESTAMP '2014-05-02 00:00:02 UTC' as timestamp_val
UNION ALL
SELECT CAST(14 AS int64) as row_id,
       CAST(true AS bool) as bool_val,
       CAST(13 AS int32) as int32_val,
       CAST(23 AS int64) as int64_val,
       CAST(31 AS uint32) as uint32_val,
       CAST(32 AS uint64) as uint64_val,
       CAST(-0.375 AS float) as float_val,
       CAST(-0.375 AS double) as double_val,
       CAST("345" AS string) as str_val,
       CAST("345" AS BYTES) as bytes_val,
       CAST('2014-01-06' AS DATE) as date_val,
       TIMESTAMP '2014-02-03 00:00:03 UTC' as timestamp_val
UNION ALL
SELECT CAST(15 AS int64) as row_id,
       CAST(false AS bool) as bool_val,
       CAST(-24 AS int32) as int32_val,
       CAST(-14 AS int64) as int64_val,
       CAST(41 AS uint32) as uint32_val,
       CAST(54 AS uint64) as uint64_val,
       CAST(-0.5 AS float) as float_val,
       CAST(-0.5 AS double) as double_val,
       CAST("432" AS string) as str_val,
       CAST("433" AS BYTES) as bytes_val,
       CAST('2014-02-04' AS DATE) as date_val,
       TIMESTAMP '2014-02-04 00:00:04 UTC' as timestamp_val
UNION ALL
SELECT CAST(16 AS int64) as row_id,
       CAST(false AS bool) as bool_val,
       CAST(NULL AS int32) as int32_val,
       CAST(-1 AS int64) as int64_val,
       CAST(NULL AS uint32) as uint32_val,
       CAST(1 AS uint64) as uint64_val,
       CAST(NULL AS float) as float_val,
       CAST(-pow(0.1, 324) AS double) as double_val, #negative 0 of type double
       CAST(NULL AS string) as str_val,
       CAST("1" AS BYTES) as bytes_val,
       CAST(NULL AS DATE) as date_val,
       TIMESTAMP '2014-02-04 00:00:04 UTC' as timestamp_val
UNION ALL
SELECT CAST(17 AS int64) as row_id,
       CAST(NULL AS bool) as bool_val,
       CAST(-1 AS int32) as int32_val,
       CAST(NULL AS int64) as int64_val,
       CAST(1 AS uint32) as uint32_val,
       CAST(NULL AS uint64) as uint64_val,
       CAST(pow(0.1, 46) AS float) as float_val, #positive 0 of type float
       CAST(NULL AS double) as double_val,
       CAST("1" AS string) as str_val,
       CAST(NULL AS BYTES) as bytes_val,
       CAST('2014-02-04' AS DATE) as date_val,
       CAST(NULL AS TIMESTAMP) as timestamp_val
--
ARRAY<STRUCT<
        row_id INT64,
        bool_val BOOL,
        int32_val INT32,
        int64_val INT64,
        uint32_val UINT32,
        uint64_val UINT64,
        float_val FLOAT,
        double_val DOUBLE,
        str_val STRING,
        bytes_val BYTES,
        date_val DATE,
        timestamp_val TIMESTAMP
      >>
[{
   1,
   true,
   -1,
   -1,
   1,
   1,
   0.125,
   0.125,
   "1",
   b"1",
   2014-01-01,
   2014-01-01 00:00:01+00
 },
 {
   2,
   true,
   -1,
   -1,
   1,
   1,
   nan,
   inf,
   "1",
   b"1",
   2014-01-01,
   2014-01-01 00:00:01+00
 },
 {
   3,
   true,
   -1,
   -1,
   1,
   1,
   inf,
   -inf,
   "1",
   b"1",
   2014-01-01,
   2014-01-01 00:00:01+00
 },
 {
   4,
   false,
   -2,
   -2,
   2,
   2,
   0.25,
   0,
   "2",
   b"2",
   2014-01-02,
   2014-01-02 00:00:02+00
 },
 {
   5,
   false,
   -2,
   -2,
   2,
   2,
   -inf,
   0.25,
   "2",
   b"2",
   2014-01-02,
   2014-01-02 00:00:02+00
 },
 {
   6,
   true,
   -3,
   -3,
   3,
   3,
   0.375,
   0.375,
   "3",
   b"3",
   2014-01-03,
   2014-01-03 00:00:03+00
 },
 {
   7,
   false,
   -4,
   -4,
   4,
   4,
   0.5,
   0.5,
   "4",
   b"4",
   2014-01-04,
   2014-01-04 00:00:04+00
 },
 {8, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
 {9, NULL, NULL, NULL, NULL, NULL, -0, nan, NULL, NULL, NULL, NULL},
 {
   10,
   true,
   1,
   1,
   11,
   11,
   0.625,
   0.625,
   "6",
   b"7",
   2014-01-08,
   2014-01-07 00:00:01+00
 },
 {
   11,
   false,
   5,
   3,
   11,
   8,
   -0.125,
   -0.125,
   "123",
   b"123",
   2014-02-01,
   2014-03-01 00:00:01+00
 },
 {
   12,
   false,
   2,
   16,
   5,
   9,
   0.75,
   -0.25,
   "24",
   b"22",
   2014-02-02,
   2014-03-02 00:00:02+00
 },
 {
   13,
   false,
   9,
   9,
   4,
   8,
   -0.25,
   -0.75,
   "222",
   b"234",
   2014-05-02,
   2014-05-02 00:00:02+00
 },
 {
   14,
   true,
   13,
   23,
   31,
   32,
   -0.375,
   -0.375,
   "345",
   b"345",
   2014-01-06,
   2014-02-03 00:00:03+00
 },
 {
   15,
   false,
   -24,
   -14,
   41,
   54,
   -0.5,
   -0.5,
   "432",
   b"433",
   2014-02-04,
   2014-02-04 00:00:04+00
 },
 {
   16,
   false,
   NULL,
   -1,
   NULL,
   1,
   NULL,
   -0,
   NULL,
   b"1",
   NULL,
   2014-02-04 00:00:04+00
 },
 {17, NULL, -1, NULL, 1, NULL, 0, NULL, "1", NULL, 2014-02-04, NULL}]
==
[prepare_database]
CREATE TABLE TableEmpty AS SELECT val FROM (SELECT 1 as val) WHERE false
--
ARRAY<STRUCT<val INT64>>[]
==
[prepare_database]
CREATE TABLE TableLarge AS
SELECT CAST(1 AS int64) as row_id,
       CAST(NULL AS bool) as bool_val, CAST(NULL AS double) as double_val,
       CAST(NULL AS int64) as int64_val, CAST(NULL AS uint64) as uint64_val,
       CAST(NULL AS string) as str_val UNION ALL
  SELECT 2,  true,  NULL, NULL, NULL, NULL UNION ALL
  SELECT 3,  false, 0.2,  NULL, NULL, NULL UNION ALL
  SELECT 4,  true,  0.3,  3,    NULL, NULL UNION ALL
  SELECT 5,  false, 0.4,  4,    15, "4" UNION ALL
  SELECT 6,  true,  0.5,  5,    17, "5" UNION ALL
  SELECT 7,  false, 0.6,  6,    19,  "6" UNION ALL
  SELECT 8,  true,  0.7,  7,    21,  "7" UNION ALL
  SELECT 9,  false, 0.8,  8,    23, "8" UNION ALL
  SELECT 10, true,  0.9,  9,    25,  "9" UNION ALL
  SELECT 11, false, 1.0, 10,    27, "10" UNION ALL
  SELECT 12, true,  IEEE_DIVIDE(1, 0), 11, 29, "11" UNION ALL
  SELECT 13, false, IEEE_DIVIDE(-1, 0), 12, 31, "12" UNION ALL
  SELECT 14, true,  IEEE_DIVIDE(0, 0), 13, 33, "13"
--
ARRAY<STRUCT<row_id INT64,
             bool_val BOOL,
             double_val DOUBLE,
             int64_val INT64,
             uint64_val UINT64,
             str_val STRING>>
[
  {1, NULL, NULL, NULL, NULL, NULL},
  {2, true, NULL, NULL, NULL, NULL},
  {3, false, 0.2, NULL, NULL, NULL},
  {4, true, 0.3, 3, NULL, NULL},
  {5, false, 0.4, 4, 15, "4"},
  {6, true, 0.5, 5, 17, "5"},
  {7, false, 0.6, 6, 19, "6"},
  {8, true, 0.7, 7, 21, "7"},
  {9, false, 0.8, 8, 23, "8"},
  {10, true, 0.9, 9, 25, "9"},
  {11, false, 1, 10, 27, "10"},
  {12, true, inf, 11, 29, "11"},
  {13, false, -inf, 12, 31, "12"},
  {14, true, nan, 13, 33, "13"}
]
==
[prepare_database]
CREATE TABLE T AS
SELECT CAST(1 AS int64) as x, CAST("foo" AS string) as y UNION ALL
  SELECT 2, "bar"
--
ARRAY<STRUCT<x INT64, y STRING>>[{1, "foo"}, {2, "bar"}]
==
[prepare_database]
CREATE TABLE SumOverflow AS
SELECT CAST(1 AS int64) as row_id, 1.1e+308 double_val, 9223372036854775807 int64_val, 18446744073709551615 uint64_val
UNION ALL
SELECT CAST(2 AS int64) as row_id, 1.2e+308 double_val, 1 int64_val, CAST(1 AS uint64) uint64_val
--
ARRAY<STRUCT<row_id INT64, double_val DOUBLE, int64_val INT64, uint64_val UINT64>>[
  {1, 1.1e+308, 9223372036854775807, 18446744073709551615},
  {2, 1.2e+308, 1, 1}
]
==

# ----------------------------------------------------------------------------
# AVG
# ----------------------------------------------------------------------------
# No overflow due to double coercion of AVG argument. AVG can be implemented
# iteratively to avoid double overflows, so we aren't testing for presence or
# absence of those.
[name=aggregation_avg_1]
SELECT AVG(x) FROM (SELECT 9223372036854775807 x UNION ALL SELECT 1)
--
ARRAY<STRUCT<DOUBLE>>[{4.6116860184273879e+18}]
==
[name=aggregation_avg_2]
SELECT AVG(double_val) FROM TableLarge
--
ARRAY<STRUCT<DOUBLE>>[{nan}]
==
[name=aggregation_avg_3]
SELECT AVG(double_val) FROM TableLarge WHERE NOT IS_NAN(double_val)
--
ARRAY<STRUCT<DOUBLE>>[{nan}]
==
[name=aggregation_avg_4]
SELECT AVG(double_val) FROM TableLarge WHERE NOT IS_INF(double_val)
--
ARRAY<STRUCT<DOUBLE>>[{nan}]
==
[name=aggregation_avg_5]
SELECT AVG(double_val) FROM TableLarge WHERE NOT IS_INF(double_val) AND
  NOT IS_NAN(double_val)
--
ARRAY<STRUCT<DOUBLE>>[{0.60000000000000009}]
==
# Depending on implementation of AVG, feeding INF's to it may result in either
# INF (if only addition is used) or in NAN (if both addition and subtraction are
# used as in Knuth algorithm).
[name=aggregation_avg_6]
SELECT IS_INF(a) OR IS_NAN(a) FROM (
SELECT AVG(double_val) a FROM TableLarge WHERE double_val > 0)
--
ARRAY<STRUCT<BOOL>>[{true}]
==
[name=aggregation_avg_7]
SELECT AVG(int64_val) FROM TableLarge
--
ARRAY<STRUCT<DOUBLE>>[{8}]
==
[name=aggregation_avg_8]
SELECT AVG(uint64_val) FROM TableLarge
--
ARRAY<STRUCT<DOUBLE>>[{23.999999999999996}]
==
# Not using BETWEEN since it may not be supported. Approximate checking allows
# for different AVG algorithms.
[name=avg_aggregation_9]
SELECT AVG(double_val) > 0.599999 AND AVG(double_val) < 0.6000001 AS true1,
       AVG(int64_val)  > 6.499999 AND AVG(int64_val)  < 6.5000001 AS true2,
       AVG(uint64_val)  > 20.999999 AND AVG(uint64_val)  < 21.0000001 AS true3
FROM TableLarge WHERE NOT IS_INF(double_val) AND NOT IS_NAN(double_val)
--
ARRAY<STRUCT<true1 BOOL, true2 BOOL, true3 BOOL>>[{true, true, true}]
==
# AVG a table of all NULL values.
[name=aggregation_avg_10]
SELECT AVG(double_val) double_avg, AVG(uint64_val) uint64_avg,
       AVG(int64_val) int64_avg
FROM TableAllNull
--
ARRAY<STRUCT<double_avg DOUBLE, uint64_avg DOUBLE, int64_avg DOUBLE>>[
  {NULL, NULL, NULL}
]
==
# AVG with HAVING on NULL.
[name=aggregation_avg_having_null]
SELECT AVG(double_val) double_avg, AVG(uint64_val) uint64_avg,
       AVG(int64_val) int64_avg
FROM TableAllNull HAVING double_avg > 0.5
--
ARRAY<STRUCT<double_avg DOUBLE, uint64_avg DOUBLE, int64_avg DOUBLE>>[]
==
# AVG should work with GROUP BY.
[name=aggregation_avg_group_by]
SELECT bool_val, AVG(double_val) FROM TableLarge
  WHERE NOT IS_INF(double_val) AND NOT IS_NAN(double_val)
    GROUP BY bool_val ORDER BY bool_val
--
ARRAY<STRUCT<bool_val BOOL, DOUBLE>>[{false, 0.6}, {true, 0.6}]
==
# AVG should work with GROUP BY and HAVING.
[name=aggregation_avg_group_by_and_having_1]
SELECT bool_val, AVG(double_val) FROM TableLarge
  WHERE NOT IS_INF(double_val) AND NOT IS_NAN(double_val)
    GROUP BY bool_val HAVING bool_val ORDER BY bool_val
--
ARRAY<STRUCT<bool_val BOOL, DOUBLE>>[{true, 0.6}]
==
# AVG should work with GROUP BY and HAVING.
[name=aggregation_avg_group_by_and_having_2]
SELECT bool_val, AVG(double_val) double_avg FROM TableLarge
  WHERE NOT IS_INF(double_val) AND NOT IS_NAN(double_val)
    GROUP BY bool_val HAVING double_avg > 0.7 ORDER BY bool_val
--
ARRAY<STRUCT<bool_val BOOL, double_avg DOUBLE>>[]
==
# ----------------------------------------------------------------------------
# SUM
# ----------------------------------------------------------------------------
[name=aggregation_sum_1]
SELECT SUM(double_val) FROM TableLarge
--
ARRAY<STRUCT<DOUBLE>>[{nan}]
==
[name=aggregation_sum_2]
SELECT SUM(double_val) FROM TableLarge WHERE NOT IS_INF(double_val)
--
ARRAY<STRUCT<DOUBLE>>[{nan}]
==
[name=aggregation_sum_3]
SELECT SUM(double_val) FROM TableLarge WHERE double_val > 0
--
ARRAY<STRUCT<DOUBLE>>[{inf}]
==
[name=aggregation_sum_4]
SELECT SUM(double_val) double_sum, SUM(uint64_val) uint64_sum,
       SUM(int64_val) int64_sum
FROM TableLarge WHERE NOT IS_INF(double_val) AND NOT IS_NAN(double_val)
--
ARRAY<STRUCT<double_sum DOUBLE, uint64_sum UINT64, int64_sum INT64>>[
  {5.4, 147, 52}
]
==
# SUM a table of all NULL values.
[name=aggregation_sum_5]
SELECT SUM(double_val) double_sum, SUM(uint64_val) uint64_sum,
       SUM(int64_val) int64_sum
FROM TableAllNull
--
ARRAY<STRUCT<double_sum DOUBLE, uint64_sum UINT64, int64_sum INT64>>[
  {NULL, NULL, NULL}
]
==
# Overflow double.
[name=aggregation_sum_6]
SELECT SUM(double_val) FROM SumOverflow
--
ERROR: generic::out_of_range: double overflow
==
# Overflow int64.
[name=aggregation_sum_7]
SELECT SUM(int64_val) FROM SumOverflow
--
ERROR: generic::out_of_range: int64 overflow
==
# Overflow uint64.
[name=aggregation_sum_8]
SELECT SUM(uint64_val) FROM SumOverflow
--
ERROR: generic::out_of_range: uint64 overflow
==
# SUM should work with GROUP BY.
[name=aggregation_sum_group_by]
SELECT row_id, SUM(int64_val) int64_sum FROM TableLarge GROUP BY row_id
--
ARRAY<STRUCT<row_id INT64, int64_sum INT64>>[
  {1, NULL},
  {2, NULL},
  {3, NULL},
  {4, 3},
  {5, 4},
  {6, 5},
  {7, 6},
  {8, 7},
  {9, 8},
  {10, 9},
  {11, 10},
  {12, 11},
  {13, 12},
  {14, 13}
]
==
# SUM should work with GROUP BY and HAVING.
[name=aggregation_sum_group_by_and_having]
SELECT row_id, SUM(int64_val) int64_sum
FROM TableLarge GROUP BY row_id HAVING int64_sum IS NULL
--
ARRAY<STRUCT<row_id INT64, int64_sum INT64>>[{2, NULL}, {1, NULL}, {3, NULL}]
==
# ----------------------------------------------------------------------------
# COUNT
# ----------------------------------------------------------------------------
[name=aggregation_count_1]
SELECT COUNT(bool_val), COUNT(double_val), COUNT(float_val), COUNT(str_val),
       COUNT(int32_val), COUNT(uint32_val), COUNT(int64_val), COUNT(uint64_val),
       COUNT(date_val), COUNT(bytes_val), COUNT(timestamp_val)
  FROM TableAllTypes
--
ARRAY<STRUCT<INT64,
             INT64,
             INT64,
             INT64,
             INT64,
             INT64,
             INT64,
             INT64,
             INT64,
             INT64,
             INT64>>[{14, 15, 15, 14, 14, 14, 14, 14, 14, 14, 14}]
==
[name=aggregation_count_2]
SELECT COUNT(bool_val), COUNT(double_val), COUNT(float_val), COUNT(str_val),
       COUNT(int32_val), COUNT(uint32_val), COUNT(int64_val), COUNT(uint64_val),
       COUNT(date_val), COUNT(bytes_val), COUNT(timestamp_val)
FROM TableAllNull
--
ARRAY<STRUCT<INT64,
             INT64,
             INT64,
             INT64,
             INT64,
             INT64,
             INT64,
             INT64,
             INT64,
             INT64,
             INT64>>[{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}]
==
[name=aggregation_count_3]
SELECT COUNT(*) FROM TableAllTypes
--
ARRAY<STRUCT<INT64>>[{17}]
==
[name=aggregation_count_4]
SELECT COUNT(*) FROM TableAllNull
--
ARRAY<STRUCT<INT64>>[{1}]
==
[name=aggregation_count_5]
SELECT COUNT(bool_val) FROM TableAllNull
--
ARRAY<STRUCT<INT64>>[{0}]
==
[name=aggregation_count_6]
SELECT COUNT(*) FROM TableEmpty
--
ARRAY<STRUCT<INT64>>[{0}]
==
[name=aggregation_count_7]
SELECT COUNT(val) FROM TableEmpty
--
ARRAY<STRUCT<INT64>>[{0}]
==
# COUNT should work with GROUP BY
[name=aggregation_count_group_by]
SELECT int32_val, COUNT(double_val) FROM TableAllTypes GROUP BY int32_val
--
ARRAY<STRUCT<int32_val INT32, INT64>>[
  {NULL, 2},
  {-24, 1},
  {-4, 1},
  {-3, 1},
  {-2, 2},
  {-1, 3},
  {1, 1},
  {2, 1},
  {5, 1},
  {9, 1},
  {13, 1}
]
==
# COUNT should work with GROUP BY and HAVING
[name=aggregation_count_group_by_and_having]
SELECT bool_val, COUNT(double_val) FROM TableAllTypes GROUP BY bool_val HAVING bool_val ORDER BY bool_val

--
ARRAY<STRUCT<bool_val BOOL, INT64>>[{true, 6}]
==
[name=aggregation_count_arrays_1]
SELECT COUNT([1,2,3]) FROM (SELECT 1 UNION ALL SELECT 2)
--
ARRAY<STRUCT<INT64>>[{2}]
==
[name=aggregation_count_arrays_2]
SELECT COUNT(arr) FROM (SELECT ["foo", "bar"] arr UNION ALL SELECT NULL)
--
ARRAY<STRUCT<INT64>>[{1}]
==

# ----------------------------------------------------------------------------
# MAX, MIN
# ----------------------------------------------------------------------------
[name=timestamp_min_max]
SELECT min(ts), max(ts) FROM (
 SELECT TIMESTAMP '1955-01-01 12:00:15 UTC' as ts UNION ALL
 SELECT TIMESTAMP '2055-02-02 10:45:00 UTC')
--
ARRAY<STRUCT<TIMESTAMP, TIMESTAMP>>[
  {
    1955-01-01 12:00:15+00,
    2055-02-02 10:45:00+00
  }
]
==
[name=timestamp_NULL_min_max]
SELECT MAX(CAST(NULL AS TIMESTAMP)) AS max_NULL,
       MIN(CAST(NULL AS TIMESTAMP)) AS min_NULL
FROM (SELECT 1)
--
ARRAY<STRUCT<max_NULL TIMESTAMP, min_NULL TIMESTAMP>>[{NULL, NULL}]
==
[name=aggregation_min_max_1]
SELECT MIN(double_val), MAX(double_val) FROM TableLarge
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[{nan, nan}]
==
[name=aggregation_min_max_2]
SELECT MIN(double_val), MAX(double_val) FROM TableLarge WHERE
  NOT IS_INF(double_val)
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[{nan, nan}]
==
[name=aggregation_min_max_neg_inf_to_pos_inf]
SELECT MIN(double_val), MAX(double_val) FROM TableLarge WHERE
  NOT IS_NAN(double_val)
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[{-inf, inf}]
==
[name=aggregation_min_max_3]
SELECT MIN(double_val), MAX(double_val) FROM TableLarge WHERE double_val > 0
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[{0.2, inf}]
==
[name=aggregation_min_max_4]
SELECT MIN(double_val), MAX(double_val) FROM TableLarge WHERE double_val <= 0
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[{-inf, -inf}]
==
[name=aggregation_min_max_5]
SELECT MIN(double_val), MAX(double_val) FROM TableLarge WHERE
  NOT IS_INF(double_val) AND NOT IS_NAN(double_val)
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[{0.2, 1}]
==
[name=aggregation_min_max_6]
SELECT MIN(pos_inf), MAX(neg_inf) FROM
  (SELECT IEEE_DIVIDE(1, 0) pos_inf, IEEE_DIVIDE(-1, 0) neg_inf)
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[{inf, -inf}]
==
[name=aggregation_min_max_7]
SELECT min(x), max(x) FROM T
--
ARRAY<STRUCT<INT64, INT64>>[{1, 2}]
==
[name=aggregation_min_max_8]
SELECT MIN(bool_val), MIN(double_val), MIN(float_val), MIN(str_val),
       MIN(int32_val), MIN(uint32_val), MIN(int64_val), MIN(uint64_val),
       MIN(date_val), MIN(bytes_val), MIN(timestamp_val)
  FROM TableAllTypes
--
ARRAY<STRUCT<BOOL,
             DOUBLE,
             FLOAT,
             STRING,
             INT32,
             UINT32,
             INT64,
             UINT64,
             DATE,
             BYTES,
             TIMESTAMP>>
[{
   false,
   nan,
   nan,
   "1",
   -24,
   1,
   -14,
   1,
   2014-01-01,
   b"1",
   2014-01-01 00:00:01+00
 }]
==
[name=aggregation_min_max_9]
SELECT MIN(bool_val), MIN(double_val), MIN(float_val), MIN(str_val),
       MIN(int32_val), MIN(uint32_val), MIN(int64_val), MIN(uint64_val),
       MIN(date_val), MIN(bytes_val), MIN(timestamp_val)
FROM TableAllNull
--
ARRAY<STRUCT<BOOL,
             DOUBLE,
             FLOAT,
             STRING,
             INT32,
             UINT32,
             INT64,
             UINT64,
             DATE,
             BYTES,
             TIMESTAMP>>[
  {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}
]
==
[name=aggregation_min_max_10]
SELECT MAX(bool_val), MAX(double_val), MAX(float_val), MAX(str_val),
       MAX(int32_val), MAX(uint32_val), MAX(int64_val), MAX(uint64_val),
       MAX(date_val), MAX(bytes_val), MAX(timestamp_val)
  FROM TableAllTypes
--
ARRAY<STRUCT<BOOL,
             DOUBLE,
             FLOAT,
             STRING,
             INT32,
             UINT32,
             INT64,
             UINT64,
             DATE,
             BYTES,
             TIMESTAMP>>
[{
   true,
   nan,
   nan,
   "6",
   13,
   41,
   23,
   54,
   2014-05-02,
   b"7",
   2014-05-02 00:00:02+00
 }]
==
[name=aggregation_min_max_11]
SELECT MAX(bool_val), MAX(double_val), MAX(float_val), MAX(str_val),
       MAX(int32_val), MAX(uint32_val), MAX(int64_val), MAX(uint64_val),
       MAX(date_val), MAX(bytes_val), MAX(timestamp_val)
FROM TableAllNull
--
ARRAY<STRUCT<BOOL,
             DOUBLE,
             FLOAT,
             STRING,
             INT32,
             UINT32,
             INT64,
             UINT64,
             DATE,
             BYTES,
             TIMESTAMP>>[
  {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}
]
==
# MIN/MAX should work with GROUP BY
[name=aggregation_min_max_group_by]
SELECT MIN(int32_val), MAX(uint32_val), bool_val FROM TableAllTypes
  GROUP BY bool_val ORDER BY bool_val
--
ARRAY<STRUCT<INT32, UINT32, bool_val BOOL>>[
  {-1, 1, NULL},
  {-24, 41, false},
  {-3, 31, true}
]
==
# MIN/MAX should work with GROUP BY and HAVING
[name=aggregation_min_max_group_by_and_having]
SELECT MIN(int32_val), bool_val FROM TableAllTypes
  GROUP BY bool_val having MAX(uint32_val) > 30 ORDER BY bool_val
--
ARRAY<STRUCT<INT32, bool_val BOOL>>[{-24, false}, {-3, true}]
==
[name=aggregation_min_max_double_float_nan]
SELECT MIN(double_val), MAX(double_val), MIN(float_val), MAX(float_val)
FROM TableAllTypes
--
ARRAY<STRUCT<DOUBLE, DOUBLE, FLOAT, FLOAT>>[{nan, nan, nan, nan}]
==
[name=aggregation_min_max_double_inf]
SELECT MIN(double_val), MAX(double_val)
FROM TableAllTypes WHERE NOT IS_NAN(double_val)
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[{-inf, inf}]
==
[name=aggregation_min_max_float_inf]
SELECT  MIN(float_val), MAX(float_val)
FROM TableAllTypes WHERE NOT IS_NAN(float_val)
--
ARRAY<STRUCT<FLOAT, FLOAT>>[{-inf, inf}]
==
[name=aggregation_min_max_double]
SELECT MIN(double_val), MAX(double_val)
FROM TableAllTypes WHERE NOT IS_NAN(double_val) AND NOT IS_INF(double_val)
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[{-0.75, 0.625}]
==
[name=aggregation_min_max_float]
SELECT MIN(float_val), MAX(float_val)
FROM TableAllTypes WHERE NOT IS_NAN(float_val) AND NOT IS_INF(float_val)
--
ARRAY<STRUCT<FLOAT, FLOAT>>[{-0.5, 0.75}]
==
[name=aggregation_min_max_array_null_vs_nan]
[required_features=V_1_3_ARRAY_ORDERING]
SELECT MIN(a), MAX(a)
FROM (
  (
    SELECT ARRAY<FLOAT64>[NULL] AS a
  )
  UNION ALL
  (
    SELECT ARRAY<FLOAT64>[CAST("NaN" AS FLOAT64)] AS a
  )
)
--
ARRAY<STRUCT<ARRAY<>, ARRAY<>>>[{ARRAY<DOUBLE>[NULL], ARRAY<DOUBLE>[nan]}]
==

[name=aggregation_min_max_array_empty_vs_null]
[required_features=V_1_3_ARRAY_ORDERING]
SELECT MIN(a), MAX(a)
FROM (
  (
    SELECT ARRAY<INT64>[] AS a
  )
  UNION ALL
  (
    SELECT ARRAY<INT64>[NULL] AS a
  )
)
--
ARRAY<STRUCT<ARRAY<>, ARRAY<>>>[{ARRAY<INT64>[], ARRAY<INT64>[NULL]}]
==

[name=aggregation_min_max_array_empty_vs_nan]
[required_features=V_1_3_ARRAY_ORDERING]
SELECT MIN(a), MAX(a)
FROM (
  (
    SELECT ARRAY<FLOAT64>[] AS a
  )
  UNION ALL
  (
    SELECT ARRAY<FLOAT64>[CAST("NaN" AS FLOAT64)] AS a
  )
)
--
ARRAY<STRUCT<ARRAY<>, ARRAY<>>>[{ARRAY<DOUBLE>[], ARRAY<DOUBLE>[nan]}]
==

[name=aggregation_min_max_array_null_nan_appended]
[required_features=V_1_3_ARRAY_ORDERING]
SELECT MIN(a), MAX(a)
FROM (
  (
    SELECT ARRAY<FLOAT64>[1] AS a
  )
  UNION ALL
  (
    SELECT ARRAY<FLOAT64>[1, NULL] AS a
  )
    UNION ALL
  (
    SELECT ARRAY<FLOAT64>[1, CAST("NaN" AS FLOAT64)] AS a
  )
)
--
ARRAY<STRUCT<ARRAY<>, ARRAY<>>>[
  {
    ARRAY<DOUBLE>[1],
    ARRAY<DOUBLE>[1, nan]
  }
]
==

[name=aggregation_min_max_array_null_in_the_middle]
[required_features=V_1_3_ARRAY_ORDERING]
SELECT MIN(a), MAX(a)
FROM (
  (
    SELECT ARRAY<INT64>[1, NULL, 3] AS a
  )
  UNION ALL
  (
    SELECT ARRAY<INT64>[1, NULL, 2] AS a
  )
)
--
ARRAY<STRUCT<ARRAY<>, ARRAY<>>>[
  {
    ARRAY<INT64>[1, NULL, 2],
    ARRAY<INT64>[1, NULL, 3]
  }
]
==

[name=aggregation_min_max_array_nan_in_the_middle]
[required_features=V_1_3_ARRAY_ORDERING]
SELECT MIN(a), MAX(a)
FROM (
  (
    SELECT ARRAY<FLOAT64>[1, CAST("NaN" AS FLOAT64), 3] AS a
  )
  UNION ALL
  (
    SELECT ARRAY<FLOAT64>[1, CAST("NaN" AS FLOAT64), 2] AS a
  )
)
--
ARRAY<STRUCT<ARRAY<>, ARRAY<>>>[
  {
    ARRAY<DOUBLE>[1, nan, 2],
    ARRAY<DOUBLE>[1, nan, 3]
  }
]
==

[name=aggregation_min_max_array_null_nan_in_the_middle]
[required_features=V_1_3_ARRAY_ORDERING]
SELECT MIN(a), MAX(a)
FROM (
  (
    SELECT ARRAY<FLOAT64>[1, NULL, 3] AS a
  )
  UNION ALL
  (
    SELECT ARRAY<FLOAT64>[1, NULL, 2] AS a
  )
  UNION ALL
  (
    SELECT ARRAY<FLOAT64>[1, CAST("NaN" AS FLOAT64), 2] AS a
  )
)
--
ARRAY<STRUCT<ARRAY<>, ARRAY<>>>[
  {
    ARRAY<DOUBLE>[1, NULL, 2],
    ARRAY<DOUBLE>[1, nan, 2]
  }
]
==

[name=aggregation_min_max_array_null_nan_vs_positive_inf]
[required_features=V_1_3_ARRAY_ORDERING]
SELECT MIN(a), MAX(a)
FROM (
  (
    SELECT ARRAY<FLOAT64>[1, CAST("+Inf" AS FLOAT64)] AS a
  )
  UNION ALL
  (
    SELECT ARRAY<FLOAT64>[1, NULL, 2] AS a
  )
  UNION ALL
  (
    SELECT ARRAY<FLOAT64>[1, CAST("NaN" AS FLOAT64), 2] AS a
  )
)
--
ARRAY<STRUCT<ARRAY<>, ARRAY<>>>[
  {
    ARRAY<DOUBLE>[1, NULL, 2],
    ARRAY<DOUBLE>[1, inf]
  }
]
==
[name=aggregation_min_max_array_null_nan_vs_negative_inf]
[required_features=V_1_3_ARRAY_ORDERING]
SELECT MIN(a), MAX(a)
FROM (
  (
    SELECT ARRAY<FLOAT64>[1, CAST("-Inf" AS FLOAT64)] AS a
  )
  UNION ALL
  (
    SELECT ARRAY<FLOAT64>[1, NULL, 2] AS a
  )
  UNION ALL
  (
    SELECT ARRAY<FLOAT64>[1, CAST("NaN" AS FLOAT64), 2] AS a
  )
)
--
ARRAY<STRUCT<ARRAY<>, ARRAY<>>>[
  {
    ARRAY<DOUBLE>[1, NULL, 2],
    ARRAY<DOUBLE>[1, -inf]
  }
]
==
# ----------------------------------------------------------------------------
# ARRAY_AGG
# ----------------------------------------------------------------------------
# ARRAY_AGG on zero rows produces NULL array.
[name=aggregation_array_agg_1]
SELECT ARRAY_AGG(val) FROM TableEmpty
--
ARRAY<STRUCT<ARRAY<>>>[{ARRAY<INT64>(NULL)}]
==
# ARRAY_AGG on NULLs produces array of NULLs.
[name=aggregation_array_agg_2]
SELECT ARRAY_AGG(bool_val), ARRAY_AGG(double_val), ARRAY_AGG(float_val),
       ARRAY_AGG(str_val), ARRAY_AGG(int32_val), ARRAY_AGG(uint32_val),
       ARRAY_AGG(int64_val), ARRAY_AGG(uint64_val), ARRAY_AGG(date_val),
       ARRAY_AGG(bytes_val), ARRAY_AGG(timestamp_val)
FROM TableAllNull
--
ARRAY<STRUCT<ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>>>
[{
   ARRAY<BOOL>[NULL],
   ARRAY<DOUBLE>[NULL],
   ARRAY<FLOAT>[NULL],
   ARRAY<STRING>[NULL],
   ARRAY<INT32>[NULL],
   ARRAY<UINT32>[NULL],
   ARRAY<INT64>[NULL],
   ARRAY<UINT64>[NULL],
   ARRAY<DATE>[NULL],
   ARRAY<BYTES>[NULL],
   ARRAY<TIMESTAMP>[NULL]
 }]
==
[name=aggregation_array_agg_3]
SELECT array_agg(x), array_agg(y) FROM T
--
ARRAY<STRUCT<ARRAY<>, ARRAY<>>>[
  {
    ARRAY<INT64>[2, 1],
    ARRAY<STRING>["bar", "foo"]
  }
]
==
[name=aggregation_array_agg_4]
SELECT ARRAY_AGG(bool_val), ARRAY_AGG(double_val), ARRAY_AGG(float_val),
       ARRAY_AGG(str_val), ARRAY_AGG(int32_val), ARRAY_AGG(uint32_val),
       ARRAY_AGG(int64_val), ARRAY_AGG(uint64_val), ARRAY_AGG(date_val),
       ARRAY_AGG(bytes_val), ARRAY_AGG(timestamp_val)
FROM TableAllTypes
--
ARRAY<STRUCT<ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>,
             ARRAY<>>>
[
  {
    ARRAY<BOOL>[true,
                false,
                true,
                NULL,
                true,
                false,
                true,
                false,
                true,
                true,
                false,
                false,
                NULL,
                false,
                false,
                false,
                NULL],
    ARRAY<DOUBLE>[inf,
                  0,
                  0.375,
                  NULL,
                  0.625,
                  -0.25,
                  -0.375,
                  -0,
                  0.125,
                  -inf,
                  0.25,
                  0.5,
                  nan,
                  -0.125,
                  -0.75,
                  -0.5,
                  NULL],
    ARRAY<FLOAT>[nan,
                 0.25,
                 0.375,
                 NULL,
                 0.625,
                 0.75,
                 -0.375,
                 NULL,
                 0.125,
                 inf,
                 -inf,
                 0.5,
                 -0,
                 -0.125,
                 -0.25,
                 -0.5,
                 0],
    ARRAY<STRING>["1",
                  "2",
                  "3",
                  NULL,
                  "6",
                  "24",
                  "345",
                  NULL,
                  "1",
                  "1",
                  "2",
                  "4",
                  NULL,
                  "123",
                  "222",
                  "432",
                  "1"],
    ARRAY<INT32>[-1,
                 -2,
                 -3,
                 NULL,
                 1,
                 2,
                 13,
                 NULL,
                 -1,
                 -1,
                 -2,
                 -4,
                 NULL,
                 5,
                 9,
                 -24,
                 -1],
    ARRAY<UINT32>[1, 2, 3, NULL, 11, 5, 31, NULL, 1, 1, 2, 4, NULL, 11, 4, 41, 1],
    ARRAY<INT64>[-1,
                 -2,
                 -3,
                 NULL,
                 1,
                 16,
                 23,
                 -1,
                 -1,
                 -1,
                 -2,
                 -4,
                 NULL,
                 3,
                 9,
                 -14,
                 NULL],
    ARRAY<UINT64>[1, 2, 3, NULL, 11, 9, 32, 1, 1, 1, 2, 4, NULL, 8, 8, 54, NULL],
    ARRAY<DATE>[2014-01-01,
                2014-01-02,
                2014-01-03,
                NULL,
                2014-01-08,
                2014-02-02,
                2014-01-06,
                NULL,
                2014-01-01,
                2014-01-01,
                2014-01-02,
                2014-01-04,
                NULL,
                2014-02-01,
                2014-05-02,
                2014-02-04,
                2014-02-04],
    ARRAY<BYTES>[b"1",
                 b"2",
                 b"3",
                 NULL,
                 b"7",
                 b"22",
                 b"345",
                 b"1",
                 b"1",
                 b"1",
                 b"2",
                 b"4",
                 NULL,
                 b"123",
                 b"234",
                 b"433",
                 NULL],
    ARRAY<TIMESTAMP>[
      2014-01-01 00:00:01+00,
      2014-01-02 00:00:02+00,
      2014-01-03 00:00:03+00,
      NULL,
      2014-01-07 00:00:01+00,
      2014-03-02 00:00:02+00,
      2014-02-03 00:00:03+00,
      2014-02-04 00:00:04+00,
      2014-01-01 00:00:01+00,
      2014-01-01 00:00:01+00,
      2014-01-02 00:00:02+00,
      2014-01-04 00:00:04+00,
      NULL,
      2014-03-01 00:00:01+00,
      2014-05-02 00:00:02+00,
      2014-02-04 00:00:04+00,
      NULL
    ]
  }
]
==
# ARRAY_AGG works with GROUP BY
[name=aggregation_array_agg_group_by]
SELECT ARRAY_AGG(bool_val), row_id FROM TableAllTypes GROUP BY row_id
--
ARRAY<STRUCT<ARRAY<>, row_id INT64>>[
  {ARRAY<BOOL>[true], 1},
  {ARRAY<BOOL>[true], 2},
  {ARRAY<BOOL>[true], 3},
  {ARRAY<BOOL>[false], 4},
  {ARRAY<BOOL>[false], 5},
  {ARRAY<BOOL>[true], 6},
  {ARRAY<BOOL>[false], 7},
  {ARRAY<BOOL>[NULL], 8},
  {ARRAY<BOOL>[NULL], 9},
  {ARRAY<BOOL>[true], 10},
  {ARRAY<BOOL>[false], 11},
  {ARRAY<BOOL>[false], 12},
  {ARRAY<BOOL>[false], 13},
  {ARRAY<BOOL>[true], 14},
  {ARRAY<BOOL>[false], 15},
  {ARRAY<BOOL>[false], 16},
  {ARRAY<BOOL>[NULL], 17}
]
==
[required_features=JSON_TYPE]
[name=aggregation_array_agg_json]
SELECT ARRAY_AGG(val) FROM (
SELECT JSON '{"a": 10}' val UNION ALL
SELECT JSON 'null' UNION ALL
SELECT CAST(NULL AS JSON) UNION ALL
SELECT JSON '10')
--
ARRAY<STRUCT<ARRAY<>>>[{ARRAY<JSON>[null, 10, {"a":10}, NULL]}]
==
# ----------------------------------------------------------------------------
# ARRAY_AGG over empty input produces NULL
# ----------------------------------------------------------------------------
[name=array_agg_empty_input]
SELECT array_agg(x) FROM T WHERE x < 0
--
ARRAY<STRUCT<ARRAY<>>>[{ARRAY<INT64>(NULL)}]
==

# ----------------------------------------------------------------------------
# ARRAY_AGG preserves NULLs in the input
# ----------------------------------------------------------------------------
[name=array_agg_all_NULLs]
SELECT array_agg(x) FROM ((SELECT NULL x) UNION ALL (SELECT NULL))
--
ARRAY<STRUCT<ARRAY<>>>[{ARRAY<INT64>[NULL, NULL]}]
==

[name=array_agg_mix_NULL_and_nonNULLs]
SELECT array_agg(x) FROM ((SELECT "foo" x) UNION ALL (SELECT NULL))
--
ARRAY<STRUCT<ARRAY<>>>[{ARRAY<STRING>[NULL, "foo"]}]
==


# ----------------------------------------------------------------------------
# Misc
# ----------------------------------------------------------------------------
# DISTINCT aggregation of atomic values
[name=aggregation_12]
SELECT COUNT(a) count_all,
       COUNT(DISTINCT a) count_distinct,
       MIN(a) min_all,
       MIN(DISTINCT a) min_distinct,
       MAX(a) max_all,
       MAX(DISTINCT a) max_distinct,
       AVG(a) avg_all,
       AVG(DISTINCT a) avg_distinct,
       ARRAY_AGG(a) agg_all,
       ARRAY_AGG(DISTINCT a) agg_distinct
FROM (SELECT 1 a UNION ALL SELECT 1 UNION ALL SELECT 2)
--
ARRAY<STRUCT<count_all INT64,
             count_distinct INT64,
             min_all INT64,
             min_distinct INT64,
             max_all INT64,
             max_distinct INT64,
             avg_all DOUBLE,
             avg_distinct DOUBLE,
             agg_all ARRAY<>,
             agg_distinct ARRAY<>>>
[{
   3,
   2,
   1,
   1,
   2,
   2,
   1.3333333333333333,
   1.5,
   ARRAY<INT64>[1, 1, 2],
   ARRAY<INT64>[1, 2]
 }]
==
# Aggregation of struct values
[name=aggregation_13]
SELECT COUNT(t) count_all,
       ARRAY_AGG(t) agg_all
FROM (SELECT 1 a UNION ALL SELECT 1 UNION ALL SELECT 2),
     UNNEST(ARRAY(SELECT AS STRUCT a AS x, a AS y)) t
--
ARRAY<STRUCT<count_all INT64, agg_all ARRAY<>>>[
  {
    3,
    ARRAY<STRUCT<x INT64, y INT64>>[{1, 1}, {1, 1}, {2, 2}]
  }
]
==
# Aggregation of 0 rows
[name=aggregation_14]
SELECT COUNT(a) count_all,
       COUNT(DISTINCT a) count_distinct,
       MIN(a) min_all,
       MIN(DISTINCT a) min_distinct,
       MAX(a) max_all,
       MAX(DISTINCT a) max_distinct,
       AVG(a) avg_all,
       AVG(DISTINCT a) avg_distinct,
       ARRAY_AGG(a) agg_all,
       ARRAY_AGG(DISTINCT a) agg_distinct,
       STRING_AGG(c) str_agg_unary,
       STRING_AGG(c, ", ") str_agg_binary,
       STRING_AGG(d) bytes_agg_unary,
       STRING_AGG(d, b", ") bytes_agg_binary
FROM (SELECT 1 a, 2 b, "foo" c, b"bar" d) WHERE a > b
--
ARRAY<STRUCT<
        count_all INT64,
        count_distinct INT64,
        min_all INT64,
        min_distinct INT64,
        max_all INT64,
        max_distinct INT64,
        avg_all DOUBLE,
        avg_distinct DOUBLE,
        agg_all ARRAY<>,
        agg_distinct ARRAY<>,
        str_agg_unary STRING,
        str_agg_binary STRING,
        bytes_agg_unary BYTES,
        bytes_agg_binary BYTES
      >>
[{0,
  0,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  ARRAY<INT64>(NULL),
  ARRAY<INT64>(NULL),
  NULL,
  NULL,
  NULL,
  NULL}]
==
[name=scalar_aggregate_where_false]
SELECT subq.c1
FROM (SELECT MIN(t.c1) c1
      FROM (SELECT 1 c1) t) subq
WHERE false;
--
ARRAY<STRUCT<c1 INT64>>[]
==
# Regression test for b/134139834 (for the PreparedQuery API, which runs with
# analyzer column pruning).
[name=aggregation_input_scan_column_pruning]
SELECT 1
FROM (SELECT 1 AS key, 10 AS value UNION ALL
      SELECT 2, 20)
GROUP BY (key + 1)
--
ARRAY<STRUCT<INT64>>[{1}, {1}]
==
# ----------------------------------------------------------------------------
# STRING_AGG
# ----------------------------------------------------------------------------
# string_agg on two strings: 'foo' and 'bar'. Note that the order of the
# elements is unspecified.
[name=aggregation_string_agg_1]
SELECT string_agg(y) IN ("bar,foo", "foo,bar"),
       string_agg(y, " : ") IN ("bar : foo", "foo : bar")
FROM T
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==
[name=aggregation_string_agg_2]
SELECT string_agg(CAST(y as bytes)) IN (b"bar,foo", b"foo,bar"),
       string_agg(CAST(y as bytes), b"<->") IN (b"bar<->foo", b"foo<->bar")
FROM T
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==
# string_agg with NULL values and several non-NULL values. Note that the order
# of the elements in the output string is non-deterministic.
[name=aggregation_string_agg_3]
SELECT string_agg(x) IN ("a,c,d", "a,d,c", "c,a,d", "c,d,a", "d,a,c", "d,c,a"),
       string_agg(x, "|") IN ("a|c|d", "a|d|c", "c|a|d", "c|d|a", "d|a|c",
                              "d|c|a")
FROM (SELECT "a" x UNION ALL SELECT NULL UNION ALL
      SELECT "c" UNION ALL SELECT "d")
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==
# string_agg on bytes with NULL values and several non-NULL values, as above.
[name=aggregation_string_agg_4]
SELECT string_agg(CAST(x as bytes)) IN (b"a,c,d", b"a,d,c", b"c,a,d", b"c,d,a",
                                        b"d,a,c", b"d,c,a"),
       string_agg(CAST(x as bytes), b"|") IN (b"a|c|d", b"a|d|c", b"c|a|d",
                                              b"c|d|a", b"d|a|c", b"d|c|a")
FROM (SELECT "a" x UNION ALL SELECT NULL UNION ALL
      SELECT "c" UNION ALL SELECT "d")
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==
# string_agg on string with a single value
[name=aggregation_string_agg_5]
SELECT string_agg(x), string_agg(x, ", ")
FROM (SELECT NULL x UNION ALL SELECT "a" UNION ALL SELECT NULL)
--
ARRAY<STRUCT<STRING, STRING>>[{"a", "a"}]
==
# string_agg on bytes with a single value
[name=aggregation_string_agg_6]
SELECT string_agg(CAST(x as bytes)), string_agg(CAST(x as bytes), b", ")
FROM (SELECT NULL x UNION ALL SELECT "a" UNION ALL SELECT NULL)
--
ARRAY<STRUCT<BYTES, BYTES>>[{b"a", b"a"}]
==
[name=string_agg_data_contains_delimiter]
SELECT STRING_AGG(x) FROM ((SELECT "f,oo" as x) UNION ALL (SELECT "f,oo"))
--
ARRAY<STRUCT<STRING>>[{"f,oo,f,oo"}]
==

# string_agg on string with NULL separator gives error
[name=aggregation_string_agg_error_1]
SELECT string_agg("s", NULL) FROM (SELECT 1)
--
ERROR: generic::invalid_argument: Argument 2 to STRING_AGG must be non-NULL [at 1:24]
SELECT string_agg("s", NULL) FROM (SELECT 1)
                       ^
==

# string_agg on string with NULL separator gives error
[name=aggregation_string_agg_error_1_null_param]
[parameters=NULL as separator]
SELECT string_agg("s", @separator) FROM (SELECT 1)
--
ERROR: generic::invalid_argument: No matching signature for aggregate function STRING_AGG for argument types: STRING, INT64. Supported signatures: STRING_AGG(STRING); STRING_AGG(STRING, STRING); STRING_AGG(BYTES); STRING_AGG(BYTES, BYTES) [at 1:8]
SELECT string_agg("s", @separator) FROM (SELECT 1)
       ^
==

# string_agg on string with NULL separator gives error
[name=aggregation_string_agg_error_1_null_string_param]
[parameters=cast(NULL as string) as separator]
SELECT string_agg("s", @separator) FROM (SELECT 1)
--
ERROR: generic::invalid_argument: Illegal NULL separator in STRING_AGG
==

# string_agg on bytes with NULL separator gives error
[name=aggregation_string_agg_error_2]
SELECT string_agg(b"b", NULL) FROM (SELECT 1)
--
ERROR: generic::invalid_argument: Argument 2 to STRING_AGG must be non-NULL [at 1:25]
SELECT string_agg(b"b", NULL) FROM (SELECT 1)
                        ^
==

# string_agg on bytes with NULL separator gives error
[name=aggregation_string_agg_error_2_null_bytes_param]
[parameters=cast(NULL as bytes) as separator]
SELECT string_agg(b"b", @separator) FROM (SELECT 1)
--
ERROR: generic::invalid_argument: Illegal NULL separator in STRING_AGG
==

# ----------------------------------------------------------------------------
# BIT_AND
# ----------------------------------------------------------------------------
[name=aggregation_23]
SELECT bit_and(CAST(x as int32)) FROM (SELECT 1 x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<INT32>>[{NULL}]
==
[name=aggregation_24]
SELECT bit_and(CAST(x as int64)) FROM (SELECT 1 x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<INT64>>[{NULL}]
==
[name=aggregation_25]
SELECT bit_and(CAST(x as uint32)) FROM (SELECT 1 x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<UINT32>>[{NULL}]
==
[name=aggregation_26]
SELECT bit_and(CAST(x as uint64)) FROM (SELECT 1 x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<UINT64>>[{NULL}]
==
[name=aggregation_27]
SELECT bit_and(x) FROM (SELECT CAST(NULL AS int32) x);
--
ARRAY<STRUCT<INT32>>[{NULL}]
==
[name=aggregation_28]
SELECT bit_and(x) FROM (SELECT CAST(NULL AS int64) x);
--
ARRAY<STRUCT<INT64>>[{NULL}]
==
[name=aggregation_29]
SELECT bit_and(x) FROM (SELECT CAST(NULL AS uint32) x);
--
ARRAY<STRUCT<UINT32>>[{NULL}]
==
[name=aggregation_30]
SELECT bit_and(x) FROM (SELECT CAST(NULL AS uint64) x);
--
ARRAY<STRUCT<UINT64>>[{NULL}]
==
[name=aggregation_31]
SELECT bit_and(CAST(x as int32)) FROM (SELECT 5 x);
--
ARRAY<STRUCT<INT32>>[{5}]
==
[name=aggregation_32]
SELECT bit_and(CAST(x as int64)) FROM (SELECT 5 x);
--
ARRAY<STRUCT<INT64>>[{5}]
==
[name=aggregation_33]
SELECT bit_and(CAST(x as uint32)) FROM (SELECT 5 x);
--
ARRAY<STRUCT<UINT32>>[{5}]
==
[name=aggregation_34]
SELECT bit_and(CAST(x as uint64)) FROM (SELECT 5 x);
--
ARRAY<STRUCT<UINT64>>[{5}]
==
[name=aggregation_35]
SELECT bit_and(CAST(x as int32)) FROM
(SELECT NULL x UNION ALL SELECT 5 UNION ALL SELECT 6);
--
ARRAY<STRUCT<INT32>>[{4}]
==
[name=aggregation_36]
SELECT bit_and(CAST(x as int64)) FROM
(SELECT NULL x UNION ALL SELECT 5 UNION ALL SELECT 6);
--
ARRAY<STRUCT<INT64>>[{4}]
==
[name=aggregation_37]
SELECT bit_and(CAST(x as uint32)) FROM
(SELECT NULL x UNION ALL SELECT 5 UNION ALL SELECT 6);
--
ARRAY<STRUCT<UINT32>>[{4}]
==
[name=aggregation_38]
SELECT bit_and(CAST(x as uint64)) FROM
(SELECT NULL x UNION ALL SELECT 5 UNION ALL SELECT 6);
--
ARRAY<STRUCT<UINT64>>[{4}]
==
# BIT_AND should work with GROUP BY.
[name=aggregation_39]
SELECT id, bit_and(x) FROM
(SELECT "a" id, 3 x UNION ALL SELECT "a", 5 UNION ALL
 SELECT "b" id, 5 x UNION ALL SELECT "b", 6)
GROUP BY id
--
ARRAY<STRUCT<id STRING, INT64>>[{"a", 1}, {"b", 4}]
==

# ----------------------------------------------------------------------------
# BIT_OR
# ----------------------------------------------------------------------------
[name=aggregation_40]
SELECT bit_or(CAST(x as int32)) FROM (SELECT 1 x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<INT32>>[{NULL}]
==
[name=aggregation_41]
SELECT bit_or(CAST(x as int64)) FROM (SELECT 1 x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<INT64>>[{NULL}]
==
[name=aggregation_42]
SELECT bit_or(CAST(x as uint32)) FROM (SELECT 1 x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<UINT32>>[{NULL}]
==
[name=aggregation_43]
SELECT bit_or(CAST(x as uint64)) FROM (SELECT 1 x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<UINT64>>[{NULL}]
==
[name=aggregation_44]
SELECT bit_or(x) FROM (SELECT CAST(NULL AS int32) x);
--
ARRAY<STRUCT<INT32>>[{NULL}]
==
[name=aggregation_45]
SELECT bit_or(x) FROM (SELECT CAST(NULL AS int64) x);
--
ARRAY<STRUCT<INT64>>[{NULL}]
==
[name=aggregation_46]
SELECT bit_or(x) FROM (SELECT CAST(NULL AS uint32) x);
--
ARRAY<STRUCT<UINT32>>[{NULL}]
==
[name=aggregation_47]
SELECT bit_or(x) FROM (SELECT CAST(NULL AS uint64) x);
--
ARRAY<STRUCT<UINT64>>[{NULL}]
==
[name=aggregation_48]
SELECT bit_or(CAST(x as int32)) FROM (SELECT 5 x);
--
ARRAY<STRUCT<INT32>>[{5}]
==
[name=aggregation_49]
SELECT bit_or(CAST(x as int64)) FROM (SELECT 5 x);
--
ARRAY<STRUCT<INT64>>[{5}]
==
[name=aggregation_50]
SELECT bit_or(CAST(x as uint32)) FROM (SELECT 5 x);
--
ARRAY<STRUCT<UINT32>>[{5}]
==
[name=aggregation_51]
SELECT bit_or(CAST(x as uint64)) FROM (SELECT 5 x);
--
ARRAY<STRUCT<UINT64>>[{5}]
==
[name=aggregation_52]
SELECT bit_or(CAST(x as int32)) FROM
(SELECT NULL x UNION ALL SELECT 5 UNION ALL SELECT 6);
--
ARRAY<STRUCT<INT32>>[{7}]
==
[name=aggregation_53]
SELECT bit_or(CAST(x as int64)) FROM
(SELECT NULL x UNION ALL SELECT 5 UNION ALL SELECT 6);
--
ARRAY<STRUCT<INT64>>[{7}]
==
[name=aggregation_54]
SELECT bit_or(CAST(x as uint32)) FROM
(SELECT NULL x UNION ALL SELECT 5 UNION ALL SELECT 6);
--
ARRAY<STRUCT<UINT32>>[{7}]
==
[name=aggregation_55]
SELECT bit_or(CAST(x as uint64)) FROM
(SELECT NULL x UNION ALL SELECT 5 UNION ALL SELECT 6);
--
ARRAY<STRUCT<UINT64>>[{7}]
==
# BIT_OR should work with GROUP BY.
[name=aggregation_56]
SELECT id, bit_or(x) FROM
(SELECT "a" id, 3 x UNION ALL SELECT "a", 5 UNION ALL
 SELECT "b" id, 5 x UNION ALL SELECT "b", 6)
GROUP BY id
--
ARRAY<STRUCT<id STRING, INT64>>[{"a", 7}, {"b", 7}]
==

# ----------------------------------------------------------------------------
# BIT_XOR
# ----------------------------------------------------------------------------
[name=aggregation_57]
SELECT bit_xor(CAST(x as int32)) FROM (SELECT 1 x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<INT32>>[{NULL}]
==
[name=aggregation_58]
SELECT bit_xor(CAST(x as int64)) FROM (SELECT 1 x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<INT64>>[{NULL}]
==
[name=aggregation_59]
SELECT bit_xor(CAST(x as uint32)) FROM (SELECT 1 x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<UINT32>>[{NULL}]
==
[name=aggregation_60]
SELECT bit_xor(CAST(x as uint64)) FROM (SELECT 1 x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<UINT64>>[{NULL}]
==
[name=aggregation_61]
SELECT bit_xor(x) FROM (SELECT CAST(NULL AS int32) x);
--
ARRAY<STRUCT<INT32>>[{NULL}]
==
[name=aggregation_62]
SELECT bit_xor(x) FROM (SELECT CAST(NULL AS int64) x);
--
ARRAY<STRUCT<INT64>>[{NULL}]
==
[name=aggregation_63]
SELECT bit_xor(x) FROM (SELECT CAST(NULL AS uint32) x);
--
ARRAY<STRUCT<UINT32>>[{NULL}]
==
[name=aggregation_64]
SELECT bit_xor(x) FROM (SELECT CAST(NULL AS uint64) x);
--
ARRAY<STRUCT<UINT64>>[{NULL}]
==
[name=aggregation_65]
SELECT bit_xor(CAST(x as int32)) FROM (SELECT 5 x);
--
ARRAY<STRUCT<INT32>>[{5}]
==
[name=aggregation_66]
SELECT bit_xor(CAST(x as int64)) FROM (SELECT 5 x);
--
ARRAY<STRUCT<INT64>>[{5}]
==
[name=aggregation_67]
SELECT bit_xor(CAST(x as uint32)) FROM (SELECT 5 x);
--
ARRAY<STRUCT<UINT32>>[{5}]
==
[name=aggregation_68]
SELECT bit_xor(CAST(x as uint64)) FROM (SELECT 5 x);
--
ARRAY<STRUCT<UINT64>>[{5}]
==
[name=aggregation_69]
SELECT bit_xor(CAST(x as int32)) FROM
(SELECT NULL x UNION ALL SELECT 5 UNION ALL SELECT 6);
--
ARRAY<STRUCT<INT32>>[{3}]
==
[name=aggregation_70]
SELECT bit_xor(CAST(x as int64)) FROM
(SELECT NULL x UNION ALL SELECT 5 UNION ALL SELECT 6);
--
ARRAY<STRUCT<INT64>>[{3}]
==
[name=aggregation_71]
SELECT bit_xor(CAST(x as uint32)) FROM
(SELECT NULL x UNION ALL SELECT 5 UNION ALL SELECT 6);
--
ARRAY<STRUCT<UINT32>>[{3}]
==
[name=aggregation_72]
SELECT bit_xor(CAST(x as uint64)) FROM
(SELECT NULL x UNION ALL SELECT 5 UNION ALL SELECT 6);
--
ARRAY<STRUCT<UINT64>>[{3}]
==
# BIT_XOR should work with GROUP BY.
[name=aggregation_73]
SELECT id, bit_xor(x) FROM
(SELECT "a" id, 3 x UNION ALL SELECT "a", 5 UNION ALL
 SELECT "b" id, 5 x UNION ALL SELECT "b", 6)
GROUP BY id
--
ARRAY<STRUCT<id STRING, INT64>>[{"a", 6}, {"b", 3}]
==

# ----------------------------------------------------------------------------
# LOGICAL_AND
# ----------------------------------------------------------------------------
[name=aggregation_74]
SELECT logical_and(x) FROM (SELECT true x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<BOOL>>[{NULL}]
==
[name=aggregation_75]
SELECT logical_and(x) FROM (SELECT CAST(NULL AS bool) x);
--
ARRAY<STRUCT<BOOL>>[{NULL}]
==
[name=aggregation_76]
SELECT logical_and(x) FROM (SELECT true x);
--
ARRAY<STRUCT<BOOL>>[{true}]
==
[name=aggregation_77]
SELECT logical_and(x) FROM (SELECT false x);
--
ARRAY<STRUCT<BOOL>>[{false}]
==
[name=aggregation_78]
SELECT logical_and(x) FROM (SELECT NULL x UNION ALL SELECT true);
--
ARRAY<STRUCT<BOOL>>[{true}]
==
[name=aggregation_79]
SELECT logical_and(x) FROM (SELECT NULL x UNION ALL SELECT false);
--
ARRAY<STRUCT<BOOL>>[{false}]
==
[name=aggregation_80]
SELECT logical_and(x) FROM
(SELECT NULL x UNION ALL SELECT true UNION ALL SELECT false);
--
ARRAY<STRUCT<BOOL>>[{false}]
==
[name=aggregation_81]
SELECT logical_and(x) FROM
(SELECT NULL x UNION ALL SELECT true UNION ALL SELECT true);
--
ARRAY<STRUCT<BOOL>>[{true}]
==
[name=aggregation_82]
SELECT logical_and(x) FROM
(SELECT NULL x UNION ALL SELECT false UNION ALL SELECT false);
--
ARRAY<STRUCT<BOOL>>[{false}]
==
# LOGICAL_AND should work with GROUP BY.
[name=aggregation_83]
SELECT id, logical_and(x) FROM
(SELECT "a" id, true x UNION ALL SELECT "a", false UNION ALL
 SELECT "b" id, true x UNION ALL SELECT "b", true UNION ALL
 SELECT "c" id, false x UNION ALL SELECT "c", false)
GROUP BY id
--
ARRAY<STRUCT<id STRING, BOOL>>[{"a", false}, {"b", true}, {"c", false}]
==

# ----------------------------------------------------------------------------
# LOGICAL_OR
# ----------------------------------------------------------------------------
[name=aggregation_84]
SELECT logical_or(x) FROM (SELECT true x FROM (SELECT 1) WHERE false);
--
ARRAY<STRUCT<BOOL>>[{NULL}]
==
[name=aggregation_85]
SELECT logical_or(x) FROM (SELECT CAST(NULL AS bool) x);
--
ARRAY<STRUCT<BOOL>>[{NULL}]
==
[name=aggregation_86]
SELECT logical_or(x) FROM (SELECT true x);
--
ARRAY<STRUCT<BOOL>>[{true}]
==
[name=aggregation_87]
SELECT logical_or(x) FROM (SELECT false x);
--
ARRAY<STRUCT<BOOL>>[{false}]
==
[name=aggregation_88]
SELECT logical_or(x) FROM (SELECT NULL x UNION ALL SELECT true);
--
ARRAY<STRUCT<BOOL>>[{true}]
==
[name=aggregation_89]
SELECT logical_or(x) FROM (SELECT NULL x UNION ALL SELECT false);
--
ARRAY<STRUCT<BOOL>>[{false}]
==
[name=aggregation_90]
SELECT logical_or(x) FROM
(SELECT NULL x UNION ALL SELECT true UNION ALL SELECT false);
--
ARRAY<STRUCT<BOOL>>[{true}]
==
[name=aggregation_91]
SELECT logical_or(x) FROM
(SELECT NULL x UNION ALL SELECT true UNION ALL SELECT true);
--
ARRAY<STRUCT<BOOL>>[{true}]
==
[name=aggregation_92]
SELECT logical_or(x) FROM
(SELECT NULL x UNION ALL SELECT false UNION ALL SELECT false);
--
ARRAY<STRUCT<BOOL>>[{false}]
==
# LOGICAL_OR should work with GROUP BY.
[name=aggregation_93]
SELECT id, logical_or(x) FROM
(SELECT "a" id, true x UNION ALL SELECT "a", false UNION ALL
 SELECT "b" id, true x UNION ALL SELECT "b", true UNION ALL
 SELECT "c" id, false x UNION ALL SELECT "c", false)
GROUP BY id
--
ARRAY<STRUCT<id STRING, BOOL>>[{"a", true}, {"b", true}, {"c", false}]
==

# ----------------------------------------------------------------------------
# ANY_VALUE
# ----------------------------------------------------------------------------
[name=aggregation_any_value_1]
SELECT any_value(x) FROM (select 2 as x)
--
ARRAY<STRUCT<INT64>>[{2}]
==
[name=aggregation_any_value_2]
SELECT ANY_VALUE(bool_val), ANY_VALUE(double_val), ANY_VALUE(float_val),
       ANY_VALUE(str_val), ANY_VALUE(int32_val), ANY_VALUE(uint32_val),
       ANY_VALUE(int64_val), ANY_VALUE(uint64_val), ANY_VALUE(date_val),
       ANY_VALUE(bytes_val), ANY_VALUE(timestamp_val)
  FROM TableOneValue
--
ARRAY<STRUCT<BOOL,
             DOUBLE,
             FLOAT,
             STRING,
             INT32,
             UINT32,
             INT64,
             UINT64,
             DATE,
             BYTES,
             TIMESTAMP>>
[{
   true,
   1,
   1,
   "1",
   1,
   1,
   1,
   1,
   2001-01-01,
   b"1",
   2001-01-01 00:00:00+00
 }]
==
[name=aggregation_any_value_array_struct_proto]
SELECT any_value(array_val), any_value(struct_val), any_value(proto_val) FROM (
  SELECT [1, 2, 3] as array_val,
         STRUCT(1 as int_field, 'foo' as str_field) as struct_val,
         NEW zetasql_test__.TestNullabilityInnerPB(1 as required_field,
                                                   2 as optional_field)
         as proto_val)
--
ARRAY<STRUCT<
        ARRAY<>,
        STRUCT<int_field INT64, str_field STRING>,
        PROTO<zetasql_test__.TestNullabilityInnerPB>
      >>
[{ARRAY<INT64>[1, 2, 3],
  {1, "foo"},
  {
    required_field: 1
    optional_field: 2
  }}]
==
[name=aggregation_any_value_3]
SELECT ANY_VALUE(bool_val), ANY_VALUE(double_val), ANY_VALUE(float_val),
       ANY_VALUE(str_val), ANY_VALUE(int32_val), ANY_VALUE(uint32_val),
       ANY_VALUE(int64_val), ANY_VALUE(uint64_val), ANY_VALUE(date_val),
       ANY_VALUE(bytes_val), ANY_VALUE(timestamp_val)
  FROM TableAllNull
--
ARRAY<STRUCT<BOOL,
             DOUBLE,
             FLOAT,
             STRING,
             INT32,
             UINT32,
             INT64,
             UINT64,
             DATE,
             BYTES,
             TIMESTAMP>>[
  {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}
]
==
# ANY_VALUE should work with GROUP BY
[name=aggregation_any_value_group_by]
SELECT bool_val, ANY_VALUE(double_val) FROM TableOneValue GROUP BY bool_val ORDER BY bool_val
--
ARRAY<STRUCT<bool_val BOOL, DOUBLE>>[{true, 1}]
==
[name=aggregation_any_value_empty]
SELECT ANY_VALUE(val) FROM TableEmpty
--
ARRAY<STRUCT<INT64>>[{NULL}]
==
[name=aggregation_any_value_double_INF]
SELECT ANY_VALUE(double_val) IN (CAST("Inf" AS float), CAST("-Inf" AS float))
FROM TableAllTypes WHERE IS_INF(double_val)
--
ARRAY<STRUCT<BOOL>>[{true}]
==
[name=aggregation_any_value_float_INF]
SELECT ANY_VALUE(float_val) IN (CAST("Inf" AS float), CAST("-Inf" AS float))
FROM TableAllTypes WHERE IS_INF(float_val)
--
ARRAY<STRUCT<BOOL>>[{true}]
==
[name=aggregation_any_value_double_NaN]
SELECT ANY_VALUE(double_val) FROM TableAllTypes WHERE IS_NAN(double_val)
--
ARRAY<STRUCT<DOUBLE>>[{nan}]
==
[name=aggregation_any_value_float_NaN]
SELECT ANY_VALUE(float_val) FROM TableAllTypes WHERE IS_NAN(float_val)
--
ARRAY<STRUCT<FLOAT>>[{nan}]
==
[name=aggregation_any_value_array]
SELECT any_value([1]) FROM (select 2)
--
ARRAY<STRUCT<ARRAY<>>>[{ARRAY<INT64>[1]}]
==
[required_features=BIGNUMERIC_TYPE]
[name=aggregation_any_value_numeric]
SELECT ANY_VALUE(x) FROM (
SELECT BIGNUMERIC '1e2' x UNION ALL
SELECT BIGNUMERIC '1e2')
--
ARRAY<STRUCT<BIGNUMERIC>>[{100}]
==
[required_features=JSON_TYPE]
[name=aggregation_any_value_json]
SELECT ANY_VALUE(x) FROM (
SELECT JSON '{"a": 10}' x UNION ALL
SELECT JSON '{"a": 10}')
--
ARRAY<STRUCT<JSON>>[{{"a":10}}]
==
[required_features=JSON_TYPE]
[name=aggregation_any_value_null_json]
SELECT ANY_VALUE(x) FROM (
SELECT CAST(NULL AS JSON) x)
--
ARRAY<STRUCT<JSON>>[{NULL}]
==

# ----------------------------------------------------------------------------
# AGGREGATING EMPTY TABLE (ZERO ROWS)
# ----------------------------------------------------------------------------
[name=aggregation_zero_rows_1]
SELECT COUNT(val), COUNT(*), SUM(val), AVG(val), MIN(val), MAX(val),
       ANY_VALUE(val), ARRAY_AGG(val), BIT_AND(val), BIT_OR(val), BIT_XOR(val),
       LOGICAL_AND(CAST(val AS bool)), LOGICAL_OR(CAST(val AS bool)),
       STRING_AGG(CAST(val AS string)), STRING_AGG(CAST(val AS string), "X")
FROM TableEmpty
--
ARRAY<STRUCT<INT64,
             INT64,
             INT64,
             DOUBLE,
             INT64,
             INT64,
             INT64,
             ARRAY<>,
             INT64,
             INT64,
             INT64,
             BOOL,
             BOOL,
             STRING,
             STRING>>
[{0,
  0,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  ARRAY<INT64>(NULL),
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL}]
==
# @nan_01 and @nan02 are both nans with different bitwise representation.
[name=count_distinct_nan_different_bitwise_representation]
[parameters=CAST(b"\x08\x00\x10\x00\x49\x01\x00\x00\x00\x00\x00\xf0\x7f" as zetasql_test__.KitchenSinkPB).double_val as nan_01, CAST(b"\x08\x00\x10\x00\x49\x02\x00\x00\x00\x00\x00\xf0\x7f" as zetasql_test__.KitchenSinkPB).double_val as nan_02]
SELECT COUNT(DISTINCT A) FROM UNNEST([@nan_01, @nan_02]) AS A;
--
ARRAY<STRUCT<INT64>>[{1}]
