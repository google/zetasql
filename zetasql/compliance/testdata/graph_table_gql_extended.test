[default reserve_graph_table]
[default required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[load_proto_files=zetasql/testdata/test_schema.proto]
[load_proto_names=zetasql_test__.KitchenSinkPB]
[prepare_database]
CREATE TABLE person AS
(SELECT 1 AS id, "name1" AS name) UNION ALL
(SELECT 2 AS id, "name2" AS name) UNION ALL
(SELECT 3 as id, "name3" AS name)
--
ARRAY<STRUCT<id INT64, name STRING>>[{1, "name1"}, {2, "name2"}, {3, "name3"}]
==
[prepare_database]
CREATE TABLE person_knows_person AS
(SELECT 100 AS id, 1 AS from_person_id, 1 AS to_person_id, TIMESTAMP '2000-01-01 00:00:00' AS since) UNION ALL
(SELECT 200 AS id, 1 AS from_person_id, 2 AS to_person_id, TIMESTAMP '2000-01-02 00:00:00' AS since) UNION ALL
(SELECT 300 AS id, 2 AS from_person_id, 1 AS to_person_id, TIMESTAMP '2000-01-03 00:00:00' AS since)
--
ARRAY<STRUCT<id INT64, from_person_id INT64, to_person_id INT64, since TIMESTAMP>>[
  {
    100,
    1,
    1,
    2000-01-01 08:00:00+00
  },
  {
    200,
    1,
    2,
    2000-01-02 08:00:00+00
  },
  {
    300,
    2,
    1,
    2000-01-03 08:00:00+00
  }
]
==
[prepare_database]
CREATE TABLE account AS
(SELECT 10 AS acct_id, cast('''
  int64_key_1: 1
  int64_key_2: 1
''' as `zetasql_test__.KitchenSinkPB`) AS owner_id, "checking" AS kind
) UNION ALL
(SELECT 20 AS acct_id, cast('''
  int64_key_1: 1
  int64_key_2: 1
''' as `zetasql_test__.KitchenSinkPB`) AS owner_id, "savings" AS kind
) UNION ALL
(SELECT 30 AS acct_id, cast('''
  int64_key_1: 2
  int64_key_2: 2
''' as `zetasql_test__.KitchenSinkPB`) AS owner_id, "checking" AS kind
)UNION ALL
(SELECT 40 AS acct_id, cast('''
  int64_key_1: 2
  int64_key_2: 2
''' as `zetasql_test__.KitchenSinkPB`) AS owner_id, "savings" as kind)
--
ARRAY<STRUCT<
        acct_id INT64,
        owner_id PROTO<zetasql_test__.KitchenSinkPB>,
        kind STRING
      >>
[{10,
  {
    int64_key_1: 1
    int64_key_2: 1
  },
  "checking"},
 {20,
  {
    int64_key_1: 1
    int64_key_2: 1
  },
  "savings"},
 {30,
  {
    int64_key_1: 2
    int64_key_2: 2
  },
  "checking"},
 {40,
  {
    int64_key_1: 2
    int64_key_2: 2
  },
  "savings"}]
==

[prepare_database]
CREATE TABLE transfer AS
(SELECT 1 AS id, 10 AS from_account_id, 20 AS to_account_id, 100 AS amount) UNION ALL
(SELECT 2 AS id, 10 AS from_account_id, 20 AS to_account_id, 200 AS amount) UNION ALL
(SELECT 3 AS id, 20 AS from_account_id, 30 AS to_account_id, 300 AS amount) UNION ALL
(SELECT 4 AS id, 20 AS from_account_id, 30 AS to_account_id, 400 AS amount) UNION ALL
(SELECT 5 AS id, 30 AS from_account_id, 10 AS to_account_id, 500 AS amount) UNION ALL
(SELECT 6 AS id, 10 AS from_account_id, 10 AS to_account_id, 600 AS amount)
--
ARRAY<STRUCT<
        id INT64,
        from_account_id INT64,
        to_account_id INT64,
        amount INT64
      >>
[{1, 10, 20, 100},
 {2, 10, 20, 200},
 {3, 20, 30, 300},
 {4, 20, 30, 400},
 {5, 30, 10, 500},
 {6, 10, 10, 600}]
==
[prepare_database]
CREATE TABLE login AS
(SELECT 1 AS person_id, 10 AS account_id, TIMESTAMP "2023-01-01 00:00:00 UTC" AS timestamp) UNION ALL
(SELECT 2 AS person_id, 30 AS account_id, TIMESTAMP "2023-01-04 00:00:00 UTC" AS timestamp)
--
ARRAY<STRUCT<person_id INT64, account_id INT64, timestamp TIMESTAMP>>[
  {
    1,
    10,
    2023-01-01 00:00:00+00
  },
  {
    2,
    30,
    2023-01-04 00:00:00+00
  }
]
==
# This edge table is "compressed". Each row represents M*N edges from M nodes
# to N nodes.
[prepare_database]
CREATE TABLE can_transfer AS
(SELECT "checking" AS src_acct_kind, "savings" AS dest_acct_kind)
--
ARRAY<STRUCT<
        src_acct_kind STRING,
        dest_acct_kind STRING
      >>[{"checking", "savings"}]
==
[prepare_database]
CREATE PROPERTY GRAPH aml
  NODE TABLES (
    Account KEY(acct_id)
    DEFAULT LABEL PROPERTIES(
      1000 + acct_id AS account_id,
      owner_id AS owner_id_proto,
      owner_id.int64_key_1 AS owner_id,
      kind AS account_kind)
    LABEL HasId PROPERTIES (acct_id AS key_id),
    Person KEY(id)
    LABEL Human PROPERTIES(
      100 AS id,
      name)
    LABEL HasId PROPERTIES (id as key_id))
  EDGE TABLES (
    person_knows_person AS Knows KEY(id)
              SOURCE KEY(from_person_id) REFERENCES Person(id)
              DESTINATION KEY(to_person_id) REFERENCES Person(id)
              DEFAULT LABEL PROPERTIES(since),
    Transfer KEY(id, from_account_id, to_account_id)
              SOURCE KEY(from_account_id) REFERENCES Account(acct_id)
              DESTINATION KEY(to_account_id) REFERENCES Account(acct_id)
              DEFAULT LABEL PROPERTIES(amount),
    Login KEY(person_id, account_id, timestamp)
          SOURCE KEY(person_id) REFERENCES Person(id)
          DESTINATION KEY(account_id) REFERENCES Account(acct_id)
          DEFAULT LABEL PROPERTIES(timestamp),
    can_transfer AS CanTransfer KEY(src_acct_kind, dest_acct_kind)
                  SOURCE KEY(src_acct_kind) REFERENCES Account(kind)
                  DESTINATION KEY(dest_acct_kind) REFERENCES Account(kind)
                  LABEL can_transfer
  )
==
[name=single_match_with_return_operation]
select * from graph_table(aml
  MATCH (a IS Account Where a.account_id = 1010) (-[t1 IS Transfer]-> (b) -[t2 IS Transfer]-> WHERE t1.amount*2 > t2.amount) (c),
        (c) -[t3 IS Transfer]-> (a)
  WHERE t1.amount + t2.amount = t3.amount
  return a.account_id as aid, t1.amount as amount1, b.account_id as bid, t2.amount as amount2, c.account_id as cid, t3.amount as amount3, a.account_id as aid2
)
ORDER BY 1,3,5,7,2,4,6
--
ARRAY<STRUCT<aid INT64,
             amount1 INT64,
             bid INT64,
             amount2 INT64,
             cid INT64,
             amount3 INT64,
             aid2 INT64>>[{1010, 200, 1020, 300, 1030, 500, 1010}]
==
[name=optional_match]
select * from graph_table(aml
  MATCH (a IS Account Where a.account_id = 1010)
  OPTIONAL MATCH (a)-[t1 IS Transfer]->(b)
  return a.account_id as aid, b.account_id as bid, t1.amount
)
ORDER BY 1,2,3
--
ARRAY<STRUCT<aid INT64, bid INT64, amount INT64>>[known order:
  {1010, 1010, 600},
  {1010, 1020, 100},
  {1010, 1020, 200}
]
==
[name=optional_match2]
select * from graph_table(aml
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  return p.name, a.account_id as aid
)
ORDER BY 1,2
--
ARRAY<STRUCT<name STRING, aid INT64>>[known order:
  {"name1", 1010},
  {"name2", 1030},
  {"name3", NULL}
]
==
[name=optional_match3]
select * from graph_table(aml
  MATCH (a:Account)
  OPTIONAL MATCH (a)-[t IS TRANSFER]->(b)
  return a.account_id as aid, b.account_id as bid, t.amount as amount
)
ORDER BY 1,2,3
--
ARRAY<STRUCT<aid INT64, bid INT64, amount INT64>>[known order:
  {1010, 1010, 600},
  {1010, 1020, 100},
  {1010, 1020, 200},
  {1020, 1030, 300},
  {1020, 1030, 400},
  {1030, 1010, 500},
  {1040, NULL, NULL}
]
==
[name=optional_match4]
select * from graph_table(aml
  MATCH (a:Account)
  OPTIONAL MATCH (a)-[t IS TRANSFER]->(b)
  OPTIONAL MATCH (b)-[t2 IS TRANSFER]->(c)
  return a.account_id as aid, b.account_id as bid, c.account_id as cid, t.amount as first_amount, t2.amount as second_amount
)
ORDER BY 1,2,3,4,5
--
ARRAY<STRUCT<aid INT64,
             bid INT64,
             cid INT64,
             first_amount INT64,
             second_amount INT64>>
[known order:
  {1010, 1010, 1010, 600, 600},
  {1010, 1010, 1020, 600, 100},
  {1010, 1010, 1020, 600, 200},
  {1010, 1020, 1030, 100, 300},
  {1010, 1020, 1030, 100, 400},
  {1010, 1020, 1030, 200, 300},
  {1010, 1020, 1030, 200, 400},
  {1020, 1030, 1010, 300, 500},
  {1020, 1030, 1010, 400, 500},
  {1030, 1010, 1010, 500, 600},
  {1030, 1010, 1020, 500, 100},
  {1030, 1010, 1020, 500, 200},
  {1040, NULL, NULL, NULL, NULL}
]
==
[name=optional_match_multiply_declared_variables]
select * from graph_table(aml
  MATCH (a:HasId)
  OPTIONAL MATCH (id:HasId)-(a)-(id:Human)
  return a.key_id, id.name
)
ORDER BY 1,2
--
ARRAY<STRUCT<key_id INT64, name STRING>>[known order:
  {1, "name1"},
  {1, "name2"},
  {1, "name2"},
  {1, "name2"},
  {1, "name2"},
  {2, "name1"},
  {2, "name1"},
  {2, "name1"},
  {2, "name1"},
  {3, NULL},
  {10, "name1"},
  {20, NULL},
  {30, "name2"},
  {40, NULL}
]

==
[name=optional_match_multiply_declared_variables2]
select * from graph_table(aml
  MATCH (a:HasId)
  OPTIONAL MATCH (id:HasId)->(a), (b)->(id:Human)
  return a.key_id, id.name
)
ORDER BY 1,2
--
ARRAY<STRUCT<key_id INT64, name STRING>>[known order:
  {1, "name1"},
  {1, "name1"},
  {1, "name2"},
  {2, "name1"},
  {2, "name1"},
  {3, NULL},
  {10, "name1"},
  {10, "name1"},
  {20, NULL},
  {30, "name2"},
  {40, NULL}
]

==
[name=linear_queries_without_consecutive_match]
select * from graph_table(aml
  MATCH (a) (<-[k IS Knows]- WHERE true)
  RETURN a, k
  NEXT
  MATCH ((b) <-[k IS Knows]- (a)), (b) <-[IS Knows]- (b)
  RETURN a.name as person_name, k.since, b.name as friend_name
)
order by 1, 2, 3
--
ARRAY<STRUCT<person_name STRING, since TIMESTAMP, friend_name STRING>>[
  {
    "name1",
    2000-01-01 08:00:00+00,
    "name1"
  }
]
==
[name=consecutive_match_across_linear_queries]
select * from graph_table(aml
  MATCH (a IS Account Where a.account_id = 1010)
  MATCH (a) (-[t1 IS Transfer]-> (b) -[t2 IS Transfer]-> WHERE t1.amount*2 > t2.amount) (c)
  RETURN *
  NEXT
  MATCH (a) -[t1 IS Transfer]-> (b), (b) (-[t2 IS Transfer]->) (c) WHERE t1.amount*2 > t2.amount
  RETURN a, b, c, t1, t2
  NEXT
  MATCH (c) -[t3 IS Transfer]-> (a) WHERE t1.amount + t2.amount = t3.amount
  return a.account_id as aid, t1.amount as amount1, b.account_id as bid, t2.amount as amount2, c.account_id as cid, t3.amount as amount3, a.account_id as aid2
  NEXT
  RETURN *
)
ORDER BY 1,3,5,7,2,4,6
--
ARRAY<STRUCT<aid INT64,
             amount1 INT64,
             bid INT64,
             amount2 INT64,
             cid INT64,
             amount3 INT64,
             aid2 INT64>>[{1010, 200, 1020, 300, 1030, 500, 1010}]
==
# same as above, replacing RETURN ... NEXT ... by WITH
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_RETURN_EXTENSIONS]
[name=consecutive_match_across_linear_queries_using_with]
select * from graph_table(aml
  MATCH (a IS Account Where a.account_id = 1010)
  MATCH (a) (-[t1 IS Transfer]-> (b) -[t2 IS Transfer]-> WHERE t1.amount*2 > t2.amount) (c)
  WITH *
  MATCH (a) -[t1 IS Transfer]-> (b), (b) (-[t2 IS Transfer]->) (c) WHERE t1.amount*2 > t2.amount
  WITH a, b, c, t1, t2
  MATCH (c) -[t3 IS Transfer]-> (a) WHERE t1.amount + t2.amount = t3.amount
  WITH a.account_id as aid, t1.amount as amount1, b.account_id as bid, t2.amount as amount2, c.account_id as cid, t3.amount as amount3, a.account_id as aid2
  RETURN *
)
ORDER BY 1,3,5,7,2,4,6
--
ARRAY<STRUCT<aid INT64,
             amount1 INT64,
             bid INT64,
             amount2 INT64,
             cid INT64,
             amount3 INT64,
             aid2 INT64>>[{1010, 200, 1020, 300, 1030, 500, 1010}]
==
[name=consecutive_match_within_linear_query]
select * from graph_table(aml
  MATCH (a) -[t1 IS Transfer]-> (b)
  MATCH ((b) (-[t2 IS Transfer]-) (c)) Where a.account_id = c.account_id
  MATCH (c IS Account) -[t3 IS Transfer]-> (a)
  RETURN *
  NEXT
  RETURN a.account_id as aid, t1.amount as amount1, b.account_id as bid, t2.amount as amount2, c.account_id as cid, t3.amount as amount3, a.account_id as aid2
)
ORDER BY 1,3,5,7,2,4,6
--
ARRAY<STRUCT<aid INT64,
             amount1 INT64,
             bid INT64,
             amount2 INT64,
             cid INT64,
             amount3 INT64,
             aid2 INT64>>
[known order:
  {1010, 600, 1010, 600, 1010, 600, 1010},
  {1010, 100, 1020, 100, 1010, 600, 1010},
  {1010, 100, 1020, 200, 1010, 600, 1010},
  {1010, 200, 1020, 100, 1010, 600, 1010},
  {1010, 200, 1020, 200, 1010, 600, 1010}
]
==
[name=casting_graph_element_keeping_all_results]
select * from graph_table(aml
  MATCH (a IS Account)
  MATCH (a)
  RETURN a.name
)
order by 1
--
ARRAY<STRUCT<name STRING>>[known order:{NULL}, {NULL}, {NULL}, {NULL}]
==
[name=casting_graph_element_empty_result]
select * from graph_table(aml
  MATCH (a IS Account)
  MATCH (a IS Human)
  RETURN a.name
)
--
ARRAY<STRUCT<name STRING>>[]
==
[name=nested_linear_query]
select * from graph_table(aml
  MATCH (a) -[t1 IS Transfer]-> (b)
  MATCH ((b) (-[t2 IS Transfer]-) (c)) Where a.account_id = c.account_id AND EXISTS(
                                                                                select account_id from graph_table (
                                                                                  aml MATCH (x) WHERE SAME(x, a)
                                                                                  RETURN x.account_id
                                                                                ) limit 1
                                                                             )
  MATCH (c IS Account) -[t3 IS Transfer]-> (a)
  RETURN *
  NEXT
  RETURN a.account_id as aid, t1.amount as amount1, b.account_id as bid, t2.amount as amount2, c.account_id as cid, t3.amount as amount3, a.account_id as aid2, (
      select amount from graph_table (
        aml MATCH -[e]-> WHERE SAME(e, t1)
        RETURN e.amount
      ) limit 1
    ) AS sth
)
ORDER BY 1,3,5,7,2,4,6,8
--
ARRAY<STRUCT<aid INT64,
             amount1 INT64,
             bid INT64,
             amount2 INT64,
             cid INT64,
             amount3 INT64,
             aid2 INT64,
             sth INT64>>
[known order:
  {1010, 600, 1010, 600, 1010, 600, 1010, 600},
  {1010, 100, 1020, 100, 1010, 600, 1010, 100},
  {1010, 100, 1020, 200, 1010, 600, 1010, 100},
  {1010, 200, 1020, 100, 1010, 600, 1010, 200},
  {1010, 200, 1020, 200, 1010, 600, 1010, 200}
]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_EXPOSE_GRAPH_ELEMENT]
[name=optional_columns_return_graph_element]
select a.account_id as aid, t1.amount as amount1, b.account_id as bid, t2.amount as amount2, c.account_id as cid, t3.amount as amount3, a.account_id as aid2 from graph_table(aml
  MATCH (a IS Account Where a.account_id = 1010) (-[t1 IS Transfer]-> (b) -[t2 IS Transfer]-> WHERE t1.amount*2 > t2.amount) (c),
        (c) -[t3 IS Transfer]-> (a)
  WHERE t1.amount + t2.amount = t3.amount
  return a, b, c, t1, t2, t3
)
ORDER BY 1,3,5,7,2,4,6
--
ARRAY<STRUCT<aid INT64,
             amount1 INT64,
             bid INT64,
             amount2 INT64,
             cid INT64,
             amount3 INT64,
             aid2 INT64>>[{1010, 200, 1020, 300, 1030, 500, 1010}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=property_specification]
SELECT * FROM GRAPH_TABLE(aml
  MATCH (a IS Account {account_id: 1010}) -[t1 IS Transfer {amount: 600}]-> (b IS Account)
  WHERE t1.amount > 100
  RETURN a.owner_id AS sender_id, a.account_kind, t1.amount, b.owner_id AS receiver_id
)
order by 1,2,3,4
--
ARRAY<STRUCT<sender_id INT64, account_kind STRING, amount INT64, receiver_id INT64>>[
  {1, "checking", 600, 1}
]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_GROUP_BY_ALL]
[name=aggregation1]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  RETURN a1.account_id as a1_id, a2.account_id as a2_id, COUNT(*) as count
    GROUP BY ALL
) gt
ORDER BY a1_id, a2_id, count
--
ARRAY<STRUCT<a1_id INT64, a2_id INT64, count INT64>>[known order:
  {1010, 1010, 1},
  {1010, 1020, 2},
  {1020, 1030, 2},
  {1030, 1010, 1}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_RETURN_EXTENSIONS]
[name=aggregation_with1]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  WITH a1.account_id as a1_id, a2.account_id as a2_id, COUNT(*) as count
  RETURN *
) gt
ORDER BY a1_id, a2_id, count
--
ARRAY<STRUCT<a1_id INT64, a2_id INT64, count INT64>>[known order:
  {1010, 1010, 1},
  {1010, 1020, 2},
  {1020, 1030, 2},
  {1030, 1010, 1}
]

==
[name=aggregation2]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  RETURN SUM(t1.amount) as total_amount
) gt
order by 1
--
ARRAY<STRUCT<total_amount INT64>>[{2100}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_RETURN_EXTENSIONS]
[name=aggregation_with2]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  WITH SUM(t1.amount) as total_amount
  RETURN *
) gt
order by 1
--
ARRAY<STRUCT<total_amount INT64>>[{2100}]

==
[name=aggregation3]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  RETURN DISTINCT a1.account_id as a1_id, a2.account_id as a2_id, t1.amount as amount
) gt
ORDER BY a1_id, a2_id, amount
--
ARRAY<STRUCT<a1_id INT64, a2_id INT64, amount INT64>>[known order:
  {1010, 1010, 600},
  {1010, 1020, 100},
  {1010, 1020, 200},
  {1020, 1030, 300},
  {1020, 1030, 400},
  {1030, 1010, 500}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_RETURN_EXTENSIONS]
[name=aggregation_with3]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  WITH DISTINCT a1.account_id as a1_id, a2.account_id as a2_id, t1.amount as amount
  RETURN *
) gt
ORDER BY a1_id, a2_id, amount
--
ARRAY<STRUCT<a1_id INT64, a2_id INT64, amount INT64>>[known order:
  {1010, 1010, 600},
  {1010, 1020, 100},
  {1010, 1020, 200},
  {1020, 1030, 300},
  {1020, 1030, 400},
  {1030, 1010, 500}
]

==
[name=aggregation4]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  RETURN ALL a1.account_id as a1_id, a2.account_id as a2_id
    GROUP BY a1, a2
) gt
ORDER BY a1_id, a2_id
--
ARRAY<STRUCT<a1_id INT64, a2_id INT64>>[known order:
  {1010, 1010},
  {1010, 1020},
  {1020, 1030},
  {1030, 1010}
]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_RETURN_EXTENSIONS]
[name=aggregation_with4]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  WITH ALL a1.account_id as a1_id, a2.account_id as a2_id
    GROUP BY a1, a2
  RETURN *
) gt
ORDER BY a1_id, a2_id
--
ARRAY<STRUCT<a1_id INT64, a2_id INT64>>[known order:
  {1010, 1010},
  {1010, 1020},
  {1020, 1030},
  {1030, 1010}
]

==
[name=aggregation5]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  RETURN a1.account_id as a1_id, a2.account_id as a2_id, SUM(t1.amount) as total_amount
    GROUP BY a1_id, a2_id
) gt
ORDER BY a1_id, a2_id, total_amount
--
ARRAY<STRUCT<a1_id INT64, a2_id INT64, total_amount INT64>>[known order:
  {1010, 1010, 600},
  {1010, 1020, 300},
  {1020, 1030, 700},
  {1030, 1010, 500}
]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_RETURN_EXTENSIONS]
[name=aggregation_with5]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  WITH a1.account_id as a1_id, a2.account_id as a2_id, SUM(t1.amount) as total_amount
    GROUP BY a1_id, a2_id
  RETURN *
) gt
ORDER BY a1_id, a2_id, total_amount
--
ARRAY<STRUCT<a1_id INT64, a2_id INT64, total_amount INT64>>[known order:
  {1010, 1010, 600},
  {1010, 1020, 300},
  {1020, 1030, 700},
  {1030, 1010, 500}
]

==
[name=aggregation6]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  RETURN DISTINCT ARRAY_AGG(a1.account_id)[OFFSET(0)] as first_id
    GROUP BY a1, t1, a2
) gt
ORDER BY first_id
--
ARRAY<STRUCT<first_id INT64>>[known order:{1010}, {1020}, {1030}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_RETURN_EXTENSIONS]
[name=aggregation_with6]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  WITH DISTINCT ARRAY_AGG(a1.account_id)[OFFSET(0)] as first_id
    GROUP BY a1, t1, a2
  RETURN *
) gt
ORDER BY first_id
--
ARRAY<STRUCT<first_id INT64>>[known order:{1010}, {1020}, {1030}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_1_HAVING_IN_AGGREGATE]
[name=aggregation7]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  LET x = t1.amount
  RETURN DISTINCT a1.account_id as a1_id, a2.account_id as a2_id, SUM(t1.amount HAVING MIN x)+MAX(x+10)-10 as norm_amount
    GROUP BY a1_id, a2_id
) gt
ORDER BY a1_id, a2_id, norm_amount
--
ARRAY<STRUCT<a1_id INT64, a2_id INT64, norm_amount INT64>>[known order:
  {1010, 1010, 1200},
  {1010, 1020, 300},
  {1020, 1030, 700},
  {1030, 1010, 1000}
]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_1_HAVING_IN_AGGREGATE,V_1_4_SQL_GRAPH_RETURN_EXTENSIONS]
[name=aggregation_with7]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2:Account)
  LET x = t1.amount
  WITH DISTINCT a1.account_id as a1_id, a2.account_id as a2_id, SUM(t1.amount HAVING MIN x)+MAX(x+10)-10 as norm_amount
    GROUP BY a1_id, a2_id
  RETURN *
) gt
ORDER BY a1_id, a2_id, norm_amount
--
ARRAY<STRUCT<a1_id INT64, a2_id INT64, norm_amount INT64>>[known order:
  {1010, 1010, 1200},
  {1010, 1020, 300},
  {1020, 1030, 700},
  {1030, 1010, 1000}
]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_GROUP_BY_ALL]
[name=aggregation8]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2)
  MATCH (a2:Account)-[t2:Transfer]->(a3)
  FILTER a1 != a2
  RETURN DISTINCT a1.account_id as a1_id, a2.account_id as a2_id, a3.account_id as a3_id, t1.amount as t1_amount, t2.amount as t2_amount
    GROUP BY ALL
  NEXT
  RETURN *
  NEXT
  RETURN ALL a1_id, a2_id, ARRAY_AGG(t1_amount) as arr
    GROUP BY a1_id,a2_id
) gt
ORDER BY a1_id, a2_id
--
ARRAY<STRUCT<a1_id INT64, a2_id INT64, arr ARRAY<>>>[known order:
  {
    1010,
    1020,
    ARRAY<INT64>[unknown order:200, 200, 100, 100]
  },
  {
    1020,
    1030,
    ARRAY<INT64>[unknown order:400, 300]
  },
  {
    1030,
    1010,
    ARRAY<INT64>[unknown order:500, 500, 500]
  }
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=for_operator_null_array]
select *
from graph_table(aml
  MATCH (a:Account)
  FOR element in CAST(NULL AS ARRAY<INT64>) WITH OFFSET AS offset
  RETURN a.account_id, element, offset
)
ORDER BY 1, 2, 3
--
ARRAY<STRUCT<account_id INT64, element INT64, offset INT64>>[]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=for_operator_empty_untyped_array]
select *
from graph_table(aml
  MATCH (a:Account)
  FOR element in [] WITH OFFSET AS offset
  RETURN a.account_id, element, offset
)
ORDER BY 1, 2, 3
--
ARRAY<STRUCT<account_id INT64, element INT64, offset INT64>>[]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=for_operator_str_literal_array]
select *
from graph_table(aml
  MATCH (a:Account)
  FOR element in ["first", "second", "third"] WITH OFFSET AS offset
  RETURN a.account_id, element, offset
)
ORDER BY 1, 2, 3
--
ARRAY<STRUCT<account_id INT64, element STRING, offset INT64>>[known order:
  {1010, "first", 0},
  {1010, "second", 1},
  {1010, "third", 2},
  {1020, "first", 0},
  {1020, "second", 1},
  {1020, "third", 2},
  {1030, "first", 0},
  {1030, "second", 1},
  {1030, "third", 2},
  {1040, "first", 0},
  {1040, "second", 1},
  {1040, "third", 2}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=for_operator_str_literal_array_with_nulls]
select *
from graph_table(aml
  MATCH (a:Account)
  FOR element in ["a", NULL, "b", "c", NULL] WITH OFFSET AS offset
  RETURN a.account_id, element, offset
)
ORDER BY 1, 2, 3
--
ARRAY<STRUCT<account_id INT64, element STRING, offset INT64>>[known order:
  {1010, NULL, 1},
  {1010, NULL, 4},
  {1010, "a", 0},
  {1010, "b", 2},
  {1010, "c", 3},
  {1020, NULL, 1},
  {1020, NULL, 4},
  {1020, "a", 0},
  {1020, "b", 2},
  {1020, "c", 3},
  {1030, NULL, 1},
  {1030, NULL, 4},
  {1030, "a", 0},
  {1030, "b", 2},
  {1030, "c", 3},
  {1040, NULL, 1},
  {1040, NULL, 4},
  {1040, "a", 0},
  {1040, "b", 2},
  {1040, "c", 3}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT]
[name=for_operator_str_literal_array_with_collation]
select *, element = "abc" AS is_equivalent_to_abc
from graph_table(aml
  MATCH (a:Account)
  FOR element in [COLLATE("abc", "und:ci"), COLLATE("Abc", "und:ci"), COLLATE("ABC", "und:ci")] WITH OFFSET AS offset
  RETURN a.account_id, element, offset
)
ORDER BY 1, 2, 3
--
ARRAY<STRUCT<
        account_id INT64,
        element STRING,
        offset INT64,
        is_equivalent_to_abc BOOL
      >>
[known order:
  {1010, "abc", 0, true},
  {1010, "Abc", 1, true},
  {1010, "ABC", 2, true},
  {1020, "abc", 0, true},
  {1020, "Abc", 1, true},
  {1020, "ABC", 2, true},
  {1030, "abc", 0, true},
  {1030, "Abc", 1, true},
  {1030, "ABC", 2, true},
  {1040, "abc", 0, true},
  {1040, "Abc", 1, true},
  {1040, "ABC", 2, true}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=for_operator_gql_array_subquery]
select *
from graph_table(aml
  MATCH (a:Account)
  FOR element in ARRAY {graph aml MATCH (n:Account) RETURN COUNT(n.account_id) as col} WITH OFFSET
  RETURN a.account_id, element, offset
)
ORDER BY 1, 2, 3
--
ARRAY<STRUCT<account_id INT64, element INT64, offset INT64>>[known order:
  {1010, 4, 0},
  {1020, 4, 0},
  {1030, 4, 0},
  {1040, 4, 0}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_3_INLINE_LAMBDA_ARGUMENT]
[name=for_operator_array_expr]
select *
from graph_table(aml
  MATCH (a:Account)
  FOR element in ARRAY_TRANSFORM(ARRAY[1,2,3,4], e -> e + 1) WITH OFFSET
  RETURN element, offset
)
ORDER BY 1, 2
--
ARRAY<STRUCT<element INT64, offset INT64>>[known order:
  {2, 0},
  {2, 0},
  {2, 0},
  {2, 0},
  {3, 1},
  {3, 1},
  {3, 1},
  {3, 1},
  {4, 2},
  {4, 2},
  {4, 2},
  {4, 2},
  {5, 3},
  {5, 3},
  {5, 3},
  {5, 3}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=for_operator_group_variable]
select COUNT(*) as cnt
from graph_table(aml
  MATCH ((a)-[b:Transfer]->(c)){1, 3}
  FOR element in b WITH OFFSET
  LET path_sum = SUM(b.amount)
  RETURN path_sum, offset
)
--
ARRAY<STRUCT<cnt INT64>>[{102}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_RETURN_EXTENSIONS]
[name=aggregation_with8]
select gt.* from
graph_table(aml
  MATCH (a1:Account)-[t1:Transfer]->(a2)
  MATCH (a2:Account)-[t2:Transfer]->(a3)
  FILTER a1 != a2
  WITH DISTINCT a1.account_id as a1_id, a2.account_id as a2_id, a3.account_id as a3_id, t1.amount as t1_amount, t2.amount as t2_amount
  WITH *, 1 as unused_col
  RETURN ALL a1_id, a2_id, ARRAY_AGG(t1_amount) as arr
    GROUP BY a1_id,a2_id
) gt
ORDER BY a1_id, a2_id
--
ARRAY<STRUCT<a1_id INT64, a2_id INT64, arr ARRAY<>>>[known order:
  {
    1010,
    1020,
    ARRAY<INT64>[unknown order:200, 200, 100, 100]
  },
  {
    1020,
    1030,
    ARRAY<INT64>[unknown order:400, 300]
  },
  {
    1030,
    1010,
    ARRAY<INT64>[unknown order:500, 500, 500]
  }
]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=horizontal_aggregation_simple]

select * from graph_table(aml
  let single = 3
  let x = [4, 5]
  let x2 = [5, 6]
  # single is multiplying each element in x: (4*3 + 5*3) + (5 + 6)
  let r = SUM(x * single) + SUM(x2)
  return r
)
--
ARRAY<STRUCT<r INT64>>[{38}]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_1_ORDER_BY_IN_AGGREGATE]
[name=horizontal_aggregation_array_agg]

select * from graph_table(aml
  let single = 3
  let x = [4, 5]
  let r = ARRAY_CONCAT(ARRAY_AGG(x + single),
                       ARRAY_AGG(x + x ORDER BY x + single DESC),
                       ARRAY_AGG(x ORDER BY single, x),
                       ARRAY_AGG(x ORDER BY single, single, single, x),
                       ARRAY_AGG(x ORDER BY x + single, x + single, single, x))
  return r
)
--
ARRAY<STRUCT<r ARRAY<>>>[
  {ARRAY<INT64>[known order:7, 8, 10, 8, 4, 5, 4, 5, 4, 5]}
]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_1_ORDER_BY_IN_AGGREGATE,V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE,V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY]
[name=horizontal_aggregation_array_agg_with_nulls]

select * from graph_table(aml
  let single = 3
  let x = [4, null, 5]
  let r = ARRAY_CONCAT(ARRAY_AGG(x IGNORE NULLS ORDER BY x),
    ARRAY_AGG(2 * x RESPECT NULLS ORDER BY x DESC NULLS LAST),
    ARRAY_AGG(2 * x RESPECT NULLS ORDER BY x DESC NULLS FIRST)
    )
  return r
)
--
ARRAY<STRUCT<r ARRAY<>>>[
  {ARRAY<INT64>[known order:4, 5, 10, 8, NULL, NULL, 10, 8]}
]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_1_HAVING_IN_AGGREGATE]
[name=horizontal_aggregation_having_max]

select * from graph_table(aml
  let fruit = [STRUCT("banana" as name, 100 as price),
               STRUCT("apple" as name, 20 as price),
               STRUCT("orange" as name, 200 as price)]
  let r = ANY_VALUE(fruit.name HAVING MAX fruit.price)
  return r
)
--
ARRAY<STRUCT<r STRING>>[{"orange"}]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_1_ORDER_BY_IN_AGGREGATE]
[name=horizontal_aggregation_string_agg_with_constant_arg]

select * from graph_table(aml
  let strings = ["hello", "world"]
  let r = STRING_AGG(strings, ", ")
  return r
)
--
ARRAY<STRUCT<r STRING>>[{"hello, world"}]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_1_ORDER_BY_IN_AGGREGATE]
[name=horizontal_aggregation_params]
[parameters=", " as separator, ARRAY<STRING>["hello", "world"] as arr]

select * from graph_table(aml
  let strings = @arr
  let r = STRING_AGG(strings, @separator)
  return r
)
--
ARRAY<STRUCT<r STRING>>[{"hello, world"}]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_1_ORDER_BY_IN_AGGREGATE]
[name=horizontal_aggregation_empty_array]

select * from graph_table(aml
  let x = []
  let r = COUNT(x) + ARRAY_LENGTH(x)
  let r2 = ARRAY_AGG(x)
  return r, r2
)
--
ARRAY<STRUCT<r INT64, r2 ARRAY<>>>[{0, ARRAY<INT64>(NULL)}]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_WITH_EXPRESSION]
[name=horizontal_aggregation_with_expr]

select * from graph_table(aml
  let x = [1,2,3]
  let x2 = [4,5,6]
  let r1 = WITH(a as SUM(x), 2 * a + COUNT(x2))
  let r2 = WITH(a as 1, a + SUM(x) + SUM(x2))
  let r3 = WITH(a as x, a[OFFSET(0)] + SUM(x) + SUM(x2))
  return r1, r2, r3
)
--
ARRAY<STRUCT<r1 INT64, r2 INT64, r3 INT64>>[{15, 22, 22}]

==


[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=horizontal_aggregation_separate_aggregations]

# Separate horizontal aggregations are separate
SELECT * from graph_table(aml
  let x = [4, 5]
  let y = [6, 7]
  let z = SUM(x + x) + MIN(y) + MAX(x - x)
  return z
)

--
ARRAY<STRUCT<z INT64>>[{24}]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=horizontal_aggregation_overflow]

# Aggregates that overflow
SELECT * from graph_table(aml
  let x = [3689348814741910528,3689348814741910528]
  let r1 = SUM(x)
  let r2 = SUM(x + x) -- should overflow
  return r1, r2
)

--
ERROR: generic::out_of_range: int64 overflow

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_2_SAFE_FUNCTION_CALL]
[name=horizontal_aggregation_safe_agg]

# SAFE aggregates are supported
SELECT * from graph_table(aml
  let x = [3689348814741910528,3689348814741910528]
  let r1 = safe.sum(x)
  let r2 = safe.sum(x + x)  # should overflow
  return r1, r2
)

--
ARRAY<STRUCT<r1 INT64, r2 INT64>>[{7378697629483821056, NULL}]

==

[name=horizontal_aggregation_conditional_evaluation]

# Horizontal aggregation with possibly failing aggregates
SELECT * from graph_table(aml
  let x = [4, 0, 5]
  let r1 = IFERROR(SUM(x / 0), SUM(x))
  let r2 = IF(LOGICAL_OR(x = 0), SUM(x / 2), SUM(2 / x))
  let r3 = IFERROR(SUM(x / 2) + SUM(2 / x), SUM(x / 2))
  let r4 = COALESCE(SUM(x / 2), SUM(2 / x))
  let r5 = CASE WHEN SUM(x) = 9 THEN COUNT(x * 0) ELSE SUM(x / 0) END

  return r1, r2, r3, r4, r5
)

--
ARRAY<STRUCT<r1 DOUBLE, r2 DOUBLE, r3 DOUBLE, r4 DOUBLE, r5 DOUBLE>>[
  {9, 4.5, 4.5, 4.5, 3}
]

==

[name=horizontal_aggregation_proto_access]

# Array aggregate with a proto field access
SELECT * from graph_table(aml
  let x = [cast('''
  int64_key_1: 1
  int64_key_2: 1
''' as `zetasql_test__.KitchenSinkPB`)]
  let r1 = SUM(x.int64_key_1)
  return r1
)

--
ARRAY<STRUCT<r1 INT64>>[{1}]

==

[name=horizontal_aggregation_null_array]
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_1_ORDER_BY_IN_AGGREGATE]

# Horizontal aggregation with possibly failing aggregates
SELECT * from graph_table(aml
  let xs = CAST(NULL AS ARRAY<INT64>)
  let bs = CAST(NULL AS ARRAY<BOOL>)
  let r1 = SUM(xs)
  LET r2 = COUNT(bs)
  LET r3 = COUNTIF(bs)
  LET r4 = ARRAY_AGG(xs)
  return r1, r2, r3, r4
)

--
ARRAY<STRUCT<r1 INT64, r2 INT64, r3 INT64, r4 ARRAY<>>>[
  {NULL, 0, 0, ARRAY<INT64>(NULL)}
]
==

[name=horizontal_aggregation_array_agg_options_without_limit]
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_1_HAVING_IN_AGGREGATE,V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE,V_1_1_ORDER_BY_IN_AGGREGATE]
# All features of ARRAY_AGG
select * from graph_table(aml
  let single = 3
  let x = [1, 2, 3, 4, 5]
  let r1 = ARRAY_AGG(x + single IGNORE NULLS HAVING MAX -x ORDER BY x - single)
  # This having min doesn't actually do anything
  let r2 = ARRAY_AGG(DISTINCT x + single IGNORE NULLS HAVING MIN 3 ORDER BY x + single )
  let r3 = ARRAY_AGG(if (x = 4, NULL, x) IGNORE NULLS HAVING MIN 3 ORDER BY -x)
  return r1, r2, r3
)
--
ARRAY<STRUCT<r1 ARRAY<>, r2 ARRAY<>, r3 ARRAY<>>>[
  {
    ARRAY<INT64>[4],
    ARRAY<INT64>[known order:4, 5, 6, 7, 8],
    ARRAY<INT64>[known order:5, 3, 2, 1]
  }
]

==
[name=horizontal_aggregation_array_agg_options]
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_1_LIMIT_IN_AGGREGATE,V_1_1_HAVING_IN_AGGREGATE,V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE,V_1_1_ORDER_BY_IN_AGGREGATE]
# All features of ARRAY_AGG
select * from graph_table(aml
  let single = 3
  let x = [1, 2, 3, 4, 5]
  let r1 = ARRAY_AGG(x + single IGNORE NULLS HAVING MAX -x ORDER BY x - single LIMIT 1 )
  # This having min doesn't actually do anything
  let r2 = ARRAY_AGG(DISTINCT x + single IGNORE NULLS HAVING MIN 3 ORDER BY x + single LIMIT 1  )
  let r3 = ARRAY_AGG(if (x = 4, NULL, x) IGNORE NULLS HAVING MIN 3 ORDER BY -x LIMIT 1  )
  return r1, r2, r3
)
--
ARRAY<STRUCT<r1 ARRAY<>, r2 ARRAY<>, r3 ARRAY<>>>[
  {ARRAY<INT64>[4], ARRAY<INT64>[4], ARRAY<INT64>[5]}
]

==

[default required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=fixed_quantified_test]
select * from graph_table(aml
  MATCH (x:Account)((a)-[e:Transfer]->(b)){3}(y:Account)
  return x.account_id AS x_id, y.account_id AS y_id
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64>>[known order:
  {1010, 1010},
  {1010, 1010},
  {1010, 1010},
  {1010, 1010},
  {1010, 1010},
  {1010, 1020},
  {1010, 1020},
  {1010, 1030},
  {1010, 1030},
  {1010, 1030},
  {1010, 1030},
  {1020, 1010},
  {1020, 1010},
  {1020, 1020},
  {1020, 1020},
  {1020, 1020},
  {1020, 1020},
  {1030, 1010},
  {1030, 1020},
  {1030, 1020},
  {1030, 1030},
  {1030, 1030},
  {1030, 1030},
  {1030, 1030}
]
==

[name=lower_upper_quantified_test]
select * from graph_table(aml
  MATCH (x:Account)((a)-[e:Transfer]->(b)){1,2}(y:Account)
  return x.account_id AS x_id, y.account_id AS y_id
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64>>[known order:
  {1010, 1010},
  {1010, 1010},
  {1010, 1020},
  {1010, 1020},
  {1010, 1020},
  {1010, 1020},
  {1010, 1030},
  {1010, 1030},
  {1010, 1030},
  {1010, 1030},
  {1020, 1010},
  {1020, 1010},
  {1020, 1030},
  {1020, 1030},
  {1030, 1010},
  {1030, 1010},
  {1030, 1020},
  {1030, 1020}
]
==

[name=count_possible_paths]
select * from graph_table(aml
  MATCH (x:Account)((a)-[e:Transfer]->(b)){1,2}(y:Account)
  RETURN x.account_id AS x_id, y.account_id AS y_id, COUNT(*) AS num_possible_paths GROUP BY x_id, y_id
)
order by x_id, y_id
--
ARRAY<STRUCT<
        x_id INT64,
        y_id INT64,
        num_possible_paths INT64
      >>
[known order:{1010, 1010, 2},
             {1010, 1020, 4},
             {1010, 1030, 4},
             {1020, 1010, 2},
             {1020, 1030, 2},
             {1030, 1010, 2},
             {1030, 1020, 2}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_2_GROUP_BY_ARRAY]
[name=count_possible_paths_group_by_group_var]
# using group var as a grouping key
select * from graph_table(aml
  MATCH (x:Account)((a)-[e:Transfer]->(b)){1,2}(y:Account)
  RETURN x.account_id AS x_id, y.account_id AS y_id, COUNT(*) AS num_possible_paths GROUP BY x_id, y_id, e
)
order by x_id, y_id
--
ARRAY<STRUCT<
        x_id INT64,
        y_id INT64,
        num_possible_paths INT64
      >>
[known order:{1010, 1010, 1},
             {1010, 1010, 1},
             {1010, 1020, 1},
             {1010, 1020, 1},
             {1010, 1020, 1},
             {1010, 1020, 1},
             {1010, 1030, 1},
             {1010, 1030, 1},
             {1010, 1030, 1},
             {1010, 1030, 1},
             {1020, 1010, 1},
             {1020, 1010, 1},
             {1020, 1030, 1},
             {1020, 1030, 1},
             {1030, 1010, 1},
             {1030, 1010, 1},
             {1030, 1020, 1},
             {1030, 1020, 1}]
==

# Avoid immediate cycles within 1-hop. Once we have group variable support, we
# may be able to add a filter to prune out all possible cycles.
[name=quantified_path_avoid_immediate_cycles]
select * from graph_table(aml
  MATCH (x:Account)((a)-[e:Transfer]->(b) WHERE ALL_DIFFERENT(a, b)){1,2}(y:Account)
  RETURN x.account_id AS x_id, y.account_id AS y_id
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64>>[known order:
  {1010, 1020},
  {1010, 1020},
  {1010, 1030},
  {1010, 1030},
  {1010, 1030},
  {1010, 1030},
  {1020, 1010},
  {1020, 1010},
  {1020, 1030},
  {1020, 1030},
  {1030, 1010},
  {1030, 1020},
  {1030, 1020}
]

==
[name=multihop_within_quantified_path_test]
# Test with more than 1 edge within a quantified path
select * from graph_table(aml
  MATCH (x:Account)((a)-[e:Transfer]->(b)-[f:Transfer]->(c)){1}(y:Account)
  return x.account_id AS x_id, y.account_id AS y_id
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64>>[known order:
  {1010, 1010},
  {1010, 1020},
  {1010, 1020},
  {1010, 1030},
  {1010, 1030},
  {1010, 1030},
  {1010, 1030},
  {1020, 1010},
  {1020, 1010},
  {1030, 1010},
  {1030, 1020},
  {1030, 1020}
]
==

[name=concatenated_quantifiers_test]
# Test the concatenation of 2 quantified paths
select * from graph_table(aml
  MATCH (x:Account)((a)-[e:Transfer]->(b)){1} ((g)-[f:Transfer]->(h)){2}(y:Account)
  return x.account_id AS x_id, y.account_id AS y_id
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64>>[known order:
  {1010, 1010},
  {1010, 1010},
  {1010, 1010},
  {1010, 1010},
  {1010, 1010},
  {1010, 1020},
  {1010, 1020},
  {1010, 1030},
  {1010, 1030},
  {1010, 1030},
  {1010, 1030},
  {1020, 1010},
  {1020, 1010},
  {1020, 1020},
  {1020, 1020},
  {1020, 1020},
  {1020, 1020},
  {1030, 1010},
  {1030, 1020},
  {1030, 1020},
  {1030, 1030},
  {1030, 1030},
  {1030, 1030},
  {1030, 1030}
]
==

[name=traverse_from_quantified_test]
# Test that extending a quantified path with more path factors works correctly
select * from graph_table(aml
  MATCH (x:Account)((a)-[e:Transfer]->(b)){1,2}-[f:Transfer WHERE f.amount > 500]->(y:Account)
  return x.account_id AS x_id, y.account_id AS y_id
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64>>[known order:
  {1010, 1010},
  {1010, 1010},
  {1020, 1010},
  {1020, 1010},
  {1030, 1010},
  {1030, 1010}
]

==

[name=traverse_to_quantified_test]
# Test that traversing to a quantified path from other path factors works
# correctly
select * from graph_table(aml
  MATCH (p:Human)-[l:Login]->((a)-[e:Transfer]->(b)){1,2}(y:Account)
  return p.name AS person_name, y.account_id AS y_id
)
order by person_name, y_id
--
ARRAY<STRUCT<person_name STRING, y_id INT64>>[known order:
  {"name1", 1010},
  {"name1", 1010},
  {"name1", 1020},
  {"name1", 1020},
  {"name1", 1020},
  {"name1", 1020},
  {"name1", 1030},
  {"name1", 1030},
  {"name1", 1030},
  {"name1", 1030},
  {"name2", 1010},
  {"name2", 1010},
  {"name2", 1020},
  {"name2", 1020}
]
==

[name=quantifier_with_start_node_filter]
# This tests that the start node and every intermediate position of 'a' have
# the same 'account_id'
select * from graph_table(aml
  MATCH (x:Account)((a WHERE a.account_id = 1010)-[e:Transfer]->(b)){1,2}(y:Account)
  return x.account_id AS x_id, y.account_id AS y_id
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64>>[known order:
  {1010, 1010},
  {1010, 1010},
  {1010, 1020},
  {1010, 1020},
  {1010, 1020},
  {1010, 1020}
]
==

[name=external_filtered_alias]
# In contrast to the previous test, this tests that ONLY the start node has a
# fixed 'account_id'.
select * from graph_table(aml
  MATCH (p:Human)-[l:Login]->(x:Account {account_id: 1010})((a)-[e:Transfer]->(b)){1,2}(y:Account)
  return p.name AS person_name, y.account_id AS y_id
)
order by person_name, y_id
--
ARRAY<STRUCT<person_name STRING, y_id INT64>>[known order:
  {"name1", 1010},
  {"name1", 1010},
  {"name1", 1020},
  {"name1", 1020},
  {"name1", 1020},
  {"name1", 1020},
  {"name1", 1030},
  {"name1", 1030},
  {"name1", 1030},
  {"name1", 1030}
]
==

[name=quantifier_with_end_node_filter]
select * from graph_table(aml
  MATCH (x:Account)((a)-[e:Transfer]->(b WHERE b.account_id = 1010)){1,2}(y:Account)
  return x.account_id AS x_id, y.account_id AS y_id
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64>>[known order:
  {1010, 1010},
  {1010, 1010},
  {1030, 1010},
  {1030, 1010}
]
==

[name=quantifier_with_edge_filter]
select * from graph_table(aml
  MATCH (x:Account)((a)-[e:Transfer WHERE e.amount > 200]->(b)){1,2}(y:Account)
  return x.account_id AS x_id, y.account_id AS y_id
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64>>[known order:
  {1010, 1010},
  {1010, 1010},
  {1020, 1010},
  {1020, 1010},
  {1020, 1030},
  {1020, 1030},
  {1030, 1010},
  {1030, 1010}
]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_1_ORDER_BY_IN_AGGREGATE]
[name=group_variables_basic]
select head, amounts, tail from graph_table(aml
  match (head:Account)(-[e:Transfer]->{1,2})(tail:Account)
  let amounts = ARRAY_AGG(e.amount)
  let sort_by = STRING_AGG(CAST(e.amount AS STRING), "x") # can't order by array
  return head.account_id as head, amounts, sort_by, tail.account_id as tail
)
order by ARRAY_LENGTH(amounts), sort_by, head, tail
--
ARRAY<STRUCT<head INT64, amounts ARRAY<>, tail INT64>>[known order:
  {1010, ARRAY<INT64>[100], 1020},
  {1010, ARRAY<INT64>[200], 1020},
  {1020, ARRAY<INT64>[300], 1030},
  {1020, ARRAY<INT64>[400], 1030},
  {1030, ARRAY<INT64>[500], 1010},
  {1010, ARRAY<INT64>[600], 1010},
  {
    1010,
    ARRAY<INT64>[known order:100, 300],
    1030
  },
  {
    1010,
    ARRAY<INT64>[known order:100, 400],
    1030
  },
  {
    1010,
    ARRAY<INT64>[known order:200, 300],
    1030
  },
  {
    1010,
    ARRAY<INT64>[known order:200, 400],
    1030
  },
  {
    1020,
    ARRAY<INT64>[known order:300, 500],
    1010
  },
  {
    1020,
    ARRAY<INT64>[known order:400, 500],
    1010
  },
  {
    1030,
    ARRAY<INT64>[known order:500, 100],
    1020
  },
  {
    1030,
    ARRAY<INT64>[known order:500, 200],
    1020
  },
  {
    1030,
    ARRAY<INT64>[known order:500, 600],
    1010
  },
  {
    1010,
    ARRAY<INT64>[known order:600, 100],
    1020
  },
  {
    1010,
    ARRAY<INT64>[known order:600, 200],
    1020
  },
  {
    1010,
    ARRAY<INT64>[known order:600, 600],
    1010
  }
]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_1_ORDER_BY_IN_AGGREGATE]
[name=group_variables_filter]
select a, amounts from graph_table(aml
  match (a:Account)(-[e:Transfer]->{1,2})(a)
  let amounts = ARRAY_AGG(e.amount)
  let sort_by = STRING_AGG(CAST(e.amount AS STRING), "x") # can't order by array
  return a.account_id as a, amounts, sort_by
)
order by ARRAY_LENGTH(amounts), sort_by, a
--
ARRAY<STRUCT<a INT64, amounts ARRAY<>>>[known order:
  {1010, ARRAY<INT64>[600]},
  {
    1010,
    ARRAY<INT64>[known order:600, 600]
  }
]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=group_variables_two_groups]
select * from
graph_table(
aml
match (a:Account)(-[e:Transfer]->{1,2})(b:Account)(-[e2:Transfer]->{1,2})(c:Account)
let total_cost = SUM(e.amount) + SUM(e2.amount)
filter ARRAY_LENGTH(e) != ARRAY_LENGTH(e2)
return a.account_id as a, b.account_id as b, c.account_id as c, total_cost, ARRAY_LENGTH(e) as num_edges_first_leg, ARRAY_LENGTH(e2) as num_edges_second_leg
)
order by total_cost, a, b, c, num_edges_first_leg, num_edges_second_leg
limit 5

--
ARRAY<STRUCT<
        a INT64,
        b INT64,
        c INT64,
        total_cost INT64,
        num_edges_first_leg INT64,
        num_edges_second_leg INT64
      >>
[known order:
  {1010, 1020, 1010, 900, 1, 2},
  {1010, 1030, 1010, 900, 2, 1},
  {1020, 1010, 1020, 900, 2, 1},
  {1020, 1030, 1020, 900, 1, 2},
  {1030, 1010, 1030, 900, 1, 2}
]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_1_ORDER_BY_IN_AGGREGATE]
[name=group_variables_different_types]
# The inner path has different graph types (the head is "everything" whereas the
# tail is Account). They should still join correctly.
select * from graph_table(
aml
match (-[e:Transfer]->(b:Account)){1,2}
let accounts = ARRAY_AGG(b.account_id)
return accounts
)
order by array_length(accounts), array_first(accounts), array_last(accounts)
--
ARRAY<STRUCT<accounts ARRAY<>>>[known order:
  {ARRAY<INT64>[1010]},
  {ARRAY<INT64>[1010]},
  {ARRAY<INT64>[1020]},
  {ARRAY<INT64>[1020]},
  {ARRAY<INT64>[1030]},
  {ARRAY<INT64>[1030]},
  {ARRAY<INT64>[known order:1010, 1010]},
  {ARRAY<INT64>[known order:1010, 1010]},
  {ARRAY<INT64>[known order:1010, 1020]},
  {ARRAY<INT64>[known order:1010, 1020]},
  {ARRAY<INT64>[known order:1010, 1020]},
  {ARRAY<INT64>[known order:1010, 1020]},
  {ARRAY<INT64>[known order:1020, 1030]},
  {ARRAY<INT64>[known order:1020, 1030]},
  {ARRAY<INT64>[known order:1020, 1030]},
  {ARRAY<INT64>[known order:1020, 1030]},
  {ARRAY<INT64>[known order:1030, 1010]},
  {ARRAY<INT64>[known order:1030, 1010]}
]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_EXPOSE_GRAPH_ELEMENT,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=group_variables_same_as_writing_it_by_hand]
with T1 as (select a.account_id as a, b.account_id as b, c.account_id as c, d.account_id as d from
(
  (select a,b, NULL as c, NULL as d from graph_table(aml
    match (a:Account)-[e1:Transfer]->(b:Account)
  ))
  union all
  (select a,b,c, NULL as d from graph_table(aml
    match (a:Account)-[e1:Transfer]->(b:Account),
          (b)-[e2:Transfer]->(c:Account)
  ))
  union all
  (select a,b,c,d from graph_table(aml
    match (a:Account)-[e1:Transfer]->(b:Account),
          (b)-[e2:Transfer]->(c:Account),
          (c)-[e3:Transfer]->(d:Account)
  ))
)),
T2 as (select * from graph_table (aml
  match (a:Account)(-[e:Transfer]->(tails:Account)){1,3}
  return a.account_id as a,
         tails[SAFE_OFFSET(0)].account_id as b,
         tails[SAFE_OFFSET(1)].account_id as c,
         tails[SAFE_OFFSET(2)].account_id as d
))
SELECT EXISTS(SELECT * FROM T1 EXCEPT ALL SELECT * FROM T2) OR
       EXISTS(SELECT * FROM T2 EXCEPT ALL SELECT * FROM T1)

--
ARRAY<STRUCT<BOOL>>[{false}]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_EXPOSE_GRAPH_ELEMENT,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=group_variables_same_as_writing_it_by_hand_no_types_or_direction]
with T1 as (select a.id as a, b.id as b, c.id as c, d.id as d from
(
  (select a,b, NULL as c, NULL as d from graph_table(aml
    match (a)-[e1]-(b)
  ))
  union all
  (select a,b,c, NULL as d from graph_table(aml
    match (a)-[e1]-(b),
          (b)-[e2]-(c)
  ))
  union all
  (select a,b,c,d from graph_table(aml
    match (a)-[e1]-(b),
          (b)-[e2]-(c),
          (c)-[e3]-(d)
  ))
)),
T2 as (select * from graph_table (aml
  match (a)(-[e]-(tails)){1,3}
  return a.id as a,
         tails[SAFE_OFFSET(0)].id as b,
         tails[SAFE_OFFSET(1)].id as c,
         tails[SAFE_OFFSET(2)].id as d
))
SELECT EXISTS(SELECT * FROM T1 EXCEPT ALL SELECT * FROM T2) OR
       EXISTS(SELECT * FROM T2 EXCEPT ALL SELECT * FROM T1)

--
ARRAY<STRUCT<BOOL>>[{false}]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=group_variables_two_hops_is_one_at_a_time]
with T1 as (select * from graph_table(aml
  match ((a)-[e]-){1,1}((b)-[e2]-(c)){1,1}
  return a[OFFSET(0)].id as a, b[OFFSET(0)].id as b, c[OFFSET(0)].id as c
)),
T2 as (select * from graph_table (aml
  match (hd)((heads)-[e]-){2,2}(tl)
  return heads[OFFSET(0)].id as a,
         heads[OFFSET(1)].id as b,
         tl.id as c
))
SELECT EXISTS(SELECT * FROM T1 EXCEPT ALL SELECT * FROM T2) OR
       EXISTS(SELECT * FROM T2 EXCEPT ALL SELECT * FROM T1)

--
ARRAY<STRUCT<BOOL>>[{false}]

==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_3_UNNEST_AND_FLATTEN_ARRAYS,V_1_1_ORDER_BY_IN_AGGREGATE]
[name=group_variables_flatten]
select distinct * from graph_table(aml
  match ((a)-[e:Transfer]-){1,3}((b)-[e2]-(c)){1,1}
  let flattened = flatten(e.amount)
  let flattened_as_strings = STRING_AGG(CAST(flattened AS STRING), "x")
  let aggregated = ARRAY_AGG(e.amount)
  let aggregated_as_strings = STRING_AGG(CAST(aggregated AS STRING), "x")
  return flattened_as_strings = aggregated_as_strings as should_be_true
)
--
ARRAY<STRUCT<should_be_true BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_1_union_all_1]
select *, COUNT(*) AS count
from graph_table(aml
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  return p.name, a.account_id as aid
  UNION ALL
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  return a.account_id as AID, p.name
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<name STRING, aid INT64, count INT64>>[known order:
  {"name1", 1010, 2},
  {"name2", 1030, 2},
  {"name3", NULL, 2}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_1_union_all_2]
select *, COUNT(*) AS count
from graph_table(aml
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  return p.name, a.account_id as aid
  UNION ALL
  return 100000 as AID, "fakename" AS nAme
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<name STRING, aid INT64, count INT64>>[known order:
  {"fakename", 100000, 1},
  {"name1", 1010, 1},
  {"name2", 1030, 1},
  {"name3", NULL, 1}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_1_union_distinct_1]
select *, COUNT(*) AS count
from graph_table(aml
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  return p.name, a.account_id as aid
  UNION DISTINCT
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  return a.account_id as AID, p.name
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<name STRING, aid INT64, count INT64>>[known order:
  {"name1", 1010, 1},
  {"name2", 1030, 1},
  {"name3", NULL, 1}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_1_union_distinct_2]
select *, COUNT(*) AS count
from graph_table(aml
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  return p.name, a.account_id as aid
  UNION DISTINCT
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  WHERE p.name = "name1"
  return a.account_id as AID, p.name
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<name STRING, aid INT64, count INT64>>[known order:
  {"name1", 1010, 1},
  {"name2", NULL, 1},
  {"name2", 1030, 1},
  {"name3", NULL, 1}
]
==

[name=composite_query_in_block_1_union_distinct_3]
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
select * from graph_table(aml
  MATCH (a:Account)
  return a as c
  UNION DISTINCT
  MATCH (c is ! Account)
  return c
  NEXT
  return c.account_id, c.name
)
ORDER BY 1, 2
--
ARRAY<STRUCT<account_id INT64, name STRING>>[known order:
  {NULL, "name1"},
  {NULL, "name2"},
  {NULL, "name3"},
  {1010, NULL},
  {1020, NULL},
  {1030, NULL},
  {1040, NULL}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_1_intersect_all]
select *, COUNT(*) AS count
from graph_table(aml
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  INTERSECT ALL
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010 OR a.account_id = 1020
  return b.account_id AS target_account_id, a.account_id AS source_account_id
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<
        source_account_id INT64,
        target_account_id INT64,
        count INT64
      >>
[known order:{1010, 1010, 1}, {1010, 1020, 2}, {1020, 1030, 2}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_1_intersect_distinct]
select *, COUNT(*) AS count
from graph_table(aml
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  INTERSECT DISTINCT
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010 OR a.account_id = 1020
  return a.account_id AS source_account_id, b.account_id AS target_account_id
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<
        source_account_id INT64,
        target_account_id INT64,
        count INT64
      >>
[known order:{1010, 1010, 1}, {1010, 1020, 1}, {1020, 1030, 1}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_1_except_all]
select *, COUNT(*) AS count
from graph_table(aml
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  EXCEPT ALL
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010
  return b.account_id AS target_account_id, a.account_id AS source_account_id
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<
        source_account_id INT64,
        target_account_id INT64,
        count INT64
      >>
[known order:{1020, 1030, 2}, {1030, 1010, 1}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_1_except_distinct]
select * from graph_table(aml
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  EXCEPT DISTINCT
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010
  return a.account_id AS source_account_id, b.account_id AS target_account_id
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<
        source_account_id INT64,
        target_account_id INT64
      >>
[known order:{1020, 1030}, {1030, 1010}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_1_union_all_with_next]
select COUNT(*) AS count
from graph_table(aml
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  return p.name, a.account_id as aid
  UNION ALL
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  return a.account_id as AID, p.name
  NEXT
  MATCH (p:Human)
  return 1 AS output
)
order by 1
--
ARRAY<STRUCT<count INT64>>[{18}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_2_union_all]
select *, COUNT(*) AS count
from graph_table(aml
  MATCH (p:Human)
  return 1 AS output
  NEXT
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  return p.name, a.account_id as aid
  UNION ALL
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  return a.account_id as AID, p.name
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<name STRING, aid INT64, count INT64>>[known order:
  {"name1", 1010, 6},
  {"name2", 1030, 6},
  {"name3", NULL, 6}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_2_union_distinct]
select *, COUNT(*) AS count
from graph_table(aml
  MATCH ()
  RETURN 1 AS output
  NEXT
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  return p.name, a.account_id as aid
  UNION DISTINCT
  MATCH (p:Human)
  OPTIONAL MATCH (p)-[e IS Login]->(a:Account)
  return a.account_id as AID, p.name
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<name STRING, aid INT64, count INT64>>[known order:
  {"name1", 1010, 1},
  {"name2", 1030, 1},
  {"name3", NULL, 1}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_2_intersect_all]
select *, COUNT(*) AS count
from graph_table(aml
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  NEXT
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  INTERSECT ALL
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010 OR a.account_id = 1020
  return b.account_id AS target_account_id, a.account_id AS source_account_id
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<
        source_account_id INT64,
        target_account_id INT64,
        count INT64
      >>
[known order:{1010, 1010, 3}, {1010, 1020, 6}, {1020, 1030, 6}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_2_intersect_distinct]
select *, COUNT(*) AS count
from graph_table(aml
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  NEXT
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  INTERSECT DISTINCT
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010 OR a.account_id = 1020
  return a.account_id AS source_account_id, b.account_id AS target_account_id
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<
        source_account_id INT64,
        target_account_id INT64,
        count INT64
      >>
[known order:{1010, 1010, 1}, {1010, 1020, 1}, {1020, 1030, 1}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_2_except_all]
select *, COUNT(*) AS count
from graph_table(aml
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  NEXT
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  EXCEPT ALL
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010
  return b.account_id AS target_account_id, a.account_id AS source_account_id
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<
        source_account_id INT64,
        target_account_id INT64,
        count INT64
      >>
[known order:{1020, 1030, 6}, {1030, 1010, 3}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_2_except_distinct]
select *, COUNT(*) AS count
from graph_table(aml
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  NEXT
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  EXCEPT DISTINCT
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010
  return a.account_id AS source_account_id, b.account_id AS target_account_id
)
GROUP BY 1, 2
ORDER BY 1, 2
--
ARRAY<STRUCT<
        source_account_id INT64,
        target_account_id INT64,
        count INT64
      >>
[known order:{1020, 1030, 1}, {1030, 1010, 1}]
==

# Correlated column reference in set operation without NEXT is supported.
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_1_with_correlated_column]
SELECT 1 FROM (
  SELECT 1000 AS Key, 1 AS Value
) kv
WHERE exists (
  SELECT 1 FROM GRAPH_TABLE (aml
    MATCH (a:Account)-[e:Transfer]->(b:Account)
    WHERE a.account_id = 1010
    RETURN (a.account_id + kv.Key) AS perturbed_source_account_id, b.account_id AS target_account_id
    UNION ALL
    MATCH (a:Account)-[e:Transfer]->(b:Account)
    WHERE a.account_id = 1010 OR a.account_id = 1020
    RETURN b.account_id AS target_account_id, (a.account_id + kv.Key) AS perturbed_source_account_id
  )
)
--
ARRAY<STRUCT<INT64>>[{1}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=composite_query_in_block_2_3]
select * from graph_table(aml
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  NEXT
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  EXCEPT DISTINCT
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  NEXT
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  return a.account_id AS source_account_id, b.account_id AS target_account_id
  INTERSECT DISTINCT
  MATCH (a:Account)-[e:Transfer]->(b:Account)
  WHERE a.account_id = 1010 OR a.account_id = 1020
  return a.account_id AS source_account_id, b.account_id AS target_account_id
)
order by 1, 2
--
ARRAY<STRUCT<
        source_account_id INT64,
        target_account_id INT64
      >>
[known order:{1010, 1010}, {1010, 1020}, {1020, 1030}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_3_UNNEST_AND_FLATTEN_ARRAYS]
[name=shortest_with_ties]
# 10 to 20, 20 to 30 both have 2 direct edges, so there are ties.
select * from graph_table(aml
  MATCH ANY SHORTEST (x:Account)((a)-[e:Transfer]->(b)){1, 3}(y:Account)
  let flattened = flatten(e.amount)
  return x.account_id AS x_id, y.account_id AS y_id, flattened
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64, flattened ARRAY<>>>[known order:
  {1010, 1010, ARRAY<INT64>[600]},
  {1010, 1020, ARRAY<INT64>[100]},
  {
    1010,
    1030,
    ARRAY<INT64>[known order:100, 300]
  },
  {
    1020,
    1010,
    ARRAY<INT64>[known order:400, 500]
  },
  {
    1020,
    1020,
    ARRAY<INT64>[known order:400, 500, 200]
  },
  {1020, 1030, ARRAY<INT64>[300]},
  {1030, 1010, ARRAY<INT64>[500]},
  {
    1030,
    1020,
    ARRAY<INT64>[known order:500, 200]
  },
  {
    1030,
    1030,
    ARRAY<INT64>[known order:500, 200, 400]
  }
]

NOTE: Reference implementation reports non-determinism.
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=shortest_with_ties_counting_hops]
# See shortest_with_ties for the exact edges. This is to allow engines like Spanner without FLATTEN feature to run this case
select * from graph_table(aml
  MATCH ANY SHORTEST (x:Account)((a)-[e:Transfer]->(b)){1, 3}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id
--

ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[known order:
  {1010, 1010, 1},
  {1010, 1020, 1},
  {1010, 1030, 2},
  {1020, 1010, 2},
  {1020, 1020, 3},
  {1020, 1030, 1},
  {1030, 1010, 1},
  {1030, 1020, 2},
  {1030, 1030, 3}
]

NOTE: Reference implementation reports non-determinism.

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_3_UNNEST_AND_FLATTEN_ARRAYS]
[name=shortest_with_no_ties]
select * from graph_table(aml
  MATCH ANY SHORTEST (x:Account)((a)-[e:Transfer WHERE e.amount != 400 AND e.amount != 200]->(b)){1, 3}(y:Account)
  let flattened = flatten(e.amount)
  return x.account_id AS x_id, y.account_id AS y_id, flattened
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64, flattened ARRAY<>>>[known order:
  {1010, 1010, ARRAY<INT64>[600]},
  {1010, 1020, ARRAY<INT64>[100]},
  {
    1010,
    1030,
    ARRAY<INT64>[known order:100, 300]
  },
  {
    1020,
    1010,
    ARRAY<INT64>[known order:300, 500]
  },
  {
    1020,
    1020,
    ARRAY<INT64>[known order:300, 500, 100]
  },
  {1020, 1030, ARRAY<INT64>[300]},
  {1030, 1010, ARRAY<INT64>[500]},
  {
    1030,
    1020,
    ARRAY<INT64>[known order:500, 100]
  },
  {
    1030,
    1030,
    ARRAY<INT64>[known order:500, 100, 300]
  }
]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=shortest_with_no_ties_counting_hops]
# To allow engines like Spanner without FLATTEN feature to run this case
select * from graph_table(aml
  MATCH ANY SHORTEST (x:Account)((a)-[e:Transfer WHERE e.amount != 400 AND e.amount != 200]->(b)){1, 3}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id
--

ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[known order:
  {1010, 1010, 1},
  {1010, 1020, 1},
  {1010, 1030, 2},
  {1020, 1010, 2},
  {1020, 1020, 3},
  {1020, 1030, 1},
  {1030, 1010, 1},
  {1030, 1020, 2},
  {1030, 1030, 3}
]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_3_UNNEST_AND_FLATTEN_ARRAYS]
[name=any_with_no_ties]
select * from graph_table(aml
  MATCH ANY (x:Account)((a)-[e:Transfer WHERE e.amount != 400 AND e.amount != 200]->(b)){2}(y:Account)
  let flattened = flatten(e.amount)
  return x.account_id AS x_id, y.account_id AS y_id, flattened
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64, flattened ARRAY<>>>[known order:
  {
    1010,
    1010,
    ARRAY<INT64>[known order:600, 600]
  },
  {
    1010,
    1020,
    ARRAY<INT64>[known order:600, 100]
  },
  {
    1010,
    1030,
    ARRAY<INT64>[known order:100, 300]
  },
  {
    1020,
    1010,
    ARRAY<INT64>[known order:300, 500]
  },
  {
    1030,
    1010,
    ARRAY<INT64>[known order:500, 600]
  },
  {
    1030,
    1020,
    ARRAY<INT64>[known order:500, 100]
  }
]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=any_with_ties_counting_hops]
select * from graph_table(aml
  MATCH ANY (x:Account)((a)-[e:Transfer WHERE e.amount != 400 AND e.amount != 200]->(b)){2, 4}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[known order:
  {1010, 1010, 3},
  {1010, 1020, 2},
  {1010, 1030, 2},
  {1020, 1010, 2},
  {1020, 1020, 3},
  {1020, 1030, 4},
  {1030, 1010, 4},
  {1030, 1020, 2},
  {1030, 1030, 3}
]

NOTE: Reference implementation reports non-determinism.
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=any_0_with_ties_counting_hops]
select * from graph_table(aml
  MATCH ANY 0 (x:Account)((a)-[e:Transfer]->(b)){1, 3}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id, hops
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=shortest_0_with_ties_counting_hops]
select * from graph_table(aml
  MATCH SHORTEST 0 (x:Account)((a)-[e:Transfer]->(b)){1, 3}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id, hops
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=any_2_with_ties_counting_hops]
select x_id, y_id from graph_table(aml
  MATCH ANY 2 (x:Account)((a)-[e:Transfer]->(b)){1, 3}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64>>[known order:
  {1010, 1010},
  {1010, 1010},
  {1010, 1020},
  {1010, 1020},
  {1010, 1030},
  {1010, 1030},
  {1020, 1010},
  {1020, 1010},
  {1020, 1020},
  {1020, 1020},
  {1020, 1030},
  {1020, 1030},
  {1030, 1010},
  {1030, 1010},
  {1030, 1020},
  {1030, 1020},
  {1030, 1030},
  {1030, 1030}
]

NOTE: Reference implementation reports non-determinism.
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=shortest_2_with_ties_counting_hops]
select * from graph_table(aml
  MATCH SHORTEST 2 (x:Account)((a)-[e:Transfer]->(b)){1, 3}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id, hops
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[known order:
  {1010, 1010, 1},
  {1010, 1010, 2},
  {1010, 1020, 1},
  {1010, 1020, 1},
  {1010, 1030, 2},
  {1010, 1030, 2},
  {1020, 1010, 2},
  {1020, 1010, 2},
  {1020, 1020, 3},
  {1020, 1020, 3},
  {1020, 1030, 1},
  {1020, 1030, 1},
  {1030, 1010, 1},
  {1030, 1010, 2},
  {1030, 1020, 2},
  {1030, 1020, 2},
  {1030, 1030, 3},
  {1030, 1030, 3}
]

NOTE: Reference implementation reports non-determinism.
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=shortest_10_with_ties_counting_hops]
select * from graph_table(aml
  MATCH SHORTEST 10 (x:Account)((a)-[e:Transfer]->(b)){1, 3}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id, hops
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[known order:
  {1010, 1010, 1},
  {1010, 1010, 2},
  {1010, 1010, 3},
  {1010, 1010, 3},
  {1010, 1010, 3},
  {1010, 1010, 3},
  {1010, 1010, 3},
  {1010, 1020, 1},
  {1010, 1020, 1},
  {1010, 1020, 2},
  {1010, 1020, 2},
  {1010, 1020, 3},
  {1010, 1020, 3},
  {1010, 1030, 2},
  {1010, 1030, 2},
  {1010, 1030, 2},
  {1010, 1030, 2},
  {1010, 1030, 3},
  {1010, 1030, 3},
  {1010, 1030, 3},
  {1010, 1030, 3},
  {1020, 1010, 2},
  {1020, 1010, 2},
  {1020, 1010, 3},
  {1020, 1010, 3},
  {1020, 1020, 3},
  {1020, 1020, 3},
  {1020, 1020, 3},
  {1020, 1020, 3},
  {1020, 1030, 1},
  {1020, 1030, 1},
  {1030, 1010, 1},
  {1030, 1010, 2},
  {1030, 1010, 3},
  {1030, 1020, 2},
  {1030, 1020, 2},
  {1030, 1020, 3},
  {1030, 1020, 3},
  {1030, 1030, 3},
  {1030, 1030, 3},
  {1030, 1030, 3},
  {1030, 1030, 3}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=any_10_with_ties_counting_hops]
select * from graph_table(aml
  MATCH ANY 10 (x:Account)((a)-[e:Transfer]->(b)){1, 3}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id, hops
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[known order:
  {1010, 1010, 1},
  {1010, 1010, 2},
  {1010, 1010, 3},
  {1010, 1010, 3},
  {1010, 1010, 3},
  {1010, 1010, 3},
  {1010, 1010, 3},
  {1010, 1020, 1},
  {1010, 1020, 1},
  {1010, 1020, 2},
  {1010, 1020, 2},
  {1010, 1020, 3},
  {1010, 1020, 3},
  {1010, 1030, 2},
  {1010, 1030, 2},
  {1010, 1030, 2},
  {1010, 1030, 2},
  {1010, 1030, 3},
  {1010, 1030, 3},
  {1010, 1030, 3},
  {1010, 1030, 3},
  {1020, 1010, 2},
  {1020, 1010, 2},
  {1020, 1010, 3},
  {1020, 1010, 3},
  {1020, 1020, 3},
  {1020, 1020, 3},
  {1020, 1020, 3},
  {1020, 1020, 3},
  {1020, 1030, 1},
  {1020, 1030, 1},
  {1030, 1010, 1},
  {1030, 1010, 2},
  {1030, 1010, 3},
  {1030, 1020, 2},
  {1030, 1020, 2},
  {1030, 1020, 3},
  {1030, 1020, 3},
  {1030, 1030, 3},
  {1030, 1030, 3},
  {1030, 1030, 3},
  {1030, 1030, 3}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=any_0_with_no_ties_counting_hops]
select * from graph_table(aml
  MATCH ANY 0 (x:Account)((a)-[e:Transfer WHERE e.amount != 400 AND e.amount != 200]->(b)){2}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id, hops
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=shortest_0_with_no_ties_counting_hops]
select * from graph_table(aml
  MATCH SHORTEST 0 (x:Account)((a)-[e:Transfer WHERE e.amount != 400 AND e.amount != 200]->(b)){2}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id, hops
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=any_2_with_no_ties_counting_hops]
select * from graph_table(aml
  MATCH ANY 2 (x:Account)((a)-[e:Transfer WHERE e.amount != 400 AND e.amount != 200]->(b)){2}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id, hops
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[known order:
  {1010, 1010, 2},
  {1010, 1020, 2},
  {1010, 1030, 2},
  {1020, 1010, 2},
  {1030, 1010, 2},
  {1030, 1020, 2}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=shortest_2_with_no_ties_counting_hops]
select * from graph_table(aml
  MATCH SHORTEST 2 (x:Account)((a)-[e:Transfer WHERE e.amount != 400 AND e.amount != 200]->(b)){2}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id, hops
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[known order:
  {1010, 1010, 2},
  {1010, 1020, 2},
  {1010, 1030, 2},
  {1020, 1010, 2},
  {1030, 1010, 2},
  {1030, 1020, 2}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=shortest_10_with_no_ties_counting_hops]
select * from graph_table(aml
  MATCH SHORTEST 10 (x:Account)((a)-[e:Transfer WHERE e.amount != 400 AND e.amount != 200]->(b)){2}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id, hops
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[known order:
  {1010, 1010, 2},
  {1010, 1020, 2},
  {1010, 1030, 2},
  {1020, 1010, 2},
  {1030, 1010, 2},
  {1030, 1020, 2}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=any_10_with_no_ties_counting_hops]
select * from graph_table(aml
  MATCH ANY 10 (x:Account)((a)-[e:Transfer WHERE e.amount != 400 AND e.amount != 200]->(b)){2}(y:Account)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id, hops
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[known order:
  {1010, 1010, 2},
  {1010, 1020, 2},
  {1010, 1030, 2},
  {1020, 1010, 2},
  {1030, 1010, 2},
  {1030, 1020, 2}
]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=no_match_from_label_or_where_or_quantifier_1]
# path pattern finds no matches due to label-expr
select * from graph_table(aml
  MATCH ANY (x:Account)-[e]->{2, 4}(y:Human)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.id AS y_id, hops
  UNION ALL
  MATCH ANY SHORTEST ((x:Account)-[e:Transfer]->{2, 4}(y) WHERE false)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
  UNION ALL
  MATCH ANY ((x:Account)-[e]->{1}(y:Account) WHERE x.account_id = 1010 AND y.account_id = 1030)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=no_match_from_label_or_where_or_quantifier_2]
# path pattern finds no matches due to label-expr
select * from graph_table(aml
  MATCH ANY SHORTEST (x:Account)-[e]->{2, 4}(y:Human)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.id AS y_id, hops
  UNION ALL
  MATCH ANY ((x:Account)-[e:Transfer]->{2, 4}(y) WHERE false)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
  UNION ALL
  MATCH ANY SHORTEST ((x:Account)-[e]->{1}(y:Account) WHERE x.account_id = 1010 AND y.account_id = 1030)
  let hops = ARRAY_LENGTH(e)
  return x.account_id AS x_id, y.account_id AS y_id, hops
)
order by x_id, y_id
--
ARRAY<STRUCT<x_id INT64, y_id INT64, hops INT64>>[]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=unspecified_path_mode_with_scalar_edges]
# This serves as a baseline for the following path mode tests. Note the repeated edges and nodes in the results.
select * from graph_table(aml
  MATCH (a:Account {account_id: 1010})-[e1:Transfer]->(b:Account)-[e2:Transfer]->(c:Account)-[e3:Transfer]->(d:Account)
  return a.account_id as a_id, e1.amount as e1_amount, b.account_id as b_id, e2.amount as e2_amount, c.account_id as c_id, e3.amount as e3_amount, d.account_id as d_id
)
ORDER BY 1, 2, 3, 4, 5, 6, 7
--
ARRAY<STRUCT<a_id INT64,
             e1_amount INT64,
             b_id INT64,
             e2_amount INT64,
             c_id INT64,
             e3_amount INT64,
             d_id INT64>>
[known order:
  {1010, 100, 1020, 300, 1030, 500, 1010},
  {1010, 100, 1020, 400, 1030, 500, 1010},
  {1010, 200, 1020, 300, 1030, 500, 1010},
  {1010, 200, 1020, 400, 1030, 500, 1010},
  {1010, 600, 1010, 100, 1020, 300, 1030},
  {1010, 600, 1010, 100, 1020, 400, 1030},
  {1010, 600, 1010, 200, 1020, 300, 1030},
  {1010, 600, 1010, 200, 1020, 400, 1030},
  {1010, 600, 1010, 600, 1010, 100, 1020},
  {1010, 600, 1010, 600, 1010, 200, 1020},
  {1010, 600, 1010, 600, 1010, 600, 1010}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_MODE]
[name=walk_path_mode_with_scalar_edges]
# Similar to unspecified path mode case above.
select * from graph_table(aml
  MATCH WALK (a:Account {account_id: 1010})-[e1:Transfer]->(b:Account)-[e2:Transfer]->(c:Account)-[e3:Transfer]->(d:Account)
  return a.account_id as a_id, e1.amount as e1_amount, b.account_id as b_id, e2.amount as e2_amount, c.account_id as c_id, e3.amount as e3_amount, d.account_id as d_id
)
ORDER BY 1, 2, 3, 4, 5, 6, 7
--
ARRAY<STRUCT<a_id INT64,
             e1_amount INT64,
             b_id INT64,
             e2_amount INT64,
             c_id INT64,
             e3_amount INT64,
             d_id INT64>>
[known order:
  {1010, 100, 1020, 300, 1030, 500, 1010},
  {1010, 100, 1020, 400, 1030, 500, 1010},
  {1010, 200, 1020, 300, 1030, 500, 1010},
  {1010, 200, 1020, 400, 1030, 500, 1010},
  {1010, 600, 1010, 100, 1020, 300, 1030},
  {1010, 600, 1010, 100, 1020, 400, 1030},
  {1010, 600, 1010, 200, 1020, 300, 1030},
  {1010, 600, 1010, 200, 1020, 400, 1030},
  {1010, 600, 1010, 600, 1010, 100, 1020},
  {1010, 600, 1010, 600, 1010, 200, 1020},
  {1010, 600, 1010, 600, 1010, 600, 1010}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_MODE]
[name=trail_path_mode_with_scalar_edges]
select * from graph_table(aml
  MATCH TRAIL (a:Account {account_id: 1010})-[e1:Transfer]->(b:Account)-[e2:Transfer]->(c:Account)-[e3:Transfer]->(d:Account)
  return a.account_id as a_id, e1.amount as e1_amount, b.account_id as b_id, e2.amount as e2_amount, c.account_id as c_id, e3.amount as e3_amount, d.account_id as d_id
)
ORDER BY 1, 2, 3, 4, 5, 6, 7
--
ARRAY<STRUCT<a_id INT64,
             e1_amount INT64,
             b_id INT64,
             e2_amount INT64,
             c_id INT64,
             e3_amount INT64,
             d_id INT64>>
[known order:
  {1010, 100, 1020, 300, 1030, 500, 1010},
  {1010, 100, 1020, 400, 1030, 500, 1010},
  {1010, 200, 1020, 300, 1030, 500, 1010},
  {1010, 200, 1020, 400, 1030, 500, 1010},
  {1010, 600, 1010, 100, 1020, 300, 1030},
  {1010, 600, 1010, 100, 1020, 400, 1030},
  {1010, 600, 1010, 200, 1020, 300, 1030},
  {1010, 600, 1010, 200, 1020, 400, 1030}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_MODE]
[name=acyclic_path_mode_with_scalar_edges]
select * from graph_table(aml
  MATCH ACYCLIC (a:Account {account_id: 1010})-[e1:Transfer]->(b:Account)-[e2:Transfer]->(c:Account)-[e3:Transfer]->(d:Account)
  return a.account_id as a_id, e1.amount as e1_amount, b.account_id as b_id, e2.amount as e2_amount, c.account_id as c_id, e3.amount as e3_amount, d.account_id as d_id
)
ORDER BY 1, 2, 3, 4, 5, 6, 7
--
ARRAY<STRUCT<a_id INT64,
             e1_amount INT64,
             b_id INT64,
             e2_amount INT64,
             c_id INT64,
             e3_amount INT64,
             d_id INT64>>[]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_MODE]
[name=simple_path_mode_with_scalar_edges]
select * from graph_table(aml
  MATCH SIMPLE (a:Account {account_id: 1010})-[e1:Transfer]->(b:Account)-[e2:Transfer]->(c:Account)-[e3:Transfer]->(d:Account)
  return a.account_id as a_id, e1.amount as e1_amount, b.account_id as b_id, e2.amount as e2_amount, c.account_id as c_id, e3.amount as e3_amount, d.account_id as d_id
)
ORDER BY 1, 2, 3, 4, 5, 6, 7
--
ARRAY<STRUCT<a_id INT64,
             e1_amount INT64,
             b_id INT64,
             e2_amount INT64,
             c_id INT64,
             e3_amount INT64,
             d_id INT64>>
[known order:
  {1010, 100, 1020, 300, 1030, 500, 1010},
  {1010, 100, 1020, 400, 1030, 500, 1010},
  {1010, 200, 1020, 300, 1030, 500, 1010},
  {1010, 200, 1020, 400, 1030, 500, 1010}
]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_MODE]
[name=trail_path_mode_with_scalar_edges_of_different_types]
select * from graph_table(aml
  MATCH TRAIL (a)-[e1]->(b)-[e2:Transfer]->(c)-[e3]->(d)
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{57}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_MODE]
[name=acyclic_path_mode_with_scalar_edges_of_different_types]
select * from graph_table(aml
  MATCH ACYCLIC (a)-[e1]->(b)-[e2:Transfer]->(c)-[e3]->(d)
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{16}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_MODE]
[name=simple_path_mode_with_scalar_edges_of_different_types]
select * from graph_table(aml
  MATCH SIMPLE (a)-[e1]->(b)-[e2:Transfer]->(c)-[e3]->(d)
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{32}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_MODE]
[name=trail_path_mode_with_duplicate_scalar_nodes]
select * from graph_table(aml
  MATCH TRAIL (a)->(b)(->(c)->(d))()
  RETURN COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{87}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_MODE]
[name=acyclic_path_mode_with_duplicate_scalar_nodes]
select * from graph_table(aml
  MATCH ACYCLIC (a)->(b)(->(c)->(d))()
  RETURN COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{25}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_MODE]
[name=simple_path_mode_with_duplicate_scalar_nodes]
select * from graph_table(aml
  MATCH SIMPLE (a)->(b)(->(c)->(d))()
  RETURN COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{43}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=trail_path_mode_with_array_edges]
select * from graph_table(aml
  MATCH TRAIL ((a:Account)-[e:Transfer]->(b:Account)){3}
  RETURN COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{20}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=acyclic_path_mode_with_array_edges]
select * from graph_table(aml
  MATCH ACYCLIC ((a:Account)-[e:Transfer]->(b:Account)){3}
  RETURN COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{0}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=simple_path_mode_with_array_edges]
select * from graph_table(aml
  MATCH SIMPLE ((a:Account)-[e:Transfer]->(b:Account)){3}
  RETURN COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{12}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=trail_path_mode_with_array_edges_of_different_types]
select * from graph_table(aml
  MATCH TRAIL (a)-[e1]->{1,3}(b)
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{140}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=acyclic_path_mode_with_array_edges_of_different_types]
select * from graph_table(aml
  MATCH ACYCLIC (a)-[e1]->{1,3}(b)
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{61}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=simple_path_mode_with_array_edges_of_different_types]
select * from graph_table(aml
  MATCH SIMPLE (a)-[e1]->{1,3}(b)
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{87}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=trail_path_mode_with_scalar_and_array_edges]
select * from graph_table(aml
  MATCH TRAIL (a:Human)-[e1]->(b:Human)-[e2]->{1,3}(c:Human)
  RETURN a.key_id as a_id, b.key_id as b_id, c.key_id as c_id, ARRAY_LENGTH(e2) as path_legnth
  ORDER BY a_id, b_id, c_id, path_legnth
)
--
ARRAY<STRUCT<a_id INT64, b_id INT64, c_id INT64, path_legnth INT64>>[unknown order:
  {1, 1, 1, 2},
  {1, 1, 2, 1},
  {1, 2, 1, 1},
  {1, 2, 1, 2},
  {2, 1, 1, 1},
  {2, 1, 2, 1},
  {2, 1, 2, 2}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=acyclic_path_mode_with_scalar_and_array_edges]
select * from graph_table(aml
  MATCH ACYCLIC (a:Human)-[e1]->(b:Human)-[e2]->{1,3}(c:Human)
  RETURN a.key_id as a_id, b.key_id as b_id, c.key_id as c_id, ARRAY_LENGTH(e2) as path_legnth
  ORDER BY a_id, b_id, c_id, path_legnth
)
--
ARRAY<STRUCT<a_id INT64, b_id INT64, c_id INT64, path_legnth INT64>>[]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=simple_path_mode_with_scalar_and_array_edges]
select * from graph_table(aml
  MATCH SIMPLE (a:Human)-[e1]->(b:Human)-[e2]->{1,3}(c:Human)
  RETURN a.key_id as a_id, b.key_id as b_id, c.key_id as c_id, ARRAY_LENGTH(e2) as path_legnth
  ORDER BY a_id, b_id, c_id, path_legnth
)
--
ARRAY<STRUCT<a_id INT64, b_id INT64, c_id INT64, path_legnth INT64>>[unknown order:
  {1, 2, 1, 1},
  {2, 1, 2, 1}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE,V_1_3_UNNEST_AND_FLATTEN_ARRAYS]
[name=trail_path_mode_with_scalar_and_long_array_edges_of_different_types]
select * from graph_table(aml
  MATCH TRAIL (a)-[e1]->((b:Account)-[e2:Transfer WHERE MOD(e2.amount, 200) != 0]->(c:Account)-[e3:Transfer WHERE MOD(e3.amount, 200) != 0]->(d:Account)){1}(e:Account)
  RETURN a.key_id as a_id, flatten(b.account_id) as b_ids, flatten(c.account_id) as c_ids, flatten(d.account_id) as d_ids
  ORDER BY a_id, e.key_id
)
--
ARRAY<STRUCT<a_id INT64, b_ids ARRAY<>, c_ids ARRAY<>, d_ids ARRAY<>>>[unknown order:
  {1, ARRAY<INT64>[1010], ARRAY<INT64>[1020], ARRAY<INT64>[1030]},
  {2, ARRAY<INT64>[1030], ARRAY<INT64>[1010], ARRAY<INT64>[1020]},
  {10, ARRAY<INT64>[1020], ARRAY<INT64>[1030], ARRAY<INT64>[1010]},
  {10, ARRAY<INT64>[1020], ARRAY<INT64>[1030], ARRAY<INT64>[1010]},
  {10, ARRAY<INT64>[1020], ARRAY<INT64>[1030], ARRAY<INT64>[1010]},
  {10, ARRAY<INT64>[1010], ARRAY<INT64>[1020], ARRAY<INT64>[1030]},
  {20, ARRAY<INT64>[1030], ARRAY<INT64>[1010], ARRAY<INT64>[1020]},
  {20, ARRAY<INT64>[1030], ARRAY<INT64>[1010], ARRAY<INT64>[1020]},
  {30, ARRAY<INT64>[1020], ARRAY<INT64>[1030], ARRAY<INT64>[1010]},
  {30, ARRAY<INT64>[1010], ARRAY<INT64>[1020], ARRAY<INT64>[1030]}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE,V_1_3_UNNEST_AND_FLATTEN_ARRAYS]
[name=acyclic_path_mode_with_scalar_and_long_array_edges_of_different_types]
select * from graph_table(aml
  MATCH ACYCLIC (a)-[e1]->((b:Account)-[e2:Transfer WHERE MOD(e2.amount, 200) != 0]->(c:Account)-[e3:Transfer WHERE MOD(e3.amount, 200) != 0]->(d:Account)){1}(e:Account)
  RETURN a.key_id as a_id, flatten(b.account_id) as b_ids, flatten(c.account_id) as c_ids, flatten(d.account_id) as d_ids
  ORDER BY a_id, e.key_id
)
--
ARRAY<STRUCT<a_id INT64, b_ids ARRAY<>, c_ids ARRAY<>, d_ids ARRAY<>>>[unknown order:
  {1, ARRAY<INT64>[1010], ARRAY<INT64>[1020], ARRAY<INT64>[1030]},
  {2, ARRAY<INT64>[1030], ARRAY<INT64>[1010], ARRAY<INT64>[1020]}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE,V_1_3_UNNEST_AND_FLATTEN_ARRAYS]
[name=simple_path_mode_with_scalar_and_long_array_edges_of_different_types]
select * from graph_table(aml
  MATCH SIMPLE (a)-[e1]->((b:Account)-[e2:Transfer WHERE MOD(e2.amount, 200) != 0]->(c:Account)-[e3:Transfer WHERE MOD(e3.amount, 200) != 0]->(d:Account)){1}(e:Account)
  RETURN a.key_id as a_id, flatten(b.account_id) as b_ids, flatten(c.account_id) as c_ids, flatten(d.account_id) as d_ids
  ORDER BY a_id, e.key_id
)
--
ARRAY<STRUCT<a_id INT64, b_ids ARRAY<>, c_ids ARRAY<>, d_ids ARRAY<>>>[unknown order:
  {1, ARRAY<INT64>[1010], ARRAY<INT64>[1020], ARRAY<INT64>[1030]},
  {2, ARRAY<INT64>[1030], ARRAY<INT64>[1010], ARRAY<INT64>[1020]},
  {10, ARRAY<INT64>[1020], ARRAY<INT64>[1030], ARRAY<INT64>[1010]},
  {10, ARRAY<INT64>[1020], ARRAY<INT64>[1030], ARRAY<INT64>[1010]},
  {10, ARRAY<INT64>[1020], ARRAY<INT64>[1030], ARRAY<INT64>[1010]},
  {20, ARRAY<INT64>[1030], ARRAY<INT64>[1010], ARRAY<INT64>[1020]},
  {20, ARRAY<INT64>[1030], ARRAY<INT64>[1010], ARRAY<INT64>[1020]},
  {30, ARRAY<INT64>[1010], ARRAY<INT64>[1020], ARRAY<INT64>[1030]}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=trail_path_mode_with_array_edges_and_duplicate_scalar_nodes]
select * from graph_table(aml
  MATCH TRAIL (a)((b)-[e1]->){2}->(c)
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{87}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=acyclic_path_mode_with_array_edges_and_duplicate_scalar_nodes]
select * from graph_table(aml
  MATCH ACYCLIC (a)((b)-[e1]->){2}->(c)
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{25}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=simple_path_mode_with_array_edges_and_duplicate_scalar_nodes]
select * from graph_table(aml
  MATCH SIMPLE (a)((b)-[e1]->){2}->(c)
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{43}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=trail_path_mode_with_scalar_and_array_edges_of_different_types]
select * from graph_table(aml
  MATCH TRAIL (a)-[e1:Transfer]->(b)-[e2]->{1,3}(c)
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{133}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=acyclic_path_mode_with_scalar_and_array_edges_of_different_types]
select * from graph_table(aml
  MATCH ACYCLIC (a)-[e1:Transfer]->(b)-[e2]->{1,3}(c)
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{18}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=simple_path_mode_with_scalar_and_array_edges_of_different_types]
select * from graph_table(aml
  MATCH SIMPLE (a)-[e1:Transfer]->(b)-[e2]->{1,3}(c)
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{36}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=trail_path_mode_with_array_edges_over_quantified_paths]
select * from graph_table(aml
  MATCH TRAIL ((-[e]->)){1,3}
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{140}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=acyclic_path_mode_with_array_edges_over_quantified_paths]
select * from graph_table(aml
  MATCH ACYCLIC ((-[e]->)){1,3}
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{61}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=simple_path_mode_with_array_edges_over_quantified_paths]
select * from graph_table(aml
  MATCH SIMPLE ((-[e]->)){1,3}
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{87}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=trail_path_mode_with_scalar_edges_within_quantified_paths]
select * from graph_table(aml
  MATCH (TRAIL (-[e]->)){1,3}
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{159}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=acyclic_path_mode_with_scalar_edges_within_quantified_paths]
select * from graph_table(aml
  MATCH (ACYCLIC (-[e]->)){1,3}
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{107}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=simple_path_mode_with_scalar_edges_within_quantified_paths]
select * from graph_table(aml
  MATCH (SIMPLE (-[e]->)){1,3}
  return COUNT(1) as num_paths
)
--
ARRAY<STRUCT<num_paths INT64>>[{159}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_MODE,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=walk_path_mode_with_scalar_edges_with_path_variable]
# This serves as a baseline for the following trail test. Note the repeated edge on the results.
select * from graph_table(aml
  MATCH p=WALK (a:Account {account_id: 1010})-[e1:Transfer]->(b:Account {account_id: 1010})-[e2:Transfer]->(c:Account)
  return a.account_id as a_id, e1.amount as e1_amount, b.account_id as b_id, e2.amount as e2_amount, c.account_id as c_id, path_length(p) as len
)
ORDER BY 1, 2, 3, 4, 5, 6
--

ARRAY<STRUCT<a_id INT64,
             e1_amount INT64,
             b_id INT64,
             e2_amount INT64,
             c_id INT64,
             len INT64>>
[known order:
  {1010, 600, 1010, 100, 1020, 2},
  {1010, 600, 1010, 200, 1020, 2},
  {1010, 600, 1010, 600, 1010, 2}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_MODE,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=trail_path_mode_with_scalar_edges_with_path_variable]
select * from graph_table(aml
  MATCH p=TRAIL (a:Account {account_id: 1010})-[e1:Transfer]->(b:Account {account_id: 1010})-[e2:Transfer]->(c:Account)
  return a.account_id as a_id, e1.amount as e1_amount, b.account_id as b_id, e2.amount as e2_amount, c.account_id as c_id, path_length(p) as len
)
ORDER BY 1, 2, 3, 4, 5, 6
--
ARRAY<STRUCT<a_id INT64,
             e1_amount INT64,
             b_id INT64,
             e2_amount INT64,
             c_id INT64,
             len INT64>>
[known order:
  {1010, 600, 1010, 100, 1020, 2},
  {1010, 600, 1010, 200, 1020, 2}
]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_MODE,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=trail_path_mode_with_scalar_edges_of_different_types_with_path_variable]
select distinct len from graph_table(aml
  MATCH p=TRAIL (a)-[e1]->(b)-[e2:Transfer]->(c)-[e3]->(d)
  return path_length(p) as len
)
order by 1
--
ARRAY<STRUCT<len INT64>>[{3}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=trail_path_mode_with_array_edges_with_path_variable]
select distinct len from graph_table(aml
  MATCH p=TRAIL (a)-[e1]->{1,3}(b)
  return path_length(p) as len
)
order by 1
--
ARRAY<STRUCT<len INT64>>[known order:{1}, {2}, {3}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=trail_path_mode_with_scalar_and_array_edges_with_path_variable]
select distinct len from graph_table(aml
  MATCH p=TRAIL (a)-[e1]->(b)-[e2]->{1,3}(c)
  return path_length(p) as len
)
order by 1
--
ARRAY<STRUCT<len INT64>>[known order:{2}, {3}, {4}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=trail_path_mode_with_scalar_and_array_edges_of_different_types_with_path_variable]
select distinct len from graph_table(aml
  MATCH p=TRAIL (a)-[e1:Transfer]->(b)-[e2]->{1,3}(c)
  return path_length(p) as len
)
order by 1
--
ARRAY<STRUCT<len INT64>>[known order:{2}, {3}, {4}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=trail_path_mode_with_array_edges_over_quantified_paths_with_path_variable]
select distinct len from graph_table(aml
  MATCH p=TRAIL ((-[e]->)){1,3}
  return path_length(p) as len
)
order by 1
--
ARRAY<STRUCT<len INT64>>[known order:{1}, {2}, {3}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=trail_path_mode_with_scalar_edges_within_quantified_paths_with_path_variable]
select distinct len from graph_table(aml
  MATCH p=(TRAIL (-[e]->)){1,3}
  return path_length(p) as len
)
order by 1
--
ARRAY<STRUCT<len INT64>>[known order:{1}, {2}, {3}]

==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=multiple_labels_between_same_nodes_without_quantification]
select * from graph_table(aml
  MATCH ANY (a: Account)-[mid: can_transfer | Transfer]->(b: Account)
  return a.account_id AS a_acct_id, b.account_id AS b_acct_id
)
order by a_acct_id, b_acct_id
--
ARRAY<STRUCT<a_acct_id INT64, b_acct_id INT64>>[known order:
  {1010, 1010},
  {1010, 1020},
  {1010, 1040},
  {1020, 1030},
  {1030, 1010},
  {1030, 1020},
  {1030, 1040}
]

NOTE: Reference implementation reports non-determinism.
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_simple_no_quantification]
select distinct len from graph_table(aml
  match p=(a)-[e]-(b)
  return path_length(p) as len
)
order by len
--
ARRAY<STRUCT<len INT64>>[{1}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_multiple_match_no_quantification]
select distinct one from graph_table(aml
  match p=(a)-[e1]->(b)-[e2]->(c)
  match q=(x)-[y]->(z), unused_path = (-[k]->){1,1}
  return path_length(p) - path_length(q) as one
)
order by one
--
ARRAY<STRUCT<one INT64>>[{1}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_simple_with_quantification]
select distinct len from graph_table(aml
  match p=(a)-[e]->{1,3}(b)
  return path_length(p) as len
)
order by len
--
ARRAY<STRUCT<len INT64>>[known order:{1}, {2}, {3}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_nested_no_quantification]
select distinct len from graph_table(aml
  match p=(a)(-[e:Transfer]-> -[f:Transfer]->)(b)
  return path_length(p) as len
)
order by len
--
ARRAY<STRUCT<len INT64>>[{2}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_nested_with_quantification]
select distinct len from graph_table(aml
  match p=(a)(-[e:Transfer]->{1,1} -[f:Transfer]->{1,2}((x)-[y]->(z))-[j]->(k))(b)
  return path_length(p) as len
)
order by len
--
ARRAY<STRUCT<len INT64>>[known order:{4}, {5}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_nested_with_quantification_all]
select distinct len from graph_table(aml
  match p=all (a)(-[e:Transfer]->{1,1} -[f:Transfer]->{1,2}((x)-[y]->(z))-[j]->(k))(b)
  return path_length(p) as len
)
order by len
--
ARRAY<STRUCT<len INT64>>[known order:{4}, {5}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_nested_with_quantification_any]
select distinct len from graph_table(aml
  match p=any (a)(-[e:Transfer]->{1,1} -[f:Transfer]->{2,2}((x)-[y]->(z))-[j]->(k))(b)
  return path_length(p) as len
)
order by len
--
ARRAY<STRUCT<len INT64>>[{5}]

NOTE: Reference implementation reports non-determinism.
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_nested_with_quantification_any_shortest]
select distinct len from graph_table(aml
  match p=any shortest (a)(-[e:Transfer]->{1,1} -[f:Transfer]->{1,2}((x)-[y]->(z))-[j]->(k))(b)
  return path_length(p) as len
)
order by len
--
ARRAY<STRUCT<len INT64>>[{4}]

NOTE: Reference implementation reports non-determinism.
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_EXPOSE_GRAPH_ELEMENT,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_GROUP_BY_GRAPH_PATH]
[name=path_variable_group_by_path]
select distinct path_length(p) from graph_table(aml
  match p=(a)(-[e:Transfer]->{1,1} -[f:Transfer]->{1,2}((x)-[y]->(z))-[j]->(k))(b)
  return p
)
group by p
order by 1
--
ARRAY<STRUCT<INT64>>[known order:{4}, {5}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_deeply_nested_with_quantification]
select distinct len from graph_table(aml
  match p=(a)-(((((x)-[y]-(z))){1,2}))
  return path_length(p) as len
)
order by len
--
ARRAY<STRUCT<len INT64>>[known order:{2}, {3}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_variable_equality]
select b_id, p_amount, c_id, q_amount, paths_equal from graph_table(aml
  match p=(a:Account)(-[e1:Transfer]->(b:Account))
  optional match q=(a:Account)(-[e2:Transfer]->(c:Account))
  return e1.amount as p_amount, e2.amount as q_amount, b.account_id as b_id,
         c.account_id as c_id, p=q as paths_equal
)
order by 1, 2, 3, 4, 5
--
ARRAY<STRUCT<b_id INT64,
             p_amount INT64,
             c_id INT64,
             q_amount INT64,
             paths_equal BOOL>>
[known order:
  {1010, 500, 1010, 500, true},
  {1010, 600, 1010, 600, true},
  {1010, 600, 1020, 100, false},
  {1010, 600, 1020, 200, false},
  {1020, 100, 1010, 600, false},
  {1020, 100, 1020, 100, true},
  {1020, 100, 1020, 200, false},
  {1020, 200, 1010, 600, false},
  {1020, 200, 1020, 100, false},
  {1020, 200, 1020, 200, true},
  {1030, 300, 1030, 300, true},
  {1030, 300, 1030, 400, false},
  {1030, 400, 1030, 300, false},
  {1030, 400, 1030, 400, true}
]
==

[required_features=V_1_3_IS_DISTINCT,V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_GROUP_BY_GRAPH_PATH]
[name=path_variable_is_not_distinct]
select b_id, p_amount, c_id, q_amount, paths_not_distinct from graph_table(aml
  match p=(a:Account)(-[e1:Transfer]->(b:Account))
  match q=(a:Account)(-[e2:Transfer]->(c:Account))
  return e1.amount as p_amount, e2.amount as q_amount, b.account_id as b_id,
         c.account_id as c_id, p is not distinct from q as paths_not_distinct
)
order by 1, 2, 3, 4, 5
--
ARRAY<STRUCT<
        b_id INT64,
        p_amount INT64,
        c_id INT64,
        q_amount INT64,
        paths_not_distinct BOOL
      >>
[known order:
  {1010, 500, 1010, 500, true},
  {1010, 600, 1010, 600, true},
  {1010, 600, 1020, 100, false},
  {1010, 600, 1020, 200, false},
  {1020, 100, 1010, 600, false},
  {1020, 100, 1020, 100, true},
  {1020, 100, 1020, 200, false},
  {1020, 200, 1010, 600, false},
  {1020, 200, 1020, 100, false},
  {1020, 200, 1020, 200, true},
  {1030, 300, 1030, 300, true},
  {1030, 300, 1030, 400, false},
  {1030, 400, 1030, 300, false},
  {1030, 400, 1030, 400, true}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_EXPOSE_GRAPH_ELEMENT,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_length_with_null_input]
select path_length(p)
FROM graph_table(aml
  match p=(n) -[e]-> (m)
  return p
) gt
RIGHT JOIN (SELECT 1)
ON FALSE
--
ARRAY<STRUCT<INT64>>[{NULL}]
==

# Each repetition of the path adds 2 nodes to the concatenated array `arr`,
# so ARR_LEN(arr) is double the particular repetition count of the path in that
# row.
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_EXPOSE_GRAPH_ELEMENT,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_1_CAST_DIFFERENT_ARRAY_TYPES]
[name=array_concat_with_arrays_of_graph_elements_and_supertype_no_lambda]
select ARRAY_LENGTH(arr) AS len
from graph_table(
  aml
  MATCH ALL (src WHERE src.account_id = 1010)((x IS Account)-[y]->(z)){1, 3} (src)
  COLUMNS(ARRAY_CONCAT(x, z) AS arr)
)
ORDER BY 1
--
ARRAY<STRUCT<len INT64>>[known order:
  {2},
  {4},
  {6},
  {6},
  {6},
  {6},
  {6},
  {6},
  {6}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_1_CAST_DIFFERENT_ARRAY_TYPES,V_1_3_INLINE_LAMBDA_ARGUMENT]
[name=array_concat_with_arrays_of_graph_elements_and_supertype_with_lambda]
select * from graph_table(
  aml
  MATCH ALL (src WHERE src.account_id = 1010)((x IS Account)-[y]->(z)){3} (src)
  COLUMNS(
    ARRAY_TRANSFORM(ARRAY_CONCAT(x, z), x -> x.account_id) AS ids,
    ARRAY_TRANSFORM(ARRAY_CONCAT(x, z), x -> x.name) AS names   # Nulls because all are accounts
  )
)
ORDER BY ids[offset(0)], ids[offset(1)], ids[offset(2)], ids[offset(3)], ids[offset(4)], ids[offset(5)]
--
ARRAY<STRUCT<ids ARRAY<>, names ARRAY<>>>[known order:
  {
    ARRAY<INT64>[known order:1010, 1010, 1010, 1010, 1010, 1010],
    ARRAY<STRING>[known order:NULL, NULL, NULL, NULL, NULL, NULL]
  },
  {
    ARRAY<INT64>[known order:1010, 1020, 1030, 1020, 1030, 1010],
    ARRAY<STRING>[known order:NULL, NULL, NULL, NULL, NULL, NULL]
  },
  {
    ARRAY<INT64>[known order:1010, 1020, 1030, 1020, 1030, 1010],
    ARRAY<STRING>[known order:NULL, NULL, NULL, NULL, NULL, NULL]
  },
  {
    ARRAY<INT64>[known order:1010, 1020, 1030, 1020, 1030, 1010],
    ARRAY<STRING>[known order:NULL, NULL, NULL, NULL, NULL, NULL]
  },
  {
    ARRAY<INT64>[known order:1010, 1020, 1030, 1020, 1030, 1010],
    ARRAY<STRING>[known order:NULL, NULL, NULL, NULL, NULL, NULL]
  },
  {
    ARRAY<INT64>[known order:1010, 1020, 1030, 1020, 1030, 1010],
    ARRAY<STRING>[known order:NULL, NULL, NULL, NULL, NULL, NULL]
  },
  {
    ARRAY<INT64>[known order:1010, 1020, 1030, 1020, 1030, 1010],
    ARRAY<STRING>[known order:NULL, NULL, NULL, NULL, NULL, NULL]
  }
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_equality_with_null_input]
select distinct *
FROM graph_table(aml
  optional match p=(a) where false
  match q = (x)
  return p = p as should_be_null,
         p = q as should_be_null2,
         q = q as should_be_true
) gt
--
ARRAY<STRUCT<should_be_null BOOL, should_be_null2 BOOL, should_be_true BOOL>>[
  {NULL, NULL, true}
]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_equality_with_null_input_with_edges]
select distinct *
FROM graph_table(aml
  optional match p=(a)-[]- where false
  match q = (x)-[e]-
  return p = p as should_be_null,
         p = q as should_be_null2,
         q = q as should_be_true
) gt
--
ARRAY<STRUCT<should_be_null BOOL, should_be_null2 BOOL, should_be_true BOOL>>[
  {NULL, NULL, true}
]
==
[required_features=V_1_3_IS_DISTINCT,V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_GROUP_BY_GRAPH_PATH]
[name=path_is_distinct_from_with_null_input]
select distinct *
FROM graph_table(aml
  optional match p=(a) where false
  match q = (x)
  return p is distinct from p as should_be_false,
         p is distinct from q as should_be_true,
         q is distinct from q as should_be_false2
) gt
--
ARRAY<STRUCT<
        should_be_false BOOL,
        should_be_true BOOL,
        should_be_false2 BOOL
      >>[{false, true, false}]
==
[required_features=V_1_3_IS_DISTINCT,V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_GROUP_BY_GRAPH_PATH]
[name=path_is_distinct_from_with_null_input_with_edges]
select distinct *
FROM graph_table(aml
  optional match p=(a)-[]- where false
  match q = (x)-[e]-
  return p is distinct from p as should_be_false,
         p is distinct from q as should_be_true,
         q is distinct from q as should_be_false2
) gt
--
ARRAY<STRUCT<
        should_be_false BOOL,
        should_be_true BOOL,
        should_be_false2 BOOL
      >>[{false, true, false}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_EXPOSE_GRAPH_ELEMENT,V_1_4_GROUP_BY_GRAPH_PATH]
[name=path_intersect_distinct]
with paths1 as ((select * from graph_table(aml match p=(:Human) return p))
  intersect distinct
  (select * from graph_table(aml match q=(:Human) return q))),
paths2 as (select * from graph_table(aml match p=(:Human) return p))

SELECT EXISTS(SELECT * FROM paths1 EXCEPT ALL SELECT * FROM paths2 LIMIT 1) OR
       EXISTS(SELECT * FROM paths2 EXCEPT ALL SELECT * FROM paths1 LIMIT 1)
       as not_equal
--
ARRAY<STRUCT<not_equal BOOL>>[{false}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_nodes_with_null_input]
select len
FROM graph_table(aml
  optional match p=(a) where false
  return array_length(nodes(p)) as len
) gt
--
ARRAY<STRUCT<len INT64>>[{NULL}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_edges_with_null_input]
select len
FROM graph_table(aml
  optional match p=(a) where false
  return array_length(edges(p)) as len
) gt
--
ARRAY<STRUCT<len INT64>>[{NULL}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_nodes_simple]
select distinct invariants
FROM graph_table(aml
  match p=(n) -[e]-> (m)
  let nodes = nodes(p)
  let invariant1 = nodes[safe_offset(0)] = n
  let invariant2 = nodes[safe_offset(1)] = m
  return invariant1 and invariant2 as invariants
) gt
--
ARRAY<STRUCT<invariants BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_edges_simple]
select distinct invariants
FROM graph_table(aml
  match p=(n) -[e]-> (m)
  let edges = edges(p)
  let invariant1 = edges[safe_offset(0)] = e
  return invariant1 as invariants
) gt
--
ARRAY<STRUCT<invariants BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_nodes_with_quantification]
select distinct invariants
FROM graph_table(aml
  match p=((n) -[e]-> (m)){1,2}
  let nodes = nodes(p)
  let invariant1 = nodes[safe_offset(0)] = n[safe_offset(0)]
  let invariant2 = ifnull(nodes[safe_offset(1)] = n[safe_offset(1)], true)
  let invariant3 = nodes[safe_offset(1)] = m[safe_offset(0)]
  let invariant4 = ifnull(nodes[safe_offset(2)] = m[safe_offset(1)], true)
  return invariant1 and invariant2 and invariant3 and invariant4 as invariants
) gt
--
ARRAY<STRUCT<invariants BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_edges_with_quantification]
select distinct invariants
FROM graph_table(aml
  match p=((n) -[e]-> (m)){1,2}
  let edges = edges(p)
  let invariant1 = edges[safe_offset(0)] = e[safe_offset(0)]
  let invariant2 = ifnull(edges[safe_offset(1)] = e[safe_offset(1)], true)
  return invariant1 and invariant2 as invariants
) gt
--
ARRAY<STRUCT<invariants BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_first_with_null_input]
select id
FROM graph_table(aml
  optional match p=(a) where false
  return path_first(p) as head
  next
  return head.account_id as id
) gt
--
ARRAY<STRUCT<id INT64>>[{NULL}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_last_with_null_input]
select id
FROM graph_table(aml
  optional match p=(a) where false
  return path_last(p) as tail
  next
  return tail.account_id as id
) gt
--
ARRAY<STRUCT<id INT64>>[{NULL}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_first_simple]
select distinct invariants
FROM graph_table(aml
  match p=(n) -[e]-> (m)
  let invariant1 = (path_first(p) = n)
  let invariant2 = (path_first(p) = array_first(nodes(p)))
  return invariant1 and invariant2 as invariants
) gt
--
ARRAY<STRUCT<invariants BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_last_simple]
select distinct invariants
FROM graph_table(aml
  match p=(n) -[e]-> (m)
  let invariant1 = (path_last(p) = m)
  let invariant2 = (path_last(p) = array_last(nodes(p)))
  return invariant1 and invariant2 as invariants
) gt
--
ARRAY<STRUCT<invariants BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_first_with_quantification]
select distinct invariants
FROM graph_table(aml
  match p=((n) -[e]-> (m)){1,2}
  let nodes = nodes(p)
  let invariant1 = (path_first(p) = n[safe_offset(0)])
  let invariant2 = (path_first(p) = array_first(nodes(p)))
  return invariant1 and invariant2 as invariants
) gt
--
ARRAY<STRUCT<invariants BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_last_with_quantification]
select distinct invariants
FROM graph_table(aml
  match p=((n) -[e]-> (m)){1,2}
  let nodes = nodes(p)
  let invariant1 = (path_last(p) = m[safe_offset(1)] or path_last(p) = m[safe_offset(0)])
  let invariant2 = (path_last(p) = array_last(nodes(p)))
  return invariant1 and invariant2 as invariants
) gt
--
ARRAY<STRUCT<invariants BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_create_with_null_input]
select len
FROM graph_table(aml
  optional match (a) where false
  return path_length(path(a)) as len
) gt
--
ERROR: generic::out_of_range: Input to the function PATH must not be null
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_create_with_invalid_edges]
select len
FROM graph_table(aml
  match p=(a:Account)-[b:Transfer]->(c:Account)-[d:Transfer]->(e:Account)
  let q = path(a, d, c, b, e)
  return path_length(q) as len
) gt
--
ERROR: generic::out_of_range: The arguments to PATH must contain edges that connect the previous node to the next node. The edge at index 1 does not
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_create_simple]
select distinct invariant
FROM graph_table(aml
  match p=(a:Account)-[b:Transfer]->(c:Account)
  let q = path(a, b, c)
  return p = q as invariant
) gt
--
ARRAY<STRUCT<invariant BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_create_multiple_match]
select distinct invariants
FROM graph_table(aml
  match p=(a:Account)-[b:Transfer]-(c:Account)
  match q=(c:Account)-[d:Transfer]-(e:Account)
  let x = path(a, b, c, d, e)
  let invariant1 = (path_length(x) = path_length(p) + path_length(q))
  let invariant2 = path_first(x) = path_first(p)
  let invariant3 = path_last(x) = path_last(q)
  return invariant1 and invariant2 and invariant3 as invariants
) gt
--
ARRAY<STRUCT<invariants BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_concat_with_null_input]
select distinct is_null
FROM graph_table(aml
  match p = (a:Human)
  optional match q = (b) where false
  return p || q as concatted
  next
  return concatted is null as is_null
) gt
--
ARRAY<STRUCT<is_null BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_concat_with_incompatible_paths]
select distinct len
FROM graph_table(aml
  match p = (a:Account), q = (b:Human)
  return p || q as concatted
  next
  return path_length(concatted) as len
) gt
--
ERROR: generic::out_of_range: Path concatenation requires that the first node of the path to be concatenated is equal to the last node of the previous path
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_concat_simple]
select distinct invariants
FROM graph_table(aml
  match p = (a:Human)-[b]->(c:Human),
        q = (c)-[d:Knows]->(e:Human)-[f:Knows]->(g:Human)
  let concatted = p || q
  let invariant1 = path_length(concatted) = path_length(p) + path_length(q)
  let invariant2 = path_first(concatted) = path_first(p)
  let invariant3 = path_last(concatted) = path_last(q)
  return invariant1 and invariant2 and invariant3 as invariants
) gt
--
ARRAY<STRUCT<invariants BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_concat_multi]
select distinct invariants
FROM graph_table(aml
  match p1 = (a:Account)
  match p2 = (a) -[:Transfer]-> ((b:Account)->(c:Account))
  match p3 = (c) (-[d:Transfer]->) (e:Account)
  let concatted = p1 || p2 || p3
  let invariant1 = path_length(concatted) = path_length(p1) + path_length(p2)
    + path_length(p3)
  let invariant2 = path_first(concatted) = path_first(p1)
  let invariant3 = path_last(concatted) = path_last(p3)
  return invariant1 and invariant2 and invariant3 as invariants
) gt
--
ARRAY<STRUCT<invariants BOOL>>[{true}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_concat_with_quantification]
select distinct invariants
FROM graph_table(aml
  match p1 = (a:Account)
  match p2 = (a) (-[b:Transfer]->){1, 2} (c:Account)
  match p3 = (c) -[d:Transfer]->{1, 2} (e:Account)
  match p4 = (e)-[f:Transfer]->(g:Account)
  let concatted = p1 || p2 || p3 || p4
  let invariant1 = path_length(concatted) = path_length(p1) + path_length(p2)
    + path_length(p3) + path_length(p4)
  let invariant2 = path_first(concatted) = path_first(p1)
  let invariant3 = path_last(concatted) = path_last(p4)
  return invariant1 and invariant2 and invariant3 as invariants
) gt
--
ARRAY<STRUCT<invariants BOOL>>[{true}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_equality]
select distinct invariants
FROM graph_table(aml
  match p=(a:Account)
  match q=(a)
  match p_prefix=(a)-[e:Transfer]-(b:Account)
  match p_suffix=(x:Account)-[f:Transfer]-(a)
  let invariant1 = p = q
  let invariant2 = q = p
  let invariant3 = p != p_prefix
  let invariant4 = p_prefix != p
  let invariant5 = p != p_suffix
  let invariant6 = p_suffix != p
  let invariant7 = (p = p_prefix) = false
  return invariant1 and invariant2 and invariant3 and invariant4 and invariant5
    and invariant6 and invariant7 as invariants
) gt
--
ARRAY<STRUCT<invariants BOOL>>[{true}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_is_trail_on_null]
SELECT is_trail as should_be_null FROM GRAPH_TABLE(aml
  OPTIONAL MATCH p = (a) WHERE false
  RETURN IS_TRAIL(p) as is_trail)
--
ARRAY<STRUCT<should_be_null BOOL>>[{NULL}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_PATH_MODE]
[name=path_is_trail]
SELECT DISTINCT is_trail as should_be_true FROM GRAPH_TABLE(aml
  MATCH p = TRAIL (a:Human)-[e]-(b)-[e2]-(c:Human)
  RETURN IS_TRAIL(p) as is_trail)
--
ARRAY<STRUCT<should_be_true BOOL>>[{true}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_PATH_MODE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_is_trail_quantified]
SELECT DISTINCT is_trail as should_be_true FROM GRAPH_TABLE(aml
  MATCH p = TRAIL (a:Human)-[e]-{1,3}-(c:Human)
  RETURN IS_TRAIL(p) as is_trail)
--
ARRAY<STRUCT<should_be_true BOOL>>[{true}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_is_acyclic_on_null]
SELECT is_acyclic as should_be_null FROM GRAPH_TABLE(aml
  OPTIONAL MATCH p = (a) WHERE false
  RETURN IS_ACYCLIC(p) as is_acyclic)
--
ARRAY<STRUCT<should_be_null BOOL>>[{NULL}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_is_acyclic_has_cycle]
SELECT distinct is_acyclic as should_be_false FROM GRAPH_TABLE(aml
  MATCH p = (a:Account)-[e:Transfer]-(a:Account)
  RETURN IS_ACYCLIC(p) as is_acyclic)
--
ARRAY<STRUCT<should_be_false BOOL>>[{false}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_is_acyclic]
SELECT distinct is_acyclic as should_be_true FROM GRAPH_TABLE(aml
  MATCH p = (a:Account)-[e:Transfer]-(b:Account)-[e2:Transfer]-(c:Account)
  FILTER ARRAY_IS_DISTINCT(nodes(p))
  RETURN IS_ACYCLIC(p) as is_acyclic)
--
ARRAY<STRUCT<should_be_true BOOL>>[{true}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=path_is_acyclic_quantified]
SELECT DISTINCT is_acyclic as should_be_true FROM GRAPH_TABLE(aml
  MATCH p = (-[e:Transfer]->){1,3}
  FILTER ARRAY_IS_DISTINCT(nodes(p))
  RETURN IS_ACYCLIC(p) as is_acyclic)
--
ARRAY<STRUCT<should_be_true BOOL>>[{true}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_is_simple_on_null]
SELECT is_simple as should_be_null FROM GRAPH_TABLE(aml
  OPTIONAL MATCH p = (a:Account) WHERE false
  RETURN IS_SIMPLE(p) as is_simple)
--
ARRAY<STRUCT<should_be_null BOOL>>[{NULL}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_is_simple_short_path]
SELECT distinct is_simple as should_be_true FROM GRAPH_TABLE(aml
  MATCH p = (a:Account)-[e:Transfer]-(a:Account)
  RETURN IS_SIMPLE(p) as is_simple)
UNION ALL
SELECT distinct is_simple as should_be_true FROM GRAPH_TABLE(aml
  MATCH q = (c:Account)
  RETURN IS_SIMPLE(q) as is_simple)
ORDER BY 1
--
ARRAY<STRUCT<should_be_true BOOL>>[known order:{true}, {true}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_3_INLINE_LAMBDA_ARGUMENT]
[name=path_is_simple_true]
SELECT distinct is_simple as should_be_true FROM GRAPH_TABLE(aml
  MATCH p = (a:Account)-[e:Transfer]->(b:Account)-[e2:Transfer]->(c:Account)
  FILTER ARRAY_IS_DISTINCT(ARRAY_FILTER(NODES(p), (e,i) -> i != 0)) AND
         ARRAY_IS_DISTINCT(ARRAY_FILTER(NODES(p), (e,i) -> i != 2*PATH_LENGTH(p) + 1))
  RETURN IS_SIMPLE(p) as is_simple)
--
ARRAY<STRUCT<should_be_true BOOL>>[{true}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE]
[name=path_is_simple_false]
SELECT distinct is_simple as should_be_false FROM GRAPH_TABLE(aml
  MATCH p = (a:Account)-[e:Transfer]->(a:Account)-[e2:Transfer]->(c:Account)
  RETURN IS_SIMPLE(p) as is_simple)
--
ARRAY<STRUCT<should_be_false BOOL>>[{false}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_3_INLINE_LAMBDA_ARGUMENT]
[name=path_is_simple_quantified]
SELECT DISTINCT is_simple as should_be_true FROM GRAPH_TABLE(aml
  MATCH p = (-[e:Transfer]->){1,3}
  FILTER ARRAY_IS_DISTINCT(ARRAY_FILTER(NODES(p), (e,i) -> i != 0)) AND
         ARRAY_IS_DISTINCT(ARRAY_FILTER(NODES(p), (e,i) -> i != 2*PATH_LENGTH(p) + 1))
  RETURN IS_SIMPLE(p) as is_simple)
--
ARRAY<STRUCT<should_be_true BOOL>>[{true}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_PATH_MODE]
[name=path_is_acyclic_with_path_mode]
SELECT distinct is_acyclic as should_be_true FROM GRAPH_TABLE(aml
  MATCH p = ACYCLIC (a:Account)-[e:Transfer]-(b:Account)-[e2:Transfer]-(c:Account)
  RETURN IS_ACYCLIC(p) as is_acyclic)
--
ARRAY<STRUCT<should_be_true BOOL>>[{true}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=path_is_acyclic_quantified_with_path_mode]
SELECT DISTINCT is_acyclic as should_be_true FROM GRAPH_TABLE(aml
  MATCH p = ACYCLIC (-[e:Transfer]->){1,3}
  RETURN IS_ACYCLIC(p) as is_acyclic)
--
ARRAY<STRUCT<should_be_true BOOL>>[{true}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_PATH_MODE]
[name=path_is_simple_with_path_mode]
SELECT distinct is_simple as should_be_true FROM GRAPH_TABLE(aml
  MATCH p = SIMPLE (a:Account)-[e:Transfer]->(b:Account)-[e2:Transfer]->(c:Account)
  RETURN IS_SIMPLE(p) as is_simple)
--
ARRAY<STRUCT<should_be_true BOOL>>[{true}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_SQL_GRAPH_PATH_MODE]
[name=path_is_simple_quantified_with_path_mode]
SELECT DISTINCT is_simple as should_be_true FROM GRAPH_TABLE(aml
  MATCH p = SIMPLE (-[e:Transfer]->){1,3}
  RETURN IS_SIMPLE(p) as is_simple)
--
ARRAY<STRUCT<should_be_true BOOL>>[{true}]
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=delete_dml_exists_graph_subquery]
DELETE person
WHERE EXISTS(
  select *
  from graph_table(aml
    MATCH (a:Account)-[e:Transfer]->(b:Account)
    WHERE a.account_id = 1010
    return a.account_id AS source_account_id, b.account_id AS target_account_id
  )
)
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  3,
  ARRAY<STRUCT<id INT64, name STRING>>[]
}
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=delete_dml_exists_graph_subquery_set_op]
DELETE person
WHERE EXISTS(
  select *
  from graph_table(aml
    MATCH (a:Account)-[e:Transfer]->(b:Account)
    return a.account_id AS source_account_id, b.account_id AS target_account_id
    INTERSECT ALL
    MATCH (a:Account)-[e:Transfer]->(b:Account)
    WHERE a.account_id = 1010 OR a.account_id = 1020
    return b.account_id AS target_account_id, a.account_id AS source_account_id
  )
)
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  3,
  ARRAY<STRUCT<id INT64, name STRING>>[]
}
==
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY]
[name=delete_dml_exists_graph_subquery_set_op_after_next]
DELETE person
WHERE EXISTS(
  select *
  from graph_table(aml
    MATCH (a:Account)-[e:Transfer]->(b:Account)
    WHERE a.account_id = 1010
    return a.account_id AS source_account_id, b.account_id AS target_account_id
    NEXT
    MATCH (a:Account)-[e:Transfer]->(b:Account)
    return a.account_id AS source_account_id, b.account_id AS target_account_id
    INTERSECT ALL
    MATCH (a:Account)-[e:Transfer]->(b:Account)
    WHERE a.account_id = 1010 OR a.account_id = 1020
    return b.account_id AS target_account_id, a.account_id AS source_account_id
  )
)
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  3,
  ARRAY<STRUCT<id INT64, name STRING>>[]
}
==
# Repro b/366540825
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
[name=array_is_distinct_on_null_graph_elements]
SELECT * FROM GRAPH_TABLE(aml
  OPTIONAL MATCH -[e:Transfer]-{1} WHERE false
  RETURN array_is_distinct(e) as is_distinct)
--
ARRAY<STRUCT<is_distinct BOOL>>[{NULL}]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,ANALYTIC_FUNCTIONS,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_3_ARRAY_ORDERING]
[name=window_functions_in_let_with_horizontal_agg]
select *
FROM GRAPH_TABLE(aml
  match (a IS Account)-[t IS transfer]->{2}(tgt)
  # For each account, sort all outgoing 2-hop transfers by their horizontal
  # average amounts then apply the windowing.
  LET h_avg = avg(t.amount),
      w = ARRAY_AGG(tgt.account_id) OVER (PARTITION BY element_id(a)
                                          ORDER BY avg(t.amount)
                                          RANGE BETWEEN 1 PRECEDING AND CURRENT ROW)
  RETURN a.account_id AS src, h_avg, w
) gt
ORDER BY 1, 2, 3
--
ARRAY<STRUCT<src INT64, h_avg DOUBLE, w ARRAY<>>>[unknown order:
  {1010, 200, ARRAY<INT64>[1030]},
  {
    1010,
    250,
    ARRAY<INT64>[unknown order:1030, 1030]
  },
  {
    1010,
    250,
    ARRAY<INT64>[unknown order:1030, 1030]
  },
  {1010, 300, ARRAY<INT64>[1030]},
  {1010, 350, ARRAY<INT64>[1020]},
  {1010, 400, ARRAY<INT64>[1020]},
  {1010, 600, ARRAY<INT64>[1010]},
  {1020, 400, ARRAY<INT64>[1010]},
  {1020, 450, ARRAY<INT64>[1010]},
  {1030, 300, ARRAY<INT64>[1020]},
  {1030, 350, ARRAY<INT64>[1020]},
  {1030, 550, ARRAY<INT64>[1010]}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,ANALYTIC_FUNCTIONS]
[name=window_functions_in_filter_with_horizontal_agg]
select *
FROM GRAPH_TABLE(aml
  match (a IS Account)-[t IS transfer]->{2}(tgt)
  FILTER AVG(MIN(t.amount)) OVER (PARTITION BY element_id(a)
                                  ORDER BY avg(t.amount)
                                  RANGE BETWEEN 1 PRECEDING AND CURRENT ROW) < 150
  RETURN a.account_id AS src, tgt.account_id AS tgt
) gt
ORDER BY 1, 2
--
ARRAY<STRUCT<src INT64, tgt INT64>>[known order:
  {1010, 1020},
  {1010, 1030},
  {1030, 1020}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,ANALYTIC_FUNCTIONS]
[name=window_functions_in_return_with_vertical_agg]
select *
FROM GRAPH_TABLE(aml
  match (a IS Account)-[t IS transfer]->(tgt)
  RETURN a.account_id AS src,
         tgt.account_id AS tgt,
         min(t.amount) AS min_amount,
         ARRAY_AGG(tgt.account_id) OVER (ORDER BY MIN(t.amount)
                                         RANGE BETWEEN 1 PRECEDING AND CURRENT ROW) AS w
    GROUP BY src, tgt
) gt
ORDER BY 1, 2, 3
--
ARRAY<STRUCT<src INT64, tgt INT64, min_amount INT64, w ARRAY<>>>[known order:
  {1010, 1010, 600, ARRAY<INT64>[1010]},
  {1010, 1020, 100, ARRAY<INT64>[1020]},
  {1020, 1030, 300, ARRAY<INT64>[1030]},
  {1030, 1010, 500, ARRAY<INT64>[1010]}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,ANALYTIC_FUNCTIONS,V_1_4_SQL_GRAPH_RETURN_EXTENSIONS]
[name=window_functions_in_WITH_with_vertical_agg]
select *
FROM GRAPH_TABLE(aml
  match (a IS Account)-[t IS transfer]->(tgt)
  WITH a.account_id AS src,
         tgt.account_id AS tgt,
         min(t.amount) AS min_amount,
         ARRAY_AGG(tgt.account_id) OVER (ORDER BY MIN(t.amount)
                                         RANGE BETWEEN 1 PRECEDING AND CURRENT ROW) AS w
    GROUP BY src, tgt
  RETURN *
) gt
ORDER BY 1, 2, 3
--
ARRAY<STRUCT<src INT64, tgt INT64, min_amount INT64, w ARRAY<>>>[known order:
  {1010, 1010, 600, ARRAY<INT64>[1010]},
  {1010, 1020, 100, ARRAY<INT64>[1020]},
  {1020, 1030, 300, ARRAY<INT64>[1030]},
  {1030, 1010, 500, ARRAY<INT64>[1010]}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,ANALYTIC_FUNCTIONS]
[name=window_functions_partition_by_graph_element]
select *
FROM GRAPH_TABLE(aml
  match (a IS Account)-[t IS transfer]->{2}(tgt)
  FILTER AVG(MIN(t.amount)) OVER (PARTITION BY a
                                  ORDER BY avg(t.amount)
                                  RANGE BETWEEN 1 PRECEDING AND CURRENT ROW) < 150
  RETURN a.account_id AS src, tgt.account_id AS tgt
) gt
ORDER BY 1, 2
--
ARRAY<STRUCT<src INT64, tgt INT64>>[known order:
  {1010, 1020},
  {1010, 1030},
  {1030, 1020}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,V_1_4_SQL_GRAPH_PATH_TYPE,V_1_4_SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,V_1_4_GROUP_BY_GRAPH_PATH,ANALYTIC_FUNCTIONS]
[name=window_functions_partition_by_graph_path]
select *
FROM GRAPH_TABLE(aml
  match p=(a IS Account)-[t IS transfer]->{2}(tgt)
  FILTER AVG(MIN(t.amount)) OVER (PARTITION BY p
                                  ORDER BY avg(t.amount)
                                  RANGE BETWEEN 1 PRECEDING AND CURRENT ROW) < 150
  RETURN a.account_id AS src, tgt.account_id AS tgt
) gt
ORDER BY 1, 2
--
ARRAY<STRUCT<src INT64, tgt INT64>>[known order:
  {1010, 1020},
  {1010, 1030},
  {1010, 1030},
  {1030, 1020}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,TABLESAMPLE]
[name=graph_sample_bernoulli_none]
select *
FROM GRAPH_TABLE(aml
  match ALL (a IS Account)-[t IS transfer]->(tgt)
  tablesample bernoulli(0 percent) WITH weight repeatable(123)
  RETURN a.account_id AS src, t.amount, tgt.account_id AS tgt, weight
) gt
ORDER BY 1, 2, 3
--
ARRAY<STRUCT<src INT64, amount INT64, tgt INT64, weight DOUBLE>>[]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,TABLESAMPLE]
[name=graph_sample_bernoulli_all]
select *
FROM GRAPH_TABLE(aml
  match ALL (a IS Account)-[t IS transfer]->(tgt)
  tablesample bernoulli(100 percent) WITH weight repeatable(123)
  RETURN a.account_id AS src, t.amount, tgt.account_id AS tgt, weight
) gt
ORDER BY 1, 2, 3
--
ARRAY<STRUCT<src INT64, amount INT64, tgt INT64, weight DOUBLE>>[known order:
  {1010, 100, 1020, 1},
  {1010, 200, 1020, 1},
  {1010, 600, 1010, 1},
  {1020, 300, 1030, 1},
  {1020, 400, 1030, 1},
  {1030, 500, 1010, 1}
]
==

[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,TABLESAMPLE]
[name=graph_sample_bernoulli_invalid_percentage]
[parameters=123 as p]
select *
FROM GRAPH_TABLE(aml
  match ALL (a IS Account)-[t IS transfer]->(tgt)
  tablesample bernoulli(@p percent) WITH weight repeatable(123)
  RETURN a.account_id AS src, t.amount, tgt.account_id AS tgt, weight
) gt
ORDER BY 1, 2, 3
--
ERROR: generic::out_of_range: PERCENT value must be in the range [0, 100]
==

# Stratified sampling
[required_features=V_1_4_SQL_GRAPH,V_1_4_SQL_GRAPH_ADVANCED_QUERY,TABLESAMPLE,STRATIFIED_RESERVOIR_TABLESAMPLE]
[name=graph_sample_stratified_sampling]
select *
FROM GRAPH_TABLE(aml
  match ALL (a IS Account)-[t IS transfer]->(tgt)
  tablesample reservoir(1 ROWS PARTITION BY element_id(a), t.amount, element_id(tgt)) WITH weight repeatable(123)
  RETURN a.account_id AS src, t.amount, tgt.account_id AS tgt, weight
) gt
ORDER BY 1, 2, 3
--
ARRAY<STRUCT<src INT64, amount INT64, tgt INT64, weight DOUBLE>>[known order:
  {1010, 100, 1020, 1},
  {1010, 200, 1020, 1},
  {1010, 600, 1010, 1},
  {1020, 300, 1030, 1},
  {1020, 400, 1030, 1},
  {1030, 500, 1010, 1}
]
