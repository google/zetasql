[prepare_database]
CREATE TABLE TestTableWithUid OPTIONS (userid_column=uid) AS
SELECT cast(1 as int64) as uid,
       cast(null as int64) as int64_val,
       cast(null as double) as double_val UNION ALL
  SELECT 2,  2,    1.5  UNION ALL
  SELECT 3,  1,    1.5  UNION ALL
  SELECT 4,  null, 2.5  UNION ALL
  SELECT 5,  1,    3.5  UNION ALL
  SELECT 6,  2,    null UNION ALL
  SELECT 7,  1,    -0.5 UNION ALL
  SELECT 8,  4,    -1.5 UNION ALL
  SELECT 9,  2,    1.5  UNION ALL
  SELECT 10, 3,    2.5
--
ARRAY<STRUCT<uid INT64, int64_val INT64, double_val DOUBLE>>[
  {1, NULL, NULL},
  {2, 2, 1.5},
  {3, 1, 1.5},
  {4, NULL, 2.5},
  {5, 1, 3.5},
  {6, 2, NULL},
  {7, 1, -0.5},
  {8, 4, -1.5},
  {9, 2, 1.5},
  {10, 3, 2.5}
]
==

[prepare_database]
CREATE TABLE TestTableWithUid2 OPTIONS (userid_column=uid) AS
SELECT cast(1 as int64) as id, cast(1 as int64) as uid,
       cast(null as int64) as int64_val,
       cast(null as double) as double_val UNION ALL
  SELECT 2,   2,  2,    1.5   UNION ALL
  SELECT 3,   3,  1,    1.5   UNION ALL
  SELECT 4,   1,  null, 2.5   UNION ALL
  SELECT 5,   2,  1,    3.5   UNION ALL
  SELECT 6,   2,  2,    null  UNION ALL
  SELECT 7,   1,  1,    -0.5  UNION ALL
  SELECT 8,   2,  4,    -1.5  UNION ALL
  SELECT 9,   3,  2,    1.5   UNION ALL
  SELECT 10,  2,  3,    2.5
--
ARRAY<STRUCT<id INT64, uid INT64, int64_val INT64, double_val DOUBLE>>[
  {1, 1, NULL, NULL},
  {2, 2, 2, 1.5},
  {3, 3, 1, 1.5},
  {4, 1, NULL, 2.5},
  {5, 2, 1, 3.5},
  {6, 2, 2, NULL},
  {7, 1, 1, -0.5},
  {8, 2, 4, -1.5},
  {9, 3, 2, 1.5},
  {10, 2, 3, 2.5}
]
==

[prepare_database]
CREATE TABLE TestTableWithUid3 OPTIONS (userid_column=uid) AS
SELECT cast(1 as int64) as id, cast(1 as int64) as uid,
       cast(null as int64) as int64_val,
       cast(null as double) as double_val UNION ALL
  SELECT 2,   2,  2,    1.5   UNION ALL
  SELECT 3,   1,  1,    1.5   UNION ALL
  SELECT 4,   1,  null, 2.5   UNION ALL
  SELECT 5,   1,  1,    3.5   UNION ALL
  SELECT 6,   2,  2,    null  UNION ALL
  SELECT 7,   1,  1,    -0.5  UNION ALL
  SELECT 8,   1,  4,    -1.5  UNION ALL
  SELECT 9,   3,  2,    1.5   UNION ALL
  SELECT 10,  1,  3,    2.5
--
ARRAY<STRUCT<id INT64, uid INT64, int64_val INT64, double_val DOUBLE>>[
  {1, 1, NULL, NULL},
  {2, 2, 2, 1.5},
  {3, 1, 1, 1.5},
  {4, 1, NULL, 2.5},
  {5, 1, 1, 3.5},
  {6, 2, 2, NULL},
  {7, 1, 1, -0.5},
  {8, 1, 4, -1.5},
  {9, 3, 2, 1.5},
  {10, 1, 3, 2.5}
]
==

[prepare_database]
CREATE TABLE TestTableWithUid4 OPTIONS (userid_column=uid) AS
SELECT cast(1 as int64) as id, cast(1 as int64) as uid,
       cast(null as int64) as int64_val,
       cast(null as double) as double_val UNION ALL
  SELECT 2,   2,  null,    null   UNION ALL
  SELECT 3,   1,  null,    null   UNION ALL
  SELECT 4,   1,  null,    null   UNION ALL
  SELECT 5,   1,  null,    null   UNION ALL
  SELECT 6,   2,  null,    null   UNION ALL
  SELECT 7,   1,  null,    null
--
ARRAY<STRUCT<id INT64, uid INT64, int64_val INT64, double_val DOUBLE>>[
  {1, 1, NULL, NULL},
  {2, 2, NULL, NULL},
  {3, 1, NULL, NULL},
  {4, 1, NULL, NULL},
  {5, 1, NULL, NULL},
  {6, 2, NULL, NULL},
  {7, 1, NULL, NULL}
]
==

[prepare_database]
CREATE TABLE TestTableWithoutUid  AS
SELECT cast(0 as int64) as int64_val,
       cast(0.0 as double) as double_val UNION ALL
  SELECT 1, 1.1 UNION ALL
  SELECT 3, 3.1 UNION ALL
  SELECT 4, 4.1 UNION ALL
  SELECT 1234, 12.34
--
ARRAY<STRUCT<int64_val INT64, double_val DOUBLE>>[
  {0, 0},
  {1, 1.1},
  {3, 3.1},
  {4, 4.1},
  {1234, 12.34}
]
==

# epsilon = 1e20 implies that no noise is added in this case
#
# Since the delta is unspecified, the query produces an error (there
# is no engine default).

[default required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
[name=differential_privacy_basic_delta_not_set]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20)
  SUM(double_val, contribution_bounds_per_group => (0, 10))
FROM TestTableWithUid;
--
ERROR: generic::invalid_argument: Differential privacy option DELTA must be set
==

[default required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
[name=differential_privacy_basic_delta_too_large]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.01)
  SUM(double_val, contribution_bounds_per_group => (0, 10))
FROM TestTableWithUid;
--
ERROR: generic::invalid_argument: Delta must be in the inclusive interval [0,1], but is 1.01
==

[name=differential_privacy_sum_int64_explicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(int64_val, contribution_bounds_per_group => (2, 3))
FROM TestTableWithUid;
--
ARRAY<STRUCT<INT64>>[{18}]
==

[name=differential_privacy_sum_int64_explicit_bounds_multi_user]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1)
  SUM(int64_val, contribution_bounds_per_group => (2, 3))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<INT64>>[{8}]
==

[name=differential_privacy_sum_int64_explicit_bounds_multi_user_smaller_delta]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=0.7)
  SUM(int64_val, contribution_bounds_per_group => (2, 3))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<INT64>>[{8}]
==

[name=differential_privacy_avg_int64_explicit_bounds_multi_user]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1)
  AVG(int64_val, contribution_bounds_per_group => (2, 3))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{2.1333333333333333}]
==

[name=differential_privacy_avg_int64_explicit_bounds_multi_user_smaller_delta]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=0.7)
  AVG(int64_val, contribution_bounds_per_group => (2, 3))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{2.1333333333333333}]
==

# epsilon must be specified
[name=differential_privacy_basic_epsilon_not_set]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS()
  PERCENTILE_CONT(double_val, 0.4)
FROM TestTableWithUid2;
--
ERROR: generic::invalid_argument: Differential privacy option EPSILON must be set and non-NULL
==

[name=differential_privacy_basic_sum_double_implicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(double_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{11}]
==

[name=differential_privacy_basic_sum_double_implicit_bounds_multi_user]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(double_val)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{11}]
==

[name=differential_privacy_basic_avg_double_implicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(double_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{1.375}]
==

[name=differential_privacy_basic_avg_double_implicit_bounds_multi_user]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(double_val)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{1.3333333333333333}]
==

[name=differential_privacy_basic_sum_int64_implicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(int64_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<INT64>>[{16}]
==

[name=differential_privacy_basic_sum_int64_implicit_bounds_multi_user]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(int64_val)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<INT64>>[{16}]
==

[name=differential_privacy_basic_avg_int64_implicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(int64_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{2}]
==

[name=differential_privacy_sum_double_explicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(double_val, contribution_bounds_per_group => (0, 10))
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{13}]
==

[name=differential_privacy_sum_double_explicit_bounds_multi_user]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(double_val, contribution_bounds_per_group => (0, 10))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{11}]
==

[name=differential_privacy_avg_double_explicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(double_val, contribution_bounds_per_group => (0, 10))
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{1.625}]
==

[name=differential_privacy_avg_double_explicit_bounds_multi_user]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(double_val, contribution_bounds_per_group => (0, 10))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{1.3333333333333335}]
==

[name=differential_privacy_avg_int64_explicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(int64_val, contribution_bounds_per_group => (2, 3))
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{2.25}]
==

[name=differential_privacy_delta_eliminates_row]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=100, delta=1e-220)
  SUM(double_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[]
==

[name=differential_privacy_delta_eliminates_row_for_avg]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=100, delta=1e-220)
  AVG(double_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[]
==

[name=differential_privacy_explicit_bounds_sum_and_count]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(int64_val, contribution_bounds_per_group => (2, 3)),
  COUNT(double_val, contribution_bounds_per_group => (0, 10))
FROM TestTableWithUid;
--
ARRAY<STRUCT<INT64, INT64>>[{18, 8}]
==

[name=differential_privacy_explicit_bounds_avg_and_count]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(int64_val, contribution_bounds_per_group => (2, 3)),
  COUNT(double_val, contribution_bounds_per_group => (0, 10))
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE, INT64>>[{2.25, 8}]
==

# Total aggregation, without max_groups_contributed.
[name=differential_privacy_max_groups_contributed_scalar_aggregation]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  COUNT(*)
FROM TestTableWithUid
  CROSS JOIN
     UNNEST([1,2,3]) as x;
--
ARRAY<STRUCT<INT64>>[{30}]
==

# Same as the previous, but with max_groups_contributed = 1.  Since max_groups_contributed is 1, and there
# is only 1 group, no user contributions are discarded and the final result
# is the same as the previous query without max_groups_contributed.
[name=differential_privacy_max_groups_contributed_scalar_aggregation_explicit]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, max_groups_contributed=1)
  COUNT(*)
FROM TestTableWithUid
  CROSS JOIN
     UNNEST([1,2,3]) as x;
--
ARRAY<STRUCT<INT64>>[{30}]

NOTE: Reference implementation reports non-determinism.
==

# In this query, each user contributes to 3 groups.  Max_groups_contributed is 3, so none
# of the contributions are filtered.
[name=differential_privacy_max_groups_contributed_group_by_3]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, max_groups_contributed=3)
  x, COUNT(*)
FROM TestTableWithUid
  CROSS JOIN
     UNNEST([1,2,3]) as x
GROUP BY x
ORDER BY x ASC;
--
ARRAY<STRUCT<x INT64, INT64>>[known order:{1, 10}, {2, 10}, {3, 10}]

NOTE: Reference implementation reports non-determinism.
==

# Similar to the previous query, each user has data for all of the 3 groups.
# Max_groups_contributed is 2, so each user can only contribute to 2 groups.  The groups that
# the user contributes to can vary from one execution of the query to the
# next, so to get a deterministic result we perform a total aggregation
# across all groups to verify that each user contributes to exactly 2
# groups.  So the expected final result is 20 (10 users, 2 groups each).
[name=differential_privacy_max_groups_contributed_group_by_2]
[labels=differential_privacy]
SELECT SUM(count_star)
FROM (
  SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, max_groups_contributed=2)
    x, COUNT(*) as count_star
  FROM TestTableWithUid
    CROSS JOIN
       UNNEST([1,2,3]) as x
  GROUP BY x);
--
ARRAY<STRUCT<INT64>>[{20}]

NOTE: Reference implementation reports non-determinism.
==

# Same as the previous query, but with max_groups_contributed = 1 so the expected result is 10.
[name=differential_privacy_max_groups_contributed_group_by_1]
[labels=differential_privacy]
SELECT SUM(count_star)
FROM (
  SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, max_groups_contributed=1)
    x, COUNT(*) as count_star
  FROM TestTableWithUid
    CROSS JOIN
       UNNEST([1,2,3]) as x
  GROUP BY x);
--
ARRAY<STRUCT<INT64>>[{10}]

NOTE: Reference implementation reports non-determinism.
==

# Sum aggregation with max_rows_contributed.
[name=differential_privacy_max_rows_contributed_sum]
[labels=differential_privacy]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_MAX_ROWS_CONTRIBUTED]

SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, max_rows_contributed=2)
  SUM(double_val)
FROM TestTableWithUid
  CROSS JOIN
    UNNEST([1,2,3]) AS x;
--
ARRAY<STRUCT<DOUBLE>>[{22}]

NOTE: Reference implementation reports non-determinism.
==

# The number of rows per user is less than 5 in TestTableWithUid2, so the result
# won't be random.
[name=differential_privacy_basic_var_pop_implicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
    VAR_POP(double_val), VAR_POP(int64_val),
  FROM TestTableWithUid2 UNION ALL
SELECT VAR_POP(double_val), VAR_POP(int64_val)
  FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[unknown order:{2.359375, 1}, {2.359375, 1}]
==

# Same as the previous query.
[name=differential_privacy_basic_var_pop_explicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
    VAR_POP(double_val, contribution_bounds_per_row => (2.0, 3.0)),
  FROM TestTableWithUid2 UNION ALL
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
    VAR_POP(int64_val, contribution_bounds_per_row => (2.0, 3.0)),
  FROM TestTableWithUid2 UNION ALL
SELECT VAR_POP(ClampedValue) FROM (SELECT
      CASE
        WHEN double_val < 2 THEN 2
        WHEN double_val > 3 THEN 3
        ELSE double_val
      END
    AS ClampedValue
  FROM TestTableWithUid2) UNION ALL
SELECT VAR_POP(ClampedValue) FROM (SELECT
      CASE
        WHEN int64_val < 2 THEN 2
        WHEN int64_val > 3 THEN 3
        ELSE int64_val
      END
    AS ClampedValue
  FROM TestTableWithUid2)
--
ARRAY<STRUCT<DOUBLE>>[unknown order:{0.125}, {0.1875}, {0.125}, {0.1875}]
==

# For All-NULLs value, when bounds are explicitly set, the VAR_POP returns
# population variance of lower bound and upper bound.
[name=differential_privacy_basic_var_pop_explicit_bounds_all_nulls]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
    VAR_POP(double_val, contribution_bounds_per_row => (10.0, 100.0)),
  FROM TestTableWithUid4 UNION ALL
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
    VAR_POP(int64_val, contribution_bounds_per_row => (10.0, 100.0)),
  FROM TestTableWithUid4
--
ARRAY<STRUCT<DOUBLE>>[unknown order:{2025}, {2025}]
==

# With less than 5 rows and verify that the anonymized variance is equal to the
# variance of all the rows.
[name=differential_privacy_verify_non_randomness_of_var_pop_implicit_bounds]
[labels=differential_privacy]
SELECT ABS(
(SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  VAR_POP(double_val) FROM TestTableWithUid2) -
(SELECT VAR_POP(double_val) FROM TestTableWithUid2)) < 0.000001;
--
ARRAY<STRUCT<BOOL>>[{true}]
==

# With exactly 6 rows and verify that the anonymized variance is NOT equal to
# the variance of all 6 rows.
[name=differential_privacy_verify_randomness_of_var_pop_implicit_bounds]
[labels=differential_privacy]
SELECT ABS(
(SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  VAR_POP(double_val) FROM TestTableWithUid3) -
(SELECT VAR_POP(double_val) FROM TestTableWithUid3)) < 0.000001;
--
ARRAY<STRUCT<BOOL>>[{false}]
==

# The number of rows per user is less than 5 in TestTableWithUid2, so the result
# won't be random.
[name=differential_privacy_basic_stddev_pop_implicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  STDDEV_POP(double_val), STDDEV_POP(int64_val)
FROM TestTableWithUid2 UNION ALL
SELECT STDDEV_POP(double_val), STDDEV_POP(int64_val)
  FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[unknown order:
  {1.5360257159305635, 1},
  {1.5360257159305635, 1}
]
==

# Same as the previous query, the result won't be random for explicit bounds as
# well.
[name=differential_privacy_basic_stddev_pop_explicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  STDDEV_POP(double_val, contribution_bounds_per_row => (2, 3))
FROM TestTableWithUid2  UNION ALL
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  STDDEV_POP(int64_val, contribution_bounds_per_row => (2, 3)),
FROM TestTableWithUid2  UNION ALL
SELECT STDDEV_POP(ClampedValue) FROM (SELECT
      CASE
        WHEN double_val < 2 THEN 2
        WHEN double_val > 3 THEN 3
        ELSE double_val
      END
    AS ClampedValue
  FROM TestTableWithUid2) UNION ALL
SELECT STDDEV_POP(ClampedValue) FROM (SELECT
      CASE
        WHEN int64_val < 2 THEN 2
        WHEN int64_val > 3 THEN 3
        ELSE int64_val
      END
    AS ClampedValue
  FROM TestTableWithUid2)
--
ARRAY<STRUCT<DOUBLE>>[unknown order:
  {0.35355339059327379},
  {0.4330127018922193},
  {0.35355339059327379},
  {0.4330127018922193}
]
==

# Same as the previous query, but input are all NULLs. For All-NULLs value,
# when bounds are explicitly set, the STDDEV_POP returns population
# standard deviation of lower bound and upper bound.
[name=differential_privacy_basic_stddev_pop_explicit_bounds_all_nulls]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  STDDEV_POP(double_val, contribution_bounds_per_row => (2, 3))
FROM TestTableWithUid4  UNION ALL
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  STDDEV_POP(int64_val, contribution_bounds_per_row => (2, 3)),
FROM TestTableWithUid4
--
ARRAY<STRUCT<DOUBLE>>[unknown order:{0.5}, {0.5}]
==

# PERCENTILE_CONT with implicit bounds. The number of rows per user is less
# than 5 in TestTableWithUid2, so the result won't be random.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=differential_privacy_basic_percentile_cont_implicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  ABS(PERCENTILE_CONT(double_val, 0.4) - 1.5) < 0.01,
  ABS(PERCENTILE_CONT(int64_val, 0.6) - 2) < 0.01
FROM TestTableWithUid2;
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==

# PERCENTILE_CONT with parameters
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=differential_privacy_basic_percentile_cont_implicit_bounds_with_params]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  ABS(PERCENTILE_CONT(double_val,
                           0.4 , contribution_bounds_per_row => (1, 3)) - 1.5) < 0.01,
  ABS(PERCENTILE_CONT(int64_val,
                           0.6 , contribution_bounds_per_row => (1, 3)) - 2) < 0.01
FROM TestTableWithUid2;
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==

# PERCENTILE_CONT with explicit bounds. The number of rows per user is less
# than 5 in TestTableWithUid2, so the result won't be random.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=differential_privacy_basic_percentile_cont_explicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  ABS(PERCENTILE_CONT(double_val,
                           0.4, contribution_bounds_per_row => (1, 3)) - 1.5) < 0.01,
  ABS(PERCENTILE_CONT(int64_val,
                           0.6, contribution_bounds_per_row => (1, 3)) - 2) < 0.01,
FROM TestTableWithUid2;
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==

# With less than 5 rows and verify that the anonymized percentile is equal to
# the percentile of all the rows. Without noise it'll behave more like
# PERCENTILE_DISC to find a value in the input set.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[required_features=ANALYTIC_FUNCTIONS,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
[name=differential_privacy_verify_non_randomness_of_percentile_cont_implicit_bounds]
[labels=differential_privacy]
(SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
   ABS(PERCENTILE_CONT(double_val, 0.1) + 1.5) < 0.01
 FROM TestTableWithUid2)
  UNION ALL
(SELECT ABS(PERCENTILE_CONT(double_val, 0.1) OVER() + 0.8) < 0.01
 FROM TestTableWithUid2 LIMIT 1)
  UNION ALL
(SELECT ABS(PERCENTILE_DISC(double_val, 0.1) OVER() + 1.5) < 0.01
 FROM TestTableWithUid2 LIMIT 1);
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}, {true}]

NOTE: Reference implementation reports non-determinism.
==

# Another case with a different percentile (0.7) with less than 5 rows and
# verify that the anonymized percentile is equal to the percentile of all the
# rows. Without noise it'll behave more like PERCENTILE_DISC to find a value in
# the input set.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[required_features=ANALYTIC_FUNCTIONS,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
[name=differential_privacy_verify_non_randomness_of_percentile_cont_implicit_bounds_2]
[labels=differential_privacy]
(SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
   ABS(PERCENTILE_CONT(double_val, 0.7) - 2.5) < 0.01
 FROM TestTableWithUid2)
  UNION ALL
(SELECT ABS(PERCENTILE_CONT(double_val, 0.7) OVER() - 2.4) < 0.01
 FROM TestTableWithUid2 LIMIT 1)
  UNION ALL
(SELECT ABS(PERCENTILE_DISC(double_val, 0.7) OVER() - 2.5) < 0.01
 FROM TestTableWithUid2 LIMIT 1);
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}, {true}]

NOTE: Reference implementation reports non-determinism.
==

# APPROX_QUANTILES with explicit bounds. The number of rows per user is less than
# 5 in TestTableWithUid2, so the result won't be random.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=differential_privacy_basic_approx_quantiles_explicit_bounds]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  ABS(APPROX_QUANTILES(double_val,
                     5, contribution_bounds_per_row => (1, 3))[OFFSET(2)] - 1.5) < 0.01,
  ABS(APPROX_QUANTILES(int64_val,
                     5, contribution_bounds_per_row => (1, 3))[OFFSET(3)] - 2) < 0.01,
FROM TestTableWithUid2;
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==

# APPROX_QUANTILES with explicit bounds, testing that the number of quantile
# boundaries returned is one greater than the number of quantiles requested.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=differential_privacy_basic_approx_quantiles_explicit_bounds_result_length]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  ARRAY_LENGTH(APPROX_QUANTILES(double_val,
                     5, contribution_bounds_per_row => (1, 3))),
  ARRAY_LENGTH(APPROX_QUANTILES(int64_val,
                     5, contribution_bounds_per_row => (1, 3))),
FROM TestTableWithUid2;
--
ARRAY<STRUCT<INT64, INT64>>[{6, 6}]
==

# With less than 5 rows per user and verify that the anonymized quantiles are
# equal to the quantiles of all the rows. Without noise, it'll behave more like
# APPROX_QUANTILES to find a value in the input set.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=differential_privacy_verify_non_randomness_of_approx_quantiles_explicit_bounds]
[labels=differential_privacy]
(SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
   ABS(APPROX_QUANTILES(double_val, 10, contribution_bounds_per_row => (-2, 10))[OFFSET(1)] + 1.5) < 0.01
 FROM TestTableWithUid2)
  UNION ALL
(SELECT ABS(APPROX_QUANTILES(double_val, 10)[OFFSET(1)] + 1.5) < 0.01
 FROM TestTableWithUid2 LIMIT 1);
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}]
==

# Another case with a different quantile (0.1) with less than 5 rows per user
# and verify that the anonymized percentile is equal to the percentile of all
# the rows. Without noise it'll behave more like APPROX_QUANTILES to find a
# value in the input set.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=differential_privacy_verify_non_randomness_of_approx_quantiles_explicit_bounds_2]
[labels=differential_privacy]
(SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
   ABS(APPROX_QUANTILES(double_val, 10, contribution_bounds_per_row => (-2, 10))[OFFSET(7)] - 2.5) < 0.01
 FROM TestTableWithUid2)
  UNION ALL
(SELECT ABS(APPROX_QUANTILES(double_val, 10)[OFFSET(7)] - 2.5) < 0.01
 FROM TestTableWithUid2 LIMIT 1);
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}]
==

[name=differential_privacy_sum_double_explicit_bounds_multi_user_with_report_proto]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(double_val, contribution_bounds_per_group => (0, 10), report_format => "PROTO")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>>>[
  {{
     value {
       float_value: 11
       noise_confidence_interval {
         lower_bound: -5.9914645471079794e-19
         upper_bound: 5.9914645471079794e-19
         confidence_level: 0.95
       }
     }
   }}
]
==

[name=differential_privacy_basic_sum_int64_implicit_bounds_multi_user_with_report_proto]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(int64_val, report_format => "PROTO")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>>>[
  {{
     value {
       int_value: 16
       noise_confidence_interval {
         lower_bound: -1.9172686550745535e-18
         upper_bound: 1.9172686550745535e-18
         confidence_level: 0.95
       }
     }
     bounding_report {
       lower_bound {
         int_value: -16
       }
       upper_bound {
         int_value: 16
       }
       num_inputs: 3
       num_outside: 0
     }
   }}
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" without setting up contribution_bounds_per_group.
[name=differential_privacy_basic_sum_int64_implicit_bounds_multi_user_with_report_proto_zero_rows]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(int64_val, report_format => "PROTO")
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::failed_precondition: Bin count threshold was too large to find approximate bounds. Either run over a larger dataset or decrease success_probability and try again.
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a contribution_bounds_per_group argument.
# Because the `float_value` is indeterministic, we only output `noise_confidence_interval`
[name=differential_privacy_sum_double_explicit_bounds_multi_user_with_report_proto_zero_rows]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(double_val, contribution_bounds_per_group => (0, 10), report_format => "PROTO").value.noise_confidence_interval
FROM TestTableWithUid2 WHERE id > 1000;
--
ARRAY<STRUCT<noise_confidence_interval PROTO<zetasql.NoiseConfidenceInterval>>>[
  {{
     lower_bound: -5.9914645471079794e-19
     upper_bound: 5.9914645471079794e-19
     confidence_level: 0.95
   }}
]
==

[name=differential_privacy_avg_double_explicit_bounds_multi_user_with_report_proto]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(double_val, contribution_bounds_per_group => (0, 10), report_format => "PROTO")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>>>[
  {{
     value {
       float_value: 1.3333333333333335
       noise_confidence_interval {
         lower_bound: 1.3333333333333335
         upper_bound: 1.3333333333333335
         confidence_level: 0.95
       }
     }
   }}
]
==

[name=differential_privacy_avg_int64_implicit_bounds_multi_user_with_report_proto]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(int64_val, report_format => "PROTO")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>>>[
  {{
     value {
       float_value: 1.6333333333333333
       noise_confidence_interval {
         lower_bound: 1.6333333333333333
         upper_bound: 1.6333333333333333
         confidence_level: 0.95
       }
     }
     bounding_report {
       lower_bound {
         float_value: 0.5
       }
       upper_bound {
         float_value: 4
       }
       num_inputs: 3
       num_outside: 0
     }
   }}
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" without setting up contribution_bounds_per_group.
[name=differential_privacy_avg_int64_implicit_bounds_multi_user_with_report_proto_zero_rows]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(int64_val, report_format => "PROTO")
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::failed_precondition: Bin count threshold was too large to find approximate bounds. Either run over a larger dataset or decrease success_probability and try again.
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a contribution_bounds_per_group argument.
# Because the `float_value` is indeterministic, we only output `noise_confidence_interval`
[name=differential_privacy_avg_double_explicit_bounds_multi_user_with_report_proto_zero_rows]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(double_val, contribution_bounds_per_group => (0, 10), report_format => "PROTO").value.noise_confidence_interval
FROM TestTableWithUid2 WHERE id > 1000;
--
ARRAY<STRUCT<noise_confidence_interval PROTO<zetasql.NoiseConfidenceInterval>>>[
  {{
     lower_bound: 5
     upper_bound: 5
     confidence_level: 0.95
   }}
]
==

[name=differential_privacy_count_double_explicit_bounds_multi_user_with_report_proto]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  COUNT(double_val, contribution_bounds_per_group => (0, 10), report_format => "PROTO")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>>>[
  {{
     value {
       int_value: 8
       noise_confidence_interval {
         lower_bound: -5.9914645471079794e-19
         upper_bound: 5.9914645471079794e-19
         confidence_level: 0.95
       }
     }
   }}
]
==

[name=differential_privacy_basic_count_int64_implicit_bounds_multi_user_with_report_proto]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  COUNT(int64_val, report_format => "PROTO")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>>>[
  {{
     value {
       int_value: 8
       noise_confidence_interval {
         lower_bound: -9.5863432753727674e-19
         upper_bound: 9.5863432753727674e-19
         confidence_level: 0.95
       }
     }
     bounding_report {
       lower_bound {
         int_value: -8
       }
       upper_bound {
         int_value: 8
       }
       num_inputs: 3
       num_outside: 0
     }
   }}
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" without a CLAMPED clause.
[name=differential_privacy_basic_count_int64_implicit_bounds_multi_user_with_report_proto_zero_rows]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  COUNT(int64_val, report_format => "PROTO")
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::failed_precondition: Bin count threshold was too large to find approximate bounds. Either run over a larger dataset or decrease success_probability and try again.
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a contribution_bounds_per_group argument.
# Because the `float_value` is indeterministic, we only output `noise_confidence_interval`
[name=differential_privacy_count_double_explicit_bounds_multi_user_with_report_proto_zero_rows]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  COUNT(double_val, contribution_bounds_per_group => (0, 10), report_format => "PROTO").value.noise_confidence_interval
FROM TestTableWithUid2 WHERE id > 1000;
--
ARRAY<STRUCT<noise_confidence_interval PROTO<zetasql.NoiseConfidenceInterval>>>[
  {{
     lower_bound: -5.9914645471079794e-19
     upper_bound: 5.9914645471079794e-19
     confidence_level: 0.95
   }}
]
==

[name=differential_privacy_count_star_explicit_bounds_multi_user_with_report_proto]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  COUNT(*, contribution_bounds_per_group => (0, 10), report_format => "PROTO")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>>>[
  {{
     value {
       int_value: 10
       noise_confidence_interval {
         lower_bound: -5.9914645471079794e-19
         upper_bound: 5.9914645471079794e-19
         confidence_level: 0.95
       }
     }
   }}
]
==

[required_features=JSON_TYPE,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[name=differential_privacy_sum_double_explicit_bounds_multi_user_with_report_json]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(double_val, contribution_bounds_per_group => (0, 10), report_format => "JSON")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-5.991464547107979e-19,"upper_bound":5.991464547107979e-19},"value":11.0}}
  }
]
==

[required_features=JSON_TYPE,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[name=differential_privacy_basic_sum_int64_implicit_bounds_multi_user_with_report_json]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(int64_val, report_format => "JSON")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"bounding_report":{"lower_bound":-16,"num_inputs":3.0,"num_outside":0.0,"upper_bound":16},"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-1.9172686550745535e-18,"upper_bound":1.9172686550745535e-18},"value":16}}
  }
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" without setting up contribution_bounds_per_group.
[name=differential_privacy_basic_sum_int64_implicit_bounds_multi_user_with_report_json_zero_rows]
[required_features=JSON_TYPE,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(int64_val, report_format => "JSON")
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::failed_precondition: Bin count threshold was too large to find approximate bounds. Either run over a larger dataset or decrease success_probability and try again.
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a contribution_bounds_per_group argument.
# Because the `float_value` is indeterministic, we only output `noise_confidence_interval`
[required_features=JSON_TYPE,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[name=differential_privacy_sum_double_explicit_bounds_multi_user_with_report_json_zero_rows]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  SUM(double_val, contribution_bounds_per_group => (0, 10), report_format => "JSON").result.noise_confidence_interval
FROM TestTableWithUid2 WHERE id > 1000;
--
ARRAY<STRUCT<noise_confidence_interval JSON>>[
  {
    {"confidence_level":0.95,"lower_bound":-5.991464547107979e-19,"upper_bound":5.991464547107979e-19}
  }
]
==

[required_features=JSON_TYPE,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[name=differential_privacy_avg_double_explicit_bounds_multi_user_with_report_json]
[labels=differential_privacy_unit_column]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(double_val, contribution_bounds_per_group => (0, 10), report_format => "JSON")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":1.3333333333333335,"upper_bound":1.3333333333333335},"value":1.3333333333333335}}
  }
]
==

[required_features=JSON_TYPE,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[name=differential_privacy_avg_int64_implicit_bounds_multi_user_with_report_json]
[labels=differential_privacy_unit_column]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(int64_val, report_format => "JSON")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"bounding_report":{"lower_bound":0.5,"num_inputs":3.0,"num_outside":0.0,"upper_bound":4.0},"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":1.6333333333333333,"upper_bound":1.6333333333333333},"value":1.6333333333333333}}
  }
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" without setting up contribution_bounds_per_group.
[name=differential_privacy_avg_int64_implicit_bounds_multi_user_with_report_json_zero_rows]
[required_features=JSON_TYPE,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy_unit_column]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(int64_val, report_format => "JSON")
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::failed_precondition: Bin count threshold was too large to find approximate bounds. Either run over a larger dataset or decrease success_probability and try again.
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a contribution_bounds_per_group argument.
# Because the `float_value` is indeterministic, we only output `noise_confidence_interval`
[required_features=JSON_TYPE,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[name=differential_privacy_avg_double_explicit_bounds_multi_user_with_report_json_zero_rows]
[labels=differential_privacy_unit_column]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  AVG(double_val, contribution_bounds_per_group => (0, 10), report_format => "JSON").result.noise_confidence_interval
FROM TestTableWithUid2 WHERE id > 1000;
--
ARRAY<STRUCT<noise_confidence_interval JSON>>[
  {{"confidence_level":0.95,"lower_bound":5.0,"upper_bound":5.0}}
]
==

[required_features=JSON_TYPE,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[name=differential_privacy_count_double_explicit_bounds_multi_user_with_report_json]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  COUNT(double_val, contribution_bounds_per_group => (0, 10), report_format => "JSON")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-5.991464547107979e-19,"upper_bound":5.991464547107979e-19},"value":8}}
  }
]
==

[required_features=JSON_TYPE,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[name=differential_privacy_basic_count_int64_implicit_bounds_multi_user_with_report_json]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  COUNT(int64_val, report_format => "JSON")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"bounding_report":{"lower_bound":-8,"num_inputs":3.0,"num_outside":0.0,"upper_bound":8},"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-9.586343275372767e-19,"upper_bound":9.586343275372767e-19},"value":8}}
  }
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" without seting up contribution_bounds_per_group .
[required_features=JSON_TYPE,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[name=differential_privacy_basic_count_int64_implicit_bounds_multi_user_with_report_json_zero_rows]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  COUNT(int64_val, report_format => "JSON")
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::failed_precondition: Bin count threshold was too large to find approximate bounds. Either run over a larger dataset or decrease success_probability and try again.
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a contribution_bounds_per_group argument.
# Because the `float_value` is indeterministic, we only output `noise_confidence_interval`
[required_features=JSON_TYPE,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[name=differential_privacy_count_double_explicit_bounds_multi_user_with_report_json_zero_rows]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  COUNT(double_val, contribution_bounds_per_group => (0, 10), report_format => "JSON").result.noise_confidence_interval
FROM TestTableWithUid2 WHERE id > 1000;
--
ARRAY<STRUCT<noise_confidence_interval JSON>>[
  {
    {"confidence_level":0.95,"lower_bound":-5.991464547107979e-19,"upper_bound":5.991464547107979e-19}
  }
]
==

[required_features=JSON_TYPE,DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[name=differential_privacy_count_star_explicit_bounds_multi_user_with_report_json]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  COUNT(*, contribution_bounds_per_group => (0, 10), report_format => "JSON")
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-5.991464547107979e-19,"upper_bound":5.991464547107979e-19},"value":10}}
  }
]
==

# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=differential_privacy_approx_quantiles_double_explicit_bounds_multi_user_with_report_proto]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT
  ABS(dp_result[OFFSET(0)].float_value - 1) < 0.01,
  ABS(dp_result[OFFSET(0)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(dp_result[OFFSET(0)].noise_confidence_interval.upper_bound - 1) < 0.01,
  dp_result[OFFSET(0)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(1)].float_value - 1) < 0.01,
  ABS(dp_result[OFFSET(1)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(dp_result[OFFSET(1)].noise_confidence_interval.upper_bound - 1) < 0.01,
  dp_result[OFFSET(1)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(2)].float_value - 1.5) < 0.01,
  ABS(dp_result[OFFSET(2)].noise_confidence_interval.lower_bound - 1.5) < 0.01,
  ABS(dp_result[OFFSET(2)].noise_confidence_interval.upper_bound - 1.5) < 0.01,
  dp_result[OFFSET(2)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(3)].float_value - 1.5) < 0.01,
  ABS(dp_result[OFFSET(3)].noise_confidence_interval.lower_bound - 1.5) < 0.01,
  ABS(dp_result[OFFSET(3)].noise_confidence_interval.upper_bound - 1.5) < 0.01,
  dp_result[OFFSET(3)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(4)].float_value - 2.5) < 0.01,
  ABS(dp_result[OFFSET(4)].noise_confidence_interval.lower_bound - 2.5) < 0.01,
  ABS(dp_result[OFFSET(4)].noise_confidence_interval.upper_bound - 2.5) < 0.01,
  dp_result[OFFSET(4)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(5)].float_value - 2.5) < 0.01,
  ABS(dp_result[OFFSET(5)].noise_confidence_interval.lower_bound - 2.5) < 0.01,
  ABS(dp_result[OFFSET(5)].noise_confidence_interval.upper_bound - 2.5) < 0.01,
  dp_result[OFFSET(5)].noise_confidence_interval.confidence_level = 0.95,
FROM (
  SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
    APPROX_QUANTILES(double_val,
                       5, contribution_bounds_per_row => (1, 3), report_format => "PROTO").values.values AS dp_result
  FROM TestTableWithUid2
);
--
ARRAY<STRUCT<BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL>>
[{true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true}]
==

[name=differential_privacy_approx_quantiles_int64_explicit_bounds_multi_user_with_report_proto]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT
  ABS(dp_result[OFFSET(0)].float_value - 1) < 0.01,
  ABS(dp_result[OFFSET(0)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(dp_result[OFFSET(0)].noise_confidence_interval.upper_bound - 1) < 0.01,
  dp_result[OFFSET(0)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(1)].float_value - 1) < 0.01,
  ABS(dp_result[OFFSET(1)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(dp_result[OFFSET(1)].noise_confidence_interval.upper_bound - 1) < 0.01,
  dp_result[OFFSET(1)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(2)].float_value - 1) < 0.01,
  ABS(dp_result[OFFSET(2)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(dp_result[OFFSET(2)].noise_confidence_interval.upper_bound - 1) < 0.01,
  dp_result[OFFSET(2)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(3)].float_value - 2) < 0.01,
  ABS(dp_result[OFFSET(3)].noise_confidence_interval.lower_bound - 2) < 0.01,
  ABS(dp_result[OFFSET(3)].noise_confidence_interval.upper_bound - 2) < 0.01,
  dp_result[OFFSET(3)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(4)].float_value - 2) < 0.01,
  ABS(dp_result[OFFSET(4)].noise_confidence_interval.lower_bound - 2) < 0.01,
  ABS(dp_result[OFFSET(4)].noise_confidence_interval.upper_bound - 2) < 0.01,
  dp_result[OFFSET(4)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(5)].float_value - 3) < 0.01,
  ABS(dp_result[OFFSET(5)].noise_confidence_interval.lower_bound - 3) < 0.01,
  ABS(dp_result[OFFSET(5)].noise_confidence_interval.upper_bound - 3) < 0.01,
  dp_result[OFFSET(5)].noise_confidence_interval.confidence_level = 0.95,
FROM (
  SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
    APPROX_QUANTILES(int64_val,
                       5, contribution_bounds_per_row => (1, 3), report_format => "PROTO").values.values AS dp_result
  FROM TestTableWithUid2
);
--
ARRAY<STRUCT<BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL>>
[{true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true}]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the output of a DP algorithm on an empty data set is indeterministic,
# we only test that the `noise_confidence_interval` value.
[name=differential_privacy_approx_quantiles_double_explicit_bounds_multi_user_with_report_proto_zero_rows]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT
  ABS(dp_result[OFFSET(0)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(dp_result[OFFSET(0)].noise_confidence_interval.upper_bound - 10) < 0.01,
  dp_result[OFFSET(0)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(1)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(dp_result[OFFSET(1)].noise_confidence_interval.upper_bound - 10) < 0.01,
  dp_result[OFFSET(1)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(2)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(dp_result[OFFSET(2)].noise_confidence_interval.upper_bound - 10) < 0.01,
  dp_result[OFFSET(2)].noise_confidence_interval.confidence_level = 0.95,
FROM (
  SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
    APPROX_QUANTILES(double_val,
                   3, contribution_bounds_per_row => (1, 10), report_format => "PROTO").values.values AS dp_result
  FROM TestTableWithUid2 WHERE id > 1000
);
--
ARRAY<STRUCT<BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL>>[
  {true, true, true, true, true, true, true, true, true}
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the output of a DP algorithm on an empty data set is indeterministic,
# we only test that the `noise_confidence_interval` value.
[name=differential_privacy_approx_quantiles_int64_explicit_bounds_multi_user_with_report_proto_zero_rows]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS]
[labels=differential_privacy]
SELECT
  ABS(dp_result[OFFSET(0)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(dp_result[OFFSET(0)].noise_confidence_interval.upper_bound - 10) < 0.01,
  dp_result[OFFSET(0)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(1)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(dp_result[OFFSET(1)].noise_confidence_interval.upper_bound - 10) < 0.01,
  dp_result[OFFSET(1)].noise_confidence_interval.confidence_level = 0.95,
  ABS(dp_result[OFFSET(2)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(dp_result[OFFSET(2)].noise_confidence_interval.upper_bound - 10) < 0.01,
  dp_result[OFFSET(2)].noise_confidence_interval.confidence_level = 0.95,
FROM (
  SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
    APPROX_QUANTILES(int64_val,
                   3, contribution_bounds_per_row => (1, 10), report_format => "PROTO").values.values AS dp_result
  FROM TestTableWithUid2 WHERE id > 1000
);
--
ARRAY<STRUCT<BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL>>[
  {true, true, true, true, true, true, true, true, true}
]
==

# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,JSON_ARRAY_FUNCTIONS,JSON_TYPE,JSON_VALUE_EXTRACTION_FUNCTIONS]
[name=differential_privacy_approx_quantiles_double_explicit_bounds_multi_user_with_report_json]
[labels=differential_privacy]
SELECT
  ABS(DOUBLE(dp_result[OFFSET(0)].value) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(0)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(0)].noise_confidence_interval.upper_bound) - 1) < 0.01,
  DOUBLE(dp_result[OFFSET(0)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(1)].value) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(1)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(1)].noise_confidence_interval.upper_bound) - 1) < 0.01,
  DOUBLE(dp_result[OFFSET(1)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(2)].value) - 1.5) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(2)].noise_confidence_interval.lower_bound) - 1.5) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(2)].noise_confidence_interval.upper_bound) - 1.5) < 0.01,
  DOUBLE(dp_result[OFFSET(2)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(3)].value) - 1.5) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(3)].noise_confidence_interval.lower_bound) - 1.5) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(3)].noise_confidence_interval.upper_bound) - 1.5) < 0.01,
  DOUBLE(dp_result[OFFSET(3)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(4)].value) - 2.5) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(4)].noise_confidence_interval.lower_bound) - 2.5) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(4)].noise_confidence_interval.upper_bound) - 2.5) < 0.01,
  DOUBLE(dp_result[OFFSET(4)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(5)].value) - 2.5) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(5)].noise_confidence_interval.lower_bound) - 2.5) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(5)].noise_confidence_interval.upper_bound) - 2.5) < 0.01,
  DOUBLE(dp_result[OFFSET(5)].noise_confidence_interval.confidence_level) = 0.95,
FROM (
  SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
    JSON_QUERY_ARRAY(APPROX_QUANTILES(double_val,
                     5, contribution_bounds_per_row => (1, 3), report_format => "JSON").result) AS dp_result
  FROM TestTableWithUid2
);
--
ARRAY<STRUCT<BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL>>
[{true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true}]
==

[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,JSON_ARRAY_FUNCTIONS,JSON_TYPE,JSON_VALUE_EXTRACTION_FUNCTIONS]
[name=differential_privacy_approx_quantiles_int64_explicit_bounds_multi_user_with_report_json]
[labels=differential_privacy]
SELECT
  ABS(DOUBLE(dp_result[OFFSET(0)].value) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(0)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(0)].noise_confidence_interval.upper_bound) - 1) < 0.01,
  DOUBLE(dp_result[OFFSET(0)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(1)].value) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(1)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(1)].noise_confidence_interval.upper_bound) - 1) < 0.01,
  DOUBLE(dp_result[OFFSET(1)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(2)].value) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(2)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(2)].noise_confidence_interval.upper_bound) - 1) < 0.01,
  DOUBLE(dp_result[OFFSET(2)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(3)].value) - 2) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(3)].noise_confidence_interval.lower_bound) - 2) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(3)].noise_confidence_interval.upper_bound) - 2) < 0.01,
  DOUBLE(dp_result[OFFSET(3)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(4)].value) - 2) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(4)].noise_confidence_interval.lower_bound) - 2) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(4)].noise_confidence_interval.upper_bound) - 2) < 0.01,
  DOUBLE(dp_result[OFFSET(4)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(5)].value) - 3) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(5)].noise_confidence_interval.lower_bound) - 3) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(5)].noise_confidence_interval.upper_bound) - 3) < 0.01,
  DOUBLE(dp_result[OFFSET(5)].noise_confidence_interval.confidence_level) = 0.95,
FROM (
  SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
    JSON_QUERY_ARRAY(APPROX_QUANTILES(int64_val,
                     5, contribution_bounds_per_row => (1, 3), report_format => "JSON").result) AS dp_result
  FROM TestTableWithUid2
);
--
ARRAY<STRUCT<BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL>>
[{true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true}]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the output of a DP algorithm on an empty data set is indeterministic,
# we only test that the `noise_confidence_interval` value.
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,JSON_ARRAY_FUNCTIONS,JSON_TYPE,JSON_VALUE_EXTRACTION_FUNCTIONS]
[name=differential_privacy_approx_quantiles_double_explicit_bounds_multi_user_with_report_json_zero_rows]
[labels=differential_privacy]
SELECT
  ABS(DOUBLE(dp_result[OFFSET(0)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(0)].noise_confidence_interval.upper_bound) - 10) < 0.01,
  DOUBLE(dp_result[OFFSET(0)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(1)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(1)].noise_confidence_interval.upper_bound) - 10) < 0.01,
  DOUBLE(dp_result[OFFSET(1)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(2)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(2)].noise_confidence_interval.upper_bound) - 10) < 0.01,
  DOUBLE(dp_result[OFFSET(2)].noise_confidence_interval.confidence_level) = 0.95,
FROM (
  SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
    JSON_QUERY_ARRAY(APPROX_QUANTILES(double_val,
                   3, contribution_bounds_per_row => (1, 10), report_format => "JSON").result) AS dp_result
  FROM TestTableWithUid2 WHERE id > 1000
);
--
ARRAY<STRUCT<BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL>>[
  {true, true, true, true, true, true, true, true, true}
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the output of a DP algorithm on an empty data set is indeterministic,
# we only test that the `noise_confidence_interval` value.
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,JSON_ARRAY_FUNCTIONS,JSON_TYPE,JSON_VALUE_EXTRACTION_FUNCTIONS]
[name=differential_privacy_approx_quantiles_int64_explicit_bounds_multi_user_with_report_json_zero_rows]
[labels=differential_privacy]
SELECT
  ABS(DOUBLE(dp_result[OFFSET(0)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(0)].noise_confidence_interval.upper_bound) - 10) < 0.01,
  DOUBLE(dp_result[OFFSET(0)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(1)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(1)].noise_confidence_interval.upper_bound) - 10) < 0.01,
  DOUBLE(dp_result[OFFSET(1)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(dp_result[OFFSET(2)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(dp_result[OFFSET(2)].noise_confidence_interval.upper_bound) - 10) < 0.01,
  DOUBLE(dp_result[OFFSET(2)].noise_confidence_interval.confidence_level) = 0.95,
FROM (
  SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
    JSON_QUERY_ARRAY(APPROX_QUANTILES(int64_val,
                   3, contribution_bounds_per_row => (1, 10), report_format => "JSON").result) AS dp_result
  FROM TestTableWithUid2 WHERE id > 1000
);
--
ARRAY<STRUCT<BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL>>[
  {true, true, true, true, true, true, true, true, true}
]
==

[name=differential_privacy_count_unique_users_with_report_json_thresholding]
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,JSON_TYPE]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0)
  COUNT(*, contribution_bounds_per_group => (0,1), report_format => "JSON")
FROM TestTableWithUid;
--
ARRAY<STRUCT<JSON>>[
  {
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-5.99146454710798e-20,"upper_bound":5.99146454710798e-20},"value":10}}
  }
]
==

# Basic test with group selection strategy LAPLACE_THRESHOLD
[name=differential_privacy_group_selection_laplace_with_delta]
[required_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, group_selection_strategy=LAPLACE_THRESHOLD)
  SUM(double_val)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{11}]
==

# Public groups without group by
[name=differential_privacy_public_groups_without_group_by]
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_PUBLIC_GROUPS,NAMED_ARGUMENTS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, group_selection_strategy=PUBLIC_GROUPS)
  COUNT(int64_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<INT64>>[{8}]
==

# Public groups with group by
[name=differential_privacy_public_groups_with_group_by]
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_PUBLIC_GROUPS,NAMED_ARGUMENTS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, group_selection_strategy=PUBLIC_GROUPS)
  int64_val, COUNT(*, contribution_bounds_per_group => (0, 1))
FROM TestTableWithUid
RIGHT OUTER JOIN (
    SELECT DISTINCT int64_val FROM TestTableWithoutUid
  ) using(int64_val)
GROUP BY int64_val;
--
ARRAY<STRUCT<int64_val INT64, INT64>>[unknown order:
  {0, 0},
  {1, 3},
  {3, 1},
  {4, 1},
  {1234, 0}
]
==

# Public groups with group by
[name=differential_privacy_public_groups_with_group_by_and_max_groups_contributed]
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_PUBLIC_GROUPS,NAMED_ARGUMENTS]
[labels=anonymization]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, group_selection_strategy=PUBLIC_GROUPS, max_groups_contributed=3)
  int64_val, COUNT(*, contribution_bounds_per_group => (0, 1))
FROM TestTableWithUid
RIGHT OUTER JOIN (
    SELECT DISTINCT int64_val FROM TestTableWithoutUid
  ) using(int64_val)
GROUP BY int64_val;
--
ARRAY<STRUCT<int64_val INT64, INT64>>[unknown order:
  {0, 0},
  {1, 3},
  {3, 1},
  {4, 1},
  {1234, 0}
]

NOTE: Reference implementation reports non-determinism.
==

# If MIN_PRIVACY_UNITS_PER_GROUP=1 and delta = 1.0, then all groups should
# appear in the output. I.e. in the same way as if MIN_PRIVACY_UNITS_PER_GROUP=1
# were omitted. Clamping is such that no actual clamping occurrs.
[name=differential_privacy_min_privacy_units_per_group_is_one]
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP,NAMED_ARGUMENTS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, min_privacy_units_per_group=1, max_groups_contributed=NULL)
  int64_val, SUM(double_val, contribution_bounds_per_group => (-4.0, 4.0))
FROM TestTableWithUid
GROUP BY int64_val;
--
ARRAY<STRUCT<int64_val INT64, DOUBLE>>[unknown order:
  {1, 4.5},
  {3, 2.5},
  {NULL, 2.5},
  {2, 3},
  {4, -1.5}
]
==

# If MIN_PRIVACY_UNITS_PER_GROUP=2 and delta = 1.0, then groups should appear
# in the output if and only if >= 2 users contribute. For the TestTableWithUid,
# there are 3 `int64_val` with not less than 2 contributions:
# `1`, `NULL` and `2`.
[name=differential_privacy_min_privacy_units_per_group_is_2]
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP,NAMED_ARGUMENTS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, min_privacy_units_per_group=2, max_groups_contributed=NULL)
  int64_val, COUNT(uid,  contribution_bounds_per_group => (0, 1))
FROM TestTableWithUid
GROUP BY int64_val;
--

ARRAY<STRUCT<int64_val INT64, INT64>>[unknown order:{1, 3}, {NULL, 2}, {2, 3}]
==

# If MIN_PRIVACY_UNITS_PER_GROUP=3 and delta = 1.0, then groups should appear
# in the output if and only if >= 3 users contribute. Compared to the test above
# the null-group is discarded, since only 2 users contribute.
[name=differential_privacy_min_privacy_units_per_group_is_3]
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP,NAMED_ARGUMENTS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, min_privacy_units_per_group=3, max_groups_contributed=NULL)
  int64_val, COUNT(uid, contribution_bounds_per_group => (0, 1))
FROM TestTableWithUid
GROUP BY int64_val;
--

ARRAY<STRUCT<int64_val INT64, INT64>>[unknown order:{1, 3}, {2, 3}]
==

# This test is the same as the one above, however, now we specify the compatible
# group selection strategy (LAPLACE_THRESHOLDING) directly.
[name=differential_privacy_min_privacy_units_per_group_and_explicit_laplace_thresholding]
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP,NAMED_ARGUMENTS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta = 1.0, min_privacy_units_per_group=3, group_selection_strategy=LAPLACE_THRESHOLD, max_groups_contributed=NULL)
  int64_val, COUNT(uid, contribution_bounds_per_group => (0, 1))
FROM TestTableWithUid
GROUP BY int64_val;
--

ARRAY<STRUCT<int64_val INT64, INT64>>[unknown order:{1, 3}, {2, 3}]
==

# If MIN_PRIVACY_UNITS_PER_GROUP=4 and delta = 1.0, then groups should appear
# in the output if and only if >= 4 users contribute. Since there are no groups
# with more than 3 users in the dataset, the output should be empty.
[name=differential_privacy_min_privacy_units_per_group_is_4]
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP,NAMED_ARGUMENTS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, min_privacy_units_per_group=4, max_groups_contributed=NULL)
  int64_val, COUNT(uid, contribution_bounds_per_group => (0, 1))
FROM TestTableWithUid
GROUP BY int64_val;
--

ARRAY<STRUCT<int64_val INT64, INT64>>[]
==

# Engines should report an error if min_privacy_units_per_group is set
# simultaneously with the PUBLIC_GROUPS groups selection strategy.
[name=differential_privacy_public_groups_and_min_privacy_units_per_group_set]
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_PUBLIC_GROUPS,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP,NAMED_ARGUMENTS]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta = 1.0, min_privacy_units_per_group=2, group_selection_strategy = PUBLIC_GROUPS, max_groups_contributed=NULL)
  SUM(double_val, contribution_bounds_per_group => (0.0, 2.0))
FROM TestTableWithUid
--

ERROR: generic::invalid_argument: The MIN_PRIVACY_UNITS_PER_GROUP option must not be specified if GROUP_SELECTION_STRATEGY=PUBLIC_GROUPS
==

# The min_privacy_units_per_group should work well together with reports of
# type JSON.
[name=differential_privacy_min_privacy_units_per_group_works_with_json_report]
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,JSON_TYPE,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP]
[forbidden_features=ANONYMIZATION_THRESHOLDING]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, min_privacy_units_per_group=3, max_groups_contributed=NULL)
  int64_val, COUNT(*, contribution_bounds_per_group => (0, 1), report_format => "JSON")
FROM TestTableWithUid
GROUP BY int64_val;
--
ARRAY<STRUCT<int64_val INT64, JSON>>[unknown order:
  {
    1,
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-5.99146454710798e-20,"upper_bound":5.99146454710798e-20},"value":3}}
  },
  {
    2,
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-5.99146454710798e-20,"upper_bound":5.99146454710798e-20},"value":3}}
  }
]
==

# The min_privacy_units_per_group should work well together with reports of
# type PROTO.
[name=differential_privacy_min_privacy_units_per_group_works_with_proto_report]
[required_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP]
[forbidden_features=ANONYMIZATION_THRESHOLDING]
[labels=differential_privacy]
SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS(epsilon=1e20, delta=1.0, min_privacy_units_per_group=3, max_groups_contributed=NULL)
  int64_val, COUNT(*,  contribution_bounds_per_group => (0, 1), report_format => "PROTO")
FROM TestTableWithUid
GROUP BY int64_val;
--
ARRAY<STRUCT<
        int64_val INT64,
        PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>
      >>
[unknown order:{1,
                {
                  value {
                    int_value: 3
                    noise_confidence_interval {
                      lower_bound: -5.99146454710798e-20
                      upper_bound: 5.99146454710798e-20
                      confidence_level: 0.95
                    }
                  }
                }},
               {2,
                {
                  value {
                    int_value: 3
                    noise_confidence_interval {
                      lower_bound: -5.99146454710798e-20
                      upper_bound: 5.99146454710798e-20
                      confidence_level: 0.95
                    }
                  }
                }}]
