[prepare_database]
CREATE TABLE TestTableWithUid OPTIONS (userid_column=uid) AS
SELECT cast(1 as int64) as uid,
       cast(null as int64) as int64_val,
       cast(null as double) as double_val UNION ALL
  SELECT 2,  2,    1.5  UNION ALL
  SELECT 3,  1,    1.5  UNION ALL
  SELECT 4,  null, 2.5  UNION ALL
  SELECT 5,  1,    3.5  UNION ALL
  SELECT 6,  2,    null UNION ALL
  SELECT 7,  1,    -0.5 UNION ALL
  SELECT 8,  4,    -1.5 UNION ALL
  SELECT 9,  2,    1.5  UNION ALL
  SELECT 10, 3,    2.5
--
ARRAY<STRUCT<uid INT64, int64_val INT64, double_val DOUBLE>>[
  {1, NULL, NULL},
  {2, 2, 1.5},
  {3, 1, 1.5},
  {4, NULL, 2.5},
  {5, 1, 3.5},
  {6, 2, NULL},
  {7, 1, -0.5},
  {8, 4, -1.5},
  {9, 2, 1.5},
  {10, 3, 2.5}
]
==

[prepare_database]
CREATE TABLE TestTableWithUid2 OPTIONS (userid_column=uid) AS
SELECT cast(1 as int64) as id, cast(1 as int64) as uid,
       cast(null as int64) as int64_val,
       cast(null as double) as double_val UNION ALL
  SELECT 2,   2,  2,    1.5   UNION ALL
  SELECT 3,   3,  1,    1.5   UNION ALL
  SELECT 4,   1,  null, 2.5   UNION ALL
  SELECT 5,   2,  1,    3.5   UNION ALL
  SELECT 6,   2,  2,    null  UNION ALL
  SELECT 7,   1,  1,    -0.5  UNION ALL
  SELECT 8,   2,  4,    -1.5  UNION ALL
  SELECT 9,   3,  2,    1.5   UNION ALL
  SELECT 10,  2,  3,    2.5
--
ARRAY<STRUCT<id INT64, uid INT64, int64_val INT64, double_val DOUBLE>>[
  {1, 1, NULL, NULL},
  {2, 2, 2, 1.5},
  {3, 3, 1, 1.5},
  {4, 1, NULL, 2.5},
  {5, 2, 1, 3.5},
  {6, 2, 2, NULL},
  {7, 1, 1, -0.5},
  {8, 2, 4, -1.5},
  {9, 3, 2, 1.5},
  {10, 2, 3, 2.5}
]
==

[prepare_database]
CREATE TABLE TestTableWithUid3 OPTIONS (userid_column=uid) AS
SELECT cast(1 as int64) as id, cast(1 as int64) as uid,
       cast(null as int64) as int64_val,
       cast(null as double) as double_val UNION ALL
  SELECT 2,   2,  2,    1.5   UNION ALL
  SELECT 3,   1,  1,    1.5   UNION ALL
  SELECT 4,   1,  null, 2.5   UNION ALL
  SELECT 5,   1,  1,    3.5   UNION ALL
  SELECT 6,   2,  2,    null  UNION ALL
  SELECT 7,   1,  1,    -0.5  UNION ALL
  SELECT 8,   1,  4,    -1.5  UNION ALL
  SELECT 9,   3,  2,    1.5   UNION ALL
  SELECT 10,  1,  3,    2.5
--
ARRAY<STRUCT<id INT64, uid INT64, int64_val INT64, double_val DOUBLE>>[
  {1, 1, NULL, NULL},
  {2, 2, 2, 1.5},
  {3, 1, 1, 1.5},
  {4, 1, NULL, 2.5},
  {5, 1, 1, 3.5},
  {6, 2, 2, NULL},
  {7, 1, 1, -0.5},
  {8, 1, 4, -1.5},
  {9, 3, 2, 1.5},
  {10, 1, 3, 2.5}
]
==

[prepare_database]
CREATE TABLE TestTableWithUid4 OPTIONS (userid_column=uid) AS
SELECT cast(1 as int64) as id, cast(1 as int64) as uid,
       cast(null as int64) as int64_val,
       cast(null as double) as double_val UNION ALL
  SELECT 2,   2,  null,    null   UNION ALL
  SELECT 3,   1,  null,    null   UNION ALL
  SELECT 4,   1,  null,    null   UNION ALL
  SELECT 5,   1,  null,    null   UNION ALL
  SELECT 6,   2,  null,    null   UNION ALL
  SELECT 7,   1,  null,    null
--
ARRAY<STRUCT<id INT64, uid INT64, int64_val INT64, double_val DOUBLE>>[
  {1, 1, NULL, NULL},
  {2, 2, NULL, NULL},
  {3, 1, NULL, NULL},
  {4, 1, NULL, NULL},
  {5, 1, NULL, NULL},
  {6, 2, NULL, NULL},
  {7, 1, NULL, NULL}
]
==

[prepare_database]
CREATE TABLE TestTableWithoutUid  AS
SELECT cast(0 as int64) as int64_val,
       cast(0.0 as double) as double_val UNION ALL
  SELECT 1, 1.1 UNION ALL
  SELECT 3, 3.1 UNION ALL
  SELECT 4, 4.1 UNION ALL
  SELECT 1234, 12.34
--
ARRAY<STRUCT<int64_val INT64, double_val DOUBLE>>[
  {0, 0},
  {1, 1.1},
  {3, 3.1},
  {4, 4.1},
  {1234, 12.34}
]
==

# Epsilon is not specified in the query, so the query result depends on the
# engine default (which is unspecified in ZetaSQL), if any (if there is
# no engine default then the query should fail).  The reference implementation
# currently provides an error in this case.
#
[default required_features=ANONYMIZATION]
[name=anonymization_basic_k_threshold_only]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(k_threshold=0)
  IF(ANON_COUNT(double_val CLAMPED BETWEEN 0 AND 10) >= 0, true, true)
FROM TestTableWithUid;
--
ERROR: generic::invalid_argument: Anonymization option EPSILON must be set and non-NULL
==

# epsilon = 1e20 implies that no noise is added in this case
#
# Since the k-threshold is unspecified, the query produces an error (there
# is no engine default).
#
# We can revisit this test in the future if engines want to support a default
# k_threshold in some way.
[name=anonymization_basic_epsilon_only]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20)
  ANON_SUM(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid;
--
ERROR: generic::invalid_argument: Anonymization option DELTA or K_THRESHOLD must be set
==

# Same as above, but for ANON_AVG
[name=anonymization_basic_epsilon_only_anon_avg]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20)
  ANON_AVG(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid;
--
ERROR: generic::invalid_argument: Anonymization option DELTA or K_THRESHOLD must be set
==

[name=anonymization_basic_anon_sum_double_implicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_SUM(double_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{11}]
==

[name=anonymization_basic_anon_sum_double_implicit_bounds_multi_user]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_SUM(double_val)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{11}]
==

[name=anonymization_basic_anon_avg_double_implicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_AVG(double_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{1.375}]
==

[name=anonymization_basic_anon_avg_double_implicit_bounds_multi_user]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_AVG(double_val)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{1.3333333333333333}]
==

[name=anonymization_basic_anon_sum_int64_implicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_SUM(int64_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<INT64>>[{16}]
==

[name=anonymization_basic_anon_sum_int64_implicit_bounds_multi_user]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_SUM(int64_val)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<INT64>>[{16}]
==

[name=anonymization_basic_anon_avg_int64_implicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_AVG(int64_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{2}]
==

[name=anonymization_anon_sum_double_explicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_SUM(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{13}]
==

[name=anonymization_anon_sum_double_explicit_bounds_multi_user]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_SUM(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{11}]
==

[name=anonymization_anon_avg_double_explicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_AVG(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{1.625}]
==

[name=anonymization_anon_avg_double_explicit_bounds_multi_user]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_AVG(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{1.3333333333333335}]
==

[name=anonymization_anon_sum_int64_explicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_SUM(int64_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid;
--
ARRAY<STRUCT<INT64>>[{18}]
==

[name=anonymization_anon_sum_int64_explicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(int64_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid;
--
ARRAY<STRUCT<INT64>>[{18}]
==

[name=anonymization_anon_sum_int64_explicit_bounds_multi_user]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_SUM(int64_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<INT64>>[{8}]
==

[name=anonymization_anon_sum_int64_explicit_bounds_multi_user_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1)
  ANON_SUM(int64_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<INT64>>[{8}]
==

[name=anonymization_anon_sum_int64_explicit_bounds_multi_user_larger_k]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=3)
  ANON_SUM(int64_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<INT64>>[{8}]
==

[name=anonymization_anon_sum_int64_explicit_bounds_multi_user_smaller_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=0.7)
  ANON_SUM(int64_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<INT64>>[{8}]
==

[name=anonymization_anon_avg_int64_explicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_AVG(int64_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{2.25}]
==

[name=anonymization_anon_avg_int64_explicit_bounds_multi_user]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_AVG(int64_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{2.1333333333333333}]
==

[name=anonymization_anon_avg_int64_explicit_bounds_multi_user_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1)
  ANON_AVG(int64_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{2.1333333333333333}]
==

[name=anonymization_anon_avg_int64_explicit_bounds_multi_user_larger_k]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=3)
  ANON_AVG(int64_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{2.1333333333333333}]
==

[name=anonymization_anon_avg_int64_explicit_bounds_multi_user_smaller_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=0.7)
  ANON_AVG(int64_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{2.1333333333333333}]
==

[name=anonymization_k_threshold_eliminates_row]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=100)
  ANON_SUM(double_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[]
==

[name=anonymization_k_threshold_eliminates_row_for_anon_avg]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=100)
  ANON_AVG(double_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[]
==

[name=anonymization_explicit_bounds_sum_and_count]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_SUM(int64_val CLAMPED BETWEEN 2 AND 3),
  ANON_COUNT(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid;
--
ARRAY<STRUCT<INT64, INT64>>[{18, 8}]
==

[name=anonymization_explicit_bounds_avg_and_count]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_AVG(int64_val CLAMPED BETWEEN 2 AND 3),
  ANON_COUNT(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE, INT64>>[{2.25, 8}]
==

# Total aggregation, without kappa.
[name=anonymization_kappa_scalar_aggregation]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_COUNT(*)
FROM TestTableWithUid
  CROSS JOIN
     UNNEST([1,2,3]) as x;
--
ARRAY<STRUCT<INT64>>[{30}]
==

# Same as the previous, but with kappa = 1.  Since kappa is 1, and there
# is only 1 group, no user contributions are discarded and the final result
# is the same as the previous query without kappa.
[name=anonymization_kappa_scalar_aggregation_explicit]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1, kappa=1)
  ANON_COUNT(*)
FROM TestTableWithUid
  CROSS JOIN
     UNNEST([1,2,3]) as x;
--
ARRAY<STRUCT<INT64>>[{30}]

NOTE: Reference implementation reports non-determinism.
==

# In this query, each user contributes to 3 groups.  Kappa is 3, so none
# of the contributions are filtered.
[name=anonymization_kappa_group_by_3]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1, kappa=3)
  x, ANON_COUNT(*)
FROM TestTableWithUid
  CROSS JOIN
     UNNEST([1,2,3]) as x
GROUP BY x
ORDER BY x ASC;
--
ARRAY<STRUCT<x INT64, INT64>>[known order:{1, 10}, {2, 10}, {3, 10}]

NOTE: Reference implementation reports non-determinism.
==

# Similar to the previous query, each user has data for all of the 3 groups.
# Kappa is 2, so each user can only contribute to 2 groups.  The groups that
# the user contributes to can vary from one execution of the query to the
# next, so to get a deterministic result we perform a total aggregation
# across all groups to verify that each user contributes to exactly 2
# groups.  So the expected final result is 20 (10 users, 2 groups each).
[name=anonymization_kappa_group_by_2]
[labels=anonymization]
SELECT SUM(anon_count_star)
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1, kappa=2)
    x, ANON_COUNT(*) as anon_count_star
  FROM TestTableWithUid
    CROSS JOIN
       UNNEST([1,2,3]) as x
  GROUP BY x);
--
ARRAY<STRUCT<INT64>>[{20}]

NOTE: Reference implementation reports non-determinism.
==

# Same as the previous query, but with kappa = 1 so the expected result is 10.
[name=anonymization_kappa_group_by_1]
[labels=anonymization]
SELECT SUM(anon_count_star)
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1, kappa=1)
    x, ANON_COUNT(*) as anon_count_star
  FROM TestTableWithUid
    CROSS JOIN
       UNNEST([1,2,3]) as x
  GROUP BY x);
--
ARRAY<STRUCT<INT64>>[{10}]

NOTE: Reference implementation reports non-determinism.
==

# Same as the previous query, but using max_groups_contributed as a synonym for
# kappa.
[name=anonymization_max_groups_contributed_group_by_1]
[labels=anonymization]
SELECT SUM(anon_count_star)
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1, max_groups_contributed=1)
    x, ANON_COUNT(*) as anon_count_star
  FROM TestTableWithUid
    CROSS JOIN
       UNNEST([1,2,3]) as x
  GROUP BY x);
--
ARRAY<STRUCT<INT64>>[{10}]

NOTE: Reference implementation reports non-determinism.
==
# The number of rows per user is less than 5 in TestTableWithUid2, so the result
# won't be random.
[name=anonymization_basic_anon_var_pop_implicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
    ANON_VAR_POP(double_val), ANON_VAR_POP(int64_val),
  FROM TestTableWithUid2 UNION ALL
SELECT VAR_POP(double_val), VAR_POP(int64_val)
  FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[unknown order:{2.359375, 1}, {2.359375, 1}]
==

# Same as the previous query.
[name=anonymization_basic_anon_var_pop_explicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
    ANON_VAR_POP(double_val CLAMPED BETWEEN 2 AND 3),
  FROM TestTableWithUid2 UNION ALL
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
    ANON_VAR_POP(int64_val CLAMPED BETWEEN 2 AND 3),
  FROM TestTableWithUid2 UNION ALL
SELECT VAR_POP(ClampedValue) FROM (SELECT
      CASE
        WHEN double_val < 2 THEN 2
        WHEN double_val > 3 THEN 3
        ELSE double_val
      END
    AS ClampedValue
  FROM TestTableWithUid2) UNION ALL
SELECT VAR_POP(ClampedValue) FROM (SELECT
      CASE
        WHEN int64_val < 2 THEN 2
        WHEN int64_val > 3 THEN 3
        ELSE int64_val
      END
    AS ClampedValue
  FROM TestTableWithUid2)
--
ARRAY<STRUCT<DOUBLE>>[unknown order:{0.125}, {0.1875}, {0.125}, {0.1875}]
==

# For All-NULLs value, when bounds are explicitly set, the ANON_VAR_POP returns
# population variance of lower bound and upper bound.
[name=anonymization_basic_anon_var_pop_explicit_bounds_all_nulls]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
    ANON_VAR_POP(double_val CLAMPED BETWEEN 10 AND 100),
  FROM TestTableWithUid4 UNION ALL
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
    ANON_VAR_POP(int64_val CLAMPED BETWEEN 10 AND 100),
  FROM TestTableWithUid4
--
ARRAY<STRUCT<DOUBLE>>[unknown order:{2025}, {2025}]
==

# With less than 5 rows and verify that the anonymized variance is equal to the
# variance of all the rows.
[name=anonymization_verify_non_randomness_of_anon_var_pop_implicit_bounds]
[labels=anonymization]
SELECT ABS(
(SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_VAR_POP(double_val) FROM TestTableWithUid2) -
(SELECT VAR_POP(double_val) FROM TestTableWithUid2)) < 0.000001;
--
ARRAY<STRUCT<BOOL>>[{true}]
==

# With exactly 6 rows and verify that the anonymized variance is NOT equal to
# the variance of all 6 rows.
[name=anonymization_verify_randomness_of_anon_var_pop_implicit_bounds]
[labels=anonymization]
SELECT ABS(
(SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_VAR_POP(double_val) FROM TestTableWithUid3) -
(SELECT VAR_POP(double_val) FROM TestTableWithUid3)) < 0.000001;
--
ARRAY<STRUCT<BOOL>>[{false}]
==

# The number of rows per user is less than 5 in TestTableWithUid2, so the result
# won't be random.
[name=anonymization_basic_anon_stddev_pop_implicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_STDDEV_POP(double_val), ANON_STDDEV_POP(int64_val)
FROM TestTableWithUid2 UNION ALL
SELECT STDDEV_POP(double_val), STDDEV_POP(int64_val)
  FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[unknown order:
  {1.5360257159305635, 1},
  {1.5360257159305635, 1}
]
==

# Same as the previous query, the result won't be random for explicit bounds as
# well.
[name=anonymization_basic_anon_stddev_pop_explicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_STDDEV_POP(double_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid2  UNION ALL
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_STDDEV_POP(int64_val CLAMPED BETWEEN 2 AND 3),
FROM TestTableWithUid2  UNION ALL
SELECT STDDEV_POP(ClampedValue) FROM (SELECT
      CASE
        WHEN double_val < 2 THEN 2
        WHEN double_val > 3 THEN 3
        ELSE double_val
      END
    AS ClampedValue
  FROM TestTableWithUid2) UNION ALL
SELECT STDDEV_POP(ClampedValue) FROM (SELECT
      CASE
        WHEN int64_val < 2 THEN 2
        WHEN int64_val > 3 THEN 3
        ELSE int64_val
      END
    AS ClampedValue
  FROM TestTableWithUid2)
--
ARRAY<STRUCT<DOUBLE>>[unknown order:
  {0.35355339059327379},
  {0.4330127018922193},
  {0.35355339059327379},
  {0.4330127018922193}
]
==

# Same as the previous query, but input are all NULLs. For All-NULLs value,
# when bounds are explicitly set, the ANON_STDDEV_POP returns population
# standard deviation of lower bound and upper bound.
[name=anonymization_basic_anon_stddev_pop_explicit_bounds_all_nulls]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_STDDEV_POP(double_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid4  UNION ALL
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ANON_STDDEV_POP(int64_val CLAMPED BETWEEN 2 AND 3),
FROM TestTableWithUid4
--
ARRAY<STRUCT<DOUBLE>>[unknown order:{0.5}, {0.5}]
==

# ANON_PERCENTILE_CONT with null epsilon
[name=anonymization_basic_anon_percentile_cont_with_null_epsilon]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS()
  ANON_PERCENTILE_CONT(double_val, 0.4), ANON_PERCENTILE_CONT(int64_val, 0.6)
FROM TestTableWithUid2;
--
ERROR: generic::invalid_argument: Anonymization option EPSILON must be set and non-NULL
==

# ANON_PERCENTILE_CONT with implicit bounds. The number of rows per user is less
# than 5 in TestTableWithUid2, so the result won't be random.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=anonymization_basic_anon_percentile_cont_implicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ABS(ANON_PERCENTILE_CONT(double_val, 0.4) - 1.5) < 0.01,
  ABS(ANON_PERCENTILE_CONT(int64_val, 0.6) - 2) < 0.01
FROM TestTableWithUid2;
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==

# ANON_PERCENTILE_CONT with parameters
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=anonymization_basic_anon_percentile_cont_implicit_bounds_with_params]
[labels=anonymization]
[parameters=1 as lower,3 as upper]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ABS(ANON_PERCENTILE_CONT(double_val,
                           0.4 CLAMPED BETWEEN @lower AND @upper) - 1.5) < 0.01,
  ABS(ANON_PERCENTILE_CONT(int64_val,
                           0.6 CLAMPED BETWEEN @lower AND @upper) - 2) < 0.01
FROM TestTableWithUid2;
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==

# ANON_PERCENTILE_CONT with explicit bounds. The number of rows per user is less
# than 5 in TestTableWithUid2, so the result won't be random.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=anonymization_basic_anon_percentile_cont_explicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  ABS(ANON_PERCENTILE_CONT(double_val,
                           0.4 CLAMPED BETWEEN 1 AND 3) - 1.5) < 0.01,
  ABS(ANON_PERCENTILE_CONT(int64_val,
                           0.6 CLAMPED BETWEEN 1 AND 3) - 2) < 0.01,
FROM TestTableWithUid2;
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==

# With less than 5 rows and verify that the anonymized percentile is equal to
# the percentile of all the rows. Without noise it'll behave more like
# PERCENTILE_DISC to find a value in the input set.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[required_features=ANALYTIC_FUNCTIONS,ANONYMIZATION]
[name=anonymization_verify_non_randomness_of_anon_percentile_cont_implicit_bounds]
[labels=anonymization]
(SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
   ABS(ANON_PERCENTILE_CONT(double_val, 0.1) + 1.5) < 0.01
 FROM TestTableWithUid2)
  UNION ALL
(SELECT ABS(PERCENTILE_CONT(double_val, 0.1) OVER() + 0.8) < 0.01
 FROM TestTableWithUid2 LIMIT 1)
  UNION ALL
(SELECT ABS(PERCENTILE_DISC(double_val, 0.1) OVER() + 1.5) < 0.01
 FROM TestTableWithUid2 LIMIT 1);
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}, {true}]

NOTE: Reference implementation reports non-determinism.
==

# Another case with a different percentile (0.7) with less than 5 rows and
# verify that the anonymized percentile is equal to the percentile of all the
# rows. Without noise it'll behave more like PERCENTILE_DISC to find a value in
# the input set.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[required_features=ANALYTIC_FUNCTIONS,ANONYMIZATION]
[name=anonymization_verify_non_randomness_of_anon_percentile_cont_implicit_bounds_2]
[labels=anonymization]
(SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
   ABS(ANON_PERCENTILE_CONT(double_val, 0.7) - 2.5) < 0.01
 FROM TestTableWithUid2)
  UNION ALL
(SELECT ABS(PERCENTILE_CONT(double_val, 0.7) OVER() - 2.4) < 0.01
 FROM TestTableWithUid2 LIMIT 1)
  UNION ALL
(SELECT ABS(PERCENTILE_DISC(double_val, 0.7) OVER() - 2.5) < 0.01
 FROM TestTableWithUid2 LIMIT 1);
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}, {true}]

NOTE: Reference implementation reports non-determinism.

==

[name=anonymization_basic_anon_sum_double_implicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(double_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{11}]
==

[name=anonymization_basic_anon_sum_double_implicit_bounds_multi_user_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(double_val)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{11}]
==

[name=anonymization_basic_anon_avg_double_implicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(double_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{1.375}]
==

[name=anonymization_basic_anon_avg_double_implicit_bounds_multi_user_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(double_val)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{1.3333333333333333}]
==

[name=anonymization_basic_anon_sum_int64_implicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(int64_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<INT64>>[{16}]
==

[name=anonymization_basic_anon_sum_int64_implicit_bounds_multi_user_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(int64_val)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<INT64>>[{16}]
==

[name=anonymization_basic_anon_avg_int64_implicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(int64_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{2}]
==

[name=anonymization_anon_sum_double_explicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{13}]
==

[name=anonymization_anon_sum_double_explicit_bounds_multi_user_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{11}]
==

[name=anonymization_anon_avg_double_explicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{1.625}]
==

[name=anonymization_anon_avg_double_explicit_bounds_multi_user_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{1.3333333333333335}]
==

[name=anonymization_anon_avg_int64_explicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(int64_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[{2.25}]
==

[name=anonymization_delta_eliminates_row]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=100, delta=1e-220)
  ANON_SUM(double_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[]
==

[name=anonymization_delta_eliminates_row_for_anon_avg]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=100, delta=1e-220)
  ANON_AVG(double_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE>>[]
==

[name=anonymization_explicit_bounds_sum_and_count_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(int64_val CLAMPED BETWEEN 2 AND 3),
  ANON_COUNT(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid;
--
ARRAY<STRUCT<INT64, INT64>>[{18, 8}]
==

[name=anonymization_explicit_bounds_avg_and_count_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(int64_val CLAMPED BETWEEN 2 AND 3),
  ANON_COUNT(double_val CLAMPED BETWEEN 0 AND 10)
FROM TestTableWithUid;
--
ARRAY<STRUCT<DOUBLE, INT64>>[{2.25, 8}]
==

# Total aggregation, without kappa.
[name=anonymization_kappa_scalar_aggregation_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(*)
FROM TestTableWithUid
  CROSS JOIN
     UNNEST([1,2,3]) as x;
--
ARRAY<STRUCT<INT64>>[{30}]
==

# Same as the previous, but with kappa = 1.  Since kappa is 1, and there
# is only 1 group, no user contributions are discarded and the final result
# is the same as the previous query without kappa.
[name=anonymization_kappa_scalar_aggregation_explicit_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, kappa=1)
  ANON_COUNT(*)
FROM TestTableWithUid
  CROSS JOIN
     UNNEST([1,2,3]) as x;
--
ARRAY<STRUCT<INT64>>[{30}]

NOTE: Reference implementation reports non-determinism.
==

# In this query, each user contributes to 3 groups.  Kappa is 3, so none
# of the contributions are filtered.
[name=anonymization_kappa_group_by_3_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, kappa=3)
  x, ANON_COUNT(*)
FROM TestTableWithUid
  CROSS JOIN
     UNNEST([1,2,3]) as x
GROUP BY x
ORDER BY x ASC;
--
ARRAY<STRUCT<x INT64, INT64>>[known order:{1, 10}, {2, 10}, {3, 10}]

NOTE: Reference implementation reports non-determinism.
==

# Similar to the previous query, each user has data for all of the 3 groups.
# Kappa is 2, so each user can only contribute to 2 groups.  The groups that
# the user contributes to can vary from one execution of the query to the
# next, so to get a determinstic result we perform a total aggregation
# across all groups to verify that each user contributes to exactly 2
# groups.  So the expected final result is 20 (10 users, 2 groups each).
[name=anonymization_kappa_group_by_2_with_delta]
[labels=anonymization]
SELECT SUM(anon_count_star)
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, kappa=2)
    x, ANON_COUNT(*) as anon_count_star
  FROM TestTableWithUid
    CROSS JOIN
       UNNEST([1,2,3]) as x
  GROUP BY x);
--
ARRAY<STRUCT<INT64>>[{20}]

NOTE: Reference implementation reports non-determinism.
==

# Same as the previous query, but with kappa = 1 so the expected result is 10.
[name=anonymization_kappa_group_by_1_with_delta]
[labels=anonymization]
SELECT SUM(anon_count_star)
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, kappa=1)
    x, ANON_COUNT(*) as anon_count_star
  FROM TestTableWithUid
    CROSS JOIN
       UNNEST([1,2,3]) as x
  GROUP BY x);
--
ARRAY<STRUCT<INT64>>[{10}]

NOTE: Reference implementation reports non-determinism.
==

# Same as the previous query, but using max_groups_contributed as a synonym for
# kappa.
[name=anonymization_max_groups_contributed_group_by_1_with_delta]
[labels=anonymization]
SELECT SUM(anon_count_star)
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, max_groups_contributed=1)
    x, ANON_COUNT(*) as anon_count_star
  FROM TestTableWithUid
    CROSS JOIN
       UNNEST([1,2,3]) as x
  GROUP BY x);
--
ARRAY<STRUCT<INT64>>[{10}]

NOTE: Reference implementation reports non-determinism.
==
# The number of rows per user is less than 5 in TestTableWithUid2, so the result
# won't be random.
[name=anonymization_basic_anon_var_pop_implicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
    ANON_VAR_POP(double_val), ANON_VAR_POP(int64_val),
  FROM TestTableWithUid2 UNION ALL
SELECT VAR_POP(double_val), VAR_POP(int64_val)
  FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[unknown order:{2.359375, 1}, {2.359375, 1}]
==

# Same as the previous query.
[name=anonymization_basic_anon_var_pop_explicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
    ANON_VAR_POP(double_val CLAMPED BETWEEN 2 AND 3),
  FROM TestTableWithUid2 UNION ALL
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
    ANON_VAR_POP(int64_val CLAMPED BETWEEN 2 AND 3),
  FROM TestTableWithUid2 UNION ALL
SELECT VAR_POP(ClampedValue) FROM (SELECT
      CASE
        WHEN double_val < 2 THEN 2
        WHEN double_val > 3 THEN 3
        ELSE double_val
      END
    AS ClampedValue
  FROM TestTableWithUid2) UNION ALL
SELECT VAR_POP(ClampedValue) FROM (SELECT
      CASE
        WHEN int64_val < 2 THEN 2
        WHEN int64_val > 3 THEN 3
        ELSE int64_val
      END
    AS ClampedValue
  FROM TestTableWithUid2)
--
ARRAY<STRUCT<DOUBLE>>[unknown order:{0.125}, {0.1875}, {0.125}, {0.1875}]
==

# For All-NULLs value, when bounds are explicitly set, the ANON_VAR_POP returns
# population variance of lower bound and upper bound.
[name=anonymization_basic_anon_var_pop_explicit_bounds_all_nulls_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
    ANON_VAR_POP(double_val CLAMPED BETWEEN 10 AND 100),
  FROM TestTableWithUid4 UNION ALL
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
    ANON_VAR_POP(int64_val CLAMPED BETWEEN 10 AND 100),
  FROM TestTableWithUid4
--
ARRAY<STRUCT<DOUBLE>>[unknown order:{2025}, {2025}]
==

# With less than 5 rows and verify that the anonymized variance is equal to the
# variance of all the rows.
[name=anonymization_verify_non_randomness_of_anon_var_pop_implicit_bounds_with_delta]
[labels=anonymization]
SELECT ABS(
(SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_VAR_POP(double_val) FROM TestTableWithUid2) -
(SELECT VAR_POP(double_val) FROM TestTableWithUid2)) < 0.000001;
--
ARRAY<STRUCT<BOOL>>[{true}]
==

# With exactly 6 rows and verify that the anonymized variance is NOT equal to
# the variance of all 6 rows.
[name=anonymization_verify_randomness_of_anon_var_pop_implicit_bounds_with_delta]
[labels=anonymization]
SELECT ABS(
(SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_VAR_POP(double_val) FROM TestTableWithUid3) -
(SELECT VAR_POP(double_val) FROM TestTableWithUid3)) < 0.000001;
--
ARRAY<STRUCT<BOOL>>[{false}]
==

# The number of rows per user is less than 5 in TestTableWithUid2, so the result
# won't be random.
[name=anonymization_basic_anon_stddev_pop_implicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_STDDEV_POP(double_val), ANON_STDDEV_POP(int64_val)
FROM TestTableWithUid2 UNION ALL
SELECT STDDEV_POP(double_val), STDDEV_POP(int64_val)
  FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE, DOUBLE>>[unknown order:
  {1.5360257159305635, 1},
  {1.5360257159305635, 1}
]
==

# Same as the previous query, the result won't be random for explicit bounds as
# well.
[name=anonymization_basic_anon_stddev_pop_explicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_STDDEV_POP(double_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid2  UNION ALL
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_STDDEV_POP(int64_val CLAMPED BETWEEN 2 AND 3),
FROM TestTableWithUid2  UNION ALL
SELECT STDDEV_POP(ClampedValue) FROM (SELECT
      CASE
        WHEN double_val < 2 THEN 2
        WHEN double_val > 3 THEN 3
        ELSE double_val
      END
    AS ClampedValue
  FROM TestTableWithUid2) UNION ALL
SELECT STDDEV_POP(ClampedValue) FROM (SELECT
      CASE
        WHEN int64_val < 2 THEN 2
        WHEN int64_val > 3 THEN 3
        ELSE int64_val
      END
    AS ClampedValue
  FROM TestTableWithUid2)
--
ARRAY<STRUCT<DOUBLE>>[unknown order:
  {0.35355339059327379},
  {0.4330127018922193},
  {0.35355339059327379},
  {0.4330127018922193}
]
==

# Same as the previous query, but input are all NULLs. For All-NULLs value,
# when bounds are explicitly set, the ANON_STDDEV_POP returns population
# standard deviation of lower bound and upper bound.
[name=anonymization_basic_anon_stddev_pop_explicit_bounds_all_nulls_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_STDDEV_POP(double_val CLAMPED BETWEEN 2 AND 3)
FROM TestTableWithUid4  UNION ALL
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_STDDEV_POP(int64_val CLAMPED BETWEEN 2 AND 3),
FROM TestTableWithUid4
--
ARRAY<STRUCT<DOUBLE>>[unknown order:{0.5}, {0.5}]
==

# ANON_PERCENTILE_CONT with null epsilon
[name=anonymization_basic_anon_percentile_cont_with_null_epsilon_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS()
  ANON_PERCENTILE_CONT(double_val, 0.4), ANON_PERCENTILE_CONT(int64_val, 0.6)
FROM TestTableWithUid2;
--
ERROR: generic::invalid_argument: Anonymization option EPSILON must be set and non-NULL
==

# ANON_PERCENTILE_CONT with implicit bounds. The number of rows per user is less
# than 5 in TestTableWithUid2, so the result won't be random.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=anonymization_basic_anon_percentile_cont_implicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ABS(ANON_PERCENTILE_CONT(double_val, 0.4) - 1.5) < 0.01,
  ABS(ANON_PERCENTILE_CONT(int64_val, 0.6) - 2) < 0.01
FROM TestTableWithUid2;
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==

# ANON_PERCENTILE_CONT with parameters
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=anonymization_basic_anon_percentile_cont_implicit_bounds_with_params_with_delta]
[labels=anonymization]
[parameters=1 as lower,3 as upper]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ABS(ANON_PERCENTILE_CONT(double_val,
                           0.4 CLAMPED BETWEEN @lower AND @upper) - 1.5) < 0.01,
  ABS(ANON_PERCENTILE_CONT(int64_val,
                           0.6 CLAMPED BETWEEN @lower AND @upper) - 2) < 0.01
FROM TestTableWithUid2;
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==

# ANON_PERCENTILE_CONT with explicit bounds. The number of rows per user is less
# than 5 in TestTableWithUid2, so the result won't be random.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=anonymization_basic_anon_percentile_cont_explicit_bounds_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ABS(ANON_PERCENTILE_CONT(double_val,
                           0.4 CLAMPED BETWEEN 1 AND 3) - 1.5) < 0.01,
  ABS(ANON_PERCENTILE_CONT(int64_val,
                           0.6 CLAMPED BETWEEN 1 AND 3) - 2) < 0.01,
FROM TestTableWithUid2;
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==

# With less than 5 rows and verify that the anonymized percentile is equal to
# the percentile of all the rows. Without noise it'll behave more like
# PERCENTILE_DISC to find a value in the input set.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[required_features=ANALYTIC_FUNCTIONS,ANONYMIZATION]
[name=anonymization_verify_non_randomness_of_anon_percentile_cont_implicit_bounds_with_delta]
[labels=anonymization]
(SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
   ABS(ANON_PERCENTILE_CONT(double_val, 0.1) + 1.5) < 0.01
 FROM TestTableWithUid2)
  UNION ALL
(SELECT ABS(PERCENTILE_CONT(double_val, 0.1) OVER() + 0.8) < 0.01
 FROM TestTableWithUid2 LIMIT 1)
  UNION ALL
(SELECT ABS(PERCENTILE_DISC(double_val, 0.1) OVER() + 1.5) < 0.01
 FROM TestTableWithUid2 LIMIT 1);
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}, {true}]

NOTE: Reference implementation reports non-determinism.
==

# Another case with a different percentile (0.7) with less than 5 rows and
# verify that the anonymized percentile is equal to the percentile of all the
# rows. Without noise it'll behave more like PERCENTILE_DISC to find a value in
# the input set.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[required_features=ANALYTIC_FUNCTIONS,ANONYMIZATION]
[name=anonymization_verify_non_randomness_of_anon_percentile_cont_implicit_bounds_2_with_delta]
[labels=anonymization]
(SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
   ABS(ANON_PERCENTILE_CONT(double_val, 0.7) - 2.5) < 0.01
 FROM TestTableWithUid2)
  UNION ALL
(SELECT ABS(PERCENTILE_CONT(double_val, 0.7) OVER() - 2.4) < 0.01
 FROM TestTableWithUid2 LIMIT 1)
  UNION ALL
(SELECT ABS(PERCENTILE_DISC(double_val, 0.7) OVER() - 2.5) < 0.01
 FROM TestTableWithUid2 LIMIT 1);
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}, {true}]

NOTE: Reference implementation reports non-determinism.
==

# ANON_QUANTILES with null epsilon
[name=anonymization_basic_anon_quantiles_with_null_epsilon]
[labels=anonymization]
[parameters=1 as lower,3 as upper]
SELECT WITH ANONYMIZATION OPTIONS()
  ANON_QUANTILES(double_val, 5 CLAMPED BETWEEN @lower AND @upper),
  ANON_QUANTILES(int64_val, 5 CLAMPED BETWEEN @lower AND @upper)
FROM TestTableWithUid2;
--
ERROR: generic::invalid_argument: Anonymization option EPSILON must be set and non-NULL
==

# ANON_QUANTILES with null delta
[name=anonymization_basic_anon_quantiles_with_null_delta]
[labels=anonymization]
[parameters=1 as lower,3 as upper]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20)
  ANON_QUANTILES(double_val, 5 CLAMPED BETWEEN @lower AND @upper),
  ANON_QUANTILES(int64_val, 5 CLAMPED BETWEEN @lower AND @upper)
FROM TestTableWithUid2;
--
ERROR: generic::invalid_argument: Anonymization option DELTA or K_THRESHOLD must be set
==

# ANON_QUANTILES with implicit bounds, which is not supported, since the DP
# libraries do not yet support them (see b/205277450).
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=anonymization_basic_anon_quantiles_implicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ABS(ANON_QUANTILES(double_val, 5)[OFFSET(2)] - 1.5) < 0.01,
  ABS(ANON_QUANTILES(int64_val, 5)[OFFSET(3)] - 2) < 0.01
FROM TestTableWithUid2;
--
ERROR: generic::invalid_argument: No matching signature for aggregate function ANON_QUANTILES for argument types: DOUBLE, INT64. Supported signatures: ANON_QUANTILES(DOUBLE, INT64 CLAMPED BETWEEN DOUBLE AND DOUBLE) [at 2:7]
  ABS(ANON_QUANTILES(double_val, 5)[OFFSET(2)] - 1.5) < 0.01,
      ^
==

# ANON_QUANTILES with explicit bounds. The number of rows per user is less than
# 5 in TestTableWithUid2, so the result won't be random.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=anonymization_basic_anon_quantiles_explicit_bounds]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ABS(ANON_QUANTILES(double_val,
                     5 CLAMPED BETWEEN 1 AND 3)[OFFSET(2)] - 1.5) < 0.01,
  ABS(ANON_QUANTILES(int64_val,
                     5 CLAMPED BETWEEN 1 AND 3)[OFFSET(3)] - 2) < 0.01,
FROM TestTableWithUid2;
--
ARRAY<STRUCT<BOOL, BOOL>>[{true, true}]
==

# ANON_QUANTILES with explicit bounds, testing that the number of quantile
# boundaries returned is one greater than the number of quantiles requested.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=anonymization_basic_anon_quantiles_explicit_bounds_result_length]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ARRAY_LENGTH(ANON_QUANTILES(double_val,
                     5 CLAMPED BETWEEN 1 AND 3)),
  ARRAY_LENGTH(ANON_QUANTILES(int64_val,
                     5 CLAMPED BETWEEN 1 AND 3)),
FROM TestTableWithUid2;
--
ARRAY<STRUCT<INT64, INT64>>[{6, 6}]
==

# With less than 5 rows per user and verify that the anonymized quantiles are
# equal to the quantiles of all the rows. Without noise, it'll behave more like
# APPROX_QUANTILES to find a value in the input set.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[required_features=ANONYMIZATION]
[name=anonymization_verify_non_randomness_of_anon_quantiles_explicit_bounds]
[labels=anonymization]
(SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
   ABS(ANON_QUANTILES(double_val, 10 CLAMPED BETWEEN -2 AND 10)[OFFSET(1)] + 1.5) < 0.01
 FROM TestTableWithUid2)
  UNION ALL
(SELECT ABS(APPROX_QUANTILES(double_val, 10)[OFFSET(1)] + 1.5) < 0.01
 FROM TestTableWithUid2 LIMIT 1);
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}]
==

# Another case with a different quantile (0.1) with less than 5 rows per user
# and verify that the anonymized percentile is equal to the percentile of all
# the rows. Without noise it'll behave more like APPROX_QUANTILES to find a
# value in the input set.
#
# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[required_features=ANONYMIZATION]
[name=anonymization_verify_non_randomness_of_anon_quantiles_explicit_bounds_2]
[labels=anonymization]
(SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
   ABS(ANON_QUANTILES(double_val, 10 CLAMPED BETWEEN -2 AND 10)[OFFSET(7)] - 2.5) < 0.01
 FROM TestTableWithUid2)
  UNION ALL
(SELECT ABS(APPROX_QUANTILES(double_val, 10)[OFFSET(7)] - 2.5) < 0.01
 FROM TestTableWithUid2 LIMIT 1);
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}]
==

[name=anonymization_anon_sum_double_explicit_bounds_multi_user_with_report_proto]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(double_val CLAMPED BETWEEN 0 AND 10 WITH Report(format=Proto))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.AnonOutputWithReport>>>[
  {{
     value {
       float_value: 11
       noise_confidence_interval {
         lower_bound: -5.9914645471079794e-19
         upper_bound: 5.9914645471079794e-19
         confidence_level: 0.95
       }
     }
   }}
]
==

[required_features=ANONYMIZATION]
[name=anonymization_anon_avg_explicit_bounds_multi_user_with_report_proto_1]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(double_val CLAMPED BETWEEN 0 AND 10 WITH Report(format=Proto))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.AnonOutputWithReport>>>[
  {{
     value {
       float_value: 1.3333333333333335
       noise_confidence_interval {
         lower_bound: 1.3333333333333335
         upper_bound: 1.3333333333333335
         confidence_level: 0.95
       }
     }
   }}
]
==

[required_features=ANONYMIZATION]
[name=anonymization_anon_avg_explicit_bounds_multi_user_with_report_proto_2]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(int64_val CLAMPED BETWEEN 0 AND 10 WITH Report(format=Proto))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.AnonOutputWithReport>>>[
  {{
     value {
       float_value: 1.6333333333333333
       noise_confidence_interval {
         lower_bound: 1.6333333333333333
         upper_bound: 1.6333333333333333
         confidence_level: 0.95
       }
     }
   }}
]
==

[required_features=ANONYMIZATION]
[name=anonymization_anon_avg_implicit_bounds_multi_user_with_report_proto_1]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(double_val WITH Report(format=Proto))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.AnonOutputWithReport>>>[
  {{
     value {
       float_value: 1.3333333333333333
       noise_confidence_interval {
         lower_bound: 1.3333333333333333
         upper_bound: 1.3333333333333333
         confidence_level: 0.95
       }
     }
     bounding_report {
       lower_bound {
         float_value: 0.5
       }
       upper_bound {
         float_value: 2
       }
       num_inputs: 3
       num_outside: 0
     }
   }}
]
==

[required_features=ANONYMIZATION]
[name=anonymization_anon_avg_implicit_bounds_multi_user_with_report_proto_2]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(int64_val WITH Report(format=Proto))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.AnonOutputWithReport>>>[
  {{
     value {
       float_value: 1.6333333333333333
       noise_confidence_interval {
         lower_bound: 1.6333333333333333
         upper_bound: 1.6333333333333333
         confidence_level: 0.95
       }
     }
     bounding_report {
       lower_bound {
         float_value: 0.5
       }
       upper_bound {
         float_value: 4
       }
       num_inputs: 3
       num_outside: 0
     }
   }}
]
==

[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_anon_avg_explicit_bounds_multi_user_with_report_json_1]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(double_val CLAMPED BETWEEN 0 AND 10 WITH Report(format=Json))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":1.3333333333333335,"upper_bound":1.3333333333333335},"value":1.3333333333333335}}
  }
]
==

[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_anon_avg_explicit_bounds_multi_user_with_report_json_2]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(int64_val CLAMPED BETWEEN 0 AND 10 WITH Report(format=Json))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":1.6333333333333333,"upper_bound":1.6333333333333333},"value":1.6333333333333333}}
  }
]
==

[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_anon_avg_implicit_bounds_multi_user_with_report_json_1]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(double_val WITH Report(format=Json))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"bounding_report":{"lower_bound":0.5,"num_inputs":3.0,"num_outside":0.0,"upper_bound":2.0},"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":1.3333333333333333,"upper_bound":1.3333333333333333},"value":1.3333333333333333}}
  }
]
==

[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_anon_avg_implicit_bounds_multi_user_with_report_json_2]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_AVG(int64_val WITH Report(format=Json))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"bounding_report":{"lower_bound":0.5,"num_inputs":3.0,"num_outside":0.0,"upper_bound":4.0},"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":1.6333333333333333,"upper_bound":1.6333333333333333},"value":1.6333333333333333}}
  }
]
==

[name=anonymization_basic_anon_sum_int64_implicit_bounds_multi_user_with_report_proto]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(int64_val WITH Report(format=Proto))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.AnonOutputWithReport>>>[
  {{
     value {
       int_value: 16
       noise_confidence_interval {
         lower_bound: -1.9172686550745535e-18
         upper_bound: 1.9172686550745535e-18
         confidence_level: 0.95
       }
     }
     bounding_report {
       lower_bound {
         int_value: -16
       }
       upper_bound {
         int_value: 16
       }
       num_inputs: 3
       num_outside: 0
     }
   }}
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" without a CLAMPED clause.
[name=anonymization_basic_anon_sum_int64_implicit_bounds_multi_user_with_report_proto_zero_rows]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(int64_val WITH Report(format=Proto))
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::failed_precondition: Bin count threshold was too large to find approximate bounds. Either run over a larger dataset or decrease success_probability and try again.
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the `float_value` is indeterministic, we only output `noise_confidence_interval`
[name=anonymization_anon_sum_double_explicit_bounds_multi_user_with_report_proto_zero_rows]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(double_val CLAMPED BETWEEN 0 AND 10 WITH Report(format=Proto)).value.noise_confidence_interval
FROM TestTableWithUid2 WHERE id > 1000;
--
ARRAY<STRUCT<noise_confidence_interval PROTO<zetasql.NoiseConfidenceInterval>>>[
  {{
     lower_bound: -5.9914645471079794e-19
     upper_bound: 5.9914645471079794e-19
     confidence_level: 0.95
   }}
]
==

[name=anonymization_anon_count_double_explicit_bounds_multi_user_with_report_proto]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(double_val CLAMPED BETWEEN 0 AND 10 WITH Report(format=Proto))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.AnonOutputWithReport>>>[
  {{
     value {
       int_value: 8
       noise_confidence_interval {
         lower_bound: -5.9914645471079794e-19
         upper_bound: 5.9914645471079794e-19
         confidence_level: 0.95
       }
     }
   }}
]
==

[name=anonymization_basic_anon_count_int64_implicit_bounds_multi_user_with_report_proto]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(int64_val WITH Report(format=Proto))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.AnonOutputWithReport>>>[
  {{
     value {
       int_value: 8
       noise_confidence_interval {
         lower_bound: -9.5863432753727674e-19
         upper_bound: 9.5863432753727674e-19
         confidence_level: 0.95
       }
     }
     bounding_report {
       lower_bound {
         int_value: -8
       }
       upper_bound {
         int_value: 8
       }
       num_inputs: 3
       num_outside: 0
     }
   }}
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" without a CLAMPED clause.
[name=anonymization_basic_anon_count_int64_implicit_bounds_multi_user_with_report_proto_zero_rows]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(int64_val WITH Report(format=Proto))
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::failed_precondition: Bin count threshold was too large to find approximate bounds. Either run over a larger dataset or decrease success_probability and try again.
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the `float_value` is indeterministic, we only output `noise_confidence_interval`
[name=anonymization_anon_count_double_explicit_bounds_multi_user_with_report_proto_zero_rows]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(double_val CLAMPED BETWEEN 0 AND 10 WITH Report(format=Proto)).value.noise_confidence_interval
FROM TestTableWithUid2 WHERE id > 1000;
--
ARRAY<STRUCT<noise_confidence_interval PROTO<zetasql.NoiseConfidenceInterval>>>[
  {{
     lower_bound: -5.9914645471079794e-19
     upper_bound: 5.9914645471079794e-19
     confidence_level: 0.95
   }}
]
==

[name=anonymization_anon_count_star_explicit_bounds_multi_user_with_report_proto]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(* CLAMPED BETWEEN 0 AND 10 WITH Report(format=Proto))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<PROTO<zetasql.AnonOutputWithReport>>>[
  {{
     value {
       int_value: 10
       noise_confidence_interval {
         lower_bound: -5.9914645471079794e-19
         upper_bound: 5.9914645471079794e-19
         confidence_level: 0.95
       }
     }
   }}
]
==

[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_anon_sum_double_explicit_bounds_multi_user_with_report_json]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(double_val CLAMPED BETWEEN 0 AND 10 WITH Report(format=Json))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-5.991464547107979e-19,"upper_bound":5.991464547107979e-19},"value":11.0}}
  }
]
==

[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_basic_anon_sum_int64_implicit_bounds_multi_user_with_report_json]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(int64_val WITH Report(format=Json))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"bounding_report":{"lower_bound":-16,"num_inputs":3.0,"num_outside":0.0,"upper_bound":16},"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-1.9172686550745535e-18,"upper_bound":1.9172686550745535e-18},"value":16}}
  }
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" without a CLAMPED clause.
[required_features=ANONYMIZATION]
[name=anonymization_basic_anon_sum_int64_implicit_bounds_multi_user_with_report_json_zero_rows]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(int64_val WITH Report(format=Proto))
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::failed_precondition: Bin count threshold was too large to find approximate bounds. Either run over a larger dataset or decrease success_probability and try again.
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the `float_value` is indeterministic, we only output `noise_confidence_interval`
[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_anon_sum_double_explicit_bounds_multi_user_with_report_json_zero_rows]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_SUM(double_val CLAMPED BETWEEN 0 AND 10 WITH Report(format=Json)).result.noise_confidence_interval
FROM TestTableWithUid2 WHERE id > 1000;
--
ARRAY<STRUCT<noise_confidence_interval JSON>>[
  {
    {"confidence_level":0.95,"lower_bound":-5.991464547107979e-19,"upper_bound":5.991464547107979e-19}
  }
]
==

[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_anon_count_double_explicit_bounds_multi_user_with_report_json]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(double_val CLAMPED BETWEEN 0 AND 10 WITH Report(format=json))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-5.991464547107979e-19,"upper_bound":5.991464547107979e-19},"value":8}}
  }
]
==

[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_basic_anon_count_int64_implicit_bounds_multi_user_with_report_json]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(int64_val WITH Report(format=json))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"bounding_report":{"lower_bound":-8,"num_inputs":3.0,"num_outside":0.0,"upper_bound":8},"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-9.586343275372767e-19,"upper_bound":9.586343275372767e-19},"value":8}}
  }
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" without a CLAMPED clause.
[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_basic_anon_count_int64_implicit_bounds_multi_user_with_report_json_zero_rows]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(int64_val WITH Report(format=json))
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::failed_precondition: Bin count threshold was too large to find approximate bounds. Either run over a larger dataset or decrease success_probability and try again.
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the `float_value` is indeterministic, we only output `noise_confidence_interval`
[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_anon_count_double_explicit_bounds_multi_user_with_report_json_zero_rows]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(double_val CLAMPED BETWEEN 0 AND 10 WITH Report(format=json)).result.noise_confidence_interval
FROM TestTableWithUid2 WHERE id > 1000;
--
ARRAY<STRUCT<noise_confidence_interval JSON>>[
  {
    {"confidence_level":0.95,"lower_bound":-5.991464547107979e-19,"upper_bound":5.991464547107979e-19}
  }
]
==

[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_anon_count_star_explicit_bounds_multi_user_with_report_json]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(* CLAMPED BETWEEN 0 AND 10 WITH Report(format=json))
FROM TestTableWithUid2;
--
ARRAY<STRUCT<JSON>>[
  {
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-5.991464547107979e-19,"upper_bound":5.991464547107979e-19},"value":10}}
  }
]
==

# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[name=anonymization_anon_quantiles_double_explicit_bounds_multi_user_with_report_proto]
[labels=anonymization]
SELECT
  ABS(anon_result[OFFSET(0)].float_value - 1) < 0.01,
  ABS(anon_result[OFFSET(0)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(anon_result[OFFSET(0)].noise_confidence_interval.upper_bound - 1) < 0.01,
  anon_result[OFFSET(0)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(1)].float_value - 1) < 0.01,
  ABS(anon_result[OFFSET(1)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(anon_result[OFFSET(1)].noise_confidence_interval.upper_bound - 1) < 0.01,
  anon_result[OFFSET(1)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(2)].float_value - 1.5) < 0.01,
  ABS(anon_result[OFFSET(2)].noise_confidence_interval.lower_bound - 1.5) < 0.01,
  ABS(anon_result[OFFSET(2)].noise_confidence_interval.upper_bound - 1.5) < 0.01,
  anon_result[OFFSET(2)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(3)].float_value - 1.5) < 0.01,
  ABS(anon_result[OFFSET(3)].noise_confidence_interval.lower_bound - 1.5) < 0.01,
  ABS(anon_result[OFFSET(3)].noise_confidence_interval.upper_bound - 1.5) < 0.01,
  anon_result[OFFSET(3)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(4)].float_value - 2.5) < 0.01,
  ABS(anon_result[OFFSET(4)].noise_confidence_interval.lower_bound - 2.5) < 0.01,
  ABS(anon_result[OFFSET(4)].noise_confidence_interval.upper_bound - 2.5) < 0.01,
  anon_result[OFFSET(4)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(5)].float_value - 2.5) < 0.01,
  ABS(anon_result[OFFSET(5)].noise_confidence_interval.lower_bound - 2.5) < 0.01,
  ABS(anon_result[OFFSET(5)].noise_confidence_interval.upper_bound - 2.5) < 0.01,
  anon_result[OFFSET(5)].noise_confidence_interval.confidence_level = 0.95,
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
    ANON_QUANTILES(double_val,
                       5 CLAMPED BETWEEN 1 AND 3 WITH REPORT(FORMAT=PROTO)).values.values AS anon_result
  FROM TestTableWithUid2
);
--
ARRAY<STRUCT<BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL>>
[{true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true}]
==

[name=anonymization_anon_quantiles_int64_explicit_bounds_multi_user_with_report_proto]
[labels=anonymization]
SELECT
  ABS(anon_result[OFFSET(0)].float_value - 1) < 0.01,
  ABS(anon_result[OFFSET(0)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(anon_result[OFFSET(0)].noise_confidence_interval.upper_bound - 1) < 0.01,
  anon_result[OFFSET(0)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(1)].float_value - 1) < 0.01,
  ABS(anon_result[OFFSET(1)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(anon_result[OFFSET(1)].noise_confidence_interval.upper_bound - 1) < 0.01,
  anon_result[OFFSET(1)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(2)].float_value - 1) < 0.01,
  ABS(anon_result[OFFSET(2)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(anon_result[OFFSET(2)].noise_confidence_interval.upper_bound - 1) < 0.01,
  anon_result[OFFSET(2)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(3)].float_value - 2) < 0.01,
  ABS(anon_result[OFFSET(3)].noise_confidence_interval.lower_bound - 2) < 0.01,
  ABS(anon_result[OFFSET(3)].noise_confidence_interval.upper_bound - 2) < 0.01,
  anon_result[OFFSET(3)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(4)].float_value - 2) < 0.01,
  ABS(anon_result[OFFSET(4)].noise_confidence_interval.lower_bound - 2) < 0.01,
  ABS(anon_result[OFFSET(4)].noise_confidence_interval.upper_bound - 2) < 0.01,
  anon_result[OFFSET(4)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(5)].float_value - 3) < 0.01,
  ABS(anon_result[OFFSET(5)].noise_confidence_interval.lower_bound - 3) < 0.01,
  ABS(anon_result[OFFSET(5)].noise_confidence_interval.upper_bound - 3) < 0.01,
  anon_result[OFFSET(5)].noise_confidence_interval.confidence_level = 0.95,
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
    ANON_QUANTILES(int64_val,
                       5 CLAMPED BETWEEN 1 AND 3 WITH REPORT(FORMAT=PROTO)).values.values AS anon_result
  FROM TestTableWithUid2
);
--
ARRAY<STRUCT<BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL>>
[{true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true}]
==

# ANON_QUANTILES with implicit bounds is not yet supported, since the DP
# libraries do not yet support them (see b/205277450).
[name=anonymization_anon_quantiles_double_implicit_bounds_multi_user_with_report_proto]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_QUANTILES(double_val, 5 WITH REPORT(FORMAT=PROTO))
FROM TestTableWithUid2;
--
ERROR: generic::invalid_argument: No matching signature for aggregate operator ANON_QUANTILES for argument types: DOUBLE, INT64. Supported signatures: ANON_QUANTILES(DOUBLE, INT64 CLAMPED BETWEEN DOUBLE AND DOUBLE WITH REPORT(FORMAT=PROTO)) [at 2:3]
  ANON_QUANTILES(double_val, 5 WITH REPORT(FORMAT=PROTO))
  ^
==

# ANON_QUANTILES with implicit bounds is not yet supported, since the DP
# libraries do not yet support them (see b/205277450).
[name=anonymization_anon_quantiles_int64_implicit_bounds_multi_user_with_report_proto]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_QUANTILES(int64_val, 5 WITH REPORT(FORMAT=PROTO))
FROM TestTableWithUid2;
--
ERROR: generic::invalid_argument: No matching signature for aggregate operator ANON_QUANTILES for argument types: INT64, INT64. Supported signatures: ANON_QUANTILES(DOUBLE, INT64 CLAMPED BETWEEN DOUBLE AND DOUBLE WITH REPORT(FORMAT=PROTO)) [at 2:3]
  ANON_QUANTILES(int64_val, 5 WITH REPORT(FORMAT=PROTO))
  ^
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the output of a DP algorithm on an empty data set is indeterministic,
# we only test that the `noise_confidence_interval` value.
[name=anonymization_anon_quantiles_double_explicit_bounds_multi_user_with_report_proto_zero_rows]
[labels=anonymization]
SELECT
  ABS(anon_result[OFFSET(0)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(anon_result[OFFSET(0)].noise_confidence_interval.upper_bound - 10) < 0.01,
  anon_result[OFFSET(0)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(1)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(anon_result[OFFSET(1)].noise_confidence_interval.upper_bound - 10) < 0.01,
  anon_result[OFFSET(1)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(2)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(anon_result[OFFSET(2)].noise_confidence_interval.upper_bound - 10) < 0.01,
  anon_result[OFFSET(2)].noise_confidence_interval.confidence_level = 0.95,
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
    ANON_QUANTILES(double_val,
                   3 CLAMPED BETWEEN 1 AND 10 WITH REPORT(FORMAT=PROTO)).values.values AS anon_result
  FROM TestTableWithUid2 WHERE id > 1000
);
--
ARRAY<STRUCT<BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL>>[
  {true, true, true, true, true, true, true, true, true}
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the output of a DP algorithm on an empty data set is indeterministic,
# we only test that the `noise_confidence_interval` value.
[name=anonymization_anon_quantiles_int64_explicit_bounds_multi_user_with_report_proto_zero_rows]
[labels=anonymization]
SELECT
  ABS(anon_result[OFFSET(0)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(anon_result[OFFSET(0)].noise_confidence_interval.upper_bound - 10) < 0.01,
  anon_result[OFFSET(0)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(1)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(anon_result[OFFSET(1)].noise_confidence_interval.upper_bound - 10) < 0.01,
  anon_result[OFFSET(1)].noise_confidence_interval.confidence_level = 0.95,
  ABS(anon_result[OFFSET(2)].noise_confidence_interval.lower_bound - 1) < 0.01,
  ABS(anon_result[OFFSET(2)].noise_confidence_interval.upper_bound - 10) < 0.01,
  anon_result[OFFSET(2)].noise_confidence_interval.confidence_level = 0.95,
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
    ANON_QUANTILES(int64_val,
                   3 CLAMPED BETWEEN 1 AND 10 WITH REPORT(FORMAT=PROTO)).values.values AS anon_result
  FROM TestTableWithUid2 WHERE id > 1000
);
--
ARRAY<STRUCT<BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL>>[
  {true, true, true, true, true, true, true, true, true}
]
==

# ANON_QUANTILES with implicit bounds is not yet supported, since the DP
# libraries do not yet support them (see b/205277450).
# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the output of a DP algorithm on an empty data set is indeterministic,
# we only test that the `noise_confidence_interval` value.
[name=anonymization_anon_quantiles_double_implicit_bounds_multi_user_with_report_proto_zero_rows]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_QUANTILES(double_val, 3 WITH REPORT(FORMAT=PROTO))
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::invalid_argument: No matching signature for aggregate operator ANON_QUANTILES for argument types: DOUBLE, INT64. Supported signatures: ANON_QUANTILES(DOUBLE, INT64 CLAMPED BETWEEN DOUBLE AND DOUBLE WITH REPORT(FORMAT=PROTO)) [at 2:3]
  ANON_QUANTILES(double_val, 3 WITH REPORT(FORMAT=PROTO))
  ^
==

# ANON_QUANTILES with implicit bounds is not yet supported, since the DP
# libraries do not yet support them (see b/205277450).
# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the output of a DP algorithm on an empty data set is indeterministic,
# we only test that the `noise_confidence_interval` value.
[name=anonymization_anon_quantiles_int64_implicit_bounds_multi_user_with_report_proto_zero_rows]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_QUANTILES(int64_val, 3 WITH REPORT(FORMAT=PROTO))
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::invalid_argument: No matching signature for aggregate operator ANON_QUANTILES for argument types: INT64, INT64. Supported signatures: ANON_QUANTILES(DOUBLE, INT64 CLAMPED BETWEEN DOUBLE AND DOUBLE WITH REPORT(FORMAT=PROTO)) [at 2:3]
  ANON_QUANTILES(int64_val, 3 WITH REPORT(FORMAT=PROTO))
  ^
==

# NOTE: To have a more robust floating point comparison, instead of:
#       F(x) -> expect y, we do |F(x) - y| < 0.01 -> expect True.
[required_features=ANONYMIZATION,JSON_ARRAY_FUNCTIONS,JSON_TYPE,JSON_VALUE_EXTRACTION_FUNCTIONS]
[name=anonymization_anon_quantiles_double_explicit_bounds_multi_user_with_report_json]
[labels=anonymization]
SELECT
  ABS(DOUBLE(anon_result[OFFSET(0)].value) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(0)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(0)].noise_confidence_interval.upper_bound) - 1) < 0.01,
  DOUBLE(anon_result[OFFSET(0)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(1)].value) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(1)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(1)].noise_confidence_interval.upper_bound) - 1) < 0.01,
  DOUBLE(anon_result[OFFSET(1)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(2)].value) - 1.5) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(2)].noise_confidence_interval.lower_bound) - 1.5) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(2)].noise_confidence_interval.upper_bound) - 1.5) < 0.01,
  DOUBLE(anon_result[OFFSET(2)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(3)].value) - 1.5) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(3)].noise_confidence_interval.lower_bound) - 1.5) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(3)].noise_confidence_interval.upper_bound) - 1.5) < 0.01,
  DOUBLE(anon_result[OFFSET(3)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(4)].value) - 2.5) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(4)].noise_confidence_interval.lower_bound) - 2.5) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(4)].noise_confidence_interval.upper_bound) - 2.5) < 0.01,
  DOUBLE(anon_result[OFFSET(4)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(5)].value) - 2.5) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(5)].noise_confidence_interval.lower_bound) - 2.5) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(5)].noise_confidence_interval.upper_bound) - 2.5) < 0.01,
  DOUBLE(anon_result[OFFSET(5)].noise_confidence_interval.confidence_level) = 0.95,
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
    JSON_QUERY_ARRAY(ANON_QUANTILES(double_val,
                     5 CLAMPED BETWEEN 1 AND 3 WITH REPORT(FORMAT=JSON)).result) AS anon_result
  FROM TestTableWithUid2
);
--
ARRAY<STRUCT<BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL>>
[{true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true}]
==

[required_features=ANONYMIZATION,JSON_ARRAY_FUNCTIONS,JSON_TYPE,JSON_VALUE_EXTRACTION_FUNCTIONS]
[name=anonymization_anon_quantiles_int64_explicit_bounds_multi_user_with_report_json]
[labels=anonymization]
SELECT
  ABS(DOUBLE(anon_result[OFFSET(0)].value) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(0)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(0)].noise_confidence_interval.upper_bound) - 1) < 0.01,
  DOUBLE(anon_result[OFFSET(0)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(1)].value) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(1)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(1)].noise_confidence_interval.upper_bound) - 1) < 0.01,
  DOUBLE(anon_result[OFFSET(1)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(2)].value) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(2)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(2)].noise_confidence_interval.upper_bound) - 1) < 0.01,
  DOUBLE(anon_result[OFFSET(2)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(3)].value) - 2) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(3)].noise_confidence_interval.lower_bound) - 2) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(3)].noise_confidence_interval.upper_bound) - 2) < 0.01,
  DOUBLE(anon_result[OFFSET(3)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(4)].value) - 2) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(4)].noise_confidence_interval.lower_bound) - 2) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(4)].noise_confidence_interval.upper_bound) - 2) < 0.01,
  DOUBLE(anon_result[OFFSET(4)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(5)].value) - 3) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(5)].noise_confidence_interval.lower_bound) - 3) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(5)].noise_confidence_interval.upper_bound) - 3) < 0.01,
  DOUBLE(anon_result[OFFSET(5)].noise_confidence_interval.confidence_level) = 0.95,
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
    JSON_QUERY_ARRAY(ANON_QUANTILES(int64_val,
                     5 CLAMPED BETWEEN 1 AND 3 WITH REPORT(FORMAT=JSON)).result) AS anon_result
  FROM TestTableWithUid2
);
--
ARRAY<STRUCT<BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL,
             BOOL>>
[{true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true,
  true}]
==

# ANON_QUANTILES with implicit bounds is not yet supported, since the DP
# libraries do not yet support them (see b/205277450).
[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_anon_quantiles_double_implicit_bounds_multi_user_with_report_json]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_QUANTILES(double_val, 5 WITH REPORT(FORMAT=JSON))
FROM TestTableWithUid2;
--
ERROR: generic::invalid_argument: No matching signature for aggregate operator ANON_QUANTILES for argument types: DOUBLE, INT64. Supported signatures: ANON_QUANTILES(DOUBLE, INT64 CLAMPED BETWEEN DOUBLE AND DOUBLE WITH REPORT(FORMAT=JSON)) [at 2:3]
  ANON_QUANTILES(double_val, 5 WITH REPORT(FORMAT=JSON))
  ^
==

# ANON_QUANTILES with implicit bounds is not yet supported, since the DP
# libraries do not yet support them (see b/205277450).
[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_anon_quantiles_int64_implicit_bounds_multi_user_with_report_JSON]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_QUANTILES(int64_val, 5 WITH REPORT(FORMAT=JSON))
FROM TestTableWithUid2;
--
ERROR: generic::invalid_argument: No matching signature for aggregate operator ANON_QUANTILES for argument types: INT64, INT64. Supported signatures: ANON_QUANTILES(DOUBLE, INT64 CLAMPED BETWEEN DOUBLE AND DOUBLE WITH REPORT(FORMAT=JSON)) [at 2:3]
  ANON_QUANTILES(int64_val, 5 WITH REPORT(FORMAT=JSON))
  ^
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the output of a DP algorithm on an empty data set is indeterministic,
# we only test that the `noise_confidence_interval` value.
[required_features=ANONYMIZATION,JSON_ARRAY_FUNCTIONS,JSON_TYPE,JSON_VALUE_EXTRACTION_FUNCTIONS]
[name=anonymization_anon_quantiles_double_explicit_bounds_multi_user_with_report_json_zero_rows]
[labels=anonymization]
SELECT
  ABS(DOUBLE(anon_result[OFFSET(0)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(0)].noise_confidence_interval.upper_bound) - 10) < 0.01,
  DOUBLE(anon_result[OFFSET(0)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(1)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(1)].noise_confidence_interval.upper_bound) - 10) < 0.01,
  DOUBLE(anon_result[OFFSET(1)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(2)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(2)].noise_confidence_interval.upper_bound) - 10) < 0.01,
  DOUBLE(anon_result[OFFSET(2)].noise_confidence_interval.confidence_level) = 0.95,
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
    JSON_QUERY_ARRAY(ANON_QUANTILES(double_val,
                   3 CLAMPED BETWEEN 1 AND 10 WITH REPORT(FORMAT=JSON)).result) AS anon_result
  FROM TestTableWithUid2 WHERE id > 1000
);
--
ARRAY<STRUCT<BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL>>[
  {true, true, true, true, true, true, true, true, true}
]
==

# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the output of a DP algorithm on an empty data set is indeterministic,
# we only test that the `noise_confidence_interval` value.
[required_features=ANONYMIZATION,JSON_ARRAY_FUNCTIONS,JSON_TYPE,JSON_VALUE_EXTRACTION_FUNCTIONS]
[name=anonymization_anon_quantiles_int64_explicit_bounds_multi_user_with_report_json_zero_rows]
[labels=anonymization]
SELECT
  ABS(DOUBLE(anon_result[OFFSET(0)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(0)].noise_confidence_interval.upper_bound) - 10) < 0.01,
  DOUBLE(anon_result[OFFSET(0)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(1)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(1)].noise_confidence_interval.upper_bound) - 10) < 0.01,
  DOUBLE(anon_result[OFFSET(1)].noise_confidence_interval.confidence_level) = 0.95,
  ABS(DOUBLE(anon_result[OFFSET(2)].noise_confidence_interval.lower_bound) - 1) < 0.01,
  ABS(DOUBLE(anon_result[OFFSET(2)].noise_confidence_interval.upper_bound) - 10) < 0.01,
  DOUBLE(anon_result[OFFSET(2)].noise_confidence_interval.confidence_level) = 0.95,
FROM (
  SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
    JSON_QUERY_ARRAY(ANON_QUANTILES(int64_val,
                   3 CLAMPED BETWEEN 1 AND 10 WITH REPORT(FORMAT=JSON)).result) AS anon_result
  FROM TestTableWithUid2 WHERE id > 1000
);
--
ARRAY<STRUCT<BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL, BOOL>>[
  {true, true, true, true, true, true, true, true, true}
]
==

# ANON_QUANTILES with implicit bounds is not yet supported, since the DP
# libraries do not yet support them (see b/205277450).
# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the output of a DP algorithm on an empty data set is indeterministic,
# we only test that the `noise_confidence_interval` value.
[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_anon_quantiles_double_implicit_bounds_multi_user_with_report_json_zero_rows]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_QUANTILES(double_val, 3 WITH REPORT(FORMAT=JSON))
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::invalid_argument: No matching signature for aggregate operator ANON_QUANTILES for argument types: DOUBLE, INT64. Supported signatures: ANON_QUANTILES(DOUBLE, INT64 CLAMPED BETWEEN DOUBLE AND DOUBLE WITH REPORT(FORMAT=JSON)) [at 2:3]
  ANON_QUANTILES(double_val, 3 WITH REPORT(FORMAT=JSON))
  ^
==

# ANON_QUANTILES with implicit bounds is not yet supported, since the DP
# libraries do not yet support them (see b/205277450).
# Test 0 rows as inputs by a filter "WHERE id > 1000" with a CLAMPED clause.
# Because the output of a DP algorithm on an empty data set is indeterministic,
# we only test that the `noise_confidence_interval` value.
[required_features=JSON_TYPE,ANONYMIZATION]
[name=anonymization_anon_quantiles_int64_implicit_bounds_multi_user_with_report_json_zero_rows]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_QUANTILES(int64_val, 3 WITH REPORT(FORMAT=JSON))
FROM TestTableWithUid2 WHERE id > 1000;
--
ERROR: generic::invalid_argument: No matching signature for aggregate operator ANON_QUANTILES for argument types: INT64, INT64. Supported signatures: ANON_QUANTILES(DOUBLE, INT64 CLAMPED BETWEEN DOUBLE AND DOUBLE WITH REPORT(FORMAT=JSON)) [at 2:3]
  ANON_QUANTILES(int64_val, 3 WITH REPORT(FORMAT=JSON))
  ^
==

[name=anonymization_count_unique_users_with_report_json_with_thresholding]
[required_features=JSON_TYPE,ANONYMIZATION,JSON_VALUE_EXTRACTION_FUNCTIONS,ANONYMIZATION_THRESHOLDING]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(* CLAMPED BETWEEN 0 AND 1 with REPORT(format=JSON))
FROM TestTableWithUid;
--
ARRAY<STRUCT<JSON>>[
  {
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-2.99573227355399e-20,"upper_bound":2.99573227355399e-20},"value":10}}
  }
]
==

[name=anonymization_count_unique_users_with_report_json_without_thresholding]
[required_features=JSON_TYPE,ANONYMIZATION]
[forbidden_features=ANONYMIZATION_THRESHOLDING]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(* CLAMPED BETWEEN 0 AND 1 with REPORT(format=JSON))
FROM TestTableWithUid;
--
ARRAY<STRUCT<JSON>>[
  {
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-5.99146454710798e-20,"upper_bound":5.99146454710798e-20},"value":10}}
  }
]
==

[name=anonymization_count_unique_users_with_report_proto_with_thresholding]
[required_features=ANONYMIZATION,ANONYMIZATION_THRESHOLDING]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(* CLAMPED BETWEEN 0 AND 1 with REPORT(format=PROTO))
FROM TestTableWithUid;
--
ARRAY<STRUCT<PROTO<zetasql.AnonOutputWithReport>>>[
  {{
     value {
       int_value: 10
       noise_confidence_interval {
         lower_bound: -2.99573227355399e-20
         upper_bound: 2.99573227355399e-20
         confidence_level: 0.95
       }
     }
   }}
]
==

[name=anonymization_count_unique_users_with_report_proto_without_thresholding]
[required_features=ANONYMIZATION]
[forbidden_features=ANONYMIZATION_THRESHOLDING]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0)
  ANON_COUNT(* CLAMPED BETWEEN 0 AND 1 with REPORT(format=PROTO))
FROM TestTableWithUid;
--
ARRAY<STRUCT<PROTO<zetasql.AnonOutputWithReport>>>[
  {{
     value {
       int_value: 10
       noise_confidence_interval {
         lower_bound: -5.99146454710798e-20
         upper_bound: 5.99146454710798e-20
         confidence_level: 0.95
       }
     }
   }}
]
==

# Sum aggregation with max_rows_contributed.
[name=anonymization_max_rows_contributed_sum]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_MAX_ROWS_CONTRIBUTED]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, max_rows_contributed=1)
  ANON_SUM(double_val)
FROM TestTableWithUid
  CROSS JOIN
    UNNEST([1,2,3]) AS x;
--
ARRAY<STRUCT<DOUBLE>>[{11}]

NOTE: Reference implementation reports non-determinism.
==

# Count star aggregation with max_rows_contributed.
[name=anonymization_max_rows_contributed_count_star]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_MAX_ROWS_CONTRIBUTED]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, max_rows_contributed=2)
  ANON_COUNT(*)
FROM TestTableWithUid
  CROSS JOIN
    UNNEST([1,2,3]) AS x;
--
ARRAY<STRUCT<INT64>>[{20}]

NOTE: Reference implementation reports non-determinism.
==

# Count aggregation with max_rows_contributed.
[name=anonymization_max_rows_contributed_count]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_MAX_ROWS_CONTRIBUTED]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, max_rows_contributed=2)
  ANON_COUNT(int64_val)
FROM TestTableWithUid
  CROSS JOIN
    UNNEST([1,2,3]) AS x;
--
ARRAY<STRUCT<INT64>>[{16}]

NOTE: Reference implementation reports non-determinism.
==

# Conditional evaluation with anonymization
[name=aggregate_in_if]
[labels=anonymization,bug_in_reference_impl]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=1)
  IF(ANON_COUNT(*) > 0, ANON_COUNT(*), ANON_COUNT(1/(int64_val-1)))
FROM TestTableWithUid
  CROSS JOIN
     UNNEST([1,2,3]) as x;
--
ARRAY<STRUCT<INT64>>[{30}]
==

# Basic test with group selection strategy LAPLACE_THRESHOLD.
[name=anonymization_group_selection_laplace_with_delta]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, group_selection_strategy=LAPLACE_THRESHOLD)
  ANON_SUM(double_val)
FROM TestTableWithUid2;
--
ARRAY<STRUCT<DOUBLE>>[{11}]
==

# Public groups without group by
[name=anonymization_public_groups_without_group_by]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_PUBLIC_GROUPS,V_1_1_WITH_ON_SUBQUERY]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, group_selection_strategy=PUBLIC_GROUPS)
  ANON_COUNT(int64_val)
FROM TestTableWithUid;
--
ARRAY<STRUCT<INT64>>[{8}]
==

# Public groups with group by
[name=anonymization_public_groups_with_group_by]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_PUBLIC_GROUPS,V_1_1_WITH_ON_SUBQUERY]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, group_selection_strategy=PUBLIC_GROUPS)
  int64_val, ANON_COUNT(* CLAMPED BETWEEN 0 AND 1)
FROM TestTableWithUid
RIGHT OUTER JOIN (
    SELECT DISTINCT int64_val FROM TestTableWithoutUid
  ) using(int64_val)
GROUP BY int64_val;
--
ARRAY<STRUCT<int64_val INT64, INT64>>[unknown order:
  {0, 0},
  {1, 3},
  {3, 1},
  {4, 1},
  {1234, 0}
]
==

# Public groups with group by
[name=anonymization_public_groups_with_group_by_and_max_groups_contributed]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_PUBLIC_GROUPS,V_1_1_WITH_ON_SUBQUERY]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, group_selection_strategy=PUBLIC_GROUPS, max_groups_contributed=3)
  int64_val, ANON_COUNT(* CLAMPED BETWEEN 0 AND 1)
FROM TestTableWithUid
RIGHT OUTER JOIN (
    SELECT DISTINCT int64_val FROM TestTableWithoutUid
  ) using(int64_val)
GROUP BY int64_val;
--
ARRAY<STRUCT<int64_val INT64, INT64>>[unknown order:
  {0, 0},
  {1, 3},
  {3, 1},
  {4, 1},
  {1234, 0}
]

NOTE: Reference implementation reports non-determinism.
==

# If MIN_PRIVACY_UNITS_PER_GROUP=1 and delta = 1.0, then all groups should
# appear in the output. I.e. in the same way as if MIN_PRIVACY_UNITS_PER_GROUP=1
# were omitted. Clamping is such that no actual clamping occurrs.
[name=anonymization_min_privacy_units_per_group_is_one]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, min_privacy_units_per_group=1)
  int64_val, ANON_SUM(double_val CLAMPED BETWEEN -4 AND 4)
FROM TestTableWithUid
GROUP BY int64_val;
--
ARRAY<STRUCT<int64_val INT64, DOUBLE>>[unknown order:
  {1, 4.5},
  {3, 2.5},
  {NULL, 2.5},
  {2, 3},
  {4, -1.5}
]
==

# If MIN_PRIVACY_UNITS_PER_GROUP=2 and delta = 1.0, then groups should appear
# in the output if and only if >= 2 users contribute. For the TestTableWithUid,
# there are 3 `int64_val` with not less than 2 contributions:
# `1`, `NULL` and `2`.
[name=anonymization_min_privacy_units_per_group_is_2]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, min_privacy_units_per_group=2)
  int64_val, ANON_COUNT(uid CLAMPED BETWEEN 0 AND 1)
FROM TestTableWithUid
GROUP BY int64_val;
--

ARRAY<STRUCT<int64_val INT64, INT64>>[unknown order:{1, 3}, {NULL, 2}, {2, 3}]
==

# If MIN_PRIVACY_UNITS_PER_GROUP=3 and delta = 1.0, then groups should appear
# in the output if and only if >= 3 users contribute. Compared to the test above
# the null-group is discarded, since only 2 users contribute.
[name=anonymization_min_privacy_units_per_group_is_3]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, min_privacy_units_per_group=3)
  int64_val, ANON_COUNT(uid CLAMPED BETWEEN 0 AND 1)
FROM TestTableWithUid
GROUP BY int64_val;
--

ARRAY<STRUCT<int64_val INT64, INT64>>[unknown order:{1, 3}, {2, 3}]
==

# This test is the same as the one above, however, now we specify the compatible
# group selection strategy (LAPLACE_THRESHOLDING) directly.
[name=anonymization_min_privacy_units_per_group_and_explicit_laplace_thresholding]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta = 1.0, min_privacy_units_per_group=3, group_selection_strategy=LAPLACE_THRESHOLD)
  int64_val, ANON_COUNT(uid CLAMPED BETWEEN 0 AND 1)
FROM TestTableWithUid
GROUP BY int64_val;
--

ARRAY<STRUCT<int64_val INT64, INT64>>[unknown order:{1, 3}, {2, 3}]
==

# If MIN_PRIVACY_UNITS_PER_GROUP=4 and delta = 1.0, then groups should appear
# in the output if and only if >= 4 users contribute. Since there are no groups
# with more than 3 users in the dataset, the output should be empty.
[name=anonymization_min_privacy_units_per_group_is_4]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, min_privacy_units_per_group=4)
  int64_val, ANON_COUNT(uid CLAMPED BETWEEN 0 AND 1)
FROM TestTableWithUid
GROUP BY int64_val;
--

ARRAY<STRUCT<int64_val INT64, INT64>>[]
==

# An error should be reported if the k_threshold is set simultaneously with
# min_privacy_units_per_group.
[name=anonymization_k_threshold_and_min_privacy_units_per_group_set]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=5, min_privacy_units_per_group=2)
  ANON_SUM(double_val CLAMPED BETWEEN 0 AND 2)
FROM TestTableWithUid
--
ERROR: generic::invalid_argument: The options min_privacy_units_per_group and k_threshold cannot be specified simultaneously. [at 1:34]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, k_threshold=5, min_privacy_un...
                                 ^
==

# An error should be reported if min_privacy_units_per_group is set
# simultaneously with the PUBLIC_GROUPS groups selection strategy.
[name=anonymization_public_groups_and_min_privacy_units_per_group_set]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_PUBLIC_GROUPS,V_1_1_WITH_ON_SUBQUERY,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta = 1.0, min_privacy_units_per_group=2, group_selection_strategy = PUBLIC_GROUPS)
  ANON_SUM(double_val CLAMPED BETWEEN 0 AND 2)
FROM TestTableWithUid
--

ERROR: generic::invalid_argument: The MIN_PRIVACY_UNITS_PER_GROUP option must not be specified if GROUP_SELECTION_STRATEGY=PUBLIC_GROUPS
==

# The min_privacy_units_per_group should work well together with reports of
# type JSON.
[name=anonymization_min_privacy_units_per_group_works_with_json_report]
[required_features=JSON_TYPE,ANONYMIZATION,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP]
[forbidden_features=ANONYMIZATION_THRESHOLDING]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, min_privacy_units_per_group=3)
  int64_val, ANON_COUNT(* CLAMPED BETWEEN 0 AND 1 with REPORT(format=JSON))
FROM TestTableWithUid
GROUP BY int64_val;
--
ARRAY<STRUCT<int64_val INT64, JSON>>[unknown order:
  {
    1,
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-5.99146454710798e-20,"upper_bound":5.99146454710798e-20},"value":3}}
  },
  {
    2,
    {"result":{"noise_confidence_interval":{"confidence_level":0.95,"lower_bound":-5.99146454710798e-20,"upper_bound":5.99146454710798e-20},"value":3}}
  }
]
==

# The min_privacy_units_per_group should work well together with reports of
# type PROTO.
[name=anonymization_min_privacy_units_per_group_works_with_proto_report]
[required_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY_MIN_PRIVACY_UNITS_PER_GROUP]
[forbidden_features=ANONYMIZATION_THRESHOLDING]
[labels=anonymization]
SELECT WITH ANONYMIZATION OPTIONS(epsilon=1e20, delta=1.0, min_privacy_units_per_group=3)
  int64_val, ANON_COUNT(* CLAMPED BETWEEN 0 AND 1 with REPORT(format=PROTO))
FROM TestTableWithUid
GROUP BY int64_val;
--
ARRAY<STRUCT<
        int64_val INT64,
        PROTO<zetasql.AnonOutputWithReport>
      >>
[unknown order:{1,
                {
                  value {
                    int_value: 3
                    noise_confidence_interval {
                      lower_bound: -5.99146454710798e-20
                      upper_bound: 5.99146454710798e-20
                      confidence_level: 0.95
                    }
                  }
                }},
               {2,
                {
                  value {
                    int_value: 3
                    noise_confidence_interval {
                      lower_bound: -5.99146454710798e-20
                      upper_bound: 5.99146454710798e-20
                      confidence_level: 0.95
                    }
                  }
                }}]
