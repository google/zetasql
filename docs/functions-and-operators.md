

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

# Functions, operators, and conditionals

This topic is a compilation of functions, operators, and
conditional expressions.

To learn more about how to call functions, function call rules,
the `SAFE` prefix, and special types of arguments,
see [Function calls][function-calls].

<!-- disableFinding(G3DOC_ATTRIBUTE) -->
---
## OPERATORS AND CONDITIONALS

## Operators

ZetaSQL supports operators.
Operators are represented by special characters or keywords; they don't use
function call syntax. An operator manipulates any number of data inputs, also
called operands, and returns a result.

Common conventions:

+  Unless otherwise specified, all operators return `NULL` when one of the
   operands is `NULL`.
+  All operators will throw an error if the computation result overflows.
+  For all floating point operations, `+/-inf` and `NaN` may only be returned
   if one of the operands is `+/-inf` or `NaN`. In other cases, an error is
   returned.

### Operator precedence

The following table lists all ZetaSQL operators from highest to
lowest precedence, i.e., the order in which they will be evaluated within a
statement.

<table>
  <thead>
    <tr>
      <th>Order of Precedence</th>
      <th>Operator</th>
      <th>Input Data Types</th>
      <th>Name</th>
      <th>Operator Arity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Field access operator</td>
      <td>

<span><code>STRUCT</code></span><br /><span><code>PROTO</code></span><br /><span><code>JSON</code></span><br />
</td>
      <td>Field access operator</td>
      <td>Binary</td>
    </tr>
    
    <tr>
      <td>&nbsp;</td>
      <td>Array elements field access operator</td>
      <td><code>ARRAY</code></td>
      <td>Field access operator for elements in an array</td>
      <td>Binary</td>
    </tr>
    
    <tr>
      <td>&nbsp;</td>
      <td>Array subscript operator</td>
      <td><code>ARRAY</code></td>
      <td>Array position. Must be used with <code>OFFSET</code> or <code>ORDINAL</code>&mdash;see
      <a href="#array_functions">Array Functions</a>
.</td>
      <td>Binary</td>
    </tr>
    
    <tr>
      <td>&nbsp;</td>
      <td>JSON subscript operator</td>
      <td><code>JSON</code></td>
      <td>Field name or array position in JSON.</td>
      <td>Binary</td>
    </tr>
    
    <tr>
      <td>2</td>
      <td><code>+</code></td>
      <td>All numeric types</td>
      <td>Unary plus</td>
      <td>Unary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>-</code></td>
      <td>All numeric types</td>
      <td>Unary minus</td>
      <td>Unary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>~</code></td>
      <td>Integer or <code>BYTES</code></td>
      <td>Bitwise not</td>
      <td>Unary</td>
    </tr>
    <tr>
      <td>3</td>
      <td><code>*</code></td>
      <td>All numeric types</td>
      <td>Multiplication</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>/</code></td>
      <td>All numeric types</td>
      <td>Division</td>
      <td>Binary</td>
    </tr>
    
    <tr>
      <td>&nbsp;</td>
      <td><code>||</code></td>
      <td><code>STRING</code>, <code>BYTES</code>, or <code>ARRAY&#60;T&#62;</code></td>
      <td>Concatenation operator</td>
      <td>Binary</td>
    </tr>
    
    <tr>
      <td>4</td>
      <td><code>+</code></td>
      <td>
        All numeric types, <code>DATE</code> with
        <code>INT64</code>
        , <code>INTERVAL</code>
      </td>
      <td>Addition</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>-</code></td>
      <td>
        All numeric types, <code>DATE</code> with
        <code>INT64</code>
        , <code>INTERVAL</code>
      </td>
      <td>Subtraction</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>5</td>
      <td><code>&lt;&lt;</code></td>
      <td>Integer or <code>BYTES</code></td>
      <td>Bitwise left-shift</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>&gt;&gt;</code></td>
      <td>Integer or <code>BYTES</code></td>
      <td>Bitwise right-shift</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>6</td>
      <td><code>&amp;</code></td>
      <td>Integer or <code>BYTES</code></td>
      <td>Bitwise and</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>7</td>
      <td><code>^</code></td>
      <td>Integer or <code>BYTES</code></td>
      <td>Bitwise xor</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>8</td>
      <td><code>|</code></td>
      <td>Integer or <code>BYTES</code></td>
      <td>Bitwise or</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>9 (Comparison Operators)</td>
      <td><code>=</code></td>
      <td>Any comparable type. See
      <a href="https://github.com/google/zetasql/blob/master/docs/data-types.md">Data Types</a>

      for a complete list.</td>
      <td>Equal</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>&lt;</code></td>
      <td>Any comparable type. See
      <a href="https://github.com/google/zetasql/blob/master/docs/data-types.md">Data Types</a>

      for a complete list.</td>
      <td>Less than</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>&gt;</code></td>
      <td>Any comparable type. See
      <a href="https://github.com/google/zetasql/blob/master/docs/data-types.md">Data Types</a>

      for a complete list.</td>
      <td>Greater than</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>&lt;=</code></td>
      <td>Any comparable type. See
      <a href="https://github.com/google/zetasql/blob/master/docs/data-types.md">Data Types</a>

      for a complete list.</td>
      <td>Less than or equal to</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>&gt;=</code></td>
      <td>Any comparable type. See
      <a href="https://github.com/google/zetasql/blob/master/docs/data-types.md">Data Types</a>

      for a complete list.</td>
      <td>Greater than or equal to</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>!=</code>, <code>&lt;&gt;</code></td>
      <td>Any comparable type. See
      <a href="https://github.com/google/zetasql/blob/master/docs/data-types.md">Data Types</a>

      for a complete list.</td>
      <td>Not equal</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>[NOT] LIKE</code></td>
      <td><code>STRING</code> and <code>BYTES</code></td>
      <td>Value does [not] match the pattern specified</td>
      <td>Binary</td>
    </tr>

  <tr>
    <td>&nbsp;</td>
    <td>Quantified LIKE</td>
    <td><code>STRING</code> and <code>BYTES</code></td>
    <td>
      Checks a search value for matches against several patterns.
    </td>
    <td>Binary</td>
  </tr>

    <tr>
      <td>&nbsp;</td>
      <td><code>[NOT] BETWEEN</code></td>
      <td>Any comparable types. See
      <a href="https://github.com/google/zetasql/blob/master/docs/data-types.md">Data Types</a>

      for a complete list.</td>
      <td>Value is [not] within the range specified</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>[NOT] IN</code></td>
      <td>Any comparable types. See
      <a href="https://github.com/google/zetasql/blob/master/docs/data-types.md">Data Types</a>

      for a complete list.</td>
      <td>Value is [not] in the set of values specified</td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>IS [NOT] NULL</code></td>
      <td>All</td>
      <td>Value is [not] <code>NULL</code></td>
      <td>Unary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>IS [NOT] TRUE</code></td>
      <td><code>BOOL</code></td>
      <td>Value is [not] <code>TRUE</code>.</td>
      <td>Unary</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>IS [NOT] FALSE</code></td>
      <td><code>BOOL</code></td>
      <td>Value is [not] <code>FALSE</code>.</td>
      <td>Unary</td>
    </tr>
    <tr>
      <td>10</td>
      <td><code>NOT</code></td>
      <td><code>BOOL</code></td>
      <td>Logical <code>NOT</code></td>
      <td>Unary</td>
    </tr>
    <tr>
      <td>11</td>
      <td><code>AND</code></td>
      <td><code>BOOL</code></td>
      <td>Logical <code>AND</code></td>
      <td>Binary</td>
    </tr>
    <tr>
      <td>12</td>
      <td><code>OR</code></td>
      <td><code>BOOL</code></td>
      <td>Logical <code>OR</code></td>
      <td>Binary</td>
    </tr>
  </tbody>
</table>

For example, the logical expression:

`x OR y AND z`

is interpreted as:

`( x OR ( y AND z ) )`

Operators with the same precedence are left associative. This means that those
operators are grouped together starting from the left and moving right. For
example, the expression:

`x AND y AND z`

is interpreted as:

`( ( x AND y ) AND z )`

The expression:

`x * y / z`

is interpreted as:

`( ( x * y ) / z )`

All comparison operators have the same priority, but comparison operators
aren't associative. Therefore, parentheses are required to resolve
ambiguity. For example:

`(x < y) IS FALSE`

### Operator list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#field_access_operator">Field access operator</a>
</td>
  <td>Gets the value of a field.</td>
</tr>

<tr>
  <td><a href="#array_subscript_operator">Array subscript operator</a>
</td>
  <td>Gets a value from an array at a specific position.</td>
</tr>

<tr>
  <td><a href="#struct_subscript_operator">Struct subscript operator</a>
</td>
  <td>Gets the value of a field at a selected position in a struct.</td>
</tr>

<tr>
  <td><a href="#json_subscript_operator">JSON subscript operator</a>
</td>
  <td>Gets a value of an array element or field in a JSON expression.</td>
</tr>

<tr>
  <td><a href="#proto_subscript_operator">Protocol buffer map subscript operator</a>
</td>
  <td>Gets the value in a protocol buffer map for a given key.</td>
</tr>

<tr>
  <td><a href="#array_el_field_operator">Array elements field access operator</a>
</td>
  <td>Traverses through the levels of a nested data type inside an array.</td>
</tr>

<tr>
  <td><a href="#arithmetic_operators">Arithmetic operators</a>
</td>
  <td>Performs arithmetic operations.</td>
</tr>

<tr>
  <td><a href="#date_arithmetics_operators">Date arithmetics operators</a>
</td>
  <td>Performs arithmetic operations on dates.</td>
</tr>

<tr>
  <td><a href="#datetime_subtraction">Datetime subtraction</a>
</td>
  <td>Computes the difference between two datetimes as an interval.</td>
</tr>

<tr>
  <td><a href="#interval_arithmetic_operators">Interval arithmetic operators</a>
</td>
  <td>
    Adds an interval to a datetime or subtracts an interval from a datetime.
  </td>
</tr>

<tr>
  <td><a href="#bitwise_operators">Bitwise operators</a>
</td>
  <td>Performs bit manipulation.</td>
</tr>

<tr>
  <td><a href="#logical_operators">Logical operators</a>
</td>
  <td>
    Tests for the truth of some condition and produces <code>TRUE</code>,
    <code>FALSE</code>, or <code>NULL</code>.
  </td>
</tr>

<tr>
  <td><a href="#graph_concatenation_operator">Graph concatenation operator</a>
</td>
  <td>
    Combines multiple graph paths into one and preserves the original order of
    the nodes and edges.
  </td>
</tr>

<tr>
  <td><a href="#graph_logical_operators">Graph logical operators</a>
</td>
  <td>
    Tests for the truth of a condition in a graph and produces either
    <code>TRUE</code> or <code>FALSE</code>.
  </td>
</tr>

<tr>
  <td><a href="#graph_predicates">Graph predicates</a>
</td>
  <td>
    Tests for the truth of a condition for a graph element and produces
    <code>TRUE</code>, <code>FALSE</code>, or <code>NULL</code>.
  </td>
</tr>

<tr>
  <td><a href="#is_destination_predicate"><code>IS DESTINATION</code> predicate</a>
</td>
  <td>In a graph, checks to see if a node is or isn't the destination of an edge.</td>
</tr>

<tr>
  <td><a href="#is_labeled_predicate"><code>IS LABELED</code> predicate</a>
</td>
  <td>In a graph, checks to see if a node or edge label satisfies a label expression.</td>
</tr>

<tr>
  <td><a href="#is_source_predicate"><code>IS SOURCE</code> predicate</a>
</td>
  <td>In a graph, checks to see if a node is or isn't the source of an edge.</td>
</tr>

<tr>
  <td><a href="#property_exists_predicate"><code>PROPERTY_EXISTS</code> predicate</a>
</td>
  <td>In a graph, checks to see if a property exists for an element.</td>
</tr>

<tr>
  <td><a href="#same_predicate"><code>SAME</code> predicate</a>
</td>
  <td>
    In a graph, checks if all graph elements in a list bind to the same node
    or edge.
  </td>
</tr>

<tr>
  <td><a href="#comparison_operators">Comparison operators</a>
</td>
  <td>
    Compares operands and produces the results of the comparison as a
    <code>BOOL</code> value.
  </td>
</tr>

<tr>
  <td><a href="#exists_operator"><code>EXISTS</code> operator</a>
</td>
  <td>Checks if a subquery produces one or more rows.</td>
</tr>

<tr>
  <td><a href="#in_operators"><code>IN</code> operator</a>
</td>
  <td>Checks for an equal value in a set of values.</td>
</tr>

<tr>
  <td><a href="#is_operators"><code>IS</code> operators</a>
</td>
  <td>
    Checks for the truth of a condition and produces either <code>TRUE</code> or
    <code>FALSE</code>.
  </td>
</tr>

<tr>
  <td><a href="#is_distinct"><code>IS DISTINCT FROM</code> operator</a>
</td>
  <td>Checks if values are considered to be distinct from each other.</td>
</tr>

<tr>
  <td><a href="#like_operator"><code>LIKE</code> operator</a>
</td>
  <td>Checks if values are like or not like one another.</td>
</tr>

<tr>
  <td><a href="#like_operator_quantified">Quantified <code>LIKE</code> operator</a>
</td>
  <td>Checks a search value for matches against several patterns.</td>
</tr>

<tr>
  <td><a href="#new_operator"><code>NEW</code> operator</a>
</td>
  <td>Creates a protocol buffer.</td>
</tr>

<tr>
  <td><a href="#concatenation_operator">Concatenation operator</a>
</td>
  <td>Combines multiple values into one.</td>
</tr>

<tr>
  <td><a href="#with_expression"><code>WITH</code> expression</a>
</td>
  <td>Creates variables for re-use and produces a result expression.</td>
</tr>

  </tbody>
</table>

### Field access operator 
<a id="field_access_operator"></a>

```
expression.fieldname[. ...]
```

**Description**

Gets the value of a field. Alternatively known as the dot operator. Can be
used to access nested fields. For example, `expression.fieldname1.fieldname2`.

Input values:

+ `STRUCT`
+ `PROTO`
+ `JSON`
+ `GRAPH_ELEMENT`

Note: If the field to access is within a `STRUCT`, you can use the
[struct subscript operator][struct-subscript-operator] to access the field by
its position within the `STRUCT` instead of by its name. Accessing by
a field by position is useful when fields are un-named or have ambiguous names.

**Return type**

+ For `STRUCT`: SQL data type of `fieldname`. If a field isn't found in
  the struct, an error is thrown.
+ For `PROTO`: SQL data type of `fieldname`. If a field isn't found in
  the protocol buffer, an error is thrown.
+ For `JSON`: `JSON`. If a field isn't found in a JSON value, a SQL `NULL` is
  returned.
+ For `GRAPH_ELEMENT`: SQL data type of `fieldname`. If a field (property)
  isn't found in the graph element, an error is returned.

**Example**

In the following example, the field access operations are `.address` and
`.country`.

```zetasql
SELECT
  STRUCT(
    STRUCT('Yonge Street' AS street, 'Canada' AS country)
      AS address).address.country

/*---------*
 | country |
 +---------+
 | Canada  |
 *---------*/
```

[struct-subscript-operator]: #struct_subscript_operator

[graph-element-type]: https://github.com/google/zetasql/blob/master/docs/graph-data-types.md#graph_element_type

### Array subscript operator 
<a id="array_subscript_operator"></a>

Note: Syntax wrapped in double quotes (`""`) is required.

```
array_expression "[" array_subscript_specifier "]"

array_subscript_specifier:
  { index | position_keyword(index) }

position_keyword:
  { OFFSET | SAFE_OFFSET | ORDINAL | SAFE_ORDINAL }
```

**Description**

Gets a value from an array at a specific position.

Input values:

+ `array_expression`: The input array.
+ `position_keyword(index)`: Determines where the index for the array should
  start and how out-of-range indexes are handled. The index is an integer that
  represents a specific position in the array.
  + `OFFSET(index)`: The index starts at zero. Produces an error if the index is
    out of range. To produce `NULL` instead of an error, use
    `SAFE_OFFSET(index)`. This
    position keyword produces the same result as `index` by itself.
  + `SAFE_OFFSET(index)`: The index starts at
    zero. Returns `NULL` if the index is out of range.
  + `ORDINAL(index)`: The index starts at one.
    Produces an error if the index is out of range.
    To produce `NULL` instead of an error, use `SAFE_ORDINAL(index)`.
  + `SAFE_ORDINAL(index)`: The index starts at
    one. Returns `NULL` if the index is out of range.
+ `index`: An integer that represents a specific position in the array. If used
  by itself without a position keyword, the index starts at zero and produces
  an error if the index is out of range. To produce `NULL` instead of an error,
  use the `SAFE_OFFSET(index)` or `SAFE_ORDINAL(index)` position keyword.

**Return type**

`T` where `array_expression` is `ARRAY<T>`.

**Examples**

In following query, the array subscript operator is used to return values at
specific position in `item_array`. This query also shows what happens when you
reference an index (`6`) in an array that's out of range. If the `SAFE` prefix
is included, `NULL` is returned, otherwise an error is produced.

```zetasql
SELECT
  ["coffee", "tea", "milk"] AS item_array,
  ["coffee", "tea", "milk"][0] AS item_index,
  ["coffee", "tea", "milk"][OFFSET(0)] AS item_offset,
  ["coffee", "tea", "milk"][ORDINAL(1)] AS item_ordinal,
  ["coffee", "tea", "milk"][SAFE_OFFSET(6)] AS item_safe_offset

/*---------------------+------------+-------------+--------------+------------------*
 | item_array          | item_index | item_offset | item_ordinal | item_safe_offset |
 +---------------------+------------+-------------+--------------+------------------+
 | [coffee, tea, milk] | coffee     | coffee      | coffee       | NULL             |
 *----------------------------------+-------------+--------------+------------------*/
```

When you reference an index that's out of range in an array, and a positional
keyword that begins with `SAFE` isn't included, an error is produced.
For example:

```zetasql
-- Error. Array index 6 is out of bounds.
SELECT ["coffee", "tea", "milk"][6] AS item_offset
```

```zetasql
-- Error. Array index 6 is out of bounds.
SELECT ["coffee", "tea", "milk"][OFFSET(6)] AS item_offset
```

### Struct subscript operator 
<a id="struct_subscript_operator"></a>

Note: Syntax wrapped in double quotes (`""`) is required.

```
struct_expression "[" struct_subscript_specifier "]"

struct_subscript_specifier:
  { index | position_keyword(index) }

position_keyword:
  { OFFSET | ORDINAL }
```

**Description**

Gets the value of a field at a selected position in a struct.

**Input types**

+ `struct_expression`: The input struct.
+ `position_keyword(index)`: Determines where the index for the struct should
  start and how out-of-range indexes are handled. The index is an
  integer literal or constant that represents a specific position in the struct.
  + `OFFSET(index)`: The index starts at zero. Produces an error if the index is
    out of range. Produces the same
    result as `index` by itself.
  + `ORDINAL(index)`: The index starts at one. Produces an error if the index
    is out of range.
+ `index`: An integer literal or constant that represents a specific position in
  the struct. If used by itself without a position keyword, the index starts at
  zero and produces an error if the index is out of range.

Note: The struct subscript operator doesn't support `SAFE` positional keywords
at this time.

**Examples**

In following query, the struct subscript operator is used to return values at
specific locations in `item_struct` using position keywords. This query also
shows what happens when you reference an index (`6`) in an struct that's out of
range.

```zetasql
SELECT
  STRUCT<INT64, STRING, BOOL>(23, "tea", FALSE)[0] AS field_index,
  STRUCT<INT64, STRING, BOOL>(23, "tea", FALSE)[OFFSET(0)] AS field_offset,
  STRUCT<INT64, STRING, BOOL>(23, "tea", FALSE)[ORDINAL(1)] AS field_ordinal

/*-------------+--------------+---------------*
 | field_index | field_offset | field_ordinal |
 +-------------+--------------+---------------+
 | 23          | 23           | 23            |
 *-------------+--------------+---------------*/
```

When you reference an index that's out of range in a struct, an error is
produced. For example:

```zetasql
-- Error: Field ordinal 6 is out of bounds in STRUCT
SELECT STRUCT<INT64, STRING, BOOL>(23, "tea", FALSE)[6] AS field_offset
```

```zetasql
-- Error: Field ordinal 6 is out of bounds in STRUCT
SELECT STRUCT<INT64, STRING, BOOL>(23, "tea", FALSE)[OFFSET(6)] AS field_offset
```

### JSON subscript operator 
<a id="json_subscript_operator"></a>

Note: Syntax wrapped in double quotes (`""`) is required.

```
json_expression "[" array_element_id "]"
```

```
json_expression "[" field_name "]"
```

**Description**

Gets a value of an array element or field in a JSON expression. Can be
used to access nested data.

Input values:

+ `JSON expression`: The `JSON` expression that contains an array element or
  field to return.
+ `[array_element_id]`: An `INT64` expression that represents a zero-based index
  in the array. If a negative value is entered, or the value is greater than
  or equal to the size of the array, or the JSON expression doesn't represent
  a JSON array, a SQL `NULL` is returned.
+ `[field_name]`: A `STRING` expression that represents the name of a field in
  JSON. If the field name isn't found, or the JSON expression isn't a
  JSON object, a SQL `NULL` is returned.

**Return type**

`JSON`

**Example**

In the following example:

+ `json_value` is a JSON expression.
+ `.class` is a JSON field access.
+ `.students` is a JSON field access.
+ `[0]` is a JSON subscript expression with an element offset that
  accesses the zeroth element of an array in the JSON value.
+ `['name']` is a JSON subscript expression with a field name that
  accesses a field.

```zetasql
SELECT json_value.class.students[0]['name'] AS first_student
FROM
  UNNEST(
    [
      JSON '{"class" : {"students" : [{"name" : "Jane"}]}}',
      JSON '{"class" : {"students" : []}}',
      JSON '{"class" : {"students" : [{"name" : "John"}, {"name": "Jamie"}]}}'])
    AS json_value;

/*-----------------*
 | first_student   |
 +-----------------+
 | "Jane"          |
 | NULL            |
 | "John"          |
 *-----------------*/
```

### Protocol buffer map subscript operator 
<a id="proto_subscript_operator"></a>

```zetasql
proto_map_field_expression[proto_subscript_specifier]

proto_subscript_specifier:
  key_name | key_keyword(key_name)

key_keyword:
  { KEY | SAFE_KEY }
```

**Description**

Returns the value in a [protocol buffer map][proto-map] for a
given key.

Input values:

+ `proto_map_field_expression`: A protocol buffer map field.
+ `key_keyword(key_name)`: Determines whether to produce `NULL` or
  an error if the key isn't present in the protocol buffer map field.
  + `KEY(key_name)`: Returns an error if the key isn't present in the
    protocol buffer map field.
  + `SAFE_KEY(key_name)`: Returns `NULL` if the key isn't present in the
    protocol buffer map field.
  + `key_name`: When `key_name` is provided without a wrapping keyword,
    it's the same as `KEY(key_name)`.
+ `key_name`: The key in the protocol buffer map field. This operator returns
  `NULL` if the key is `NULL`.

**Return type**

In the input protocol buffer map field, `V` as represented in `map<K,V>`.

**Examples**

To illustrate the use of this function, we use the protocol buffer message
`Item`.

```proto
message Item {
  optional map<string, int64> purchased = 1;
};
```

In the following example, the subscript operator returns the value when the key
is present.

```zetasql
SELECT
  m.purchased[KEY('A')] AS map_value
FROM
  (SELECT AS VALUE CAST("purchased { key: 'A' value: 2 }" AS Item)) AS m;

/*-----------*
 | map_value |
 +-----------+
 | 2         |
 *-----------*/
```

When the key doesn't exist in the map field and you use `KEY`, an error is
produced. For example:

```zetasql
-- ERROR: Key not found in map: 2
SELECT
  m.purchased[KEY('B')] AS value
FROM
  (SELECT AS VALUE CAST("purchased { key: 'A' value: 2 }" AS Item)) AS m;
```

When the key doesn't exist in the map field and you use `SAFE_KEY`,
the subscript operator returns `NULL`. For example:

```zetasql
SELECT
  CAST(m.purchased[SAFE_KEY('B')] AS safe_key_missing
FROM
  (SELECT AS VALUE CAST("purchased { key: 'A' value: 2 }" AS Item)) AS m;

/*------------------*
 | safe_key_missing |
 +------------------+
 | NULL             |
 *------------------*/
```

The subscript operator returns `NULL` when the map field or key is `NULL`.
For example:

```zetasql
SELECT
  CAST(NULL AS Item).purchased[KEY('A')] AS null_map,
  m.purchased[KEY(NULL)] AS null_key
FROM
  (SELECT AS VALUE CAST("purchased { key: 'A' value: 2 }" AS Item)) AS m;

/*-----------------------*
 | null_map  | null_key  |
 +-----------------------+
 | NULL      | NULL      |
 *-----------------------*/
```

When a key is used without `KEY()` or `SAFE_KEY()`, it has the same behavior
as if `KEY()` had been used. For example:

```zetasql
SELECT
  m.purchased['A'] AS map_value
FROM
  (SELECT AS VALUE CAST("purchased { key: 'A' value: 2 }" AS Item)) AS m;

/*-----------*
 | map_value |
 +-----------+
 | 2         |
 *-----------*/
```

[proto-map]: https://developers.google.com/protocol-buffers/docs/proto3#maps

### Array elements field access operator 
<a id="array_el_field_operator"></a>

Note: Syntax wrapped in double quotes (`""`) is required.

```
array_expression.field_or_element[. ...]

field_or_element:
  { fieldname | array_element }

array_element:
  array_fieldname "[" array_subscript_specifier "]"
```

**Description**

The array elements field access operation lets you traverse through the
levels of a nested data type inside an array.

Input values:

+ `array_expression`: An expression that evaluates to an array value.
+ `field_or_element[. ...]`: The field to access. This can also be a position
  in an array-typed field.
+ `fieldname`: The name of the field to access.

  For example, this query returns all values for the `items` field inside of the
  `my_array` array expression:

  ```zetasql
  WITH MyTable AS ( SELECT [STRUCT(['foo', 'bar'] AS items)] AS my_array )
  SELECT FLATTEN(my_array.items)
  FROM MyTable
  ```

  These data types have fields:

<!-- disableFinding(SPACES) -->

  + `STRUCT`
  + `PROTO`
  + `JSON`

<!-- enableFinding(SPACES) -->

+ `array_element`: If the field to access is an array field (`array_field`),
  you can additionally access a specific position in the field
  with the [array subscript operator][array-subscript-operator]
  (`[array_subscript_specifier]`). This operation returns only elements at a
  selected position, rather than all elements, in the array field.

  For example, this query only returns values at position 0 in the `items`
  array field:

  ```zetasql
  WITH MyTable AS ( SELECT [STRUCT(['foo', 'bar'] AS items)] AS my_array )
  SELECT FLATTEN(my_array.items[OFFSET(0)])
  FROM MyTable
  ```

Details:

The array elements field access operation isn't a typical expression
that returns a typed value; it represents a concept outside the type system
and can only be interpreted by the following operations:

+  [`FLATTEN` operation][flatten-operation]: Returns an array. For example:

   ```zetasql
   FLATTEN(my_array.sales.prices)
   ```
+  [`UNNEST` operation][operators-link-to-unnest]: Returns a table.
   `array_expression` must be a path expression.
   Implicitly implements the `FLATTEN` operator.
   For example, these do the same thing:

   ```zetasql
   UNNEST(my_array.sales.prices)
   ```

   ```zetasql
   UNNEST(FLATTEN(my_array.sales.prices))
   ```
+  [`FROM` clause][operators-link-to-from-clause]: Returns a table.
   `array_expression` must be a path expression.
   Implicitly implements the `UNNEST` operator and the `FLATTEN` operator.
   For example, these unnesting operations produce the same values for
   `results`:

   ```zetasql
   SELECT results FROM SalesTable, SalesTable.my_array.sales.prices AS results;
   ```

   ```zetasql
   SELECT results FROM SalesTable, UNNEST(my_array.sales.prices) AS results;
   ```

   ```zetasql
   SELECT results FROM SalesTable, UNNEST(FLATTEN(my_array.sales.prices)) AS results;
   ```

If `NULL` array elements are encountered, they are added to the resulting array.

**Common shapes of this operation**

This operation can take several shapes. The right-most value in
the operation determines what type of array is returned. Here are some example
shapes and a description of what they return:

The following shapes extract the final non-array field from each element of
an array expression and return an array of those non-array field values.

+ `array_expression.non_array_field_1`
+ `array_expression.non_array_field_1.array_field.non_array_field_2`

The following shapes extract the final array field from each element of the
array expression and concatenate the array fields together.
An empty array or a `NULL` array contributes no elements to the resulting array.

+ `array_expression.non_array_field_1.array_field_1`
+ `array_expression.non_array_field_1.array_field_1.non_array_field_2.array_field_2`
+ `array_expression.non_array_field_1.non_array_field_2.array_field_1`

The following shapes extract the final array field from each element of the
array expression at a specific position. Then they return an array of those
extracted elements. An empty array or a `NULL` array contributes no elements
to the resulting array.

+ `array_expression.non_array_field_1.array_field_1[OFFSET(1)]`
+ `array_expression.non_array_field_1.array_field_1[SAFE_OFFSET(1)]`
+ `array_expression.non_array_field_1.non_array_field_2.array_field_1[ORDINAL(2)]`
+ `array_expression.non_array_field_1.non_array_field_2.array_field_1[SAFE_ORDINAL(2)]`

**Return Value**

+ `FLATTEN` of an array element access operation returns an array.
+ `UNNEST` of an array element access operation, whether explicit or implicit,
   returns a table.

**Examples**

The next examples in this section reference a table called `SalesTable`, that
contains a nested struct in an array called `my_array`:

```zetasql
WITH
  SalesTable AS (
    SELECT
      [
        STRUCT(
          [
            STRUCT([25.0, 75.0] AS prices),
            STRUCT([30.0] AS prices)
          ] AS sales
        )
      ] AS my_array
  )
SELECT * FROM SalesTable;

/*----------------------------------------------*
 | my_array                                     |
 +----------------------------------------------+
 | [{[{[25, 75] prices}, {[30] prices}] sales}] |
 *----------------------------------------------*/
```

This is what the array elements field access operator looks like in the
`FLATTEN` operator:

```zetasql
SELECT FLATTEN(my_array.sales.prices) AS all_prices FROM SalesTable;

/*--------------*
 | all_prices   |
 +--------------+
 | [25, 75, 30] |
 *--------------*/
```

This is how you use the array subscript operator to only return values at a
specific index in the `prices` array:

```zetasql
SELECT FLATTEN(my_array.sales.prices[OFFSET(0)]) AS first_prices FROM SalesTable;

/*--------------*
 | first_prices |
 +--------------+
 | [25, 30]     |
 *--------------*/
```

This is an example of an explicit `UNNEST` operation that includes the
array elements field access operator:

```zetasql
SELECT all_prices FROM SalesTable, UNNEST(my_array.sales.prices) AS all_prices

/*------------*
 | all_prices |
 +------------+
 | 25         |
 | 75         |
 | 30         |
 *------------*/
```

This is an example of an implicit `UNNEST` operation that includes the
array elements field access operator:

```zetasql
SELECT all_prices FROM SalesTable, SalesTable.my_array.sales.prices AS all_prices

/*------------*
 | all_prices |
 +------------+
 | 25         |
 | 75         |
 | 30         |
 *------------*/
```

This query produces an error because one of the `prices` arrays doesn't have
an element at index `1` and `OFFSET` is used:

```zetasql
SELECT FLATTEN(my_array.sales.prices[OFFSET(1)]) AS second_prices FROM SalesTable;

-- Error
```

This query is like the previous query, but `SAFE_OFFSET` is used. This
produces a `NULL` value instead of an error.

```zetasql
SELECT FLATTEN(my_array.sales.prices[SAFE_OFFSET(1)]) AS second_prices FROM SalesTable;

/*---------------*
 | second_prices |
 +---------------+
 | [75, NULL]    |
 *---------------*/
```

In this next example, an empty array and a `NULL` field value have been added to
the query. These contribute no elements to the result.

```zetasql
WITH
  SalesTable AS (
    SELECT
      [
        STRUCT(
          [
            STRUCT([25.0, 75.0] AS prices),
            STRUCT([30.0] AS prices),
            STRUCT(ARRAY<DOUBLE>[] AS prices),
            STRUCT(NULL AS prices)
          ] AS sales
        )
      ] AS my_array
  )
SELECT FLATTEN(my_array.sales.prices) AS first_prices FROM SalesTable;

/*--------------*
 | first_prices |
 +--------------+
 | [25, 75, 30] |
 *--------------*/
```

The next examples in this section reference a protocol buffer called
`Album` that looks like this:

```proto
message Album {
  optional string album_name = 1;
  repeated string song = 2;
  oneof group_name {
    string solo = 3;
    string duet = 4;
    string band = 5;
  }
}
```

Nested data is common in protocol buffers that have data within repeated
messages. The following example extracts a flattened array of songs from a
table called `AlbumList` that contains a column called `Album` of type `PROTO`.

```zetasql
WITH
  AlbumList AS (
    SELECT
      [
        NEW Album(
          'One Way' AS album_name,
          ['North', 'South'] AS song,
          'Crossroads' AS band),
        NEW Album(
          'After Hours' AS album_name,
          ['Snow', 'Ice', 'Water'] AS song,
          'Sunbirds' AS band)]
        AS albums_array
  )
SELECT FLATTEN(albums_array.song) AS songs FROM AlbumList

/*------------------------------*
 | songs                        |
 +------------------------------+
 | [North,South,Snow,Ice,Water] |
 *------------------------------*/
```

The following example extracts a flattened array of album names, one album name
per row. The data comes from a table called `AlbumList` that contains a
proto-typed column called `Album`.

```zetasql
WITH
  AlbumList AS (
    SELECT
      [
        (
          SELECT
            NEW Album(
              'One Way' AS album_name,
              ['North', 'South'] AS song,
              'Crossroads' AS band) AS album_col
        ),
        (
          SELECT
            NEW Album(
              'After Hours' AS album_name,
              ['Snow', 'Ice', 'Water'] AS song,
              'Sunbirds' AS band) AS album_col
        )]
        AS albums_array
  )
SELECT names FROM AlbumList, UNNEST(albums_array.album_name) AS names

/*----------------------*
 | names                |
 +----------------------+
 | One Way              |
 | After Hours          |
 *----------------------*/
```

[array-subscript-operator]: #array_subscript_operator

[flatten-operation]: #flatten

[operators-link-to-unnest]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#unnest_operator

[operators-link-to-from-clause]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#from_clause

### Arithmetic operators 
<a id="arithmetic_operators"></a>

All arithmetic operators accept input of numeric type `T`, and the result type
has type `T` unless otherwise indicated in the description below:

<table>
  <thead>
    <tr>
    <th>Name</th>
    <th>Syntax</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Addition</td>
      <td><code>X + Y</code></td>
    </tr>
    <tr>
      <td>Subtraction</td>
      <td><code>X - Y</code></td>
    </tr>
    <tr>
      <td>Multiplication</td>
      <td><code>X * Y</code></td>
    </tr>
    <tr>
      <td>Division</td>
      <td><code>X / Y</code></td>
    </tr>
    <tr>
      <td>Unary Plus</td>
      <td><code>+ X</code></td>
    </tr>
    <tr>
      <td>Unary Minus</td>
      <td><code>- X</code></td>
    </tr>
  </tbody>
</table>

NOTE: Divide by zero operations return an error. To return a different result,
consider the `IEEE_DIVIDE` or `SAFE_DIVIDE` functions.

Result types for Addition and Multiplication:

<table style="font-size:small">

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th><code>INT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>INT64</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT64</code></th><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>NUMERIC</code></th><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>BIGNUMERIC</code></th><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>FLOAT</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>DOUBLE</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

Result types for Subtraction:

<table style="font-size:small">

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th><code>INT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>INT64</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT64</code></th><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>NUMERIC</code></th><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>BIGNUMERIC</code></th><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>FLOAT</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>DOUBLE</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

Result types for Division:

<table style="font-size:small">

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th><code>INT32</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>INT64</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT32</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT64</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>NUMERIC</code></th><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>BIGNUMERIC</code></th><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>FLOAT</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>DOUBLE</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

Result types for Unary Plus:

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>INT32</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>UINT32</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>FLOAT</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

Result types for Unary Minus:

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>INT32</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>FLOAT</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### Date arithmetics operators 
<a id="date_arithmetics_operators"></a>

Operators '+' and '-' can be used for arithmetic operations on dates.

```zetasql
date_expression + int64_expression
int64_expression + date_expression
date_expression - int64_expression
```

**Description**

Adds or subtracts `int64_expression` days to or from `date_expression`. This is
equivalent to `DATE_ADD` or `DATE_SUB` functions, when interval is expressed in
days.

**Return Data Type**

`DATE`

**Example**

```zetasql
SELECT DATE "2020-09-22" + 1 AS day_later, DATE "2020-09-22" - 7 AS week_ago

/*------------+------------*
 | day_later  | week_ago   |
 +------------+------------+
 | 2020-09-23 | 2020-09-15 |
 *------------+------------*/
```

### Datetime subtraction 
<a id="datetime_subtraction"></a>

```zetasql
date_expression - date_expression
timestamp_expression - timestamp_expression
datetime_expression - datetime_expression
```

**Description**

Computes the difference between two datetime values as an interval.

**Return Data Type**

`INTERVAL`

**Example**

```zetasql
SELECT
  DATE "2021-05-20" - DATE "2020-04-19" AS date_diff,
  TIMESTAMP "2021-06-01 12:34:56.789" - TIMESTAMP "2021-05-31 00:00:00" AS time_diff

/*-------------------+------------------------*
 | date_diff         | time_diff              |
 +-------------------+------------------------+
 | 0-0 396 0:0:0     | 0-0 0 36:34:56.789     |
 *-------------------+------------------------*/
```

### Interval arithmetic operators 
<a id="interval_arithmetic_operators"></a>

**Addition and subtraction**

```zetasql
date_expression + interval_expression = DATETIME
date_expression - interval_expression = DATETIME
timestamp_expression + interval_expression = TIMESTAMP
timestamp_expression - interval_expression = TIMESTAMP
datetime_expression + interval_expression = DATETIME
datetime_expression - interval_expression = DATETIME

```

**Description**

Adds an interval to a datetime value or subtracts an interval from a datetime
value.

**Example**

```zetasql
SELECT
  DATE "2021-04-20" + INTERVAL 25 HOUR AS date_plus,
  TIMESTAMP "2021-05-02 00:01:02.345" - INTERVAL 10 SECOND AS time_minus;

/*-------------------------+--------------------------------*
 | date_plus               | time_minus                     |
 +-------------------------+--------------------------------+
 | 2021-04-21 01:00:00     | 2021-05-02 00:00:52.345+00     |
 *-------------------------+--------------------------------*/
```

**Multiplication and division**

```zetasql
interval_expression * integer_expression = INTERVAL
interval_expression / integer_expression = INTERVAL

```

**Description**

Multiplies or divides an interval value by an integer.

**Example**

```zetasql
SELECT
  INTERVAL '1:2:3' HOUR TO SECOND * 10 AS mul1,
  INTERVAL 35 SECOND * 4 AS mul2,
  INTERVAL 10 YEAR / 3 AS div1,
  INTERVAL 1 MONTH / 12 AS div2

/*----------------+--------------+-------------+--------------*
 | mul1           | mul2         | div1        | div2         |
 +----------------+--------------+-------------+--------------+
 | 0-0 0 10:20:30 | 0-0 0 0:2:20 | 3-4 0 0:0:0 | 0-0 2 12:0:0 |
 *----------------+--------------+-------------+--------------*/
```

### Bitwise operators 
<a id="bitwise_operators"></a>

All bitwise operators return the same type
 and the same length as
the first operand.

<table>
<thead>
<tr>
<th>Name</th>
<th>Syntax</th>
<th style="white-space:nowrap">Input Data Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitwise not</td>
<td><code>~ X</code></td>
<td style="white-space:nowrap">Integer or <code>BYTES</code></td>
<td>Performs logical negation on each bit, forming the ones' complement of the
given binary value.</td>
</tr>
<tr>
<td>Bitwise or</td>
<td><code>X | Y</code></td>
<td style="white-space:nowrap">
<code>X</code>: Integer or <code>BYTES</code><br>
<code>Y</code>: Same type as <code>X</code>
</td>
<td>Takes two bit patterns of equal length and performs the logical inclusive
<code>OR</code> operation on each pair of the corresponding bits.

This operator throws an error if <code>X</code> and <code>Y</code> are bytes of
different lengths.

</td>
</tr>
<tr>
<td>Bitwise xor</td>
<td style="white-space:nowrap"><code>X ^ Y</code></td>
<td style="white-space:nowrap">
<code>X</code>: Integer or <code>BYTES</code><br>
<code>Y</code>: Same type as <code>X</code>
</td>
<td>Takes two bit patterns of equal length and performs the
logical exclusive <code>OR</code> operation on each pair of the corresponding
bits.

This operator throws an error if <code>X</code> and <code>Y</code> are bytes of
different lengths.

</td>
</tr>
<tr>
<td>Bitwise and</td>
<td style="white-space:nowrap"><code>X &amp; Y</code></td>
<td style="white-space:nowrap">
<code>X</code>: Integer or <code>BYTES</code><br>
<code>Y</code>: Same type as <code>X</code>
</td>
<td>Takes two bit patterns of equal length and performs the
logical <code>AND</code> operation on each pair of the corresponding bits.

This operator throws an error if <code>X</code> and <code>Y</code> are bytes of
different lengths.

</td>
</tr>
<tr>
<td>Left shift</td>
<td style="white-space:nowrap"><code>X &lt;&lt; Y</code></td>
<td style="white-space:nowrap">
<code>X</code>: Integer or <code>BYTES</code><br>
<code>Y</code>: <code>INT64</code>
</td>
<td>Shifts the first operand <code>X</code> to the left.
This operator returns
<code>0</code> or a byte sequence of <code>b'\x00'</code>
if the second operand <code>Y</code> is greater than or equal to

the bit length of the first operand <code>X</code> (for example, <code>64</code>
if <code>X</code> has the type <code>INT64</code>).

This operator throws an error if <code>Y</code> is negative.</td>
</tr>
<tr>
<td>Right shift</td>
<td style="white-space:nowrap"><code>X &gt;&gt; Y</code></td>
<td style="white-space:nowrap">
<code>X</code>: Integer or <code>BYTES</code><br>
<code>Y</code>: <code>INT64</code></td>
<td>Shifts the first operand <code>X</code> to the right. This operator doesn't
perform sign bit extension with a signed type (i.e., it fills vacant bits on the left
with <code>0</code>). This operator returns
<code>0</code> or a byte sequence of
<code>b'\x00'</code>
if the second operand <code>Y</code> is greater than or equal to

the bit length of the first operand <code>X</code> (for example, <code>64</code>
if <code>X</code> has the type <code>INT64</code>).

This operator throws an error if <code>Y</code> is negative.</td>
</tr>
</tbody>
</table>

### Logical operators 
<a id="logical_operators"></a>

ZetaSQL supports the `AND`, `OR`, and `NOT` logical operators.
Logical operators allow only `BOOL` or `NULL` input
and use [three-valued logic][three-valued-logic]
to produce a result. The result can be `TRUE`, `FALSE`, or `NULL`:

| `x`     | `y`       | `x AND y` | `x OR y` |
| ------- | --------- | --------- | -------- |
| `TRUE`  | `TRUE`    | `TRUE`    | `TRUE`   |
| `TRUE`  | `FALSE`   | `FALSE`   | `TRUE`   |
| `TRUE`  | `NULL`    | `NULL`    | `TRUE`   |
| `FALSE` | `TRUE`    | `FALSE`   | `TRUE`   |
| `FALSE` | `FALSE`   | `FALSE`   | `FALSE`  |
| `FALSE` | `NULL`    | `FALSE`   | `NULL`   |
| `NULL`  | `TRUE`    | `NULL`    | `TRUE`   |
| `NULL`  | `FALSE`   | `FALSE`   | `NULL`   |
| `NULL`  | `NULL`    | `NULL`    | `NULL`   |

| `x`       | `NOT x`   |
| --------- | --------- |
| `TRUE`    | `FALSE`   |
| `FALSE`   | `TRUE`    |
| `NULL`    | `NULL`    |

The order of evaluation of operands to `AND` and `OR` can vary, and evaluation
can be skipped if unnecessary.

**Examples**

The examples in this section reference a table called `entry_table`:

```zetasql
/*-------*
 | entry |
 +-------+
 | a     |
 | b     |
 | c     |
 | NULL  |
 *-------*/
```

```zetasql
SELECT 'a' FROM entry_table WHERE entry = 'a'

-- a => 'a' = 'a' => TRUE
-- b => 'b' = 'a' => FALSE
-- NULL => NULL = 'a' => NULL

/*-------*
 | entry |
 +-------+
 | a     |
 *-------*/
```

```zetasql
SELECT entry FROM entry_table WHERE NOT (entry = 'a')

-- a => NOT('a' = 'a') => NOT(TRUE) => FALSE
-- b => NOT('b' = 'a') => NOT(FALSE) => TRUE
-- NULL => NOT(NULL = 'a') => NOT(NULL) => NULL

/*-------*
 | entry |
 +-------+
 | b     |
 | c     |
 *-------*/
```

```zetasql
SELECT entry FROM entry_table WHERE entry IS NULL

-- a => 'a' IS NULL => FALSE
-- b => 'b' IS NULL => FALSE
-- NULL => NULL IS NULL => TRUE

/*-------*
 | entry |
 +-------+
 | NULL  |
 *-------*/
```

[three-valued-logic]: https://en.wikipedia.org/wiki/Three-valued_logic

### Graph concatenation operator 
<a id="graph_concatenation_operator"></a>

```zetasql
graph_path || graph_path [ || ... ]
```

**Description**

Combines multiple graph paths into one and preserves the original order of the
nodes and edges.

Arguments:

+ `graph_path`: A `GRAPH_PATH` value that represents a graph path to
  concatenate.

**Details**

This operator produces an error if the last node in the first path isn't the
same as the first node in the second path.

```zetasql
-- This successfully produces the concatenated path called `full_path`.
MATCH
  p=(src:Account)-[t1:Transfers]->(mid:Account),
  q=(mid)-[t2:Transfers]->(dst:Account)
LET full_path = p || q
```

```zetasql
-- This produces an error because the first node of the path to be concatenated
-- (mid2) isn't equal to the last node of the previous path (mid1).
MATCH
  p=(src:Account)-[t1:Transfers]->(mid1:Account),
  q=(mid2:Account)-[t2:Transfers]->(dst:Account)
LET full_path = p || q
```

The first node in each subsequent path is removed from the
concatenated path.

```zetasql
-- The concatenated path called `full_path` contains these elements:
-- src, t1, mid, t2, dst.
MATCH
  p=(src:Account)-[t1:Transfers]->(mid:Account),
  q=(mid)-[t2:Transfers]->(dst:Account)
LET full_path = p || q
```

If any `graph_path` is `NULL`, produces `NULL`.

**Example**

In the following query, a path called `p` and `q` are concatenated. Notice that
`mid` is used at the end of the first path and at the beginning of the
second path. Also notice that the duplicate `mid` is removed from the
concatenated path called `full_path`:

```zetasql
GRAPH FinGraph
MATCH
  p=(src:Account)-[t1:Transfers]->(mid:Account),
  q = (mid)-[t2:Transfers]->(dst:Account)
LET full_path = p || q
RETURN
  JSON_QUERY(TO_JSON(full_path)[0], '$.labels') AS element_a,
  JSON_QUERY(TO_JSON(full_path)[1], '$.labels') AS element_b,
  JSON_QUERY(TO_JSON(full_path)[2], '$.labels') AS element_c,
  JSON_QUERY(TO_JSON(full_path)[3], '$.labels') AS element_d,
  JSON_QUERY(TO_JSON(full_path)[4], '$.labels') AS element_e,
  JSON_QUERY(TO_JSON(full_path)[5], '$.labels') AS element_f

/*-------------------------------------------------------------------------------------*
 | element_a   | element_b     | element_c   | element_d     | element_e   | element_f |
 +-------------------------------------------------------------------------------------+
 | ["Account"] | ["Transfers"] | ["Account"] | ["Transfers"] | ["Account"] |           |
 | ...         | ...           | ...         | ...           | ...         | ...       |
 *-------------------------------------------------------------------------------------/*
```

The following query produces an error because the last node for `p` must
be the first node for `q`:

```zetasql
-- Error: `mid1` and `mid2` aren't equal.
GRAPH FinGraph
MATCH
  p=(src:Account)-[t1:Transfers]->(mid1:Account),
  q=(mid2:Account)-[t2:Transfers]->(dst:Account)
LET full_path = p || q
RETURN TO_JSON(full_path) AS results
```

The following query produces an error because the path called `p` is `NULL`:

```zetasql
-- Error: a graph path is NULL.
GRAPH FinGraph
MATCH
  p=NULL,
  q=(mid:Account)-[t2:Transfers]->(dst:Account)
LET full_path = p || q
RETURN TO_JSON(full_path) AS results
```

### Graph logical operators 
<a id="graph_logical_operators"></a>

ZetaSQL supports the following logical operators in
[element pattern label expressions][element-pattern-definition]:

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Syntax</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>NOT</code></td>
      <td style="white-space:nowrap"><code>!X</code></td>
      <td>
        Returns <code>TRUE</code> if <code>X</code> isn't included, otherwise,
        returns <code>FALSE</code>.
      </td>
    </tr>
    <tr>
      <td><code>OR</code></td>
      <td style="white-space:nowrap"><code>X | Y</code></td>
      <td>
        Returns <code>TRUE</code> if either <code>X</code> or <code>Y</code> is
        included, otherwise, returns <code>FALSE</code>.
      </td>
    </tr>
    <tr>
      <td><code>AND</code></td>
      <td style="white-space:nowrap"><code>X & Y</code></td>
      <td>
        Returns <code>TRUE</code> if both <code>X</code> and <code>Y</code> are
        included, otherwise, returns <code>FALSE</code>.
      </td>
    </tr>
  </tbody>
</table>

[element-pattern-definition]: https://github.com/google/zetasql/blob/master/docs/graph-patterns.md#element_pattern_definition

### Graph predicates 
<a id="graph_predicates"></a>

ZetaSQL supports the following graph-specific predicates in
graph expressions. A predicate can produce `TRUE`, `FALSE`, or `NULL`.

+   [`PROPERTY_EXISTS` predicate][property-exists-predicate]
+   [`IS SOURCE` predicate][is-source-predicate]
+   [`IS DESTINATION` predicate][is-destination-predicate]
+   [`IS LABELED` predicate][is-labeled-predicate]
+   [`SAME` predicate][same-predicate]

[all-different-predicate]: #all_different_predicate

[property-exists-predicate]: #property_exists_predicate

[is-source-predicate]: #is_source_predicate

[is-destination-predicate]: #is_destination_predicate

[is-labeled-predicate]: #is_labeled_predicate

[same-predicate]: #same_predicate

### `IS DESTINATION` predicate 
<a id="is_destination_predicate"></a>

```zetasql
node IS [ NOT ] DESTINATION [ OF ] edge
```

**Description**

In a graph, checks to see if a node is or isn't the destination of an edge.
Can produce `TRUE`, `FALSE`, or `NULL`.

Arguments:

+ `node`: The graph pattern variable for the node element.
+ `edge`: The graph pattern variable for the edge element.

**Examples**

```zetasql
GRAPH FinGraph
MATCH (a:Account)-[transfer:Transfers]-(b:Account)
WHERE a IS DESTINATION of transfer
RETURN a.id AS a_id, b.id AS b_id

/*-------------+
 | a_id | b_id |
 +-------------+
 | 16   | 7    |
 | 16   | 7    |
 | 20   | 16   |
 | 7    | 20   |
 | 16   | 20   |
 +-------------*/
```

```zetasql
GRAPH FinGraph
MATCH (a:Account)-[transfer:Transfers]-(b:Account)
WHERE b IS DESTINATION of transfer
RETURN a.id AS a_id, b.id AS b_id

/*-------------+
 | a_id | b_id |
 +-------------+
 | 7    | 16   |
 | 7    | 16   |
 | 16   | 20   |
 | 20   | 7    |
 | 20   | 16   |
 +-------------*/
```

### `IS LABELED` predicate 
<a id="is_labeled_predicate"></a>

```zetasql
element IS [ NOT ] LABELED label_expression
```

**Description**

In a graph, checks to see if a node or edge label satisfies a label
expression. Can produce `TRUE`, `FALSE`, or `NULL` if `element` is `NULL`.

Arguments:

+   `element`: The graph pattern variable for a graph node or edge element.
+   `label_expression`: The label expression to verify. For more information,
     see [Label expression definition][label-expression-definition].

**Examples**

```zetasql
GRAPH FinGraph
MATCH (a)
WHERE a IS LABELED Account | Person
RETURN a.id AS a_id, LABELS(a) AS labels

/*----------------+
 | a_id | labels  |
 +----------------+
 | 1    | Person  |
 | 2    | Person  |
 | 3    | Person  |
 | 7    | Account |
 | 16   | Account |
 | 20   | Account |
 +----------------*/
```

```zetasql
GRAPH FinGraph
MATCH (a)-[e]-(b:Account)
WHERE e IS LABELED Transfers | Owns
RETURN a.Id as a_id, Labels(e) AS labels, b.Id as b_id
ORDER BY a_id, b_id

/*------+-----------------------+------+
 | a_id | labels                | b_id |
 +------+-----------------------+------+
 |    1 | [owns]                |    7 |
 |    2 | [owns]                |   20 |
 |    3 | [owns]                |   16 |
 |    7 | [transfers]           |   16 |
 |    7 | [transfers]           |   16 |
 |    7 | [transfers]           |   20 |
 |   16 | [transfers]           |    7 |
 |   16 | [transfers]           |    7 |
 |   16 | [transfers]           |   20 |
 |   16 | [transfers]           |   20 |
 |   20 | [transfers]           |    7 |
 |   20 | [transfers]           |   16 |
 |   20 | [transfers]           |   16 |
 +------+-----------------------+------*/
```

```zetasql
GRAPH FinGraph
MATCH (a:Account {Id: 7})
OPTIONAL MATCH (a)-[:OWNS]->(b)
RETURN a.Id AS a_id, b.Id AS b_id, b IS LABELED Account AS b_is_account

/*------+-----------------------+
 | a_id | b_id   | b_is_account |
 +------+-----------------------+
 | 7    | NULL   | NULL         |
 +------+-----------------------+*/
```

[label-expression-definition]: https://github.com/google/zetasql/blob/master/docs/graph-patterns.md#label_expression_definition

### `IS SOURCE` predicate 
<a id="is_source_predicate"></a>

```zetasql
node IS [ NOT ] SOURCE [ OF ] edge
```

**Description**

In a graph, checks to see if a node is or isn't the source of an edge.
Can produce `TRUE`, `FALSE`, or `NULL`.

Arguments:

+ `node`: The graph pattern variable for the node element.
+ `edge`: The graph pattern variable for the edge element.

**Examples**

```zetasql
GRAPH FinGraph
MATCH (a:Account)-[transfer:Transfers]-(b:Account)
WHERE a IS SOURCE of transfer
RETURN a.id AS a_id, b.id AS b_id

/*-------------+
 | a_id | b_id |
 +-------------+
 | 20   | 7    |
 | 7    | 16   |
 | 7    | 16   |
 | 20   | 16   |
 | 16   | 20   |
 +-------------*/
```

```zetasql
GRAPH FinGraph
MATCH (a:Account)-[transfer:Transfers]-(b:Account)
WHERE b IS SOURCE of transfer
RETURN a.id AS a_id, b.id AS b_id

/*-------------+
 | a_id | b_id |
 +-------------+
 | 7    | 20   |
 | 16   | 7    |
 | 16   | 7    |
 | 16   | 20   |
 | 20   | 16   |
 +-------------*/
```

### `PROPERTY_EXISTS` predicate 
<a id="property_exists_predicate"></a>

```zetasql
PROPERTY_EXISTS(element, element_property)
```

**Description**

In a graph, checks to see if a property exists for an element.
Can produce `TRUE`, `FALSE`, or `NULL`.

Arguments:

+ `element`: The graph pattern variable for a node or edge element.
+ `element_property`: The name of the property to look for in `element`.
  The property name must refer to a property in the graph. If the property
  doesn't exist in the graph, an error is produced. The property name is
  resolved in a case-insensitive manner.

**Example**

```zetasql
GRAPH FinGraph
MATCH (n:Person|Account WHERE PROPERTY_EXISTS(n, name))
RETURN n.name

/*------+
 | name |
 +------+
 | Alex |
 | Dana |
 | Lee  |
 +------*/
```

### `SAME` predicate 
<a id="same_predicate"></a>

```zetasql
SAME (element, element[, ...])
```

**Description**

In a graph, checks if all graph elements in a list bind to the same node or
edge. Returns `TRUE` if the elements bind to the same node or edge, otherwise
`FALSE`.

Arguments:

+ `element`: The graph pattern variable for a node or edge element.

**Details**

Produces an error if `element` is `NULL`.

**Example**

The following query checks to see if `a` and `b` aren't the same person.

```zetasql
GRAPH FinGraph
MATCH (src:Account)<-[transfer:Transfers]-(dest:Account)
WHERE NOT SAME(src, dest)
RETURN src.id AS source_id, dest.id AS destination_id

/*----------------------------+
 | source_id | destination_id |
 +----------------------------+
 | 7         | 20             |
 | 16        | 7              |
 | 16        | 7              |
 | 16        | 20             |
 | 20        | 16             |
 +----------------------------*/
```

### Comparison operators 
<a id="comparison_operators"></a>

Compares operands and produces the results of the comparison as a `BOOL`
value. These comparison operators are available:

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Syntax</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Less Than</td>
      <td><code>X &lt; Y</code></td>
      <td>
        Returns <code>TRUE</code> if <code>X</code> is less than <code>Y</code>.
        

This operator supports specifying <a href="https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about">collation</a>.

      </td>
    </tr>
    <tr>
      <td>Less Than or Equal To</td>
      <td><code>X &lt;= Y</code></td>
      <td>
        Returns <code>TRUE</code> if <code>X</code> is less than or equal to
        <code>Y</code>.
        

This operator supports specifying <a href="https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about">collation</a>.

      </td>
    </tr>
    <tr>
      <td>Greater Than</td>
      <td><code>X &gt; Y</code></td>
      <td>
        Returns <code>TRUE</code> if <code>X</code> is greater than
        <code>Y</code>.
        

This operator supports specifying <a href="https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about">collation</a>.

      </td>
    </tr>
    <tr>
      <td>Greater Than or Equal To</td>
      <td><code>X &gt;= Y</code></td>
      <td>
        Returns <code>TRUE</code> if <code>X</code> is greater than or equal to
        <code>Y</code>.
        

This operator supports specifying <a href="https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about">collation</a>.

      </td>
    </tr>
    <tr>
      <td>Equal</td>
      <td><code>X = Y</code></td>
      <td>
        Returns <code>TRUE</code> if <code>X</code> is equal to <code>Y</code>.
        

This operator supports specifying <a href="https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about">collation</a>.

      </td>
    </tr>
    <tr>
      <td>Not Equal</td>
      <td><code>X != Y</code><br><code>X &lt;&gt; Y</code></td>
      <td>
        Returns <code>TRUE</code> if <code>X</code> isn't equal to
        <code>Y</code>.
        

This operator supports specifying <a href="https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about">collation</a>.

      </td>
    </tr>
    <tr>
      <td><code>BETWEEN</code></td>
      <td><code>X [NOT] BETWEEN Y AND Z</code></td>
      <td>
        <p>
          Returns <code>TRUE</code> if <code>X</code> is [not] within the range
          specified. The result of <code>X BETWEEN Y AND Z</code> is equivalent
          to <code>Y &lt;= X AND X &lt;= Z</code> but <code>X</code> is
          evaluated only once in the former.
          

This operator supports specifying <a href="https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about">collation</a>.

        </p>
      </td>
    </tr>
    <tr>
      <td><code>LIKE</code></td>
      <td><code>X [NOT] LIKE Y</code></td>
      <td>
        See the <a href="#like_operator">`LIKE` operator</a>

        for details.
      </td>
    </tr>
    <tr>
      <td><code>IN</code></td>
      <td>Multiple</td>
      <td>
        See the <a href="#in_operator">`IN` operator</a>

        for details.
      </td>
    </tr>
  </tbody>
</table>

The following rules apply to operands in a comparison operator:

+   The operands must be [comparable][data-type-comparable].
+   A comparison operator generally requires both operands to be of the
    same type.
+   If the operands are of different types, and the values of those types can be
    converted to a common type without loss of precision,
    they are generally coerced to that common type for the comparison.
+   A literal operand is generally coerced to the same data type of a
    non-literal operand that's part of the comparison.
+   Comparisons between operands that are signed and unsigned integers is
    allowed.
+   Struct operands support only these comparison operators: equal
    (`=`), not equal (`!=` and `<>`), and `IN`.

The following rules apply when comparing these data types:

+   Floating point:
    All comparisons with `NaN` return `FALSE`,
    except for `!=` and `<>`, which return `TRUE`.
+   `BOOL`: `FALSE` is less than `TRUE`.
+   `STRING`: Strings are compared codepoint-by-codepoint, which means that
    canonically equivalent strings are only guaranteed to compare as equal if
    they have been normalized first.
+   `JSON`: You can't compare JSON, but you can compare
    the values inside of JSON if you convert the values to
    SQL values first. For more information, see
    [`JSON` functions][json-functions].
+   `NULL`: Any operation with a `NULL` input returns `NULL`.
+   `STRUCT`: When testing a struct for equality, it's possible that one or more
    fields are `NULL`. In such cases:

    +   If all non-`NULL` field values are equal, the comparison returns `NULL`.
    +   If any non-`NULL` field values aren't equal, the comparison returns
        `FALSE`.

    The following table demonstrates how `STRUCT` data types are compared when
    they have fields that are `NULL` valued.

    <table>
      <thead>
        <tr>
          <th>Struct1</th>
          <th>Struct2</th>
          <th>Struct1 = Struct2</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>STRUCT(1, NULL)</code></td>
          <td><code>STRUCT(1, NULL)</code></td>
          <td><code>NULL</code></td>
        </tr>
        <tr>
          <td><code>STRUCT(1, NULL)</code></td>
          <td><code>STRUCT(2, NULL)</code></td>
          <td><code>FALSE</code></td>
        </tr>
        <tr>
          <td><code>STRUCT(1,2)</code></td>
          <td><code>STRUCT(1, NULL)</code></td>
          <td><code>NULL</code></td>
        </tr>
      </tbody>
    </table>

[data-type-comparable]: https://github.com/google/zetasql/blob/master/docs/data-types.md#comparable_data_types

[json-functions]: #json_functions

### `EXISTS` operator 
<a id="exists_operator"></a>

```zetasql
EXISTS( subquery )
```

**Description**

Returns `TRUE` if the subquery produces one or more rows. Returns `FALSE` if
the subquery produces zero rows. Never returns `NULL`. To learn more about
how you can use a subquery with `EXISTS`,
see [`EXISTS` subqueries][exists-subqueries].

**Examples**

In this example, the `EXISTS` operator returns `FALSE` because there are no
rows in `Words` where the direction is `south`:

```zetasql
WITH Words AS (
  SELECT 'Intend' as value, 'east' as direction UNION ALL
  SELECT 'Secure', 'north' UNION ALL
  SELECT 'Clarity', 'west'
 )
SELECT EXISTS( SELECT value FROM Words WHERE direction = 'south' ) as result;

/*--------*
 | result |
 +--------+
 | FALSE  |
 *--------*/
```

[exists-subqueries]: https://github.com/google/zetasql/blob/master/docs/subqueries.md#exists_subquery_concepts

### `IN` operator 
<a id="in_operators"></a>

The `IN` operator supports the following syntax:

```zetasql
search_value [NOT] IN value_set

value_set:
  {
    (expression[, ...])
    | (subquery)
    | UNNEST(array_expression)
  }
```

**Description**

Checks for an equal value in a set of values.
[Semantic rules][semantic-rules-in] apply, but in general, `IN` returns `TRUE`
if an equal value is found, `FALSE` if an equal value is excluded, otherwise
`NULL`. `NOT IN` returns `FALSE` if an equal value is found, `TRUE` if an
equal value is excluded, otherwise `NULL`.

+ `search_value`: The expression that's compared to a set of values.
+ `value_set`: One or more values to compare to a search value.
   + `(expression[, ...])`: A list of expressions.
   + `(subquery)`: A [subquery][operators-subqueries] that returns
     a single column. The values in that column are the set of values.
     If no rows are produced, the set of values is empty.
   + `UNNEST(array_expression)`: An [UNNEST operator][operators-link-to-unnest]
      that returns a column of values from an array expression. This is
      equivalent to:

      ```zetasql
      IN (SELECT element FROM UNNEST(array_expression) AS element)
      ```

This operator supports [collation][collation], but these limitations apply:

+ `[NOT] IN UNNEST` doesn't support collation.
+ If collation is used with a list of expressions, there must be at least one
  item in the list.

<a id="semantic_rules_in"></a>

**Semantic rules**

When using the `IN` operator, the following semantics apply in this order:

+ Returns `FALSE` if `value_set` is empty.
+ Returns `NULL` if `search_value` is `NULL`.
+ Returns `TRUE` if `value_set` contains a value equal to `search_value`.
+ Returns `NULL` if `value_set` contains a `NULL`.
+ Returns `FALSE`.

When using the `NOT IN` operator, the following semantics apply in this order:

+ Returns `TRUE` if `value_set` is empty.
+ Returns `NULL` if `search_value` is `NULL`.
+ Returns `FALSE` if `value_set` contains a value equal to `search_value`.
+ Returns `NULL` if `value_set` contains a `NULL`.
+ Returns `TRUE`.

The semantics of:

```
x IN (y, z, ...)
```

are defined as equivalent to:

```
(x = y) OR (x = z) OR ...
```

and the subquery and array forms are defined similarly.

```
x NOT IN ...
```

is equivalent to:

```
NOT(x IN ...)
```

The `UNNEST` form treats an array scan like `UNNEST` in the
[`FROM`][operators-link-to-from-clause] clause:

```
x [NOT] IN UNNEST(<array expression>)
```

This form is often used with array parameters. For example:

```
x IN UNNEST(@array_parameter)
```

See the [Arrays][operators-link-to-filtering-arrays] topic for more information
on how to use this syntax.

`IN` can be used with multi-part keys by using the struct constructor syntax.
For example:

```
(Key1, Key2) IN ( (12,34), (56,78) )
(Key1, Key2) IN ( SELECT (table.a, table.b) FROM table )
```

See the [Struct Type][operators-link-to-struct-type] topic for more information.

**Return Data Type**

`BOOL`

**Examples**

You can use these `WITH` clauses to emulate temporary tables for
`Words` and `Items` in the following examples:

```zetasql
WITH Words AS (
  SELECT 'Intend' as value UNION ALL
  SELECT 'Secure' UNION ALL
  SELECT 'Clarity' UNION ALL
  SELECT 'Peace' UNION ALL
  SELECT 'Intend'
 )
SELECT * FROM Words;

/*----------*
 | value    |
 +----------+
 | Intend   |
 | Secure   |
 | Clarity  |
 | Peace    |
 | Intend   |
 *----------*/
```

```zetasql
WITH
  Items AS (
    SELECT STRUCT('blue' AS color, 'round' AS shape) AS info UNION ALL
    SELECT STRUCT('blue', 'square') UNION ALL
    SELECT STRUCT('red', 'round')
  )
SELECT * FROM Items;

/*----------------------------*
 | info                       |
 +----------------------------+
 | {blue color, round shape}  |
 | {blue color, square shape} |
 | {red color, round shape}   |
 *----------------------------*/
```

Example with `IN` and an expression:

```zetasql
SELECT * FROM Words WHERE value IN ('Intend', 'Secure');

/*----------*
 | value    |
 +----------+
 | Intend   |
 | Secure   |
 | Intend   |
 *----------*/
```

Example with `NOT IN` and an expression:

```zetasql
SELECT * FROM Words WHERE value NOT IN ('Intend');

/*----------*
 | value    |
 +----------+
 | Secure   |
 | Clarity  |
 | Peace    |
 *----------*/
```

Example with `IN`, a scalar subquery, and an expression:

```zetasql
SELECT * FROM Words WHERE value IN ((SELECT 'Intend'), 'Clarity');

/*----------*
 | value    |
 +----------+
 | Intend   |
 | Clarity  |
 | Intend   |
 *----------*/
```

Example with `IN` and an `UNNEST` operation:

```zetasql
SELECT * FROM Words WHERE value IN UNNEST(['Secure', 'Clarity']);

/*----------*
 | value    |
 +----------+
 | Secure   |
 | Clarity  |
 *----------*/
```

Example with `IN` and a struct:

```zetasql
SELECT
  (SELECT AS STRUCT Items.info) as item
FROM
  Items
WHERE (info.shape, info.color) IN (('round', 'blue'));

/*------------------------------------*
 | item                               |
 +------------------------------------+
 | { {blue color, round shape} info } |
 *------------------------------------*/
```

[semantic-rules-in]: #semantic_rules_in

[operators-subqueries]: https://github.com/google/zetasql/blob/master/docs/subqueries.md#about_subqueries

[operators-link-to-unnest]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#unnest_operator

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_funcs

[operators-link-to-from-clause]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#from_clause

[operators-link-to-filtering-arrays]: https://github.com/google/zetasql/blob/master/docs/arrays.md#filtering_arrays

[operators-link-to-struct-type]: https://github.com/google/zetasql/blob/master/docs/data-types.md#struct_type

### `IS` operators 
<a id="is_operators"></a>

IS operators return TRUE or FALSE for the condition they are testing. They never
return `NULL`, even for `NULL` inputs, unlike the `IS_INF` and `IS_NAN`
functions defined in [Mathematical Functions][operators-link-to-math-functions].
If `NOT` is present, the output `BOOL` value is
inverted.

<table>
  <thead>
    <tr>
      <th>Function Syntax</th>
      <th>Input Data Type</th>
      <th>Result Data Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>X IS TRUE</code></td>
      <td><code>BOOL</code></td>
      <td><code>BOOL</code></td>
      <td>
        Evaluates to <code>TRUE</code> if <code>X</code> evaluates to
        <code>TRUE</code>.
        Otherwise, evaluates to <code>FALSE</code>.
      </td>
    </tr>
    <tr>
      <td><code>X IS NOT TRUE</code></td>
      <td><code>BOOL</code></td>
      <td><code>BOOL</code></td>
      <td>
        Evaluates to <code>FALSE</code> if <code>X</code> evaluates to
        <code>TRUE</code>.
        Otherwise, evaluates to <code>TRUE</code>.
      </td>
    </tr>
    <tr>
      <td><code>X IS FALSE</code></td>
      <td><code>BOOL</code></td>
      <td><code>BOOL</code></td>
      <td>
        Evaluates to <code>TRUE</code> if <code>X</code> evaluates to
        <code>FALSE</code>.
        Otherwise, evaluates to <code>FALSE</code>.
      </td>
    </tr>
    <tr>
      <td><code>X IS NOT FALSE</code></td>
      <td><code>BOOL</code></td>
      <td><code>BOOL</code></td>
      <td>
        Evaluates to <code>FALSE</code> if <code>X</code> evaluates to
        <code>FALSE</code>.
        Otherwise, evaluates to <code>TRUE</code>.
      </td>
    </tr>
    <tr>
      <td><code>X IS NULL</code></td>
      <td>Any value type</td>
      <td><code>BOOL</code></td>
      <td>
        Evaluates to <code>TRUE</code> if <code>X</code> evaluates to
        <code>NULL</code>.
        Otherwise evaluates to <code>FALSE</code>.
      </td>
    </tr>
    <tr>
      <td><code>X IS NOT NULL</code></td>
      <td>Any value type</td>
      <td><code>BOOL</code></td>
      <td>
        Evaluates to <code>FALSE</code> if <code>X</code> evaluates to
        <code>NULL</code>.
        Otherwise evaluates to <code>TRUE</code>.
      </td>
    </tr>
    <tr>
      <td><code>X IS UNKNOWN</code></td>
      <td><code>BOOL</code></td>
      <td><code>BOOL</code></td>
      <td>
        Evaluates to <code>TRUE</code> if <code>X</code> evaluates to
        <code>NULL</code>.
        Otherwise evaluates to <code>FALSE</code>.
      </td>
    </tr>
    <tr>
      <td><code>X IS NOT UNKNOWN</code></td>
      <td><code>BOOL</code></td>
      <td><code>BOOL</code></td>
      <td>
        Evaluates to <code>FALSE</code> if <code>X</code> evaluates to
        <code>NULL</code>.
        Otherwise, evaluates to <code>TRUE</code>.
      </td>
    </tr>
  </tbody>
</table>

[operators-link-to-math-functions]: #mathematical_functions

### `IS DISTINCT FROM` operator 
<a id="is_distinct"></a>

```zetasql
expression_1 IS [NOT] DISTINCT FROM expression_2
```

**Description**

`IS DISTINCT FROM` returns `TRUE` if the input values are considered to be
distinct from each other by the [`DISTINCT`][operators-distinct] and
[`GROUP BY`][operators-group-by] clauses. Otherwise, returns `FALSE`.

`a IS DISTINCT FROM b` being `TRUE` is equivalent to:

+ `SELECT COUNT(DISTINCT x) FROM UNNEST([a,b]) x` returning `2`.
+ `SELECT * FROM UNNEST([a,b]) x GROUP BY x` returning 2 rows.

`a IS DISTINCT FROM b` is equivalent to `NOT (a = b)`, except for the
following cases:

+ This operator never returns `NULL` so `NULL` values are considered to be
  distinct from non-`NULL` values, not other `NULL` values.
+ `NaN` values are considered to be distinct from non-`NaN` values, but not
  other `NaN` values.

Input values:

+ `expression_1`: The first value to compare. This can be a groupable data type,
  `NULL` or `NaN`.
+ `expression_2`: The second value to compare. This can be a groupable
  data type, `NULL` or `NaN`.
+ `NOT`: If present, the output `BOOL` value is inverted.

**Return type**

`BOOL`

**Examples**

These return `TRUE`:

```zetasql
SELECT 1 IS DISTINCT FROM 2
```

```zetasql
SELECT 1 IS DISTINCT FROM NULL
```

```zetasql
SELECT 1 IS NOT DISTINCT FROM 1
```

```zetasql
SELECT NULL IS NOT DISTINCT FROM NULL
```

These return `FALSE`:

```zetasql
SELECT NULL IS DISTINCT FROM NULL
```

```zetasql
SELECT 1 IS DISTINCT FROM 1
```

```zetasql
SELECT 1 IS NOT DISTINCT FROM 2
```

```zetasql
SELECT 1 IS NOT DISTINCT FROM NULL
```

[operators-distinct]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#select_distinct

[operators-group-by]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#group_by_clause

### `LIKE` operator 
<a id="like_operator"></a>

```zetasql
expression_1 [NOT] LIKE expression_2
```

**Description**

`LIKE` returns `TRUE` if the string in the first operand `expression_1`
matches a pattern specified by the second operand `expression_2`,
otherwise returns `FALSE`.

`NOT LIKE` returns `TRUE` if the string in the first operand `expression_1`
doesn't match a pattern specified by the second operand `expression_2`,
otherwise returns `FALSE`.

Expressions can contain these characters:

+   A percent sign (`%`) matches any number of characters or bytes.
+   An underscore (`_`) matches a single character or byte.
+   You can escape `\ `, `_`, or `%` using two backslashes. For example,
    `\\% `. If you are using raw strings, only a single backslash is
    required. For example, `r'\%'`.

This operator supports [collation][collation], but caveats apply:

+   Each `%` character in `expression_2` represents an
    _arbitrary string specifier_. An arbitrary string specifier can represent
    any sequence of `0` or more characters.
+   A character in the expression represents itself and is considered a
    _single character specifier_ unless:

    +   The character is a percent sign (`%`).

    +   The character is an underscore (`_`) and the collator isn't `und:ci`.
+   These additional rules apply to the underscore (`_`) character:

    +   If the collator isn't `und:ci`, an error is produced when an underscore
        isn't escaped in `expression_2`.

    +   If the collator isn't `und:ci`, the underscore isn't allowed when the
        operands have collation specified.

    +   Some _compatibility composites_, such as the fi-ligature (``) and the
        telephone sign (``), will produce a match if they are compared to an
        underscore.

    +   A single underscore matches the idea of what a character is, based on
        an approximation known as a [_grapheme cluster_][grapheme-cluster].
+   For a contiguous sequence of single character specifiers, equality
    depends on the collator and its language tags and tailoring.

    +   By default, the `und:ci` collator doesn't fully normalize a string.
        Some canonically equivalent strings are considered unequal for
        both the `=` and `LIKE` operators.

    +   The `LIKE` operator with collation has the same behavior as the `=`
        operator when there are no wildcards in the strings.

    +   Character sequences with secondary or higher-weighted differences are
        considered unequal. This includes accent differences and some
        special cases.

        For example there are three ways to produce German sharp ``:

        +   `\u1E9E`
        +   `\U00DF`
        +   `ss`

        `\u1E9E` and `\U00DF` are considered equal but differ in tertiary.
        They are considered equal with `und:ci` collation but different from
        `ss`, which has secondary differences.

    +   Character sequences with tertiary or lower-weighted differences are
        considered equal. This includes case differences and
        kana subtype differences, which are considered equal.
+   There are [ignorable characters][ignorable-chars] defined in Unicode.
    Ignorable characters are ignored in the pattern matching.

**Return type**

`BOOL`

**Examples**

The following examples illustrate how you can check to see if the string in the
first operand matches a pattern specified by the second operand.

```zetasql
-- Returns TRUE
SELECT 'apple' LIKE 'a%';
```

```zetasql
-- Returns FALSE
SELECT '%a' LIKE 'apple';
```

```zetasql
-- Returns FALSE
SELECT 'apple' NOT LIKE 'a%';
```

```zetasql
-- Returns TRUE
SELECT '%a' NOT LIKE 'apple';
```

```zetasql
-- Produces an error
SELECT NULL LIKE 'a%';
```

```zetasql
-- Produces an error
SELECT 'apple' LIKE NULL;
```

The following example illustrates how to search multiple patterns in an array
to find a match with the `LIKE` operator:

```zetasql
WITH Words AS
 (SELECT 'Intend with clarity.' as value UNION ALL
  SELECT 'Secure with intention.' UNION ALL
  SELECT 'Clarity and security.')
SELECT value
FROM Words
WHERE ARRAY_INCLUDES(['%ity%', '%and%'], pattern->(Words.value LIKE pattern));

/*------------------------+
 | value                  |
 +------------------------+
 | Intend with clarity.   |
 | Clarity and security.  |
 +------------------------*/
```

The following examples illustrate how collation can be used with the `LIKE`
operator.

```zetasql
-- Returns FALSE
'Foo' LIKE '%foo%'
```

```zetasql
-- Returns TRUE
COLLATE('Foo', 'und:ci') LIKE COLLATE('%foo%', 'und:ci');
```

```zetasql
-- Returns TRUE
COLLATE('Foo', 'und:ci') = COLLATE('foo', 'und:ci');
```

```zetasql
-- Produces an error
COLLATE('Foo', 'und:ci') LIKE COLLATE('%foo%', 'binary');
```

```zetasql
-- Produces an error
COLLATE('Foo', 'und:ci') LIKE COLLATE('%f_o%', 'und:ci');
```

```zetasql
-- Returns TRUE
COLLATE('Foo_', 'und:ci') LIKE COLLATE('%foo\\_%', 'und:ci');
```

There are two capital forms of ``. We can use either `SS` or `` as upper
case. While the difference between `` and `` is case difference (tertiary
difference), the difference between sharp `s` and `ss` is secondary and
considered not equal using the `und:ci` collator. For example:

```zetasql
-- Returns FALSE
'MASSE' LIKE 'Mae';
```

```zetasql
-- Returns FALSE
COLLATE('MASSE', 'und:ci') LIKE '%Mae%';
```

```zetasql
-- Returns FALSE
COLLATE('MASSE', 'und:ci') = COLLATE('Mae', 'und:ci');
```

The kana differences in Japanese are considered as tertiary or quaternary
differences, and should be considered as equal in the `und:ci` collator with
secondary strength.

+ `'\u3042'` is `''` (hiragana)
+ `'\u30A2'` is `''` (katakana)

For example:

```zetasql
-- Returns FALSE
'\u3042' LIKE '%\u30A2%';
```

```zetasql
-- Returns TRUE
COLLATE('\u3042', 'und:ci') LIKE COLLATE('%\u30A2%', 'und:ci');
```

```zetasql
-- Returns TRUE
COLLATE('\u3042', 'und:ci') = COLLATE('\u30A2', 'und:ci');
```

When comparing two strings, the `und:ci` collator compares the collation units
based on the specification of the collation. Even though the number of
code points is different, the two strings are considered equal when the
collation units are considered the same.

+ `'\u0041\u030A'` is `'A'` (two code points)
+ `'\u0061\u030A'` is `'a'` (two code points)
+ `'\u00C5'` is `''` (one code point)

In the following examples, the difference between `'\u0061\u030A'` and
`'\u00C5'` is tertiary.

```zetasql
-- Returns FALSE
'\u0061\u030A' LIKE '%\u00C5%';
```

```zetasql
-- Returns TRUE
COLLATE('\u0061\u030A', 'und:ci') LIKE '%\u00C5%';
```

```zetasql
-- Returns TRUE
COLLATE('\u0061\u030A', 'und:ci') = COLLATE('\u00C5', 'und:ci');
```

In the following example, `'\u0083'` is a `NO BREAK HERE` character and
is ignored.

```zetasql
-- Returns FALSE
'\u0083' LIKE '';
```

```zetasql
-- Returns TRUE
COLLATE('\u0083', 'und:ci') LIKE '';
```

[ignorable-chars]: https://www.unicode.org/charts/collation/chart_Ignored.html

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_funcs

[grapheme-cluster]: https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries

### Quantified `LIKE` operator 
<a id="like_operator_quantified"></a>

The quantified `LIKE` operator supports the following syntax:

```zetasql
search_value [NOT] LIKE quantifier patterns

quantifier:
 { ANY | SOME | ALL }

patterns:
  {
    pattern_expression_list
    | pattern_subquery
    | pattern_array
  }

pattern_expression_list:
  (expression[, ...])

pattern_subquery:
  (subquery)

pattern_array:
  UNNEST(array_expression)
```

**Description**

Checks `search_value` for matches against several patterns. Each comparison is
case-sensitive. Wildcard searches are supported.
[Semantic rules][semantic-rules-quant-like] apply, but in general, `LIKE`
returns `TRUE` if a matching pattern is found, `FALSE` if a matching pattern
isn't found, or otherwise `NULL`. `NOT LIKE` returns `FALSE` if a
matching pattern is found, `TRUE` if a matching pattern isn't found, or
otherwise `NULL`.

+ `search_value`: The value to search for matching patterns. This value can be a
  `STRING` or `BYTES` type.
+ `patterns`: The patterns to look for in the search value. Each pattern must
  resolve to the same type as `search_value`.

  + `pattern_expression_list`: A list of one or more patterns that match the
    `search_value` type.

  + `pattern_subquery`: A [subquery][operators-subqueries] that returns
    a single column with the same type as `search_value`.

  + `pattern_array`: An [`UNNEST`][operators-link-to-unnest]
    operation that returns a column of values with
    the same type as `search_value` from an array expression.

  The regular expressions that are supported by the
  [`LIKE` operator][like-operator] are also supported by `patterns` in the
  [quantified `LIKE` operator][like-operator].
+ `quantifier`: Condition for pattern matching.

  + `ANY`: Checks if the set of patterns contains at least one pattern that
    matches the search value.

  + `SOME`: Synonym for `ANY`.

  + `ALL`: Checks if every pattern in the set of patterns matches the
    search value.

**Collation caveats**

[Collation][collation] is supported, but with the following caveats:

+ The collation caveats that apply to the [`LIKE` operator][like-operator] also
  apply to the quantified `LIKE` operator.
+ If a collation-supported input contains no collation specification or an
  empty collation specification and another input contains an explicitly defined
  collation, the explicitly defined collation is used for all of the inputs.
+ All inputs with a non-empty, explicitly defined collation specification must
  have the same type of collation specification, otherwise an error is thrown.

<a id="semantic_rules_quant_like"></a>

**Semantics rules**

When using the quantified `LIKE` operator with `ANY` or `SOME`, the
following semantics apply in this order:

+ Returns `FALSE` if `patterns` is empty.
+ Returns `NULL` if `search_value` is `NULL`.
+ Returns `TRUE` if `search_value` matches at least one value in `patterns`.
+ Returns `NULL` if a pattern in `patterns` is `NULL` and other patterns
  in `patterns` don't match.
+ Returns `FALSE`.

When using the quantified `LIKE` operator with `ALL`, the following semantics
apply in this order:

+ For `pattern_subquery`, returns `TRUE` if `patterns` is empty.
+ For `pattern_array`, returns `FALSE` if `patterns` is empty.
+ Returns `NULL` if `search_value` is `NULL`.
+ Returns `TRUE` if `search_value` matches all values in `patterns`.
+ Returns `NULL` if a pattern in `patterns` is `NULL` and other patterns
  in `patterns` don't match.
+ Returns `FALSE`.

When using the quantified `NOT LIKE` operator with `ANY` or `SOME`, the
following semantics apply in this order:

+ For `pattern_subquery`, returns `TRUE` if `patterns` is empty.
+ For `pattern_array`, returns `TRUE` if `patterns` is empty.
+ Returns `NULL` if `search_value` is `NULL`.
+ Returns `TRUE` if `search_value` doesn't match at least one value in
  `patterns`.
+ Returns `NULL` if a pattern in `patterns` is `NULL` and other patterns
  in `patterns` don't match.
+ Returns `FALSE`.

When using the quantified `NOT LIKE` operator with `ALL`, the following
semantics apply in this order:

+ For `pattern_subquery`, returns `FALSE` if `patterns` is empty.
+ For `pattern_array`, returns `TRUE` if `patterns` is empty.
+ Returns `NULL` if `search_value` is `NULL`.
+ Returns `TRUE` if `search_value` matches none of the values in `patterns`.
+ Returns `NULL` if a pattern in `patterns` is `NULL` and other patterns
  in `patterns` don't match.
+ Returns `FALSE`.

**Return Data Type**

`BOOL`

**Examples**

The following example checks to see if the `Intend%` or `%intention%`
pattern exists in a value and produces that value if either pattern is found:

```zetasql
WITH Words AS
 (SELECT 'Intend with clarity.' as value UNION ALL
  SELECT 'Secure with intention.' UNION ALL
  SELECT 'Clarity and security.')
SELECT * FROM Words WHERE value LIKE ANY ('Intend%', '%intention%');

/*------------------------+
 | value                  |
 +------------------------+
 | Intend with clarity.   |
 | Secure with intention. |
 +------------------------*/
```

The following example checks to see if the `%ity%`
pattern exists in a value and produces that value if the pattern is found.

Example with `LIKE ALL`:

```zetasql
WITH Words AS
 (SELECT 'Intend with clarity.' as value UNION ALL
  SELECT 'Secure with intention.' UNION ALL
  SELECT 'Clarity and security.')
SELECT * FROM Words WHERE value LIKE ALL ('%ity%');

/*-----------------------+
 | value                 |
 +-----------------------+
 | Intend with clarity.  |
 | Clarity and security. |
 +-----------------------*/
```

The following example checks to see if the `%ity%`
pattern exists in a value produces that value if the pattern
isn't found:

```zetasql
WITH Words AS
 (SELECT 'Intend with clarity.' as value UNION ALL
  SELECT 'Secure with intention.' UNION ALL
  SELECT 'Clarity and security.')
SELECT * FROM Words WHERE value NOT LIKE ('%ity%');

/*------------------------+
 | value                  |
 +------------------------+
 | Secure with intention. |
 +------------------------*/
```

You can use a subquery as an expression in `patterns`. For example:

```zetasql
WITH Words AS
 (SELECT 'Intend with clarity.' as value UNION ALL
  SELECT 'Secure with intention.' UNION ALL
  SELECT 'Clarity and security.')
SELECT * FROM Words WHERE value LIKE ANY ((SELECT '%ion%'), '%and%');

/*------------------------+
 | value                  |
 +------------------------+
 | Secure with intention. |
 | Clarity and security.  |
 +------------------------*/
```

You can pass in a subquery for `patterns`. For example:

```zetasql
WITH Words AS
 (SELECT 'Intend with clarity.' as value UNION ALL
  SELECT 'Secure with intention.' UNION ALL
  SELECT 'Clarity and security.')
SELECT * FROM Words WHERE value LIKE ANY (SELECT '%with%');

/*------------------------+
 | value                  |
 +------------------------+
 | Intend with clarity.   |
 | Secure with intention. |
 +------------------------*/
```

You can pass in an array for `patterns`. For example:

```zetasql
WITH Words AS
 (SELECT 'Intend with clarity.' as value UNION ALL
  SELECT 'Secure with intention.' UNION ALL
  SELECT 'Clarity and security.')
SELECT * FROM Words WHERE value LIKE ANY UNNEST(['%ion%', '%and%']);

/*------------------------+
 | value                  |
 +------------------------+
 | Secure with intention. |
 | Clarity and security.  |
 +------------------------*/
```

You can pass in an array and subquery for `patterns`. For example:

```zetasql
WITH Words AS
 (SELECT 'Intend with clarity.' as value UNION ALL
  SELECT 'Secure with intention.' UNION ALL
  SELECT 'Clarity and security.')
SELECT *
FROM Words
WHERE
  value LIKE ANY UNNEST(ARRAY(SELECT e FROM UNNEST(['%ion%', '%and%']) AS e));

/*------------------------+
 | value                  |
 +------------------------+
 | Secure with intention. |
 | Clarity and security.  |
 +------------------------*/
```

The following queries illustrate some of the semantic rules for the
quantified `LIKE` operator:

```zetasql
SELECT
  NULL LIKE ANY ('a', 'b'), -- NULL
  'a' LIKE ANY ('a', 'c'), -- TRUE
  'a' LIKE ANY ('b', 'c'), -- FALSE
  'a' LIKE ANY ('a', NULL), -- TRUE
  'a' LIKE ANY ('b', NULL), -- NULL
  NULL NOT LIKE ANY ('a', 'b'), -- NULL
  'a' NOT LIKE ANY ('a', 'b'), -- TRUE
  'a' NOT LIKE ANY ('a', '%a%'), -- FALSE
  'a' NOT LIKE ANY ('a', NULL), -- NULL
  'a' NOT LIKE ANY ('b', NULL); -- TRUE
```

```zetasql
SELECT
  NULL LIKE SOME ('a', 'b'), -- NULL
  'a' LIKE SOME ('a', 'c'), -- TRUE
  'a' LIKE SOME ('b', 'c'), -- FALSE
  'a' LIKE SOME ('a', NULL), -- TRUE
  'a' LIKE SOME ('b', NULL), -- NULL
  NULL NOT LIKE SOME ('a', 'b'), -- NULL
  'a' NOT LIKE SOME ('a', 'b'), -- TRUE
  'a' NOT LIKE SOME ('a', '%a%'), -- FALSE
  'a' NOT LIKE SOME ('a', NULL), -- NULL
  'a' NOT LIKE SOME ('b', NULL); -- TRUE
```

```zetasql
SELECT
  NULL LIKE ALL ('a', 'b'), -- NULL
  'a' LIKE ALL ('a', '%a%'), -- TRUE
  'a' LIKE ALL ('a', 'c'), -- FALSE
  'a' LIKE ALL ('a', NULL), -- NULL
  'a' LIKE ALL ('b', NULL), -- FALSE
  NULL NOT LIKE ALL ('a', 'b'), -- NULL
  'a' NOT LIKE ALL ('b', 'c'), -- TRUE
  'a' NOT LIKE ALL ('a', 'c'), -- FALSE
  'a' NOT LIKE ALL ('a', NULL), -- FALSE
  'a' NOT LIKE ALL ('b', NULL); -- NULL
```

The following queries illustrate some of the semantic rules for the
quantified `LIKE` operator and collation:

```zetasql
SELECT
  COLLATE('a', 'und:ci') LIKE ALL ('a', 'A'), -- TRUE
  'a' LIKE ALL (COLLATE('a', 'und:ci'), 'A'), -- TRUE
  'a' LIKE ALL ('%A%', COLLATE('a', 'und:ci')); -- TRUE
```

```zetasql
-- ERROR: BYTES and STRING values can't be used together.
SELECT b'a' LIKE ALL (COLLATE('a', 'und:ci'), 'A');
```

[like-operator]: #like_operator

[semantic-rules-quant-like]: #semantic_rules_quant_like

[reg-expressions-quant-like]: #reg_expressions_quant_like

[operators-subqueries]: https://github.com/google/zetasql/blob/master/docs/subqueries.md#about_subqueries

[operators-link-to-unnest]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#unnest_operator

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_funcs

### `NEW` operator 
<a id="new_operator"></a>

The `NEW` operator only supports protocol buffers and uses the following syntax:

 + `NEW protocol_buffer {...}`: Creates a
protocol buffer using a map constructor.

  ```zetasql
  NEW protocol_buffer {
    field_name: literal_or_expression
    field_name { ... }
    repeated_field_name: [literal_or_expression, ... ]
  }
  ```
+   `NEW protocol_buffer (...)`: Creates a protocol buffer using a parenthesized
    list of arguments.

    ```zetasql
    NEW protocol_buffer(field [AS alias], ...field [AS alias])
    ```

**Examples**

The following example uses the `NEW` operator with a map constructor:

```zetasql
NEW Universe {
  name: "Sol"
  closest_planets: ["Mercury", "Venus", "Earth" ]
  star {
    radius_miles: 432,690
    age: 4,603,000,000
  }
  constellations: [{
    name: "Libra"
    index: 0
  }, {
    name: "Scorpio"
    index: 1
  }]
  all_planets: (SELECT planets FROM SolTable)
}
```

The following example uses the `NEW` operator with a parenthesized list of
arguments:

```zetasql
SELECT
  key,
  name,
  NEW zetasql.examples.music.Chart(key AS rank, name AS chart_name)
FROM
  (SELECT 1 AS key, "2" AS name);
```

To learn more about protocol buffers in ZetaSQL, see [Work with
protocol buffers][protocol-buffers].

[protocol-buffers]: https://github.com/google/zetasql/blob/master/docs/protocol-buffers.md

### Concatenation operator 
<a id="concatenation_operator"></a>

The concatenation operator combines multiple values into one.

<table>
<thead>
<tr>
<th>Function Syntax</th>
<th>Input Data Type</th>
<th>Result Data Type</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>STRING || STRING [ || ... ]</code></td>
  <td><code>STRING</code></td>
  <td><code>STRING</code></td>
</tr>
<tr>
  <td><code>BYTES || BYTES [ || ... ]</code></td>
  <td><code>BYTES</code></td>
  <td><code>BYTES</code></td>
</tr>
<tr>
  <td><code>ARRAY&#60;T&#62; || ARRAY&#60;T&#62; [ || ... ]</code></td>
  <td><code>ARRAY&#60;T&#62;</code></td>
  <td><code>ARRAY&#60;T&#62;</code></td>
</tr>
</tbody>
</table>

Note: The concatenation operator is translated into a nested
[`CONCAT`][concat] function call. For example, `'A' || 'B' || 'C'` becomes
`CONCAT('A', CONCAT('B', 'C'))`.

[concat]: #concat

### `WITH` expression 
<a id="with_expression"></a>

```zetasql
WITH(variable_assignment[, ...], result_expression)

variable_assignment:
  variable_name AS expression
```

**Description**

Creates one or more variables. Each variable can be used in subsequent
expressions within the `WITH` expression. Returns the value of
`result_expression`.

+   `variable_assignment`: Introduces a variable. The variable name must be
    unique within a given `WITH` expression. Each expression can reference the
    variables that come before it. For example, if you create variable `a`,
    then follow it with variable `b`, then you can reference `a` inside of the
    expression for `b`.

    +   `variable_name`: The name of the variable.

    +   `expression`: The value to assign to the variable.
+   `result_expression`: An expression that can use all of the variables defined
    before it. The value of `result_expression` is returned by the `WITH`
    expression.

**Return Type**

+   The type of the `result_expression`.

**Requirements and Caveats**

+   A variable can only be assigned once within a `WITH` expression.
+   Variables created during `WITH` may not be used
    in analytic or aggregate
    function arguments. For example,
    `WITH(a AS ..., SUM(a))` produces an error.
+   Each variable's expression is evaluated only once.

**Examples**

The following example first concatenates variable `a` with `b`, then variable
`b` with `c`:

```zetasql
SELECT WITH(a AS '123',               -- a is '123'
            b AS CONCAT(a, '456'),    -- b is '123456'
            c AS '789',               -- c is '789'
            CONCAT(b, c)) AS result;  -- b + c is '123456789'

/*-------------*
 | result      |
 +-------------+
 | '123456789' |
 *-------------*/
```

In the following example, the volatile expression `RAND()` is evaluated once.
The value of the result expression is always `0.0`:

```zetasql
SELECT WITH(a AS RAND(), a - a);

/*---------*
 | result  |
 +---------+
 | 0.0     |
 *---------*/
```

Aggregate or analytic function
results can be stored in variables.

```zetasql
SELECT WITH(s AS SUM(input), c AS COUNT(input), s/c)
FROM UNNEST([1.0, 2.0, 3.0]) AS input;

/*---------*
 | result  |
 +---------+
 | 2.0     |
 *---------*/
```

Variables can't be used in aggregate or
analytic function call arguments.

```zetasql
SELECT WITH(diff AS a - b, AVG(diff))
FROM UNNEST([
              STRUCT(1 AS a, 2 AS b),
              STRUCT(3 AS a, 4 AS b),
              STRUCT(5 AS a, 6 AS b)
            ]);

-- ERROR: WITH variables like 'diff' can't be used in aggregate or analytic
-- function arguments.
```

A `WITH` expression is different from a `WITH` clause. The following example
shows a query that uses both:

```zetasql
WITH my_table AS (
  SELECT 1 AS x, 2 AS y
  UNION ALL
  SELECT 3 AS x, 4 AS y
  UNION ALL
  SELECT 5 AS x, 6 AS y
)
SELECT WITH(a AS SUM(x), b AS COUNT(x), a/b) AS avg_x, AVG(y) AS avg_y
FROM my_table
WHERE x > 1;

/*-------+-------+
 | avg_x | avg_y |
 +-------+-------+
 | 4     | 5     |
 +-------+-------*/
```

## Conditional expressions

ZetaSQL supports conditional expressions.
Conditional expressions impose constraints on the evaluation order of their
inputs. In essence, they are evaluated left to right, with short-circuiting, and
only evaluate the output value that was chosen. In contrast, all inputs to
regular functions are evaluated before calling the function. Short-circuiting in
conditional expressions can be exploited for error handling or performance
tuning.

### Expression list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#case_expr"><code>CASE expr</code></a>
</td>
  <td>
    Compares the given expression to each successive <code>WHEN</code> clause
    and produces the first result where the values are equal.
  </td>
</tr>

<tr>
  <td><a href="#case"><code>CASE</code></a>
</td>
  <td>
    Evaluates the condition of each successive <code>WHEN</code> clause and
    produces the first result where the condition evaluates to
    <code>TRUE</code>.
  </td>
</tr>

<tr>
  <td><a href="#coalesce"><code>COALESCE</code></a>
</td>
  <td>
    Produces the value of the first non-<code>NULL</code> expression, if any,
    otherwise <code>NULL</code>.
  </td>
</tr>

<tr>
  <td><a href="#if"><code>IF</code></a>
</td>
  <td>
    If an expression evaluates to <code>TRUE</code>, produces a specified
    result, otherwise produces the evaluation for an <i>else result</i>.
  </td>
</tr>

<tr>
  <td><a href="#ifnull"><code>IFNULL</code></a>
</td>
  <td>
    If an expression evaluates to <code>NULL</code>, produces a specified
    result, otherwise produces the expression.
  </td>
</tr>

<tr>
  <td><a href="#nullif"><code>NULLIF</code></a>
</td>
  <td>
    Produces <code>NULL</code> if the first expression that matches another
    evaluates to <code>TRUE</code>, otherwise returns the first expression.
  </td>
</tr>

<tr>
  <td><a href="#nullifzero"><code>NULLIFZERO</code></a>
</td>
  <td>
    Produces <code>NULL</code> if an expression is <code>0</code>,
    otherwise produces the expression.
  </td>
</tr>

<tr>
  <td><a href="#zeroifnull"><code>ZEROIFNULL</code></a>
</td>
  <td>
    Produces <code>0</code> if an expression is <code>NULL</code>, otherwise
    produces the expression.
  </td>
</tr>

  </tbody>
</table>

### `CASE expr` 
<a id="case_expr"></a>

```zetasql
CASE expr
  WHEN expr_to_match THEN result
  [ ... ]
  [ ELSE else_result ]
  END
```

**Description**

Compares `expr` to `expr_to_match` of each successive `WHEN` clause and returns
the first result where this comparison evaluates to `TRUE`. The remaining `WHEN`
clauses and `else_result` aren't evaluated.

If the `expr = expr_to_match` comparison evaluates to `FALSE` or `NULL` for all
`WHEN` clauses, returns the evaluation of `else_result` if present; if
`else_result` isn't present, then returns `NULL`.

Consistent with [equality comparisons][logical-operators] elsewhere, if both
`expr` and `expr_to_match` are `NULL`, then `expr = expr_to_match` evaluates to
`NULL`, which returns `else_result`. If a CASE statement needs to distinguish a
`NULL` value, then the alternate [CASE][case] syntax should be used.

`expr` and `expr_to_match` can be any type. They must be implicitly
coercible to a common [supertype][cond-exp-supertype]; equality comparisons are
done on coerced values. There may be multiple `result` types. `result` and
`else_result` expressions must be coercible to a common supertype.

This expression supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

**Return Data Type**

[Supertype][cond-exp-supertype] of `result`[, ...] and `else_result`.

**Example**

```zetasql
WITH Numbers AS (
  SELECT 90 as A, 2 as B UNION ALL
  SELECT 50, 8 UNION ALL
  SELECT 60, 6 UNION ALL
  SELECT 50, 10
)
SELECT
  A,
  B,
  CASE A
    WHEN 90 THEN 'red'
    WHEN 50 THEN 'blue'
    ELSE 'green'
    END
    AS result
FROM Numbers

/*------------------*
 | A  | B  | result |
 +------------------+
 | 90 | 2  | red    |
 | 50 | 8  | blue   |
 | 60 | 6  | green  |
 | 50 | 10 | blue   |
 *------------------*/
```

[logical-operators]: #logical_operators

[case]: #case

[cond-exp-supertype]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md#supertypes

### `CASE` 
<a id="case"></a>

```zetasql
CASE
  WHEN condition THEN result
  [ ... ]
  [ ELSE else_result ]
  END
```

**Description**

Evaluates the condition of each successive `WHEN` clause and returns the
first result where the condition evaluates to `TRUE`; any remaining `WHEN`
clauses and `else_result` aren't evaluated.

If all conditions evaluate to `FALSE` or `NULL`, returns evaluation of
`else_result` if present; if `else_result` isn't present, then returns `NULL`.

For additional rules on how values are evaluated, see the
three-valued logic table in [Logical operators][logical-operators].

`condition` must be a boolean expression. There may be multiple `result` types.
`result` and `else_result` expressions must be implicitly coercible to a common
[supertype][cond-exp-supertype].

This expression supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

**Return Data Type**

[Supertype][cond-exp-supertype] of `result`[, ...] and `else_result`.

**Example**

```zetasql
WITH Numbers AS (
  SELECT 90 as A, 2 as B UNION ALL
  SELECT 50, 6 UNION ALL
  SELECT 20, 10
)
SELECT
  A,
  B,
  CASE
    WHEN A > 60 THEN 'red'
    WHEN B = 6 THEN 'blue'
    ELSE 'green'
    END
    AS result
FROM Numbers

/*------------------*
 | A  | B  | result |
 +------------------+
 | 90 | 2  | red    |
 | 50 | 6  | blue   |
 | 20 | 10 | green  |
 *------------------*/
```

[cond-exp-supertype]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md#supertypes

[logical-operators]: #logical_operators

### `COALESCE` 
<a id="coalesce"></a>

```zetasql
COALESCE(expr[, ...])
```

**Description**

Returns the value of the first non-`NULL` expression, if any, otherwise
`NULL`. The remaining expressions aren't evaluated. An input expression can be
any type. There may be multiple input expression types.
All input expressions must be implicitly coercible to a common
[supertype][cond-exp-supertype].

**Return Data Type**

[Supertype][cond-exp-supertype] of `expr`[, ...].

**Examples**

```zetasql
SELECT COALESCE('A', 'B', 'C') as result

/*--------*
 | result |
 +--------+
 | A      |
 *--------*/
```

```zetasql
SELECT COALESCE(NULL, 'B', 'C') as result

/*--------*
 | result |
 +--------+
 | B      |
 *--------*/
```

[cond-exp-supertype]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md#supertypes

### `IF` 
<a id="if"></a>

```zetasql
IF(expr, true_result, else_result)
```

**Description**

If `expr` evaluates to `TRUE`, returns `true_result`, else returns the
evaluation for `else_result`. `else_result` isn't evaluated if `expr` evaluates
to `TRUE`. `true_result` isn't evaluated if `expr` evaluates to `FALSE` or
`NULL`.

`expr` must be a boolean expression. `true_result` and `else_result`
must be coercible to a common [supertype][cond-exp-supertype].

**Return Data Type**

[Supertype][cond-exp-supertype] of `true_result` and `else_result`.

**Examples**

```zetasql
SELECT
  10 AS A,
  20 AS B,
  IF(10 < 20, 'true', 'false') AS result

/*------------------*
 | A  | B  | result |
 +------------------+
 | 10 | 20 | true   |
 *------------------*/
```

```zetasql
SELECT
  30 AS A,
  20 AS B,
  IF(30 < 20, 'true', 'false') AS result

/*------------------*
 | A  | B  | result |
 +------------------+
 | 30 | 20 | false  |
 *------------------*/
```

[cond-exp-supertype]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md#supertypes

### `IFNULL` 
<a id="ifnull"></a>

```zetasql
IFNULL(expr, null_result)
```

**Description**

If `expr` evaluates to `NULL`, returns `null_result`. Otherwise, returns
`expr`. If `expr` doesn't evaluate to `NULL`, `null_result` isn't evaluated.

`expr` and `null_result` can be any type and must be implicitly coercible to
a common [supertype][cond-exp-supertype]. Synonym for
`COALESCE(expr, null_result)`.

**Return Data Type**

[Supertype][cond-exp-supertype] of `expr` or `null_result`.

**Examples**

```zetasql
SELECT IFNULL(NULL, 0) as result

/*--------*
 | result |
 +--------+
 | 0      |
 *--------*/
```

```zetasql
SELECT IFNULL(10, 0) as result

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

[cond-exp-supertype]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md#supertypes

### `NULLIF` 
<a id="nullif"></a>

```zetasql
NULLIF(expr, expr_to_match)
```

**Description**

Returns `NULL` if `expr = expr_to_match` evaluates to `TRUE`, otherwise
returns `expr`.

`expr` and `expr_to_match` must be implicitly coercible to a
common [supertype][cond-exp-supertype], and must be comparable.

This expression supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

**Return Data Type**

[Supertype][cond-exp-supertype] of `expr` and `expr_to_match`.

**Example**

```zetasql
SELECT NULLIF(0, 0) as result

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT NULLIF(10, 0) as result

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

[cond-exp-supertype]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md#supertypes

### `NULLIFZERO` 
<a id="nullifzero"></a>

```zetasql
NULLIFZERO(expr)
```

**Description**

Returns `NULL` if the value of `expr` is `0`. Otherwise, returns `expr`. `expr`
must be a zeroable type.

**Return Data Type**

Type of `expr`.

**Example**

```zetasql
SELECT NULLIFZERO(0) AS result

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `ZEROIFNULL` 
<a id="zeroifnull"></a>

```zetasql
ZEROIFNULL(expr)
```

**Description**

Returns `0` if the value of `expr` is `NULL`. Otherwise, returns `expr`. `expr`
must be a zeroable type.

**Return Data Type**

Type of `expr`.

**Example**

```zetasql
SELECT ZEROIFNULL(NULL) AS result

/*--------*
 | result |
 +--------+
 | 0      |
 *--------*/
```

---
## FUNCTIONS

## AEAD encryption functions

ZetaSQL supports the following AEAD encryption functions.
For a description of how the AEAD encryption
functions work, see [AEAD encryption concepts][aead-encryption-concepts].

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#aeaddecrypt_bytes"><code>AEAD.DECRYPT_BYTES</code></a>
</td>
  <td>
    Uses the matching key from a keyset to decrypt a
    <code>BYTES</code> ciphertext.
  </td>
</tr>

<tr>
  <td><a href="#aeaddecrypt_string"><code>AEAD.DECRYPT_STRING</code></a>
</td>
  <td>
    Uses the matching key from a keyset to decrypt a <code>BYTES</code>
    ciphertext into a <code>STRING</code> plaintext.
  </td>
</tr>

<tr>
  <td><a href="#aeadencrypt"><code>AEAD.ENCRYPT</code></a>
</td>
  <td>
    Encrypts <code>STRING</code> plaintext, using the primary cryptographic key
    in a keyset.
  </td>
</tr>

<tr>
  <td><a href="#deterministic_decrypt_bytes"><code>DETERMINISTIC_DECRYPT_BYTES</code></a>
</td>
  <td>
    Uses the matching key from a keyset to decrypt a <code>BYTES</code>
    ciphertext, using deterministic AEAD.
  </td>
</tr>

<tr>
  <td><a href="#deterministic_decrypt_string"><code>DETERMINISTIC_DECRYPT_STRING</code></a>
</td>
  <td>
    Uses the matching key from a keyset to decrypt a <code>BYTES</code>
    ciphertext into a <code>STRING</code> plaintext, using deterministic AEAD.
  </td>
</tr>

<tr>
  <td><a href="#deterministic_encrypt"><code>DETERMINISTIC_ENCRYPT</code></a>
</td>
  <td>
    Encrypts <code>STRING</code> plaintext, using the primary cryptographic key
    in a keyset, using deterministic AEAD encryption.
  </td>
</tr>

<tr>
  <td><a href="#keysadd_key_from_raw_bytes"><code>KEYS.ADD_KEY_FROM_RAW_BYTES</code></a>
</td>
  <td>
    Adds a key to a keyset, and return the new keyset as a serialized
    <code>BYTES</code> value.
  </td>
</tr>

<tr>
  <td><a href="#keyskeyset_from_json"><code>KEYS.KEYSET_FROM_JSON</code></a>
</td>
  <td>
    Converts a <code>STRING</code> JSON keyset to a serialized
    <code>BYTES</code> value.
  </td>
</tr>

<tr>
  <td><a href="#keyskeyset_length"><code>KEYS.KEYSET_LENGTH</code></a>
</td>
  <td>
    Gets the number of keys in the provided keyset.
  </td>
</tr>

<tr>
  <td><a href="#keyskeyset_to_json"><code>KEYS.KEYSET_TO_JSON</code></a>
</td>
  <td>
    Gets a JSON <code>STRING</code> representation of a keyset.
  </td>
</tr>

<tr>
  <td><a href="#keysnew_keyset"><code>KEYS.NEW_KEYSET</code></a>
</td>
  <td>
    Gets a serialized keyset containing a new key based on the key type.
  </td>
</tr>

<tr>
  <td><a href="#keysrotate_keyset"><code>KEYS.ROTATE_KEYSET</code></a>
</td>
  <td>
    Adds a new primary cryptographic key to a keyset, based on the key type.
  </td>
</tr>

  </tbody>
</table>

### `AEAD.DECRYPT_BYTES`

```zetasql
AEAD.DECRYPT_BYTES(keyset, ciphertext, additional_data)
```

**Description**

Uses the matching key from `keyset` to decrypt `ciphertext` and verifies the
integrity of the data using `additional_data`. Returns an error if decryption or
verification fails.

`keyset` is a serialized `BYTES` value returned by one of the
`KEYS` functions. `keyset` must contain the key that was used to
encrypt `ciphertext`, and the key must be in an `'ENABLED'` state, or else the
function returns an error. `AEAD.DECRYPT_BYTES` identifies the matching key
in `keyset` by finding the key with the key ID that matches the one encrypted in
`ciphertext`.

`ciphertext` is a `BYTES` value that's the result of
a call to `AEAD.ENCRYPT` where the input `plaintext` was of type
`BYTES`.

If `ciphertext` includes an initialization vector (IV),
it should be the first bytes of `ciphertext`. If `ciphertext` includes an
authentication tag, it should be the last bytes of `ciphertext`. If the
IV and authentic tag are one (SIV), it should be the first bytes of
`ciphertext`. The IV and authentication tag commonly require 16 bytes, but may
vary in size.

`additional_data` is a `STRING` or `BYTES` value that binds the ciphertext to
its context. This forces the ciphertext to be decrypted in the same context in
which it was encrypted. This function casts any
`STRING` value to `BYTES`.
This must be the same as the `additional_data` provided to `AEAD.ENCRYPT` to
encrypt `ciphertext`, ignoring its type, or else the function returns an error.

**Return Data Type**

`BYTES`

**Example**

This example creates a table of unique IDs with associated plaintext values and
keysets. Then it uses these keysets to encrypt the plaintext values as
`BYTES` and store them in a new table. Finally, it
uses `AEAD.DECRYPT_BYTES` to decrypt the encrypted values and display them as
plaintext.

The following statement creates a table `CustomerKeysets` containing a column of
unique IDs, a column of `AEAD_AES_GCM_256` keysets, and a column of favorite
animals.

```zetasql
CREATE TABLE aead.CustomerKeysets AS
SELECT
  1 AS customer_id,
  KEYS.NEW_KEYSET('AEAD_AES_GCM_256') AS keyset,
  b'jaguar' AS favorite_animal
UNION ALL
SELECT
  2 AS customer_id,
  KEYS.NEW_KEYSET('AEAD_AES_GCM_256') AS keyset,
  b'zebra' AS favorite_animal
UNION ALL
SELECT
  3 AS customer_id,
  KEYS.NEW_KEYSET('AEAD_AES_GCM_256') AS keyset,
  b'nautilus' AS favorite_animal;
```

The following statement creates a table `EncryptedCustomerData` containing a
column of unique IDs and a column of ciphertext. The statement encrypts the
plaintext `favorite_animal` using the keyset value from `CustomerKeysets`
corresponding to each unique ID.

```zetasql
CREATE TABLE aead.EncryptedCustomerData AS
SELECT
  customer_id,
  AEAD.ENCRYPT(keyset, favorite_animal, CAST(CAST(customer_id AS STRING) AS BYTES))
   AS encrypted_animal
FROM
  aead.CustomerKeysets AS ck;
```

The following query uses the keysets in the `CustomerKeysets` table to decrypt
data in the `EncryptedCustomerData` table.

```zetasql
SELECT
  ecd.customer_id,
  AEAD.DECRYPT_BYTES(
    (SELECT ck.keyset
     FROM aead.CustomerKeysets AS ck
     WHERE ecd.customer_id = ck.customer_id),
    ecd.encrypted_animal,
    CAST(CAST(customer_id AS STRING) AS BYTES)
  ) AS favorite_animal
FROM aead.EncryptedCustomerData AS ecd;
```

### `AEAD.DECRYPT_STRING`

```zetasql
AEAD.DECRYPT_STRING(keyset, ciphertext, additional_data)
```

**Description**

Like [`AEAD.DECRYPT_BYTES`][aeaddecrypt-bytes], but where `additional_data` is
of type `STRING`.

**Return Data Type**

`STRING`

[aeaddecrypt-bytes]: #aeaddecrypt_bytes

### `AEAD.ENCRYPT`

```zetasql
AEAD.ENCRYPT(keyset, plaintext, additional_data)
```

**Description**

Encrypts `plaintext` using the primary cryptographic key in `keyset`. The
algorithm of the primary key must be `AEAD_AES_GCM_256`. Binds the ciphertext to
the context defined by `additional_data`. Returns `NULL` if any input is `NULL`.

`keyset` is a serialized `BYTES` value returned by one of the
`KEYS` functions.

`plaintext` is the `STRING` or
`BYTES` value to be encrypted.

`additional_data` is a `STRING` or `BYTES` value that binds the ciphertext to
its context. This forces the ciphertext to be decrypted in the same context in
which it was encrypted. `plaintext` and `additional_data` must be of the same
type. `AEAD.ENCRYPT(keyset, string1, string2)` is equivalent to
`AEAD.ENCRYPT(keyset, CAST(string1 AS BYTES), CAST(string2 AS BYTES))`.

The output is ciphertext `BYTES`. The ciphertext contains a
[Tink-specific][tink] prefix indicating the key used to perform the encryption.

**Return Data Type**

`BYTES`

**Example**

The following query uses the keysets for each `customer_id` in the
`CustomerKeysets` table to encrypt the value of the plaintext `favorite_animal`
in the `PlaintextCustomerData` table corresponding to that `customer_id`. The
output contains a column of `customer_id` values and a column of
corresponding ciphertext output as `BYTES`.

```zetasql
WITH CustomerKeysets AS (
  SELECT 1 AS customer_id, KEYS.NEW_KEYSET('AEAD_AES_GCM_256') AS keyset UNION ALL
  SELECT 2, KEYS.NEW_KEYSET('AEAD_AES_GCM_256') UNION ALL
  SELECT 3, KEYS.NEW_KEYSET('AEAD_AES_GCM_256')
), PlaintextCustomerData AS (
  SELECT 1 AS customer_id, 'elephant' AS favorite_animal UNION ALL
  SELECT 2, 'walrus' UNION ALL
  SELECT 3, 'leopard'
)
SELECT
  pcd.customer_id,
  AEAD.ENCRYPT(
    (SELECT keyset
     FROM CustomerKeysets AS ck
     WHERE ck.customer_id = pcd.customer_id),
    pcd.favorite_animal,
    CAST(pcd.customer_id AS STRING)
  ) AS encrypted_animal
FROM PlaintextCustomerData AS pcd;
```

[tink]: https://github.com/google/tink/blob/master/docs/KEY-MANAGEMENT.md

### `DETERMINISTIC_DECRYPT_BYTES`

```zetasql
DETERMINISTIC_DECRYPT_BYTES(keyset, ciphertext, additional_data)
```

**Description**

Uses the matching key from `keyset` to decrypt `ciphertext` and verifies the
integrity of the data using `additional_data`. Returns an error if decryption
fails.

`keyset` is a serialized `BYTES` value returned by one of the `KEYS` functions. `keyset` must contain
the key that was used to encrypt `ciphertext`, the key must be in an `'ENABLED'`
state, and the key must be of type `DETERMINISTIC_AEAD_AES_SIV_CMAC_256`, or
else the function returns an error. `DETERMINISTIC_DECRYPT_BYTES` identifies the
matching key in `keyset` by finding the key with the key ID that matches the one
encrypted in `ciphertext`.

`ciphertext` is a `BYTES` value that's the result of a call to
`DETERMINISTIC_ENCRYPT` where the input `plaintext` was of type `BYTES`.

The ciphertext must follow Tink's [wire format][tink-wire-format]. The first
byte of `ciphertext` should contain a Tink key version followed by a 4 byte key
hint. If `ciphertext` includes an initialization vector (IV), it should be the
next bytes of `ciphertext`. If `ciphertext` includes an authentication tag, it
should be the last bytes of `ciphertext`. If the IV and authentic tag are one
(SIV), it should be the first bytes of `ciphertext`. The IV and authentication
tag commonly require 16 bytes, but may vary in size.

`additional_data` is a `STRING` or `BYTES` value that binds the ciphertext to
its context. This forces the ciphertext to be decrypted in the same context in
which it was encrypted. This function casts any `STRING` value to `BYTES`. This
must be the same as the `additional_data` provided to `DETERMINISTIC_ENCRYPT` to
encrypt `ciphertext`, ignoring its type, or else the function returns an error.

**Return Data Type**

`BYTES`

**Example**

This example creates a table of unique IDs with associated plaintext values and
keysets. Then it uses these keysets to encrypt the plaintext values as `BYTES`
and store them in a new table. Finally, it uses `DETERMINISTIC_DECRYPT_BYTES` to
decrypt the encrypted values and display them as plaintext.

The following statement creates a table `CustomerKeysets` containing a column of
unique IDs, a column of `DETERMINISTIC_AEAD_AES_SIV_CMAC_256` keysets, and a
column of favorite animals.

```zetasql
CREATE TABLE deterministic.CustomerKeysets AS
SELECT
  1 AS customer_id,
  KEYS.NEW_KEYSET('DETERMINISTIC_AEAD_AES_SIV_CMAC_256') AS keyset,
  b'jaguar' AS favorite_animal
UNION ALL
SELECT
  2 AS customer_id,
  KEYS.NEW_KEYSET('DETERMINISTIC_AEAD_AES_SIV_CMAC_256') AS keyset,
  b'zebra' AS favorite_animal
UNION ALL
SELECT
  3 AS customer_id,
  KEYS.NEW_KEYSET('DETERMINISTIC_AEAD_AES_SIV_CMAC_256') AS keyset,
  b'nautilus' AS favorite_animal;
```

The following statement creates a table `EncryptedCustomerData` containing a
column of unique IDs and a column of ciphertext. The statement encrypts the
plaintext `favorite_animal` using the keyset value from `CustomerKeysets`
corresponding to each unique ID.

```zetasql
CREATE TABLE deterministic.EncryptedCustomerData AS
SELECT
  customer_id,
  DETERMINISTIC_ENCRYPT(ck.keyset, favorite_animal, CAST(CAST(customer_id AS STRING) AS BYTES))
   AS encrypted_animal
FROM
  deterministic.CustomerKeysets AS ck;
```

The following query uses the keysets in the `CustomerKeysets` table to decrypt
data in the `EncryptedCustomerData` table.

```zetasql
SELECT
  ecd.customer_id,
  DETERMINISTIC_DECRYPT_BYTES(
    (SELECT ck.keyset
     FROM deterministic.CustomerKeysets AS ck
     WHERE ecd.customer_id = ck.customer_id),
    ecd.encrypted_animal,
    CAST(CAST(ecd.customer_id AS STRING) AS BYTES)
  ) AS favorite_animal
FROM deterministic.EncryptedCustomerData AS ecd;
```

[tink-wire-format]: https://developers.google.com/tink/wire-format#deterministic_aead

### `DETERMINISTIC_DECRYPT_STRING`

```zetasql
DETERMINISTIC_DECRYPT_STRING(keyset, ciphertext, additional_data)
```

**Description**

Like [`DETERMINISTIC_DECRYPT_BYTES`][deterministic-decrypt-bytes], but where
`plaintext` is of type `STRING`.

**Return Data Type**

`STRING`

[deterministic-decrypt-bytes]: #deterministic_decrypt_bytes

### `DETERMINISTIC_ENCRYPT`

```zetasql
DETERMINISTIC_ENCRYPT(keyset, plaintext, additional_data)
```

**Description**

Encrypts `plaintext` using the primary cryptographic key in `keyset` using
[deterministic AEAD][deterministic-aead]. The algorithm of the primary key must
be `DETERMINISTIC_AEAD_AES_SIV_CMAC_256`. Binds the ciphertext to the context
defined by `additional_data`. Returns `NULL` if any input is `NULL`.

`keyset` is a serialized `BYTES` value returned by one of the `KEYS` functions.

`plaintext` is the `STRING` or `BYTES` value to be encrypted.

`additional_data` is a `STRING` or `BYTES` value that binds the ciphertext to
its context. This forces the ciphertext to be decrypted in the same context in
which it was encrypted. `plaintext` and `additional_data` must be of the same
type. `DETERMINISTIC_ENCRYPT(keyset, string1, string2)` is equivalent to
`DETERMINISTIC_ENCRYPT(keyset, CAST(string1 AS BYTES), CAST(string2 AS BYTES))`.

The output is ciphertext `BYTES`. The ciphertext contains a
[Tink-specific][tink] prefix indicating the key used to perform the encryption.
Given an identical `keyset` and `plaintext`, this function returns the same
ciphertext each time it's invoked (including across queries).

**Return Data Type**

`BYTES`

**Example**

The following query uses the keysets for each `customer_id` in the
`CustomerKeysets` table to encrypt the value of the plaintext `favorite_animal`
in the `PlaintextCustomerData` table corresponding to that `customer_id`. The
output contains a column of `customer_id` values and a column of corresponding
ciphertext output as `BYTES`.

```zetasql
WITH CustomerKeysets AS (
  SELECT 1 AS customer_id,
  KEYS.NEW_KEYSET('DETERMINISTIC_AEAD_AES_SIV_CMAC_256') AS keyset UNION ALL
  SELECT 2, KEYS.NEW_KEYSET('DETERMINISTIC_AEAD_AES_SIV_CMAC_256') UNION ALL
  SELECT 3, KEYS.NEW_KEYSET('DETERMINISTIC_AEAD_AES_SIV_CMAC_256')
), PlaintextCustomerData AS (
  SELECT 1 AS customer_id, 'elephant' AS favorite_animal UNION ALL
  SELECT 2, 'walrus' UNION ALL
  SELECT 3, 'leopard'
)
SELECT
  pcd.customer_id,
  DETERMINISTIC_ENCRYPT(
    (SELECT keyset
     FROM CustomerKeysets AS ck
     WHERE ck.customer_id = pcd.customer_id),
    pcd.favorite_animal,
    CAST(pcd.customer_id AS STRING)
  ) AS encrypted_animal
FROM PlaintextCustomerData AS pcd;
```

[tink]: https://github.com/google/tink/blob/master/docs/KEY-MANAGEMENT.md

[deterministic-aead]: https://developers.google.com/tink/deterministic-aead

### `KEYS.ADD_KEY_FROM_RAW_BYTES`

```
KEYS.ADD_KEY_FROM_RAW_BYTES(keyset, key_type, raw_key_bytes)
```

**Description**

Returns a serialized keyset as `BYTES` with the
addition of a key to `keyset` based on `key_type` and `raw_key_bytes`.

The primary cryptographic key remains the same as in `keyset`. The expected
length of `raw_key_bytes` depends on the value of `key_type`. The following are
supported `key_types`:

+ `'AES_CBC_PKCS'`: Creates a key for AES decryption using cipher block chaining
  and PKCS padding. `raw_key_bytes` is expected to be a raw key
  `BYTES` value of length 16, 24, or 32; these
  lengths have sizes of 128, 192, and 256 bits, respectively. ZetaSQL
  AEAD functions don't support keys of these types for encryption; instead,
  prefer `'AEAD_AES_GCM_256'` or `'AES_GCM'` keys.
+ `'AES_GCM'`: Creates a key for AES decryption or encryption using
  [Galois/Counter Mode][galois-counter-mode].
  `raw_key_bytes` must be a raw key `BYTES`
  value of length 16 or 32; these lengths have sizes of 128 and 256 bits,
  respectively. When keys of this type are inputs to `AEAD.ENCRYPT`, the output
  ciphertext doesn't have a Tink-specific prefix indicating which key was
  used as input.

**Return Data Type**

`BYTES`

**Example**

The following query creates a table of customer IDs along with raw key bytes,
called `CustomerRawKeys`, and a table of unique IDs, called `CustomerIds`. It
creates a new `'AEAD_AES_GCM_256'` keyset for each `customer_id`; then it adds a
new key to each keyset, using the `raw_key_bytes` value corresponding to that
`customer_id`. The output is a table where each row contains a `customer_id` and
a keyset in `BYTES`, which contains the raw key added
using KEYS.ADD_KEY_FROM_RAW_BYTES.

```zetasql
WITH CustomerRawKeys AS (
  SELECT 1 AS customer_id, b'0123456789012345' AS raw_key_bytes UNION ALL
  SELECT 2, b'9876543210543210' UNION ALL
  SELECT 3, b'0123012301230123'
), CustomerIds AS (
  SELECT 1 AS customer_id UNION ALL
  SELECT 2 UNION ALL
  SELECT 3
)
SELECT
  ci.customer_id,
  KEYS.ADD_KEY_FROM_RAW_BYTES(
    KEYS.NEW_KEYSET('AEAD_AES_GCM_256'),
    'AES_CBC_PKCS',
    (SELECT raw_key_bytes FROM CustomerRawKeys AS crk
     WHERE crk.customer_id = ci.customer_id)
  ) AS keyset
FROM CustomerIds AS ci;
```

The output keysets each contain two things: the primary cryptographic key
created using `KEYS.NEW_KEYSET('AEAD_AES_GCM_256')`, and the raw key added using
`KEYS.ADD_KEY_FROM_RAW_BYTES`. If a keyset in the output is used with
`AEAD.ENCRYPT`, ZetaSQL uses the primary cryptographic key created
using `KEYS.NEW_KEYSET('AEAD_AES_GCM_256')` to encrypt the input plaintext. If
the keyset is used with `AEAD.DECRYPT_STRING` or `AEAD.DECRYPT_BYTES`,
ZetaSQL returns the resulting plaintext if either key succeeds in
decrypting the ciphertext.

[galois-counter-mode]: https://en.wikipedia.org/wiki/Galois/Counter_Mode

### `KEYS.KEYSET_FROM_JSON`

```zetasql
KEYS.KEYSET_FROM_JSON(json_keyset)
```

**Description**

Returns the input `json_keyset` `STRING` as
serialized `BYTES`, which is a valid input for other
`KEYS` and `AEAD` functions. The JSON `STRING` must
be compatible with the definition of the
[google.crypto.tink.Keyset][google-crypto-tink-keyset]
protocol buffer message: the JSON keyset should be a JSON object containing
objects and name-value pairs corresponding to those in the "keyset" message in
the google.crypto.tink.Keyset definition. You can convert the output serialized
`BYTES` representation back to a JSON
`STRING` using `KEYS.KEYSET_TO_JSON`.

**Return Data Type**

`BYTES`

**Example**

`KEYS.KEYSET_FROM_JSON` takes JSON-formatted `STRING`
values like the following:

```json
{
  "key":[
      {
        "keyData":{
          "keyMaterialType":"SYMMETRIC",
          "typeUrl":"type.googleapis.com/google.crypto.tink.AesGcmKey",
          "value":"GiD80Z8kL6AP3iSNHhqseZGAIvq7TVQzClT7FQy8YwK3OQ=="
        },
        "keyId":3101427138,
        "outputPrefixType":"TINK",
        "status":"ENABLED"
      }
    ],
  "primaryKeyId":3101427138
}
```

The following query creates a new keyset from a JSON-formatted
`STRING` `json_keyset`:

```zetasql
SELECT KEYS.KEYSET_FROM_JSON(json_keyset);
```

This returns the `json_keyset` serialized as `BYTES`, like the following:

```
\x08\x9d\x8e\x85\x82\x09\x12d\x0aX\x0a0
type.googleapis.com/google.crypto.tink.AesGcmKey\x12\"\x1a qX\xe4IG\x87\x1f\xde
\xe3)+e\x98\x0a\x1c}\xfe\x88<\x12\xeb\xc1t\xb8\x83\x1a\xcd\xa8\x97\x84g\x18\x01
\x10\x01\x18\x9d\x8e\x85\x82\x09 \x01
```

[google-crypto-tink-keyset]: https://github.com/google/tink/blob/master/proto/tink.proto

### `KEYS.KEYSET_LENGTH`

```zetasql
KEYS.KEYSET_LENGTH(keyset)
```

**Description**

Returns the number of keys in the provided keyset.

**Return Data Type**

`INT64`

**Example**

This example references a JSON-formatted STRING
called `json_keyset` that contains two keys:

```json
{
   "primaryKeyId":1354994251,
   "key":[
      {
         "keyData":{
            "keyMaterialType":"SYMMETRIC",
            "typeUrl":"type.googleapis.com/google.crypto.tink.AesGcmKey",
            "value":"GiD9sxQRgFj4aYN78vaIlxInjZkG/uvyWSY9a8GN+ELV2Q=="
         },
         "keyId":1354994251,
         "outputPrefixType":"TINK",
         "status":"ENABLED"
      }
   ],
   "key":[
      {
         "keyData":{
            "keyMaterialType":"SYMMETRIC",
            "typeUrl":"type.googleapis.com/google.crypto.tink.AesGcmKey",
            "value":"PRn76sxQRgFj4aYN00vaIlxInjZkG/uvyWSY9a2bLRm"
         },
         "keyId":852264701,
         "outputPrefixType":"TINK",
         "status":"DISABLED"
      }
   ]
}
```

The following query converts `json_keyset` to a keyset and then returns
the number of keys in the keyset:

```zetasql
SELECT KEYS.KEYSET_LENGTH(KEYS.KEYSET_FROM_JSON(json_keyset)) as key_count;

/*-----------*
 | key_count |
 +-----------+
 | 2         |
 *-----------*/
```

### `KEYS.KEYSET_TO_JSON`

```zetasql
KEYS.KEYSET_TO_JSON(keyset)
```

**Description**

Returns a JSON `STRING` representation of the input
`keyset`. The returned JSON `STRING` is compatible
with the definition of the
[google.crypto.tink.Keyset][google-crypto-tink-keyset]
protocol buffer message. You can convert the JSON
`STRING` representation back to
`BYTES` using `KEYS.KEYSET_FROM_JSON`.

**Return Data Type**

`STRING`

**Example**

The following query returns a new `'AEAD_AES_GCM_256'` keyset as a
JSON-formatted `STRING`.

```zetasql
SELECT KEYS.KEYSET_TO_JSON(KEYS.NEW_KEYSET('AEAD_AES_GCM_256'));
```

The result is a `STRING` like the following.

```json
{
  "key":[
      {
        "keyData":{
          "keyMaterialType":"SYMMETRIC",
          "typeUrl":"type.googleapis.com/google.crypto.tink.AesGcmKey",
          "value":"GiD80Z8kL6AP3iSNHhqseZGAIvq7TVQzClT7FQy8YwK3OQ=="
        },
        "keyId":3101427138,
        "outputPrefixType":"TINK",
        "status":"ENABLED"
      }
    ],
  "primaryKeyId":3101427138
}
```

[google-crypto-tink-keyset]: https://github.com/google/tink/blob/master/proto/tink.proto

### `KEYS.NEW_KEYSET`

```
KEYS.NEW_KEYSET(key_type)
```

**Description**

Returns a serialized keyset containing a new key based on `key_type`. The
returned keyset is a serialized `BYTES`
representation of
[google.crypto.tink.Keyset][google-crypto-tink-keyset]
that contains a primary cryptographic key and no additional keys. You can use
the keyset with the `AEAD.ENCRYPT`, `AEAD.DECRYPT_BYTES`, and
`AEAD.DECRYPT_STRING` functions for encryption and decryption, as well as with
the `KEYS` group of key- and keyset-related functions.

`key_type` is a `STRING` literal representation of the type of key to create.
`key_type` can't be `NULL`. `key_type` can be:

+   `AEAD_AES_GCM_256`: Creates a 256-bit key with the pseudo-random number
    generator provided by [boringSSL][boringSSL]. The key uses AES-GCM for
    encryption and decryption operations.
+   `DETERMINISTIC_AEAD_AES_SIV_CMAC_256`:
    Creates a 512-bit `AES-SIV-CMAC` key, which contains a 256-bit `AES-CTR` key
    and 256-bit `AES-CMAC` key. The `AES-SIV-CMAC` key is created with the
    pseudo-random number generator provided by [boringSSL][boringSSL]. The key
    uses AES-SIV for encryption and decryption operations.

**Return Data Type**

`BYTES`

**Example**

The following query creates a keyset for each row in `CustomerIds`, which can
subsequently be used to encrypt data. Each keyset contains a single encryption
key with randomly-generated key data. Each row in the output contains a
`customer_id` and an `'AEAD_AES_GCM_256'` key in
`BYTES`.

```zetasql
SELECT customer_id, KEYS.NEW_KEYSET('AEAD_AES_GCM_256') AS keyset
FROM (
  SELECT 1 AS customer_id UNION ALL
  SELECT 2 UNION ALL
  SELECT 3
) AS CustomerIds;
```

[boringSSL]: https://boringssl.googlesource.com/boringssl/

[google-crypto-tink-keyset]: https://github.com/google/tink/blob/master/proto/tink.proto

### `KEYS.ROTATE_KEYSET`

```zetasql
KEYS.ROTATE_KEYSET(keyset, key_type)
```

**Description**

Adds a new key to `keyset` based on `key_type`. This new key becomes the primary
cryptographic key of the new keyset. Returns the new keyset serialized as
`BYTES`.

The old primary cryptographic key from the input `keyset` remains an additional
key in the returned keyset.

The new `key_type` must match the key type of existing keys in the `keyset`.

**Return Data Type**

`BYTES`

**Example**

The following statement creates a table containing a column of unique
`customer_id` values and `'AEAD_AES_GCM_256'` keysets. Then, it creates a new
primary cryptographic key within each keyset in the source table using
`KEYS.ROTATE_KEYSET`. Each row in the output contains a `customer_id` and an
`'AEAD_AES_GCM_256'` keyset in `BYTES`.

```zetasql
WITH ExistingKeysets AS (
SELECT 1 AS customer_id, KEYS.NEW_KEYSET('AEAD_AES_GCM_256') AS keyset
    UNION ALL
  SELECT 2, KEYS.NEW_KEYSET('AEAD_AES_GCM_256') UNION ALL
  SELECT 3, KEYS.NEW_KEYSET('AEAD_AES_GCM_256')
)
SELECT customer_id, KEYS.ROTATE_KEYSET(keyset, 'AEAD_AES_GCM_256') AS keyset
FROM ExistingKeysets;
```

[aead-encryption-concepts]: https://github.com/google/zetasql/blob/master/docs/aead-encryption-concepts.md

## Aggregate functions

ZetaSQL supports the following general aggregate functions.
To learn about the syntax for aggregate function calls, see
[Aggregate function calls][agg-function-calls].

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#any_value"><code>ANY_VALUE</code></a>
</td>
  <td>
    Gets an expression for some row.
  </td>
</tr>

<tr>
  <td><a href="#approx_count_distinct"><code>APPROX_COUNT_DISTINCT</code></a>
</td>
  <td>
    Gets the approximate result for <code>COUNT(DISTINCT expression)</code>.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/approximate_aggregate_functions.md">Approximate aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#approx_quantiles"><code>APPROX_QUANTILES</code></a>
</td>
  <td>
    Gets the approximate quantile boundaries.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/approximate_aggregate_functions.md">Approximate aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#approx_top_count"><code>APPROX_TOP_COUNT</code></a>
</td>
  <td>
    Gets the approximate top elements and their approximate count.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/approximate_aggregate_functions.md">Approximate aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#approx_top_sum"><code>APPROX_TOP_SUM</code></a>
</td>
  <td>
    Gets the approximate top elements and sum, based on the approximate sum
    of an assigned weight.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/approximate_aggregate_functions.md">Approximate aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#array_agg"><code>ARRAY_AGG</code></a>
</td>
  <td>
    Gets an array of values.
    
  </td>
</tr>

<tr>
  <td><a href="#array_concat_agg"><code>ARRAY_CONCAT_AGG</code></a>
</td>
  <td>
    Concatenates arrays and returns a single array as a result.
    
  </td>
</tr>

<tr>
  <td><a href="#avg"><code>AVG</code></a>
</td>
  <td>
    Gets the average of non-<code>NULL</code> values.
    
  </td>
</tr>

<tr>
  <td><a href="#dp_avg"><code>AVG</code> (Differential Privacy)</a>
</td>
  <td>
    <code>DIFFERENTIAL_PRIVACY</code>-supported <code>AVG</code>.<br/><br/>
    Gets the differentially-private average of non-<code>NULL</code>,
    non-<code>NaN</code> values in a query with a
    <code>DIFFERENTIAL_PRIVACY</code> clause.
    <br><br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate-dp-functions.md">Differential privacy functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#bit_and"><code>BIT_AND</code></a>
</td>
  <td>
    Performs a bitwise AND operation on an expression.
    
  </td>
</tr>

<tr>
  <td><a href="#bit_or"><code>BIT_OR</code></a>
</td>
  <td>
    Performs a bitwise OR operation on an expression.
    
  </td>
</tr>

<tr>
  <td><a href="#bit_xor"><code>BIT_XOR</code></a>
</td>
  <td>
    Performs a bitwise XOR operation on an expression.
    
  </td>
</tr>

<tr>
  <td><a href="#corr"><code>CORR</code></a>
</td>
  <td>
    Computes the Pearson coefficient of correlation of a set of number pairs.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/statistical_aggregate_functions.md">Statistical aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#count"><code>COUNT</code></a>
</td>
  <td>
    Gets the number of rows in the input, or the number of rows with an
    expression evaluated to any value other than <code>NULL</code>.
  </td>
</tr>

<tr>
  <td><a href="#dp_count"><code>COUNT</code> (Differential Privacy)</a>
</td>
  <td>
    <code>DIFFERENTIAL_PRIVACY</code>-supported <code>COUNT</code>.<br/><br/>
    Signature 1: Gets the differentially-private count of rows in a query with a
    <code>DIFFERENTIAL_PRIVACY</code> clause.
    <br/>
    <br/>
    Signature 2: Gets the differentially-private count of rows with a
    non-<code>NULL</code> expression in a query with a
    <code>DIFFERENTIAL_PRIVACY</code> clause.
    <br><br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate-dp-functions.md">Differential privacy functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#countif"><code>COUNTIF</code></a>
</td>
  <td>
    Gets the number of <code>TRUE</code> values for an expression.
  </td>
</tr>

<tr>
  <td><a href="#covar_pop"><code>COVAR_POP</code></a>
</td>
  <td>
    Computes the population covariance of a set of number pairs.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/statistical_aggregate_functions.md">Statistical aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#covar_samp"><code>COVAR_SAMP</code></a>
</td>
  <td>
    Computes the sample covariance of a set of number pairs.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/statistical_aggregate_functions.md">Statistical aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#grouping"><code>GROUPING</code></a>
</td>
  <td>
    Checks if a groupable value in the <code>GROUP BY</code> clause is
    aggregated.
  </td>
</tr>

<tr>
  <td><a href="#logical_and"><code>LOGICAL_AND</code></a>
</td>
  <td>
    Gets the logical AND of all non-<code>NULL</code> expressions.
  </td>
</tr>

<tr>
  <td><a href="#logical_or"><code>LOGICAL_OR</code></a>
</td>
  <td>
    Gets the logical OR of all non-<code>NULL</code> expressions.
  </td>
</tr>

<tr>
  <td><a href="#max"><code>MAX</code></a>
</td>
  <td>
    Gets the maximum non-<code>NULL</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#min"><code>MIN</code></a>
</td>
  <td>
    Gets the minimum non-<code>NULL</code> value.
  </td>
</tr>

<tr>
  <td><a href="#dp_percentile_cont"><code>PERCENTILE_CONT</code> (Differential Privacy)</a>
</td>
  <td>
    <code>DIFFERENTIAL_PRIVACY</code>-supported <code>PERCENTILE_CONT</code>.<br/><br/>
    Computes a differentially-private percentile across privacy unit columns
    in a query with a <code>DIFFERENTIAL_PRIVACY</code> clause.
    <br><br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate-dp-functions.md">Differential privacy functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#st_extent"><code>ST_EXTENT</code></a>
</td>
  <td>
    Gets the bounding box for a group of <code>GEOGRAPHY</code> values.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/geography_functions.md">Geography functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#st_union_agg"><code>ST_UNION_AGG</code></a>
</td>
  <td>
    Aggregates over <code>GEOGRAPHY</code> values and gets their
    point set union.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/geography_functions.md">Geography functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#stddev"><code>STDDEV</code></a>
</td>
  <td>
    An alias of the <code>STDDEV_SAMP</code> function.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/statistical_aggregate_functions.md">Statistical aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#stddev_pop"><code>STDDEV_POP</code></a>
</td>
  <td>
    Computes the population (biased) standard deviation of the values.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/statistical_aggregate_functions.md">Statistical aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#stddev_samp"><code>STDDEV_SAMP</code></a>
</td>
  <td>
    Computes the sample (unbiased) standard deviation of the values.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/statistical_aggregate_functions.md">Statistical aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#string_agg"><code>STRING_AGG</code></a>
</td>
  <td>
    Concatenates non-<code>NULL</code> <code>STRING</code> or
    <code>BYTES</code> values.
    
  </td>
</tr>

<tr>
  <td><a href="#sum"><code>SUM</code></a>
</td>
  <td>
    Gets the sum of non-<code>NULL</code> values.
    
  </td>
</tr>

<tr>
  <td><a href="#dp_sum"><code>SUM</code> (Differential Privacy)</a>
</td>
  <td>
    <code>DIFFERENTIAL_PRIVACY</code>-supported <code>SUM</code>.<br/><br/>
    Gets the differentially-private sum of non-<code>NULL</code>,
    non-<code>NaN</code> values in a query with a
    <code>DIFFERENTIAL_PRIVACY</code> clause.
    <br><br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate-dp-functions.md">Differential privacy functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#var_pop"><code>VAR_POP</code></a>
</td>
  <td>
    Computes the population (biased) variance of the values.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/statistical_aggregate_functions.md">Statistical aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#dp_var_pop"><code>VAR_POP</code> (Differential Privacy)</a>
</td>
  <td>
    <code>DIFFERENTIAL_PRIVACY</code>-supported <code>VAR_POP</code> (Differential Privacy).<br/><br/>
    Computes the differentially-private population (biased) variance of values
    in a query with a <code>DIFFERENTIAL_PRIVACY</code> clause.
    <br><br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate-dp-functions.md">Differential privacy functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#var_samp"><code>VAR_SAMP</code></a>
</td>
  <td>
    Computes the sample (unbiased) variance of the values.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/statistical_aggregate_functions.md">Statistical aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#variance"><code>VARIANCE</code></a>
</td>
  <td>
    An alias of <code>VAR_SAMP</code>.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/statistical_aggregate_functions.md">Statistical aggregate functions</a>.

  </td>
</tr>

  </tbody>
</table>

### `ANY_VALUE`

```zetasql
ANY_VALUE(
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns `expression` for some row chosen from the group. Which row is chosen is
nondeterministic, not random. Returns `NULL` when the input produces no
rows. Returns `NULL` when `expression`
or `expression2` is
`NULL` for all rows in the group.

If `expression` contains any non-NULL values, then `ANY_VALUE` behaves as if
`IGNORE NULLS` is specified;
rows for which `expression` is `NULL` aren't considered and won't be
selected.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

Any

**Returned Data Types**

Matches the input data type.

**Examples**

```zetasql
SELECT ANY_VALUE(fruit) as any_value
FROM UNNEST(["apple", "banana", "pear"]) as fruit;

/*-----------*
 | any_value |
 +-----------+
 | apple     |
 *-----------*/
```

```zetasql
SELECT
  fruit,
  ANY_VALUE(fruit) OVER (ORDER BY LENGTH(fruit) ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS any_value
FROM UNNEST(["apple", "banana", "pear"]) as fruit;

/*--------+-----------*
 | fruit  | any_value |
 +--------+-----------+
 | pear   | pear      |
 | apple  | pear      |
 | banana | apple     |
 *--------+-----------*/
```

```zetasql
WITH
  Store AS (
    SELECT 20 AS sold, "apples" AS fruit
    UNION ALL
    SELECT 30 AS sold, "pears" AS fruit
    UNION ALL
    SELECT 30 AS sold, "bananas" AS fruit
    UNION ALL
    SELECT 10 AS sold, "oranges" AS fruit
  )
SELECT ANY_VALUE(fruit HAVING MAX sold) AS a_highest_selling_fruit FROM Store;

/*-------------------------*
 | a_highest_selling_fruit |
 +-------------------------+
 | pears                   |
 *-------------------------*/
```

```zetasql
WITH
  Store AS (
    SELECT 20 AS sold, "apples" AS fruit
    UNION ALL
    SELECT 30 AS sold, "pears" AS fruit
    UNION ALL
    SELECT 30 AS sold, "bananas" AS fruit
    UNION ALL
    SELECT 10 AS sold, "oranges" AS fruit
  )
SELECT ANY_VALUE(fruit HAVING MIN sold) AS a_lowest_selling_fruit FROM Store;

/*-------------------------*
 | a_lowest_selling_fruit  |
 +-------------------------+
 | oranges                 |
 *-------------------------*/
```

### `ARRAY_AGG`

```zetasql
ARRAY_AGG(
  [ DISTINCT ]
  expression
  [ { IGNORE | RESPECT } NULLS ]
  [ HAVING { MAX | MIN } expression2 ]
  [ ORDER BY key [ { ASC | DESC } ] [, ... ] ]
  [ LIMIT n ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns an ARRAY of `expression` values.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

All data types except ARRAY.

**Returned Data Types**

ARRAY

If there are zero input rows, this function returns `NULL`.

**Examples**

```zetasql
SELECT ARRAY_AGG(x) AS array_agg FROM UNNEST([2, 1,-2, 3, -2, 1, 2]) AS x;

/*-------------------------*
 | array_agg               |
 +-------------------------+
 | [2, 1, -2, 3, -2, 1, 2] |
 *-------------------------*/
```

```zetasql
SELECT ARRAY_AGG(DISTINCT x) AS array_agg
FROM UNNEST([2, 1, -2, 3, -2, 1, 2]) AS x;

/*---------------*
 | array_agg     |
 +---------------+
 | [2, 1, -2, 3] |
 *---------------*/
```

```zetasql
SELECT ARRAY_AGG(x IGNORE NULLS) AS array_agg
FROM UNNEST([NULL, 1, -2, 3, -2, 1, NULL]) AS x;

/*-------------------*
 | array_agg         |
 +-------------------+
 | [1, -2, 3, -2, 1] |
 *-------------------*/
```

```zetasql
SELECT ARRAY_AGG(x ORDER BY ABS(x)) AS array_agg
FROM UNNEST([2, 1, -2, 3, -2, 1, 2]) AS x;

/*-------------------------*
 | array_agg               |
 +-------------------------+
 | [1, 1, 2, -2, -2, 2, 3] |
 *-------------------------*/
```

```zetasql
SELECT ARRAY_AGG(x LIMIT 5) AS array_agg
FROM UNNEST([2, 1, -2, 3, -2, 1, 2]) AS x;

/*-------------------*
 | array_agg         |
 +-------------------+
 | [2, 1, -2, 3, -2] |
 *-------------------*/
```

```zetasql
WITH vals AS
  (
    SELECT 1 x UNION ALL
    SELECT -2 x UNION ALL
    SELECT 3 x UNION ALL
    SELECT -2 x UNION ALL
    SELECT 1 x
  )
SELECT ARRAY_AGG(DISTINCT x ORDER BY x) as array_agg
FROM vals;

/*------------*
 | array_agg  |
 +------------+
 | [-2, 1, 3] |
 *------------*/
```

```zetasql
WITH vals AS
  (
    SELECT 1 x, 'a' y UNION ALL
    SELECT 1 x, 'b' y UNION ALL
    SELECT 2 x, 'a' y UNION ALL
    SELECT 2 x, 'c' y
  )
SELECT x, ARRAY_AGG(y) as array_agg
FROM vals
GROUP BY x;

/*---------------*
 | x | array_agg |
 +---------------+
 | 1 | [a, b]    |
 | 2 | [a, c]    |
 *---------------*/
```

```zetasql
SELECT
  x,
  ARRAY_AGG(x) OVER (ORDER BY ABS(x)) AS array_agg
FROM UNNEST([2, 1, -2, 3, -2, 1, 2]) AS x;

/*----+-------------------------*
 | x  | array_agg               |
 +----+-------------------------+
 | 1  | [1, 1]                  |
 | 1  | [1, 1]                  |
 | 2  | [1, 1, 2, -2, -2, 2]    |
 | -2 | [1, 1, 2, -2, -2, 2]    |
 | -2 | [1, 1, 2, -2, -2, 2]    |
 | 2  | [1, 1, 2, -2, -2, 2]    |
 | 3  | [1, 1, 2, -2, -2, 2, 3] |
 *----+-------------------------*/
```

### `ARRAY_CONCAT_AGG`

```zetasql
ARRAY_CONCAT_AGG(
  expression
  [ HAVING { MAX | MIN } expression2 ]
  [ ORDER BY key [ { ASC | DESC } ] [, ... ] ]
  [ LIMIT n ]
)
```

**Description**

Concatenates elements from `expression` of type `ARRAY`, returning a single
array as a result.

This function ignores `NULL` input arrays, but respects the `NULL` elements in
non-`NULL` input arrays. Returns `NULL` if there are zero input rows or
`expression` evaluates to `NULL` for all rows.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

`ARRAY`

**Returned Data Types**

`ARRAY`

**Examples**

```zetasql
SELECT ARRAY_CONCAT_AGG(x) AS array_concat_agg FROM (
  SELECT [NULL, 1, 2, 3, 4] AS x
  UNION ALL SELECT NULL
  UNION ALL SELECT [5, 6]
  UNION ALL SELECT [7, 8, 9]
);

/*-----------------------------------*
 | array_concat_agg                  |
 +-----------------------------------+
 | [NULL, 1, 2, 3, 4, 5, 6, 7, 8, 9] |
 *-----------------------------------*/
```

```zetasql
SELECT ARRAY_CONCAT_AGG(x ORDER BY ARRAY_LENGTH(x)) AS array_concat_agg FROM (
  SELECT [1, 2, 3, 4] AS x
  UNION ALL SELECT [5, 6]
  UNION ALL SELECT [7, 8, 9]
);

/*-----------------------------------*
 | array_concat_agg                  |
 +-----------------------------------+
 | [5, 6, 7, 8, 9, 1, 2, 3, 4]       |
 *-----------------------------------*/
```

```zetasql
SELECT ARRAY_CONCAT_AGG(x LIMIT 2) AS array_concat_agg FROM (
  SELECT [1, 2, 3, 4] AS x
  UNION ALL SELECT [5, 6]
  UNION ALL SELECT [7, 8, 9]
);

/*--------------------------*
 | array_concat_agg         |
 +--------------------------+
 | [1, 2, 3, 4, 5, 6]       |
 *--------------------------*/
```

```zetasql
SELECT ARRAY_CONCAT_AGG(x ORDER BY ARRAY_LENGTH(x) LIMIT 2) AS array_concat_agg FROM (
  SELECT [1, 2, 3, 4] AS x
  UNION ALL SELECT [5, 6]
  UNION ALL SELECT [7, 8, 9]
);

/*------------------*
 | array_concat_agg |
 +------------------+
 | [5, 6, 7, 8, 9]  |
 *------------------*/
```

### `AVG`

```zetasql
AVG(
  [ DISTINCT ]
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns the average of non-`NULL` values in an aggregated group.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

This function can be used with the
[`AGGREGATION_THRESHOLD` clause][agg-threshold-clause].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

[agg-threshold-clause]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#agg_threshold_clause

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

`AVG` can be used with differential privacy. For more information, see
[Differentially private aggregate functions][dp-functions].

Caveats:

+ If the aggregated group is empty or the argument is `NULL` for all rows in
  the group, returns `NULL`.
+ If the argument is `NaN` for any row in the group, returns `NaN`.
+ If the argument is `[+|-]Infinity` for any row in the group, returns either
  `[+|-]Infinity` or `NaN`.
+ If there is numeric overflow, produces an error.
+ If a [floating-point type][floating-point-types] is returned, the result is
  [non-deterministic][non-deterministic], which means you might receive a
  different result each time you use this function.

[floating-point-types]: https://github.com/google/zetasql/blob/master/docs/data-types.md#floating_point_types

[non-deterministic]: https://github.com/google/zetasql/blob/master/docs/data-types.md#floating_point_semantics

**Supported Argument Types**

+ Any numeric input type
+ `INTERVAL`

**Returned Data Types**

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th><th><code>INTERVAL</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>INTERVAL</code></td></tr>
</tbody>

</table>

**Examples**

```zetasql
SELECT AVG(x) as avg
FROM UNNEST([0, 2, 4, 4, 5]) as x;

/*-----*
 | avg |
 +-----+
 | 3   |
 *-----*/
```

```zetasql
SELECT AVG(DISTINCT x) AS avg
FROM UNNEST([0, 2, 4, 4, 5]) AS x;

/*------*
 | avg  |
 +------+
 | 2.75 |
 *------*/
```

```zetasql
SELECT
  x,
  AVG(x) OVER (ORDER BY x ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS avg
FROM UNNEST([0, 2, NULL, 4, 4, 5]) AS x;

/*------+------*
 | x    | avg  |
 +------+------+
 | NULL | NULL |
 | 0    | 0    |
 | 2    | 1    |
 | 4    | 3    |
 | 4    | 4    |
 | 5    | 4.5  |
 *------+------*/
```

[dp-functions]: #aggregate-dp-functions

### `BIT_AND`

```zetasql
BIT_AND(
  [ DISTINCT ]
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
```

**Description**

Performs a bitwise AND operation on `expression` and returns the result.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

+ UINT32
+ UINT64
+ INT32
+ INT64

**Returned Data Types**

INT64

**Examples**

```zetasql
SELECT BIT_AND(x) as bit_and FROM UNNEST([0xF001, 0x00A1]) as x;

/*---------*
 | bit_and |
 +---------+
 | 1       |
 *---------*/
```

### `BIT_OR`

```zetasql
BIT_OR(
  [ DISTINCT ]
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
```

**Description**

Performs a bitwise OR operation on `expression` and returns the result.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

+ UINT32
+ UINT64
+ INT32
+ INT64

**Returned Data Types**

INT64

**Examples**

```zetasql
SELECT BIT_OR(x) as bit_or FROM UNNEST([0xF001, 0x00A1]) as x;

/*--------*
 | bit_or |
 +--------+
 | 61601  |
 *--------*/
```

### `BIT_XOR`

```zetasql
BIT_XOR(
  [ DISTINCT ]
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
```

**Description**

Performs a bitwise XOR operation on `expression` and returns the result.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

+ UINT32
+ UINT64
+ INT32
+ INT64

**Returned Data Types**

INT64

**Examples**

```zetasql
SELECT BIT_XOR(x) AS bit_xor FROM UNNEST([5678, 1234]) AS x;

/*---------*
 | bit_xor |
 +---------+
 | 4860    |
 *---------*/
```

```zetasql
SELECT BIT_XOR(x) AS bit_xor FROM UNNEST([1234, 5678, 1234]) AS x;

/*---------*
 | bit_xor |
 +---------+
 | 5678    |
 *---------*/
```

```zetasql
SELECT BIT_XOR(DISTINCT x) AS bit_xor FROM UNNEST([1234, 5678, 1234]) AS x;

/*---------*
 | bit_xor |
 +---------+
 | 4860    |
 *---------*/
```

### `COUNT`

```zetasql
COUNT(*)
[ OVER over_clause ]
```

```zetasql
COUNT(
  [ DISTINCT ]
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Gets the number of rows in the input or the number of rows with an
expression evaluated to any value other than `NULL`.

Note: If you're querying a large dataset, you can compute results faster and
save resources by using [HLL++ functions][hll-functions] for approximate
distinct counts. For more information, see
[Sketches][sketches].

**Definitions**

+ `*`: Use this value to get the number of all rows in the input.
+ `expression`: A value of any data type that represents the expression to
  evaluate. If `DISTINCT` is present,
  `expression` can only be a data type that is
  [groupable][groupable-data-types].
+   `DISTINCT`: To learn more, see
    [Aggregate function calls][aggregate-function-calls].
+   `HAVING { MAX | MIN }`: To learn more, see
    [Aggregate function calls][aggregate-function-calls].
+   `OVER`: To learn more, see
    [Aggregate function calls][aggregate-function-calls].
+   `over_clause`: To learn more, see
    [Aggregate function calls][aggregate-function-calls].
+   `window_specification`: To learn more, see
    [Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

[agg-threshold-clause]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#agg_threshold_clause

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Details**

To count the number of distinct values of an expression for which a
certain condition is satisfied, you can use the following recipe:

```zetasql
COUNT(DISTINCT IF(condition, expression, NULL))
```

`IF` returns the value of `expression` if `condition` is `TRUE`, or
`NULL` otherwise. The surrounding `COUNT(DISTINCT ...)` ignores the `NULL`
values, so it counts only the distinct values of `expression` for which
`condition` is `TRUE`.

To count the number of non-distinct values of an expression for which a
certain condition is satisfied, consider using the
[`COUNTIF`][countif] function.

This function with `DISTINCT` supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

`COUNT` can be used with differential privacy. For more information, see
[Differentially private aggregate functions][dp-functions].

**Return type**

`INT64`

**Examples**

You can use the `COUNT` function to return the number of rows in a table or the
number of distinct values of an expression. For example:

```zetasql
SELECT
  COUNT(*) AS count_star,
  COUNT(DISTINCT x) AS count_dist_x
FROM UNNEST([1, 4, 4, 5]) AS x;

/*------------+--------------*
 | count_star | count_dist_x |
 +------------+--------------+
 | 4          | 3            |
 *------------+--------------*/
```

```zetasql
SELECT
  x,
  COUNT(*) OVER (PARTITION BY MOD(x, 3)) AS count_star,
  COUNT(DISTINCT x) OVER (PARTITION BY MOD(x, 3)) AS count_dist_x
FROM UNNEST([1, 4, 4, 5]) AS x;

/*------+------------+--------------*
 | x    | count_star | count_dist_x |
 +------+------------+--------------+
 | 1    | 3          | 2            |
 | 4    | 3          | 2            |
 | 4    | 3          | 2            |
 | 5    | 1          | 1            |
 *------+------------+--------------*/
```

```zetasql
SELECT
  x,
  COUNT(*) OVER (PARTITION BY MOD(x, 3)) AS count_star,
  COUNT(x) OVER (PARTITION BY MOD(x, 3)) AS count_x
FROM UNNEST([1, 4, NULL, 4, 5]) AS x;

/*------+------------+---------*
 | x    | count_star | count_x |
 +------+------------+---------+
 | NULL | 1          | 0       |
 | 1    | 3          | 3       |
 | 4    | 3          | 3       |
 | 4    | 3          | 3       |
 | 5    | 1          | 1       |
 *------+------------+---------*/
```

The following query counts the number of distinct positive values of `x`:

```zetasql
SELECT COUNT(DISTINCT IF(x > 0, x, NULL)) AS distinct_positive
FROM UNNEST([1, -2, 4, 1, -5, 4, 1, 3, -6, 1]) AS x;

/*-------------------*
 | distinct_positive |
 +-------------------+
 | 3                 |
 *-------------------*/
```

The following query counts the number of distinct dates on which a certain kind
of event occurred:

```zetasql
WITH Events AS (
  SELECT DATE '2021-01-01' AS event_date, 'SUCCESS' AS event_type
  UNION ALL
  SELECT DATE '2021-01-02' AS event_date, 'SUCCESS' AS event_type
  UNION ALL
  SELECT DATE '2021-01-02' AS event_date, 'FAILURE' AS event_type
  UNION ALL
  SELECT DATE '2021-01-03' AS event_date, 'SUCCESS' AS event_type
  UNION ALL
  SELECT DATE '2021-01-04' AS event_date, 'FAILURE' AS event_type
  UNION ALL
  SELECT DATE '2021-01-04' AS event_date, 'FAILURE' AS event_type
)
SELECT
  COUNT(DISTINCT IF(event_type = 'FAILURE', event_date, NULL))
    AS distinct_dates_with_failures
FROM Events;

/*------------------------------*
 | distinct_dates_with_failures |
 +------------------------------+
 | 2                            |
 *------------------------------*/
```

The following query counts the number of distinct `id`s that exist in both
the `customers` and `vendor` tables:

```zetasql
WITH
  customers AS (
    SELECT 1934 AS id, 'a' AS team UNION ALL
    SELECT 2991, 'b' UNION ALL
    SELECT 3988, 'c'),
  vendors AS (
    SELECT 1934 AS id, 'd' AS team UNION ALL
    SELECT 2991, 'e' UNION ALL
    SELECT 4366, 'f')
SELECT
  COUNT(DISTINCT IF(id IN (SELECT id FROM customers), id, NULL)) AS result
FROM vendors;

/*--------*
 | result |
 +--------+
 | 2      |
 *--------*/
```

[sketches]: https://github.com/google/zetasql/blob/master/docs/sketches.md

[hll-functions]: #hll_functions

[countif]: https://github.com/google/zetasql/blob/master/docs/aggregate_functions.md#countif

[groupable-data-types]: https://github.com/google/zetasql/blob/master/docs/data-types.md#groupable_data_types

[dp-functions]: #aggregate-dp-functions

### `COUNTIF`

```zetasql
COUNTIF(
  [ DISTINCT ]
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Gets the number of `TRUE` values for an expression.

**Definitions**

+ `expression`: A `BOOL` value that represents the expression to evaluate.
+   `DISTINCT`: To learn more, see
    [Aggregate function calls][aggregate-function-calls].
+   `HAVING { MAX | MIN }`: To learn more, see
    [Aggregate function calls][aggregate-function-calls].
+   `OVER`: To learn more, see
    [Aggregate function calls][aggregate-function-calls].
+   `over_clause`: To learn more, see
    [Aggregate function calls][aggregate-function-calls].
+   `window_specification`: To learn more, see
    [Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

[agg-threshold-clause]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#agg_threshold_clause

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Details**

The function signature `COUNTIF(DISTINCT ...)` is generally not useful. If you
would like to use `DISTINCT`, use `COUNT` with `DISTINCT IF`. For more
information, see the [`COUNT`][count] function.

**Return type**

`INT64`

**Examples**

```zetasql
SELECT COUNTIF(x<0) AS num_negative, COUNTIF(x>0) AS num_positive
FROM UNNEST([5, -2, 3, 6, -10, -7, 4, 0]) AS x;

/*--------------+--------------*
 | num_negative | num_positive |
 +--------------+--------------+
 | 3            | 4            |
 *--------------+--------------*/
```

```zetasql
SELECT
  x,
  COUNTIF(x<0) OVER (ORDER BY ABS(x) ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS num_negative
FROM UNNEST([5, -2, 3, 6, -10, NULL, -7, 4, 0]) AS x;

/*------+--------------*
 | x    | num_negative |
 +------+--------------+
 | NULL | 0            |
 | 0    | 1            |
 | -2   | 1            |
 | 3    | 1            |
 | 4    | 0            |
 | 5    | 0            |
 | 6    | 1            |
 | -7   | 2            |
 | -10  | 2            |
 *------+--------------*/
```

[count]: https://github.com/google/zetasql/blob/master/docs/aggregate_functions.md#count

### `GROUPING`

```zetasql
GROUPING(groupable_value)
```

**Description**

If a groupable item in the [`GROUP BY` clause][group-by-clause] is aggregated
(and thus not grouped), this function returns `1`. Otherwise,
this function returns `0`.

Definitions:

+ `groupable_value`: An expression that represents a value that can be grouped
  in the `GROUP BY` clause.

Details:

The `GROUPING` function is helpful if you need to determine which rows are
produced by which grouping sets. A grouping set is a group of columns by which
rows can be grouped together. So, if you need to filter rows by
a few specific grouping sets, you can use the `GROUPING` function to identify
which grouping sets grouped which rows by creating a matrix of the results.

In addition, you can use the `GROUPING` function to determine the type of
`NULL` produced by the `GROUP BY` clause. In some cases, the `GROUP BY` clause
produces a `NULL` placeholder. This placeholder represents all groupable items
that are aggregated (not grouped) in the current grouping set. This is different
from a standard `NULL`, which can also be produced by a query.

For more information, see the following examples.

**Returned Data Type**

`INT64`

**Examples**

In the following example, it's difficult to determine which rows are grouped by
the grouping value `product_type` or `product_name`. The `GROUPING` function
makes this easier to determine.

Pay close attention to what's in the `product_type_agg` and
`product_name_agg` column matrix. This determines how the rows are grouped.

`product_type_agg` | `product_name_agg` | Notes
------------------ | -------------------| ------
1                  | 0                  | Rows are grouped by `product_name`.
0                  | 1                  | Rows are grouped by `product_type`.
0                  | 0                  | Rows are grouped by `product_type` and `product_name`.
1                  | 1                  | Grand total row.

```zetasql
WITH
  Products AS (
    SELECT 'shirt' AS product_type, 't-shirt' AS product_name, 3 AS product_count UNION ALL
    SELECT 'shirt', 't-shirt', 8 UNION ALL
    SELECT 'shirt', 'polo', 25 UNION ALL
    SELECT 'pants', 'jeans', 6
  )
SELECT
  product_type,
  product_name,
  SUM(product_count) AS product_sum,
  GROUPING(product_type) AS product_type_agg,
  GROUPING(product_name) AS product_name_agg,
FROM Products
GROUP BY GROUPING SETS(product_type, product_name, ())
ORDER BY product_name;

/*--------------+--------------+-------------+------------------+------------------+
 | product_type | product_name | product_sum | product_type_agg | product_name_agg |
 +--------------+--------------+-------------+------------------+------------------+
 | NULL         | NULL         | 42          | 1                | 1                |
 | shirt        | NULL         | 36          | 0                | 1                |
 | pants        | NULL         | 6           | 0                | 1                |
 | NULL         | jeans        | 6           | 1                | 0                |
 | NULL         | polo         | 25          | 1                | 0                |
 | NULL         | t-shirt      | 11          | 1                | 0                |
 +--------------+--------------+-------------+------------------+------------------*/
```

In the following example, it's difficult to determine
if `NULL` represents a `NULL` placeholder or a standard `NULL` value in the
`product_type` column. The `GROUPING` function makes it easier to
determine what type of `NULL` is being produced. If
`product_type_is_aggregated` is `1`, the `NULL` value for
the `product_type` column is a `NULL` placeholder.

```zetasql
WITH
  Products AS (
    SELECT 'shirt' AS product_type, 't-shirt' AS product_name, 3 AS product_count UNION ALL
    SELECT 'shirt', 't-shirt', 8 UNION ALL
    SELECT NULL, 'polo', 25 UNION ALL
    SELECT 'pants', 'jeans', 6
  )
SELECT
  product_type,
  product_name,
  SUM(product_count) AS product_sum,
  GROUPING(product_type) AS product_type_is_aggregated
FROM Products
GROUP BY GROUPING SETS(product_type, product_name)
ORDER BY product_name;

/*--------------+--------------+-------------+----------------------------+
 | product_type | product_name | product_sum | product_type_is_aggregated |
 +--------------+--------------+-------------+----------------------------+
 | shirt        | NULL         | 11          | 0                          |
 | NULL         | NULL         | 25          | 0                          |
 | pants        | NULL         | 6           | 0                          |
 | NULL         | jeans        | 6           | 1                          |
 | NULL         | polo         | 25          | 1                          |
 | NULL         | t-shirt      | 11          | 1                          |
 +--------------+--------------+-------------+----------------------------*/
```

[group-by-clause]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#group_by_clause

### `LOGICAL_AND`

```zetasql
LOGICAL_AND(
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns the logical AND of all non-`NULL` expressions. Returns `NULL` if there
are zero input rows or `expression` evaluates to `NULL` for all rows.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

This function can be used with the
[`AGGREGATION_THRESHOLD` clause][agg-threshold-clause].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

[agg-threshold-clause]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#agg_threshold_clause

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

`BOOL`

**Return Data Types**

`BOOL`

**Examples**

`LOGICAL_AND` returns `FALSE` because not all of the values in the array are
less than 3.

```zetasql
SELECT LOGICAL_AND(x < 3) AS logical_and FROM UNNEST([1, 2, 4]) AS x;

/*-------------*
 | logical_and |
 +-------------+
 | FALSE       |
 *-------------*/
```

### `LOGICAL_OR`

```zetasql
LOGICAL_OR(
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns the logical OR of all non-`NULL` expressions. Returns `NULL` if there
are zero input rows or `expression` evaluates to `NULL` for all rows.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

This function can be used with the
[`AGGREGATION_THRESHOLD` clause][agg-threshold-clause].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

[agg-threshold-clause]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#agg_threshold_clause

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

`BOOL`

**Return Data Types**

`BOOL`

**Examples**

`LOGICAL_OR` returns `TRUE` because at least one of the values in the array is
less than 3.

```zetasql
SELECT LOGICAL_OR(x < 3) AS logical_or FROM UNNEST([1, 2, 4]) AS x;

/*------------*
 | logical_or |
 +------------+
 | TRUE       |
 *------------*/
```

### `MAX`

```zetasql
MAX(
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns the maximum non-`NULL` value in an aggregated group.

Caveats:

+ If the aggregated group is empty or the argument is `NULL` for all rows in
  the group, returns `NULL`.
+ If the argument is `NaN` for any row in the group, returns `NaN`.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

This function supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

**Supported Argument Types**

Any [orderable data type][agg-data-type-properties] except for `ARRAY`.

**Return Data Types**

The data type of the input values.

**Examples**

```zetasql
SELECT MAX(x) AS max
FROM UNNEST([8, 37, 55, 4]) AS x;

/*-----*
 | max |
 +-----+
 | 55  |
 *-----*/
```

```zetasql
SELECT x, MAX(x) OVER (PARTITION BY MOD(x, 2)) AS max
FROM UNNEST([8, NULL, 37, 55, NULL, 4]) AS x;

/*------+------*
 | x    | max  |
 +------+------+
 | NULL | NULL |
 | NULL | NULL |
 | 8    | 8    |
 | 4    | 8    |
 | 37   | 55   |
 | 55   | 55   |
 *------+------*/
```

[agg-data-type-properties]: https://github.com/google/zetasql/blob/master/docs/data-types.md#data_type_properties

### `MIN`

```zetasql
MIN(
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns the minimum non-`NULL` value in an aggregated group.

Caveats:

+ If the aggregated group is empty or the argument is `NULL` for all rows in
  the group, returns `NULL`.
+ If the argument is `NaN` for any row in the group, returns `NaN`.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

This function supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

**Supported Argument Types**

Any [orderable data type][agg-data-type-properties] except for `ARRAY`.

**Return Data Types**

The data type of the input values.

**Examples**

```zetasql
SELECT MIN(x) AS min
FROM UNNEST([8, 37, 4, 55]) AS x;

/*-----*
 | min |
 +-----+
 | 4   |
 *-----*/
```

```zetasql
SELECT x, MIN(x) OVER (PARTITION BY MOD(x, 2)) AS min
FROM UNNEST([8, NULL, 37, 4, NULL, 55]) AS x;

/*------+------*
 | x    | min  |
 +------+------+
 | NULL | NULL |
 | NULL | NULL |
 | 8    | 4    |
 | 4    | 4    |
 | 37   | 37   |
 | 55   | 37   |
 *------+------*/
```

[agg-data-type-properties]: https://github.com/google/zetasql/blob/master/docs/data-types.md#data_type_properties

### `STRING_AGG`

```zetasql
STRING_AGG(
  [ DISTINCT ]
  expression [, delimiter]
  [ HAVING { MAX | MIN } expression2 ]
  [ ORDER BY key [ { ASC | DESC } ] [, ... ] ]
  [ LIMIT n ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns a value (either `STRING` or `BYTES`) obtained by concatenating
non-`NULL` values. Returns `NULL` if there are zero input rows or `expression`
evaluates to `NULL` for all rows.

If a `delimiter` is specified, concatenated values are separated by that
delimiter; otherwise, a comma is used as a delimiter.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

Either `STRING` or `BYTES`.

**Return Data Types**

Either `STRING` or `BYTES`.

**Examples**

```zetasql
SELECT STRING_AGG(fruit) AS string_agg
FROM UNNEST(["apple", NULL, "pear", "banana", "pear"]) AS fruit;

/*------------------------*
 | string_agg             |
 +------------------------+
 | apple,pear,banana,pear |
 *------------------------*/
```

```zetasql
SELECT STRING_AGG(fruit, " & ") AS string_agg
FROM UNNEST(["apple", "pear", "banana", "pear"]) AS fruit;

/*------------------------------*
 | string_agg                   |
 +------------------------------+
 | apple & pear & banana & pear |
 *------------------------------*/
```

```zetasql
SELECT STRING_AGG(DISTINCT fruit, " & ") AS string_agg
FROM UNNEST(["apple", "pear", "banana", "pear"]) AS fruit;

/*-----------------------*
 | string_agg            |
 +-----------------------+
 | apple & pear & banana |
 *-----------------------*/
```

```zetasql
SELECT STRING_AGG(fruit, " & " ORDER BY LENGTH(fruit)) AS string_agg
FROM UNNEST(["apple", "pear", "banana", "pear"]) AS fruit;

/*------------------------------*
 | string_agg                   |
 +------------------------------+
 | pear & pear & apple & banana |
 *------------------------------*/
```

```zetasql
SELECT STRING_AGG(fruit, " & " LIMIT 2) AS string_agg
FROM UNNEST(["apple", "pear", "banana", "pear"]) AS fruit;

/*--------------*
 | string_agg   |
 +--------------+
 | apple & pear |
 *--------------*/
```

```zetasql
SELECT STRING_AGG(DISTINCT fruit, " & " ORDER BY fruit DESC LIMIT 2) AS string_agg
FROM UNNEST(["apple", "pear", "banana", "pear"]) AS fruit;

/*---------------*
 | string_agg    |
 +---------------+
 | pear & banana |
 *---------------*/
```

```zetasql
SELECT
  fruit,
  STRING_AGG(fruit, " & ") OVER (ORDER BY LENGTH(fruit)) AS string_agg
FROM UNNEST(["apple", NULL, "pear", "banana", "pear"]) AS fruit;

/*--------+------------------------------*
 | fruit  | string_agg                   |
 +--------+------------------------------+
 | NULL   | NULL                         |
 | pear   | pear & pear                  |
 | pear   | pear & pear                  |
 | apple  | pear & pear & apple          |
 | banana | pear & pear & apple & banana |
 *--------+------------------------------*/
```

### `SUM`

```zetasql
SUM(
  [ DISTINCT ]
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns the sum of non-`NULL` values in an aggregated group.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

This function can be used with the
[`AGGREGATION_THRESHOLD` clause][agg-threshold-clause].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

[agg-threshold-clause]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#agg_threshold_clause

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

`SUM` can be used with differential privacy. For more information, see
[Differentially private aggregate functions][dp-functions].

Caveats:

+ If the aggregated group is empty or the argument is `NULL` for all rows in
  the group, returns `NULL`.
+ If the argument is `NaN` for any row in the group, returns `NaN`.
+ If the argument is `[+|-]Infinity` for any row in the group, returns either
  `[+|-]Infinity` or `NaN`.
+ If there is numeric overflow, produces an error.
+ If a [floating-point type][floating-point-types] is returned, the result is
  [non-deterministic][non-deterministic], which means you might receive a
  different result each time you use this function.

[floating-point-types]: https://github.com/google/zetasql/blob/master/docs/data-types.md#floating_point_types

[non-deterministic]: https://github.com/google/zetasql/blob/master/docs/data-types.md#floating_point_semantics

**Supported Argument Types**

+ Any supported numeric data type
+ `INTERVAL`

**Return Data Types**

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th><th><code>INTERVAL</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>INTERVAL</code></td></tr>
</tbody>

</table>

**Examples**

```zetasql
SELECT SUM(x) AS sum
FROM UNNEST([1, 2, 3, 4, 5, 4, 3, 2, 1]) AS x;

/*-----*
 | sum |
 +-----+
 | 25  |
 *-----*/
```

```zetasql
SELECT SUM(DISTINCT x) AS sum
FROM UNNEST([1, 2, 3, 4, 5, 4, 3, 2, 1]) AS x;

/*-----*
 | sum |
 +-----+
 | 15  |
 *-----*/
```

```zetasql
SELECT
  x,
  SUM(x) OVER (PARTITION BY MOD(x, 3)) AS sum
FROM UNNEST([1, 2, 3, 4, 5, 4, 3, 2, 1]) AS x;

/*---+-----*
 | x | sum |
 +---+-----+
 | 3 | 6   |
 | 3 | 6   |
 | 1 | 10  |
 | 4 | 10  |
 | 4 | 10  |
 | 1 | 10  |
 | 2 | 9   |
 | 5 | 9   |
 | 2 | 9   |
 *---+-----*/
```

```zetasql
SELECT
  x,
  SUM(DISTINCT x) OVER (PARTITION BY MOD(x, 3)) AS sum
FROM UNNEST([1, 2, 3, 4, 5, 4, 3, 2, 1]) AS x;

/*---+-----*
 | x | sum |
 +---+-----+
 | 3 | 3   |
 | 3 | 3   |
 | 1 | 5   |
 | 4 | 5   |
 | 4 | 5   |
 | 1 | 5   |
 | 2 | 7   |
 | 5 | 7   |
 | 2 | 7   |
 *---+-----*/
```

```zetasql
SELECT SUM(x) AS sum
FROM UNNEST([]) AS x;

/*------*
 | sum  |
 +------+
 | NULL |
 *------*/
```

[dp-functions]: #aggregate-dp-functions

[agg-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

## Approximate aggregate functions

ZetaSQL supports approximate aggregate functions.
To learn about the syntax for aggregate function calls, see
[Aggregate function calls][agg-function-calls].

Approximate aggregate functions are scalable in terms of memory usage and time,
but produce approximate results instead of exact results. These functions
typically require less memory than [exact aggregation functions][aggregate-functions-reference]
like `COUNT(DISTINCT ...)`, but also introduce statistical uncertainty.
This makes approximate aggregation appropriate for large data streams for
which linear memory usage is impractical, as well as for data that is
already approximate.

The approximate aggregate functions in this section work directly on the
input data, rather than an intermediate estimation of the data. These functions
_don't allow_ users to specify the precision for the estimation with
sketches. If you would like to specify precision with sketches, see:

+  [HyperLogLog++ functions][hll-functions] to estimate cardinality.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#approx_count_distinct"><code>APPROX_COUNT_DISTINCT</code></a>
</td>
  <td>
    Gets the approximate result for <code>COUNT(DISTINCT expression)</code>.
    
  </td>
</tr>

<tr>
  <td><a href="#approx_quantiles"><code>APPROX_QUANTILES</code></a>
</td>
  <td>
    Gets the approximate quantile boundaries.
    
  </td>
</tr>

<tr>
  <td><a href="#approx_top_count"><code>APPROX_TOP_COUNT</code></a>
</td>
  <td>
    Gets the approximate top elements and their approximate count.
    
  </td>
</tr>

<tr>
  <td><a href="#approx_top_sum"><code>APPROX_TOP_SUM</code></a>
</td>
  <td>
    Gets the approximate top elements and sum, based on the approximate sum
    of an assigned weight.
    
  </td>
</tr>

  </tbody>
</table>

### `APPROX_COUNT_DISTINCT`

```zetasql
APPROX_COUNT_DISTINCT(
  expression
)
```

**Description**

Returns the approximate result for `COUNT(DISTINCT expression)`. The value
returned is a statistical estimate, not necessarily the actual value.

This function is less accurate than `COUNT(DISTINCT expression)`, but performs
better on huge input.

**Supported Argument Types**

Any data type **except**:

+ `ARRAY`
+ `STRUCT`
+ `PROTO`

**Returned Data Types**

`INT64`

**Examples**

```zetasql
SELECT APPROX_COUNT_DISTINCT(x) as approx_distinct
FROM UNNEST([0, 1, 1, 2, 3, 5]) as x;

/*-----------------*
 | approx_distinct |
 +-----------------+
 | 5               |
 *-----------------*/
```

### `APPROX_QUANTILES`

```zetasql
APPROX_QUANTILES(
  [ DISTINCT ]
  expression, number
  [ { IGNORE | RESPECT } NULLS ]
  [ HAVING { MAX | MIN } expression2 ]
)
```

**Description**

Returns the approximate boundaries for a group of `expression` values, where
`number` represents the number of quantiles to create. This function returns an
array of `number` + 1 elements, sorted in ascending order, where the
first element is the approximate minimum and the last element is the approximate
maximum.

Returns `NULL` if there are zero input rows or `expression` evaluates to
`NULL` for all rows.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

+ `expression`: Any supported data type **except**:

  + `ARRAY`
  + `STRUCT`
  + `PROTO`
+ `number`: `INT64` literal or query parameter.

**Returned Data Types**

`ARRAY<T>` where `T` is the type specified by `expression`.

**Examples**

```zetasql
SELECT APPROX_QUANTILES(x, 2) AS approx_quantiles
FROM UNNEST([1, 1, 1, 4, 5, 6, 7, 8, 9, 10]) AS x;

/*------------------*
 | approx_quantiles |
 +------------------+
 | [1, 5, 10]       |
 *------------------*/
```

```zetasql
SELECT APPROX_QUANTILES(x, 100)[OFFSET(90)] AS percentile_90
FROM UNNEST([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) AS x;

/*---------------*
 | percentile_90 |
 +---------------+
 | 9             |
 *---------------*/
```

```zetasql
SELECT APPROX_QUANTILES(DISTINCT x, 2) AS approx_quantiles
FROM UNNEST([1, 1, 1, 4, 5, 6, 7, 8, 9, 10]) AS x;

/*------------------*
 | approx_quantiles |
 +------------------+
 | [1, 6, 10]       |
 *------------------*/
```

```zetasql
SELECT APPROX_QUANTILES(x, 2 RESPECT NULLS) AS approx_quantiles
FROM UNNEST([NULL, NULL, 1, 1, 1, 4, 5, 6, 7, 8, 9, 10]) AS x;

/*------------------*
 | approx_quantiles |
 +------------------+
 | [NULL, 4, 10]    |
 *------------------*/
```

```zetasql
SELECT APPROX_QUANTILES(DISTINCT x, 2 RESPECT NULLS) AS approx_quantiles
FROM UNNEST([NULL, NULL, 1, 1, 1, 4, 5, 6, 7, 8, 9, 10]) AS x;

/*------------------*
 | approx_quantiles |
 +------------------+
 | [NULL, 6, 10]    |
 *------------------*/
```

### `APPROX_TOP_COUNT`

```zetasql
APPROX_TOP_COUNT(
  expression, number
  [ HAVING { MAX | MIN } expression2 ]
)
```

**Description**

Returns the approximate top elements of `expression` as an array of `STRUCT`s.
The `number` parameter specifies the number of elements returned.

Each `STRUCT` contains two fields. The first field (named `value`) contains an
input value. The second field (named `count`) contains an `INT64` specifying the
number of times the value was returned.

Returns `NULL` if there are zero input rows.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

+ `expression`: Any data type that the `GROUP BY` clause supports.
+ `number`: `INT64` literal or query parameter.

**Returned Data Types**

`ARRAY<STRUCT>`

**Examples**

```zetasql
SELECT APPROX_TOP_COUNT(x, 2) as approx_top_count
FROM UNNEST(["apple", "apple", "pear", "pear", "pear", "banana"]) as x;

/*-------------------------*
 | approx_top_count        |
 +-------------------------+
 | [{pear, 3}, {apple, 2}] |
 *-------------------------*/
```

**NULL handling**

`APPROX_TOP_COUNT` doesn't ignore `NULL`s in the input. For example:

```zetasql
SELECT APPROX_TOP_COUNT(x, 2) as approx_top_count
FROM UNNEST([NULL, "pear", "pear", "pear", "apple", NULL]) as x;

/*------------------------*
 | approx_top_count       |
 +------------------------+
 | [{pear, 3}, {NULL, 2}] |
 *------------------------*/
```

### `APPROX_TOP_SUM`

```zetasql
APPROX_TOP_SUM(
  expression, weight, number
  [ HAVING { MAX | MIN } expression2 ]
)
```

**Description**

Returns the approximate top elements of `expression`, ordered by the sum of the
`weight` values provided for each unique value of `expression`. The `number`
parameter specifies the number of elements returned.

If the `weight` input is negative or `NaN`, this function returns an error.

The elements are returned as an array of `STRUCT`s.
Each `STRUCT` contains two fields: `value` and `sum`.
The `value` field contains the value of the input expression. The `sum` field is
the same type as `weight`, and is the approximate sum of the input weight
associated with the `value` field.

Returns `NULL` if there are zero input rows.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

+ `expression`: Any data type that the `GROUP BY` clause supports.
+ `weight`: One of the following:

  + `INT64`
  + `UINT64`
  + `NUMERIC`
  + `BIGNUMERIC`
  + `DOUBLE`
+ `number`: `INT64` literal or query parameter.

**Returned Data Types**

`ARRAY<STRUCT>`

**Examples**

```zetasql
SELECT APPROX_TOP_SUM(x, weight, 2) AS approx_top_sum FROM
UNNEST([
  STRUCT("apple" AS x, 3 AS weight),
  ("pear", 2),
  ("apple", 0),
  ("banana", 5),
  ("pear", 4)
]);

/*--------------------------*
 | approx_top_sum           |
 +--------------------------+
 | [{pear, 6}, {banana, 5}] |
 *--------------------------*/
```

**NULL handling**

`APPROX_TOP_SUM` doesn't ignore `NULL` values for the `expression` and `weight`
parameters.

```zetasql
SELECT APPROX_TOP_SUM(x, weight, 2) AS approx_top_sum FROM
UNNEST([STRUCT("apple" AS x, NULL AS weight), ("pear", 0), ("pear", NULL)]);

/*----------------------------*
 | approx_top_sum             |
 +----------------------------+
 | [{pear, 0}, {apple, NULL}] |
 *----------------------------*/
```

```zetasql
SELECT APPROX_TOP_SUM(x, weight, 2) AS approx_top_sum FROM
UNNEST([STRUCT("apple" AS x, 0 AS weight), (NULL, 2)]);

/*-------------------------*
 | approx_top_sum          |
 +-------------------------+
 | [{NULL, 2}, {apple, 0}] |
 *-------------------------*/
```

```zetasql
SELECT APPROX_TOP_SUM(x, weight, 2) AS approx_top_sum FROM
UNNEST([STRUCT("apple" AS x, 0 AS weight), (NULL, NULL)]);

/*----------------------------*
 | approx_top_sum             |
 +----------------------------+
 | [{apple, 0}, {NULL, NULL}] |
 *----------------------------*/
```

[hll-functions]: #hll_functions

[aggregate-functions-reference]: #aggregate_functions

[agg-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

## Array functions

ZetaSQL supports the following array functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#array"><code>ARRAY</code></a>
</td>
  <td>
    Produces an array with one element for each row in a subquery.
  </td>
</tr>

<tr>
  <td><a href="#array_agg"><code>ARRAY_AGG</code></a>
</td>
  <td>
    Gets an array of values.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate_functions.md">Aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#array_avg"><code>ARRAY_AVG</code></a>
</td>
  <td>
    Gets the average of non-<code>NULL</code> values in an array.
  </td>
</tr>

<tr>
  <td><a href="#array_concat"><code>ARRAY_CONCAT</code></a>
</td>
  <td>
    Concatenates one or more arrays with the same element type into a
    single array.
  </td>
</tr>

<tr>
  <td><a href="#array_concat_agg"><code>ARRAY_CONCAT_AGG</code></a>
</td>
  <td>
    Concatenates arrays and returns a single array as a result.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate_functions.md">Aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#array_filter"><code>ARRAY_FILTER</code></a>
</td>
  <td>
    Takes an array, filters out unwanted elements, and returns the results
    in a new array.
  </td>
</tr>

<tr>
  <td><a href="#array_first"><code>ARRAY_FIRST</code></a>
</td>
  <td>
    Gets the first element in an array.
  </td>
</tr>

<tr>
  <td><a href="#array_includes"><code>ARRAY_INCLUDES</code></a>
</td>
  <td>
    Checks if there is an element in the array that is
    equal to a search value.
  </td>
</tr>

<tr>
  <td><a href="#array_includes_all"><code>ARRAY_INCLUDES_ALL</code></a>
</td>
  <td>
    Checks if all search values are in an array.
  </td>
</tr>

<tr>
  <td><a href="#array_includes_any"><code>ARRAY_INCLUDES_ANY</code></a>
</td>
  <td>
    Checks if any search values are in an array.
  </td>
</tr>

<tr>
  <td><a href="#array_is_distinct"><code>ARRAY_IS_DISTINCT</code></a>
</td>
  <td>
    Checks if an array contains no repeated elements.
  </td>
</tr>

<tr>
  <td><a href="#array_last"><code>ARRAY_LAST</code></a>
</td>
  <td>
    Gets the last element in an array.
  </td>
</tr>

<tr>
  <td><a href="#array_length"><code>ARRAY_LENGTH</code></a>
</td>
  <td>
    Gets the number of elements in an array.
  </td>
</tr>

<tr>
  <td><a href="#array_max"><code>ARRAY_MAX</code></a>
</td>
  <td>
    Gets the maximum non-<code>NULL</code> value in an array.
  </td>
</tr>

<tr>
  <td><a href="#array_min"><code>ARRAY_MIN</code></a>
</td>
  <td>
    Gets the minimum non-<code>NULL</code> value in an array.
  </td>
</tr>

<tr>
  <td><a href="#array_reverse"><code>ARRAY_REVERSE</code></a>
</td>
  <td>
    Reverses the order of elements in an array.
  </td>
</tr>

<tr>
  <td><a href="#array_slice"><code>ARRAY_SLICE</code></a>
</td>
  <td>
    Produces an array containing zero or more consecutive elements from an
    input array.
  </td>
</tr>

<tr>
  <td><a href="#array_sum"><code>ARRAY_SUM</code></a>
</td>
  <td>
    Gets the sum of non-<code>NULL</code> values in an array.
  </td>
</tr>

<tr>
  <td><a href="#array_to_string"><code>ARRAY_TO_STRING</code></a>
</td>
  <td>
    Produces a concatenation of the elements in an array as a
    <code>STRING</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#array_transform"><code>ARRAY_TRANSFORM</code></a>
</td>
  <td>
    Transforms the elements of an array, and returns the results in a new
    array.
  </td>
</tr>

<tr>
  <td><a href="#array_zip"><code>ARRAY_ZIP</code></a>
</td>
  <td>
    Combines elements from two to four arrays into one array.
  </td>
</tr>

<tr>
  <td><a href="#flatten"><code>FLATTEN</code></a>
</td>
  <td>
    Flattens arrays of nested data to create a single flat array.
  </td>
</tr>

<tr>
  <td><a href="#generate_array"><code>GENERATE_ARRAY</code></a>
</td>
  <td>
    Generates an array of values in a range.
  </td>
</tr>

<tr>
  <td><a href="#generate_date_array"><code>GENERATE_DATE_ARRAY</code></a>
</td>
  <td>
    Generates an array of dates in a range.
    
  </td>
</tr>

<tr>
  <td><a href="#generate_range_array"><code>GENERATE_RANGE_ARRAY</code></a>
</td>
  <td>
    Splits a range into an array of subranges.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/range-functions.md">Range functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#generate_timestamp_array"><code>GENERATE_TIMESTAMP_ARRAY</code></a>
</td>
  <td>
    Generates an array of timestamps in a range.
    
  </td>
</tr>

<tr>
  <td><a href="#json_array"><code>JSON_ARRAY</code></a>
</td>
  <td>
    Creates a JSON array.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#json_array_append"><code>JSON_ARRAY_APPEND</code></a>
</td>
  <td>
    Appends JSON data to the end of a JSON array.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#json_array_insert"><code>JSON_ARRAY_INSERT</code></a>
</td>
  <td>
    Inserts JSON data into a JSON array.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#json_extract_array"><code>JSON_EXTRACT_ARRAY</code></a>
</td>
  <td>
    (Deprecated)
    Extracts a JSON array and converts it to
    a SQL <code>ARRAY&lt;JSON-formatted STRING&gt;</code>
     or
    <code>ARRAY&lt;JSON&gt;</code>
    
    value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#json_extract_string_array"><code>JSON_EXTRACT_STRING_ARRAY</code></a>
</td>
  <td>
    (Deprecated)
    Extracts a JSON array of scalar values and converts it to a SQL
    <code>ARRAY&lt;STRING&gt;</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#json_query_array"><code>JSON_QUERY_ARRAY</code></a>
</td>
  <td>
    Extracts a JSON array and converts it to
    a SQL <code>ARRAY&lt;JSON-formatted STRING&gt;</code>
     or
    <code>ARRAY&lt;JSON&gt;</code>
    
    value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#json_value_array"><code>JSON_VALUE_ARRAY</code></a>
</td>
  <td>
    Extracts a JSON array of scalar values and converts it to a SQL
    <code>ARRAY&lt;STRING&gt;</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#range_bucket"><code>RANGE_BUCKET</code></a>
</td>
  <td>
    Scans through a sorted array and returns the 0-based position
    of a point's upper bound.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/mathematical_functions.md">Mathematical functions</a>.

  </td>
</tr>

  </tbody>
</table>

### `ARRAY`

```zetasql
ARRAY(subquery)
```

**Description**

The `ARRAY` function returns an `ARRAY` with one element for each row in a
[subquery][subqueries].

If `subquery` produces a
[SQL table][datamodel-sql-tables],
the table must have exactly one column. Each element in the output `ARRAY` is
the value of the single column of a row in the table.

If `subquery` produces a
[value table][datamodel-value-tables],
then each element in the output `ARRAY` is the entire corresponding row of the
value table.

**Constraints**

+ Subqueries are unordered, so the elements of the output `ARRAY` aren't
guaranteed to preserve any order in the source table for the subquery. However,
if the subquery includes an `ORDER BY` clause, the `ARRAY` function will return
an `ARRAY` that honors that clause.
+ If the subquery returns more than one column, the `ARRAY` function returns an
error.
+ If the subquery returns an `ARRAY` typed column or `ARRAY` typed rows, the
  `ARRAY` function returns an error that ZetaSQL doesn't support
  `ARRAY`s with elements of type
  [`ARRAY`][array-data-type].
+ If the subquery returns zero rows, the `ARRAY` function returns an empty
`ARRAY`. It never returns a `NULL` `ARRAY`.

**Return type**

`ARRAY`

**Examples**

```zetasql
SELECT ARRAY
  (SELECT 1 UNION ALL
   SELECT 2 UNION ALL
   SELECT 3) AS new_array;

/*-----------*
 | new_array |
 +-----------+
 | [1, 2, 3] |
 *-----------*/
```

To construct an `ARRAY` from a subquery that contains multiple
columns, change the subquery to use `SELECT AS STRUCT`. Now
the `ARRAY` function will return an `ARRAY` of `STRUCT`s. The `ARRAY` will
contain one `STRUCT` for each row in the subquery, and each of these `STRUCT`s
will contain a field for each column in that row.

```zetasql
SELECT
  ARRAY
    (SELECT AS STRUCT 1, 2, 3
     UNION ALL SELECT AS STRUCT 4, 5, 6) AS new_array;

/*------------------------*
 | new_array              |
 +------------------------+
 | [{1, 2, 3}, {4, 5, 6}] |
 *------------------------*/
```

Similarly, to construct an `ARRAY` from a subquery that contains
one or more `ARRAY`s, change the subquery to use `SELECT AS STRUCT`.

```zetasql
SELECT ARRAY
  (SELECT AS STRUCT [1, 2, 3] UNION ALL
   SELECT AS STRUCT [4, 5, 6]) AS new_array;

/*----------------------------*
 | new_array                  |
 +----------------------------+
 | [{[1, 2, 3]}, {[4, 5, 6]}] |
 *----------------------------*/
```

[subqueries]: https://github.com/google/zetasql/blob/master/docs/subqueries.md

[datamodel-sql-tables]: https://github.com/google/zetasql/blob/master/docs/data-model.md#standard_sql_tables

[datamodel-value-tables]: https://github.com/google/zetasql/blob/master/docs/data-model.md#value_tables

[array-data-type]: https://github.com/google/zetasql/blob/master/docs/data-types.md#array_type

### `ARRAY_AVG`

```zetasql
ARRAY_AVG(input_array)
```

**Description**

Returns the average of non-`NULL` values in an array.

Caveats:

+ If the array is `NULL`, empty, or contains only `NULL`s, returns
  `NULL`.
+ If the array contains `NaN`, returns `NaN`.
+ If the array contains `[+|-]Infinity`, returns either `[+|-]Infinity`
  or `NaN`.
+ If there is numeric overflow, produces an error.
+ If a [floating-point type][floating-point-types] is returned, the result is
  [non-deterministic][non-deterministic], which means you might receive a
  different result each time you use this function.

[floating-point-types]: https://github.com/google/zetasql/blob/master/docs/data-types.md#floating_point_types

[non-deterministic]: https://github.com/google/zetasql/blob/master/docs/data-types.md#floating_point_semantics

**Supported Argument Types**

In the input array, `ARRAY<T>`, `T` can represent one of the following
data types:

+ Any numeric input type
+ `INTERVAL`

**Return type**

The return type depends upon `T` in the input array:

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th><th><code>INTERVAL</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>INTERVAL</code></td></tr>
</tbody>

</table>

**Examples**

```zetasql
SELECT ARRAY_AVG([0, 2, NULL, 4, 4, 5]) as avg

/*-----*
 | avg |
 +-----+
 | 3   |
 *-----*/
```

### `ARRAY_CONCAT`

```zetasql
ARRAY_CONCAT(array_expression[, ...])
```

**Description**

Concatenates one or more arrays with the same element type into a single array.

The function returns `NULL` if any input argument is `NULL`.

Note: You can also use the [|| concatenation operator][array-link-to-operators]
to concatenate arrays.

**Return type**

`ARRAY`

**Examples**

```zetasql
SELECT ARRAY_CONCAT([1, 2], [3, 4], [5, 6]) as count_to_six;

/*--------------------------------------------------*
 | count_to_six                                     |
 +--------------------------------------------------+
 | [1, 2, 3, 4, 5, 6]                               |
 *--------------------------------------------------*/
```

[array-link-to-operators]: #operators

### `ARRAY_FILTER`

```zetasql
ARRAY_FILTER(array_expression, lambda_expression)

lambda_expression:
  {
    element_alias -> boolean_expression
    | (element_alias, index_alias) -> boolean_expression
  }
```

**Description**

Takes an array, filters out unwanted elements, and returns the results in a new
array.

+   `array_expression`: The array to filter.
+   `lambda_expression`: Each element in `array_expression` is evaluated against
    the [lambda expression][lambda-definition]. If the expression evaluates to
    `FALSE` or `NULL`, the element is removed from the resulting array.
+   `element_alias`: An alias that represents an array element.
+   `index_alias`: An alias that represents the zero-based offset of the array
    element.
+   `boolean_expression`: The predicate used to filter the array elements.

Returns `NULL` if the `array_expression` is `NULL`.

**Return type**

ARRAY

**Example**

```zetasql
SELECT
  ARRAY_FILTER([1 ,2, 3], e -> e > 1) AS a1,
  ARRAY_FILTER([0, 2, 3], (e, i) -> e > i) AS a2;

/*-------+-------*
 | a1    | a2    |
 +-------+-------+
 | [2,3] | [2,3] |
 *-------+-------*/
```

[lambda-definition]: https://github.com/google/zetasql/blob/master/docs/functions-reference.md#lambdas

### `ARRAY_FIRST`

```zetasql
ARRAY_FIRST(array_expression)
```

**Description**

Takes an array and returns the first element in the array.

Produces an error if the array is empty.

Returns `NULL` if `array_expression` is `NULL`.

Note: To get the last element in an array, see [`ARRAY_LAST`][array-last].

**Return type**

Matches the data type of elements in `array_expression`.

**Example**

```zetasql
SELECT ARRAY_FIRST(['a','b','c','d']) as first_element

/*---------------*
 | first_element |
 +---------------+
 | a             |
 *---------------*/
```

[array-last]: #array_last

### `ARRAY_INCLUDES`

+   [Signature 1](#array_includes_signature1):
    `ARRAY_INCLUDES(array_to_search, search_value)`
+   [Signature 2](#array_includes_signature2):
    `ARRAY_INCLUDES(array_to_search, lambda_expression)`

#### Signature 1 
<a id="array_includes_signature1"></a>

```zetasql
ARRAY_INCLUDES(array_to_search, search_value)
```

**Description**

Takes an array and returns `TRUE` if there is an element in the array that is
equal to the search_value.

+   `array_to_search`: The array to search.
+   `search_value`: The element to search for in the array.

Returns `NULL` if `array_to_search` or `search_value` is `NULL`.

**Return type**

`BOOL`

**Example**

In the following example, the query first checks to see if `0` exists in an
array. Then the query checks to see if `1` exists in an array.

```zetasql
SELECT
  ARRAY_INCLUDES([1, 2, 3], 0) AS a1,
  ARRAY_INCLUDES([1, 2, 3], 1) AS a2;

/*-------+------*
 | a1    | a2   |
 +-------+------+
 | false | true |
 *-------+------*/
```

#### Signature 2 
<a id="array_includes_signature2"></a>

```zetasql
ARRAY_INCLUDES(array_to_search, lambda_expression)

lambda_expression: element_alias -> boolean_expression
```

**Description**

Takes an array and returns `TRUE` if the lambda expression evaluates to `TRUE`
for any element in the array.

+   `array_to_search`: The array to search.
+   `lambda_expression`: Each element in `array_to_search` is evaluated against
    the [lambda expression][lambda-definition].
+   `element_alias`: An alias that represents an array element.
+   `boolean_expression`: The predicate used to evaluate the array elements.

Returns `NULL` if `array_to_search` is `NULL`.

**Return type**

`BOOL`

**Example**

In the following example, the query first checks to see if any elements that are
greater than 3 exist in an array (`e > 3`). Then the query checks to see if any
elements that are greater than 0 exist in an array (`e > 0`).

```zetasql
SELECT
  ARRAY_INCLUDES([1, 2, 3], e -> e > 3) AS a1,
  ARRAY_INCLUDES([1, 2, 3], e -> e > 0) AS a2;

/*-------+------*
 | a1    | a2   |
 +-------+------+
 | false | true |
 *-------+------*/
```

[lambda-definition]: https://github.com/google/zetasql/blob/master/docs/functions-reference.md#lambdas

### `ARRAY_INCLUDES_ALL`

```zetasql
ARRAY_INCLUDES_ALL(array_to_search, search_values)
```

**Description**

Takes an array to search and an array of search values. Returns `TRUE` if all
search values are in the array to search, otherwise returns `FALSE`.

+   `array_to_search`: The array to search.
+   `search_values`: The array that contains the elements to search for.

Returns `NULL` if `array_to_search` or `search_values` is
`NULL`.

**Return type**

`BOOL`

**Example**

In the following example, the query first checks to see if `3`, `4`, and `5`
exists in an array. Then the query checks to see if `4`, `5`, and `6` exists in
an array.

```zetasql
SELECT
  ARRAY_INCLUDES_ALL([1,2,3,4,5], [3,4,5]) AS a1,
  ARRAY_INCLUDES_ALL([1,2,3,4,5], [4,5,6]) AS a2;

/*------+-------*
 | a1   | a2    |
 +------+-------+
 | true | false |
 *------+-------*/
```

### `ARRAY_INCLUDES_ANY`

```zetasql
ARRAY_INCLUDES_ANY(array_to_search, search_values)
```

**Description**

Takes an array to search and an array of search values. Returns `TRUE` if any
search values are in the array to search, otherwise returns `FALSE`.

+   `array_to_search`: The array to search.
+   `search_values`: The array that contains the elements to search for.

Returns `NULL` if `array_to_search` or `search_values` is
`NULL`.

**Return type**

`BOOL`

**Example**

In the following example, the query first checks to see if `3`, `4`, or `5`
exists in an array. Then the query checks to see if `4`, `5`, or `6` exists in
an array.

```zetasql
SELECT
  ARRAY_INCLUDES_ANY([1,2,3], [3,4,5]) AS a1,
  ARRAY_INCLUDES_ANY([1,2,3], [4,5,6]) AS a2;

/*------+-------*
 | a1   | a2    |
 +------+-------+
 | true | false |
 *------+-------*/
```

### `ARRAY_IS_DISTINCT`

```zetasql
ARRAY_IS_DISTINCT(value)
```

**Description**

Returns `TRUE` if the array contains no repeated elements, using the same
equality comparison logic as `SELECT DISTINCT`.

**Return type**

`BOOL`

**Examples**

```zetasql
SELECT ARRAY_IS_DISTINCT([1, 2, 3]) AS is_distinct

/*-------------*
 | is_distinct |
 +-------------+
 | true        |
 *-------------*/
```

```zetasql
SELECT ARRAY_IS_DISTINCT([1, 1, 1]) AS is_distinct

/*-------------*
 | is_distinct |
 +-------------+
 | false       |
 *-------------*/
```

```zetasql
SELECT ARRAY_IS_DISTINCT([1, 2, NULL]) AS is_distinct

/*-------------*
 | is_distinct |
 +-------------+
 | true        |
 *-------------*/
```

```zetasql
SELECT ARRAY_IS_DISTINCT([1, 1, NULL]) AS is_distinct

/*-------------*
 | is_distinct |
 +-------------+
 | false       |
 *-------------*/
```

```zetasql
SELECT ARRAY_IS_DISTINCT([1, NULL, NULL]) AS is_distinct

/*-------------*
 | is_distinct |
 +-------------+
 | false       |
 *-------------*/
```
```zetasql
SELECT ARRAY_IS_DISTINCT([]) AS is_distinct

/*-------------*
 | is_distinct |
 +-------------+
 | true        |
 *-------------*/
```

```zetasql
SELECT ARRAY_IS_DISTINCT(NULL) AS is_distinct

/*-------------*
 | is_distinct |
 +-------------+
 | NULL        |
 *-------------*/
```

### `ARRAY_LAST`

```zetasql
ARRAY_LAST(array_expression)
```

**Description**

Takes an array and returns the last element in the array.

Produces an error if the array is empty.

Returns `NULL` if `array_expression` is `NULL`.

Note: To get the first element in an array, see [`ARRAY_FIRST`][array-first].

**Return type**

Matches the data type of elements in `array_expression`.

**Example**

```zetasql
SELECT ARRAY_LAST(['a','b','c','d']) as last_element

/*---------------*
 | last_element  |
 +---------------+
 | d             |
 *---------------*/
```

[array-first]: #array_first

### `ARRAY_LENGTH`

```zetasql
ARRAY_LENGTH(array_expression)
```

**Description**

Returns the size of the array. Returns 0 for an empty array. Returns `NULL` if
the `array_expression` is `NULL`.

**Return type**

`INT64`

**Examples**

```zetasql
SELECT
  ARRAY_LENGTH(["coffee", NULL, "milk" ]) AS size_a,
  ARRAY_LENGTH(["cake", "pie"]) AS size_b;

/*--------+--------*
 | size_a | size_b |
 +--------+--------+
 | 3      | 2      |
 *--------+--------*/
```

### `ARRAY_MAX`

```zetasql
ARRAY_MAX(input_array)
```

**Description**

Returns the maximum non-`NULL` value in an array.

Caveats:

+ If the array is `NULL`, empty, or contains only `NULL`s, returns
  `NULL`.
+ If the array contains `NaN`, returns `NaN`.

**Supported Argument Types**

In the input array, `ARRAY<T>`, `T` can be an
[orderable data type][data-type-properties].

**Return type**

The same data type as `T` in the input array.

**Examples**

```zetasql
SELECT ARRAY_MAX([8, 37, NULL, 55, 4]) as max

/*-----*
 | max |
 +-----+
 | 55  |
 *-----*/
```

[data-type-properties]: https://github.com/google/zetasql/blob/master/docs/data-types.md#data_type_properties

### `ARRAY_MIN`

```zetasql
ARRAY_MIN(input_array)
```

**Description**

Returns the minimum non-`NULL` value in an array.

Caveats:

+ If the array is `NULL`, empty, or contains only `NULL`s, returns
  `NULL`.
+ If the array contains `NaN`, returns `NaN`.

**Supported Argument Types**

In the input array, `ARRAY<T>`, `T` can be an
[orderable data type][data-type-properties].

**Return type**

The same data type as `T` in the input array.

**Examples**

```zetasql
SELECT ARRAY_MIN([8, 37, NULL, 4, 55]) as min

/*-----*
 | min |
 +-----+
 | 4   |
 *-----*/
```

[data-type-properties]: https://github.com/google/zetasql/blob/master/docs/data-types.md#data_type_properties

### `ARRAY_REVERSE`

```zetasql
ARRAY_REVERSE(value)
```

**Description**

Returns the input `ARRAY` with elements in reverse order.

**Return type**

`ARRAY`

**Examples**

```zetasql
SELECT ARRAY_REVERSE([1, 2, 3]) AS reverse_arr

/*-------------*
 | reverse_arr |
 +-------------+
 | [3, 2, 1]   |
 *-------------*/
```

### `ARRAY_SLICE`

```zetasql
ARRAY_SLICE(array_to_slice, start_offset, end_offset)
```

**Description**

Returns an array containing zero or more consecutive elements from the
input array.

+ `array_to_slice`: The array that contains the elements you want to slice.
+ `start_offset`: The inclusive starting offset.
+ `end_offset`: The inclusive ending offset.

An offset can be positive or negative. A positive offset starts from the
beginning of the input array and is 0-based. A negative offset starts from
the end of the input array. Out-of-bounds offsets are supported. Here are some
examples:

  <table>
  <thead>
    <tr>
      <th width="150px">Input offset</th>
      <th width="200px">Final offset in array</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>[<b>'a'</b>, 'b', 'c', 'd']</td>
      <td>The final offset is <code>0</code>.</td>
    </tr>
    <tr>
      <td>3</td>
      <td>['a', 'b', 'c', <b>'d'</b>]</td>
      <td>The final offset is <code>3</code>.</td>
    </tr>
    <tr>
      <td>5</td>
      <td>['a', 'b', 'c', <b>'d'</b>]</td>
      <td>
        Because the input offset is out of bounds,
        the final offset is <code>3</code> (<code>array length - 1</code>).
      </td>
    </tr>
    <tr>
      <td>-1</td>
      <td>['a', 'b', 'c', <b>'d'</b>]</td>
      <td>
        Because a negative offset is used, the offset starts at the end of the
        array. The final offset is <code>3</code>
        (<code>array length - 1</code>).
      </td>
    </tr>
    <tr>
      <td>-2</td>
      <td>['a', 'b', <b>'c'</b>, 'd']</td>
      <td>
        Because a negative offset is used, the offset starts at the end of the
        array. The final offset is <code>2</code>
        (<code>array length - 2</code>).
      </td>
    </tr>
    <tr>
      <td>-4</td>
      <td>[<b>'a'</b>, 'b', 'c', 'd']</td>
      <td>
        Because a negative offset is used, the offset starts at the end of the
        array. The final offset is <code>0</code>
        (<code>array length - 4</code>).
      </td>
    </tr>
    <tr>
      <td>-5</td>
      <td>[<b>'a'</b>, 'b', 'c', 'd']</td>
      <td>
        Because the offset is negative and out of bounds, the final offset is
        <code>0</code> (<code>array length - array length</code>).
      </td>
    </tr>
  </tbody>
</table>

Additional details:

+ The input array can contain `NULL` elements. `NULL` elements are included
  in the resulting array.
+ Returns `NULL` if `array_to_slice`, `start_offset`, or `end_offset` is
  `NULL`.
+ Returns an empty array if `array_to_slice` is empty.
+ Returns an empty array if the position of the `start_offset` in the array is
  after the position of the `end_offset`.

**Return type**

`ARRAY`

**Examples**

```zetasql
SELECT ARRAY_SLICE(['a', 'b', 'c', 'd', 'e'], 1, 3) AS result

/*-----------*
 | result    |
 +-----------+
 | [b, c, d] |
 *-----------*/
```

```zetasql
SELECT ARRAY_SLICE(['a', 'b', 'c', 'd', 'e'], -1, 3) AS result

/*-----------*
 | result    |
 +-----------+
 | []        |
 *-----------*/
```

```zetasql
SELECT ARRAY_SLICE(['a', 'b', 'c', 'd', 'e'], 1, -3) AS result

/*--------*
 | result |
 +--------+
 | [b, c] |
 *--------*/
```

```zetasql
SELECT ARRAY_SLICE(['a', 'b', 'c', 'd', 'e'], -1, -3) AS result

/*-----------*
 | result    |
 +-----------+
 | []        |
 *-----------*/
```

```zetasql
SELECT ARRAY_SLICE(['a', 'b', 'c', 'd', 'e'], -3, -1) AS result

/*-----------*
 | result    |
 +-----------+
 | [c, d, e] |
 *-----------*/
```

```zetasql
SELECT ARRAY_SLICE(['a', 'b', 'c', 'd', 'e'], 3, 3) AS result

/*--------*
 | result |
 +--------+
 | [d]    |
 *--------*/
```

```zetasql
SELECT ARRAY_SLICE(['a', 'b', 'c', 'd', 'e'], -3, -3) AS result

/*--------*
 | result |
 +--------+
 | [c]    |
 *--------*/
```

```zetasql
SELECT ARRAY_SLICE(['a', 'b', 'c', 'd', 'e'], 1, 30) AS result

/*--------------*
 | result       |
 +--------------+
 | [b, c, d, e] |
 *--------------*/
```

```zetasql
SELECT ARRAY_SLICE(['a', 'b', 'c', 'd', 'e'], 1, -30) AS result

/*-----------*
 | result    |
 +-----------+
 | []        |
 *-----------*/
```

```zetasql
SELECT ARRAY_SLICE(['a', 'b', 'c', 'd', 'e'], -30, 30) AS result

/*-----------------*
 | result          |
 +-----------------+
 | [a, b, c, d, e] |
 *-----------------*/
```

```zetasql
SELECT ARRAY_SLICE(['a', 'b', 'c', 'd', 'e'], -30, -5) AS result

/*--------*
 | result |
 +--------+
 | [a]    |
 *--------*/
```

```zetasql
SELECT ARRAY_SLICE(['a', 'b', 'c', 'd', 'e'], 5, 30) AS result

/*--------*
 | result |
 +--------+
 | []     |
 *--------*/
```

```zetasql
SELECT ARRAY_SLICE(['a', 'b', 'c', 'd', 'e'], 1, NULL) AS result

/*-----------*
 | result    |
 +-----------+
 | NULL      |
 *-----------*/
```

```zetasql
SELECT ARRAY_SLICE(['a', 'b', NULL, 'd', 'e'], 1, 3) AS result

/*--------------*
 | result       |
 +--------------+
 | [b, NULL, d] |
 *--------------*/
```

### `ARRAY_SUM`

```zetasql
ARRAY_SUM(input_array)
```

**Description**

Returns the sum of non-`NULL` values in an array.

Caveats:

+ If the array is `NULL`, empty, or contains only `NULL`s, returns
  `NULL`.
+ If the array contains `NaN`, returns `NaN`.
+ If the array contains `[+|-]Infinity`, returns either `[+|-]Infinity`
  or `NaN`.
+ If there is numeric overflow, produces an error.
+ If a [floating-point type][floating-point-types] is returned, the result is
  [non-deterministic][non-deterministic], which means you might receive a
  different result each time you use this function.

[floating-point-types]: https://github.com/google/zetasql/blob/master/docs/data-types.md#floating_point_types

[non-deterministic]: https://github.com/google/zetasql/blob/master/docs/data-types.md#floating_point_semantics

**Supported Argument Types**

In the input array, `ARRAY<T>`, `T` can represent:

+ Any supported numeric data type
+ `INTERVAL`

**Return type**

The return type depends upon `T` in the input array:

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th><th><code>INTERVAL</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>INTERVAL</code></td></tr>
</tbody>

</table>

**Examples**

```zetasql
SELECT ARRAY_SUM([1, 2, 3, 4, 5, NULL, 4, 3, 2, 1]) as sum

/*-----*
 | sum |
 +-----+
 | 25  |
 *-----*/
```

### `ARRAY_TO_STRING`

```zetasql
ARRAY_TO_STRING(array_expression, delimiter[, null_text])
```

**Description**

Returns a concatenation of the elements in `array_expression`
as a `STRING`. The value for `array_expression`
can either be an array of `STRING` or
`BYTES` data types.

If the `null_text` parameter is used, the function replaces any `NULL` values in
the array with the value of `null_text`.

If the `null_text` parameter isn't used, the function omits the `NULL` value
and its preceding delimiter.

**Return type**

`STRING`

**Examples**

```zetasql
SELECT ARRAY_TO_STRING(['coffee', 'tea', 'milk', NULL], '--', 'MISSING') AS text

/*--------------------------------*
 | text                           |
 +--------------------------------+
 | coffee--tea--milk--MISSING     |
 *--------------------------------*/
```

```zetasql

SELECT ARRAY_TO_STRING(['cake', 'pie', NULL], '--', 'MISSING') AS text

/*--------------------------------*
 | text                           |
 +--------------------------------+
 | cake--pie--MISSING             |
 *--------------------------------*/
```

### `ARRAY_TRANSFORM`

```zetasql
ARRAY_TRANSFORM(array_expression, lambda_expression)

lambda_expression:
  {
    element_alias -> transform_expression
    | (element_alias, index_alias) -> transform_expression
  }
```

**Description**

Takes an array, transforms the elements, and returns the results in a new array.
The output array always has the same length as the input array.

+   `array_expression`: The array to transform.
+   `lambda_expression`: Each element in `array_expression` is evaluated against
    the [lambda expression][lambda-definition]. The evaluation results are
    returned in a new array.
+   `element_alias`: An alias that represents an array element.
+   `index_alias`: An alias that represents the zero-based offset of the array
    element.
+   `transform_expression`: The expression used to transform the array elements.

Returns `NULL` if the `array_expression` is `NULL`.

**Return type**

`ARRAY`

**Example**

```zetasql
SELECT
  ARRAY_TRANSFORM([1, 4, 3], e -> e + 1) AS a1,
  ARRAY_TRANSFORM([1, 4, 3], (e, i) -> e + i) AS a2;

/*---------+---------*
 | a1      | a2      |
 +---------+---------+
 | [2,5,4] | [1,5,5] |
 *---------+---------*/
```

[lambda-definition]: https://github.com/google/zetasql/blob/master/docs/functions-reference.md#lambdas

### `ARRAY_ZIP`

```zetasql
ARRAY_ZIP(
  array_input [ AS alias ],
  array_input [ AS alias ][, ... ]
  [, [ transformation => ] value ]
  [, mode => { 'STRICT' | 'TRUNCATE' | 'PAD' } ]
)
```

**Description**

Combines the elements from two to four arrays into one array.

**Definitions**

+   `array_input`: An input `ARRAY` value to be zipped with the other array
    inputs. `ARRAY_ZIP` supports two to four input arrays.
+   `alias`: An alias optionally supplied for an `array_input`. In the results,
    the alias is the name of the associated `STRUCT` field.
+   `transformation`: A named argument with a lambda expression.
    The lambda expression specifies how elements are combined as they are
    zipped. This overrides the default `STRUCT` creation behavior.
+   `mode`: A named argument with a `STRING` value. Determines how arrays of
    differing lengths are zipped. If this argument isn't supplied, the
    function uses `STRICT` mode. This argument can be one of the
    following values:

    +   `STRICT` (default): If the length of any array is different from the
        others, produce an error.

    +   `TRUNCATE`: Truncate longer arrays to match the length of the shortest
        array.

    +   `PAD`: Pad shorter arrays with `NULL` values to match the length of the
        longest array.

**Details**

+   If an `array_input` or `mode` is `NULL`, this function returns `NULL`, even when
    `mode` is `STRICT`.
+   Argument aliases can't be used with the `transformation` argument.

**Return type**

+   If `transformation` is used and returns type `T`, the
    return type is `ARRAY<T>`.
+   Otherwise, the return type is `ARRAY<STRUCT>`, with the `STRUCT` having a
    number of fields equal to the number of input arrays. Each field's name is
    either the user-provided `alias` for the corresponding `array_input`, or a
    default alias assigned by the compiler, following the same logic used for
    [naming columns in a SELECT list][implicit-aliases].

**Examples**

The following query zips two arrays into one:

```zetasql
SELECT ARRAY_ZIP([1, 2], ['a', 'b']) AS results

/*----------------------*
 | results              |
 +----------------------+
 | [(1, 'a'), (2, 'b')] |
 *----------------------*/
```

You can give an array an alias. For example, in the following
query, the returned array is of type `ARRAY<STRUCT<A1, alias_inferred>>`,
where:

+   `A1` is the alias provided for array `[1, 2]`.
+   `alias_inferred` is the inferred alias provided for array `['a', 'b']`.

```zetasql
WITH T AS (
  SELECT ['a', 'b'] AS alias_inferred
)
SELECT ARRAY_ZIP([1, 2] AS A1, alias_inferred) AS results
FROM T

/*----------------------------------------------------------+
 | results                                                  |
 +----------------------------------------------------------+
 | [{1 A1, 'a' alias_inferred}, {2 A1, 'b' alias_inferred}] |
 +----------------------------------------------------------*/
```

To provide a custom transformation of the input arrays, use the `transformation`
argument:

```zetasql
SELECT ARRAY_ZIP([1, 2], [3, 4], transformation => (e1, e2) -> (e1 + e2))

/*---------+
 | results |
 +---------+
 | [4, 6]  |
 +---------*/
```

The argument name `transformation` isn't required. For example:

```zetasql
SELECT ARRAY_ZIP([1, 2], [3, 4], (e1, e2) -> (e1 + e2))

/*---------+
 | results |
 +---------+
 | [4, 6]  |
 +---------*/
```

When `transformation` is provided, the input arrays aren't allowed to have
aliases. For example, the following query is invalid:

```zetasql {.bad}
-- Error: ARRAY_ZIP function with lambda argument doesn't allow providing
-- argument aliases
SELECT ARRAY_ZIP([1, 2], [3, 4] AS alias_not_allowed, (e1, e2) -> (e1 + e2))
```

To produce an error when arrays with different lengths are zipped, don't
add `mode`, or if you do, set it as `STRICT`. For example:

```zetasql {.bad}
-- Error: Unequal array length
SELECT ARRAY_ZIP([1, 2], ['a', 'b', 'c', 'd']) AS results
```

```zetasql {.bad}
-- Error: Unequal array length
SELECT ARRAY_ZIP([1, 2], ['a', 'b', 'c', 'd'], mode => 'STRICT') AS results
```

Use the `PAD` mode to pad missing values with `NULL` when input arrays have
different lengths. For example:

```zetasql
SELECT ARRAY_ZIP([1, 2], ['a', 'b', 'c', 'd'], [], mode => 'PAD') AS results

/*------------------------------------------------------------------------+
 | results                                                                |
 +------------------------------------------------------------------------+
 | [{1, 'a', NULL}, {2, 'b', NULL}, {NULL, 'c', NULL}, {NULL, 'd', NULL}] |
 +------------------------------------------------------------------------*/
```

Use the `TRUNCATE` mode to truncate all arrays that are longer than the shortest
array. For example:

```zetasql
SELECT ARRAY_ZIP([1, 2], ['a', 'b', 'c', 'd'], mode => 'TRUNCATE') AS results

/*----------------------*
 | results              |
 +----------------------+
 | [(1, 'a'), (2, 'b')] |
 *----------------------*/
```

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[implicit-aliases]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#implicit_aliases

<!-- mdlint on -->

### `FLATTEN`

```zetasql
FLATTEN(array_elements_field_access_expression)
```

**Description**

Takes an array of nested data and flattens a specific part of it into a single,
flat array with the
[array elements field access operator][array-el-field-operator].
Returns `NULL` if the input value is `NULL`.
If `NULL` array elements are
encountered, they are added to the resulting array.

There are several ways to flatten nested data into arrays. To learn more, see
[Flattening nested data into an array][flatten-tree-to-array].

**Return type**

`ARRAY`

**Examples**

In the following example, all of the arrays for `v.sales.quantity` are
concatenated in a flattened array.

```zetasql
WITH t AS (
  SELECT
  [
    STRUCT([STRUCT([1,2,3] AS quantity), STRUCT([4,5,6] AS quantity)] AS sales),
    STRUCT([STRUCT([7,8] AS quantity), STRUCT([] AS quantity)] AS sales)
  ] AS v
)
SELECT FLATTEN(v.sales.quantity) AS all_values
FROM t;

/*--------------------------*
 | all_values               |
 +--------------------------+
 | [1, 2, 3, 4, 5, 6, 7, 8] |
 *--------------------------*/
```

In the following example, `OFFSET` gets the second value in each array and
concatenates them.

```zetasql
WITH t AS (
  SELECT
  [
    STRUCT([STRUCT([1,2,3] AS quantity), STRUCT([4,5,6] AS quantity)] AS sales),
    STRUCT([STRUCT([7,8,9] AS quantity), STRUCT([10,11,12] AS quantity)] AS sales)
  ] AS v
)
SELECT FLATTEN(v.sales.quantity[OFFSET(1)]) AS second_values
FROM t;

/*---------------*
 | second_values |
 +---------------+
 | [2, 5, 8, 11] |
 *---------------*/
```

In the following example, all values for `v.price` are returned in a
flattened array.

```zetasql
WITH t AS (
  SELECT
  [
    STRUCT(1 AS price, 2 AS quantity),
    STRUCT(10 AS price, 20 AS quantity)
  ] AS v
)
SELECT FLATTEN(v.price) AS all_prices
FROM t;

/*------------*
 | all_prices |
 +------------+
 | [1, 10]    |
 *------------*/
```

For more examples, including how to use protocol buffers with `FLATTEN`, see the
[array elements field access operator][array-el-field-operator].

[flatten-tree-to-array]: https://github.com/google/zetasql/blob/master/docs/arrays.md#flattening_nested_data_into_arrays

[array-el-field-operator]: #array_el_field_operator

### `GENERATE_ARRAY`

```zetasql
GENERATE_ARRAY(start_expression, end_expression[, step_expression])
```

**Description**

Returns an array of values. The `start_expression` and `end_expression`
parameters determine the inclusive start and end of the array.

The `GENERATE_ARRAY` function accepts the following data types as inputs:

+ `INT64`
+ `UINT64`
+ `NUMERIC`
+ `BIGNUMERIC`
+ `DOUBLE`

The `step_expression` parameter determines the increment used to
generate array values. The default value for this parameter is `1`.

This function returns an error if `step_expression` is set to 0, or if any
input is `NaN`.

If any argument is `NULL`, the function will return a `NULL` array.

**Return Data Type**

`ARRAY`

**Examples**

The following returns an array of integers, with a default step of 1.

```zetasql
SELECT GENERATE_ARRAY(1, 5) AS example_array;

/*-----------------*
 | example_array   |
 +-----------------+
 | [1, 2, 3, 4, 5] |
 *-----------------*/
```

The following returns an array using a user-specified step size.

```zetasql
SELECT GENERATE_ARRAY(0, 10, 3) AS example_array;

/*---------------*
 | example_array |
 +---------------+
 | [0, 3, 6, 9]  |
 *---------------*/
```

The following returns an array using a negative value, `-3` for its step size.

```zetasql
SELECT GENERATE_ARRAY(10, 0, -3) AS example_array;

/*---------------*
 | example_array |
 +---------------+
 | [10, 7, 4, 1] |
 *---------------*/
```

The following returns an array using the same value for the `start_expression`
and `end_expression`.

```zetasql
SELECT GENERATE_ARRAY(4, 4, 10) AS example_array;

/*---------------*
 | example_array |
 +---------------+
 | [4]           |
 *---------------*/
```

The following returns an empty array, because the `start_expression` is greater
than the `end_expression`, and the `step_expression` value is positive.

```zetasql
SELECT GENERATE_ARRAY(10, 0, 3) AS example_array;

/*---------------*
 | example_array |
 +---------------+
 | []            |
 *---------------*/
```

The following returns a `NULL` array because `end_expression` is `NULL`.

```zetasql
SELECT GENERATE_ARRAY(5, NULL, 1) AS example_array;

/*---------------*
 | example_array |
 +---------------+
 | NULL          |
 *---------------*/
```

The following returns multiple arrays.

```zetasql
SELECT GENERATE_ARRAY(start, 5) AS example_array
FROM UNNEST([3, 4, 5]) AS start;

/*---------------*
 | example_array |
 +---------------+
 | [3, 4, 5]     |
 | [4, 5]        |
 | [5]           |
 +---------------*/
```

### `GENERATE_DATE_ARRAY`

```zetasql
GENERATE_DATE_ARRAY(start_date, end_date[, INTERVAL INT64_expr date_part])
```

**Description**

Returns an array of dates. The `start_date` and `end_date`
parameters determine the inclusive start and end of the array.

The `GENERATE_DATE_ARRAY` function accepts the following data types as inputs:

+ `start_date` must be a `DATE`.
+ `end_date` must be a `DATE`.
+ `INT64_expr` must be an `INT64`.
+ `date_part` must be either DAY, WEEK, MONTH, QUARTER, or YEAR.

The `INT64_expr` parameter determines the increment used to generate dates. The
default value for this parameter is 1 day.

This function returns an error if `INT64_expr` is set to 0.

**Return Data Type**

`ARRAY` containing 0 or more `DATE` values.

**Examples**

The following returns an array of dates, with a default step of 1.

```zetasql
SELECT GENERATE_DATE_ARRAY('2016-10-05', '2016-10-08') AS example;

/*--------------------------------------------------*
 | example                                          |
 +--------------------------------------------------+
 | [2016-10-05, 2016-10-06, 2016-10-07, 2016-10-08] |
 *--------------------------------------------------*/
```

The following returns an array using a user-specified step size.

```zetasql
SELECT GENERATE_DATE_ARRAY(
 '2016-10-05', '2016-10-09', INTERVAL 2 DAY) AS example;

/*--------------------------------------*
 | example                              |
 +--------------------------------------+
 | [2016-10-05, 2016-10-07, 2016-10-09] |
 *--------------------------------------*/
```

The following returns an array using a negative value, `-3` for its step size.

```zetasql
SELECT GENERATE_DATE_ARRAY('2016-10-05',
  '2016-10-01', INTERVAL -3 DAY) AS example;

/*--------------------------*
 | example                  |
 +--------------------------+
 | [2016-10-05, 2016-10-02] |
 *--------------------------*/
```

The following returns an array using the same value for the `start_date`and
`end_date`.

```zetasql
SELECT GENERATE_DATE_ARRAY('2016-10-05',
  '2016-10-05', INTERVAL 8 DAY) AS example;

/*--------------*
 | example      |
 +--------------+
 | [2016-10-05] |
 *--------------*/
```

The following returns an empty array, because the `start_date` is greater
than the `end_date`, and the `step` value is positive.

```zetasql
SELECT GENERATE_DATE_ARRAY('2016-10-05',
  '2016-10-01', INTERVAL 1 DAY) AS example;

/*---------*
 | example |
 +---------+
 | []      |
 *---------*/
```

The following returns a `NULL` array, because one of its inputs is
`NULL`.

```zetasql
SELECT GENERATE_DATE_ARRAY('2016-10-05', NULL) AS example;

/*---------*
 | example |
 +---------+
 | NULL    |
 *---------*/
```

The following returns an array of dates, using MONTH as the `date_part`
interval:

```zetasql
SELECT GENERATE_DATE_ARRAY('2016-01-01',
  '2016-12-31', INTERVAL 2 MONTH) AS example;

/*--------------------------------------------------------------------------*
 | example                                                                  |
 +--------------------------------------------------------------------------+
 | [2016-01-01, 2016-03-01, 2016-05-01, 2016-07-01, 2016-09-01, 2016-11-01] |
 *--------------------------------------------------------------------------*/
```

The following uses non-constant dates to generate an array.

```zetasql
SELECT GENERATE_DATE_ARRAY(date_start, date_end, INTERVAL 1 WEEK) AS date_range
FROM (
  SELECT DATE '2016-01-01' AS date_start, DATE '2016-01-31' AS date_end
  UNION ALL SELECT DATE "2016-04-01", DATE "2016-04-30"
  UNION ALL SELECT DATE "2016-07-01", DATE "2016-07-31"
  UNION ALL SELECT DATE "2016-10-01", DATE "2016-10-31"
) AS items;

/*--------------------------------------------------------------*
 | date_range                                                   |
 +--------------------------------------------------------------+
 | [2016-01-01, 2016-01-08, 2016-01-15, 2016-01-22, 2016-01-29] |
 | [2016-04-01, 2016-04-08, 2016-04-15, 2016-04-22, 2016-04-29] |
 | [2016-07-01, 2016-07-08, 2016-07-15, 2016-07-22, 2016-07-29] |
 | [2016-10-01, 2016-10-08, 2016-10-15, 2016-10-22, 2016-10-29] |
 *--------------------------------------------------------------*/
```

### `GENERATE_TIMESTAMP_ARRAY`

```zetasql
GENERATE_TIMESTAMP_ARRAY(start_timestamp, end_timestamp,
                         INTERVAL step_expression date_part)
```

**Description**

Returns an `ARRAY` of `TIMESTAMPS` separated by a given interval. The
`start_timestamp` and `end_timestamp` parameters determine the inclusive
lower and upper bounds of the `ARRAY`.

The `GENERATE_TIMESTAMP_ARRAY` function accepts the following data types as
inputs:

+ `start_timestamp`: `TIMESTAMP`
+ `end_timestamp`: `TIMESTAMP`
+ `step_expression`: `INT64`
+ Allowed `date_part` values are:
  `NANOSECOND`
  (if the SQL engine supports it),
  `MICROSECOND`, `MILLISECOND`, `SECOND`, `MINUTE`, `HOUR`, or `DAY`.

The `step_expression` parameter determines the increment used to generate
timestamps.

**Return Data Type**

An `ARRAY` containing 0 or more `TIMESTAMP` values.

**Examples**

The following example returns an `ARRAY` of `TIMESTAMP`s at intervals of 1 day.

```zetasql
SELECT GENERATE_TIMESTAMP_ARRAY('2016-10-05 00:00:00', '2016-10-07 00:00:00',
                                INTERVAL 1 DAY) AS timestamp_array;

/*--------------------------------------------------------------------------*
 | timestamp_array                                                          |
 +--------------------------------------------------------------------------+
 | [2016-10-05 00:00:00+00, 2016-10-06 00:00:00+00, 2016-10-07 00:00:00+00] |
 *--------------------------------------------------------------------------*/
```

The following example returns an `ARRAY` of `TIMESTAMP`s at intervals of 1
second.

```zetasql
SELECT GENERATE_TIMESTAMP_ARRAY('2016-10-05 00:00:00', '2016-10-05 00:00:02',
                                INTERVAL 1 SECOND) AS timestamp_array;

/*--------------------------------------------------------------------------*
 | timestamp_array                                                          |
 +--------------------------------------------------------------------------+
 | [2016-10-05 00:00:00+00, 2016-10-05 00:00:01+00, 2016-10-05 00:00:02+00] |
 *--------------------------------------------------------------------------*/
```

The following example returns an `ARRAY` of `TIMESTAMPS` with a negative
interval.

```zetasql
SELECT GENERATE_TIMESTAMP_ARRAY('2016-10-06 00:00:00', '2016-10-01 00:00:00',
                                INTERVAL -2 DAY) AS timestamp_array;

/*--------------------------------------------------------------------------*
 | timestamp_array                                                          |
 +--------------------------------------------------------------------------+
 | [2016-10-06 00:00:00+00, 2016-10-04 00:00:00+00, 2016-10-02 00:00:00+00] |
 *--------------------------------------------------------------------------*/
```

The following example returns an `ARRAY` with a single element, because
`start_timestamp` and `end_timestamp` have the same value.

```zetasql
SELECT GENERATE_TIMESTAMP_ARRAY('2016-10-05 00:00:00', '2016-10-05 00:00:00',
                                INTERVAL 1 HOUR) AS timestamp_array;

/*--------------------------*
 | timestamp_array          |
 +--------------------------+
 | [2016-10-05 00:00:00+00] |
 *--------------------------*/
```

The following example returns an empty `ARRAY`, because `start_timestamp` is
later than `end_timestamp`.

```zetasql
SELECT GENERATE_TIMESTAMP_ARRAY('2016-10-06 00:00:00', '2016-10-05 00:00:00',
                                INTERVAL 1 HOUR) AS timestamp_array;

/*-----------------*
 | timestamp_array |
 +-----------------+
 | []              |
 *-----------------*/
```

The following example returns a null `ARRAY`, because one of the inputs is
`NULL`.

```zetasql
SELECT GENERATE_TIMESTAMP_ARRAY('2016-10-05 00:00:00', NULL, INTERVAL 1 HOUR)
  AS timestamp_array;

/*-----------------*
 | timestamp_array |
 +-----------------+
 | NULL            |
 *-----------------*/
```

The following example generates `ARRAY`s of `TIMESTAMP`s from columns containing
values for `start_timestamp` and `end_timestamp`.

```zetasql
SELECT GENERATE_TIMESTAMP_ARRAY(start_timestamp, end_timestamp, INTERVAL 1 HOUR)
  AS timestamp_array
FROM
  (SELECT
    TIMESTAMP '2016-10-05 00:00:00' AS start_timestamp,
    TIMESTAMP '2016-10-05 02:00:00' AS end_timestamp
   UNION ALL
   SELECT
    TIMESTAMP '2016-10-05 12:00:00' AS start_timestamp,
    TIMESTAMP '2016-10-05 14:00:00' AS end_timestamp
   UNION ALL
   SELECT
    TIMESTAMP '2016-10-05 23:59:00' AS start_timestamp,
    TIMESTAMP '2016-10-06 01:59:00' AS end_timestamp);

/*--------------------------------------------------------------------------*
 | timestamp_array                                                          |
 +--------------------------------------------------------------------------+
 | [2016-10-05 00:00:00+00, 2016-10-05 01:00:00+00, 2016-10-05 02:00:00+00] |
 | [2016-10-05 12:00:00+00, 2016-10-05 13:00:00+00, 2016-10-05 14:00:00+00] |
 | [2016-10-05 23:59:00+00, 2016-10-06 00:59:00+00, 2016-10-06 01:59:00+00] |
 *--------------------------------------------------------------------------*/
```

### Supplemental materials

### OFFSET and ORDINAL

For information about using `OFFSET` and `ORDINAL` with arrays, see
[Array subscript operator][array-subscript-operator] and [Accessing array
elements][accessing-array-elements].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[array-subscript-operator]: #array_subscript_operator

[accessing-array-elements]: https://github.com/google/zetasql/blob/master/docs/arrays.md#accessing_array_elements

<!-- mdlint on -->

## Bit functions

ZetaSQL supports the following bit functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#bit_and"><code>BIT_AND</code></a>
</td>
  <td>
    Performs a bitwise AND operation on an expression.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate_functions.md">Aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#bit_cast_to_int32"><code>BIT_CAST_TO_INT32</code></a>
</td>
  <td>
    Cast bits to an <code>INT32</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#bit_cast_to_int64"><code>BIT_CAST_TO_INT64</code></a>
</td>
  <td>
    Cast bits to an <code>INT64</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#bit_cast_to_uint32"><code>BIT_CAST_TO_UINT32</code></a>
</td>
  <td>
    Cast bits to an <code>UINT32</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#bit_cast_to_uint64"><code>BIT_CAST_TO_UINT64</code></a>
</td>
  <td>
    Cast bits to an <code>UINT64</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#bit_count"><code>BIT_COUNT</code></a>
</td>
  <td>
    Gets the number of bits that are set in an input expression.
  </td>
</tr>

<tr>
  <td><a href="#bit_or"><code>BIT_OR</code></a>
</td>
  <td>
    Performs a bitwise OR operation on an expression.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate_functions.md">Aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#bit_xor"><code>BIT_XOR</code></a>
</td>
  <td>
    Performs a bitwise XOR operation on an expression.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate_functions.md">Aggregate functions</a>.

  </td>
</tr>

  </tbody>
</table>

### `BIT_CAST_TO_INT32`

```zetasql
BIT_CAST_TO_INT32(value)
```

**Description**

ZetaSQL supports bit casting to `INT32`. A bit
cast is a cast in which the order of bits is preserved instead of the value
those bytes represent.

The `value` parameter can represent:

+ `INT32`
+ `UINT32`

**Return Data Type**

`INT32`

**Examples**

```zetasql
SELECT BIT_CAST_TO_UINT32(-1) as UINT32_value, BIT_CAST_TO_INT32(BIT_CAST_TO_UINT32(-1)) as bit_cast_value;

/*---------------+----------------------*
 | UINT32_value  | bit_cast_value       |
 +---------------+----------------------+
 | 4294967295    | -1                   |
 *---------------+----------------------*/
```

### `BIT_CAST_TO_INT64`

```zetasql
BIT_CAST_TO_INT64(value)
```

**Description**

ZetaSQL supports bit casting to `INT64`. A bit
cast is a cast in which the order of bits is preserved instead of the value
those bytes represent.

The `value` parameter can represent:

+ `INT64`
+ `UINT64`

**Return Data Type**

`INT64`

**Example**

```zetasql
SELECT BIT_CAST_TO_UINT64(-1) as UINT64_value, BIT_CAST_TO_INT64(BIT_CAST_TO_UINT64(-1)) as bit_cast_value;

/*-----------------------+----------------------*
 | UINT64_value          | bit_cast_value       |
 +-----------------------+----------------------+
 | 18446744073709551615  | -1                   |
 *-----------------------+----------------------*/
```

### `BIT_CAST_TO_UINT32`

```zetasql
BIT_CAST_TO_UINT32(value)
```

**Description**

ZetaSQL supports bit casting to `UINT32`. A bit
cast is a cast in which the order of bits is preserved instead of the value
those bytes represent.

The `value` parameter can represent:

+ `INT32`
+ `UINT32`

**Return Data Type**

`UINT32`

**Examples**

```zetasql
SELECT -1 as UINT32_value, BIT_CAST_TO_UINT32(-1) as bit_cast_value;

/*--------------+----------------------*
 | UINT32_value | bit_cast_value       |
 +--------------+----------------------+
 | -1           | 4294967295           |
 *--------------+----------------------*/
```

### `BIT_CAST_TO_UINT64`

```zetasql
BIT_CAST_TO_UINT64(value)
```

**Description**

ZetaSQL supports bit casting to `UINT64`. A bit
cast is a cast in which the order of bits is preserved instead of the value
those bytes represent.

The `value` parameter can represent:

+ `INT64`
+ `UINT64`

**Return Data Type**

`UINT64`

**Example**

```zetasql
SELECT -1 as INT64_value, BIT_CAST_TO_UINT64(-1) as bit_cast_value;

/*--------------+----------------------*
 | INT64_value  | bit_cast_value       |
 +--------------+----------------------+
 | -1           | 18446744073709551615 |
 *--------------+----------------------*/
```

### `BIT_COUNT`

```zetasql
BIT_COUNT(expression)
```

**Description**

The input, `expression`, must be an
integer or `BYTES`.

Returns the number of bits that are set in the input `expression`.
For signed integers, this is the number of bits in two's complement form.

**Return Data Type**

`INT64`

**Example**

```zetasql
SELECT a, BIT_COUNT(a) AS a_bits, FORMAT("%T", b) as b, BIT_COUNT(b) AS b_bits
FROM UNNEST([
  STRUCT(0 AS a, b'' AS b), (0, b'\x00'), (5, b'\x05'), (8, b'\x00\x08'),
  (0xFFFF, b'\xFF\xFF'), (-2, b'\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE'),
  (-1, b'\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF'),
  (NULL, b'\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF')
]) AS x;

/*-------+--------+---------------------------------------------+--------*
 | a     | a_bits | b                                           | b_bits |
 +-------+--------+---------------------------------------------+--------+
 | 0     | 0      | b""                                         | 0      |
 | 0     | 0      | b"\x00"                                     | 0      |
 | 5     | 2      | b"\x05"                                     | 2      |
 | 8     | 1      | b"\x00\x08"                                 | 1      |
 | 65535 | 16     | b"\xff\xff"                                 | 16     |
 | -2    | 63     | b"\xff\xff\xff\xff\xff\xff\xff\xfe"         | 63     |
 | -1    | 64     | b"\xff\xff\xff\xff\xff\xff\xff\xff"         | 64     |
 | NULL  | NULL   | b"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" | 80     |
 *-------+--------+---------------------------------------------+--------*/
```

## Conversion functions

ZetaSQL supports conversion functions. These data type
conversions are explicit, but some conversions can happen implicitly. You can
learn more about implicit and explicit conversion [here][conversion-rules].

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#array_to_string"><code>ARRAY_TO_STRING</code></a>
</td>
  <td>
    Produces a concatenation of the elements in an array as a
    <code>STRING</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/array_functions.md">Array functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#bit_cast_to_int32"><code>BIT_CAST_TO_INT32</code></a>
</td>
  <td>
    Cast bits to an <code>INT32</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/bit_functions.md">Bit functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#bit_cast_to_int64"><code>BIT_CAST_TO_INT64</code></a>
</td>
  <td>
    Cast bits to an <code>INT64</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/bit_functions.md">Bit functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#bit_cast_to_uint32"><code>BIT_CAST_TO_UINT32</code></a>
</td>
  <td>
    Cast bits to an <code>UINT32</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/bit_functions.md">Bit functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#bit_cast_to_uint64"><code>BIT_CAST_TO_UINT64</code></a>
</td>
  <td>
    Cast bits to an <code>UINT64</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/bit_functions.md">Bit functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#bool_for_json"><code>BOOL</code></a>
</td>
  <td>
    Converts a JSON boolean to a SQL <code>BOOL</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#bool_array_for_json"><code>BOOL_ARRAY</code></a>
</td>
  <td>
    Converts a JSON array of booleans to a
    SQL <code>ARRAY&lt;BOOL&gt;</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#cast"><code>CAST</code></a>
</td>
  <td>
    Convert the results of an expression to the given type.
  </td>
</tr>

<tr>
  <td><a href="#chr"><code>CHR</code></a>
</td>
  <td>
    Converts a Unicode code point to a character.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/string_functions.md">String functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#code_points_to_bytes"><code>CODE_POINTS_TO_BYTES</code></a>
</td>
  <td>
    Converts an array of extended ASCII code points to a
    <code>BYTES</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/string_functions.md">String aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#code_points_to_string"><code>CODE_POINTS_TO_STRING</code></a>
</td>
  <td>
    Converts an array of extended ASCII code points to a
    <code>STRING</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/string_functions.md">String aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#date_from_unix_date"><code>DATE_FROM_UNIX_DATE</code></a>
</td>
  <td>
    Interprets an <code>INT64</code> expression as the number of days
    since 1970-01-01.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/date_functions.md">Date functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#from_base32"><code>FROM_BASE32</code></a>
</td>
  <td>
    Converts a base32-encoded <code>STRING</code> value into a
    <code>BYTES</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/string_functions.md">String functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#from_base64"><code>FROM_BASE64</code></a>
</td>
  <td>
    Converts a base64-encoded <code>STRING</code> value into a
    <code>BYTES</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/string_functions.md">String functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#from_hex"><code>FROM_HEX</code></a>
</td>
  <td>
    Converts a hexadecimal-encoded <code>STRING</code> value into a
    <code>BYTES</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/string_functions.md">String functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#from_proto"><code>FROM_PROTO</code></a>
</td>
  <td>
    Converts a protocol buffer value into ZetaSQL value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/protocol_buffer_functions.md">Protocol buffer functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#int32_for_json"><code>INT32</code></a>
</td>
  <td>
    Converts a JSON number to a SQL <code>INT32</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#int32_array_for_json"><code>INT32_ARRAY</code></a>
</td>
  <td>
    Converts a JSON number to a SQL <code>ARRAY&lt;INT32&gt;</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#int64_for_json"><code>INT64</code></a>
</td>
  <td>
    Converts a JSON number to a SQL <code>INT64</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#int64_array_for_json"><code>INT64_ARRAY</code></a>
</td>
  <td>
    Converts a JSON array of numbers to a
    SQL <code>ARRAY&lt;INT64&gt;</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lax_bool"><code>LAX_BOOL</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a SQL <code>BOOL</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lax_bool_array"><code>LAX_BOOL_ARRAY</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;BOOL&gt;</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td>
  
  <a href="#lax_double"><code>LAX_DOUBLE</code></a>

  
  </td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>DOUBLE</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td>
    
      <a href="#lax_double_array"><code>LAX_DOUBLE_ARRAY</code></a>

    
  </td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;DOUBLE&gt;</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td>
    
      <a href="#lax_float"><code>LAX_FLOAT</code></a>

    
  </td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>FLOAT</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td>
    
      <a href="#lax_float_array"><code>LAX_FLOAT_ARRAY</code></a>

    
  </td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&gt;FLOAT&lt;</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lax_int32"><code>LAX_INT32</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a SQL <code>INT32</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lax_int32_array"><code>LAX_INT32_ARRAY</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;INT32&gt;</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lax_int64"><code>LAX_INT64</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a SQL <code>INT64</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lax_int64_array"><code>LAX_INT64_ARRAY</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;INT64&gt;</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lax_string"><code>LAX_STRING</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a SQL <code>STRING</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lax_string_array"><code>LAX_STRING_ARRAY</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;STRING&gt;</code>value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lax_uint32"><code>LAX_UINT32</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a SQL <code>UINT32</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lax_uint64"><code>LAX_UINT64</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a SQL <code>UINT64</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lax_uint64_array"><code>LAX_UINT64_ARRAY</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;UINT64&gt;</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#parse_bignumeric"><code>PARSE_BIGNUMERIC</code></a>
</td>
  <td>
    Converts a <code>STRING</code> value to a <code>BIGNUMERIC</code> value.
  </td>
</tr>

<tr>
  <td><a href="#parse_date"><code>PARSE_DATE</code></a>
</td>
  <td>
    Converts a <code>STRING</code> value to a <code>DATE</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/date_functions.md">Date functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#parse_datetime"><code>PARSE_DATETIME</code></a>
</td>
  <td>
    Converts a <code>STRING</code> value to a <code>DATETIME</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/datetime_functions.md">Datetime functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#parse_json"><code>PARSE_JSON</code></a>
</td>
  <td>
    Converts a JSON-formatted <code>STRING</code> value to a
    <code>JSON</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#parse_numeric"><code>PARSE_NUMERIC</code></a>
</td>
  <td>
    Converts a <code>STRING</code> value to a <code>NUMERIC</code> value.
  </td>
</tr>

<tr>
  <td><a href="#parse_time"><code>PARSE_TIME</code></a>
</td>
  <td>
    Converts a <code>STRING</code> value to a <code>TIME</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/time_functions.md">Time functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#parse_timestamp"><code>PARSE_TIMESTAMP</code></a>
</td>
  <td>
    Converts a <code>STRING</code> value to a <code>TIMESTAMP</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/timestamp_functions.md">Timestamp functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#safe_casting"><code>SAFE_CAST</code></a>
</td>
  <td>
    Similar to the <code>CAST</code> function, but returns <code>NULL</code>
    when a runtime error is produced.
  </td>
</tr>

<tr>
  <td><a href="#safe_convert_bytes_to_string"><code>SAFE_CONVERT_BYTES_TO_STRING</code></a>
</td>
  <td>
    Converts a <code>BYTES</code> value to a <code>STRING</code> value and
    replace any invalid UTF-8 characters with the Unicode replacement character,
    <code>U+FFFD</code>.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/string_functions.md">String functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#string_for_json"><code>STRING</code> (JSON)</a>
</td>
  <td>
    Converts a JSON string to a SQL <code>STRING</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#string_array_for_json"><code>STRING_ARRAY</code></a>
</td>
  <td>
    Converts a JSON array of strings to a SQL <code>ARRAY&lt;STRING&gt;</code>
    value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#string"><code>STRING</code> (Timestamp)</a>
</td>
  <td>
    Converts a <code>TIMESTAMP</code> value to a <code>STRING</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/timestamp_functions.md">Timestamp functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#timestamp_micros"><code>TIMESTAMP_MICROS</code></a>
</td>
  <td>
    Converts the number of microseconds since
    1970-01-01 00:00:00 UTC to a <code>TIMESTAMP</code>.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/timestamp_functions.md">Timestamp functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#timestamp_millis"><code>TIMESTAMP_MILLIS</code></a>
</td>
  <td>
    Converts the number of milliseconds since
    1970-01-01 00:00:00 UTC to a <code>TIMESTAMP</code>.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/timestamp_functions.md">Timestamp functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#timestamp_seconds"><code>TIMESTAMP_SECONDS</code></a>
</td>
  <td>
    Converts the number of seconds since
    1970-01-01 00:00:00 UTC to a <code>TIMESTAMP</code>.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/timestamp_functions.md">Timestamp functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#to_base32"><code>TO_BASE32</code></a>
</td>
  <td>
    Converts a <code>BYTES</code> value to a
    base32-encoded <code>STRING</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/string_functions.md">String functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#to_base64"><code>TO_BASE64</code></a>
</td>
  <td>
    Converts a <code>BYTES</code> value to a
    base64-encoded <code>STRING</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/string_functions.md">String functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#to_code_points"><code>TO_CODE_POINTS</code></a>
</td>
  <td>
    Converts a <code>STRING</code> or <code>BYTES</code> value into an array of
    extended ASCII code points.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/string_functions.md">String functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#to_hex"><code>TO_HEX</code></a>
</td>
  <td>
    Converts a <code>BYTES</code> value to a
    hexadecimal <code>STRING</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/string_functions.md">String functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#to_json"><code>TO_JSON</code></a>
</td>
  <td>
    Converts a SQL value to a JSON value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#to_json_string"><code>TO_JSON_STRING</code></a>
</td>
  <td>
    Converts a SQL value to a JSON-formatted <code>STRING</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#to_proto"><code>TO_PROTO</code></a>
</td>
  <td>
    Converts a ZetaSQL value into a protocol buffer value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/protocol_buffer_functions.md">Protocol buffer functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#uint32_for_json"><code>UINT32</code></a>
</td>
  <td>
    Converts a JSON number to a SQL <code>UINT32</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#uint32_array_for_json"><code>UINT32_ARRAY</code></a>
</td>
  <td>
    Converts a JSON number to a
    SQL <code>ARRAY&lt;UINT32&gt;</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#uint64_for_json"><code>UINT64</code></a>
</td>
  <td>
    Converts a JSON number to a SQL <code>UINT64</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#uint64_array_for_json"><code>UINT64_ARRAY</code></a>
</td>
  <td>
    Converts a JSON number to a SQL <code>ARRAY&lt;UINT64&gt;</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#unix_date"><code>UNIX_DATE</code></a>
</td>
  <td>
    Converts a <code>DATE</code> value to the number of days since 1970-01-01.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/date_functions.md">Date functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#unix_micros"><code>UNIX_MICROS</code></a>
</td>
  <td>
    Converts a <code>TIMESTAMP</code> value to the number of microseconds since
    1970-01-01 00:00:00 UTC.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/timestamp_functions.md">Timestamp functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#unix_millis"><code>UNIX_MILLIS</code></a>
</td>
  <td>
    Converts a <code>TIMESTAMP</code> value to the number of milliseconds
    since 1970-01-01 00:00:00 UTC.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/timestamp_functions.md">Timestamp functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#unix_seconds"><code>UNIX_SECONDS</code></a>
</td>
  <td>
    Converts a <code>TIMESTAMP</code> value to the number of seconds since
    1970-01-01 00:00:00 UTC.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/timestamp_functions.md">Timestamp functions</a>.

  </td>
</tr>

  </tbody>
</table>

### `BIT_CAST_TO_INT32`

```zetasql
BIT_CAST_TO_INT32(value)
```

**Description**

ZetaSQL supports bit casting to `INT32`. A bit
cast is a cast in which the order of bits is preserved instead of the value
those bytes represent.

The `value` parameter can represent:

+ `INT32`
+ `UINT32`

**Return Data Type**

`INT32`

**Examples**

```zetasql
SELECT BIT_CAST_TO_UINT32(-1) as UINT32_value, BIT_CAST_TO_INT32(BIT_CAST_TO_UINT32(-1)) as bit_cast_value;

/*---------------+----------------------*
 | UINT32_value  | bit_cast_value       |
 +---------------+----------------------+
 | 4294967295    | -1                   |
 *---------------+----------------------*/
```

### `BIT_CAST_TO_INT64`

```zetasql
BIT_CAST_TO_INT64(value)
```

**Description**

ZetaSQL supports bit casting to `INT64`. A bit
cast is a cast in which the order of bits is preserved instead of the value
those bytes represent.

The `value` parameter can represent:

+ `INT64`
+ `UINT64`

**Return Data Type**

`INT64`

**Example**

```zetasql
SELECT BIT_CAST_TO_UINT64(-1) as UINT64_value, BIT_CAST_TO_INT64(BIT_CAST_TO_UINT64(-1)) as bit_cast_value;

/*-----------------------+----------------------*
 | UINT64_value          | bit_cast_value       |
 +-----------------------+----------------------+
 | 18446744073709551615  | -1                   |
 *-----------------------+----------------------*/
```

### `BIT_CAST_TO_UINT32`

```zetasql
BIT_CAST_TO_UINT32(value)
```

**Description**

ZetaSQL supports bit casting to `UINT32`. A bit
cast is a cast in which the order of bits is preserved instead of the value
those bytes represent.

The `value` parameter can represent:

+ `INT32`
+ `UINT32`

**Return Data Type**

`UINT32`

**Examples**

```zetasql
SELECT -1 as UINT32_value, BIT_CAST_TO_UINT32(-1) as bit_cast_value;

/*--------------+----------------------*
 | UINT32_value | bit_cast_value       |
 +--------------+----------------------+
 | -1           | 4294967295           |
 *--------------+----------------------*/
```

### `BIT_CAST_TO_UINT64`

```zetasql
BIT_CAST_TO_UINT64(value)
```

**Description**

ZetaSQL supports bit casting to `UINT64`. A bit
cast is a cast in which the order of bits is preserved instead of the value
those bytes represent.

The `value` parameter can represent:

+ `INT64`
+ `UINT64`

**Return Data Type**

`UINT64`

**Example**

```zetasql
SELECT -1 as INT64_value, BIT_CAST_TO_UINT64(-1) as bit_cast_value;

/*--------------+----------------------*
 | INT64_value  | bit_cast_value       |
 +--------------+----------------------+
 | -1           | 18446744073709551615 |
 *--------------+----------------------*/
```

### `CAST` 
<a id="cast"></a>

```zetasql
CAST(expression AS typename [format_clause])
```

**Description**

Cast syntax is used in a query to indicate that the result type of an
expression should be converted to some other type.

When using `CAST`, a query can fail if ZetaSQL is unable to perform
the cast. If you want to protect your queries from these types of errors, you
can use [SAFE_CAST][con-func-safecast].

Casts between supported types that don't successfully map from the original
value to the target domain produce runtime errors. For example, casting
`BYTES` to `STRING` where the byte sequence isn't valid UTF-8 results in a
runtime error.

Other examples include:

+ Casting `INT64` to `INT32` where the value overflows `INT32`.
+ Casting `STRING` to `INT32` where the `STRING` contains non-digit characters.

Some casts can include a [format clause][formatting-syntax], which provides
instructions for how to conduct the
cast. For example, you could
instruct a cast to convert a sequence of bytes to a BASE64-encoded string
instead of a UTF-8-encoded string.

The structure of the format clause is unique to each type of cast and more
information is available in the section for that cast.

**Examples**

The following query results in `"true"` if `x` is `1`, `"false"` for any other
non-`NULL` value, and `NULL` if `x` is `NULL`.

```zetasql
CAST(x=1 AS STRING)
```

### CAST AS ARRAY

```zetasql
CAST(expression AS ARRAY<element_type>)
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `ARRAY`. The
`expression` parameter can represent an expression for these data types:

+ `ARRAY`

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td><code>ARRAY</code></td>
    <td><code>ARRAY</code></td>
    <td>
      
      The element types of the input
      array must be castable to the
      element types of the target array.
      For example, casting from type
      <code>ARRAY&lt;INT64&gt;</code> to
      <code>ARRAY&lt;DOUBLE&gt;</code> or
      <code>ARRAY&lt;STRING&gt;</code> is valid;
      casting from type <code>ARRAY&lt;INT64&gt;</code>
      to <code>ARRAY&lt;BYTES&gt;</code> isn't valid.
      
    </td>
  </tr>
</table>

### CAST AS BIGNUMERIC 
<a id="cast_bignumeric"></a>

```zetasql
CAST(expression AS BIGNUMERIC)
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `BIGNUMERIC`. The
`expression` parameter can represent an expression for these data types:

+ `INT32`
+ `UINT32`
+ `INT64`
+ `UINT64`
+ `FLOAT`
+ `DOUBLE`
+ `NUMERIC`
+ `BIGNUMERIC`
+ `STRING`

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td>Floating Point</td>
    <td><code>BIGNUMERIC</code></td>
    <td>
      The floating point number will round
      <a href="https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero">half away from zero</a>.

      Casting a <code>NaN</code>, <code>+inf</code> or
      <code>-inf</code> will return an error. Casting a value outside the range
      of <code>BIGNUMERIC</code> returns an overflow error.
    </td>
  </tr>
  <tr>
    <td><code>STRING</code></td>
    <td><code>BIGNUMERIC</code></td>
    <td>
      The numeric literal contained in the string must not exceed
      the maximum precision or range of the
      <code>BIGNUMERIC</code> type, or an error will occur. If the number of
      digits after the decimal point exceeds 38, then the resulting
      <code>BIGNUMERIC</code> value will round
      <a href="https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero">half away from zero</a>

      to have 38 digits after the decimal point.
    </td>
  </tr>
</table>

### CAST AS BOOL

```zetasql
CAST(expression AS BOOL)
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `BOOL`. The
`expression` parameter can represent an expression for these data types:

+ `INT32`
+ `UINT32`
+ `INT64`
+ `UINT64`
+ `BOOL`
+ `STRING`

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td>Integer</td>
    <td><code>BOOL</code></td>
    <td>
      Returns <code>FALSE</code> if <code>x</code> is <code>0</code>,
      <code>TRUE</code> otherwise.
    </td>
  </tr>
  <tr>
    <td><code>STRING</code></td>
    <td><code>BOOL</code></td>
    <td>
      Returns <code>TRUE</code> if <code>x</code> is <code>"true"</code> and
      <code>FALSE</code> if <code>x</code> is <code>"false"</code><br />
      All other values of <code>x</code> are invalid and throw an error instead
      of casting to a boolean.<br />
      A string is case-insensitive when converting
      to a boolean.
    </td>
  </tr>
</table>

### CAST AS BYTES

```zetasql
CAST(expression AS BYTES [format_clause])
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `BYTES`. The
`expression` parameter can represent an expression for these data types:

+ `BYTES`
+ `STRING`
+ `PROTO`

**Format clause**

When an expression of one type is cast to another type, you can use the
[format clause][formatting-syntax] to provide instructions for how to conduct
the cast. You can use the format clause in this section if `expression` is a
`STRING`.

+ [Format string as bytes][format-string-as-bytes]

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td><code>STRING</code></td>
    <td><code>BYTES</code></td>
    <td>
      Strings are cast to bytes using UTF-8 encoding. For example,
      the string "&copy;", when cast to
      bytes, would become a 2-byte sequence with the
      hex values C2 and A9.
    </td>
  </tr>
  
  <tr>
    <td><code>PROTO</code></td>
    <td><code>BYTES</code></td>
    <td>
      Returns the proto2 wire format bytes
      of <code>x</code>.
    </td>
  </tr>
  
</table>

### CAST AS DATE

```zetasql
CAST(expression AS DATE [format_clause])
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `DATE`. The `expression`
parameter can represent an expression for these data types:

+ `STRING`
+ `DATETIME`
+ `TIMESTAMP`

**Format clause**

When an expression of one type is cast to another type, you can use the
[format clause][formatting-syntax] to provide instructions for how to conduct
the cast. You can use the format clause in this section if `expression` is a
`STRING`.

+ [Format string as date and time][format-string-as-date-time]

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td><code>STRING</code></td>
    <td><code>DATE</code></td>
    <td>
      When casting from string to date, the string must conform to
      the supported date literal format, and is independent of time zone. If the
      string expression is invalid or represents a date that's outside of the
      supported min/max range, then an error is produced.
    </td>
  </tr>
  
  <tr>
    <td><code>TIMESTAMP</code></td>
    <td><code>DATE</code></td>
    <td>
      Casting from a timestamp to date effectively truncates the timestamp as
      of the default time zone.
    </td>
  </tr>
  
</table>

### CAST AS DATETIME

```zetasql
CAST(expression AS DATETIME [format_clause])
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `DATETIME`. The
`expression` parameter can represent an expression for these data types:

+ `STRING`
+ `DATETIME`
+ `TIMESTAMP`

**Format clause**

When an expression of one type is cast to another type, you can use the
[format clause][formatting-syntax] to provide instructions for how to conduct
the cast. You can use the format clause in this section if `expression` is a
`STRING`.

+ [Format string as date and time][format-string-as-date-time]

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td><code>STRING</code></td>
    <td><code>DATETIME</code></td>
    <td>
      When casting from string to datetime, the string must conform to the
      supported datetime literal format, and is independent of time zone. If
      the string expression is invalid or represents a datetime that's outside
      of the supported min/max range, then an error is produced.
    </td>
  </tr>
  
  <tr>
    <td><code>TIMESTAMP</code></td>
    <td><code>DATETIME</code></td>
    <td>
      Casting from a timestamp to datetime effectively truncates the timestamp
      as of the default time zone.
    </td>
  </tr>
  
</table>

### CAST AS ENUM

```zetasql
CAST(expression AS ENUM)
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `ENUM`. The `expression`
parameter can represent an expression for these data types:

+ `INT32`
+ `UINT32`
+ `INT64`
+ `UINT64`
+ `STRING`
+ `ENUM`

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td><code>ENUM</code></td>
    <td><code>ENUM</code></td>
    <td>Must have the same enum name.</td>
  </tr>
</table>

### CAST AS Floating Point 
<a id="cast_as_floating_point"></a>

```zetasql
CAST(expression AS DOUBLE)
```

```zetasql
CAST(expression AS FLOAT)
```

**Description**

ZetaSQL supports [casting][con-func-cast] to floating point types.
The `expression` parameter can represent an expression for these data types:

+ `INT32`
+ `UINT32`
+ `INT64`
+ `UINT64`
+ `FLOAT`
+ `DOUBLE`
+ `NUMERIC`
+ `BIGNUMERIC`
+ `STRING`

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td>Integer</td>
    <td>Floating Point</td>
    <td>
      Returns a close but potentially not exact floating point value.
    </td>
  </tr>
  
  <tr>
    <td><code>NUMERIC</code></td>
    <td>Floating Point</td>
    <td>
      <code>NUMERIC</code> will convert to the closest floating point number
      with a possible loss of precision.
    </td>
  </tr>
  
  
  <tr>
    <td><code>BIGNUMERIC</code></td>
    <td>Floating Point</td>
    <td>
      <code>BIGNUMERIC</code> will convert to the closest floating point number
      with a possible loss of precision.
    </td>
  </tr>
  
  <tr>
    <td><code>STRING</code></td>
    <td>Floating Point</td>
    <td>
      Returns <code>x</code> as a floating point value, interpreting it as
      having the same form as a valid floating point literal.
      Also supports casts from <code>"[+,-]inf"</code> to
      <code>[,-]Infinity</code>,
      <code>"[+,-]infinity"</code> to <code>[,-]Infinity</code>, and
      <code>"[+,-]nan"</code> to <code>NaN</code>.
      Conversions are case-insensitive.
    </td>
  </tr>
</table>

### CAST AS Integer 
<a id="cast_as_integer"></a>

```zetasql
CAST(expression AS INT32)
```

```zetasql
CAST(expression AS UINT32)
```

```zetasql
CAST(expression AS INT64)
```

```zetasql
CAST(expression AS UINT64)
```

**Description**

ZetaSQL supports [casting][con-func-cast] to integer types.
The `expression` parameter can represent an expression for these data types:

+ `INT32`
+ `UINT32`
+ `INT64`
+ `UINT64`
+ `FLOAT`
+ `DOUBLE`
+ `NUMERIC`
+ `BIGNUMERIC`
+ `ENUM`
+ `BOOL`
+ `STRING`

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  
  <tr>
    <td>
      Floating Point
    </td>
    <td>
      Integer
    </td>
    <td>
      Returns the closest integer value.<br />
      Halfway cases such as 1.5 or -0.5 round away from zero.
    </td>
  </tr>
  <tr>
    <td><code>BOOL</code></td>
    <td>Integer</td>
    <td>
      Returns <code>1</code> if <code>x</code> is <code>TRUE</code>,
      <code>0</code> otherwise.
    </td>
  </tr>
  
  <tr>
    <td><code>STRING</code></td>
    <td>Integer</td>
    <td>
      A hex string can be cast to an integer. For example,
      <code>0x123</code> to <code>291</code> or <code>-0x123</code> to
      <code>-291</code>.
    </td>
  </tr>
  
</table>

**Examples**

If you are working with hex strings (`0x123`), you can cast those strings as
integers:

```zetasql
SELECT '0x123' as hex_value, CAST('0x123' as INT64) as hex_to_int;

/*-----------+------------*
 | hex_value | hex_to_int |
 +-----------+------------+
 | 0x123     | 291        |
 *-----------+------------*/
```

```zetasql
SELECT '-0x123' as hex_value, CAST('-0x123' as INT64) as hex_to_int;

/*-----------+------------*
 | hex_value | hex_to_int |
 +-----------+------------+
 | -0x123    | -291       |
 *-----------+------------*/
```

### CAST AS INTERVAL

```zetasql
CAST(expression AS INTERVAL)
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `INTERVAL`. The
`expression` parameter can represent an expression for these data types:

+ `STRING`

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td><code>STRING</code></td>
    <td><code>INTERVAL</code></td>
    <td>
      When casting from string to interval, the string must conform to either
      <a href="https://en.wikipedia.org/wiki/ISO_8601#Durations">ISO 8601 Duration</a>

      standard or to interval literal
      format 'Y-M D H:M:S.F'. Partial interval literal formats are also accepted
      when they aren't ambiguous, for example 'H:M:S'.
      If the string expression is invalid or represents an interval that is
      outside of the supported min/max range, then an error is produced.
    </td>
  </tr>
</table>

**Examples**

```zetasql
SELECT input, CAST(input AS INTERVAL) AS output
FROM UNNEST([
  '1-2 3 10:20:30.456',
  '1-2',
  '10:20:30',
  'P1Y2M3D',
  'PT10H20M30,456S'
]) input

/*--------------------+--------------------*
 | input              | output             |
 +--------------------+--------------------+
 | 1-2 3 10:20:30.456 | 1-2 3 10:20:30.456 |
 | 1-2                | 1-2 0 0:0:0        |
 | 10:20:30           | 0-0 0 10:20:30     |
 | P1Y2M3D            | 1-2 3 0:0:0        |
 | PT10H20M30,456S    | 0-0 0 10:20:30.456 |
 *--------------------+--------------------*/
```

### CAST AS NUMERIC 
<a id="cast_numeric"></a>

```zetasql
CAST(expression AS NUMERIC)
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `NUMERIC`. The
`expression` parameter can represent an expression for these data types:

+ `INT32`
+ `UINT32`
+ `INT64`
+ `UINT64`
+ `FLOAT`
+ `DOUBLE`
+ `NUMERIC`
+ `BIGNUMERIC`
+ `STRING`

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td><code>Floating Point</code></td>
    <td><code>NUMERIC</code></td>
    <td>
      The floating point number will round
      <a href="https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero">half away from zero</a>.

      Casting a <code>NaN</code>, <code>+inf</code> or
      <code>-inf</code> will return an error. Casting a value outside the range
      of <code>NUMERIC</code> returns an overflow error.
    </td>
  </tr>
  <tr>
    <td><code>STRING</code></td>
    <td><code>NUMERIC</code></td>
    <td>
      The numeric literal contained in the string must not exceed
      the maximum precision or range of the <code>NUMERIC</code>
      type, or an error will occur. If the number of digits
      after the decimal point exceeds nine, then the resulting
      <code>NUMERIC</code> value will round
      <a href="https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero">half away from zero</a>.

      to have nine digits after the decimal point.
    </td>
  </tr>
</table>

### CAST AS PROTO

```zetasql
CAST(expression AS PROTO)
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `PROTO`. The
`expression` parameter can represent an expression for these data types:

+ `STRING`
+ `BYTES`
+ `PROTO`

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td><code>STRING</code></td>
    <td><code>PROTO</code></td>
    <td>
      Returns the protocol buffer that results from parsing
      from proto2 text format.<br />
      Throws an error if parsing fails, e.g., if not all required fields are
      set.
    </td>
  </tr>
  <tr>
    <td><code>BYTES</code></td>
    <td><code>PROTO</code></td>
    <td>
      Returns the protocol buffer that results from parsing
      <code>x</code> from the proto2 wire format.<br />
      Throws an error if parsing fails, e.g., if not all required fields are
      set.
    </td>
  </tr>
  <tr>
    <td><code>PROTO</code></td>
    <td><code>PROTO</code></td>
    <td>Must have the same protocol buffer name.</td>
  </tr>
</table>

**Example**

This example references a protocol buffer called `Award`.

```proto
message Award {
  required int32 year = 1;
  optional int32 month = 2;
  repeated Type type = 3;

  message Type {
    optional string award_name = 1;
    optional string category = 2;
  }
}
```

```zetasql
SELECT
  CAST(
    '''
    year: 2001
    month: 9
    type { award_name: 'Best Artist' category: 'Artist' }
    type { award_name: 'Best Album' category: 'Album' }
    '''
    AS zetasql.examples.music.Award)
  AS award_col

/*---------------------------------------------------------*
 | award_col                                               |
 +---------------------------------------------------------+
 | {                                                       |
 |   year: 2001                                            |
 |   month: 9                                              |
 |   type { award_name: "Best Artist" category: "Artist" } |
 |   type { award_name: "Best Album" category: "Album" }   |
 | }                                                       |
 *---------------------------------------------------------*/
```

### CAST AS RANGE

```zetasql
CAST(expression AS RANGE)
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `RANGE`. The
`expression` parameter can represent an expression for these data types:

+ `STRING`

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td><code>STRING</code></td>
    <td><code>RANGE</code></td>
    <td>
      When casting from string to range, the string must conform to the
      supported range literal format. If the string expression is invalid or
      represents a range that's outside of the supported subtype min/max range,
      then an error is produced.
    </td>
  </tr>
</table>

**Examples**

```zetasql
SELECT CAST(
  '[2020-01-01, 2020-01-02)'
  AS RANGE<DATE>) AS string_to_range

/*----------------------------------------*
 | string_to_range                        |
 +----------------------------------------+
 | [DATE '2020-01-01', DATE '2020-01-02') |
 *----------------------------------------*/
```

```zetasql
SELECT CAST(
  '[2014-09-27 12:30:00.45, 2016-10-17 11:15:00.33)'
  AS RANGE<DATETIME>) AS string_to_range

/*------------------------------------------------------------------------*
 | string_to_range                                                        |
 +------------------------------------------------------------------------+
 | [DATETIME '2014-09-27 12:30:00.45', DATETIME '2016-10-17 11:15:00.33') |
 *------------------------------------------------------------------------*/
```

```zetasql
SELECT CAST(
  '[2014-09-27 12:30:00+08, 2016-10-17 11:15:00+08)'
  AS RANGE<TIMESTAMP>) AS string_to_range

-- Results depend upon where this query was executed.
/*--------------------------------------------------------------------------*
 | string_to_range                                                          |
 +--------------------------------------------------------------------------+
 | [TIMESTAMP '2014-09-27 12:30:00+08', TIMESTAMP '2016-10-17 11:15:00+08') |
 *--------------------------------------------------------------------------*/
```

```zetasql
SELECT CAST(
  '[UNBOUNDED, 2020-01-02)'
  AS RANGE<DATE>) AS string_to_range

/*--------------------------------*
 | string_to_range                |
 +--------------------------------+
 | [UNBOUNDED, DATE '2020-01-02') |
 *--------------------------------*/
```

```zetasql
SELECT CAST(
  '[2020-01-01, NULL)'
  AS RANGE<DATE>) AS string_to_range

/*--------------------------------*
 | string_to_range                |
 +--------------------------------+
 | [DATE '2020-01-01', UNBOUNDED) |
 *--------------------------------*/
```

### CAST AS STRING 
<a id="cast_as_string"></a>

```zetasql
CAST(expression AS STRING [format_clause [AT TIME ZONE timezone_expr]])
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `STRING`. The
`expression` parameter can represent an expression for these data types:

+ `INT32`
+ `UINT32`
+ `INT64`
+ `UINT64`
+ `FLOAT`
+ `DOUBLE`
+ `NUMERIC`
+ `BIGNUMERIC`
+ `ENUM`
+ `BOOL`
+ `BYTES`
+ `PROTO`
+ `TIME`
+ `DATE`
+ `DATETIME`
+ `TIMESTAMP`
+ `RANGE`
+ `INTERVAL`
+ `STRING`

**Format clause**

When an expression of one type is cast to another type, you can use the
[format clause][formatting-syntax] to provide instructions for how to conduct
the cast. You can use the format clause in this section if `expression` is one
of these data types:

+ `INT32`
+ `UINT32`
+ `INT64`
+ `UINT64`
+ `FLOAT`
+ `DOUBLE`
+ `NUMERIC`
+ `BIGNUMERIC`
+ `BYTES`
+ `TIME`
+ `DATE`
+ `DATETIME`
+ `TIMESTAMP`

The format clause for `STRING` has an additional optional clause called
`AT TIME ZONE timezone_expr`, which you can use to specify a specific time zone
to use during formatting of a `TIMESTAMP`. If this optional clause isn't
included when formatting a `TIMESTAMP`, your current time zone is used.

For more information, see the following topics:

+ [Format bytes as string][format-bytes-as-string]
+ [Format date and time as string][format-date-time-as-string]
+ [Format numeric type as string][format-numeric-type-as-string]

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td>Floating Point</td>
    <td><code>STRING</code></td>
    <td>Returns an approximate string representation. A returned
    <code>NaN</code> or <code>0</code> will not be signed.<br />
    </td>
  </tr>
  <tr>
    <td><code>BOOL</code></td>
    <td><code>STRING</code></td>
    <td>
      Returns <code>"true"</code> if <code>x</code> is <code>TRUE</code>,
      <code>"false"</code> otherwise.</td>
  </tr>
  <tr>
    <td><code>BYTES</code></td>
    <td><code>STRING</code></td>
    <td>
      Returns <code>x</code> interpreted as a UTF-8 string.<br />
      For example, the bytes literal
      <code>b'\xc2\xa9'</code>, when cast to a string,
      is interpreted as UTF-8 and becomes the unicode character "&copy;".<br />
      An error occurs if <code>x</code> isn't valid UTF-8.</td>
  </tr>
  
  <tr>
    <td><code>ENUM</code></td>
    <td><code>STRING</code></td>
    <td>
      Returns the canonical enum value name of
      <code>x</code>.<br />
      If an enum value has multiple names (aliases),
      the canonical name/alias for that value is used.</td>
  </tr>
  
  
  <tr>
    <td><code>PROTO</code></td>
    <td><code>STRING</code></td>
    <td>Returns the proto2 text format representation of <code>x</code>.</td>
  </tr>
  
  
  <tr>
    <td><code>TIME</code></td>
    <td><code>STRING</code></td>
    <td>
      Casting from a time type to a string is independent of time zone and
      is of the form <code>HH:MM:SS</code>.
    </td>
  </tr>
  
  
  <tr>
    <td><code>DATE</code></td>
    <td><code>STRING</code></td>
    <td>
      Casting from a date type to a string is independent of time zone and is
      of the form <code>YYYY-MM-DD</code>.
    </td>
  </tr>
  
  
  <tr>
    <td><code>DATETIME</code></td>
    <td><code>STRING</code></td>
    <td>
      Casting from a datetime type to a string is independent of time zone and
      is of the form <code>YYYY-MM-DD HH:MM:SS</code>.
    </td>
  </tr>
  
  
  <tr>
    <td><code>TIMESTAMP</code></td>
    <td><code>STRING</code></td>
    <td>
      When casting from timestamp types to string, the timestamp is interpreted
      using the default time zone, which is implementation defined. The number of
      subsecond digits produced depends on the number of trailing zeroes in the
      subsecond part: the CAST function will truncate zero, three, or six
      digits.
    </td>
  </tr>
  
  <tr>
    <td><code>INTERVAL</code></td>
    <td><code>STRING</code></td>
    <td>
      Casting from an interval to a string is of the form
      <code>Y-M D H:M:S</code>.
    </td>
  </tr>
  
</table>

**Examples**

```zetasql
SELECT CAST(CURRENT_DATE() AS STRING) AS current_date

/*---------------*
 | current_date  |
 +---------------+
 | 2021-03-09    |
 *---------------*/
```

```zetasql
SELECT CAST(CURRENT_DATE() AS STRING FORMAT 'DAY') AS current_day

/*-------------*
 | current_day |
 +-------------+
 | MONDAY      |
 *-------------*/
```

```zetasql
SELECT CAST(
  TIMESTAMP '2008-12-25 00:00:00+00:00'
  AS STRING FORMAT 'YYYY-MM-DD HH24:MI:SS TZH:TZM') AS date_time_to_string

-- Results depend upon where this query was executed.
/*------------------------------*
 | date_time_to_string          |
 +------------------------------+
 | 2008-12-24 16:00:00 -08:00   |
 *------------------------------*/
```

```zetasql
SELECT CAST(
  TIMESTAMP '2008-12-25 00:00:00+00:00'
  AS STRING FORMAT 'YYYY-MM-DD HH24:MI:SS TZH:TZM'
  AT TIME ZONE 'Asia/Kolkata') AS date_time_to_string

-- Because the time zone is specified, the result is always the same.
/*------------------------------*
 | date_time_to_string          |
 +------------------------------+
 | 2008-12-25 05:30:00 +05:30   |
 *------------------------------*/
```

```zetasql
SELECT CAST(INTERVAL 3 DAY AS STRING) AS interval_to_string

/*--------------------*
 | interval_to_string |
 +--------------------+
 | 0-0 3 0:0:0        |
 *--------------------*/
```

```zetasql
SELECT CAST(
  INTERVAL "1-2 3 4:5:6.789" YEAR TO SECOND
  AS STRING) AS interval_to_string

/*--------------------*
 | interval_to_string |
 +--------------------+
 | 1-2 3 4:5:6.789    |
 *--------------------*/
```

### CAST AS STRUCT

```zetasql
CAST(expression AS STRUCT)
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `STRUCT`. The
`expression` parameter can represent an expression for these data types:

+ `STRUCT`

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td><code>STRUCT</code></td>
    <td><code>STRUCT</code></td>
    <td>
      Allowed if the following conditions are met:<br />
      <ol>
        <li>
          The two structs have the same number of
          fields.
        </li>
        <li>
          The original struct field types can be
          explicitly cast to the corresponding target
          struct field types (as defined by field
          order, not field name).
        </li>
      </ol>
    </td>
  </tr>
</table>

### CAST AS TIME

```zetasql
CAST(expression AS TIME [format_clause])
```

**Description**

ZetaSQL supports [casting][con-func-cast] to TIME. The `expression`
parameter can represent an expression for these data types:

+ `STRING`
+ `TIME`
+ `DATETIME`
+ `TIMESTAMP`

**Format clause**

When an expression of one type is cast to another type, you can use the
[format clause][formatting-syntax] to provide instructions for how to conduct
the cast. You can use the format clause in this section if `expression` is a
`STRING`.

+ [Format string as date and time][format-string-as-date-time]

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td><code>STRING</code></td>
    <td><code>TIME</code></td>
    <td>
      When casting from string to time, the string must conform to
      the supported time literal format, and is independent of time zone. If the
      string expression is invalid or represents a time that's outside of the
      supported min/max range, then an error is produced.
    </td>
  </tr>
</table>

### CAST AS TIMESTAMP

```zetasql
CAST(expression AS TIMESTAMP [format_clause [AT TIME ZONE timezone_expr]])
```

**Description**

ZetaSQL supports [casting][con-func-cast] to `TIMESTAMP`. The
`expression` parameter can represent an expression for these data types:

+ `STRING`
+ `DATETIME`
+ `TIMESTAMP`

**Format clause**

When an expression of one type is cast to another type, you can use the
[format clause][formatting-syntax] to provide instructions for how to conduct
the cast. You can use the format clause in this section if `expression` is a
`STRING`.

+ [Format string as date and time][format-string-as-date-time]

The format clause for `TIMESTAMP` has an additional optional clause called
`AT TIME ZONE timezone_expr`, which you can use to specify a specific time zone
to use during formatting. If this optional clause isn't included, your
current time zone is used.

**Conversion rules**

<table>
  <tr>
    <th>From</th>
    <th>To</th>
    <th>Rule(s) when casting <code>x</code></th>
  </tr>
  <tr>
    <td><code>STRING</code></td>
    <td><code>TIMESTAMP</code></td>
    <td>
      When casting from string to a timestamp, <code>string_expression</code>
      must conform to the supported timestamp literal formats, or else a runtime
      error occurs. The <code>string_expression</code> may itself contain a
      time zone.
      <br /><br />
      If there is a time zone in the <code>string_expression</code>, that
      time zone is used for conversion, otherwise the default time zone,
      which is implementation defined, is used. If the string has fewer than six digits,
      then it's implicitly widened.
      <br /><br />
      An error is produced if the <code>string_expression</code> is invalid,
      has more than six subsecond digits (i.e., precision greater than
      microseconds), or represents a time outside of the supported timestamp
      range.
    </td>
  </tr>
  
  <tr>
    <td><code>DATE</code></td>
    <td><code>TIMESTAMP</code></td>
    <td>
      Casting from a date to a timestamp interprets <code>date_expression</code>
      as of midnight (start of the day) in the default time zone,
      which is implementation defined.
    </td>
  </tr>
  
  
  <tr>
    <td><code>DATETIME</code></td>
    <td><code>TIMESTAMP</code></td>
    <td>
      Casting from a datetime to a timestamp interprets
      <code>datetime_expression</code> in the default time zone,
      which is implementation defined.
      <br /><br />
      Most valid datetime values have exactly one corresponding timestamp
      in each time zone. However, there are certain combinations of valid
      datetime values and time zones that have zero or two corresponding
      timestamp values. This happens in a time zone when clocks are set forward
      or set back, such as for Daylight Savings Time.
      When there are two valid timestamps, the earlier one is used.
      When there is no valid timestamp, the length of the gap in time
      (typically one hour) is added to the datetime.
    </td>
  </tr>
  
</table>

**Examples**

The following example casts a string-formatted timestamp as a timestamp:

```zetasql
SELECT CAST("2020-06-02 17:00:53.110+00:00" AS TIMESTAMP) AS as_timestamp

-- Results depend upon where this query was executed.
/*----------------------------*
 | as_timestamp               |
 +----------------------------+
 | 2020-06-03 00:00:53.110+00 |
 *----------------------------*/
```

The following examples cast a string-formatted date and time as a timestamp.
These examples return the same output as the previous example.

```zetasql
SELECT CAST('06/02/2020 17:00:53.110' AS TIMESTAMP FORMAT 'MM/DD/YYYY HH24:MI:SS.FF3' AT TIME ZONE 'UTC') AS as_timestamp
```

```zetasql
SELECT CAST('06/02/2020 17:00:53.110' AS TIMESTAMP FORMAT 'MM/DD/YYYY HH24:MI:SS.FF3' AT TIME ZONE '+00') AS as_timestamp
```

```zetasql
SELECT CAST('06/02/2020 17:00:53.110 +00' AS TIMESTAMP FORMAT 'MM/DD/YYYY HH24:MI:SS.FF3 TZH') AS as_timestamp
```

[formatting-syntax]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#formatting_syntax

[format-string-as-bytes]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#format_string_as_bytes

[format-bytes-as-string]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#format_bytes_as_string

[format-date-time-as-string]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#format_date_time_as_string

[format-string-as-date-time]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#format_string_as_datetime

[format-numeric-type-as-string]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#format_numeric_type_as_string

[con-func-cast]: #cast

[con-func-safecast]: #safe_casting

### `PARSE_BIGNUMERIC` 
<a id="parse_bignumeric"></a>

```zetasql
PARSE_BIGNUMERIC(string_expression)
```

**Description**

Converts a `STRING` to a `BIGNUMERIC` value.

The numeric literal contained in the string must not exceed the
[maximum precision or range][bignumeric-type] of the `BIGNUMERIC` type, or an
error occurs. If the number of digits after the decimal point exceeds 38, then
the resulting `BIGNUMERIC` value rounds
[half away from zero][half-from-zero-wikipedia] to have 38 digits after the
decimal point.

```zetasql

-- This example shows how a string with a decimal point is parsed.
SELECT PARSE_BIGNUMERIC("123.45") AS parsed;

/*--------*
 | parsed |
 +--------+
 | 123.45 |
 *--------*/

-- This example shows how a string with an exponent is parsed.
SELECT PARSE_BIGNUMERIC("123.456E37") AS parsed;

/*-----------------------------------------*
 | parsed                                  |
 +-----------------------------------------+
 | 123400000000000000000000000000000000000 |
 *-----------------------------------------*/

-- This example shows the rounding when digits after the decimal point exceeds 38.
SELECT PARSE_BIGNUMERIC("1.123456789012345678901234567890123456789") as parsed;

/*------------------------------------------*
 | parsed                                   |
 +------------------------------------------+
 | 1.12345678901234567890123456789012345679 |
 *------------------------------------------*/
```

This function is similar to using the [`CAST AS BIGNUMERIC`][cast-bignumeric]
function except that the `PARSE_BIGNUMERIC` function only accepts string inputs
and allows the following in the string:

+   Spaces between the sign (+/-) and the number
+   Signs (+/-) after the number

Rules for valid input strings:

<table>
  <thead>
    <tr>
      <th>Rule</th>
      <th>Example Input</th>
      <th>Output</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        The string can only contain digits, commas, decimal points and signs.
      </td>
      <td>
        "- 12,34567,89.0"
      </td>
      <td>-123456789</td>
    </tr>
    <tr>
      <td>Whitespaces are allowed anywhere except between digits.</td>
      <td>
        "  -  12.345  "
      </td>
      <td>-12.345</td>
    </tr>
    <tr>
      <td>Only digits and commas are allowed before the decimal point.</td>
      <td>
        " 12,345,678"
      </td>
      <td>12345678</td>
    </tr>
    <tr>
      <td>Only digits are allowed after the decimal point.</td>
      <td>
        "1.234 "
      </td>
      <td>1.234</td>
    </tr>
    <tr>
      <td>
        Use <code>E</code> or <code>e</code> for exponents. After the
        <code>e</code>, digits and a leading sign indicator are allowed.
      </td>
      <td>" 123.45e-1"</td>
      <td>12.345</td>
    </tr>
    <tr>
      <td>
        If the integer part isn't empty, then it must contain at least one
        digit.
      </td>
      <td>" 0,.12 -"</td>
      <td>-0.12</td>
    </tr>
    <tr>
      <td>
        If the string contains a decimal point, then it must contain at least
        one digit.
      </td>
      <td>" .1"</td>
      <td>0.1</td>
    </tr>
    <tr>
      <td>
        The string can't contain more than one sign.
      </td>
      <td>" 0.5 +"</td>
      <td>0.5</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

`BIGNUMERIC`

**Examples**

This example shows an input with spaces before, after, and between the
sign and the number:

```zetasql
SELECT PARSE_BIGNUMERIC("  -  12.34 ") as parsed;

/*--------*
 | parsed |
 +--------+
 | -12.34 |
 *--------*/
```

This example shows an input with an exponent as well as the sign after the
number:

```zetasql
SELECT PARSE_BIGNUMERIC("12.34e-1-") as parsed;

/*--------*
 | parsed |
 +--------+
 | -1.234 |
 *--------*/
```

This example shows an input with multiple commas in the integer part of the
number:

```zetasql
SELECT PARSE_BIGNUMERIC("  1,2,,3,.45 + ") as parsed;

/*--------*
 | parsed |
 +--------+
 | 123.45 |
 *--------*/
```

This example shows an input with a decimal point and no digits in the whole
number part:

```zetasql
SELECT PARSE_BIGNUMERIC(".1234  ") as parsed;

/*--------*
 | parsed |
 +--------+
 | 0.1234 |
 *--------*/
```

**Examples of invalid inputs**

This example is invalid because the whole number part contains no digits:

```zetasql
SELECT PARSE_BIGNUMERIC(",,,.1234  ") as parsed;
```

This example is invalid because there are whitespaces between digits:

```zetasql
SELECT PARSE_BIGNUMERIC("1  23.4 5  ") as parsed;
```

This example is invalid because the number is empty except for an exponent:

```zetasql
SELECT PARSE_BIGNUMERIC("  e1 ") as parsed;
```

This example is invalid because the string contains multiple signs:

```zetasql
SELECT PARSE_BIGNUMERIC("  - 12.3 - ") as parsed;
```

This example is invalid because the value of the number falls outside the range
of `BIGNUMERIC`:

```zetasql
SELECT PARSE_BIGNUMERIC("12.34E100 ") as parsed;
```

This example is invalid because the string contains invalid characters:

```zetasql
SELECT PARSE_BIGNUMERIC("$12.34") as parsed;
```

[half-from-zero-wikipedia]: https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero

[cast-bignumeric]: #cast_bignumeric

[bignumeric-type]: https://github.com/google/zetasql/blob/master/docs/data-types.md#decimal_types

### `PARSE_NUMERIC`

```zetasql
PARSE_NUMERIC(string_expression)
```

**Description**

Converts a `STRING` to a `NUMERIC` value.

The numeric literal contained in the string must not exceed the
[maximum precision or range][numeric-type] of the `NUMERIC` type, or an error
occurs. If the number of digits after the decimal point exceeds nine, then the
resulting `NUMERIC` value rounds
[half away from zero][half-from-zero-wikipedia] to have nine digits after the
decimal point.

```zetasql

-- This example shows how a string with a decimal point is parsed.
SELECT PARSE_NUMERIC("123.45") AS parsed;

/*--------*
 | parsed |
 +--------+
 | 123.45 |
 *--------*/

-- This example shows how a string with an exponent is parsed.
SELECT PARSE_NUMERIC("12.34E27") as parsed;

/*-------------------------------*
 | parsed                        |
 +-------------------------------+
 | 12340000000000000000000000000 |
 *-------------------------------*/

-- This example shows the rounding when digits after the decimal point exceeds 9.
SELECT PARSE_NUMERIC("1.0123456789") as parsed;

/*-------------*
 | parsed      |
 +-------------+
 | 1.012345679 |
 *-------------*/
```

This function is similar to using the [`CAST AS NUMERIC`][cast-numeric] function
except that the `PARSE_NUMERIC` function only accepts string inputs and allows
the following in the string:

+   Spaces between the sign (+/-) and the number
+   Signs (+/-) after the number

Rules for valid input strings:

<table>
  <thead>
    <tr>
      <th>Rule</th>
      <th>Example Input</th>
      <th>Output</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        The string can only contain digits, commas, decimal points and signs.
      </td>
      <td>
        "- 12,34567,89.0"
      </td>
      <td>-123456789</td>
    </tr>
    <tr>
      <td>Whitespaces are allowed anywhere except between digits.</td>
      <td>
        "  -  12.345  "
      </td>
      <td>-12.345</td>
    </tr>
    <tr>
      <td>Only digits and commas are allowed before the decimal point.</td>
      <td>
        " 12,345,678"
      </td>
      <td>12345678</td>
    </tr>
    <tr>
      <td>Only digits are allowed after the decimal point.</td>
      <td>
        "1.234 "
      </td>
      <td>1.234</td>
    </tr>
    <tr>
      <td>
        Use <code>E</code> or <code>e</code> for exponents. After
        the <code>e</code>,
        digits and a leading sign indicator are allowed.
      </td>
      <td>" 123.45e-1"</td>
      <td>12.345</td>
    </tr>
    <tr>
      <td>
        If the integer part isn't empty, then it must contain at least one
        digit.
      </td>
      <td>" 0,.12 -"</td>
      <td>-0.12</td>
    </tr>
    <tr>
      <td>
        If the string contains a decimal point, then it must contain at least
        one digit.
      </td>
      <td>" .1"</td>
      <td>0.1</td>
    </tr>
    <tr>
      <td>
        The string can't contain more than one sign.
      </td>
      <td>" 0.5 +"</td>
      <td>0.5</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

`NUMERIC`

**Examples**

This example shows an input with spaces before, after, and between the
sign and the number:

```zetasql
SELECT PARSE_NUMERIC("  -  12.34 ") as parsed;

/*--------*
 | parsed |
 +--------+
 | -12.34 |
 *--------*/
```

This example shows an input with an exponent as well as the sign after the
number:

```zetasql
SELECT PARSE_NUMERIC("12.34e-1-") as parsed;

/*--------*
 | parsed |
 +--------+
 | -1.234 |
 *--------*/
```

This example shows an input with multiple commas in the integer part of the
number:

```zetasql
SELECT PARSE_NUMERIC("  1,2,,3,.45 + ") as parsed;

/*--------*
 | parsed |
 +--------+
 | 123.45 |
 *--------*/
```

This example shows an input with a decimal point and no digits in the whole
number part:

```zetasql
SELECT PARSE_NUMERIC(".1234  ") as parsed;

/*--------*
 | parsed |
 +--------+
 | 0.1234 |
 *--------*/
```

**Examples of invalid inputs**

This example is invalid because the whole number part contains no digits:

```zetasql
SELECT PARSE_NUMERIC(",,,.1234  ") as parsed;
```

This example is invalid because there are whitespaces between digits:

```zetasql
SELECT PARSE_NUMERIC("1  23.4 5  ") as parsed;
```

This example is invalid because the number is empty except for an exponent:

```zetasql
SELECT PARSE_NUMERIC("  e1 ") as parsed;
```

This example is invalid because the string contains multiple signs:

```zetasql
SELECT PARSE_NUMERIC("  - 12.3 - ") as parsed;
```

This example is invalid because the value of the number falls outside the range
of `BIGNUMERIC`:

```zetasql
SELECT PARSE_NUMERIC("12.34E100 ") as parsed;
```

This example is invalid because the string contains invalid characters:

```zetasql
SELECT PARSE_NUMERIC("$12.34") as parsed;
```

[half-from-zero-wikipedia]: https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero

[cast-numeric]: #cast_numeric

[numeric-type]: https://github.com/google/zetasql/blob/master/docs/data-types.md#decimal_types

### `SAFE_CAST` 
<a id="safe_casting"></a>

<pre class="lang-sql prettyprint">
<code>SAFE_CAST(expression AS typename [format_clause])</code>
</pre>

**Description**

When using `CAST`, a query can fail if ZetaSQL is unable to perform
the cast. For example, the following query generates an error:

```zetasql
SELECT CAST("apple" AS INT64) AS not_a_number;
```

If you want to protect your queries from these types of errors, you can use
`SAFE_CAST`. `SAFE_CAST` replaces runtime errors with `NULL`s. However, during
static analysis, impossible casts between two non-castable types still produce
an error because the query is invalid.

```zetasql
SELECT SAFE_CAST("apple" AS INT64) AS not_a_number;

/*--------------*
 | not_a_number |
 +--------------+
 | NULL         |
 *--------------*/
```

Some casts can include a [format clause][formatting-syntax], which provides
instructions for how to conduct the
cast. For example, you could
instruct a cast to convert a sequence of bytes to a BASE64-encoded string
instead of a UTF-8-encoded string.

The structure of the format clause is unique to each type of cast and more
information is available in the section for that cast.

If you are casting from bytes to strings, you can also use the
function, [`SAFE_CONVERT_BYTES_TO_STRING`][SC_BTS]. Any invalid UTF-8 characters
are replaced with the unicode replacement character, `U+FFFD`.

[SC_BTS]: #safe_convert_bytes_to_string

[formatting-syntax]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#formatting_syntax

[conversion-rules]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md

## Date functions

ZetaSQL supports the following date functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#current_date"><code>CURRENT_DATE</code></a>
</td>
  <td>
    Returns the current date as a <code>DATE</code> value.
  </td>
</tr>

<tr>
  <td><a href="#date"><code>DATE</code></a>
</td>
  <td>
    Constructs a <code>DATE</code> value.
  </td>
</tr>

<tr>
  <td><a href="#date_add"><code>DATE_ADD</code></a>
</td>
  <td>
    Adds a specified time interval to a <code>DATE</code> value.
  </td>
</tr>

<tr>
  <td><a href="#date_diff"><code>DATE_DIFF</code></a>
</td>
  <td>
    Gets the number of unit boundaries between two <code>DATE</code> values
    at a particular time granularity.
  </td>
</tr>

<tr>
  <td><a href="#date_from_unix_date"><code>DATE_FROM_UNIX_DATE</code></a>
</td>
  <td>
    Interprets an <code>INT64</code> expression as the number of days
    since 1970-01-01.
    
  </td>
</tr>

<tr>
  <td><a href="#date_sub"><code>DATE_SUB</code></a>
</td>
  <td>
    Subtracts a specified time interval from a <code>DATE</code> value.
  </td>
</tr>

<tr>
  <td><a href="#date_trunc"><code>DATE_TRUNC</code></a>
</td>
  <td>
    
    Truncates a <code>DATE</code>, <code>DATETIME</code>, or
    <code>TIMESTAMP</code> value at a particular
    granularity.
    
  </td>
</tr>

<tr>
  <td><a href="#extract"><code>EXTRACT</code></a>
</td>
  <td>
    Extracts part of a date from a <code>DATE</code> value.
  </td>
</tr>

<tr>
  <td><a href="#format_date"><code>FORMAT_DATE</code></a>
</td>
  <td>
    Formats a <code>DATE</code> value according to a specified format string.
  </td>
</tr>

<tr>
  <td><a href="#generate_date_array"><code>GENERATE_DATE_ARRAY</code></a>
</td>
  <td>
    Generates an array of dates in a range.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/array_functions.md">Array functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#last_day"><code>LAST_DAY</code></a>
</td>
  <td>
    Gets the last day in a specified time period that contains a
    <code>DATE</code> value.
  </td>
</tr>

<tr>
  <td><a href="#parse_date"><code>PARSE_DATE</code></a>
</td>
  <td>
    Converts a <code>STRING</code> value to a <code>DATE</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#unix_date"><code>UNIX_DATE</code></a>
</td>
  <td>
    Converts a <code>DATE</code> value to the number of days since 1970-01-01.
    
  </td>
</tr>

  </tbody>
</table>

### `CURRENT_DATE`

```zetasql
CURRENT_DATE()
```

```zetasql
CURRENT_DATE(time_zone_expression)
```

```zetasql
CURRENT_DATE
```

**Description**

Returns the current date as a `DATE` object. Parentheses are optional when
called with no arguments.

This function supports the following arguments:

+ `time_zone_expression`: A `STRING` expression that represents a
  [time zone][date-timezone-definitions]. If no time zone is specified, the
  default time zone, which is implementation defined, is used. If this expression is
  used and it evaluates to `NULL`, this function returns `NULL`.

The current date value is set at the start of the query statement that contains
this function. All invocations of `CURRENT_DATE()` within a query statement
yield the same value.

**Return Data Type**

`DATE`

**Examples**

The following query produces the current date in the default time zone:

```zetasql
SELECT CURRENT_DATE() AS the_date;

/*--------------*
 | the_date     |
 +--------------+
 | 2016-12-25   |
 *--------------*/
```

The following queries produce the current date in a specified time zone:

```zetasql
SELECT CURRENT_DATE('America/Los_Angeles') AS the_date;

/*--------------*
 | the_date     |
 +--------------+
 | 2016-12-25   |
 *--------------*/
```

```zetasql
SELECT CURRENT_DATE('-08') AS the_date;

/*--------------*
 | the_date     |
 +--------------+
 | 2016-12-25   |
 *--------------*/
```

The following query produces the current date in the default time zone.
Parentheses aren't needed if the function has no arguments.

```zetasql
SELECT CURRENT_DATE AS the_date;

/*--------------*
 | the_date     |
 +--------------+
 | 2016-12-25   |
 *--------------*/
```

[date-timezone-definitions]: https://github.com/google/zetasql/blob/master/docs/data-types.md#time_zones

### `DATE`

```zetasql
DATE(year, month, day)
```

```zetasql
DATE(timestamp_expression)
```

```zetasql
DATE(timestamp_expression, time_zone_expression)
```

```
DATE(datetime_expression)
```

**Description**

Constructs or extracts a date.

This function supports the following arguments:

+ `year`: The `INT64` value for year.
+ `month`: The `INT64` value for month.
+ `day`: The `INT64` value for day.
+ `timestamp_expression`: A `TIMESTAMP` expression that contains the date.
+ `time_zone_expression`: A `STRING` expression that represents a
  [time zone][date-timezone-definitions]. If no time zone is specified with
  `timestamp_expression`, the default time zone, which is implementation defined, is
  used.
+ `datetime_expression`: A `DATETIME` expression that contains the date.

**Return Data Type**

`DATE`

**Example**

```zetasql
SELECT
  DATE(2016, 12, 25) AS date_ymd,
  DATE(DATETIME '2016-12-25 23:59:59') AS date_dt,
  DATE(TIMESTAMP '2016-12-25 05:30:00+07', 'America/Los_Angeles') AS date_tstz;

/*------------+------------+------------*
 | date_ymd   | date_dt    | date_tstz  |
 +------------+------------+------------+
 | 2016-12-25 | 2016-12-25 | 2016-12-24 |
 *------------+------------+------------*/
```

[date-timezone-definitions]: #timezone_definitions

### `DATE_ADD`

```zetasql
DATE_ADD(date_expression, INTERVAL int64_expression date_part)
```

**Description**

Adds a specified time interval to a DATE.

`DATE_ADD` supports the following `date_part` values:

+  `DAY`
+  `WEEK`. Equivalent to 7 `DAY`s.
+  `MONTH`
+  `QUARTER`
+  `YEAR`

Special handling is required for MONTH, QUARTER, and YEAR parts when
the date is at (or near) the last day of the month. If the resulting
month has fewer days than the original date's day, then the resulting
date is the last date of that month.

**Return Data Type**

DATE

**Example**

```zetasql
SELECT DATE_ADD(DATE '2008-12-25', INTERVAL 5 DAY) AS five_days_later;

/*--------------------*
 | five_days_later    |
 +--------------------+
 | 2008-12-30         |
 *--------------------*/
```

### `DATE_DIFF`

```zetasql
DATE_DIFF(end_date, start_date, granularity)
```

**Description**

Gets the number of unit boundaries between two `DATE` values (`end_date` -
`start_date`) at a particular time granularity.

**Definitions**

+   `start_date`: The starting `DATE` value.
+   `end_date`: The ending `DATE` value.
+   `granularity`: The date part that represents the granularity. If
    you have passed in `DATE` values for the first arguments, `granularity` can
    be:

    +  `DAY`
    +  `WEEK` This date part begins on Sunday.
    +  `WEEK(<WEEKDAY>)`: This date part begins on `WEEKDAY`. Valid values for
       `WEEKDAY` are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`,
       `FRIDAY`, and `SATURDAY`.
    +  `ISOWEEK`: Uses [ISO 8601 week][ISO-8601-week] boundaries. ISO weeks
       begin on Monday.
    +  `MONTH`
    +  `QUARTER`
    +  `YEAR`
    +  `ISOYEAR`: Uses the [ISO 8601][ISO-8601] week-numbering year boundary.
       The ISO year boundary is the Monday of the first week whose Thursday
       belongs to the corresponding Gregorian calendar year.

**Details**

If `end_date` is earlier than `start_date`, the output is negative.

Note: The behavior of the this function follows the type of arguments passed in.
For example, `DATE_DIFF(TIMESTAMP, TIMESTAMP, PART)`
behaves like `TIMESTAMP_DIFF(TIMESTAMP, TIMESTAMP, PART)`.

**Return Data Type**

`INT64`

**Example**

```zetasql
SELECT DATE_DIFF(DATE '2010-07-07', DATE '2008-12-25', DAY) AS days_diff;

/*-----------*
 | days_diff |
 +-----------+
 | 559       |
 *-----------*/
```

```zetasql
SELECT
  DATE_DIFF(DATE '2017-10-15', DATE '2017-10-14', DAY) AS days_diff,
  DATE_DIFF(DATE '2017-10-15', DATE '2017-10-14', WEEK) AS weeks_diff;

/*-----------+------------*
 | days_diff | weeks_diff |
 +-----------+------------+
 | 1         | 1          |
 *-----------+------------*/
```

The example above shows the result of `DATE_DIFF` for two days in succession.
`DATE_DIFF` with the date part `WEEK` returns 1 because `DATE_DIFF` counts the
number of date part boundaries in this range of dates. Each `WEEK` begins on
Sunday, so there is one date part boundary between Saturday, 2017-10-14
and Sunday, 2017-10-15.

The following example shows the result of `DATE_DIFF` for two dates in different
years. `DATE_DIFF` with the date part `YEAR` returns 3 because it counts the
number of Gregorian calendar year boundaries between the two dates. `DATE_DIFF`
with the date part `ISOYEAR` returns 2 because the second date belongs to the
ISO year 2015. The first Thursday of the 2015 calendar year was 2015-01-01, so
the ISO year 2015 begins on the preceding Monday, 2014-12-29.

```zetasql
SELECT
  DATE_DIFF('2017-12-30', '2014-12-30', YEAR) AS year_diff,
  DATE_DIFF('2017-12-30', '2014-12-30', ISOYEAR) AS isoyear_diff;

/*-----------+--------------*
 | year_diff | isoyear_diff |
 +-----------+--------------+
 | 3         | 2            |
 *-----------+--------------*/
```

The following example shows the result of `DATE_DIFF` for two days in
succession. The first date falls on a Monday and the second date falls on a
Sunday. `DATE_DIFF` with the date part `WEEK` returns 0 because this date part
uses weeks that begin on Sunday. `DATE_DIFF` with the date part `WEEK(MONDAY)`
returns 1. `DATE_DIFF` with the date part `ISOWEEK` also returns 1 because
ISO weeks begin on Monday.

```zetasql
SELECT
  DATE_DIFF('2017-12-18', '2017-12-17', WEEK) AS week_diff,
  DATE_DIFF('2017-12-18', '2017-12-17', WEEK(MONDAY)) AS week_weekday_diff,
  DATE_DIFF('2017-12-18', '2017-12-17', ISOWEEK) AS isoweek_diff;

/*-----------+-------------------+--------------*
 | week_diff | week_weekday_diff | isoweek_diff |
 +-----------+-------------------+--------------+
 | 0         | 1                 | 1            |
 *-----------+-------------------+--------------*/
```

[ISO-8601]: https://en.wikipedia.org/wiki/ISO_8601

[ISO-8601-week]: https://en.wikipedia.org/wiki/ISO_week_date

### `DATE_FROM_UNIX_DATE`

```zetasql
DATE_FROM_UNIX_DATE(int64_expression)
```

**Description**

Interprets `int64_expression` as the number of days since 1970-01-01.

**Return Data Type**

DATE

**Example**

```zetasql
SELECT DATE_FROM_UNIX_DATE(14238) AS date_from_epoch;

/*-----------------*
 | date_from_epoch |
 +-----------------+
 | 2008-12-25      |
 *-----------------+*/
```

### `DATE_SUB`

```zetasql
DATE_SUB(date_expression, INTERVAL int64_expression date_part)
```

**Description**

Subtracts a specified time interval from a DATE.

`DATE_SUB` supports the following `date_part` values:

+  `DAY`
+  `WEEK`. Equivalent to 7 `DAY`s.
+  `MONTH`
+  `QUARTER`
+  `YEAR`

Special handling is required for MONTH, QUARTER, and YEAR parts when
the date is at (or near) the last day of the month. If the resulting
month has fewer days than the original date's day, then the resulting
date is the last date of that month.

**Return Data Type**

DATE

**Example**

```zetasql
SELECT DATE_SUB(DATE '2008-12-25', INTERVAL 5 DAY) AS five_days_ago;

/*---------------*
 | five_days_ago |
 +---------------+
 | 2008-12-20    |
 *---------------*/
```

### `DATE_TRUNC`

```zetasql
DATE_TRUNC(date_value, date_granularity)
```

```zetasql
DATE_TRUNC(datetime_value, datetime_granularity)
```

```zetasql
DATE_TRUNC(timestamp_value, timestamp_granularity[, time_zone])
```

**Description**

Truncates a `DATE`, `DATETIME`, or `TIMESTAMP` value at a particular
granularity.

**Definitions**

+ `date_value`: A `DATE` value to truncate.
+ `date_granularity`: The truncation granularity for a `DATE` value.
  [Date granularities][date-trunc-granularity-date] can be used.
+ `datetime_value`: A `DATETIME` value to truncate.
+ `datetime_granularity`: The truncation granularity for a `DATETIME` value.
  [Date granularities][date-trunc-granularity-date] and
  [time granularities][date-trunc-granularity-time] can be used.
+ `timestamp_value`: A `TIMESTAMP` value to truncate.
+ `timestamp_granularity`: The truncation granularity for a `TIMESTAMP` value.
  [Date granularities][date-trunc-granularity-date] and
  [time granularities][date-trunc-granularity-time] can be used.
+ `time_zone`: A time zone to use with the `TIMESTAMP` value.
  [Time zone parts][date-time-zone-parts] can be used.
  Use this argument if you want to use a time zone other than
  the default time zone, which is implementation defined, as part of the
  truncate operation.

      Note: When truncating a timestamp to `MINUTE`
    or `HOUR` parts, this function determines the civil time of the
    timestamp in the specified (or default) time zone
    and subtracts the minutes and seconds (when truncating to `HOUR`) or the
    seconds (when truncating to `MINUTE`) from that timestamp.
    While this provides intuitive results in most cases, the result is
    non-intuitive near daylight savings transitions that aren't hour-aligned.

<a id="date_trunc_granularity_date"></a>

**Date granularity definitions**

  + `DAY`: The day in the Gregorian calendar year that contains the
    value to truncate.

  + `WEEK`: The first day in the week that contains the
    value to truncate. Weeks begin on Sundays. `WEEK` is equivalent to
    `WEEK(SUNDAY)`.

  + `WEEK(WEEKDAY)`: The first day in the week that contains the
    value to truncate. Weeks begin on `WEEKDAY`. `WEEKDAY` must be one of the
     following: `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`,
     or `SATURDAY`.

  + `ISOWEEK`: The first day in the [ISO 8601 week][ISO-8601-week] that contains
    the value to truncate. The ISO week begins on
    Monday. The first ISO week of each ISO year contains the first Thursday of the
    corresponding Gregorian calendar year.

  + `MONTH`: The first day in the month that contains the
    value to truncate.

  + `QUARTER`: The first day in the quarter that contains the
    value to truncate.

  + `YEAR`: The first day in the year that contains the
    value to truncate.

  + `ISOYEAR`: The first day in the [ISO 8601][ISO-8601] week-numbering year
    that contains the value to truncate. The ISO year is the
    Monday of the first week where Thursday belongs to the corresponding
    Gregorian calendar year.

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[ISO-8601]: https://en.wikipedia.org/wiki/ISO_8601

[ISO-8601-week]: https://en.wikipedia.org/wiki/ISO_week_date

<!-- mdlint on -->

<a id="date_trunc_granularity_time"></a>

**Time granularity definitions**

  + `NANOSECOND`: If used, nothing is truncated from the value.

  + `MICROSECOND`: The nearest lesser than or equal microsecond.

  + `MILLISECOND`: The nearest lesser than or equal millisecond.

  + `SECOND`: The nearest lesser than or equal second.

  + `MINUTE`: The nearest lesser than or equal minute.

  + `HOUR`: The nearest lesser than or equal hour.

<a id="date_time_zone_parts"></a>

**Time zone part definitions**

+ `MINUTE`
+ `HOUR`
+ `DAY`
+ `WEEK`
+ `WEEK(<WEEKDAY>)`
+ `ISOWEEK`
+ `MONTH`
+ `QUARTER`
+ `YEAR`
+ `ISOYEAR`

**Details**

The resulting value is always rounded to the beginning of `granularity`.

**Return Data Type**

The same data type as the first argument passed into this function.

**Examples**

```zetasql
SELECT DATE_TRUNC(DATE '2008-12-25', MONTH) AS month;

/*------------*
 | month      |
 +------------+
 | 2008-12-01 |
 *------------*/
```

In the following example, the original date falls on a Sunday. Because
the `date_part` is `WEEK(MONDAY)`, `DATE_TRUNC` returns the `DATE` for the
preceding Monday.

```zetasql
SELECT date AS original, DATE_TRUNC(date, WEEK(MONDAY)) AS truncated
FROM (SELECT DATE('2017-11-05') AS date);

/*------------+------------*
 | original   | truncated  |
 +------------+------------+
 | 2017-11-05 | 2017-10-30 |
 *------------+------------*/
```

In the following example, the original `date_expression` is in the Gregorian
calendar year 2015. However, `DATE_TRUNC` with the `ISOYEAR` date part
truncates the `date_expression` to the beginning of the ISO year, not the
Gregorian calendar year. The first Thursday of the 2015 calendar year was
2015-01-01, so the ISO year 2015 begins on the preceding Monday, 2014-12-29.
Therefore the ISO year boundary preceding the `date_expression` 2015-06-15 is
2014-12-29.

```zetasql
SELECT
  DATE_TRUNC('2015-06-15', ISOYEAR) AS isoyear_boundary,
  EXTRACT(ISOYEAR FROM DATE '2015-06-15') AS isoyear_number;

/*------------------+----------------*
 | isoyear_boundary | isoyear_number |
 +------------------+----------------+
 | 2014-12-29       | 2015           |
 *------------------+----------------*/
```

[date-trunc-granularity-date]: #date_trunc_granularity_date

[date-trunc-granularity-time]: #date_trunc_granularity_time

[date-time-zone-parts]: #date_time_zone_parts

### `EXTRACT`

```zetasql
EXTRACT(part FROM date_expression)
```

**Description**

Returns the value corresponding to the specified date part. The `part` must
be one of:

+   `DAYOFWEEK`: Returns values in the range [1,7] with Sunday as the first day
    of the week.
+   `DAY`
+   `DAYOFYEAR`
+ `WEEK`: Returns the week number of the date in the range [0, 53]. Weeks begin
  with Sunday, and dates prior to the first Sunday of the year are in week
  0.
+ `WEEK(<WEEKDAY>)`: Returns the week number of the date in the range [0, 53].
  Weeks begin on `WEEKDAY`. Dates prior to
  the first `WEEKDAY` of the year are in week 0. Valid values for `WEEKDAY` are
  `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, and
  `SATURDAY`.
+ `ISOWEEK`: Returns the [ISO 8601 week][ISO-8601-week]
  number of the `date_expression`. `ISOWEEK`s begin on Monday. Return values
  are in the range [1, 53]. The first `ISOWEEK` of each ISO year begins on the
  Monday before the first Thursday of the Gregorian calendar year.
+   `MONTH`
+   `QUARTER`: Returns values in the range [1,4].
+   `YEAR`
+   `ISOYEAR`: Returns the [ISO 8601][ISO-8601]
    week-numbering year, which is the Gregorian calendar year containing the
    Thursday of the week to which `date_expression` belongs.

**Return Data Type**

INT64

**Examples**

In the following example, `EXTRACT` returns a value corresponding to the `DAY`
date part.

```zetasql
SELECT EXTRACT(DAY FROM DATE '2013-12-25') AS the_day;

/*---------*
 | the_day |
 +---------+
 | 25      |
 *---------*/
```

In the following example, `EXTRACT` returns values corresponding to different
date parts from a column of dates near the end of the year.

```zetasql
SELECT
  date,
  EXTRACT(ISOYEAR FROM date) AS isoyear,
  EXTRACT(ISOWEEK FROM date) AS isoweek,
  EXTRACT(YEAR FROM date) AS year,
  EXTRACT(WEEK FROM date) AS week
FROM UNNEST(GENERATE_DATE_ARRAY('2015-12-23', '2016-01-09')) AS date
ORDER BY date;

/*------------+---------+---------+------+------*
 | date       | isoyear | isoweek | year | week |
 +------------+---------+---------+------+------+
 | 2015-12-23 | 2015    | 52      | 2015 | 51   |
 | 2015-12-24 | 2015    | 52      | 2015 | 51   |
 | 2015-12-25 | 2015    | 52      | 2015 | 51   |
 | 2015-12-26 | 2015    | 52      | 2015 | 51   |
 | 2015-12-27 | 2015    | 52      | 2015 | 52   |
 | 2015-12-28 | 2015    | 53      | 2015 | 52   |
 | 2015-12-29 | 2015    | 53      | 2015 | 52   |
 | 2015-12-30 | 2015    | 53      | 2015 | 52   |
 | 2015-12-31 | 2015    | 53      | 2015 | 52   |
 | 2016-01-01 | 2015    | 53      | 2016 | 0    |
 | 2016-01-02 | 2015    | 53      | 2016 | 0    |
 | 2016-01-03 | 2015    | 53      | 2016 | 1    |
 | 2016-01-04 | 2016    | 1       | 2016 | 1    |
 | 2016-01-05 | 2016    | 1       | 2016 | 1    |
 | 2016-01-06 | 2016    | 1       | 2016 | 1    |
 | 2016-01-07 | 2016    | 1       | 2016 | 1    |
 | 2016-01-08 | 2016    | 1       | 2016 | 1    |
 | 2016-01-09 | 2016    | 1       | 2016 | 1    |
 *------------+---------+---------+------+------*/
```

In the following example, `date_expression` falls on a Sunday. `EXTRACT`
calculates the first column using weeks that begin on Sunday, and it calculates
the second column using weeks that begin on Monday.

```zetasql
WITH table AS (SELECT DATE('2017-11-05') AS date)
SELECT
  date,
  EXTRACT(WEEK(SUNDAY) FROM date) AS week_sunday,
  EXTRACT(WEEK(MONDAY) FROM date) AS week_monday FROM table;

/*------------+-------------+-------------*
 | date       | week_sunday | week_monday |
 +------------+-------------+-------------+
 | 2017-11-05 | 45          | 44          |
 *------------+-------------+-------------*/
```

[ISO-8601]: https://en.wikipedia.org/wiki/ISO_8601

[ISO-8601-week]: https://en.wikipedia.org/wiki/ISO_week_date

### `FORMAT_DATE`

```zetasql
FORMAT_DATE(format_string, date_expr)
```

**Description**

Formats a `DATE` value according to a specified format string.

**Definitions**

+   `format_string`: A `STRING` value that contains the
    [format elements][date-format-elements] to use with `date_expr`.
+   `date_expr`: A `DATE` value that represents the date to format.

**Return Data Type**

`STRING`

**Examples**

```zetasql
SELECT FORMAT_DATE('%x', DATE '2008-12-25') AS US_format;

/*------------*
 | US_format  |
 +------------+
 | 12/25/08   |
 *------------*/
```

```zetasql
SELECT FORMAT_DATE('%b-%d-%Y', DATE '2008-12-25') AS formatted;

/*-------------*
 | formatted   |
 +-------------+
 | Dec-25-2008 |
 *-------------*/
```

```zetasql
SELECT FORMAT_DATE('%b %Y', DATE '2008-12-25') AS formatted;

/*-------------*
 | formatted   |
 +-------------+
 | Dec 2008    |
 *-------------*/
```

[date-format-elements]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#format_elements_date_time

### `LAST_DAY`

```zetasql
LAST_DAY(date_expression[, date_part])
```

**Description**

Returns the last day from a date expression. This is commonly used to return
the last day of the month.

You can optionally specify the date part for which the last day is returned.
If this parameter isn't used, the default value is `MONTH`.
`LAST_DAY` supports the following values for `date_part`:

+  `YEAR`
+  `QUARTER`
+  `MONTH`
+  `WEEK`. Equivalent to 7 `DAY`s.
+  `WEEK(<WEEKDAY>)`. `<WEEKDAY>` represents the starting day of the week.
   Valid values are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`,
   `FRIDAY`, and `SATURDAY`.
+  `ISOWEEK`. Uses [ISO 8601][ISO-8601-week] week boundaries. ISO weeks begin
   on Monday.
+  `ISOYEAR`. Uses the [ISO 8601][ISO-8601] week-numbering year boundary.
   The ISO year boundary is the Monday of the first week whose Thursday belongs
   to the corresponding Gregorian calendar year.

**Return Data Type**

`DATE`

**Example**

These both return the last day of the month:

```zetasql
SELECT LAST_DAY(DATE '2008-11-25', MONTH) AS last_day

/*------------*
 | last_day   |
 +------------+
 | 2008-11-30 |
 *------------*/
```

```zetasql
SELECT LAST_DAY(DATE '2008-11-25') AS last_day

/*------------*
 | last_day   |
 +------------+
 | 2008-11-30 |
 *------------*/
```

This returns the last day of the year:

```zetasql
SELECT LAST_DAY(DATE '2008-11-25', YEAR) AS last_day

/*------------*
 | last_day   |
 +------------+
 | 2008-12-31 |
 *------------*/
```

This returns the last day of the week for a week that starts on a Sunday:

```zetasql
SELECT LAST_DAY(DATE '2008-11-10', WEEK(SUNDAY)) AS last_day

/*------------*
 | last_day   |
 +------------+
 | 2008-11-15 |
 *------------*/
```

This returns the last day of the week for a week that starts on a Monday:

```zetasql
SELECT LAST_DAY(DATE '2008-11-10', WEEK(MONDAY)) AS last_day

/*------------*
 | last_day   |
 +------------+
 | 2008-11-16 |
 *------------*/
```

[ISO-8601]: https://en.wikipedia.org/wiki/ISO_8601

[ISO-8601-week]: https://en.wikipedia.org/wiki/ISO_week_date

### `PARSE_DATE`

```zetasql
PARSE_DATE(format_string, date_string)
```

**Description**

Converts a `STRING` value to a `DATE` value.

**Definitions**

+   `format_string`: A `STRING` value that contains the
    [format elements][date-format-elements] to use with `date_string`.
+   `date_string`: A `STRING` value that represents the date to parse.

**Details**

Each element in `date_string` must have a corresponding element in
`format_string`. The location of each element in `format_string` must match the
location of each element in `date_string`.

```zetasql
-- This works because elements on both sides match.
SELECT PARSE_DATE('%A %b %e %Y', 'Thursday Dec 25 2008');

-- This produces an error because the year element is in different locations.
SELECT PARSE_DATE('%Y %A %b %e', 'Thursday Dec 25 2008');

-- This produces an error because one of the year elements is missing.
SELECT PARSE_DATE('%A %b %e', 'Thursday Dec 25 2008');

-- This works because %F can find all matching elements in date_string.
SELECT PARSE_DATE('%F', '2000-12-30');
```

The following additional considerations apply when using the `PARSE_DATE`
function:

+ Unspecified fields. Any unspecified field is initialized from `1970-01-01`.
+ Case insensitivity. Names, such as `Monday`, `February`, and so on, are
  case insensitive.
+ Whitespace. One or more consecutive white spaces in the format string
  matches zero or more consecutive white spaces in the date string. In
  addition, leading and trailing white spaces in the date string are always
  allowed, even if they aren't in the format string.
+ Format precedence. When two (or more) format elements have overlapping
  information (for example both `%F` and `%Y` affect the year), the last one
  generally overrides any earlier ones.
+   Mixed ISO and non-ISO elements. The ISO format elements are `%G`, `%g`,
    `%J`, and `%V`. When these ISO elements are used together with other non-ISO
    elements, the ISO elements are ignored, resulting in different values. For
    example, the function arguments `('%g %J', '8405')` return a value with the
    year `1984`, whereas the arguments `('%g %j', '8405')` return a value with
    the year `1970` because the ISO element `%g` is ignored.
+   Numeric values after `%G` input values. Any input string value that
    corresponds to the `%G` format element requires a whitespace or non-digit
    character as a separator from numeric values that follow. This is a known
    issue in ZetaSQL. For example, the function arguments `('%G
    %V','2020 50')` or `('%G-%V','2020-50')` work, but not `('%G%V','202050')`.
    For input values before the corresponding `%G` value, no separator is
    needed. For example, the arguments `('%V%G','502020')` work. The separator
    after the `%G` values identifies the end of the specified ISO year value so
    that the function can parse properly.

**Return Data Type**

`DATE`

**Examples**

This example converts a `MM/DD/YY` formatted string to a `DATE` object:

```zetasql
SELECT PARSE_DATE('%x', '12/25/08') AS parsed;

/*------------*
 | parsed     |
 +------------+
 | 2008-12-25 |
 *------------*/
```

This example converts a `YYYYMMDD` formatted string to a `DATE` object:

```zetasql
SELECT PARSE_DATE('%Y%m%d', '20081225') AS parsed;

/*------------*
 | parsed     |
 +------------+
 | 2008-12-25 |
 *------------*/
```

[date-format-elements]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#format_elements_date_time

### `UNIX_DATE`

```zetasql
UNIX_DATE(date_expression)
```

**Description**

Returns the number of days since `1970-01-01`.

**Return Data Type**

INT64

**Example**

```zetasql
SELECT UNIX_DATE(DATE '2008-12-25') AS days_from_epoch;

/*-----------------*
 | days_from_epoch |
 +-----------------+
 | 14238           |
 *-----------------*/
```

## Datetime functions

ZetaSQL supports the following datetime functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#current_datetime"><code>CURRENT_DATETIME</code></a>
</td>
  <td>
    Returns the current date and time as a <code>DATETIME</code> value.
  </td>
</tr>

<tr>
  <td><a href="#datetime"><code>DATETIME</code></a>
</td>
  <td>
    Constructs a <code>DATETIME</code> value.
  </td>
</tr>

<tr>
  <td><a href="#datetime_add"><code>DATETIME_ADD</code></a>
</td>
  <td>
    Adds a specified time interval to a <code>DATETIME</code> value.
  </td>
</tr>

<tr>
  <td><a href="#datetime_diff"><code>DATETIME_DIFF</code></a>
</td>
  <td>
    Gets the number of unit boundaries between two <code>DATETIME</code> values
    at a particular time granularity.
  </td>
</tr>

<tr>
  <td><a href="#datetime_sub"><code>DATETIME_SUB</code></a>
</td>
  <td>
    Subtracts a specified time interval from a <code>DATETIME</code> value.
  </td>
</tr>

<tr>
  <td><a href="#datetime_trunc"><code>DATETIME_TRUNC</code></a>
</td>
  <td>
    
    Truncates a <code>DATETIME</code> or
    <code>TIMESTAMP</code> value at a particular
    granularity.
    
  </td>
</tr>

<tr>
  <td><a href="#extract"><code>EXTRACT</code></a>
</td>
  <td>
    Extracts part of a date and time from a <code>DATETIME</code> value.
  </td>
</tr>

<tr>
  <td><a href="#format_datetime"><code>FORMAT_DATETIME</code></a>
</td>
  <td>
    Formats a <code>DATETIME</code> value according to a specified
    format string.
  </td>
</tr>

<tr>
  <td><a href="#last_day"><code>LAST_DAY</code></a>
</td>
  <td>
    Gets the last day in a specified time period that contains a
    <code>DATETIME</code> value.
  </td>
</tr>

<tr>
  <td><a href="#parse_datetime"><code>PARSE_DATETIME</code></a>
</td>
  <td>
    Converts a <code>STRING</code> value to a <code>DATETIME</code> value.
    
  </td>
</tr>

  </tbody>
</table>

### `CURRENT_DATETIME`

```zetasql
CURRENT_DATETIME([time_zone])
```

```zetasql
CURRENT_DATETIME
```

**Description**

Returns the current time as a `DATETIME` object. Parentheses are optional when
called with no arguments.

This function supports an optional `time_zone` parameter.
See [Time zone definitions][datetime-timezone-definitions] for
information on how to specify a time zone.

The current date and time value is set at the start of the query statement that
contains this function. All invocations of `CURRENT_DATETIME()` within a query
statement yield the same value.

**Return Data Type**

`DATETIME`

**Example**

```zetasql
SELECT CURRENT_DATETIME() as now;

/*----------------------------*
 | now                        |
 +----------------------------+
 | 2016-05-19 10:38:47.046465 |
 *----------------------------*/
```

[datetime-timezone-definitions]: #timezone_definitions

### `DATETIME`

```zetasql
1. DATETIME(year, month, day, hour, minute, second)
2. DATETIME(date_expression[, time_expression])
3. DATETIME(timestamp_expression [, time_zone])
```

**Description**

1. Constructs a `DATETIME` object using `INT64` values
   representing the year, month, day, hour, minute, and second.
2. Constructs a `DATETIME` object using a DATE object and an optional `TIME`
   object.
3. Constructs a `DATETIME` object using a `TIMESTAMP` object. It supports an
   optional parameter to
   [specify a time zone][datetime-timezone-definitions].
   If no time zone is specified, the default time zone, which is implementation defined,
   is used.

**Return Data Type**

`DATETIME`

**Example**

```zetasql
SELECT
  DATETIME(2008, 12, 25, 05, 30, 00) as datetime_ymdhms,
  DATETIME(TIMESTAMP "2008-12-25 05:30:00+00", "America/Los_Angeles") as datetime_tstz;

/*---------------------+---------------------*
 | datetime_ymdhms     | datetime_tstz       |
 +---------------------+---------------------+
 | 2008-12-25 05:30:00 | 2008-12-24 21:30:00 |
 *---------------------+---------------------*/
```

[datetime-timezone-definitions]: #timezone_definitions

### `DATETIME_ADD`

```zetasql
DATETIME_ADD(datetime_expression, INTERVAL int64_expression part)
```

**Description**

Adds `int64_expression` units of `part` to the `DATETIME` object.

`DATETIME_ADD` supports the following values for `part`:

+ `NANOSECOND`
  (if the SQL engine supports it)
+ `MICROSECOND`
+ `MILLISECOND`
+ `SECOND`
+ `MINUTE`
+ `HOUR`
+ `DAY`
+ `WEEK`. Equivalent to 7 `DAY`s.
+ `MONTH`
+ `QUARTER`
+ `YEAR`

Special handling is required for MONTH, QUARTER, and YEAR parts when the
date is at (or near) the last day of the month. If the resulting month has fewer
days than the original DATETIME's day, then the result day is the last day of
the new month.

**Return Data Type**

`DATETIME`

**Example**

```zetasql
SELECT
  DATETIME "2008-12-25 15:30:00" as original_date,
  DATETIME_ADD(DATETIME "2008-12-25 15:30:00", INTERVAL 10 MINUTE) as later;

/*-----------------------------+------------------------*
 | original_date               | later                  |
 +-----------------------------+------------------------+
 | 2008-12-25 15:30:00         | 2008-12-25 15:40:00    |
 *-----------------------------+------------------------*/
```

### `DATETIME_DIFF`

```zetasql
DATETIME_DIFF(end_datetime, start_datetime, granularity)
```

**Description**

Gets the number of unit boundaries between two `DATETIME` values
(`end_datetime` - `start_datetime`) at a particular time granularity.

**Definitions**

+   `start_datetime`: The starting `DATETIME` value.
+   `end_datetime`: The ending `DATETIME` value.
+   `granularity`: The datetime part that represents the granularity. If
    you have passed in `DATETIME` values for the first arguments, `granularity`
    can be:

      
      + `NANOSECOND`
        (if the SQL engine supports it)
      + `MICROSECOND`
      + `MILLISECOND`
      + `SECOND`
      + `MINUTE`
      + `HOUR`
      + `DAY`
      + `WEEK`: This date part begins on Sunday.
      + `WEEK(<WEEKDAY>)`: This date part begins on `WEEKDAY`. Valid values for
        `WEEKDAY` are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`,
        `FRIDAY`, and `SATURDAY`.
      + `ISOWEEK`: Uses [ISO 8601 week][ISO-8601-week]
        boundaries. ISO weeks begin on Monday.
      + `MONTH`
      + `QUARTER`
      + `YEAR`
      + `ISOYEAR`: Uses the [ISO 8601][ISO-8601]
        week-numbering year boundary. The ISO year boundary is the Monday of the
        first week whose Thursday belongs to the corresponding Gregorian calendar
        year.

**Details**

If `end_datetime` is earlier than `start_datetime`, the output is negative.
Produces an error if the computation overflows, such as if the difference
in nanoseconds
between the two `DATETIME` values overflows.

Note: The behavior of the this function follows the type of arguments passed in.
For example, `DATETIME_DIFF(TIMESTAMP, TIMESTAMP, PART)`
behaves like `TIMESTAMP_DIFF(TIMESTAMP, TIMESTAMP, PART)`.

**Return Data Type**

`INT64`

**Example**

```zetasql
SELECT
  DATETIME "2010-07-07 10:20:00" as first_datetime,
  DATETIME "2008-12-25 15:30:00" as second_datetime,
  DATETIME_DIFF(DATETIME "2010-07-07 10:20:00",
    DATETIME "2008-12-25 15:30:00", DAY) as difference;

/*----------------------------+------------------------+------------------------*
 | first_datetime             | second_datetime        | difference             |
 +----------------------------+------------------------+------------------------+
 | 2010-07-07 10:20:00        | 2008-12-25 15:30:00    | 559                    |
 *----------------------------+------------------------+------------------------*/
```

```zetasql
SELECT
  DATETIME_DIFF(DATETIME '2017-10-15 00:00:00',
    DATETIME '2017-10-14 00:00:00', DAY) as days_diff,
  DATETIME_DIFF(DATETIME '2017-10-15 00:00:00',
    DATETIME '2017-10-14 00:00:00', WEEK) as weeks_diff;

/*-----------+------------*
 | days_diff | weeks_diff |
 +-----------+------------+
 | 1         | 1          |
 *-----------+------------*/
```

The example above shows the result of `DATETIME_DIFF` for two `DATETIME`s that
are 24 hours apart. `DATETIME_DIFF` with the part `WEEK` returns 1 because
`DATETIME_DIFF` counts the number of part boundaries in this range of
`DATETIME`s. Each `WEEK` begins on Sunday, so there is one part boundary between
Saturday, `2017-10-14 00:00:00` and Sunday, `2017-10-15 00:00:00`.

The following example shows the result of `DATETIME_DIFF` for two dates in
different years. `DATETIME_DIFF` with the date part `YEAR` returns 3 because it
counts the number of Gregorian calendar year boundaries between the two
`DATETIME`s. `DATETIME_DIFF` with the date part `ISOYEAR` returns 2 because the
second `DATETIME` belongs to the ISO year 2015. The first Thursday of the 2015
calendar year was 2015-01-01, so the ISO year 2015 begins on the preceding
Monday, 2014-12-29.

```zetasql
SELECT
  DATETIME_DIFF('2017-12-30 00:00:00',
    '2014-12-30 00:00:00', YEAR) AS year_diff,
  DATETIME_DIFF('2017-12-30 00:00:00',
    '2014-12-30 00:00:00', ISOYEAR) AS isoyear_diff;

/*-----------+--------------*
 | year_diff | isoyear_diff |
 +-----------+--------------+
 | 3         | 2            |
 *-----------+--------------*/
```

The following example shows the result of `DATETIME_DIFF` for two days in
succession. The first date falls on a Monday and the second date falls on a
Sunday. `DATETIME_DIFF` with the date part `WEEK` returns 0 because this time
part uses weeks that begin on Sunday. `DATETIME_DIFF` with the date part
`WEEK(MONDAY)` returns 1. `DATETIME_DIFF` with the date part
`ISOWEEK` also returns 1 because ISO weeks begin on Monday.

```zetasql
SELECT
  DATETIME_DIFF('2017-12-18', '2017-12-17', WEEK) AS week_diff,
  DATETIME_DIFF('2017-12-18', '2017-12-17', WEEK(MONDAY)) AS week_weekday_diff,
  DATETIME_DIFF('2017-12-18', '2017-12-17', ISOWEEK) AS isoweek_diff;

/*-----------+-------------------+--------------*
 | week_diff | week_weekday_diff | isoweek_diff |
 +-----------+-------------------+--------------+
 | 0         | 1                 | 1            |
 *-----------+-------------------+--------------*/
```

[ISO-8601]: https://en.wikipedia.org/wiki/ISO_8601

[ISO-8601-week]: https://en.wikipedia.org/wiki/ISO_week_date

### `DATETIME_SUB`

```zetasql
DATETIME_SUB(datetime_expression, INTERVAL int64_expression part)
```

**Description**

Subtracts `int64_expression` units of `part` from the `DATETIME`.

`DATETIME_SUB` supports the following values for `part`:

+ `NANOSECOND`
  (if the SQL engine supports it)
+ `MICROSECOND`
+ `MILLISECOND`
+ `SECOND`
+ `MINUTE`
+ `HOUR`
+ `DAY`
+ `WEEK`. Equivalent to 7 `DAY`s.
+ `MONTH`
+ `QUARTER`
+ `YEAR`

Special handling is required for `MONTH`, `QUARTER`, and `YEAR` parts when the
date is at (or near) the last day of the month. If the resulting month has fewer
days than the original `DATETIME`'s day, then the result day is the last day of
the new month.

**Return Data Type**

`DATETIME`

**Example**

```zetasql
SELECT
  DATETIME "2008-12-25 15:30:00" as original_date,
  DATETIME_SUB(DATETIME "2008-12-25 15:30:00", INTERVAL 10 MINUTE) as earlier;

/*-----------------------------+------------------------*
 | original_date               | earlier                |
 +-----------------------------+------------------------+
 | 2008-12-25 15:30:00         | 2008-12-25 15:20:00    |
 *-----------------------------+------------------------*/
```

### `DATETIME_TRUNC`

```zetasql
DATETIME_TRUNC(datetime_value, datetime_granularity)
```

```zetasql
DATETIME_TRUNC(timestamp_value, timestamp_granularity[, time_zone])
```

**Description**

Truncates a `DATETIME` or `TIMESTAMP` value at a particular granularity.

**Definitions**

+ `datetime_value`: A `DATETIME` value to truncate.
+ `datetime_granularity`: The truncation granularity for a `DATETIME` value.
  [Date granularities][datetime-trunc-granularity-date] and
  [time granularities][datetime-trunc-granularity-time] can be used.
+ `timestamp_value`: A `TIMESTAMP` value to truncate.
+ `timestamp_granularity`: The truncation granularity for a `TIMESTAMP` value.
  [Date granularities][datetime-trunc-granularity-date] and
  [time granularities][datetime-trunc-granularity-time] can be used.
+ `time_zone`: A time zone to use with the `TIMESTAMP` value.
  [Time zone parts][datetime-time-zone-parts] can be used.
  Use this argument if you want to use a time zone other than
  the default time zone, which is implementation defined, as part of the
  truncate operation.

      Note: When truncating a timestamp to `MINUTE`
    or `HOUR` parts, this function determines the civil time of the
    timestamp in the specified (or default) time zone
    and subtracts the minutes and seconds (when truncating to `HOUR`) or the
    seconds (when truncating to `MINUTE`) from that timestamp.
    While this provides intuitive results in most cases, the result is
    non-intuitive near daylight savings transitions that aren't hour-aligned.

<a id="datetime_trunc_granularity_date"></a>

**Date granularity definitions**

  + `DAY`: The day in the Gregorian calendar year that contains the
    value to truncate.

  + `WEEK`: The first day in the week that contains the
    value to truncate. Weeks begin on Sundays. `WEEK` is equivalent to
    `WEEK(SUNDAY)`.

  + `WEEK(WEEKDAY)`: The first day in the week that contains the
    value to truncate. Weeks begin on `WEEKDAY`. `WEEKDAY` must be one of the
     following: `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`,
     or `SATURDAY`.

  + `ISOWEEK`: The first day in the [ISO 8601 week][ISO-8601-week] that contains
    the value to truncate. The ISO week begins on
    Monday. The first ISO week of each ISO year contains the first Thursday of the
    corresponding Gregorian calendar year.

  + `MONTH`: The first day in the month that contains the
    value to truncate.

  + `QUARTER`: The first day in the quarter that contains the
    value to truncate.

  + `YEAR`: The first day in the year that contains the
    value to truncate.

  + `ISOYEAR`: The first day in the [ISO 8601][ISO-8601] week-numbering year
    that contains the value to truncate. The ISO year is the
    Monday of the first week where Thursday belongs to the corresponding
    Gregorian calendar year.

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[ISO-8601]: https://en.wikipedia.org/wiki/ISO_8601

[ISO-8601-week]: https://en.wikipedia.org/wiki/ISO_week_date

<!-- mdlint on -->

<a id="datetime_trunc_granularity_time"></a>

**Time granularity definitions**

  + `NANOSECOND`: If used, nothing is truncated from the value.

  + `MICROSECOND`: The nearest lesser than or equal microsecond.

  + `MILLISECOND`: The nearest lesser than or equal millisecond.

  + `SECOND`: The nearest lesser than or equal second.

  + `MINUTE`: The nearest lesser than or equal minute.

  + `HOUR`: The nearest lesser than or equal hour.

<a id="datetime_time_zone_parts"></a>

**Time zone part definitions**

+ `MINUTE`
+ `HOUR`
+ `DAY`
+ `WEEK`
+ `WEEK(<WEEKDAY>)`
+ `ISOWEEK`
+ `MONTH`
+ `QUARTER`
+ `YEAR`
+ `ISOYEAR`

**Details**

The resulting value is always rounded to the beginning of `granularity`.

**Return Data Type**

The same data type as the first argument passed into this function.

**Examples**

```zetasql
SELECT
  DATETIME "2008-12-25 15:30:00" as original,
  DATETIME_TRUNC(DATETIME "2008-12-25 15:30:00", DAY) as truncated;

/*----------------------------+------------------------*
 | original                   | truncated              |
 +----------------------------+------------------------+
 | 2008-12-25 15:30:00        | 2008-12-25 00:00:00    |
 *----------------------------+------------------------*/
```

In the following example, the original `DATETIME` falls on a Sunday. Because the
`part` is `WEEK(MONDAY)`, `DATE_TRUNC` returns the `DATETIME` for the
preceding Monday.

```zetasql
SELECT
 datetime AS original,
 DATETIME_TRUNC(datetime, WEEK(MONDAY)) AS truncated
FROM (SELECT DATETIME(TIMESTAMP "2017-11-05 00:00:00+00", "UTC") AS datetime);

/*---------------------+---------------------*
 | original            | truncated           |
 +---------------------+---------------------+
 | 2017-11-05 00:00:00 | 2017-10-30 00:00:00 |
 *---------------------+---------------------*/
```

In the following example, the original `datetime_expression` is in the Gregorian
calendar year 2015. However, `DATETIME_TRUNC` with the `ISOYEAR` date part
truncates the `datetime_expression` to the beginning of the ISO year, not the
Gregorian calendar year. The first Thursday of the 2015 calendar year was
2015-01-01, so the ISO year 2015 begins on the preceding Monday, 2014-12-29.
Therefore the ISO year boundary preceding the `datetime_expression`
2015-06-15 00:00:00 is 2014-12-29.

```zetasql
SELECT
  DATETIME_TRUNC('2015-06-15 00:00:00', ISOYEAR) AS isoyear_boundary,
  EXTRACT(ISOYEAR FROM DATETIME '2015-06-15 00:00:00') AS isoyear_number;

/*---------------------+----------------*
 | isoyear_boundary    | isoyear_number |
 +---------------------+----------------+
 | 2014-12-29 00:00:00 | 2015           |
 *---------------------+----------------*/
```

[datetime-trunc-granularity-date]: #datetime_trunc_granularity_date

[datetime-trunc-granularity-time]: #datetime_trunc_granularity_time

[datetime-time-zone-parts]: #datetime_time_zone_parts

### `EXTRACT`

```zetasql
EXTRACT(part FROM datetime_expression)
```

**Description**

Returns a value that corresponds to the
specified `part` from a supplied `datetime_expression`.

Allowed `part` values are:

+ `NANOSECOND`
  (if the SQL engine supports it)
+ `MICROSECOND`
+ `MILLISECOND`
+ `SECOND`
+ `MINUTE`
+ `HOUR`
+ `DAYOFWEEK`: Returns values in the range [1,7] with Sunday as the first day of
   of the week.
+ `DAY`
+ `DAYOFYEAR`
+ `WEEK`: Returns the week number of the date in the range [0, 53]. Weeks begin
  with Sunday, and dates prior to the first Sunday of the year are in week
  0.
+ `WEEK(<WEEKDAY>)`: Returns the week number of `datetime_expression` in the
  range [0, 53]. Weeks begin on `WEEKDAY`.
  `datetime`s prior to the first `WEEKDAY` of the year are in week 0. Valid
  values for `WEEKDAY` are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`,
  `THURSDAY`, `FRIDAY`, and `SATURDAY`.
+ `ISOWEEK`: Returns the [ISO 8601 week][ISO-8601-week]
  number of the `datetime_expression`. `ISOWEEK`s begin on Monday. Return values
  are in the range [1, 53]. The first `ISOWEEK` of each ISO year begins on the
  Monday before the first Thursday of the Gregorian calendar year.
+ `MONTH`
+ `QUARTER`
+ `YEAR`
+ `ISOYEAR`: Returns the [ISO 8601][ISO-8601]
  week-numbering year, which is the Gregorian calendar year containing the
  Thursday of the week to which `date_expression` belongs.
+ `DATE`
+ `TIME`

Returned values truncate lower order time periods. For example, when extracting
seconds, `EXTRACT` truncates the millisecond and microsecond values.

**Return Data Type**

`INT64`, except in the following cases:

+ If `part` is `DATE`, returns a `DATE` object.
+ If `part` is `TIME`, returns a `TIME` object.

**Examples**

In the following example, `EXTRACT` returns a value corresponding to the `HOUR`
time part.

```zetasql
SELECT EXTRACT(HOUR FROM DATETIME(2008, 12, 25, 15, 30, 00)) as hour;

/*------------------*
 | hour             |
 +------------------+
 | 15               |
 *------------------*/
```

In the following example, `EXTRACT` returns values corresponding to different
time parts from a column of datetimes.

```zetasql
WITH Datetimes AS (
  SELECT DATETIME '2005-01-03 12:34:56' AS datetime UNION ALL
  SELECT DATETIME '2007-12-31' UNION ALL
  SELECT DATETIME '2009-01-01' UNION ALL
  SELECT DATETIME '2009-12-31' UNION ALL
  SELECT DATETIME '2017-01-02' UNION ALL
  SELECT DATETIME '2017-05-26'
)
SELECT
  datetime,
  EXTRACT(ISOYEAR FROM datetime) AS isoyear,
  EXTRACT(ISOWEEK FROM datetime) AS isoweek,
  EXTRACT(YEAR FROM datetime) AS year,
  EXTRACT(WEEK FROM datetime) AS week
FROM Datetimes
ORDER BY datetime;

/*---------------------+---------+---------+------+------*
 | datetime            | isoyear | isoweek | year | week |
 +---------------------+---------+---------+------+------+
 | 2005-01-03 12:34:56 | 2005    | 1       | 2005 | 1    |
 | 2007-12-31 00:00:00 | 2008    | 1       | 2007 | 52   |
 | 2009-01-01 00:00:00 | 2009    | 1       | 2009 | 0    |
 | 2009-12-31 00:00:00 | 2009    | 53      | 2009 | 52   |
 | 2017-01-02 00:00:00 | 2017    | 1       | 2017 | 1    |
 | 2017-05-26 00:00:00 | 2017    | 21      | 2017 | 21   |
 *---------------------+---------+---------+------+------*/
```

In the following example, `datetime_expression` falls on a Sunday. `EXTRACT`
calculates the first column using weeks that begin on Sunday, and it calculates
the second column using weeks that begin on Monday.

```zetasql
WITH table AS (SELECT DATETIME(TIMESTAMP "2017-11-05 00:00:00+00", "UTC") AS datetime)
SELECT
  datetime,
  EXTRACT(WEEK(SUNDAY) FROM datetime) AS week_sunday,
  EXTRACT(WEEK(MONDAY) FROM datetime) AS week_monday
FROM table;

/*---------------------+-------------+---------------*
 | datetime            | week_sunday | week_monday   |
 +---------------------+-------------+---------------+
 | 2017-11-05 00:00:00 | 45          | 44            |
 *---------------------+-------------+---------------*/
```

[ISO-8601]: https://en.wikipedia.org/wiki/ISO_8601

[ISO-8601-week]: https://en.wikipedia.org/wiki/ISO_week_date

### `FORMAT_DATETIME`

```zetasql
FORMAT_DATETIME(format_string, datetime_expr)
```

**Description**

Formats a `DATETIME` value according to a specified format string.

**Definitions**

+   `format_string`: A `STRING` value that contains the
    [format elements][datetime-format-elements] to use with
    `datetime_expr`.
+   `datetime_expr`: A `DATETIME` value that represents the date and time to
    format.

**Return Data Type**

`STRING`

**Examples**

```zetasql
SELECT
  FORMAT_DATETIME("%c", DATETIME "2008-12-25 15:30:00")
  AS formatted;

/*--------------------------*
 | formatted                |
 +--------------------------+
 | Thu Dec 25 15:30:00 2008 |
 *--------------------------*/
```

```zetasql
SELECT
  FORMAT_DATETIME("%b-%d-%Y", DATETIME "2008-12-25 15:30:00")
  AS formatted;

/*-------------*
 | formatted   |
 +-------------+
 | Dec-25-2008 |
 *-------------*/
```

```zetasql
SELECT
  FORMAT_DATETIME("%b %Y", DATETIME "2008-12-25 15:30:00")
  AS formatted;

/*-------------*
 | formatted   |
 +-------------+
 | Dec 2008    |
 *-------------*/
```

[datetime-format-elements]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#format_elements_date_time

### `LAST_DAY`

```zetasql
LAST_DAY(datetime_expression[, date_part])
```

**Description**

Returns the last day from a datetime expression that contains the date.
This is commonly used to return the last day of the month.

You can optionally specify the date part for which the last day is returned.
If this parameter isn't used, the default value is `MONTH`.
`LAST_DAY` supports the following values for `date_part`:

+  `YEAR`
+  `QUARTER`
+  `MONTH`
+  `WEEK`. Equivalent to 7 `DAY`s.
+  `WEEK(<WEEKDAY>)`. `<WEEKDAY>` represents the starting day of the week.
   Valid values are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`,
   `FRIDAY`, and `SATURDAY`.
+  `ISOWEEK`. Uses [ISO 8601][ISO-8601-week] week boundaries. ISO weeks begin
   on Monday.
+  `ISOYEAR`. Uses the [ISO 8601][ISO-8601] week-numbering year boundary.
   The ISO year boundary is the Monday of the first week whose Thursday belongs
   to the corresponding Gregorian calendar year.

**Return Data Type**

`DATE`

**Example**

These both return the last day of the month:

```zetasql
SELECT LAST_DAY(DATETIME '2008-11-25', MONTH) AS last_day

/*------------*
 | last_day   |
 +------------+
 | 2008-11-30 |
 *------------*/
```

```zetasql
SELECT LAST_DAY(DATETIME '2008-11-25') AS last_day

/*------------*
 | last_day   |
 +------------+
 | 2008-11-30 |
 *------------*/
```

This returns the last day of the year:

```zetasql
SELECT LAST_DAY(DATETIME '2008-11-25 15:30:00', YEAR) AS last_day

/*------------*
 | last_day   |
 +------------+
 | 2008-12-31 |
 *------------*/
```

This returns the last day of the week for a week that starts on a Sunday:

```zetasql
SELECT LAST_DAY(DATETIME '2008-11-10 15:30:00', WEEK(SUNDAY)) AS last_day

/*------------*
 | last_day   |
 +------------+
 | 2008-11-15 |
 *------------*/
```

This returns the last day of the week for a week that starts on a Monday:

```zetasql
SELECT LAST_DAY(DATETIME '2008-11-10 15:30:00', WEEK(MONDAY)) AS last_day

/*------------*
 | last_day   |
 +------------+
 | 2008-11-16 |
 *------------*/
```

[ISO-8601]: https://en.wikipedia.org/wiki/ISO_8601

[ISO-8601-week]: https://en.wikipedia.org/wiki/ISO_week_date

### `PARSE_DATETIME`

```zetasql
PARSE_DATETIME(format_string, datetime_string)
```

**Description**

Converts a `STRING` value to a `DATETIME` value.

**Definitions**

+   `format_string`: A `STRING` value that contains the
    [format elements][datetime-format-elements] to use with `datetime_string`.
+   `datetime_string`: A `STRING` value that represents the date and time to
    parse.

**Details**

Each element in `datetime_string` must have a corresponding element in
`format_string`. The location of each element in `format_string` must match the
location of each element in `datetime_string`.

```zetasql
-- This works because elements on both sides match.
SELECT PARSE_DATETIME("%a %b %e %I:%M:%S %Y", "Thu Dec 25 07:30:00 2008");

-- This produces an error because the year element is in different locations.
SELECT PARSE_DATETIME("%a %b %e %Y %I:%M:%S", "Thu Dec 25 07:30:00 2008");

-- This produces an error because one of the year elements is missing.
SELECT PARSE_DATETIME("%a %b %e %I:%M:%S", "Thu Dec 25 07:30:00 2008");

-- This works because %c can find all matching elements in datetime_string.
SELECT PARSE_DATETIME("%c", "Thu Dec 25 07:30:00 2008");
```

The following additional considerations apply when using the `PARSE_DATETIME`
function:

+ Unspecified fields. Any unspecified field is initialized from
  `1970-01-01 00:00:00.0`. For example, if the year is unspecified then it
  defaults to `1970`.
+ Case insensitivity. Names, such as `Monday` and `February`,
  are case insensitive.
+ Whitespace. One or more consecutive white spaces in the format string
  matches zero or more consecutive white spaces in the
  `DATETIME` string. Leading and trailing
  white spaces in the `DATETIME` string are always
  allowed, even if they aren't in the format string.
+ Format precedence. When two or more format elements have overlapping
  information, the last one generally overrides any earlier ones, with some
  exceptions. For example, both `%F` and `%Y` affect the year, so the earlier
  element overrides the later. See the descriptions
  of `%s`, `%C`, and `%y` in
  [Supported Format Elements For DATETIME][datetime-format-elements].
+ Format divergence. `%p` can be used with `am`, `AM`, `pm`, and `PM`.
+   Mixed ISO and non-ISO elements. The ISO format elements are `%G`, `%g`,
    `%J`, and `%V`. When these ISO elements are used together with other non-ISO
    elements, the ISO elements are ignored, resulting in different values. For
    example, the function arguments `('%g %J', '8405')` return a value with the
    year `1984`, whereas the arguments `('%g %j', '8405')` return a value with
    the year `1970` because the ISO element `%g` is ignored.
+   Numeric values after `%G` input values. Any input string value that
    corresponds to the `%G` format element requires a whitespace or non-digit
    character as a separator from numeric values that follow. This is a known
    issue in ZetaSQL. For example, the function arguments `('%G
    %V','2020 50')` or `('%G-%V','2020-50')` work, but not `('%G%V','202050')`.
    For input values before the corresponding `%G` value, no separator is
    needed. For example, the arguments `('%V%G','502020')` work. The separator
    after the `%G` values identifies the end of the specified ISO year value so
    that the function can parse properly.

**Return Data Type**

`DATETIME`

**Examples**

The following examples parse a `STRING` literal as a
`DATETIME`.

```zetasql
SELECT PARSE_DATETIME('%Y-%m-%d %H:%M:%S', '1998-10-18 13:45:55') AS datetime;

/*---------------------*
 | datetime            |
 +---------------------+
 | 1998-10-18 13:45:55 |
 *---------------------*/
```

```zetasql
SELECT PARSE_DATETIME('%m/%d/%Y %I:%M:%S %p', '8/30/2018 2:23:38 pm') AS datetime;

/*---------------------*
 | datetime            |
 +---------------------+
 | 2018-08-30 14:23:38 |
 *---------------------*/
```

The following example parses a `STRING` literal
containing a date in a natural language format as a
`DATETIME`.

```zetasql
SELECT PARSE_DATETIME('%A, %B %e, %Y','Wednesday, December 19, 2018')
  AS datetime;

/*---------------------*
 | datetime            |
 +---------------------+
 | 2018-12-19 00:00:00 |
 *---------------------*/
```

[datetime-format-elements]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#format_elements_date_time

[ISO-8601]: https://en.wikipedia.org/wiki/ISO_8601

## Debugging functions

ZetaSQL supports the following debugging functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#error"><code>ERROR</code></a>
</td>
  <td>
    Produces an error with a custom error message.
  </td>
</tr>

<tr>
  <td><a href="#iferror"><code>IFERROR</code></a>
</td>
  <td>
    Evaluates a try expression, and if an evaluation error is produced, returns
    the result of a catch expression.
  </td>
</tr>

<tr>
  <td><a href="#iserror"><code>ISERROR</code></a>
</td>
  <td>
    Evaluates a try expression, and if an evaluation error is produced, returns
    <code>TRUE</code>.
  </td>
</tr>

<tr>
  <td><a href="#nulliferror"><code>NULLIFERROR</code></a>
</td>
  <td>
    Evaluates a try expression, and if an evaluation error is produced, returns
    <code>NULL</code>.
  </td>
</tr>

  </tbody>
</table>

### `ERROR`

```zetasql
ERROR(error_message)
```

**Description**

Returns an error.

**Definitions**

+   `error_message`: A `STRING` value that represents the error message to
    produce. Any whitespace characters beyond a
    single space are trimmed from the results.

**Details**

`ERROR` is treated like any other expression that may
result in an error: there is no special guarantee of evaluation order.

**Return Data Type**

ZetaSQL infers the return type in context.

**Examples**

In the following example, the query produces an error message:

```zetasql
-- ERROR: Show this error message (while evaluating error("Show this error message"))
SELECT ERROR('Show this error message')
```

In the following example, the query returns an error message if the value of the
row doesn't match one of two defined values.

```zetasql
SELECT
  CASE
    WHEN value = 'foo' THEN 'Value is foo.'
    WHEN value = 'bar' THEN 'Value is bar.'
    ELSE ERROR(CONCAT('Found unexpected value: ', value))
  END AS new_value
FROM (
  SELECT 'foo' AS value UNION ALL
  SELECT 'bar' AS value UNION ALL
  SELECT 'baz' AS value);

-- Found unexpected value: baz
```

In the following example, ZetaSQL may evaluate the `ERROR` function
before or after the <nobr>`x > 0`</nobr> condition, because ZetaSQL
generally provides no ordering guarantees between `WHERE` clause conditions and
there are no special guarantees for the `ERROR` function.

```zetasql
SELECT *
FROM (SELECT -1 AS x)
WHERE x > 0 AND ERROR('Example error');
```

In the next example, the `WHERE` clause evaluates an `IF` condition, which
ensures that ZetaSQL only evaluates the `ERROR` function if the
condition fails.

```zetasql
SELECT *
FROM (SELECT -1 AS x)
WHERE IF(x > 0, true, ERROR(FORMAT('Error: x must be positive but is %t', x)));

-- Error: x must be positive but is -1
```

### `IFERROR`

```zetasql
IFERROR(try_expression, catch_expression)
```

**Description**

Evaluates `try_expression`.

When `try_expression` is evaluated:

+ If the evaluation of `try_expression` doesn't produce an error, then
  `IFERROR` returns the result of `try_expression` without evaluating
  `catch_expression`.
+ If the evaluation of `try_expression` produces a system error, then `IFERROR`
  produces that system error.
+ If the evaluation of `try_expression` produces an evaluation error, then
  `IFERROR` suppresses that evaluation error and evaluates `catch_expression`.

If `catch_expression` is evaluated:

+ If the evaluation of `catch_expression` doesn't produce an error, then
  `IFERROR` returns the result of `catch_expression`.
+ If the evaluation of `catch_expression` produces any error, then `IFERROR`
  produces that error.

**Arguments**

+ `try_expression`: An expression that returns a scalar value.
+ `catch_expression`: An expression that returns a scalar value.

The results of `try_expression` and `catch_expression` must share a
[supertype][supertype].

**Return Data Type**

The [supertype][supertype] for `try_expression` and
`catch_expression`.

**Example**

In the following example, the query successfully evaluates `try_expression`.

```zetasql
SELECT IFERROR('a', 'b') AS result

/*--------*
 | result |
 +--------+
 | a      |
 *--------*/
```

In the following example, the query successfully evaluates the
`try_expression` subquery.

```zetasql
SELECT IFERROR((SELECT [1,2,3][OFFSET(0)]), -1) AS result

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

In the following example, `IFERROR` catches an evaluation error in the
`try_expression` and successfully evaluates `catch_expression`.

```zetasql
SELECT IFERROR(ERROR('a'), 'b') AS result

/*--------*
 | result |
 +--------+
 | b      |
 *--------*/
```

In the following example, `IFERROR` catches an evaluation error in the
`try_expression` subquery and successfully evaluates `catch_expression`.

```zetasql
SELECT IFERROR((SELECT [1,2,3][OFFSET(9)]), -1) AS result

/*--------*
 | result |
 +--------+
 | -1     |
 *--------*/
```

In the following query, the error is handled by the innermost `IFERROR`
operation, `IFERROR(ERROR('a'), 'b')`.

```zetasql
SELECT IFERROR(IFERROR(ERROR('a'), 'b'), 'c') AS result

/*--------*
 | result |
 +--------+
 | b      |
 *--------*/
```

In the following query, the error is handled by the outermost `IFERROR`
operation, `IFERROR(..., 'c')`.

```zetasql
SELECT IFERROR(IFERROR(ERROR('a'), ERROR('b')), 'c') AS result

/*--------*
 | result |
 +--------+
 | c      |
 *--------*/
```

In the following example, an evaluation error is produced because the subquery
passed in as the `try_expression` evaluates to a table, not a scalar value.

```zetasql
SELECT IFERROR((SELECT e FROM UNNEST([1, 2]) AS e), 3) AS result

/*--------*
 | result |
 +--------+
 | 3      |
 *--------*/
```

In the following example, `IFERROR` catches an evaluation error in `ERROR('a')`
and then evaluates `ERROR('b')`. Because there is also an evaluation error in
`ERROR('b')`, `IFERROR` produces an evaluation error for `ERROR('b')`.

```zetasql
SELECT IFERROR(ERROR('a'), ERROR('b')) AS result

--ERROR: OUT_OF_RANGE 'b'
```

[supertype]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md#supertypes

### `ISERROR`

```zetasql
ISERROR(try_expression)
```

**Description**

Evaluates `try_expression`.

+ If the evaluation of `try_expression` doesn't produce an error, then
  `ISERROR` returns `FALSE`.
+ If the evaluation of `try_expression` produces a system error, then `ISERROR`
  produces that system error.
+ If the evaluation of `try_expression` produces an evaluation error, then
  `ISERROR` returns `TRUE`.

**Arguments**

+ `try_expression`: An expression that returns a scalar value.

**Return Data Type**

`BOOL`

**Example**

In the following examples, `ISERROR` successfully evaluates `try_expression`.

```zetasql
SELECT ISERROR('a') AS is_error

/*----------*
 | is_error |
 +----------+
 | false    |
 *----------*/
```

```zetasql
SELECT ISERROR(2/1) AS is_error

/*----------*
 | is_error |
 +----------+
 | false    |
 *----------*/
```

```zetasql
SELECT ISERROR((SELECT [1,2,3][OFFSET(0)])) AS is_error

/*----------*
 | is_error |
 +----------+
 | false    |
 *----------*/
```

In the following examples, `ISERROR` catches an evaluation error in
`try_expression`.

```zetasql
SELECT ISERROR(ERROR('a')) AS is_error

/*----------*
 | is_error |
 +----------+
 | true     |
 *----------*/
```

```zetasql
SELECT ISERROR(2/0) AS is_error

/*----------*
 | is_error |
 +----------+
 | true     |
 *----------*/
```

```zetasql
SELECT ISERROR((SELECT [1,2,3][OFFSET(9)])) AS is_error

/*----------*
 | is_error |
 +----------+
 | true     |
 *----------*/
```

In the following example, an evaluation error is produced because the subquery
passed in as `try_expression` evaluates to a table, not a scalar value.

```zetasql
SELECT ISERROR((SELECT e FROM UNNEST([1, 2]) AS e)) AS is_error

/*----------*
 | is_error |
 +----------+
 | true     |
 *----------*/
```

### `NULLIFERROR`

```zetasql
NULLIFERROR(try_expression)
```

**Description**

Evaluates `try_expression`.

+ If the evaluation of `try_expression` doesn't produce an error, then
  `NULLIFERROR` returns the result of `try_expression`.
+ If the evaluation of `try_expression` produces a system error, then
 `NULLIFERROR` produces that system error.

+ If the evaluation of `try_expression` produces an evaluation error, then
  `NULLIFERROR` returns `NULL`.

**Arguments**

+ `try_expression`: An expression that returns a scalar value.

**Return Data Type**

The data type for `try_expression` or `NULL`

**Example**

In the following example, `NULLIFERROR` successfully evaluates
`try_expression`.

```zetasql
SELECT NULLIFERROR('a') AS result

/*--------*
 | result |
 +--------+
 | a      |
 *--------*/
```

In the following example, `NULLIFERROR` successfully evaluates
the `try_expression` subquery.

```zetasql
SELECT NULLIFERROR((SELECT [1,2,3][OFFSET(0)])) AS result

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

In the following example, `NULLIFERROR` catches an evaluation error in
`try_expression`.

```zetasql
SELECT NULLIFERROR(ERROR('a')) AS result

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

In the following example, `NULLIFERROR` catches an evaluation error in
the `try_expression` subquery.

```zetasql
SELECT NULLIFERROR((SELECT [1,2,3][OFFSET(9)])) AS result

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

In the following example, an evaluation error is produced because the subquery
passed in as `try_expression` evaluates to a table, not a scalar value.

```zetasql
SELECT NULLIFERROR((SELECT e FROM UNNEST([1, 2]) AS e)) AS result

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

## Differentially private aggregate functions 
<a id="aggregate-dp-functions"></a>

ZetaSQL supports differentially private aggregate functions.
For an explanation of how aggregate functions work, see
[Aggregate function calls][agg-function-calls].

You can only use differentially private aggregate functions with
[differentially private queries][dp-guide] in a
[differential privacy clause][dp-syntax].

Note: In this topic, the privacy parameters in the examples aren't
recommendations. You should work with your privacy or security officer to
determine the optimal privacy parameters for your dataset and organization.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#dp_avg"><code>AVG</code> (Differential Privacy)</a>
</td>
  <td>
    <code>DIFFERENTIAL_PRIVACY</code>-supported <code>AVG</code>.<br/><br/>
    Gets the differentially-private average of non-<code>NULL</code>,
    non-<code>NaN</code> values in a query with a
    <code>DIFFERENTIAL_PRIVACY</code> clause.
    
  </td>
</tr>

<tr>
  <td><a href="#dp_count"><code>COUNT</code> (Differential Privacy)</a>
</td>
  <td>
    <code>DIFFERENTIAL_PRIVACY</code>-supported <code>COUNT</code>.<br/><br/>
    Signature 1: Gets the differentially-private count of rows in a query with a
    <code>DIFFERENTIAL_PRIVACY</code> clause.
    <br/>
    <br/>
    Signature 2: Gets the differentially-private count of rows with a
    non-<code>NULL</code> expression in a query with a
    <code>DIFFERENTIAL_PRIVACY</code> clause.
    
  </td>
</tr>

<tr>
  <td><a href="#dp_percentile_cont"><code>PERCENTILE_CONT</code> (Differential Privacy)</a>
</td>
  <td>
    <code>DIFFERENTIAL_PRIVACY</code>-supported <code>PERCENTILE_CONT</code>.<br/><br/>
    Computes a differentially-private percentile across privacy unit columns
    in a query with a <code>DIFFERENTIAL_PRIVACY</code> clause.
    
  </td>
</tr>

<tr>
  <td><a href="#dp_sum"><code>SUM</code> (Differential Privacy)</a>
</td>
  <td>
    <code>DIFFERENTIAL_PRIVACY</code>-supported <code>SUM</code>.<br/><br/>
    Gets the differentially-private sum of non-<code>NULL</code>,
    non-<code>NaN</code> values in a query with a
    <code>DIFFERENTIAL_PRIVACY</code> clause.
    
  </td>
</tr>

<tr>
  <td><a href="#dp_var_pop"><code>VAR_POP</code> (Differential Privacy)</a>
</td>
  <td>
    <code>DIFFERENTIAL_PRIVACY</code>-supported <code>VAR_POP</code> (Differential Privacy).<br/><br/>
    Computes the differentially-private population (biased) variance of values
    in a query with a <code>DIFFERENTIAL_PRIVACY</code> clause.
    
  </td>
</tr>

<tr>
  <td><a href="#anon_avg"><code>ANON_AVG</code></a>
</td>
  <td>
    Deprecated.
    Gets the differentially-private average of non-<code>NULL</code>,
    non-<code>NaN</code> values in a query with an
    <code>ANONYMIZATION</code> clause.
  </td>
</tr>

<tr>
  <td><a href="#anon_count"><code>ANON_COUNT</code></a>
</td>
  <td>
    Deprecated.
    <br/>
    <br/>
    Signature 1: Gets the differentially-private count of rows in a query
    with an <code>ANONYMIZATION</code> clause.
    <br/>
    <br/>
    Signature 2: Gets the differentially-private count of rows with a
    non-<code>NULL</code> expression in a query with an
    <code>ANONYMIZATION</code> clause.
  </td>
</tr>

<tr>
  <td><a href="#anon_percentile_cont"><code>ANON_PERCENTILE_CONT</code></a>
</td>
  <td>
    Deprecated.
    Computes a differentially-private percentile across privacy unit columns
    in a query with an <code>ANONYMIZATION</code> clause.
  </td>
</tr>

<tr>
  <td><a href="#anon_quantiles"><code>ANON_QUANTILES</code></a>
</td>
  <td>
    Deprecated.
    Produces an array of differentially-private quantile boundaries
    in a query with an <code>ANONYMIZATION</code> clause.
  </td>
</tr>

<tr>
  <td><a href="#anon_stddev_pop"><code>ANON_STDDEV_POP</code></a>
</td>
  <td>
    Deprecated.
    Computes a differentially-private population (biased) standard deviation of
    values in a query with an <code>ANONYMIZATION</code> clause.
  </td>
</tr>

<tr>
  <td><a href="#anon_sum"><code>ANON_SUM</code></a>
</td>
  <td>
    Deprecated.
    Gets the differentially-private sum of non-<code>NULL</code>,
    non-<code>NaN</code> values in a query with an
    <code>ANONYMIZATION</code> clause.
  </td>
</tr>

<tr>
  <td><a href="#anon_var_pop"><code>ANON_VAR_POP</code></a>
</td>
  <td>
    Deprecated.
    Computes a differentially-private population (biased) variance of values
    in a query with an <code>ANONYMIZATION</code> clause.
  </td>
</tr>

  </tbody>
</table>

### `AVG` (`DIFFERENTIAL_PRIVACY`) 
<a id="dp_avg"></a>

```zetasql
WITH DIFFERENTIAL_PRIVACY ...
  AVG(
    expression,
    [ contribution_bounds_per_group => (lower_bound, upper_bound) ]
  )
```

**Description**

Returns the average of non-`NULL`, non-`NaN` values in the expression.
This function first computes the average per privacy unit column, and then
computes the final result by averaging these averages.

This function must be used with the [`DIFFERENTIAL_PRIVACY` clause][dp-syntax]
and can support the following arguments:

+ `expression`: The input expression. This can be any numeric input type,
  such as `INT64`.
+ `contribution_bounds_per_group`: A named argument with a
  [contribution bound][dp-clamped-named].
  Performs clamping for each group separately before performing intermediate
  grouping on the privacy unit column.

**Return type**

`DOUBLE`

**Examples**

The following differentially private query gets the average number of each item
requested per professor. Smaller aggregations might not be included. This query
references a table called [`professors`][dp-example-tables].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1, privacy_unit_column=id)
    item,
    AVG(quantity, contribution_bounds_per_group => (0,100)) average_quantity
FROM professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+------------------*
 | item     | average_quantity |
 +----------+------------------+
 | pencil   | 38.5038356810269 |
 | pen      | 13.4725028762032 |
 *----------+------------------*/
```

```zetasql
-- Without noise, using the epsilon parameter.
-- (this un-noised version is for demonstration only)
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=1e20, delta=.01, max_groups_contributed=1, privacy_unit_column=id)
    item,
    AVG(quantity) average_quantity
FROM professors
GROUP BY item;

-- These results will not change when you run the query.
/*----------+------------------*
 | item     | average_quantity |
 +----------+------------------+
 | scissors | 8                |
 | pencil   | 40               |
 | pen      | 18.5             |
 *----------+------------------*/
```

The following differentially private query gets the average number of each item
requested per professor. Smaller aggregations might not be included. This query
references a view called [`view_on_professors`][dp-example-views].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    AVG(quantity, contribution_bounds_per_group=>(0, 100)) average_quantity
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+------------------*
 | item     | average_quantity |
 +----------+------------------+
 | pencil   | 38.5038356810269 |
 | pen      | 13.4725028762032 |
 *----------+------------------*/
```

```zetasql
-- Without noise, using the epsilon parameter.
-- (this un-noised version is for demonstration only)
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=1e20, delta=.01, max_groups_contributed=1)
    item,
    AVG(quantity) average_quantity
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will not change when you run the query.
/*----------+------------------*
 | item     | average_quantity |
 +----------+------------------+
 | scissors | 8                |
 | pencil   | 40               |
 | pen      | 18.5             |
 *----------+------------------*/
```

Note: For more information about when and when not to use
noise, see [Remove noise][dp-noise].

[dp-example-tables]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_tables

[dp-noise]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#eliminate_noise

[dp-clamped-named]: #dp_clamped_named

[dp-syntax]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_clause

[dp-example-views]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_views

### `COUNT` (`DIFFERENTIAL_PRIVACY`) 
<a id="dp_count"></a>

+ [Signature 1](#dp_count_signature1): Returns the number of rows in a
  differentially private `FROM` clause.
+ [Signature 2](#dp_count_signature2): Returns the number of non-`NULL`
  values in an expression.

#### Signature 1 
<a id="dp_count_signature1"></a>

```zetasql
WITH DIFFERENTIAL_PRIVACY ...
  COUNT(
    *,
    [ contribution_bounds_per_group => (lower_bound, upper_bound) ]
  )
```

**Description**

Returns the number of rows in the
[differentially private][dp-from-clause] `FROM` clause. The final result
is an aggregation across a privacy unit column.

This function must be used with the [`DIFFERENTIAL_PRIVACY` clause][dp-syntax]
and can support the following argument:

+ `contribution_bounds_per_group`: A named argument with a
  [contribution bound][dp-clamped-named].
  Performs clamping for each group separately before performing intermediate
  grouping on the privacy unit column.

**Return type**

`INT64`

**Examples**

The following differentially private query counts the number of requests for
each item. This query references a table called
[`professors`][dp-example-tables].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1, privacy_unit_column=id)
    item,
    COUNT(*, contribution_bounds_per_group=>(0, 100)) times_requested
FROM professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+-----------------*
 | item     | times_requested |
 +----------+-----------------+
 | pencil   | 5               |
 | pen      | 2               |
 *----------+-----------------*/
```

```zetasql
-- Without noise, using the epsilon parameter.
-- (this un-noised version is for demonstration only)
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=1e20, delta=.01, max_groups_contributed=1, privacy_unit_column=id)
    item,
    COUNT(*, contribution_bounds_per_group=>(0, 100)) times_requested
FROM professors
GROUP BY item;

-- These results will not change when you run the query.
/*----------+-----------------*
 | item     | times_requested |
 +----------+-----------------+
 | scissors | 1               |
 | pencil   | 4               |
 | pen      | 3               |
 *----------+-----------------*/
```

The following differentially private query counts the number of requests for
each item. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    COUNT(*, contribution_bounds_per_group=>(0, 100)) times_requested
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+-----------------*
 | item     | times_requested |
 +----------+-----------------+
 | pencil   | 5               |
 | pen      | 2               |
 *----------+-----------------*/
```

```zetasql
-- Without noise, using the epsilon parameter.
-- (this un-noised version is for demonstration only)
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=1e20, delta=.01, max_groups_contributed=1)
    item,
    COUNT(*, contribution_bounds_per_group=>(0, 100)) times_requested
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will not change when you run the query.
/*----------+-----------------*
 | item     | times_requested |
 +----------+-----------------+
 | scissors | 1               |
 | pencil   | 4               |
 | pen      | 3               |
 *----------+-----------------*/
```

Note: For more information about when and when not to use
noise, see [Remove noise][dp-noise].

#### Signature 2 
<a id="dp_count_signature2"></a>

```zetasql
WITH DIFFERENTIAL_PRIVACY ...
  COUNT(
    expression,
    [contribution_bounds_per_group => (lower_bound, upper_bound)]
  )
```

**Description**

Returns the number of non-`NULL` expression values. The final result is an
aggregation across a privacy unit column.

This function must be used with the [`DIFFERENTIAL_PRIVACY` clause][dp-syntax]
and can support these arguments:

+ `expression`: The input expression. This expression can be any
  numeric input type, such as `INT64`.
+ `contribution_bounds_per_group`: A named argument with a
  [contribution bound][dp-clamped-named].
  Performs clamping per each group separately before performing intermediate
  grouping on the privacy unit column.

**Return type**

`INT64`

**Examples**

The following differentially private query counts the number of requests made
for each type of item. This query references a table called
[`professors`][dp-example-tables].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1, privacy_unit_column=id)
    item,
    COUNT(item, contribution_bounds_per_group => (0,100)) times_requested
FROM professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+-----------------*
 | item     | times_requested |
 +----------+-----------------+
 | pencil   | 5               |
 | pen      | 2               |
 *----------+-----------------*/
```

```zetasql
-- Without noise, using the epsilon parameter.
-- (this un-noised version is for demonstration only)
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=1e20, delta=.01, max_groups_contributed=1, privacy_unit_column=id)
    item,
    COUNT(item, contribution_bounds_per_group => (0,100)) times_requested
FROM professors
GROUP BY item;

-- These results will not change when you run the query.
/*----------+-----------------*
 | item     | times_requested |
 +----------+-----------------+
 | scissors | 1               |
 | pencil   | 4               |
 | pen      | 3               |
 *----------+-----------------*/
```

The following differentially private query counts the number of requests made
for each type of item. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
-- With noise
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    COUNT(item, contribution_bounds_per_group=>(0, 100)) times_requested
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+-----------------*
 | item     | times_requested |
 +----------+-----------------+
 | pencil   | 5               |
 | pen      | 2               |
 *----------+-----------------*/
```

```zetasql
--Without noise (this un-noised version is for demonstration only)
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=1e20, delta=.01, max_groups_contributed=1)
    item,
    COUNT(item, contribution_bounds_per_group=>(0, 100)) times_requested
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will not change when you run the query.
/*----------+-----------------*
 | item     | times_requested |
 +----------+-----------------+
 | scissors | 1               |
 | pencil   | 4               |
 | pen      | 3               |
 *----------+-----------------*/
```

Note: For more information about when and when not to use
noise, see [Remove noise][dp-noise].

[dp-clamp-implicit]: #dp_implicit_clamping

[dp-from-clause]: https://github.com/google/zetasql/blob/master/docs/differential-privacy.md#dp_from_rules

[dp-example-tables]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_tables

[dp-noise]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#eliminate_noise

[dp-syntax]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_clause

[dp-clamped-named]: #dp_clamped_named

[dp-example-views]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_views

### `PERCENTILE_CONT` (`DIFFERENTIAL_PRIVACY`) 
<a id="dp_percentile_cont"></a>

```zetasql
WITH DIFFERENTIAL_PRIVACY ...
  PERCENTILE_CONT(
    expression,
    percentile,
    contribution_bounds_per_row => (lower_bound, upper_bound)
  )
```

**Description**

Takes an expression and computes a percentile for it. The final result is an
aggregation across privacy unit columns.

This function must be used with the [`DIFFERENTIAL_PRIVACY` clause][dp-syntax]
and can support these arguments:

+ `expression`: The input expression. This can be most numeric input types,
  such as `INT64`. `NULL` values are always ignored.
+ `percentile`: The percentile to compute. The percentile must be a literal in
  the range `[0, 1]`.
+ `contribution_bounds_per_row`: A named argument with a
  [contribution bounds][dp-clamped-named].
  Performs clamping for each row separately before performing intermediate
  grouping on the privacy unit column.

`NUMERIC` and `BIGNUMERIC` arguments aren't allowed.
 If you need them, cast them as the
`DOUBLE` data type first.

**Return type**

`DOUBLE`

**Examples**

The following differentially private query gets the percentile of items
requested. Smaller aggregations might not be included. This query references a
view called [`professors`][dp-example-tables].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1, privacy_unit_column=id)
    item,
    PERCENTILE_CONT(quantity, 0.5, contribution_bounds_per_row => (0,100)) percentile_requested
FROM professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
 /*----------+----------------------*
  | item     | percentile_requested |
  +----------+----------------------+
  | pencil   | 72.00011444091797    |
  | scissors | 8.000175476074219    |
  | pen      | 23.001075744628906   |
  *----------+----------------------*/
```

The following differentially private query gets the percentile of items
requested. Smaller aggregations might not be included. This query references a
view called [`view_on_professors`][dp-example-views].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    PERCENTILE_CONT(quantity, 0.5, contribution_bounds_per_row=>(0, 100)) percentile_requested
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+----------------------*
 | item     | percentile_requested |
 +----------+----------------------+
 | pencil   | 72.00011444091797    |
 | scissors | 8.000175476074219    |
 | pen      | 23.001075744628906   |
 *----------+----------------------*/
```

[dp-example-tables]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_tables

[dp-clamped-named]: #dp_clamped_named

[dp-syntax]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_clause

[dp-example-views]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_views

### `SUM` (`DIFFERENTIAL_PRIVACY`) 
<a id="dp_sum"></a>

```zetasql
WITH DIFFERENTIAL_PRIVACY ...
  SUM(
    expression,
    [ contribution_bounds_per_group => (lower_bound, upper_bound) ]
  )
```

**Description**

Returns the sum of non-`NULL`, non-`NaN` values in the expression. The final
result is an aggregation across privacy unit columns.

This function must be used with the [`DIFFERENTIAL_PRIVACY` clause][dp-syntax]
and can support these arguments:

+ `expression`: The input expression. This can be any numeric input type,
  such as `INT64`. `NULL` values are always ignored.
+ `contribution_bounds_per_group`: A named argument with a
  [contribution bound][dp-clamped-named]. Performs clamping for each group
  separately before performing intermediate grouping on the privacy unit column.

**Return type**

One of the following [supertypes][dp-supertype]:

+ `INT64`
+ `UINT64`
+ `DOUBLE`

**Examples**

The following differentially private query gets the sum of items requested.
Smaller aggregations might not be included. This query references a view called
[`professors`][dp-example-tables].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1, privacy_unit_column=id)
    item,
    SUM(quantity, contribution_bounds_per_group => (0,100)) quantity
FROM professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+-----------*
 | item     | quantity  |
 +----------+-----------+
 | pencil   | 143       |
 | pen      | 59        |
 *----------+-----------*/
```

```zetasql
-- Without noise, using the epsilon parameter.
-- (this un-noised version is for demonstration only)
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=1e20, delta=.01, max_groups_contributed=1, privacy_unit_column=id)
    item,
    SUM(quantity) quantity
FROM professors
GROUP BY item;

-- These results will not change when you run the query.
/*----------+----------*
 | item     | quantity |
 +----------+----------+
 | scissors | 8        |
 | pencil   | 144      |
 | pen      | 58       |
 *----------+----------*/
```

The following differentially private query gets the sum of items requested.
Smaller aggregations might not be included. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    SUM(quantity, contribution_bounds_per_group=>(0, 100)) quantity
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+-----------*
 | item     | quantity  |
 +----------+-----------+
 | pencil   | 143       |
 | pen      | 59        |
 *----------+-----------*/
```

```zetasql
-- Without noise, using the epsilon parameter.
-- (this un-noised version is for demonstration only)
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=1e20, delta=.01, max_groups_contributed=1)
    item,
    SUM(quantity) quantity
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will not change when you run the query.
/*----------+----------*
 | item     | quantity |
 +----------+----------+
 | scissors | 8        |
 | pencil   | 144      |
 | pen      | 58       |
 *----------+----------*/
```

Note: For more information about when and when not to use
noise, see [Use differential privacy][dp-noise].

[dp-example-tables]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_tables

[dp-noise]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#eliminate_noise

[dp-supertype]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md#supertypes

[dp-clamped-named]: #dp_clamped_named

[dp-syntax]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_clause

[dp-example-views]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_views

### `VAR_POP` (`DIFFERENTIAL_PRIVACY`) 
<a id="dp_var_pop"></a>

```zetasql
WITH DIFFERENTIAL_PRIVACY ...
  VAR_POP(
    expression,
    [ contribution_bounds_per_row => (lower_bound, upper_bound) ]
  )
```

**Description**

Takes an expression and computes the population (biased) variance of the values
in the expression. The final result is an aggregation across
privacy unit columns between `0` and `+Inf`. You can
[clamp the input values][dp_clamped_named] explicitly, otherwise input values
are clamped implicitly. Clamping is performed per individual user values.

This function must be used with the `DIFFERENTIAL_PRIVACY` clause and
can support these arguments:

+ `expression`: The input expression. This can be any numeric input type,
  such as `INT64`. `NULL`s are always ignored.
+ `contribution_bounds_per_row`: A named argument with a
  [contribution bound][dp-clamped-named].
  Performs clamping for each row separately before performing intermediate
  grouping on individual user values.

`NUMERIC` and `BIGNUMERIC` arguments aren't allowed.
 If you need them, cast them as the
`DOUBLE` data type first.

**Return type**

`DOUBLE`

**Examples**

The following differentially private query gets the
population (biased) variance of items requested. Smaller aggregations may not
be included. This query references a view called
[`professors`][dp-example-tables].

```zetasql
-- With noise
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1, privacy_unit_column=id)
    item,
    VAR_POP(quantity, contribution_bounds_per_row => (0,100)) pop_variance
FROM professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations may be removed.
/*----------+-----------------*
 | item     | pop_variance    |
 +----------+-----------------+
 | pencil   | 642             |
 | pen      | 2.6666666666665 |
 | scissors | 2500            |
 *----------+-----------------*/
```

The following differentially private query gets the
population (biased) variance of items requested. Smaller aggregations might not
be included. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
-- With noise
SELECT
  WITH DIFFERENTIAL_PRIVACY
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    VAR_POP(quantity, contribution_bounds_per_row=>(0, 100)) pop_variance
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+-----------------*
 | item     | pop_variance    |
 +----------+-----------------+
 | pencil   | 642             |
 | pen      | 2.6666666666665 |
 | scissors | 2500            |
 *----------+-----------------*/
```

[dp-example-tables]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_tables

[dp-clamped-named]: #dp_clamped_named

[dp-example-views]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_views

### `ANON_AVG` (DEPRECATED) 
<a id="anon_avg"></a>

Warning: This function has been deprecated. Use
`AVG` (differential privacy) instead.

```zetasql
WITH ANONYMIZATION ...
  ANON_AVG(expression [clamped_between_clause])

clamped_between_clause:
  CLAMPED BETWEEN lower_bound AND upper_bound
```

**Description**

Returns the average of non-`NULL`, non-`NaN` values in the expression.
This function first computes the average per privacy unit column, and then
computes the final result by averaging these averages.

This function must be used with the `ANONYMIZATION` clause and
can support these arguments:

+ `expression`: The input expression. This can be any numeric input type,
  such as `INT64`.
+ `clamped_between_clause`: Perform [clamping][dp-clamping] per
  privacy unit column averages.

**Return type**

`DOUBLE`

**Examples**

The following differentially private query gets the average number of each item
requested per professor. Smaller aggregations might not be included. This query
references a view called [`view_on_professors`][dp-example-views].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH ANONYMIZATION
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    ANON_AVG(quantity CLAMPED BETWEEN 0 AND 100) average_quantity
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+------------------*
 | item     | average_quantity |
 +----------+------------------+
 | pencil   | 38.5038356810269 |
 | pen      | 13.4725028762032 |
 *----------+------------------*/
```

```zetasql
-- Without noise, using the epsilon parameter.
-- (this un-noised version is for demonstration only)
SELECT
  WITH ANONYMIZATION
    OPTIONS(epsilon=1e20, delta=.01, max_groups_contributed=1)
    item,
    ANON_AVG(quantity) average_quantity
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will not change when you run the query.
/*----------+------------------*
 | item     | average_quantity |
 +----------+------------------+
 | scissors | 8                |
 | pencil   | 40               |
 | pen      | 18.5             |
 *----------+------------------*/
```

Note: You can learn more about when and when not to use
noise [here][dp-noise].

[dp-example-views]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_views

[dp-noise]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#eliminate_noise

[dp-clamping]: #dp_clamping

### `ANON_COUNT` (DEPRECATED) 
<a id="anon_count"></a>

Warning: This function has been deprecated. Use
`COUNT` (differential privacy) instead.

+ [Signature 1](#anon_count_signature1)
+ [Signature 2](#anon_count_signature2)

#### Signature 1 
<a id="anon_count_signature1"></a>

```zetasql
WITH ANONYMIZATION ...
  ANON_COUNT(*)
```

**Description**

Returns the number of rows in the
[differentially private][dp-from-clause] `FROM` clause. The final result
is an aggregation across privacy unit columns.
[Input values are clamped implicitly][dp-clamp-implicit]. Clamping is
performed per privacy unit column.

This function must be used with the `ANONYMIZATION` clause.

**Return type**

`INT64`

**Examples**

The following differentially private query counts the number of requests for
each item. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH ANONYMIZATION
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    ANON_COUNT(*) times_requested
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+-----------------*
 | item     | times_requested |
 +----------+-----------------+
 | pencil   | 5               |
 | pen      | 2               |
 *----------+-----------------*/
```

```zetasql
-- Without noise, using the epsilon parameter.
-- (this un-noised version is for demonstration only)
SELECT
  WITH ANONYMIZATION
    OPTIONS(epsilon=1e20, delta=.01, max_groups_contributed=1)
    item,
    ANON_COUNT(*) times_requested
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will not change when you run the query.
/*----------+-----------------*
 | item     | times_requested |
 +----------+-----------------+
 | scissors | 1               |
 | pencil   | 4               |
 | pen      | 3               |
 *----------+-----------------*/
```

Note: You can learn more about when and when not to use
noise [here][dp-noise].

#### Signature 2 
<a id="anon_count_signature2"></a>

```zetasql
WITH ANONYMIZATION ...
  ANON_COUNT(expression [CLAMPED BETWEEN lower_bound AND upper_bound])
```

**Description**

Returns the number of non-`NULL` expression values. The final result is an
aggregation across privacy unit columns.

This function must be used with the `ANONYMIZATION` clause and
can support these arguments:

+ `expression`: The input expression. This can be any numeric input type,
  such as `INT64`.
+ `CLAMPED BETWEEN` clause:
  Perform [clamping][dp-clamping] per privacy unit column.

**Return type**

`INT64`

**Examples**

The following differentially private query counts the number of requests made
for each type of item. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
-- With noise
SELECT
  WITH ANONYMIZATION
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    ANON_COUNT(item CLAMPED BETWEEN 0 AND 100) times_requested
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+-----------------*
 | item     | times_requested |
 +----------+-----------------+
 | pencil   | 5               |
 | pen      | 2               |
 *----------+-----------------*/
```

```zetasql
--Without noise (this un-noised version is for demonstration only)
SELECT
  WITH ANONYMIZATION
    OPTIONS(epsilon=1e20, delta=.01, max_groups_contributed=1)
    item,
    ANON_COUNT(item CLAMPED BETWEEN 0 AND 100) times_requested
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will not change when you run the query.
/*----------+-----------------*
 | item     | times_requested |
 +----------+-----------------+
 | scissors | 1               |
 | pencil   | 4               |
 | pen      | 3               |
 *----------+-----------------*/
```

Note: You can learn more about when and when not to use
noise [here][dp-noise].

[dp-clamp-implicit]: #dp_clamped_named_implicit

[dp-from-clause]: https://github.com/google/zetasql/blob/master/docs/differential-privacy.md#dp_from_rules

[dp-example-views]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_views

[dp-noise]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#eliminate_noise

[dp-clamping]: #dp_clamping

### `ANON_PERCENTILE_CONT` (DEPRECATED) 
<a id="anon_percentile_cont"></a>

Warning: This function has been deprecated. Use
`PERCENTILE_CONT` (differential privacy) instead.

```zetasql
WITH ANONYMIZATION ...
  ANON_PERCENTILE_CONT(expression, percentile [CLAMPED BETWEEN lower_bound AND upper_bound])
```

**Description**

Takes an expression and computes a percentile for it. The final result is an
aggregation across privacy unit columns.

This function must be used with the `ANONYMIZATION` clause and
can support these arguments:

+ `expression`: The input expression. This can be most numeric input types,
  such as `INT64`. `NULL`s are always ignored.
+ `percentile`: The percentile to compute. The percentile must be a literal in
  the range [0, 1]
+ `CLAMPED BETWEEN` clause:
  Perform [clamping][dp-clamping] per privacy unit column.

`NUMERIC` and `BIGNUMERIC` arguments aren't allowed.
 If you need them, cast them as the
`DOUBLE` data type first.

**Return type**

`DOUBLE`

**Examples**

The following differentially private query gets the percentile of items
requested. Smaller aggregations might not be included. This query references a
view called [`view_on_professors`][dp-example-views].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH ANONYMIZATION
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    ANON_PERCENTILE_CONT(quantity, 0.5 CLAMPED BETWEEN 0 AND 100) percentile_requested
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+----------------------*
 | item     | percentile_requested |
 +----------+----------------------+
 | pencil   | 72.00011444091797    |
 | scissors | 8.000175476074219    |
 | pen      | 23.001075744628906   |
 *----------+----------------------*/
```

[dp-example-views]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_views

[dp-clamping]: #dp_clamping

### `ANON_QUANTILES` (DEPRECATED) 
<a id="anon_quantiles"></a>

Warning: This function has been deprecated. Use
`QUANTILES` (differential privacy) instead.

```zetasql
WITH ANONYMIZATION ...
  ANON_QUANTILES(expression, number CLAMPED BETWEEN lower_bound AND upper_bound)
```

**Description**

Returns an array of differentially private quantile boundaries for values in
`expression`. The first element in the return value is the
minimum quantile boundary and the last element is the maximum quantile boundary.
The returned results are aggregations across privacy unit columns.

This function must be used with the `ANONYMIZATION` clause and
can support these arguments:

+ `expression`: The input expression. This can be most numeric input types,
  such as `INT64`. `NULL`s are always ignored.
+ `number`: The number of quantiles to create. This must be an `INT64`.
+ `CLAMPED BETWEEN` clause:
  Perform [clamping][dp-clamping] per privacy unit column.

`NUMERIC` and `BIGNUMERIC` arguments aren't allowed.
 If you need them, cast them as the
`DOUBLE` data type first.

**Return type**

`ARRAY`\<`DOUBLE`>

**Examples**

The following differentially private query gets the five quantile boundaries of
the four quartiles of the number of items requested. Smaller aggregations
might not be included. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH ANONYMIZATION
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    ANON_QUANTILES(quantity, 4 CLAMPED BETWEEN 0 AND 100) quantiles_requested
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+----------------------------------------------------------------------*
 | item     | quantiles_requested                                                  |
 +----------+----------------------------------------------------------------------+
 | pen      | [6.409375,20.647684733072918,41.40625,67.30848524305556,99.80078125] |
 | pencil   | [6.849259,44.010416666666664,62.64204,65.83806818181819,98.59375]    |
 *----------+----------------------------------------------------------------------*/
```

[dp-example-views]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_views

[dp-clamping]: #dp_clamping

### `ANON_STDDEV_POP` (DEPRECATED) 
<a id="anon_stddev_pop"></a>

Warning: This function has been deprecated. Use
`STDDEV_POP` (differential privacy) instead.

```zetasql
WITH ANONYMIZATION ...
  ANON_STDDEV_POP(expression [CLAMPED BETWEEN lower_bound AND upper_bound])
```

**Description**

Takes an expression and computes the population (biased) standard deviation of
the values in the expression. The final result is an aggregation across
privacy unit columns between `0` and `+Inf`.

This function must be used with the `ANONYMIZATION` clause and
can support these arguments:

+ `expression`: The input expression. This can be most numeric input types,
  such as `INT64`. `NULL`s are always ignored.
+ `CLAMPED BETWEEN` clause:
  Perform [clamping][dp-clamping] per individual entity values.

`NUMERIC` and `BIGNUMERIC` arguments aren't allowed.
 If you need them, cast them as the
`DOUBLE` data type first.

**Return type**

`DOUBLE`

**Examples**

The following differentially private query gets the
population (biased) standard deviation of items requested. Smaller aggregations
might not be included. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH ANONYMIZATION
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    ANON_STDDEV_POP(quantity CLAMPED BETWEEN 0 AND 100) pop_standard_deviation
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+------------------------*
 | item     | pop_standard_deviation |
 +----------+------------------------+
 | pencil   | 25.350871122442054     |
 | scissors | 50                     |
 | pen      | 2                      |
 *----------+------------------------*/
```

[dp-example-views]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_views

[dp-clamping]: #dp_clamping

### `ANON_SUM` (DEPRECATED) 
<a id="anon_sum"></a>

Warning: This function has been deprecated. Use
`SUM` (differential privacy) instead.

```zetasql
WITH ANONYMIZATION ...
  ANON_SUM(expression [CLAMPED BETWEEN lower_bound AND upper_bound])
```

**Description**

Returns the sum of non-`NULL`, non-`NaN` values in the expression. The final
result is an aggregation across privacy unit columns.

This function must be used with the `ANONYMIZATION` clause and
can support these arguments:

+ `expression`: The input expression. This can be any numeric input type,
  such as `INT64`.
+ `CLAMPED BETWEEN` clause:
  Perform [clamping][dp-clamping] per privacy unit column.

**Return type**

One of the following [supertypes][dp-supertype]:

+ `INT64`
+ `UINT64`
+ `DOUBLE`

**Examples**

The following differentially private query gets the sum of items requested.
Smaller aggregations might not be included. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH ANONYMIZATION
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    ANON_SUM(quantity CLAMPED BETWEEN 0 AND 100) quantity
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+-----------*
 | item     | quantity  |
 +----------+-----------+
 | pencil   | 143       |
 | pen      | 59        |
 *----------+-----------*/
```

```zetasql
-- Without noise, using the epsilon parameter.
-- (this un-noised version is for demonstration only)
SELECT
  WITH ANONYMIZATION
    OPTIONS(epsilon=1e20, delta=.01, max_groups_contributed=1)
    item,
    ANON_SUM(quantity) quantity
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will not change when you run the query.
/*----------+----------*
 | item     | quantity |
 +----------+----------+
 | scissors | 8        |
 | pencil   | 144      |
 | pen      | 58       |
 *----------+----------*/
```

Note: You can learn more about when and when not to use
noise [here][dp-noise].

[dp-example-views]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_views

[dp-noise]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#eliminate_noise

[dp-supertype]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md#supertypes

[dp-clamping]: #dp_clamping

### `ANON_VAR_POP` (DEPRECATED) 
<a id="anon_var_pop"></a>

Warning: This function has been deprecated. Use
`VAR_POP` (differential privacy) instead.

```zetasql
WITH ANONYMIZATION ...
  ANON_VAR_POP(expression [CLAMPED BETWEEN lower_bound AND upper_bound])
```

**Description**

Takes an expression and computes the population (biased) variance of the values
in the expression. The final result is an aggregation across
privacy unit columns between `0` and `+Inf`. You can
[clamp the input values][dp-clamp-explicit] explicitly, otherwise input values
are clamped implicitly. Clamping is performed per individual entity values.

This function must be used with the `ANONYMIZATION` clause and
can support these arguments:

+ `expression`: The input expression. This can be any numeric input type,
  such as `INT64`. `NULL`s are always ignored.
+ `CLAMPED BETWEEN` clause:
  Perform [clamping][dp-clamping] per individual entity values.

`NUMERIC` and `BIGNUMERIC` arguments aren't allowed.
 If you need them, cast them as the
`DOUBLE` data type first.

**Return type**

`DOUBLE`

**Examples**

The following differentially private query gets the
population (biased) variance of items requested. Smaller aggregations might not
be included. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
-- With noise, using the epsilon parameter.
SELECT
  WITH ANONYMIZATION
    OPTIONS(epsilon=10, delta=.01, max_groups_contributed=1)
    item,
    ANON_VAR_POP(quantity CLAMPED BETWEEN 0 AND 100) pop_variance
FROM {{USERNAME}}.view_on_professors
GROUP BY item;

-- These results will change each time you run the query.
-- Smaller aggregations might be removed.
/*----------+-----------------*
 | item     | pop_variance    |
 +----------+-----------------+
 | pencil   | 642             |
 | pen      | 2.6666666666665 |
 | scissors | 2500            |
 *----------+-----------------*/
```

[dp-clamp-explicit]: #dp_clamped_named

[dp-example-views]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_views

[dp-clamping]: #dp_clamping

### Supplemental materials

### Clamp values in a differentially private aggregate function 
<a id="dp_clamping"></a>

In [differentially private queries][dp-syntax],
aggregation clamping is used to limit the contribution of outliers. You can
clamp explicitly or implicitly as follows:

+ [Clamp explicitly in the `DIFFERENTIAL_PRIVACY` clause][dp-clamped-named].
+ [Clamp implicitly in the `DIFFERENTIAL_PRIVACY` clause][dp-clamped-named-imp].

#### Implicitly clamp values 
<a id="dp_clamped_named_implicit"></a>

If you don't include the contribution bounds named argument with the
`DIFFERENTIAL_PRIVACY` clause, clamping is implicit, which
means bounds are derived from the data itself in a differentially private way.

Implicit bounding works best when computed using large datasets. For more
information, see
[Implicit bounding limitations for small datasets][implicit-limits].

**Details**

In differentially private aggregate functions, explicit clamping is optional.
If you don't include this clause, clamping is implicit,
which means bounds are derived from the data itself in a differentially
private way. The process is somewhat random, so aggregations with identical
ranges can have different bounds.

Implicit bounds are determined for each aggregation. So if some
aggregations have a wide range of values, and others have a narrow range of
values, implicit bounding can identify different bounds for different
aggregations as appropriate. Implicit bounds might be an advantage or a
disadvantage depending on your use case. Different bounds for different
aggregations can result in lower error. Different bounds also means that
different aggregations have different levels of uncertainty, which might not be
directly comparable. [Explicit bounds][dp-clamped-named], on the other hand,
apply uniformly to all aggregations and should be derived from public
information.

When clamping is implicit, part of the total epsilon is spent picking bounds.
This leaves less epsilon for aggregations, so these aggregations are noisier.

**Example**

The following anonymized query clamps each aggregate contribution for each
differential privacy ID and within a derived range from the data itself.
As long as all or most values fall within this range, your results
will be accurate. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
--Without noise (this un-noised version is for demonstration only)
SELECT WITH DIFFERENTIAL_PRIVACY
  OPTIONS (
    epsilon = 1e20,
    delta = .01,
    privacy_unit_column=id
  )
  item,
  AVG(quantity) average_quantity
FROM view_on_professors
GROUP BY item;

/*----------+------------------*
 | item     | average_quantity |
 +----------+------------------+
 | scissors | 8                |
 | pencil   | 72               |
 | pen      | 18.5             |
 *----------+------------------*/
```

The following anonymized query clamps each aggregate contribution for each
differential privacy ID and within a derived range from the data itself.
As long as all or most values fall within this range, your results
will be accurate. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
--Without noise (this un-noised version is for demonstration only)
SELECT WITH DIFFERENTIAL_PRIVACY
  OPTIONS (
    epsilon = 1e20,
    delta = .01,
    max_groups_contributed = 1
  )
  item,
  AVG(quantity) AS average_quantity
FROM view_on_professors
GROUP BY item;

/*----------+------------------*
 | item     | average_quantity |
 +----------+------------------+
 | scissors | 8                |
 | pencil   | 72               |
 | pen      | 18.5             |
 *----------+------------------*/
```

#### Explicitly clamp values 
<a id="dp_clamped_named"></a>

```zetasql
contribution_bounds_per_group => (lower_bound,upper_bound)
```

```zetasql
contribution_bounds_per_row => (lower_bound,upper_bound)
```

Use the contribution bounds named argument to explicitly clamp
values per group or per row between a lower and upper bound in a
`DIFFERENTIAL_PRIVACY` clause.

Input values:

+ `contribution_bounds_per_row`: Contributions per privacy unit are clamped
  on a per-row (per-record) basis. This means the following:
  +  Upper and lower bounds are applied to column values in individual
    rows produced by the input subquery independently.
  +  The maximum possible contribution per privacy unit (and per grouping set)
    is the product of the per-row contribution limit and `max_groups_contributed`
    differential privacy parameter.
+ `contribution_bounds_per_group`: Contributions per privacy unit are clamped
  on a unique set of entity-specified `GROUP BY` keys. The upper and lower
  bounds are applied to values per group after the values are aggregated per
  privacy unit.
+ `lower_bound`: Numeric literal that represents the smallest value to
  include in an aggregation.
+ `upper_bound`: Numeric literal that represents the largest value to
  include in an aggregation.

`NUMERIC` and `BIGNUMERIC` arguments aren't allowed.

**Details**

In differentially private aggregate functions, clamping explicitly clamps the
total contribution from each privacy unit column to within a specified
range.

Explicit bounds are uniformly applied to all aggregations. So even if some
aggregations have a wide range of values, and others have a narrow range of
values, the same bounds are applied to all of them. On the other hand, when
[implicit bounds][dp-clamped-named-imp] are inferred from the data, the bounds
applied to each aggregation can be different.

Explicit bounds should be chosen to reflect public information.
For example, bounding ages between 0 and 100 reflects public information
because the age of most people generally falls within this range.

Important: The results of the query reveal the explicit bounds. Don't use
explicit bounds based on the entity data; explicit bounds should be based on
public information.

**Examples**

The following anonymized query clamps each aggregate contribution for each
differential privacy ID and within a specified range (`0` and `100`).
As long as all or most values fall within this range, your results
will be accurate. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
--Without noise (this un-noised version is for demonstration only)
SELECT WITH DIFFERENTIAL_PRIVACY
  OPTIONS (
    epsilon = 1e20,
    delta = .01,
    privacy_unit_column=id
  )
  item,
  AVG(quantity, contribution_bounds_per_group=>(0,100)) AS average_quantity
FROM view_on_professors
GROUP BY item;

/*----------+------------------*
 | item     | average_quantity |
 +----------+------------------+
 | scissors | 8                |
 | pencil   | 40               |
 | pen      | 18.5             |
 *----------+------------------*/
```

Notice what happens when most or all values fall outside of the clamped range.
To get accurate results, ensure that the difference between the upper and lower
bound is as small as possible, and that most inputs are between the upper and
lower bound.

```zetasql {.bad}
--Without noise (this un-noised version is for demonstration only)
SELECT WITH DIFFERENTIAL_PRIVACY
  OPTIONS (
    epsilon = 1e20,
    delta = .01,
    privacy_unit_column=id
  )
  item,
  AVG(quantity, contribution_bounds_per_group=>(50,100)) AS average_quantity
FROM view_on_professors
GROUP BY item;

/*----------+------------------*
 | item     | average_quantity |
 +----------+------------------+
 | scissors | 54               |
 | pencil   | 58               |
 | pen      | 51               |
 *----------+------------------*/
```

The following differentially private query clamps each aggregate contribution
for each privacy unit column and within a specified range (`0` and `100`).
As long as all or most values fall within this range, your results will be
accurate. This query references a view called
[`view_on_professors`][dp-example-views].

```zetasql
--Without noise (this un-noised version is for demonstration only)
SELECT WITH DIFFERENTIAL_PRIVACY
  OPTIONS (
    epsilon = 1e20,
    delta = .01,
    max_groups_contributed = 1
  )
  item,
  AVG(quantity, contribution_bounds_per_group=>(0,100)) AS average_quantity
FROM view_on_professors
GROUP BY item;

/*----------+------------------*
 | item     | average_quantity |
 +----------+------------------+
 | scissors | 8                |
 | pencil   | 40               |
 | pen      | 18.5             |
 *----------+------------------*/
```

Notice what happens when most or all values fall outside of the clamped range.
To get accurate results, ensure that the difference between the upper and lower
bound is as small as possible, and that most inputs are between the upper and
lower bound.

```zetasql {.bad}
--Without noise (this un-noised version is for demonstration only)
SELECT WITH DIFFERENTIAL_PRIVACY
  OPTIONS (
    epsilon = 1e20,
    delta = .01,
    max_groups_contributed = 1
  )
  item,
  AVG(quantity, contribution_bounds_per_group=>(50,100)) AS average_quantity
FROM view_on_professors
GROUP BY item;

/*----------+------------------*
 | item     | average_quantity |
 +----------+------------------+
 | scissors | 54               |
 | pencil   | 58               |
 | pen      | 51               |
 *----------+------------------*/
```

Note: For more information about when and when not to use
noise, see [Remove noise][dp-noise].

[dp-syntax]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_clause

[dp-example-views]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_example_views

[dp-noise]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#eliminate_noise

[implicit-limits]: https://github.com/google/zetasql/blob/master/docs/differential-privacy.md#implicit_limits

[dp-clamped-named]: #dp_clamped_named

[dp-clamped-named-imp]: #dp_clamped_named_implicit

[dp-guide]: https://github.com/google/zetasql/blob/master/docs/differential-privacy.md

[dp-syntax]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#dp_clause

[agg-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

## GQL functions

ZetaSQL supports the following GQL functions:

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td>
    
    <a href="#destination_node_id"><code>DESTINATION_NODE_ID</code></a>

    
  </td>
  <td>Gets a unique identifier of a graph edge's destination node.</td>
</tr>

<tr>
  <td>
    
    <a href="#edges"><code>EDGES</code></a>

    
  </td>
  <td>
    Gets the edges in a graph path. The resulting array retains the
    original order in the graph path.
  </td>
</tr>

<tr>
  <td>
    
    <a href="#element_id"><code>ELEMENT_ID</code></a>

    
  </td>
  <td>Gets a graph element's unique identifier.</td>
</tr>

<tr>
  <td>
    
    <a href="#is_acyclic"><code>IS_ACYCLIC</code></a>

    
  </td>
  <td>Checks if a graph path has a repeating node.</td>
</tr>

<tr>
  <td>
    
    <a href="#is_simple"><code>IS_SIMPLE</code></a>

    
  </td>
  <td>Checks if a graph path is simple.</td>
</tr>

<tr>
  <td>
    
    <a href="#is_trail"><code>IS_TRAIL</code></a>

    
  </td>
  <td>Checks if a graph path has a repeating edge.</td>
</tr>

<tr>
  <td>
    
    <a href="#labels"><code>LABELS</code></a>

    
  </td>
  <td>Gets the labels associated with a graph element.</td>
</tr>

<tr>
  <td>
    
    <a href="#nodes"><code>NODES</code></a>

    
  </td>
  <td>
    Gets the nodes in a graph path. The resulting array retains the
    original order in the graph path.
  </td>
</tr>

<tr>
  <td>
    
    <a href="#path"><code>PATH</code></a>

    
  </td>
  <td>Creates a graph path from a list of graph elements.</td>
</tr>

<tr>
  <td>
    
    <a href="#path_first"><code>PATH_FIRST</code></a>

    
  </td>
  <td>Gets the first node in a graph path.</td>
</tr>

<tr>
  <td>
    
    <a href="#path_last"><code>PATH_LAST</code></a>

    
  </td>
  <td>Gets the last node in a graph path.</td>
</tr>

<tr>
  <td>
    
    <a href="#path_length"><code>PATH_LENGTH</code></a>

    
  </td>
  <td>Gets the number of edges in a graph path.</td>
</tr>

<tr>
  <td>
    
    <a href="#property_names"><code>PROPERTY_NAMES</code></a>

    
  </td>
  <td>Gets the property names associated with a graph element.</td>
</tr>

<tr>
  <td>
    
    <a href="#source_node_id"><code>SOURCE_NODE_ID</code></a>

    
  </td>
  <td>Gets a unique identifier of a graph edge's source node.</td>
</tr>

  </tbody>
</table>

### `DESTINATION_NODE_ID`

```zetasql
DESTINATION_NODE_ID(edge_element)
```

**Description**

Gets a unique identifier of a graph edge's destination node. The unique identifier is only valid for the scope of the query where it's obtained.

**Arguments**

+   `edge_element`: A `GRAPH_ELEMENT` value that represents an edge.

**Details**

Returns `NULL` if `edge_element` is `NULL`.

**Return type**

`STRING`

**Examples**

```zetasql
GRAPH FinGraph
MATCH (:Person)-[o:Owns]->(a:Account)
RETURN a.id AS account_id, DESTINATION_NODE_ID(o) AS destination_node_id

/*------------------------------------------+
 |account_id | destination_node_id          |
 +-----------|------------------------------+
 | 7         | mUZpbkdyYXBoLkFjY291bnQAeJEO |
 | 16        | mUZpbkdyYXBoLkFjY291bnQAeJEg |
 | 20        | mUZpbkdyYXBoLkFjY291bnQAeJEo |
 +------------------------------------------*/
```

Note that the actual identifiers obtained may be different from what's shown above.

### `EDGES`

```zetasql
EDGES(graph_path)
```

**Description**

Gets the edges in a graph path. The resulting array retains the
original order in the graph path.

**Definitions**

+   `graph_path`: A `GRAPH_PATH` value that represents a graph path.

**Details**

If `graph_path` is `NULL`, returns `NULL`.

**Return type**

`ARRAY<GRAPH_ELEMENT>`

**Examples**

```zetasql
GRAPH FinGraph
MATCH p=(src:Account)-[t1:Transfers]->(mid:Account)-[t2:Transfers]->(dst:Account)
LET es = EDGES(p)
RETURN ARRAY_CONCAT(ARRAY_TRANSFORM(es, e -> e.Id), [dst.Id]) as ids_in_path

/*-------------+
 | ids_in_path |
 +-------------+
 | [16,20,7]   |
 +-------------+
 | [20,7,16]   |
 +-------------+
 | [20,7,16]   |
 +-------------+
 | [16,20,16]  |
 +-------------+
 | [7,16,20]   |
 +-------------+
 | [7,16,20]   |
 +-------------+
 | [20,16,20]  |
 +-------------*/
```

### `ELEMENT_ID`

```zetasql
ELEMENT_ID(element)
```

**Description**

Gets a graph element's unique identifier. The unique identifier is only valid for the scope of the query where it's obtained.

**Arguments**

+   `element`: A `GRAPH_ELEMENT` value.

**Details**

Returns `NULL` if `element` is `NULL`.

**Return type**

`STRING`

**Examples**

```zetasql
GRAPH FinGraph
MATCH (p:Person)-[o:Owns]->(:Account)
RETURN p.name AS name, ELEMENT_ID(p) AS node_element_id, ELEMENT_ID(o) AS edge_element_id

/*--------------------------------------------------------------------------------------------------------------------------------------------+
 | name | node_element_id              | edge_element_id         .                                                                            |
 +------|------------------------------|------------------------------------------------------------------------------------------------------+
 | Alex | mUZpbkdyYXBoLlBlcnNvbgB4kQI= | mUZpbkdyYXBoLlBlcnNvbk93bkFjY291bnQAeJECkQ6ZRmluR3JhcGguUGVyc29uAHiRAplGaW5HcmFwaC5BY2NvdW50AHiRDg== |
 | Dana | mUZpbkdyYXBoLlBlcnNvbgB4kQQ= | mUZpbkdyYXBoLlBlcnNvbk93bkFjY291bnQAeJEGkSCZRmluR3JhcGguUGVyc29uAHiRBplGaW5HcmFwaC5BY2NvdW50AHiRIA== |
 | Lee  | mUZpbkdyYXBoLlBlcnNvbgB4kQY= | mUZpbkdyYXBoLlBlcnNvbk93bkFjY291bnQAeJEEkSiZRmluR3JhcGguUGVyc29uAHiRBJlGaW5HcmFwaC5BY2NvdW50AHiRKA== |
 +--------------------------------------------------------------------------------------------------------------------------------------------*/
```

Note that the actual identifiers obtained may be different from what's shown above.

### `IS_ACYCLIC`

```zetasql
IS_ACYCLIC(graph_path)
```

**Description**

Checks if a graph path has a repeating node. Returns `TRUE` if a repetition
isn't found, otherwise returns `FALSE`.

**Definitions**

+   `graph_path`: A `GRAPH_PATH` value that represents a graph path.

**Details**

Two nodes are considered equal if they compare as equal.

Returns `NULL` if `graph_path` is `NULL`.

**Return type**

`BOOL`

**Examples**

```zetasql
GRAPH FinGraph
MATCH p=(src:Account)-[t1:Transfers]->(mid:Account)-[t2:Transfers]->(dst:Account)
RETURN src.id AS source_account_id, IS_ACYCLIC(p) AS is_acyclic_path

/*-------------------------------------*
 | source_account_id | is_acyclic_path |
 +-------------------------------------+
 | 16                | TRUE            |
 | 20                | TRUE            |
 | 20                | TRUE            |
 | 16                | FALSE           |
 | 7                 | TRUE            |
 | 7                 | TRUE            |
 | 20                | FALSE           |
 *-------------------------------------*/
```

### `IS_SIMPLE`

```zetasql
IS_SIMPLE(graph_path)
```

**Description**

Checks if a graph path is simple. Returns `TRUE` if the path has no repeated
nodes, or if the only repeated nodes are its head and tail. Otherwise, returns
`FALSE`.

**Definitions**

+   `graph_path`: A `GRAPH_PATH` value that represents a graph path.

**Details**

Returns `NULL` if `graph_path` is `NULL`.

**Return type**

`BOOL`

**Examples**

```zetasql
GRAPH FinGraph
MATCH p=(a1:Account)-[t1:Transfers where t1.amount > 200]->
        (a2:Account)-[t2:Transfers where t2.amount > 200]->
        (a3:Account)-[t3:Transfers where t3.amount > 100]->(a4:Account)
RETURN
  IS_SIMPLE(p) AS is_simple_path,
  a1.id as a1_id, a2.id as a2_id, a3.id as a3_id, a4.id as a4_id

/*----------------+-------+-------+-------+-------+
 | is_simple_path | a1_id | a2_id | a3_id | a4_id |
 +----------------+-------+-------+-------+-------+
 | TRUE           | 7     | 16    | 20    | 7     |
 | TRUE           | 16    | 20    | 7     | 16    |
 | FALSE          | 7     | 16    | 20    | 16    |
 | TRUE           | 20    | 7     | 16    | 20    |
 +----------------+-------+-------+-------+-------*/
```

### `IS_TRAIL`

```zetasql
IS_TRAIL(graph_path)
```

**Description**

Checks if a graph path has a repeating edge. Returns `TRUE` if a repetition
isn't found, otherwise returns `FALSE`.

**Definitions**

+   `graph_path`: A `GRAPH_PATH` value that represents a graph path.

**Details**

Returns `NULL` if `graph_path` is `NULL`.

**Return type**

`BOOL`

**Examples**

```zetasql
GRAPH FinGraph
MATCH
  p=(a1:Account)-[t1:Transfers]->(a2:Account)-[t2:Transfers]->
    (a3:Account)-[t3:Transfers]->(a4:Account)
WHERE a1.id < a4.id
RETURN
  IS_TRAIL(p) AS is_trail_path, t1.id as t1_id, t2.id as t2_id, t3.id as t3_id

/*---------------+-------+-------+-------+
 | is_trail_path | t1_id | t2_id | t3_id |
 +---------------+-------+-------+-------+
 | FALSE         | 16    | 20    | 16    |
 | TRUE          | 7     | 16    | 20    |
 | TRUE          | 7     | 16    | 20    |
 +---------------+-------+-------+-------*/
```

### `LABELS`

```zetasql
LABELS(element)
```

**Description**

Gets the labels associated with a graph element and preserves the original case
of each label.

**Arguments**

+   `element`: A `GRAPH_ELEMENT` value that represents the graph element to
    extract labels from.

**Details**

Returns `NULL` if `element` is `NULL`.

**Return type**

`ARRAY<STRING>`

**Examples**

```zetasql
GRAPH FinGraph
MATCH (n:Person|Account)
RETURN LABELS(n) AS label, n.id

/*----------------+
 | label     | id |
 +----------------+
 | [Account] | 7  |
 | [Account] | 16 |
 | [Account] | 20 |
 | [Person]  | 1  |
 | [Person]  | 2  |
 | [Person]  | 3  |
 +----------------*/
```

### `NODES`

```zetasql
NODES(graph_path)
```

**Description**

Gets the nodes in a graph path. The resulting array retains the
original order in the graph path.

**Definitions**

+   `graph_path`: A `GRAPH_PATH` value that represents a graph path.

**Details**

Returns `NULL` if `graph_path` is `NULL`.

**Return type**

`ARRAY<GRAPH_ELEMENT>`

**Examples**

```zetasql
GRAPH FinGraph
MATCH p=(src:Account)-[t1:Transfers]->(mid:Account)-[t2:Transfers]->(dst:Account)
LET ns = NODES(p)
RETURN
  JSON_QUERY(TO_JSON(ns)[0], '$.labels') AS labels,
  JSON_QUERY(TO_JSON(ns)[0], '$.properties.nick_name') AS nick_name;

/*--------------------------------*
 | labels      | nick_name        |
 +--------------------------------+
 | ["Account"] | "Vacation Fund"  |
 | ["Account"] | "Rainy Day Fund" |
 | ["Account"] | "Rainy Day Fund" |
 | ["Account"] | "Rainy Day Fund" |
 | ["Account"] | "Vacation Fund"  |
 | ["Account"] | "Vacation Fund"  |
 | ["Account"] | "Vacation Fund"  |
 | ["Account"] | "Rainy Day Fund" |
 *--------------------------------*/
```

### `PATH`

```zetasql
PATH(graph_element[, ...])
```

**Description**

Creates a graph path from a list of graph elements.

**Definitions**

+   `graph_element`: A `GRAPH_ELEMENT` value that represents a graph element,
    such as a node or edge, to add to a graph path.

**Details**

This function produces an error if:

+ A graph element is `NULL`.
+ Nodes aren't interleaved with edges.
+ An edge doesn't connect to neighboring nodes.

**Return type**

`GRAPH_PATH`

**Examples**

```zetasql
GRAPH FinGraph
MATCH (src:Account)-[t1:Transfers]->(mid:Account)-[t2:Transfers]->(dst:Account)
LET p = PATH(src, t1, mid, t2, dst)
RETURN
  JSON_QUERY(TO_JSON(p)[0], '$.labels') AS element_a,
  JSON_QUERY(TO_JSON(p)[1], '$.labels') AS element_b,
  JSON_QUERY(TO_JSON(p)[2], '$.labels') AS element_c

/*-------------------------------------------*
 | element_a   | element_b     | element_c   |
 +-------------------------------------------+
 | ["Account"] | ["Transfers"] | ["Account"] |
 | ...         | ...           | ...         |
 *-------------------------------------------*/
```

```zetasql
-- Error: in 'p', a graph element is NULL.
GRAPH FinGraph
MATCH (src:Account)-[t1:Transfers]->(mid:Account)-[t2:Transfers]->(dst:Account)
LET p = PATH(src, NULL, mid, t2, dst)
RETURN TO_JSON(p) AS results
```

```zetasql
-- Error: in 'p', 'src' and 'mid' are nodes that should be interleaved with an
-- edge.
GRAPH FinGraph
MATCH (src:Account)-[t1:Transfers]->(mid:Account)-[t2:Transfers]->(dst:Account)
LET p = PATH(src, mid, t2, dst)
RETURN TO_JSON(p) AS results
```

```zetasql
-- Error: in 'p', 't2' is an edge that doesn't connect to a neighboring node on
-- the right.
GRAPH FinGraph
MATCH (src:Account)-[t1:Transfers]->(mid:Account)-[t2:Transfers]->(dst:Account)
LET p = PATH(src, t2, mid)
RETURN TO_JSON(p) AS results
```

### `PATH_FIRST`

```zetasql
PATH_FIRST(graph_path)
```

**Description**

Gets the first node in a graph path.

**Definitions**

+   `graph_path`: A `GRAPH_PATH` value that represents the graph path to
    extract the first node from.

**Details**

Returns `NULL` if `graph_path` is `NULL`.

**Return type**

`GRAPH_ELEMENT`

**Examples**

```zetasql
GRAPH FinGraph
MATCH p=(src:Account)-[t1:Transfers]->(mid:Account)-[t2:Transfers]->(dst:Account)
LET f = PATH_FIRST(p)
RETURN
  LABELS(f) AS labels,
  f.nick_name AS nick_name;

/*--------------------------*
 | labels  | nick_name      |
 +--------------------------+
 | Account | Vacation Fund  |
 | Account | Rainy Day Fund |
 | Account | Rainy Day Fund |
 | Account | Vacation Fund  |
 | Account | Vacation Fund  |
 | Account | Vacation Fund  |
 | Account | Rainy Day Fund |
 *--------------------------*/
```

### `PATH_LAST`

```zetasql
PATH_LAST(graph_path)
```

**Description**

Gets the last node in a graph path.

**Definitions**

+   `graph_path`: A `GRAPH_PATH` value that represents the graph path to
    extract the last node from.

**Details**

Returns `NULL` if `graph_path` is `NULL`.

**Return type**

`GRAPH_ELEMENT`

**Examples**

```zetasql
GRAPH FinGraph
MATCH p=(src:Account)-[t1:Transfers]->(mid:Account)-[t2:Transfers]->(dst:Account)
LET f = PATH_LAST(p)
RETURN
  LABELS(f) AS labels,
  f.nick_name AS nick_name;

/*--------------------------*
 | labels  | nick_name      |
 +--------------------------+
 | Account | Vacation Fund  |
 | Account | Vacation Fund  |
 | Account | Vacation Fund  |
 | Account | Vacation Fund  |
 | Account | Rainy Day Fund |
 | Account | Rainy Day Fund |
 | Account | Rainy Day Fund |
 *--------------------------*/
```

### `PATH_LENGTH`

```zetasql
PATH_LENGTH(graph_path)
```

**Description**

Gets the number of edges in a graph path.

**Definitions**

+   `graph_path`: A `GRAPH_PATH` value that represents the graph path with the
    edges to count.

**Details**

Returns `NULL` if `graph_path` is `NULL`.

**Return type**

`INT64`

**Examples**

```zetasql
GRAPH FinGraph
MATCH p=(src:Account)-[t1:Transfers]->(mid:Account)-[t2:Transfers]->(dst:Account)
RETURN PATH_LENGTH(p) AS results

/*---------*
 | results |
 +---------+
 | 2       |
 | 2       |
 | 2       |
 | 2       |
 | 2       |
 | 2       |
 | 2       |
 *---------*/
```

### `PROPERTY_NAMES`

```zetasql
PROPERTY_NAMES(element)
```

**Description**

Gets the name of each property associated with a graph element and preserves
the original case of each name.

**Arguments**

+   `element`: A `GRAPH_ELEMENT` value.

**Details**

Returns `NULL` if `element` is `NULL`.

**Return type**

`ARRAY<STRING>`

**Examples**

```zetasql
GRAPH FinGraph
MATCH (n:Person|Account)
RETURN PROPERTY_NAMES(n) AS property_names, n.id

/*-----------------------------------------------+
 | label                                    | id |
 +-----------------------------------------------+
 | [create_time, id, is_blocked, nick_name] | 7  |
 | [create_time, id, is_blocked, nick_name] | 16 |
 | [create_time, id, is_blocked, nick_name] | 20 |
 | [birthday, city, country, id, name]      | 1  |
 | [birthday, city, country, id, name]      | 2  |
 | [birthday, city, country, id, name]      | 3  |
 +-----------------------------------------------*/
```

### `SOURCE_NODE_ID`

```zetasql
SOURCE_NODE_ID(edge_element)
```

**Description**

Gets a unique identifier of a graph edge's source node. The unique identifier is only valid for the scope of the query where it's obtained.

**Arguments**

+   `edge_element`: A `GRAPH_ELEMENT` value that represents an edge.

**Details**

Returns `NULL` if `edge_element` is `NULL`.

**Return type**

`STRING`

**Examples**

```zetasql
GRAPH FinGraph
MATCH (p:Person)-[o:Owns]->(:Account)
RETURN p.name AS name, SOURCE_NODE_ID(o) AS source_node_id

/*-------------------------------------+
 | name | source_node_id               |
 +------|------------------------------+
 | Alex | mUZpbkdyYXBoLlBlcnNvbgB4kQI= |
 | Dana | mUZpbkdyYXBoLlBlcnNvbgB4kQQ= |
 | Lee  | mUZpbkdyYXBoLlBlcnNvbgB4kQY= |
 +-------------------------------------*/
```

Note that the actual identifiers obtained may be different from what's shown above.

[functions-and-operators]: https://github.com/google/zetasql/blob/master/docs/functions-and-operators.md

## Geography functions

ZetaSQL supports geography functions.
Geography functions operate on or generate ZetaSQL
`GEOGRAPHY` values. The signature of most geography
functions starts with `ST_`. ZetaSQL supports the following functions
that can be used to analyze geographical data, determine spatial relationships
between geographical features, and construct or manipulate
`GEOGRAPHY`s.

All ZetaSQL geography functions return `NULL` if any input argument
is `NULL`.

### Categories

The geography functions are grouped into the following categories based on their
behavior:

<!-- disableFinding(LINK_ID) -->
<table>
  <thead>
    <tr>
      <td>Category</td>
      <td width='300px'>Functions</td>
      <td>Description</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Constructors</td>
      <td>
        <a href="#st_geogpoint"><code>ST_GEOGPOINT</code></a><br>
        <a href="#st_makeline"><code>ST_MAKELINE</code></a><br>
        <a href="#st_makepolygon"><code>ST_MAKEPOLYGON</code></a><br>
        <a href="#st_makepolygonoriented"><code>ST_MAKEPOLYGONORIENTED</code></a>
      </td>
      <td>
        Functions that build new
        geography values from coordinates
        or existing geographies.
      </td>
    </tr>
    <tr>
      <td>Parsers</td>
      <td>
        <a href="#st_geogfrom"><code>ST_GEOGFROM</code></a><br>
        <a href="#st_geogfromgeojson"><code>ST_GEOGFROMGEOJSON</code></a><br>
        <a href="#st_geogfromkml"><code>ST_GEOGFROMKML</code></a><br>
        <a href="#st_geogfromtext"><code>ST_GEOGFROMTEXT</code></a><br>
        <a href="#st_geogfromwkb"><code>ST_GEOGFROMWKB</code></a><br>
        <a href="#st_geogpointfromgeohash"><code>ST_GEOGPOINTFROMGEOHASH</code></a><br>
      </td>
      <td>
        Functions that create geographies
        from an external format such as
        <a href="https://en.wikipedia.org/wiki/Well-known_text">WKT</a> and
        <a href="https://en.wikipedia.org/wiki/GeoJSON">GeoJSON</a>.
      </td>
    </tr>
    <tr>
      <td>Formatters</td>
      <td>
        <a href="#st_asbinary"><code>ST_ASBINARY</code></a><br>
        <a href="#st_asgeojson"><code>ST_ASGEOJSON</code></a><br>
        <a href="#st_askml"><code>ST_ASKML</code></a><br>
        <a href="#st_astext"><code>ST_ASTEXT</code></a><br>
        <a href="#st_geohash"><code>ST_GEOHASH</code></a>
      </td>
      <td>
        Functions that export geographies
        to an external format such as WKT.
      </td>
    </tr>
    <tr>
      <td>Transformations</td>
      <td>
        <a href="#st_accum"><code>ST_ACCUM</code></a> (Aggregate)<br>
        <a href="#st_boundary"><code>ST_BOUNDARY</code></a><br>
        <a href="#st_buffer"><code>ST_BUFFER</code></a><br>
        <a href="#st_bufferwithtolerance"><code>ST_BUFFERWITHTOLERANCE</code></a><br>
        <a href="#st_centroid"><code>ST_CENTROID</code></a><br>
        <a href="#st_centroid_agg"><code>ST_CENTROID_AGG</code></a> (Aggregate)<br>
        <a href="#st_closestpoint"><code>ST_CLOSESTPOINT</code></a><br>
        <a href="#st_convexhull"><code>ST_CONVEXHULL</code></a><br>
        <a href="#st_difference"><code>ST_DIFFERENCE</code></a><br>
        <a href="#st_exteriorring"><code>ST_EXTERIORRING</code></a><br>
        <a href="#st_interiorrings"><code>ST_INTERIORRINGS</code></a><br>
        <a href="#st_intersection"><code>ST_INTERSECTION</code></a><br>
        <a href="#st_lineinterpolatepoint"><code>ST_LINEINTERPOLATEPOINT</code></a><br>
        <a href="#st_linesubstring"><code>ST_LINESUBSTRING</code></a><br>
        <a href="#st_simplify"><code>ST_SIMPLIFY</code></a><br>
        <a href="#st_snaptogrid"><code>ST_SNAPTOGRID</code></a><br>
        <a href="#st_union"><code>ST_UNION</code></a><br>
        <a href="#st_union_agg"><code>ST_UNION_AGG</code></a> (Aggregate)<br>
      </td>
      <td>
        Functions that generate a new
        geography based on input.
      </td>
    </tr>
    <tr>
      <td>Accessors</td>
      <td>
        <a href="#st_dimension"><code>ST_DIMENSION</code></a><br>
        <a href="#st_dump"><code>ST_DUMP</code></a><br>
        <a href="#st_dumppoints"><code>ST_DUMPPOINTS</code></a><br>
        <a href="#st_endpoint"><code>ST_ENDPOINT</code></a><br>
        <a href="#st_geometrytype"><code>ST_GEOMETRYTYPE</code></a><br>
        <a href="#st_isclosed"><code>ST_ISCLOSED</code></a><br>
        <a href="#st_iscollection"><code>ST_ISCOLLECTION</code></a><br>
        <a href="#st_isempty"><code>ST_ISEMPTY</code></a><br>
        <a href="#st_isring"><code>ST_ISRING</code></a><br>
        <a href="#st_npoints"><code>ST_NPOINTS</code></a><br>
        <a href="#st_numgeometries"><code>ST_NUMGEOMETRIES</code></a><br>
        <a href="#st_numpoints"><code>ST_NUMPOINTS</code></a><br>
        <a href="#st_pointn"><code>ST_POINTN</code></a><br>
        <a href="#st_startpoint"><code>ST_STARTPOINT</code></a><br>
        <a href="#st_x"><code>ST_X</code></a><br>
        <a href="#st_y"><code>ST_Y</code></a><br>
      </td>
      <td>
        Functions that provide access to
        properties of a geography without
        side-effects.
      </td>
    </tr>
    <tr>
      <td>Predicates</td>
      <td>
        <a href="#st_contains"><code>ST_CONTAINS</code></a><br>
        <a href="#st_coveredby"><code>ST_COVEREDBY</code></a><br>
        <a href="#st_covers"><code>ST_COVERS</code></a><br>
        <a href="#st_disjoint"><code>ST_DISJOINT</code></a><br>
        <a href="#st_dwithin"><code>ST_DWITHIN</code></a><br>
        <a href="#st_equals"><code>ST_EQUALS</code></a><br>
        <a href="#st_hausdorffdwithin"><code>ST_HAUSDORFFDWITHIN</code></a><br>
        <a href="#st_intersects"><code>ST_INTERSECTS</code></a><br>
        <a href="#st_intersectsbox"><code>ST_INTERSECTSBOX</code></a><br>
        <a href="#st_touches"><code>ST_TOUCHES</code></a><br>
        <a href="#st_within"><code>ST_WITHIN</code></a><br>
      </td>
      <td>
        Functions that return <code>TRUE</code> or
        <code>FALSE</code> for some spatial
        relationship between two
        geographies or some property of
        a geography. These functions
        are commonly used in filter
        clauses.
      </td>
    </tr>
    <tr>
      <td>Measures</td>
      <td>
        <a href="#st_angle"><code>ST_ANGLE</code></a><br>
        <a href="#st_area"><code>ST_AREA</code></a><br>
        <a href="#st_azimuth"><code>ST_AZIMUTH</code></a><br>
        <a href="#st_boundingbox"><code>ST_BOUNDINGBOX</code></a><br>
        <a href="#st_distance"><code>ST_DISTANCE</code></a><br>
        <a href="#st_extent"><code>ST_EXTENT</code></a> (Aggregate)<br>
        <a href="#st_hausdorffdistance"><code>ST_HAUSDORFFDISTANCE</code></a><br>
        <a href="#st_linelocatepoint"><code>ST_LINELOCATEPOINT</code></a><br>
        <a href="#st_length"><code>ST_LENGTH</code></a><br>
        <a href="#st_maxdistance"><code>ST_MAXDISTANCE</code></a><br>
        <a href="#st_perimeter"><code>ST_PERIMETER</code></a><br>
      </td>
      <td>
        Functions that compute measurements
        of one or more geographies.
      </td>
    </tr>
    
    <tr>
      <td>Clustering</td>
      <td>
        <a href="#st_clusterdbscan"><code>ST_CLUSTERDBSCAN</code></a>
      </td>
      <td>
        Functions that perform clustering on geographies.
      </td>
    </tr>
    
    
    <tr>
      <td>S2 functions</td>
      <td>
        <a href="#s2_cellidfrompoint"><code>S2_CELLIDFROMPOINT</code></a><br>
        <a href="#s2_coveringcellids"><code>S2_COVERINGCELLIDS</code></a><br>
      </td>
      <td>
        Functions for working with S2 cell coverings of GEOGRAPHY.
      </td>
    </tr>
    
  </tbody>
</table>
<!-- enableFinding(LINK_ID) -->

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#s2_cellidfrompoint"><code>S2_CELLIDFROMPOINT</code></a>
</td>
  <td>
    Gets the S2 cell ID covering a point <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#s2_coveringcellids"><code>S2_COVERINGCELLIDS</code></a>
</td>
  <td>
    Gets an array of S2 cell IDs that cover a <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_accum"><code>ST_ACCUM</code></a>
</td>
  <td>
    Aggregates <code>GEOGRAPHY</code> values into an array of
    <code>GEOGRAPHY</code> elements.
  </td>
</tr>

<tr>
  <td><a href="#st_angle"><code>ST_ANGLE</code></a>
</td>
  <td>
    Takes three point <code>GEOGRAPHY</code> values, which represent two
    intersecting lines, and returns the angle between these lines.
  </td>
</tr>

<tr>
  <td><a href="#st_area"><code>ST_AREA</code></a>
</td>
  <td>
    Gets the area covered by the polygons in a <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_asbinary"><code>ST_ASBINARY</code></a>
</td>
  <td>
    Converts a <code>GEOGRAPHY</code> value to a
    <code>BYTES</code> WKB geography value.
  </td>
</tr>

<tr>
  <td><a href="#st_asgeojson"><code>ST_ASGEOJSON</code></a>
</td>
  <td>
    Converts a <code>GEOGRAPHY</code> value to a <code>STRING</code>
    GeoJSON geography value.
  </td>
</tr>

<tr>
  <td><a href="#st_askml"><code>ST_ASKML</code></a>
</td>
  <td>
    Converts a <code>GEOGRAPHY</code> value to a <code>STRING</code>
    KML geometry value.
  </td>
</tr>

<tr>
  <td><a href="#st_astext"><code>ST_ASTEXT</code></a>
</td>
  <td>
    Converts a <code>GEOGRAPHY</code> value to a
    <code>STRING</code> WKT geography value.
  </td>
</tr>

<tr>
  <td><a href="#st_azimuth"><code>ST_AZIMUTH</code></a>
</td>
  <td>
    Gets the azimuth of a line segment formed by two
    point <code>GEOGRAPHY</code> values.
  </td>
</tr>

<tr>
  <td><a href="#st_boundary"><code>ST_BOUNDARY</code></a>
</td>
  <td>
    Gets the union of component boundaries in a
    <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_boundingbox"><code>ST_BOUNDINGBOX</code></a>
</td>
  <td>
    Gets the bounding box for a <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_buffer"><code>ST_BUFFER</code></a>
</td>
  <td>
    Gets the buffer around a <code>GEOGRAPHY</code> value, using a specific
    number of segments.
  </td>
</tr>

<tr>
  <td><a href="#st_bufferwithtolerance"><code>ST_BUFFERWITHTOLERANCE</code></a>
</td>
  <td>
    Gets the buffer around a <code>GEOGRAPHY</code> value, using tolerance.
  </td>
</tr>

<tr>
  <td><a href="#st_centroid"><code>ST_CENTROID</code></a>
</td>
  <td>
    Gets the centroid of a <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_closestpoint"><code>ST_CLOSESTPOINT</code></a>
</td>
  <td>
    Gets the point on a <code>GEOGRAPHY</code> value which is closest to any
    point in a second <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_clusterdbscan"><code>ST_CLUSTERDBSCAN</code></a>
</td>
  <td>
    Performs DBSCAN clustering on a group of <code>GEOGRAPHY</code> values and
    produces a 0-based cluster number for this row.
    
  </td>
</tr>

<tr>
  <td><a href="#st_contains"><code>ST_CONTAINS</code></a>
</td>
  <td>
    Checks if one <code>GEOGRAPHY</code> value contains another
    <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_convexhull"><code>ST_CONVEXHULL</code></a>
</td>
  <td>
    Returns the convex hull for a <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_coveredby"><code>ST_COVEREDBY</code></a>
</td>
  <td>
    Checks if all points of a <code>GEOGRAPHY</code> value are on the boundary
    or interior of another <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_covers"><code>ST_COVERS</code></a>
</td>
  <td>
    Checks if all points of a <code>GEOGRAPHY</code> value are on the boundary
    or interior of another <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_difference"><code>ST_DIFFERENCE</code></a>
</td>
  <td>
    Gets the point set difference between two <code>GEOGRAPHY</code> values.
  </td>
</tr>

<tr>
  <td><a href="#st_dimension"><code>ST_DIMENSION</code></a>
</td>
  <td>
    Gets the dimension of the highest-dimensional element in a
    <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_disjoint"><code>ST_DISJOINT</code></a>
</td>
  <td>
    Checks if two <code>GEOGRAPHY</code> values are disjoint (don't intersect).
  </td>
</tr>

<tr>
  <td><a href="#st_distance"><code>ST_DISTANCE</code></a>
</td>
  <td>
    Gets the shortest distance in meters between two <code>GEOGRAPHY</code>
    values.
  </td>
</tr>

<tr>
  <td><a href="#st_dump"><code>ST_DUMP</code></a>
</td>
  <td>
    Returns an array of simple <code>GEOGRAPHY</code> components in a
    <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_dumppoints"><code>ST_DUMPPOINTS</code></a>
</td>
  <td>
    Produces an array of <code>GEOGRAPHY</code> points with all points, line
    vertices, and polygon vertices in a <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_dwithin"><code>ST_DWITHIN</code></a>
</td>
  <td>
    Checks if any points in two <code>GEOGRAPHY</code> values are within a given
    distance.
  </td>
</tr>

<tr>
  <td><a href="#st_endpoint"><code>ST_ENDPOINT</code></a>
</td>
  <td>
    Gets the last point of a linestring <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_equals"><code>ST_EQUALS</code></a>
</td>
  <td>
    Checks if two <code>GEOGRAPHY</code> values represent the same
    <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_extent"><code>ST_EXTENT</code></a>
</td>
  <td>
    Gets the bounding box for a group of <code>GEOGRAPHY</code> values.
    
  </td>
</tr>

<tr>
  <td><a href="#st_exteriorring"><code>ST_EXTERIORRING</code></a>
</td>
  <td>
    Returns a linestring <code>GEOGRAPHY</code> value that corresponds to the
    outermost ring of a polygon <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_geogfrom"><code>ST_GEOGFROM</code></a>
</td>
  <td>
    Converts a <code>STRING</code> or <code>BYTES</code> value
    into a <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_geogfromgeojson"><code>ST_GEOGFROMGEOJSON</code></a>
</td>
  <td>
    Converts a <code>STRING</code> GeoJSON geometry value into a
    <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_geogfromkml"><code>ST_GEOGFROMKML</code></a>
</td>
  <td>
    Converts a <code>STRING</code> KML geometry value into a
    <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_geogfromtext"><code>ST_GEOGFROMTEXT</code></a>
</td>
  <td>
    Converts a <code>STRING</code> WKT geometry value into a
    <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_geogfromwkb"><code>ST_GEOGFROMWKB</code></a>
</td>
  <td>
    Converts a <code>BYTES</code> or hexadecimal-text <code>STRING</code> WKT
    geometry value into a <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_geogpoint"><code>ST_GEOGPOINT</code></a>
</td>
  <td>
    Creates a point <code>GEOGRAPHY</code> value for a given longitude and
    latitude.
  </td>
</tr>

<tr>
  <td><a href="#st_geogpointfromgeohash"><code>ST_GEOGPOINTFROMGEOHASH</code></a>
</td>
  <td>
    Gets a point <code>GEOGRAPHY</code> value that's in the middle of a
    bounding box defined in a <code>STRING</code> GeoHash value.
  </td>
</tr>

<tr>
  <td><a href="#st_geohash"><code>ST_GEOHASH</code></a>
</td>
  <td>
    Converts a point <code>GEOGRAPHY</code> value to a <code>STRING</code>
    GeoHash value.
  </td>
</tr>

<tr>
  <td><a href="#st_geometrytype"><code>ST_GEOMETRYTYPE</code></a>
</td>
  <td>
    Gets the Open Geospatial Consortium (OGC) geometry type for a
    <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_hausdorffdistance"><code>ST_HAUSDORFFDISTANCE</code></a>
</td>
  <td>Gets the discrete Hausdorff distance between two geometries.</td>
</tr>

<tr>
  <td><a href="#st_hausdorffdwithin"><code>ST_HAUSDORFFDWITHIN</code></a>
</td>
  <td>
    Checks if the Hausdorff distance between two <code>GEOGRAPHY</code> values
    is within a given distance.
  </td>
</tr>

<tr>
  <td><a href="#st_interiorrings"><code>ST_INTERIORRINGS</code></a>
</td>
  <td>
    Gets the interior rings of a polygon <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_intersection"><code>ST_INTERSECTION</code></a>
</td>
  <td>
    Gets the point set intersection of two <code>GEOGRAPHY</code> values.
  </td>
</tr>

<tr>
  <td><a href="#st_intersects"><code>ST_INTERSECTS</code></a>
</td>
  <td>
    Checks if at least one point appears in two <code>GEOGRAPHY</code>
    values.
  </td>
</tr>

<tr>
  <td><a href="#st_intersectsbox"><code>ST_INTERSECTSBOX</code></a>
</td>
  <td>
    Checks if a <code>GEOGRAPHY</code> value intersects a rectangle.
  </td>
</tr>

<tr>
  <td><a href="#st_isclosed"><code>ST_ISCLOSED</code></a>
</td>
  <td>
    Checks if all components in a <code>GEOGRAPHY</code> value are closed.
  </td>
</tr>

<tr>
  <td><a href="#st_iscollection"><code>ST_ISCOLLECTION</code></a>
</td>
  <td>
    Checks if the total number of points, linestrings, and polygons is
    greater than one in a <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_isempty"><code>ST_ISEMPTY</code></a>
</td>
  <td>
    Checks if a <code>GEOGRAPHY</code> value is empty.
  </td>
</tr>

<tr>
  <td><a href="#st_isring"><code>ST_ISRING</code></a>
</td>
  <td>
    Checks if a <code>GEOGRAPHY</code> value is a closed, simple
    linestring.
  </td>
</tr>

<tr>
  <td><a href="#st_length"><code>ST_LENGTH</code></a>
</td>
  <td>
    Gets the total length of lines in a <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_lineinterpolatepoint"><code>ST_LINEINTERPOLATEPOINT</code></a>
</td>
  <td>
    Gets a point at a specific fraction in a linestring <code>GEOGRAPHY</code>
    value.
  </td>
</tr>

<tr>
  <td><a href="#st_linelocatepoint"><code>ST_LINELOCATEPOINT</code></a>
</td>
  <td>
    Gets a section of a linestring <code>GEOGRAPHY</code> value between the
    start point and a point <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_linesubstring"><code>ST_LINESUBSTRING</code></a>
</td>
  <td>
    Gets a segment of a single linestring at a specific starting and
    ending fraction.
  </td>
</tr>

<tr>
  <td><a href="#st_makeline"><code>ST_MAKELINE</code></a>
</td>
  <td>
    Creates a linestring <code>GEOGRAPHY</code> value by concatenating the point
    and linestring vertices of <code>GEOGRAPHY</code> values.
  </td>
</tr>

<tr>
  <td><a href="#st_makepolygon"><code>ST_MAKEPOLYGON</code></a>
</td>
  <td>
    Constructs a polygon <code>GEOGRAPHY</code> value by combining
    a polygon shell with polygon holes.
  </td>
</tr>

<tr>
  <td><a href="#st_makepolygonoriented"><code>ST_MAKEPOLYGONORIENTED</code></a>
</td>
  <td>
    Constructs a polygon <code>GEOGRAPHY</code> value, using an array of
    linestring <code>GEOGRAPHY</code> values. The vertex ordering of each
    linestring determines the orientation of each polygon ring.
  </td>
</tr>

<tr>
  <td><a href="#st_maxdistance"><code>ST_MAXDISTANCE</code></a>
</td>
  <td>
    Gets the longest distance between two non-empty
    <code>GEOGRAPHY</code> values.
  </td>
</tr>

<tr>
  <td><a href="#st_npoints"><code>ST_NPOINTS</code></a>
</td>
  <td>
    An alias of <code>ST_NUMPOINTS</code>.
  </td>
</tr>

<tr>
  <td><a href="#st_numgeometries"><code>ST_NUMGEOMETRIES</code></a>
</td>
  <td>
    Gets the number of geometries in a <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_numpoints"><code>ST_NUMPOINTS</code></a>
</td>
  <td>
    Gets the number of vertices in the a <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_perimeter"><code>ST_PERIMETER</code></a>
</td>
  <td>
    Gets the length of the boundary of the polygons in a
    <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_pointn"><code>ST_POINTN</code></a>
</td>
  <td>
    Gets the point at a specific index of a linestring <code>GEOGRAPHY</code>
    value.
  </td>
</tr>

<tr>
  <td><a href="#st_simplify"><code>ST_SIMPLIFY</code></a>
</td>
  <td>
    Converts a <code>GEOGRAPHY</code> value into a simplified
    <code>GEOGRAPHY</code> value, using tolerance.
  </td>
</tr>

<tr>
  <td><a href="#st_snaptogrid"><code>ST_SNAPTOGRID</code></a>
</td>
  <td>
    Produces a <code>GEOGRAPHY</code> value, where each vertex has
    been snapped to a longitude/latitude grid.
  </td>
</tr>

<tr>
  <td><a href="#st_startpoint"><code>ST_STARTPOINT</code></a>
</td>
  <td>
    Gets the first point of a linestring <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_touches"><code>ST_TOUCHES</code></a>
</td>
  <td>
    Checks if two <code>GEOGRAPHY</code> values intersect and their interiors
    have no elements in common.
  </td>
</tr>

<tr>
  <td><a href="#st_union"><code>ST_UNION</code></a>
</td>
  <td>
    Gets the point set union of multiple <code>GEOGRAPHY</code> values.
  </td>
</tr>

<tr>
  <td><a href="#st_union_agg"><code>ST_UNION_AGG</code></a>
</td>
  <td>
    Aggregates over <code>GEOGRAPHY</code> values and gets their
    point set union.
    
  </td>
</tr>

<tr>
  <td><a href="#st_within"><code>ST_WITHIN</code></a>
</td>
  <td>
    Checks if one <code>GEOGRAPHY</code> value contains another
    <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_x"><code>ST_X</code></a>
</td>
  <td>
    Gets the longitude from a point <code>GEOGRAPHY</code> value.
  </td>
</tr>

<tr>
  <td><a href="#st_y"><code>ST_Y</code></a>
</td>
  <td>
    Gets the latitude from a point <code>GEOGRAPHY</code> value.
  </td>
</tr>

  </tbody>
</table>

### `S2_CELLIDFROMPOINT`

```zetasql
S2_CELLIDFROMPOINT(point_geography[, level => cell_level])
```

**Description**

Returns the [S2 cell ID][s2-cells-link] covering a point `GEOGRAPHY`.

+ The optional `INT64` parameter `level` specifies the S2 cell level for the
  returned cell. Naming this argument is optional.

This is advanced functionality for interoperability with systems utilizing the
[S2 Geometry Library][s2-root-link].

**Constraints**

+ Returns the cell ID as a signed `INT64` bit-equivalent to
  [unsigned 64-bit integer representation][s2-cells-link].
+ Can return negative cell IDs.
+ Valid S2 cell levels are 0 to 30.
+ `level` defaults to 30 if not explicitly specified.
+ The function only supports a single point GEOGRAPHY. Use the `SAFE` prefix if
  the input can be multipoint, linestring, polygon, or an empty `GEOGRAPHY`.
+ To compute the covering of a complex `GEOGRAPHY`, use
  [S2_COVERINGCELLIDS][s2-coveringcellids].

**Return type**

`INT64`

**Example**

```zetasql
WITH data AS (
  SELECT 1 AS id, ST_GEOGPOINT(-122, 47) AS geo
  UNION ALL
  -- empty geography isn't supported
  SELECT 2 AS id, ST_GEOGFROMTEXT('POINT EMPTY') AS geo
  UNION ALL
  -- only points are supported
  SELECT 3 AS id, ST_GEOGFROMTEXT('LINESTRING(1 2, 3 4)') AS geo
)
SELECT id,
       SAFE.S2_CELLIDFROMPOINT(geo) cell30,
       SAFE.S2_CELLIDFROMPOINT(geo, level => 10) cell10
FROM data;

/*----+---------------------+---------------------*
 | id | cell30              | cell10              |
 +----+---------------------+---------------------+
 | 1  | 6093613931972369317 | 6093613287902019584 |
 | 2  | NULL                | NULL                |
 | 3  | NULL                | NULL                |
 *----+---------------------+---------------------*/
```

[s2-cells-link]: https://s2geometry.io/devguide/s2cell_hierarchy

[s2-root-link]: https://s2geometry.io/

[s2-coveringcellids]: #s2_coveringcellids

### `S2_COVERINGCELLIDS`

```zetasql
S2_COVERINGCELLIDS(
    geography
    [, min_level => cell_level]
    [, max_level => cell_level]
    [, max_cells => max_cells]
    [, buffer => buffer])
```

**Description**

Returns an array of [S2 cell IDs][s2-cells-link] that cover the input
`GEOGRAPHY`. The function returns at most `max_cells` cells. The optional
arguments `min_level` and `max_level` specify minimum and maximum levels for
returned S2 cells. The array size is limited by the optional `max_cells`
argument. The optional `buffer` argument specifies a buffering factor in
meters; the region being covered is expanded from the extent of the
input geography by this amount.

This is advanced functionality for interoperability with systems utilizing the
[S2 Geometry Library][s2-root-link].

**Constraints**

+ Returns the cell ID as a signed `INT64` bit-equivalent to
  [unsigned 64-bit integer representation][s2-cells-link].
+ Can return negative cell IDs.
+ Valid S2 cell levels are 0 to 30.
+ `max_cells` defaults to 8 if not explicitly specified.
+ `buffer` should be nonnegative. It defaults to 0.0 meters if not explicitly
  specified.

**Return type**

`ARRAY<INT64>`

**Example**

```zetasql
WITH data AS (
  SELECT 1 AS id, ST_GEOGPOINT(-122, 47) AS geo
  UNION ALL
  SELECT 2 AS id, ST_GEOGFROMTEXT('POINT EMPTY') AS geo
  UNION ALL
  SELECT 3 AS id, ST_GEOGFROMTEXT('LINESTRING(-122.12 47.67, -122.19 47.69)') AS geo
)
SELECT id, S2_COVERINGCELLIDS(geo, min_level => 12) cells
FROM data;

/*----+--------------------------------------------------------------------------------------*
 | id | cells                                                                                |
 +----+--------------------------------------------------------------------------------------+
 | 1  | [6093613931972369317]                                                                |
 | 2  | []                                                                                   |
 | 3  | [6093384954555662336, 6093390709811838976, 6093390735581642752, 6093390740145045504, |
 |    |  6093390791416217600, 6093390812891054080, 6093390817187069952, 6093496378892222464] |
 *----+--------------------------------------------------------------------------------------*/
```

[s2-cells-link]: https://s2geometry.io/devguide/s2cell_hierarchy

[s2-root-link]: https://s2geometry.io/

### `ST_ACCUM`

```zetasql
ST_ACCUM(geography)
```

**Description**

Takes a `GEOGRAPHY` and returns an array of
`GEOGRAPHY` elements.
This function is identical to [ARRAY_AGG][geography-link-array-agg],
but only applies to `GEOGRAPHY` objects.

**Return type**

`ARRAY<GEOGRAPHY>`

[geography-link-array-agg]: #array_agg

### `ST_ANGLE`

```zetasql
ST_ANGLE(point_geography_1, point_geography_2, point_geography_3)
```

**Description**

Takes three point `GEOGRAPHY` values, which represent two intersecting lines.
Returns the angle between these lines. Point 2 and point 1 represent the first
line and point 2 and point 3 represent the second line. The angle between
these lines is in radians, in the range `[0, 2pi)`. The angle is measured
clockwise from the first line to the second line.

`ST_ANGLE` has the following edge cases:

+ If points 2 and 3 are the same, returns `NULL`.
+ If points 2 and 1 are the same, returns `NULL`.
+ If points 2 and 3 are exactly antipodal, returns `NULL`.
+ If points 2 and 1 are exactly antipodal, returns `NULL`.
+ If any of the input geographies aren't single points or are the empty
  geography, then throws an error.

**Return type**

`DOUBLE`

**Example**

```zetasql
WITH geos AS (
  SELECT 1 id, ST_GEOGPOINT(1, 0) geo1, ST_GEOGPOINT(0, 0) geo2, ST_GEOGPOINT(0, 1) geo3 UNION ALL
  SELECT 2 id, ST_GEOGPOINT(0, 0), ST_GEOGPOINT(1, 0), ST_GEOGPOINT(0, 1) UNION ALL
  SELECT 3 id, ST_GEOGPOINT(1, 0), ST_GEOGPOINT(0, 0), ST_GEOGPOINT(1, 0) UNION ALL
  SELECT 4 id, ST_GEOGPOINT(1, 0) geo1, ST_GEOGPOINT(0, 0) geo2, ST_GEOGPOINT(0, 0) geo3 UNION ALL
  SELECT 5 id, ST_GEOGPOINT(0, 0), ST_GEOGPOINT(-30, 0), ST_GEOGPOINT(150, 0) UNION ALL
  SELECT 6 id, ST_GEOGPOINT(0, 0), NULL, NULL UNION ALL
  SELECT 7 id, NULL, ST_GEOGPOINT(0, 0), NULL UNION ALL
  SELECT 8 id, NULL, NULL, ST_GEOGPOINT(0, 0))
SELECT ST_ANGLE(geo1,geo2,geo3) AS angle FROM geos ORDER BY id;

/*---------------------*
 | angle               |
 +---------------------+
 | 4.71238898038469    |
 | 0.78547432161873854 |
 | 0                   |
 | NULL                |
 | NULL                |
 | NULL                |
 | NULL                |
 | NULL                |
 *---------------------*/
```

### `ST_AREA`

```zetasql
ST_AREA(geography_expression[, use_spheroid])
```

**Description**

Returns the area in square meters covered by the polygons in the input
`GEOGRAPHY`.

If `geography_expression` is a point or a line, returns zero. If
`geography_expression` is a collection, returns the area of the polygons in the
collection; if the collection doesn't contain polygons, returns zero.

The optional `use_spheroid` parameter determines how this function measures
distance. If `use_spheroid` is `FALSE`, the function measures distance on the
surface of a perfect sphere.

The `use_spheroid` parameter currently only supports
the value `FALSE`. The default value of `use_spheroid` is `FALSE`.

**Return type**

`DOUBLE`

[wgs84-link]: https://en.wikipedia.org/wiki/World_Geodetic_System

### `ST_ASBINARY`

```zetasql
ST_ASBINARY(geography_expression)
```

**Description**

Returns the [WKB][wkb-link] representation of an input
`GEOGRAPHY`.

See [`ST_GEOGFROMWKB`][st-geogfromwkb] to construct a
`GEOGRAPHY` from WKB.

**Return type**

`BYTES`

[wkb-link]: https://en.wikipedia.org/wiki/Well-known_text#Well-known_binary

[st-geogfromwkb]: #st_geogfromwkb

### `ST_ASGEOJSON`

```zetasql
ST_ASGEOJSON(geography_expression)
```

**Description**

Returns the [RFC 7946][GeoJSON-spec-link] compliant [GeoJSON][geojson-link]
representation of the input `GEOGRAPHY`.

A ZetaSQL `GEOGRAPHY` has spherical
geodesic edges, whereas a GeoJSON `Geometry` object explicitly has planar edges.
To convert between these two types of edges, ZetaSQL adds additional
points to the line where necessary so that the resulting sequence of edges
remains within 10 meters of the original edge.

See [`ST_GEOGFROMGEOJSON`][st-geogfromgeojson] to construct a
`GEOGRAPHY` from GeoJSON.

**Return type**

`STRING`

[geojson-spec-link]: https://tools.ietf.org/html/rfc7946

[geojson-link]: https://en.wikipedia.org/wiki/GeoJSON

[st-geogfromgeojson]: #st_geogfromgeojson

### `ST_ASKML`

```zetasql
ST_ASKML(geography)
```

**Description**

Takes a `GEOGRAPHY` and returns a `STRING` [KML geometry][kml-geometry-link].
Coordinates are formatted with as few digits as possible without loss
of precision.

**Return type**

`STRING`

[kml-geometry-link]: https://developers.google.com/kml/documentation/kmlreference#geometry

### `ST_ASTEXT`

```zetasql
ST_ASTEXT(geography_expression)
```

**Description**

Returns the [WKT][wkt-link] representation of an input
`GEOGRAPHY`.

See [`ST_GEOGFROMTEXT`][st-geogfromtext] to construct a
`GEOGRAPHY` from WKT.

**Return type**

`STRING`

[wkt-link]: https://en.wikipedia.org/wiki/Well-known_text

[st-geogfromtext]: #st_geogfromtext

### `ST_AZIMUTH`

```zetasql
ST_AZIMUTH(point_geography_1, point_geography_2)
```

**Description**

Takes two point `GEOGRAPHY` values, and returns the azimuth of the line segment
formed by points 1 and 2. The azimuth is the angle in radians measured between
the line from point 1 facing true North to the line segment from point 1 to
point 2.

The positive angle is measured clockwise on the surface of a sphere. For
example, the azimuth for a line segment:

+   Pointing North is `0`
+   Pointing East is `PI/2`
+   Pointing South is `PI`
+   Pointing West is `3PI/2`

`ST_AZIMUTH` has the following edge cases:

+   If the two input points are the same, returns `NULL`.
+   If the two input points are exactly antipodal, returns `NULL`.
+   If either of the input geographies aren't single points or are the empty
    geography, throws an error.

**Return type**

`DOUBLE`

**Example**

```zetasql
WITH geos AS (
  SELECT 1 id, ST_GEOGPOINT(1, 0) AS geo1, ST_GEOGPOINT(0, 0) AS geo2 UNION ALL
  SELECT 2, ST_GEOGPOINT(0, 0), ST_GEOGPOINT(1, 0) UNION ALL
  SELECT 3, ST_GEOGPOINT(0, 0), ST_GEOGPOINT(0, 1) UNION ALL
  -- identical
  SELECT 4, ST_GEOGPOINT(0, 0), ST_GEOGPOINT(0, 0) UNION ALL
  -- antipode
  SELECT 5, ST_GEOGPOINT(-30, 0), ST_GEOGPOINT(150, 0) UNION ALL
  -- nulls
  SELECT 6, ST_GEOGPOINT(0, 0), NULL UNION ALL
  SELECT 7, NULL, ST_GEOGPOINT(0, 0))
SELECT ST_AZIMUTH(geo1, geo2) AS azimuth FROM geos ORDER BY id;

/*--------------------*
 | azimuth            |
 +--------------------+
 | 4.71238898038469   |
 | 1.5707963267948966 |
 | 0                  |
 | NULL               |
 | NULL               |
 | NULL               |
 | NULL               |
 *--------------------*/
```

### `ST_BOUNDARY`

```zetasql
ST_BOUNDARY(geography_expression)
```

**Description**

Returns a single `GEOGRAPHY` that contains the union
of the boundaries of each component in the given input
`GEOGRAPHY`.

The boundary of each component of a `GEOGRAPHY` is
defined as follows:

+   The boundary of a point is empty.
+   The boundary of a linestring consists of the endpoints of the linestring.
+   The boundary of a polygon consists of the linestrings that form the polygon
    shell and each of the polygon's holes.

**Return type**

`GEOGRAPHY`

### `ST_BOUNDINGBOX`

```zetasql
ST_BOUNDINGBOX(geography_expression)
```

**Description**

Returns a `STRUCT` that represents the bounding box for the specified geography.
The bounding box is the minimal rectangle that encloses the geography. The edges
of the rectangle follow constant lines of longitude and latitude.

Caveats:

+ Returns `NULL` if the input is `NULL` or an empty geography.
+ The bounding box might cross the antimeridian if this allows for a smaller
  rectangle. In this case, the bounding box has one of its longitudinal bounds
  outside of the [-180, 180] range, so that `xmin` is smaller than the eastmost
  value `xmax`.

**Return type**

`STRUCT<xmin DOUBLE, ymin DOUBLE, xmax DOUBLE, ymax DOUBLE>`.

Bounding box parts:

+ `xmin`: The westmost constant longitude line that bounds the rectangle.
+ `xmax`: The eastmost constant longitude line that bounds the rectangle.
+ `ymin`: The minimum constant latitude line that bounds the rectangle.
+ `ymax`: The maximum constant latitude line that bounds the rectangle.

**Example**

```zetasql
WITH data AS (
  SELECT 1 id, ST_GEOGFROMTEXT('POLYGON((-125 48, -124 46, -117 46, -117 49, -125 48))') g
  UNION ALL
  SELECT 2 id, ST_GEOGFROMTEXT('POLYGON((172 53, -130 55, -141 70, 172 53))') g
  UNION ALL
  SELECT 3 id, ST_GEOGFROMTEXT('POINT EMPTY') g
  UNION ALL
  SELECT 4 id, ST_GEOGFROMTEXT('POLYGON((172 53, -141 70, -130 55, 172 53))', oriented => TRUE)
)
SELECT id, ST_BOUNDINGBOX(g) AS box
FROM data

/*----+------------------------------------------*
 | id | box                                      |
 +----+------------------------------------------+
 | 1  | {xmin:-125, ymin:46, xmax:-117, ymax:49} |
 | 2  | {xmin:172, ymin:53, xmax:230, ymax:70}   |
 | 3  | NULL                                     |
 | 4  | {xmin:-180, ymin:-90, xmax:180, ymax:90} |
 *----+------------------------------------------*/
```

See [`ST_EXTENT`][st-extent] for the aggregate version of `ST_BOUNDINGBOX`.

[st-extent]: #st_extent

### `ST_BUFFER`

```zetasql
ST_BUFFER(
    geography,
    buffer_radius
    [, num_seg_quarter_circle => num_segments]
    [, use_spheroid => boolean_expression]
    [, endcap => endcap_style]
    [, side => line_side])
```

**Description**

Returns a `GEOGRAPHY` that represents the buffer around the input `GEOGRAPHY`.
This function is similar to [`ST_BUFFERWITHTOLERANCE`][st-bufferwithtolerance],
but you specify the number of segments instead of providing tolerance to
determine how much the resulting geography can deviate from the ideal
buffer radius.

+   `geography`: The input `GEOGRAPHY` to encircle with the buffer radius.
+   `buffer_radius`: `DOUBLE` that represents the radius of the
    buffer around the input geography. The radius is in meters. Note that
    polygons contract when buffered with a negative `buffer_radius`. Polygon
    shells and holes that are contracted to a point are discarded.
+   `num_seg_quarter_circle`: (Optional) `DOUBLE` specifies the
    number of segments that are used to approximate a quarter circle. The
    default value is `8.0`. Naming this argument is optional.
+   `endcap`: (Optional) `STRING` allows you to specify one of two endcap
    styles: `ROUND` and `FLAT`. The default value is `ROUND`. This option only
    affects the endcaps of buffered linestrings.
+   `side`: (Optional) `STRING` allows you to specify one of three possibilities
    for lines: `BOTH`, `LEFT`, and `RIGHT`. The default is `BOTH`. This option
    only affects how linestrings are buffered.
+   `use_spheroid`: (Optional) `BOOL` determines how this function measures
    distance. If `use_spheroid` is `FALSE`, the function measures distance on
    the surface of a perfect sphere. The `use_spheroid` parameter
    currently only supports the value `FALSE`. The default value of
    `use_spheroid` is `FALSE`.

**Return type**

Polygon `GEOGRAPHY`

**Example**

The following example shows the result of `ST_BUFFER` on a point. A buffered
point is an approximated circle. When `num_seg_quarter_circle = 2`, there are
two line segments in a quarter circle, and therefore the buffered circle has
eight sides and [`ST_NUMPOINTS`][st-numpoints] returns nine vertices. When
`num_seg_quarter_circle = 8`, there are eight line segments in a quarter circle,
and therefore the buffered circle has thirty-two sides and
[`ST_NUMPOINTS`][st-numpoints] returns thirty-three vertices.

```zetasql
SELECT
  -- num_seg_quarter_circle=2
  ST_NUMPOINTS(ST_BUFFER(ST_GEOGFROMTEXT('POINT(1 2)'), 50, 2)) AS eight_sides,
  -- num_seg_quarter_circle=8, since 8 is the default
  ST_NUMPOINTS(ST_BUFFER(ST_GEOGFROMTEXT('POINT(100 2)'), 50)) AS thirty_two_sides;

/*-------------+------------------*
 | eight_sides | thirty_two_sides |
 +-------------+------------------+
 | 9           | 33               |
 *-------------+------------------*/
```

[wgs84-link]: https://en.wikipedia.org/wiki/World_Geodetic_System

[st-bufferwithtolerance]: #st_bufferwithtolerance

[st-numpoints]: #st_numpoints

### `ST_BUFFERWITHTOLERANCE`

```zetasql
ST_BUFFERWITHTOLERANCE(
    geography,
    buffer_radius,
    tolerance_meters => tolerance
    [, use_spheroid => boolean_expression]
    [, endcap => endcap_style]
    [, side => line_side])
```

Returns a `GEOGRAPHY` that represents the buffer around the input `GEOGRAPHY`.
This function is similar to [`ST_BUFFER`][st-buffer],
but you provide tolerance instead of segments to determine how much the
resulting geography can deviate from the ideal buffer radius.

+   `geography`: The input `GEOGRAPHY` to encircle with the buffer radius.
+   `buffer_radius`: `DOUBLE` that represents the radius of the
    buffer around the input geography. The radius is in meters. Note that
    polygons contract when buffered with a negative `buffer_radius`. Polygon
    shells and holes that are contracted to a point are discarded.
+   `tolerance_meters`: `DOUBLE` specifies a tolerance in
    meters with which the shape is approximated. Tolerance determines how much a
    polygon can deviate from the ideal radius. Naming this argument is optional.
+   `endcap`: (Optional) `STRING` allows you to specify one of two endcap
    styles: `ROUND` and `FLAT`. The default value is `ROUND`. This option only
    affects the endcaps of buffered linestrings.
+   `side`: (Optional) `STRING` allows you to specify one of three possible line
    styles: `BOTH`, `LEFT`, and `RIGHT`. The default is `BOTH`. This option only
    affects the endcaps of buffered linestrings.
+   `use_spheroid`: (Optional) `BOOL` determines how this function measures
    distance. If `use_spheroid` is `FALSE`, the function measures distance on
    the surface of a perfect sphere. The `use_spheroid` parameter
    currently only supports the value `FALSE`. The default value of
    `use_spheroid` is `FALSE`.

**Return type**

Polygon `GEOGRAPHY`

**Example**

The following example shows the results of `ST_BUFFERWITHTOLERANCE` on a point,
given two different values for tolerance but with the same buffer radius of
`100`. A buffered point is an approximated circle. When `tolerance_meters=25`,
the tolerance is a large percentage of the buffer radius, and therefore only
five segments are used to approximate a circle around the input point. When
`tolerance_meters=1`, the tolerance is a much smaller percentage of the buffer
radius, and therefore twenty-four edges are used to approximate a circle around
the input point.

```zetasql
SELECT
  -- tolerance_meters=25, or 25% of the buffer radius.
  ST_NumPoints(ST_BUFFERWITHTOLERANCE(ST_GEOGFROMTEXT('POINT(1 2)'), 100, 25)) AS five_sides,
  -- tolerance_meters=1, or 1% of the buffer radius.
  st_NumPoints(ST_BUFFERWITHTOLERANCE(ST_GEOGFROMTEXT('POINT(100 2)'), 100, 1)) AS twenty_four_sides;

/*------------+-------------------*
 | five_sides | twenty_four_sides |
 +------------+-------------------+
 | 6          | 24                |
 *------------+-------------------*/
```

[wgs84-link]: https://en.wikipedia.org/wiki/World_Geodetic_System

[st-buffer]: #st_buffer

### `ST_CENTROID`

```zetasql
ST_CENTROID(geography_expression)
```

**Description**

Returns the _centroid_ of the input `GEOGRAPHY` as a single point `GEOGRAPHY`.

The _centroid_ of a `GEOGRAPHY` is the weighted average of the centroids of the
highest-dimensional components in the `GEOGRAPHY`. The centroid for components
in each dimension is defined as follows:

+   The centroid of points is the arithmetic mean of the input coordinates.
+   The centroid of linestrings is the centroid of all the edges weighted by
    length. The centroid of each edge is the geodesic midpoint of the edge.
+   The centroid of a polygon is its center of mass.

If the input `GEOGRAPHY` is empty, an empty `GEOGRAPHY` is returned.

**Constraints**

In the unlikely event that the centroid of a `GEOGRAPHY` can't be defined by a
single point on the surface of the Earth, a deterministic but otherwise
arbitrary point is returned. This can only happen if the centroid is exactly at
the center of the Earth, such as the centroid for a pair of antipodal points,
and the likelihood of this happening is vanishingly small.

**Return type**

Point `GEOGRAPHY`

### `ST_CLOSESTPOINT`

```zetasql
ST_CLOSESTPOINT(geography_1, geography_2[, use_spheroid])
```

**Description**

Returns a `GEOGRAPHY` containing a point on
`geography_1` with the smallest possible distance to `geography_2`. This implies
that the distance between the point returned by `ST_CLOSESTPOINT` and
`geography_2` is less than or equal to the distance between any other point on
`geography_1` and `geography_2`.

If either of the input `GEOGRAPHY`s is empty, `ST_CLOSESTPOINT` returns `NULL`.

The optional `use_spheroid` parameter determines how this function measures
distance. If `use_spheroid` is `FALSE`, the function measures distance on the
surface of a perfect sphere.

The `use_spheroid` parameter currently only supports
the value `FALSE`. The default value of `use_spheroid` is `FALSE`.

**Return type**

Point `GEOGRAPHY`

[wgs84-link]: https://en.wikipedia.org/wiki/World_Geodetic_System

### `ST_CLUSTERDBSCAN`

```zetasql
ST_CLUSTERDBSCAN(geography_column, epsilon, minimum_geographies)
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]

```

Performs [DBSCAN clustering][dbscan-link] on a column of geographies. Returns a
0-based cluster number.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Input parameters**

+   `geography_column`: A column of `GEOGRAPHY`s that
    is clustered.
+   `epsilon`: The epsilon that specifies the radius, measured in meters, around
    a core value. Non-negative `DOUBLE` value.
+   `minimum_geographies`: Specifies the minimum number of geographies in a
    single cluster. Only dense input forms a cluster, otherwise it's classified
    as noise. Non-negative `INT64` value.

**Geography types and the DBSCAN algorithm**

The DBSCAN algorithm identifies high-density clusters of data and marks outliers
in low-density areas of noise. Geographies passed in through `geography_column`
are classified in one of three ways by the DBSCAN algorithm:

+   Core value: A geography is a core value if it's within `epsilon` distance
    of `minimum_geographies` geographies, including itself. The core value
    starts a new cluster, or is added to the same cluster as a core value within
    `epsilon` distance. Core values are grouped in a cluster together with all
    other core and border values that are within `epsilon` distance.
+   Border value: A geography is a border value if it's within epsilon distance
    of a core value. It's added to the same cluster as a core value within
    `epsilon` distance. A border value may be within `epsilon` distance of more
    than one cluster. In this case, it may be arbitrarily assigned to either
    cluster and the function will produce the same result in subsequent calls.
+   Noise: A geography is noise if it's neither a core nor a border value.
    Noise values are assigned to a `NULL` cluster. An empty
    `GEOGRAPHY` is always classified as noise.

**Constraints**

+   The argument `minimum_geographies` is a non-negative
    `INT64`and `epsilon` is a non-negative
    `DOUBLE`.
+   An empty geography can't join any cluster.
+   Multiple clustering assignments could be possible for a border value. If a
    geography is a border value, `ST_CLUSTERDBSCAN` will assign it to an
    arbitrary valid cluster.

**Return type**

`INT64` for each geography in the geography column.

**Examples**

This example performs DBSCAN clustering with a radius of 100,000 meters with a
`minimum_geographies` argument of 1. The geographies being analyzed are a
mixture of points, lines, and polygons.

```zetasql
WITH Geos as
  (SELECT 1 as row_id, ST_GEOGFROMTEXT('POINT EMPTY') as geo UNION ALL
    SELECT 2, ST_GEOGFROMTEXT('MULTIPOINT(1 1, 2 2, 4 4, 5 2)') UNION ALL
    SELECT 3, ST_GEOGFROMTEXT('POINT(14 15)') UNION ALL
    SELECT 4, ST_GEOGFROMTEXT('LINESTRING(40 1, 42 34, 44 39)') UNION ALL
    SELECT 5, ST_GEOGFROMTEXT('POLYGON((40 2, 40 1, 41 2, 40 2))'))
SELECT row_id, geo, ST_CLUSTERDBSCAN(geo, 1e5, 1) OVER () AS cluster_num FROM
Geos ORDER BY row_id

/*--------+-----------------------------------+-------------*
 | row_id |                geo                | cluster_num |
 +--------+-----------------------------------+-------------+
 | 1      | GEOMETRYCOLLECTION EMPTY          | NULL        |
 | 2      | MULTIPOINT(1 1, 2 2, 5 2, 4 4)    | 0           |
 | 3      | POINT(14 15)                      | 1           |
 | 4      | LINESTRING(40 1, 42 34, 44 39)    | 2           |
 | 5      | POLYGON((40 2, 40 1, 41 2, 40 2)) | 2           |
 *--------+-----------------------------------+-------------*/
```

[dbscan-link]: https://en.wikipedia.org/wiki/DBSCAN

### `ST_CONTAINS`

```zetasql
ST_CONTAINS(geography_1, geography_2)
```

**Description**

Returns `TRUE` if no point of `geography_2` is outside `geography_1`, and
the interiors intersect; returns `FALSE` otherwise.

NOTE: A `GEOGRAPHY` *does not* contain its own
boundary. Compare with [`ST_COVERS`][st_covers].

**Return type**

`BOOL`

**Example**

The following query tests whether the polygon `POLYGON((1 1, 20 1, 10 20, 1 1))`
contains each of the three points `(0, 0)`, `(1, 1)`, and `(10, 10)`, which lie
on the exterior, the boundary, and the interior of the polygon respectively.

```zetasql
SELECT
  ST_GEOGPOINT(i, i) AS p,
  ST_CONTAINS(ST_GEOGFROMTEXT('POLYGON((1 1, 20 1, 10 20, 1 1))'),
              ST_GEOGPOINT(i, i)) AS `contains`
FROM UNNEST([0, 1, 10]) AS i;

/*--------------+----------*
 | p            | contains |
 +--------------+----------+
 | POINT(0 0)   | FALSE    |
 | POINT(1 1)   | FALSE    |
 | POINT(10 10) | TRUE     |
 *--------------+----------*/
```

[st_covers]: #st_covers

### `ST_CONVEXHULL`

```zetasql
ST_CONVEXHULL(geography_expression)
```

**Description**

Returns the convex hull for the input `GEOGRAPHY`. The convex hull is the
smallest convex `GEOGRAPHY` that covers the input. A `GEOGRAPHY` is convex if
for every pair of points in the `GEOGRAPHY`, the geodesic edge connecting the
points are also contained in the same `GEOGRAPHY`.

In most cases, the convex hull consists of a single polygon. Notable edge cases
include the following:

*   The convex hull of a single point is also a point.
*   The convex hull of two or more collinear points is a linestring as long as
    that linestring is convex.
*   If the input `GEOGRAPHY` spans more than a
    hemisphere, the convex hull is the full globe. This includes any input that
    contains a pair of antipodal points.
*   `ST_CONVEXHULL` returns `NULL` if the input is either `NULL` or the empty
    `GEOGRAPHY`.

**Return type**

`GEOGRAPHY`

**Examples**

The convex hull returned by `ST_CONVEXHULL` can be a point, linestring, or a
polygon, depending on the input.

```zetasql
WITH Geographies AS
 (SELECT ST_GEOGFROMTEXT('POINT(1 1)') AS g UNION ALL
  SELECT ST_GEOGFROMTEXT('LINESTRING(1 1, 2 2)') AS g UNION ALL
  SELECT ST_GEOGFROMTEXT('MULTIPOINT(2 11, 4 12, 0 15, 1 9, 1 12)') AS g)
SELECT
  g AS input_geography,
  ST_CONVEXHULL(g) AS convex_hull
FROM Geographies;

/*-----------------------------------------+--------------------------------------------------------*
 |             input_geography             |                      convex_hull                       |
 +-----------------------------------------+--------------------------------------------------------+
 | POINT(1 1)                              | POINT(0.999999999999943 1)                             |
 | LINESTRING(1 1, 2 2)                    | LINESTRING(2 2, 1.49988573656168 1.5000570914792, 1 1) |
 | MULTIPOINT(1 9, 4 12, 2 11, 1 12, 0 15) | POLYGON((1 9, 4 12, 0 15, 1 9))                        |
 *-----------------------------------------+--------------------------------------------------------*/
```

### `ST_COVEREDBY`

```zetasql
ST_COVEREDBY(geography_1, geography_2)
```

**Description**

Returns `FALSE` if `geography_1` or `geography_2` is empty. Returns `TRUE` if no
points of `geography_1` lie in the exterior of `geography_2`.

Given two `GEOGRAPHY`s `a` and `b`,
`ST_COVEREDBY(a, b)` returns the same result as
[`ST_COVERS`][st-covers]`(b, a)`. Note the opposite order of arguments.

**Return type**

`BOOL`

[st-covers]: #st_covers

### `ST_COVERS`

```zetasql
ST_COVERS(geography_1, geography_2)
```

**Description**

Returns `FALSE` if `geography_1` or `geography_2` is empty.
Returns `TRUE` if no points of `geography_2` lie in the exterior of
`geography_1`.

**Return type**

`BOOL`

**Example**

The following query tests whether the polygon `POLYGON((1 1, 20 1, 10 20, 1 1))`
covers each of the three points `(0, 0)`, `(1, 1)`, and `(10, 10)`, which lie
on the exterior, the boundary, and the interior of the polygon respectively.

```zetasql
SELECT
  ST_GEOGPOINT(i, i) AS p,
  ST_COVERS(ST_GEOGFROMTEXT('POLYGON((1 1, 20 1, 10 20, 1 1))'),
            ST_GEOGPOINT(i, i)) AS `covers`
FROM UNNEST([0, 1, 10]) AS i;

/*--------------+--------*
 | p            | covers |
 +--------------+--------+
 | POINT(0 0)   | FALSE  |
 | POINT(1 1)   | TRUE   |
 | POINT(10 10) | TRUE   |
 *--------------+--------*/
```

### `ST_DIFFERENCE`

```zetasql
ST_DIFFERENCE(geography_1, geography_2)
```

**Description**

Returns a `GEOGRAPHY` that represents the point set
difference of `geography_1` and `geography_2`. Therefore, the result consists of
the part of `geography_1` that doesn't intersect with `geography_2`.

If `geometry_1` is completely contained in `geometry_2`, then `ST_DIFFERENCE`
returns an empty `GEOGRAPHY`.

**Constraints**

The underlying geometric objects that a ZetaSQL
`GEOGRAPHY` represents correspond to a *closed* point
set. Therefore, `ST_DIFFERENCE` is the closure of the point set difference of
`geography_1` and `geography_2`. This implies that if `geography_1` and
`geography_2` intersect, then a portion of the boundary of `geography_2` could
be in the difference.

**Return type**

`GEOGRAPHY`

**Example**

The following query illustrates the difference between `geog1`, a larger polygon
`POLYGON((0 0, 10 0, 10 10, 0 0))` and `geog2`, a smaller polygon
`POLYGON((4 2, 6 2, 8 6, 4 2))` that intersects with `geog1`. The result is
`geog1` with a hole where `geog2` intersects with it.

```zetasql
SELECT
  ST_DIFFERENCE(
      ST_GEOGFROMTEXT('POLYGON((0 0, 10 0, 10 10, 0 0))'),
      ST_GEOGFROMTEXT('POLYGON((4 2, 6 2, 8 6, 4 2))')
  );

/*--------------------------------------------------------*
 | difference_of_geog1_and_geog2                          |
 +--------------------------------------------------------+
 | POLYGON((0 0, 10 0, 10 10, 0 0), (8 6, 6 2, 4 2, 8 6)) |
 *--------------------------------------------------------*/
```

### `ST_DIMENSION`

```zetasql
ST_DIMENSION(geography_expression)
```

**Description**

Returns the dimension of the highest-dimensional element in the input
`GEOGRAPHY`.

The dimension of each possible element is as follows:

+   The dimension of a point is `0`.
+   The dimension of a linestring is `1`.
+   The dimension of a polygon is `2`.

If the input `GEOGRAPHY` is empty, `ST_DIMENSION`
returns `-1`.

**Return type**

`INT64`

### `ST_DISJOINT`

```zetasql
ST_DISJOINT(geography_1, geography_2)
```

**Description**

Returns `TRUE` if the intersection of `geography_1` and `geography_2` is empty,
that is, no point in `geography_1` also appears in `geography_2`.

`ST_DISJOINT` is the logical negation of [`ST_INTERSECTS`][st-intersects].

**Return type**

`BOOL`

[st-intersects]: #st_intersects

### `ST_DISTANCE`

```
ST_DISTANCE(geography_1, geography_2[, use_spheroid])
```

**Description**

Returns the shortest distance in meters between two non-empty
`GEOGRAPHY`s.

If either of the input `GEOGRAPHY`s is empty,
`ST_DISTANCE` returns `NULL`.

The optional `use_spheroid` parameter determines how this function measures
distance. If `use_spheroid` is `FALSE`, the function measures distance on the
surface of a perfect sphere. If `use_spheroid` is `TRUE`, the function measures
distance on the surface of the [WGS84][wgs84-link] spheroid. The default value
of `use_spheroid` is `FALSE`.

**Return type**

`DOUBLE`

[wgs84-link]: https://en.wikipedia.org/wiki/World_Geodetic_System

### `ST_DUMP`

```zetasql
ST_DUMP(geography[, dimension])
```

**Description**

Returns an `ARRAY` of simple
`GEOGRAPHY`s where each element is a component of
the input `GEOGRAPHY`. A simple
`GEOGRAPHY` consists of a single point, linestring,
or polygon. If the input `GEOGRAPHY` is simple, the
result is a single element. When the input
`GEOGRAPHY` is a collection, `ST_DUMP` returns an
`ARRAY` with one simple
`GEOGRAPHY` for each component in the collection.

If `dimension` is provided, the function only returns
`GEOGRAPHY`s of the corresponding dimension. A
dimension of -1 is equivalent to omitting `dimension`.

**Return Type**

`ARRAY<GEOGRAPHY>`

**Examples**

The following example shows how `ST_DUMP` returns the simple geographies within
a complex geography.

```zetasql
WITH example AS (
  SELECT ST_GEOGFROMTEXT('POINT(0 0)') AS geography
  UNION ALL
  SELECT ST_GEOGFROMTEXT('MULTIPOINT(0 0, 1 1)') AS geography
  UNION ALL
  SELECT ST_GEOGFROMTEXT('GEOMETRYCOLLECTION(POINT(0 0), LINESTRING(1 2, 2 1))'))
SELECT
  geography AS original_geography,
  ST_DUMP(geography) AS dumped_geographies
FROM example

/*-------------------------------------+------------------------------------*
 |         original_geographies        |      dumped_geographies            |
 +-------------------------------------+------------------------------------+
 | POINT(0 0)                          | [POINT(0 0)]                       |
 | MULTIPOINT(0 0, 1 1)                | [POINT(0 0), POINT(1 1)]           |
 | GEOMETRYCOLLECTION(POINT(0 0),      | [POINT(0 0), LINESTRING(1 2, 2 1)] |
 |   LINESTRING(1 2, 2 1))             |                                    |
 *-------------------------------------+------------------------------------*/
```

The following example shows how `ST_DUMP` with the dimension argument only
returns simple geographies of the given dimension.

```zetasql
WITH example AS (
  SELECT ST_GEOGFROMTEXT('GEOMETRYCOLLECTION(POINT(0 0), LINESTRING(1 2, 2 1))') AS geography)
SELECT
  geography AS original_geography,
  ST_DUMP(geography, 1) AS dumped_geographies
FROM example

/*-------------------------------------+------------------------------*
 |         original_geographies        |      dumped_geographies      |
 +-------------------------------------+------------------------------+
 | GEOMETRYCOLLECTION(POINT(0 0),      | [LINESTRING(1 2, 2 1)]       |
 |   LINESTRING(1 2, 2 1))             |                              |
 *-------------------------------------+------------------------------*/
```

### `ST_DUMPPOINTS`

```zetasql
ST_DUMPPOINTS(geography)
```

**Description**

Takes an input geography and returns all of its points, line vertices, and
polygon vertices as an array of point geographies.

**Return Type**

`ARRAY<Point GEOGRAPHY>`

**Examples**

```zetasql
WITH example AS (
  SELECT ST_GEOGFROMTEXT('POINT(0 0)') AS geography
  UNION ALL
  SELECT ST_GEOGFROMTEXT('MULTIPOINT(0 0, 1 1)') AS geography
  UNION ALL
  SELECT ST_GEOGFROMTEXT('GEOMETRYCOLLECTION(POINT(0 0), LINESTRING(1 2, 2 1))'))
SELECT
  geography AS original_geography,
  ST_DUMPPOINTS(geography) AS dumped_points_geographies
FROM example

/*-------------------------------------+------------------------------------*
 | original_geographies                | dumped_points_geographies          |
 +-------------------------------------+------------------------------------+
 | POINT(0 0)                          | [POINT(0 0)]                       |
 | MULTIPOINT(0 0, 1 1)                | [POINT(0 0),POINT(1 1)]            |
 | GEOMETRYCOLLECTION(POINT(0 0),      | [POINT(0 0),POINT(1 2),POINT(2 1)] |
 |   LINESTRING(1 2, 2 1))             |                                    |
 *-------------------------------------+------------------------------------*/
```

### `ST_DWITHIN`

```zetasql
ST_DWITHIN(geography_1, geography_2, distance[, use_spheroid])
```

**Description**

Returns `TRUE` if the distance between at least one point in `geography_1` and
one point in `geography_2` is less than or equal to the distance given by the
`distance` argument; otherwise, returns `FALSE`. If either input
`GEOGRAPHY` is empty, `ST_DWithin` returns `FALSE`. The
given `distance` is in meters on the surface of the Earth.

The optional `use_spheroid` parameter determines how this function measures
distance. If `use_spheroid` is `FALSE`, the function measures distance on the
surface of a perfect sphere.

The `use_spheroid` parameter currently only supports
the value `FALSE`. The default value of `use_spheroid` is `FALSE`.

**Return type**

`BOOL`

[wgs84-link]: https://en.wikipedia.org/wiki/World_Geodetic_System

### `ST_ENDPOINT`

```zetasql
ST_ENDPOINT(linestring_geography)
```

**Description**

Returns the last point of a linestring geography as a point geography. Returns
an error if the input isn't a linestring or if the input is empty. Use the
`SAFE` prefix to obtain `NULL` for invalid input instead of an error.

**Return Type**

Point `GEOGRAPHY`

**Example**

```zetasql
SELECT ST_ENDPOINT(ST_GEOGFROMTEXT('LINESTRING(1 1, 2 1, 3 2, 3 3)')) last

/*--------------*
 | last         |
 +--------------+
 | POINT(3 3)   |
 *--------------*/
```

### `ST_EQUALS`

```zetasql
ST_EQUALS(geography_1, geography_2)
```

**Description**

Checks if two `GEOGRAPHY` values represent the same `GEOGRAPHY` value. Returns
`TRUE` if the values are the same, otherwise returns `FALSE`.

**Definitions**

+ `geography_1`: The first `GEOGRAPHY` value to compare.
+ `geography_2`: The second `GEOGRAPHY` value to compare.

**Details**

As long as they still represent the same geometric structure, two
`GEOGRAPHY` values can be equal even if the ordering of points or vertices
differ. This means that one of the following conditions must be true for this
function to return `TRUE`:

+   Both `ST_COVERS(geography_1, geography_2)` and
    `ST_COVERS(geography_2, geography_1)` are `TRUE`.
+   Both `geography_1` and `geography_2` are empty.

`ST_EQUALS` isn't guaranteed to be a transitive function.

**Return type**

`BOOL`

### `ST_EXTENT`

```zetasql
ST_EXTENT(geography_expression)
```

**Description**

Returns a `STRUCT` that represents the bounding box for the set of input
`GEOGRAPHY` values. The bounding box is the minimal rectangle that encloses the
geography. The edges of the rectangle follow constant lines of longitude and
latitude.

Caveats:

+ Returns `NULL` if all the inputs are `NULL` or empty geographies.
+ The bounding box might cross the antimeridian if this allows for a smaller
  rectangle. In this case, the bounding box has one of its longitudinal bounds
  outside of the [-180, 180] range, so that `xmin` is smaller than the eastmost
  value `xmax`.
+ If the longitude span of the bounding box is larger than or equal to 180
  degrees, the function returns the bounding box with the longitude range of
  [-180, 180].

**Return type**

`STRUCT<xmin DOUBLE, ymin DOUBLE, xmax DOUBLE, ymax DOUBLE>`.

Bounding box parts:

+ `xmin`: The westmost constant longitude line that bounds the rectangle.
+ `xmax`: The eastmost constant longitude line that bounds the rectangle.
+ `ymin`: The minimum constant latitude line that bounds the rectangle.
+ `ymax`: The maximum constant latitude line that bounds the rectangle.

**Example**

```zetasql
WITH data AS (
  SELECT 1 id, ST_GEOGFROMTEXT('POLYGON((-125 48, -124 46, -117 46, -117 49, -125 48))') g
  UNION ALL
  SELECT 2 id, ST_GEOGFROMTEXT('POLYGON((172 53, -130 55, -141 70, 172 53))') g
  UNION ALL
  SELECT 3 id, ST_GEOGFROMTEXT('POINT EMPTY') g
)
SELECT ST_EXTENT(g) AS box
FROM data

/*----------------------------------------------*
 | box                                          |
 +----------------------------------------------+
 | {xmin:172, ymin:46, xmax:243, ymax:70}       |
 *----------------------------------------------*/
```

[`ST_BOUNDINGBOX`][st-boundingbox] for the non-aggregate version of `ST_EXTENT`.

[st-boundingbox]: #st_boundingbox

### `ST_EXTERIORRING`

```zetasql
ST_EXTERIORRING(polygon_geography)
```

**Description**

Returns a linestring geography that corresponds to the outermost ring of a
polygon geography.

+   If the input geography is a polygon, gets the outermost ring of the polygon
    geography and returns the corresponding linestring.
+   If the input is the full `GEOGRAPHY`, returns an empty geography.
+   Returns an error if the input isn't a single polygon.

Use the `SAFE` prefix to return `NULL` for invalid input instead of an error.

**Return type**

+ Linestring `GEOGRAPHY`
+ Empty `GEOGRAPHY`

**Examples**

```zetasql
WITH geo as
 (SELECT ST_GEOGFROMTEXT('POLYGON((0 0, 1 4, 2 2, 0 0))') AS g UNION ALL
  SELECT ST_GEOGFROMTEXT('''POLYGON((1 1, 1 10, 5 10, 5 1, 1 1),
                                  (2 2, 3 4, 2 4, 2 2))''') as g)
SELECT ST_EXTERIORRING(g) AS ring FROM geo;

/*---------------------------------------*
 | ring                                  |
 +---------------------------------------+
 | LINESTRING(2 2, 1 4, 0 0, 2 2)        |
 | LINESTRING(5 1, 5 10, 1 10, 1 1, 5 1) |
 *---------------------------------------*/
```

### `ST_GEOGFROM`

```zetasql
ST_GEOGFROM(expression)
```

**Description**

Converts an expression for a `STRING` or `BYTES` value into a
`GEOGRAPHY` value.

If `expression` represents a `STRING` value, it must be a valid
`GEOGRAPHY` representation in one of the following formats:

+ WKT format. To learn more about this format and the requirements to use it,
  see [ST_GEOGFROMTEXT][st-geogfromtext].
+ WKB in hexadecimal text format. To learn more about this format and the
  requirements to use it, see [ST_GEOGFROMWKB][st-geogfromwkb].
+ GeoJSON format. To learn more about this format and the
  requirements to use it, see [ST_GEOGFROMGEOJSON][st-geogfromgeojson].

If `expression` represents a `BYTES` value, it must be a valid `GEOGRAPHY`
binary expression in WKB format. To learn more about this format and the
requirements to use it, see [ST_GEOGFROMWKB][st-geogfromwkb].

If `expression` is `NULL`, the output is `NULL`.

**Return type**

`GEOGRAPHY`

**Examples**

This takes a WKT-formatted string and returns a `GEOGRAPHY` polygon:

```zetasql
SELECT ST_GEOGFROM('POLYGON((0 0, 0 2, 2 2, 2 0, 0 0))') AS WKT_format;

/*------------------------------------*
 | WKT_format                         |
 +------------------------------------+
 | POLYGON((2 0, 2 2, 0 2, 0 0, 2 0)) |
 *------------------------------------*/
```

This takes a WKB-formatted hexadecimal-encoded string and returns a
`GEOGRAPHY` point:

```zetasql
SELECT ST_GEOGFROM(FROM_HEX('010100000000000000000000400000000000001040')) AS WKB_format;

/*----------------*
 | WKB_format     |
 +----------------+
 | POINT(2 4)     |
 *----------------*/
```

This takes WKB-formatted bytes and returns a `GEOGRAPHY` point:

```zetasql
SELECT ST_GEOGFROM('010100000000000000000000400000000000001040') AS WKB_format;

/*----------------*
 | WKB_format     |
 +----------------+
 | POINT(2 4)     |
 *----------------*/
```

This takes a GeoJSON-formatted string and returns a `GEOGRAPHY` polygon:

```zetasql
SELECT ST_GEOGFROM(
  '{ "type": "Polygon", "coordinates": [ [ [2, 0], [2, 2], [1, 2], [0, 2], [0, 0], [2, 0] ] ] }'
) AS GEOJSON_format;

/*-----------------------------------------*
 | GEOJSON_format                          |
 +-----------------------------------------+
 | POLYGON((2 0, 2 2, 1 2, 0 2, 0 0, 2 0)) |
 *-----------------------------------------*/
```

[st-geogfromtext]: #st_geogfromtext

[st-geogfromwkb]: #st_geogfromwkb

[st-geogfromgeojson]: #st_geogfromgeojson

### `ST_GEOGFROMGEOJSON`

```zetasql
ST_GEOGFROMGEOJSON(
  geojson_string
  [, make_valid => constant_expression ]
)
```

**Description**

Returns a `GEOGRAPHY` value that corresponds to the
input [GeoJSON][geojson-link] representation.

`ST_GEOGFROMGEOJSON` accepts input that's [RFC 7946][geojson-spec-link]
compliant.

If the named argument `make_valid` is set to `TRUE`, the function attempts to
repair polygons that don't conform to [Open Geospatial Consortium][ogc-link]
semantics.

A ZetaSQL `GEOGRAPHY` has spherical
geodesic edges, whereas a GeoJSON `Geometry` object explicitly has planar edges.
To convert between these two types of edges, ZetaSQL adds additional
points to the line where necessary so that the resulting sequence of edges
remains within 10 meters of the original edge.

See [`ST_ASGEOJSON`][st-asgeojson] to format a
`GEOGRAPHY` as GeoJSON.

**Constraints**

The JSON input is subject to the following constraints:

+   `ST_GEOGFROMGEOJSON` only accepts JSON geometry fragments and can't be used
    to ingest a whole JSON document.
+   The input JSON fragment must consist of a GeoJSON geometry type, which
    includes `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`,
    `MultiPolygon`, and `GeometryCollection`. Any other GeoJSON type such as
    `Feature` or `FeatureCollection` will result in an error.
+   A position in the `coordinates` member of a GeoJSON geometry type must
    consist of exactly two elements. The first is the longitude and the second
    is the latitude. Therefore, `ST_GEOGFROMGEOJSON` doesn't support the
    optional third element for a position in the `coordinates` member.

**Return type**

`GEOGRAPHY`

[geojson-link]: https://en.wikipedia.org/wiki/GeoJSON

[geojson-spec-link]: https://tools.ietf.org/html/rfc7946

[ogc-link]: https://www.ogc.org/standards/sfa

[st-asgeojson]: #st_asgeojson

### `ST_GEOGFROMKML`

```zetasql
ST_GEOGFROMKML(kml_geometry)
```

Takes a `STRING` [KML geometry][kml-geometry-link] and returns a
`GEOGRAPHY`. The KML geomentry can include:

+  Point with coordinates element only
+  Linestring with coordinates element only
+  Polygon with boundary elements only
+  Multigeometry

[kml-geometry-link]: https://developers.google.com/kml/documentation/kmlreference#geometry

### `ST_GEOGFROMTEXT`

<a id="st_geogfromtext_signature1"></a><a id="st_geogfromtext_signature2"></a>

```zetasql
ST_GEOGFROMTEXT(
  wkt_string
  [ , oriented => value ]
  [ , planar => value ]
  [ , make_valid => value ]
)
```

**Description**

Converts a `STRING` [WKT][wkt-link] geometry value into a `GEOGRAPHY`
value.

To format `GEOGRAPHY` value as WKT, use [`ST_ASTEXT`][st-astext].

**Definitions**

+   `wkt_string`: A `STRING` value that contains the [WKT][wkt-link] format.
+   `oriented`: A named argument with a `BOOL` literal.

    +   If the value is `TRUE`, any polygons in the input are assumed to be
        oriented as follows: when traveling along the boundary of the polygon
        in the order of the input vertices, the interior of the polygon is on
        the left. This allows WKT to represent polygons larger than a
        hemisphere. See also [`ST_MAKEPOLYGONORIENTED`][st-makepolygonoriented],
        which is similar to `ST_GEOGFROMTEXT` with `oriented=TRUE`.

    +   If the value is `FALSE` or omitted, this function returns the polygon
        with the smaller area.
+   `planar`: A named argument with a `BOOL` literal. If the value
    is `TRUE`, the edges of the linestrings and polygons are assumed to use
    planar map semantics, rather than ZetaSQL default spherical
    geodesics semantics.
+   `make_valid`: A named argument with a `BOOL` literal. If the
    value is `TRUE`, the function attempts to repair polygons that don't
    conform to [Open Geospatial Consortium][ogc-link] semantics.

**Details**

+   The function doesn't support three-dimensional geometries that have a `Z`
    suffix, nor does it support linear referencing system geometries with an `M`
    suffix.
+   `oriented` and `planar` can't be `TRUE` at the same time.
+   `oriented` and `make_valid` can't be `TRUE` at the same time.

**Example**

The following query reads the WKT string `POLYGON((0 0, 0 2, 2 2, 0 2, 0 0))`
both as a non-oriented polygon and as an oriented polygon, and checks whether
each result contains the point `(1, 1)`.

```zetasql
WITH polygon AS (SELECT 'POLYGON((0 0, 0 2, 2 2, 2 0, 0 0))' AS p)
SELECT
  ST_CONTAINS(ST_GEOGFROMTEXT(p), ST_GEOGPOINT(1, 1)) AS fromtext_default,
  ST_CONTAINS(ST_GEOGFROMTEXT(p, oriented => FALSE), ST_GEOGPOINT(1, 1)) AS non_oriented,
  ST_CONTAINS(ST_GEOGFROMTEXT(p, oriented => TRUE),  ST_GEOGPOINT(1, 1)) AS oriented
FROM polygon;

/*-------------------+---------------+-----------*
 | fromtext_default  | non_oriented  | oriented  |
 +-------------------+---------------+-----------+
 | TRUE              | TRUE          | FALSE     |
 *-------------------+---------------+-----------*/
```

The following query converts a WKT string with an invalid polygon to
`GEOGRAPHY`. The WKT string violates two properties
of a valid polygon - the loop describing the polygon isn't closed, and it
contains self-intersection. With the `make_valid` option, `ST_GEOGFROMTEXT`
successfully converts it to a multipolygon shape.

```zetasql
WITH data AS (
  SELECT 'POLYGON((0 -1, 2 1, 2 -1, 0 1))' wkt)
SELECT
  SAFE.ST_GEOGFROMTEXT(wkt) as geom,
  SAFE.ST_GEOGFROMTEXT(wkt, make_valid => TRUE) as valid_geom
FROM data

/*------+-----------------------------------------------------------------*
 | geom | valid_geom                                                      |
 +------+-----------------------------------------------------------------+
 | NULL | MULTIPOLYGON(((0 -1, 1 0, 0 1, 0 -1)), ((1 0, 2 -1, 2 1, 1 0))) |
 *------+-----------------------------------------------------------------*/
```

[ogc-link]: https://www.ogc.org/standards/sfa

[wkt-link]: https://en.wikipedia.org/wiki/Well-known_text

[st-makepolygonoriented]: #st_makepolygonoriented

[st-astext]: #st_astext

[st-geogfromgeojson]: #st_geogfromgeojson

### `ST_GEOGFROMWKB`

```zetasql
ST_GEOGFROMWKB(
  wkb_bytes_expression
  [ , oriented => value ]
  [ , planar => value ]
  [ , make_valid => value ]
)
```

```zetasql
ST_GEOGFROMWKB(
  wkb_hex_string_expression
  [, oriented => value ]
  [, planar => value ]
  [, make_valid => value ]
)
```

**Description**

Converts an expression from a hexadecimal-text `STRING` or `BYTES`
value into a `GEOGRAPHY` value. The expression must be in
[WKB][wkb-link] format.

To format `GEOGRAPHY` as WKB, use [`ST_ASBINARY`][st-asbinary].

**Definitions**

+   `wkb_bytes_expression`: A `BYTES` value that contains the [WKB][wkb-link]
    format.
+   `wkb_hex_string_expression`: A `STRING` value that contains the
    hexadecimal-encoded [WKB][wkb-link] format.
+   `oriented`: A named argument with a `BOOL` literal.

    +   If the value is `TRUE`, any polygons in the input are assumed to be
        oriented as follows: when traveling along the boundary of the polygon
        in the order of the input vertices, the interior of the polygon is on
        the left. This allows WKB to represent polygons larger than a
        hemisphere. See also [`ST_MAKEPOLYGONORIENTED`][st-makepolygonoriented],
        which is similar to `ST_GEOGFROMWKB` with `oriented=TRUE`.

    +   If the value is `FALSE` or omitted, this function returns the polygon
        with the smaller area.
+   `planar`: A named argument with a `BOOL` literal. If the value
    is `TRUE`, the edges of the linestrings and polygons are assumed to use
    planar map semantics, rather than ZetaSQL default spherical
    geodesics semantics.
+   `make_valid`: A named argument with a `BOOL` literal. If the
    value is `TRUE`, the function attempts to repair polygons that
    don't conform to [Open Geospatial Consortium][ogc-link] semantics.

**Details**

+   The function doesn't support three-dimensional geometries that have a `Z`
    suffix, nor does it support linear referencing system geometries with an `M`
    suffix.
+   `oriented` and `planar` can't be `TRUE` at the same time.
+   `oriented` and `make_valid` can't be `TRUE` at the same time.

**Return type**

`GEOGRAPHY`

**Example**

The following query reads the hex-encoded WKB data containing
`LINESTRING(1 1, 3 2)` and uses it with planar and geodesic semantics. When
planar is used, the function approximates the planar input line using
line that contains a chain of geodesic segments.

```zetasql
WITH wkb_data AS (
  SELECT '010200000002000000feffffffffffef3f000000000000f03f01000000000008400000000000000040' geo
)
SELECT
  ST_GeogFromWkb(geo, planar=>TRUE) AS from_planar,
  ST_GeogFromWkb(geo, planar=>FALSE) AS from_geodesic,
FROM wkb_data

/*---------------------------------------+----------------------*
 | from_planar                           | from_geodesic        |
 +---------------------------------------+----------------------+
 | LINESTRING(1 1, 2 1.5, 2.5 1.75, 3 2) | LINESTRING(1 1, 3 2) |
 *---------------------------------------+----------------------*/
```

[wkb-link]: https://en.wikipedia.org/wiki/Well-known_text#Well-known_binary

[st-asbinary]: #st_asbinary

[st-geogfromgeojson]: #st_geogfromgeojson

### `ST_GEOGPOINT`

```zetasql
ST_GEOGPOINT(longitude, latitude)
```

**Description**

Creates a `GEOGRAPHY` with a single point. `ST_GEOGPOINT` creates a point from
the specified `DOUBLE` longitude (in degrees,
negative west of the Prime Meridian, positive east) and latitude (in degrees,
positive north of the Equator, negative south) parameters and returns that point
in a `GEOGRAPHY` value.

NOTE: Some systems present latitude first; take care with argument order.

**Constraints**

+   Longitudes outside the range \[-180, 180\] are allowed; `ST_GEOGPOINT` uses
    the input longitude modulo 360 to obtain a longitude within \[-180, 180\].
+   Latitudes must be in the range \[-90, 90\]. Latitudes outside this range
    will result in an error.

**Return type**

Point `GEOGRAPHY`

### `ST_GEOGPOINTFROMGEOHASH`

```zetasql
ST_GEOGPOINTFROMGEOHASH(geohash)
```

**Description**

Returns a `GEOGRAPHY` value that corresponds to a
point in the middle of a bounding box defined in the [GeoHash][geohash-link].

**Return type**

Point `GEOGRAPHY`

[geohash-link]: https://en.wikipedia.org/wiki/Geohash

### `ST_GEOHASH`

```zetasql
ST_GEOHASH(geography_expression[, maxchars])
```

**Description**

Takes a single-point `GEOGRAPHY` and returns a [GeoHash][geohash-link]
representation of that `GEOGRAPHY` object.

+   `geography_expression`: Represents a `GEOGRAPHY` object. Only a `GEOGRAPHY`
    object that represents a single point is supported. If `ST_GEOHASH` is used
    over an empty `GEOGRAPHY` object, returns `NULL`.
+   `maxchars`: This optional `INT64` parameter specifies the maximum number of
    characters the hash will contain. Fewer characters corresponds to lower
    precision (or, described differently, to a bigger bounding box). `maxchars`
    defaults to 20 if not explicitly specified. A valid `maxchars` value is 1
    to 20. Any value below or above is considered unspecified and the default of
    20 is used.

**Return type**

`STRING`

**Example**

Returns a GeoHash of the Seattle Center with 10 characters of precision.

```zetasql
SELECT ST_GEOHASH(ST_GEOGPOINT(-122.35, 47.62), 10) geohash

/*--------------*
 | geohash      |
 +--------------+
 | c22yzugqw7   |
 *--------------*/
```

[geohash-link]: https://en.wikipedia.org/wiki/Geohash

### `ST_GEOMETRYTYPE`

```zetasql
ST_GEOMETRYTYPE(geography_expression)
```

**Description**

Returns the [Open Geospatial Consortium][ogc-link] (OGC) geometry type that
describes the input `GEOGRAPHY`. The OGC geometry type matches the
types that are used in [WKT][wkt-link] and [GeoJSON][geojson-link] formats and
printed for [ST_ASTEXT][st-astext] and [ST_ASGEOJSON][st-asgeojson].
`ST_GEOMETRYTYPE` returns the OGC geometry type with the "ST_" prefix.

`ST_GEOMETRYTYPE` returns the following given the type on the input:

+   Single point geography: Returns `ST_Point`.
+   Collection of only points: Returns `ST_MultiPoint`.
+   Single linestring geography: Returns `ST_LineString`.
+   Collection of only linestrings: Returns `ST_MultiLineString`.
+   Single polygon geography: Returns `ST_Polygon`.
+   Collection of only polygons: Returns `ST_MultiPolygon`.
+   Collection with elements of different dimensions, or the input is the empty
    geography: Returns `ST_GeometryCollection`.

**Return type**

`STRING`

**Example**

The following example shows how `ST_GEOMETRYTYPE` takes geographies and returns
the names of their OGC geometry types.

```zetasql
WITH example AS(
  SELECT ST_GEOGFROMTEXT('POINT(0 1)') AS geography
  UNION ALL
  SELECT ST_GEOGFROMTEXT('MULTILINESTRING((2 2, 3 4), (5 6, 7 7))')
  UNION ALL
  SELECT ST_GEOGFROMTEXT('GEOMETRYCOLLECTION(MULTIPOINT(-1 2, 0 12), LINESTRING(-2 4, 0 6))')
  UNION ALL
  SELECT ST_GEOGFROMTEXT('GEOMETRYCOLLECTION EMPTY'))
SELECT
  geography AS WKT,
  ST_GEOMETRYTYPE(geography) AS geometry_type_name
FROM example;

/*-------------------------------------------------------------------+-----------------------*
 | WKT                                                               | geometry_type_name    |
 +-------------------------------------------------------------------+-----------------------+
 | POINT(0 1)                                                        | ST_Point              |
 | MULTILINESTRING((2 2, 3 4), (5 6, 7 7))                           | ST_MultiLineString    |
 | GEOMETRYCOLLECTION(MULTIPOINT(-1 2, 0 12), LINESTRING(-2 4, 0 6)) | ST_GeometryCollection |
 | GEOMETRYCOLLECTION EMPTY                                          | ST_GeometryCollection |
 *-------------------------------------------------------------------+-----------------------*/
```

[ogc-link]: https://www.ogc.org/standards/sfa

[wkt-link]: https://en.wikipedia.org/wiki/Well-known_text

[geojson-link]: https://en.wikipedia.org/wiki/GeoJSON

[st-astext]: #st_astext

[st-asgeojson]: #st_asgeojson

### `ST_HAUSDORFFDISTANCE`

```zetasql
ST_HAUSDORFFDISTANCE(
  geography_1,
  geography_2
  [, directed => { TRUE | FALSE } ]
)
```

**Description**

Gets the discrete [Hausdorff distance][h-distance], which is the greatest of all
the distances from a discrete point in one geography to the closest
discrete point in another geography.

**Definitions**

+   `geography_1`: A `GEOGRAPHY` value that represents the first geography.
+   `geography_2`: A `GEOGRAPHY` value that represents the second geography.
+   `directed`: A named argument with a `BOOL` value. Represents the type of
    computation to use on the input geographies. If this argument isn't
    specified, `directed => FALSE` is used by default.

    +   `FALSE`: The largest Hausdorff distance found in
        (`geography_1`, `geography_2`) and
        (`geography_2`, `geography_1`).

    +   `TRUE` (default): The Hausdorff distance for
        (`geography_1`, `geography_2`).

**Details**

If an input geography is `NULL`, the function returns `NULL`.

**Return type**

`DOUBLE`

**Example**

The following query gets the Hausdorff distance between `geo1` and `geo2`:

```zetasql
WITH data AS (
  SELECT
    ST_GEOGFROMTEXT('LINESTRING(20 70, 70 60, 10 70, 70 70)') AS geo1,
    ST_GEOGFROMTEXT('LINESTRING(20 90, 30 90, 60 10, 90 10)') AS geo2
)
SELECT ST_HAUSDORFFDISTANCE(geo1, geo2, directed=>TRUE) AS distance
FROM data;

/*--------------------+
 | distance           |
 +--------------------+
 | 1688933.9832041925 |
 +--------------------*/
```

The following query gets the Hausdorff distance between `geo2` and `geo1`:

```zetasql
WITH data AS (
  SELECT
    ST_GEOGFROMTEXT('LINESTRING(20 70, 70 60, 10 70, 70 70)') AS geo1,
    ST_GEOGFROMTEXT('LINESTRING(20 90, 30 90, 60 10, 90 10)') AS geo2
)
SELECT ST_HAUSDORFFDISTANCE(geo2, geo1, directed=>TRUE) AS distance
FROM data;

/*--------------------+
 | distance           |
 +--------------------+
 | 5802892.745488612  |
 +--------------------*/
```

The following query gets the largest Hausdorff distance between
(`geo1` and `geo2`) and (`geo2` and `geo1`):

```zetasql
WITH data AS (
  SELECT
    ST_GEOGFROMTEXT('LINESTRING(20 70, 70 60, 10 70, 70 70)') AS geo1,
    ST_GEOGFROMTEXT('LINESTRING(20 90, 30 90, 60 10, 90 10)') AS geo2
)
SELECT ST_HAUSDORFFDISTANCE(geo1, geo2, directed=>FALSE) AS distance
FROM data;

/*--------------------+
 | distance           |
 +--------------------+
 | 5802892.745488612  |
 +--------------------*/
```

The following query produces the same results as the previous query because
`ST_HAUSDORFFDISTANCE` uses `directed=>FALSE` by default.

```zetasql
WITH data AS (
  SELECT
    ST_GEOGFROMTEXT('LINESTRING(20 70, 70 60, 10 70, 70 70)') AS geo1,
    ST_GEOGFROMTEXT('LINESTRING(20 90, 30 90, 60 10, 90 10)') AS geo2
)
SELECT ST_HAUSDORFFDISTANCE(geo1, geo2) AS distance
FROM data;
```

[h-distance]: http://en.wikipedia.org/wiki/Hausdorff_distance

### `ST_HAUSDORFFDWITHIN`

```zetasql
ST_HAUSDORFFDWITHIN(
  geography_1,
  geography_2,
  distance
  [, directed => { TRUE | FALSE } ]
)
```

**Description**

Returns `TRUE` if the [Hausdorff distance][st-hausdorffdistance] between `geography_1` and
`geography_2` is less than or equal to the distance given by the
`distance` argument; otherwise, returns `FALSE`.

**Definitions**

+   `geography_1`: A `GEOGRAPHY` value that represents the first geography.
+   `geography_2`: A `GEOGRAPHY` value that represents the second geography.
+   `distance`: A `DOUBLE` value that represents meters on the
    surface of the Earth.
+   `directed`: A named argument with a `BOOL` value. Represents the type of
    computation to use on the input geographies. If this argument isn't
    specified, `directed => FALSE` is used by default.

    +   `FALSE`: The largest Hausdorff distance found in
        (`geography_1`, `geography_2`) and
        (`geography_2`, `geography_1`).

    +   `TRUE` (default): The Hausdorff distance for
        (`geography_1`, `geography_2`).

**Details**

If an input geography is `NULL`, the function returns `NULL`.

**Return type**

`BOOL`

**Examples**

The following example checks whether the Hausdorff distance between the first
and second geographies is less than or equal to 100,000 meters.

```zetasql
SELECT
  ST_HAUSDORFFDWITHIN(
    ST_GEOGFROMTEXT('LINESTRING(10 1, 20 1)'),
    ST_GEOGFROMTEXT('LINESTRING(10 2, 20 2)'),
    100000) AS is_close;

/*----------*
 | is_close |
 +----------+
 | false    |
 *----------*/
```

[st-hausdorffdistance]: #st_hausdorffdistance

### `ST_INTERIORRINGS`

```zetasql
ST_INTERIORRINGS(polygon_geography)
```

**Description**

Returns an array of linestring geographies that corresponds to the interior
rings of a polygon geography. Each interior ring is the border of a hole within
the input polygon.

+   If the input geography is a polygon, excludes the outermost ring of the
    polygon geography and returns the linestrings corresponding to the interior
    rings.
+   If the input is the full `GEOGRAPHY`, returns an empty array.
+   If the input polygon has no holes, returns an empty array.
+   Returns an error if the input isn't a single polygon.

Use the `SAFE` prefix to return `NULL` for invalid input instead of an error.

**Return type**

`ARRAY<LineString GEOGRAPHY>`

**Examples**

```zetasql
WITH geo AS (
  SELECT ST_GEOGFROMTEXT('POLYGON((0 0, 1 1, 1 2, 0 0))') AS g UNION ALL
  SELECT ST_GEOGFROMTEXT('POLYGON((1 1, 1 10, 5 10, 5 1, 1 1), (2 2, 3 4, 2 4, 2 2))') UNION ALL
  SELECT ST_GEOGFROMTEXT('POLYGON((1 1, 1 10, 5 10, 5 1, 1 1), (2 2.5, 3.5 3, 2.5 2, 2 2.5), (3.5 7, 4 6, 3 3, 3.5 7))') UNION ALL
  SELECT ST_GEOGFROMTEXT('fullglobe') UNION ALL
  SELECT NULL)
SELECT ST_INTERIORRINGS(g) AS rings FROM geo;

/*----------------------------------------------------------------------------*
 | rings                                                                      |
 +----------------------------------------------------------------------------+
 | []                                                                         |
 | [LINESTRING(2 2, 3 4, 2 4, 2 2)]                                           |
 | [LINESTRING(2.5 2, 3.5 3, 2 2.5, 2.5 2), LINESTRING(3 3, 4 6, 3.5 7, 3 3)] |
 | []                                                                         |
 | NULL                                                                       |
 *----------------------------------------------------------------------------*/
```

### `ST_INTERSECTION`

```zetasql
ST_INTERSECTION(geography_1, geography_2)
```

**Description**

Returns a `GEOGRAPHY` that represents the point set
intersection of the two input `GEOGRAPHY`s. Thus,
every point in the intersection appears in both `geography_1` and `geography_2`.

If the two input `GEOGRAPHY`s are disjoint, that is,
there are no points that appear in both input `geometry_1` and `geometry_2`,
then an empty `GEOGRAPHY` is returned.

See [ST_INTERSECTS][st-intersects], [ST_DISJOINT][st-disjoint] for related
predicate functions.

**Return type**

`GEOGRAPHY`

[st-intersects]: #st_intersects

[st-disjoint]: #st_disjoint

### `ST_INTERSECTS`

```zetasql
ST_INTERSECTS(geography_1, geography_2)
```

**Description**

Returns `TRUE` if the point set intersection of `geography_1` and `geography_2`
is non-empty. Thus, this function returns `TRUE` if there is at least one point
that appears in both input `GEOGRAPHY`s.

If `ST_INTERSECTS` returns `TRUE`, it implies that [`ST_DISJOINT`][st-disjoint]
returns `FALSE`.

**Return type**

`BOOL`

[st-disjoint]: #st_disjoint

### `ST_INTERSECTSBOX`

```zetasql
ST_INTERSECTSBOX(geography, lng1, lat1, lng2, lat2)
```

**Description**

Returns `TRUE` if `geography` intersects the rectangle between `[lng1, lng2]`
and `[lat1, lat2]`. The edges of the rectangle follow constant lines of
longitude and latitude. `lng1` and `lng2` specify the westmost and eastmost
constant longitude lines that bound the rectangle, and `lat1` and `lat2` specify
the minimum and maximum constant latitude lines that bound the rectangle.

Specify all longitude and latitude arguments in degrees.

**Constraints**

The input arguments are subject to the following constraints:

+   Latitudes should be in the `[-90, 90]` degree range.
+   Longitudes should follow either of the following rules:
    +   Both longitudes are in the `[-180, 180]` degree range.
    +   One of the longitudes is in the `[-180, 180]` degree range, and
        `lng2 - lng1` is in the `[0, 360]` interval.

**Return type**

`BOOL`

**Example**

```zetasql
SELECT p, ST_INTERSECTSBOX(p, -90, 0, 90, 20) AS box1,
       ST_INTERSECTSBOX(p, 90, 0, -90, 20) AS box2
FROM UNNEST([ST_GEOGPOINT(10, 10), ST_GEOGPOINT(170, 10),
             ST_GEOGPOINT(30, 30)]) p

/*----------------+--------------+--------------*
 | p              | box1         | box2         |
 +----------------+--------------+--------------+
 | POINT(10 10)   | TRUE         | FALSE        |
 | POINT(170 10)  | FALSE        | TRUE         |
 | POINT(30 30)   | FALSE        | FALSE        |
 *----------------+--------------+--------------*/
```

### `ST_ISCLOSED`

```zetasql
ST_ISCLOSED(geography_expression)
```

**Description**

Returns `TRUE` for a non-empty Geography, where each element in the Geography
has an empty boundary. The boundary for each element can be defined with
[`ST_BOUNDARY`][st-boundary].

+   A point is closed.
+   A linestring is closed if the start and end points of the linestring are
    the same.
+   A polygon is closed only if it's a full polygon.
+   A collection is closed if and only if every element in the collection is
    closed.

An empty `GEOGRAPHY` isn't closed.

**Return type**

`BOOL`

**Example**

```zetasql
WITH example AS(
  SELECT ST_GEOGFROMTEXT('POINT(5 0)') AS geography
  UNION ALL
  SELECT ST_GEOGFROMTEXT('LINESTRING(0 1, 4 3, 2 6, 0 1)') AS geography
  UNION ALL
  SELECT ST_GEOGFROMTEXT('LINESTRING(2 6, 1 3, 3 9)') AS geography
  UNION ALL
  SELECT ST_GEOGFROMTEXT('GEOMETRYCOLLECTION(POINT(0 0), LINESTRING(1 2, 2 1))') AS geography
  UNION ALL
  SELECT ST_GEOGFROMTEXT('GEOMETRYCOLLECTION EMPTY'))
SELECT
  geography,
  ST_ISCLOSED(geography) AS is_closed,
FROM example;

/*------------------------------------------------------+-----------*
 | geography                                            | is_closed |
 +------------------------------------------------------+-----------+
 | POINT(5 0)                                           | TRUE      |
 | LINESTRING(0 1, 4 3, 2 6, 0 1)                       | TRUE      |
 | LINESTRING(2 6, 1 3, 3 9)                            | FALSE     |
 | GEOMETRYCOLLECTION(POINT(0 0), LINESTRING(1 2, 2 1)) | FALSE     |
 | GEOMETRYCOLLECTION EMPTY                             | FALSE     |
 *------------------------------------------------------+-----------*/
```

[st-boundary]: #st_boundary

### `ST_ISCOLLECTION`

```zetasql
ST_ISCOLLECTION(geography_expression)
```

**Description**

Returns `TRUE` if the total number of points, linestrings, and polygons is
greater than one.

An empty `GEOGRAPHY` isn't a collection.

**Return type**

`BOOL`

### `ST_ISEMPTY`

```zetasql
ST_ISEMPTY(geography_expression)
```

**Description**

Returns `TRUE` if the given `GEOGRAPHY` is empty; that is, the `GEOGRAPHY`
doesn't contain any points, lines, or polygons.

NOTE: An empty `GEOGRAPHY` isn't associated with a particular geometry shape.
For example, the results of expressions `ST_GEOGFROMTEXT('POINT EMPTY')` and
`ST_GEOGFROMTEXT('GEOMETRYCOLLECTION EMPTY')` are identical.

**Return type**

`BOOL`

### `ST_ISRING`

```zetasql
ST_ISRING(geography_expression)
```

**Description**

Returns `TRUE` if the input `GEOGRAPHY` is a linestring and if the
linestring is both [`ST_ISCLOSED`][st-isclosed] and
simple. A linestring is considered simple if it doesn't pass through the
same point twice (with the exception of the start and endpoint, which may
overlap to form a ring).

An empty `GEOGRAPHY` isn't a ring.

**Return type**

`BOOL`

[st-isclosed]: #st_isclosed

### `ST_LENGTH`

```zetasql
ST_LENGTH(geography_expression[, use_spheroid])
```

**Description**

Returns the total length in meters of the lines in the input
`GEOGRAPHY`.

If `geography_expression` is a point or a polygon, returns zero. If
`geography_expression` is a collection, returns the length of the lines in the
collection; if the collection doesn't contain lines, returns zero.

The optional `use_spheroid` parameter determines how this function measures
distance. If `use_spheroid` is `FALSE`, the function measures distance on the
surface of a perfect sphere.

The `use_spheroid` parameter currently only supports
the value `FALSE`. The default value of `use_spheroid` is `FALSE`.

**Return type**

`DOUBLE`

[wgs84-link]: https://en.wikipedia.org/wiki/World_Geodetic_System

### `ST_LINEINTERPOLATEPOINT`

```zetasql
ST_LINEINTERPOLATEPOINT(linestring_geography, fraction)
```

**Description**

Gets a point at a specific fraction in a linestring `GEOGRAPHY` value.

**Definitions**

+  `linestring_geography`: A linestring `GEOGRAPHY` on which the target point
    is located.
+  `fraction`: A `DOUBLE` value that represents a fraction
    along the linestring `GEOGRAPHY` where the target point is located.
    This should be an inclusive value between `0` (start of the
    linestring) and `1` (end of the linestring).

**Details**

+   Returns `NULL` if any input argument is `NULL`.
+   Returns an empty geography if `linestring_geography` is an empty geography.
+   Returns an error if `linestring_geography` isn't a linestring or an empty
    geography, or if `fraction` is outside the `[0, 1]` range.

**Return Type**

`GEOGRAPHY`

**Example**

The following query returns a few points on a linestring. Notice that the
 midpoint of the linestring `LINESTRING(1 1, 5 5)` is slightly different from
 `POINT(3 3)` because the `GEOGRAPHY` type uses geodesic line segments.

```zetasql
WITH fractions AS (
    SELECT 0 AS fraction UNION ALL
    SELECT 0.5 UNION ALL
    SELECT 1 UNION ALL
    SELECT NULL
  )
SELECT
  fraction,
  ST_LINEINTERPOLATEPOINT(ST_GEOGFROMTEXT('LINESTRING(1 1, 5 5)'), fraction)
    AS point
FROM fractions

/*-------------+-------------------------------------------*
 | fraction    | point                                     |
 +-------------+-------------------------------------------+
 | 0           | POINT(1 1)                                |
 | 0.5         | POINT(2.99633827268976 3.00182528336078)  |
 | 1           | POINT(5 5)                                |
 | NULL        | NULL                                      |
 *-------------+-------------------------------------------*/
```

### `ST_LINELOCATEPOINT`

```zetasql
ST_LINELOCATEPOINT(linestring_geography, point_geography)
```

**Description**

Gets a section of a linestring between the start point and a selected point (a
point on the linestring closest to the `point_geography` argument). Returns the
percentage that this section represents in the linestring.

Details:

+   To select a point on the linestring `GEOGRAPHY` (`linestring_geography`),
    this function takes a point `GEOGRAPHY` (`point_geography`) and finds the
    [closest point][st-closestpoint] to it on the linestring.
+   If two points on `linestring_geography` are an equal distance away from
    `point_geography`, it isn't guaranteed which one will be selected.
+   The return value is an inclusive value between 0 and 1 (0-100%).
+   If the selected point is the start point on the linestring, function returns
    0 (0%).
+   If the selected point is the end point on the linestring, function returns 1
    (100%).

`NULL` and error handling:

+   Returns `NULL` if any input argument is `NULL`.
+   Returns an error if `linestring_geography` isn't a linestring or if
    `point_geography` isn't a point. Use the `SAFE` prefix
    to obtain `NULL` for invalid input instead of an error.

**Return Type**

`DOUBLE`

**Examples**

```zetasql
WITH geos AS (
    SELECT ST_GEOGPOINT(0, 0) AS point UNION ALL
    SELECT ST_GEOGPOINT(1, 0) UNION ALL
    SELECT ST_GEOGPOINT(1, 1) UNION ALL
    SELECT ST_GEOGPOINT(2, 2) UNION ALL
    SELECT ST_GEOGPOINT(3, 3) UNION ALL
    SELECT ST_GEOGPOINT(4, 4) UNION ALL
    SELECT ST_GEOGPOINT(5, 5) UNION ALL
    SELECT ST_GEOGPOINT(6, 5) UNION ALL
    SELECT NULL
  )
SELECT
  point AS input_point,
  ST_LINELOCATEPOINT(ST_GEOGFROMTEXT('LINESTRING(1 1, 5 5)'), point)
    AS percentage_from_beginning
FROM geos

/*-------------+---------------------------*
 | input_point | percentage_from_beginning |
 +-------------+---------------------------+
 | POINT(0 0)  | 0                         |
 | POINT(1 0)  | 0                         |
 | POINT(1 1)  | 0                         |
 | POINT(2 2)  | 0.25015214685147907       |
 | POINT(3 3)  | 0.5002284283637185        |
 | POINT(4 4)  | 0.7501905913884388        |
 | POINT(5 5)  | 1                         |
 | POINT(6 5)  | 1                         |
 | NULL        | NULL                      |
 *-------------+---------------------------*/
```

[st-closestpoint]: #st_closestpoint

### `ST_LINESUBSTRING`

```zetasql
ST_LINESUBSTRING(linestring_geography, start_fraction, end_fraction);
```

**Description**

Gets a segment of a linestring at a specific starting and ending fraction.

**Definitions**

+   `linestring_geography`: The LineString `GEOGRAPHY` value that represents the
    linestring from which to extract a segment.
+   `start_fraction`: `DOUBLE` value that represents
    the starting fraction of the total length of `linestring_geography`.
    This must be an inclusive value between 0 and 1 (0-100%).
+   `end_fraction`: `DOUBLE` value that represents
    the ending fraction of the total length of `linestring_geography`.
    This must be an inclusive value between 0 and 1 (0-100%).

**Details**

`end_fraction` must be greater than or equal to `start_fraction`.

If `start_fraction` and `end_fraction` are equal, a linestring with only
one point is produced.

**Return type**

+   LineString `GEOGRAPHY` if the resulting geography has more than one point.
+   Point `GEOGRAPHY` if the resulting geography has only one point.

**Example**

The following query returns the second half of the linestring:

```zetasql
WITH data AS (
  SELECT ST_GEOGFROMTEXT('LINESTRING(20 70, 70 60, 10 70, 70 70)') AS geo1
)
SELECT ST_LINESUBSTRING(geo1, 0.5, 1) AS segment
FROM data;

/*-------------------------------------------------------------+
 | segment                                                     |
 +-------------------------------------------------------------+
 | LINESTRING(49.4760661523471 67.2419539103851, 10 70, 70 70) |
 +-------------------------------------------------------------*/
```

The following query returns a linestring that only contains one point:

```zetasql
WITH data AS (
  SELECT ST_GEOGFROMTEXT('LINESTRING(20 70, 70 60, 10 70, 70 70)') AS geo1
)
SELECT ST_LINESUBSTRING(geo1, 0.5, 0.5) AS segment
FROM data;

/*------------------------------------------+
 | segment                                  |
 +------------------------------------------+
 | POINT(49.4760661523471 67.2419539103851) |
 +------------------------------------------*/
```

### `ST_MAKELINE`

```zetasql
ST_MAKELINE(geography_1, geography_2)
```

```zetasql
ST_MAKELINE(array_of_geography)
```

**Description**

Creates a `GEOGRAPHY` with a single linestring by
concatenating the point or line vertices of each of the input
`GEOGRAPHY`s in the order they are given.

`ST_MAKELINE` comes in two variants. For the first variant, input must be two
`GEOGRAPHY`s. For the second, input must be an `ARRAY` of type `GEOGRAPHY`. In
either variant, each input `GEOGRAPHY` must consist of one of the following
values:

+   Exactly one point.
+   Exactly one linestring.

For the first variant of `ST_MAKELINE`, if either input `GEOGRAPHY` is `NULL`,
`ST_MAKELINE` returns `NULL`. For the second variant, if input `ARRAY` or any
element in the input `ARRAY` is `NULL`, `ST_MAKELINE` returns `NULL`.

**Constraints**

Every edge must span strictly less than 180 degrees.

NOTE: The ZetaSQL snapping process may discard sufficiently short
edges and snap the two endpoints together. For instance, if two input
`GEOGRAPHY`s each contain a point and the two points are separated by a distance
less than the snap radius, the points will be snapped together. In such a case
the result will be a `GEOGRAPHY` with exactly one point.

**Return type**

LineString `GEOGRAPHY`

### `ST_MAKEPOLYGON`

```zetasql
ST_MAKEPOLYGON(polygon_shell[, array_of_polygon_holes])
```

**Description**

Creates a `GEOGRAPHY` containing a single polygon
from linestring inputs, where each input linestring is used to construct a
polygon ring.

`ST_MAKEPOLYGON` comes in two variants. For the first variant, the input
linestring is provided by a single `GEOGRAPHY` containing exactly one
linestring. For the second variant, the input consists of a single `GEOGRAPHY`
and an array of `GEOGRAPHY`s, each containing exactly one linestring.

The first `GEOGRAPHY` in either variant is used to construct the polygon shell.
Additional `GEOGRAPHY`s provided in the input `ARRAY` specify a polygon hole.
For every input `GEOGRAPHY` containing exactly one linestring, the following
must be true:

+   The linestring must consist of at least three distinct vertices.
+   The linestring must be closed: that is, the first and last vertex have to be
    the same. If the first and last vertex differ, the function constructs a
    final edge from the first vertex to the last.

For the first variant of `ST_MAKEPOLYGON`, if either input `GEOGRAPHY` is
`NULL`, `ST_MAKEPOLYGON` returns `NULL`. For the second variant, if
input `ARRAY` or any element in the `ARRAY` is `NULL`, `ST_MAKEPOLYGON` returns
`NULL`.

NOTE: `ST_MAKEPOLYGON` accepts an empty `GEOGRAPHY` as input. `ST_MAKEPOLYGON`
interprets an empty `GEOGRAPHY` as having an empty linestring, which will
create a full loop: that is, a polygon that covers the entire Earth.

**Constraints**

Together, the input rings must form a valid polygon:

+   The polygon shell must cover each of the polygon holes.
+   There can be only one polygon shell (which has to be the first input ring).
    This implies that polygon holes can't be nested.
+   Polygon rings may only intersect in a vertex on the boundary of both rings.

Every edge must span strictly less than 180 degrees.

Each polygon ring divides the sphere into two regions. The first input linesting
to `ST_MAKEPOLYGON` forms the polygon shell, and the interior is chosen to be
the smaller of the two regions. Each subsequent input linestring specifies a
polygon hole, so the interior of the polygon is already well-defined. In order
to define a polygon shell such that the interior of the polygon is the larger of
the two regions, see [`ST_MAKEPOLYGONORIENTED`][st-makepolygonoriented].

NOTE: The ZetaSQL snapping process may discard sufficiently
short edges and snap the two endpoints together. Hence, when vertices are
snapped together, it's possible that a polygon hole that's sufficiently small
may disappear, or the output `GEOGRAPHY` may contain only a line or a
point.

**Return type**

`GEOGRAPHY`

[st-makepolygonoriented]: #st_makepolygonoriented

### `ST_MAKEPOLYGONORIENTED`

```zetasql
ST_MAKEPOLYGONORIENTED(array_of_geography)
```

**Description**

Like `ST_MAKEPOLYGON`, but the vertex ordering of each input linestring
determines the orientation of each polygon ring. The orientation of a polygon
ring defines the interior of the polygon as follows: if someone walks along the
boundary of the polygon in the order of the input vertices, the interior of the
polygon is on the left. This applies for each polygon ring provided.

This variant of the polygon constructor is more flexible since
`ST_MAKEPOLYGONORIENTED` can construct a polygon such that the interior is on
either side of the polygon ring. However, proper orientation of polygon rings is
critical in order to construct the desired polygon.

If the input `ARRAY` or any element in the `ARRAY` is `NULL`,
`ST_MAKEPOLYGONORIENTED` returns `NULL`.

NOTE: The input argument for `ST_MAKEPOLYGONORIENTED` may contain an empty
`GEOGRAPHY`. `ST_MAKEPOLYGONORIENTED` interprets an empty `GEOGRAPHY` as having
an empty linestring, which will create a full loop: that is, a polygon that
covers the entire Earth.

**Constraints**

Together, the input rings must form a valid polygon:

+   The polygon shell must cover each of the polygon holes.
+   There must be only one polygon shell, which must to be the first input ring.
    This implies that polygon holes can't be nested.
+   Polygon rings may only intersect in a vertex on the boundary of both rings.

Every edge must span strictly less than 180 degrees.

`ST_MAKEPOLYGONORIENTED` relies on the ordering of the input vertices of each
linestring to determine the orientation of the polygon. This applies to the
polygon shell and any polygon holes. `ST_MAKEPOLYGONORIENTED` expects all
polygon holes to have the opposite orientation of the shell. See
[`ST_MAKEPOLYGON`][st-makepolygon] for an alternate polygon constructor, and
other constraints on building a valid polygon.

NOTE: Due to the ZetaSQL snapping process, edges with a sufficiently
short length will be discarded and the two endpoints will be snapped to a single
point. Therefore, it's possible that vertices in a linestring may be snapped
together such that one or more edge disappears. Hence, it's possible that a
polygon hole that's sufficiently small may disappear, or the resulting
`GEOGRAPHY` may contain only a line or a point.

**Return type**

`GEOGRAPHY`

[st-makepolygon]: #st_makepolygon

### `ST_MAXDISTANCE`

```zetasql
ST_MAXDISTANCE(geography_1, geography_2[, use_spheroid])
```

Returns the longest distance in meters between two non-empty
`GEOGRAPHY`s; that is, the distance between two
vertices where the first vertex is in the first
`GEOGRAPHY`, and the second vertex is in the second
`GEOGRAPHY`. If `geography_1` and `geography_2` are the
same `GEOGRAPHY`, the function returns the distance
between the two most distant vertices in that
`GEOGRAPHY`.

If either of the input `GEOGRAPHY`s is empty,
`ST_MAXDISTANCE` returns `NULL`.

The optional `use_spheroid` parameter determines how this function measures
distance. If `use_spheroid` is `FALSE`, the function measures distance on the
surface of a perfect sphere.

The `use_spheroid` parameter currently only supports
the value `FALSE`. The default value of `use_spheroid` is `FALSE`.

**Return type**

`DOUBLE`

[wgs84-link]: https://en.wikipedia.org/wiki/World_Geodetic_System

### `ST_NPOINTS`

```zetasql
ST_NPOINTS(geography_expression)
```

**Description**

An alias of [ST_NUMPOINTS][st-numpoints].

[st-numpoints]: #st_numpoints

### `ST_NUMGEOMETRIES`

```
ST_NUMGEOMETRIES(geography_expression)
```

**Description**

Returns the number of geometries in the input `GEOGRAPHY`. For a single point,
linestring, or polygon, `ST_NUMGEOMETRIES` returns `1`. For any collection of
geometries, `ST_NUMGEOMETRIES` returns the number of geometries making up the
collection. `ST_NUMGEOMETRIES` returns `0` if the input is the empty
`GEOGRAPHY`.

**Return type**

`INT64`

**Example**

The following example computes `ST_NUMGEOMETRIES` for a single point geography,
two collections, and an empty geography.

```zetasql
WITH example AS(
  SELECT ST_GEOGFROMTEXT('POINT(5 0)') AS geography
  UNION ALL
  SELECT ST_GEOGFROMTEXT('MULTIPOINT(0 1, 4 3, 2 6)') AS geography
  UNION ALL
  SELECT ST_GEOGFROMTEXT('GEOMETRYCOLLECTION(POINT(0 0), LINESTRING(1 2, 2 1))') AS geography
  UNION ALL
  SELECT ST_GEOGFROMTEXT('GEOMETRYCOLLECTION EMPTY'))
SELECT
  geography,
  ST_NUMGEOMETRIES(geography) AS num_geometries,
FROM example;

/*------------------------------------------------------+----------------*
 | geography                                            | num_geometries |
 +------------------------------------------------------+----------------+
 | POINT(5 0)                                           | 1              |
 | MULTIPOINT(0 1, 4 3, 2 6)                            | 3              |
 | GEOMETRYCOLLECTION(POINT(0 0), LINESTRING(1 2, 2 1)) | 2              |
 | GEOMETRYCOLLECTION EMPTY                             | 0              |
 *------------------------------------------------------+----------------*/
```

### `ST_NUMPOINTS`

```zetasql
ST_NUMPOINTS(geography_expression)
```

**Description**

Returns the number of vertices in the input
`GEOGRAPHY`. This includes the number of points, the
number of linestring vertices, and the number of polygon vertices.

NOTE: The first and last vertex of a polygon ring are counted as distinct
vertices.

**Return type**

`INT64`

### `ST_PERIMETER`

```zetasql
ST_PERIMETER(geography_expression[, use_spheroid])
```

**Description**

Returns the length in meters of the boundary of the polygons in the input
`GEOGRAPHY`.

If `geography_expression` is a point or a line, returns zero. If
`geography_expression` is a collection, returns the perimeter of the polygons
in the collection; if the collection doesn't contain polygons, returns zero.

The optional `use_spheroid` parameter determines how this function measures
distance. If `use_spheroid` is `FALSE`, the function measures distance on the
surface of a perfect sphere.

The `use_spheroid` parameter currently only supports
the value `FALSE`. The default value of `use_spheroid` is `FALSE`.

**Return type**

`DOUBLE`

[wgs84-link]: https://en.wikipedia.org/wiki/World_Geodetic_System

### `ST_POINTN`

```zetasql
ST_POINTN(linestring_geography, index)
```

**Description**

Returns the Nth point of a linestring geography as a point geography, where N is
the index. The index is 1-based. Negative values are counted backwards from the
end of the linestring, so that -1 is the last point. Returns an error if the
input isn't a linestring, if the input is empty, or if there is no vertex at
the given index. Use the `SAFE` prefix to obtain `NULL` for invalid input
instead of an error.

**Return Type**

Point `GEOGRAPHY`

**Example**

The following example uses `ST_POINTN`, [`ST_STARTPOINT`][st-startpoint] and
[`ST_ENDPOINT`][st-endpoint] to extract points from a linestring.

```zetasql
WITH linestring AS (
    SELECT ST_GEOGFROMTEXT('LINESTRING(1 1, 2 1, 3 2, 3 3)') g
)
SELECT ST_POINTN(g, 1) AS first, ST_POINTN(g, -1) AS last,
    ST_POINTN(g, 2) AS second, ST_POINTN(g, -2) AS second_to_last
FROM linestring;

/*--------------+--------------+--------------+----------------*
 | first        | last         | second       | second_to_last |
 +--------------+--------------+--------------+----------------+
 | POINT(1 1)   | POINT(3 3)   | POINT(2 1)   | POINT(3 2)     |
 *--------------+--------------+--------------+----------------*/
```

[st-startpoint]: #st_startpoint

[st-endpoint]: #st_endpoint

### `ST_SIMPLIFY`

```zetasql
ST_SIMPLIFY(geography, tolerance_meters)
```

**Description**

Returns a simplified version of `geography`, the given input
`GEOGRAPHY`. The input `GEOGRAPHY` is simplified by replacing nearly straight
chains of short edges with a single long edge. The input `geography` will not
change by more than the tolerance specified by `tolerance_meters`. Thus,
simplified edges are guaranteed to pass within `tolerance_meters` of the
*original* positions of all vertices that were removed from that edge. The given
`tolerance_meters` is in meters on the surface of the Earth.

Note that `ST_SIMPLIFY` preserves topological relationships, which means that
no new crossing edges will be created and the output will be valid. For a large
enough tolerance, adjacent shapes may collapse into a single object, or a shape
could be simplified to a shape with a smaller dimension.

**Constraints**

For `ST_SIMPLIFY` to have any effect, `tolerance_meters` must be non-zero.

`ST_SIMPLIFY` returns an error if the tolerance specified by `tolerance_meters`
is one of the following:

+ A negative tolerance.
+ Greater than ~7800 kilometers.

**Return type**

`GEOGRAPHY`

**Examples**

The following example shows how `ST_SIMPLIFY` simplifies the input line
`GEOGRAPHY` by removing intermediate vertices.

```zetasql
WITH example AS
 (SELECT ST_GEOGFROMTEXT('LINESTRING(0 0, 0.05 0, 0.1 0, 0.15 0, 2 0)') AS line)
SELECT
   line AS original_line,
   ST_SIMPLIFY(line, 1) AS simplified_line
FROM example;

/*---------------------------------------------+----------------------*
 |                original_line                |   simplified_line    |
 +---------------------------------------------+----------------------+
 | LINESTRING(0 0, 0.05 0, 0.1 0, 0.15 0, 2 0) | LINESTRING(0 0, 2 0) |
 *---------------------------------------------+----------------------*/
```

The following example illustrates how the result of `ST_SIMPLIFY` can have a
lower dimension than the original shape.

```zetasql
WITH example AS
 (SELECT
    ST_GEOGFROMTEXT('POLYGON((0 0, 0.1 0, 0.1 0.1, 0 0))') AS polygon,
    t AS tolerance
  FROM UNNEST([1000, 10000, 100000]) AS t)
SELECT
  polygon AS original_triangle,
  tolerance AS tolerance_meters,
  ST_SIMPLIFY(polygon, tolerance) AS simplified_result
FROM example

/*-------------------------------------+------------------+-------------------------------------*
 |          original_triangle          | tolerance_meters |          simplified_result          |
 +-------------------------------------+------------------+-------------------------------------+
 | POLYGON((0 0, 0.1 0, 0.1 0.1, 0 0)) |             1000 | POLYGON((0 0, 0.1 0, 0.1 0.1, 0 0)) |
 | POLYGON((0 0, 0.1 0, 0.1 0.1, 0 0)) |            10000 |            LINESTRING(0 0, 0.1 0.1) |
 | POLYGON((0 0, 0.1 0, 0.1 0.1, 0 0)) |           100000 |                          POINT(0 0) |
 *-------------------------------------+------------------+-------------------------------------*/
```

### `ST_SNAPTOGRID`

```zetasql
ST_SNAPTOGRID(geography_expression, grid_size)
```

**Description**

Returns the input `GEOGRAPHY`, where each vertex has
been snapped to a longitude/latitude grid. The grid size is determined by the
`grid_size` parameter which is given in degrees.

**Constraints**

Arbitrary grid sizes aren't supported. The `grid_size` parameter is rounded so
that it's of the form `10^n`, where `-10 < n < 0`.

**Return type**

`GEOGRAPHY`

### `ST_STARTPOINT`

```zetasql
ST_STARTPOINT(linestring_geography)
```

**Description**

Returns the first point of a linestring geography as a point geography. Returns
an error if the input isn't a linestring or if the input is empty. Use the
`SAFE` prefix to obtain `NULL` for invalid input instead of an error.

**Return Type**

Point `GEOGRAPHY`

**Example**

```zetasql
SELECT ST_STARTPOINT(ST_GEOGFROMTEXT('LINESTRING(1 1, 2 1, 3 2, 3 3)')) first

/*--------------*
 | first        |
 +--------------+
 | POINT(1 1)   |
 *--------------*/
```

### `ST_TOUCHES`

```zetasql
ST_TOUCHES(geography_1, geography_2)
```

**Description**

Returns `TRUE` provided the following two conditions are satisfied:

1.  `geography_1` intersects `geography_2`.
1.  The interior of `geography_1` and the interior of `geography_2` are
    disjoint.

**Return type**

`BOOL`

### `ST_UNION`

```zetasql
ST_UNION(geography_1, geography_2)
```

```zetasql
ST_UNION(array_of_geography)
```

**Description**

Returns a `GEOGRAPHY` that represents the point set
union of all input `GEOGRAPHY`s.

`ST_UNION` comes in two variants. For the first variant, input must be two
`GEOGRAPHY`s. For the second, the input is an
`ARRAY` of type `GEOGRAPHY`.

For the first variant of `ST_UNION`, if an input
`GEOGRAPHY` is `NULL`, `ST_UNION` returns `NULL`.
For the second variant, if the input `ARRAY` value
is `NULL`, `ST_UNION` returns `NULL`.
For a non-`NULL` input `ARRAY`, the union is computed
and `NULL` elements are ignored so that they don't affect the output.

See [`ST_UNION_AGG`][st-union-agg] for the aggregate version of `ST_UNION`.

**Return type**

`GEOGRAPHY`

**Example**

```zetasql
SELECT ST_UNION(
  ST_GEOGFROMTEXT('LINESTRING(-122.12 47.67, -122.19 47.69)'),
  ST_GEOGFROMTEXT('LINESTRING(-122.12 47.67, -100.19 47.69)')
) AS results

/*---------------------------------------------------------*
 | results                                                 |
 +---------------------------------------------------------+
 | LINESTRING(-100.19 47.69, -122.12 47.67, -122.19 47.69) |
 *---------------------------------------------------------*/
```

[st-union-agg]: #st_union_agg

### `ST_UNION_AGG`

```zetasql
ST_UNION_AGG(geography)
```

**Description**

Returns a `GEOGRAPHY` that represents the point set
union of all input `GEOGRAPHY`s.

`ST_UNION_AGG` ignores `NULL` input `GEOGRAPHY` values.

See [`ST_UNION`][st-union] for the non-aggregate version of `ST_UNION_AGG`.

**Return type**

`GEOGRAPHY`

**Example**

```zetasql
SELECT ST_UNION_AGG(items) AS results
FROM UNNEST([
  ST_GEOGFROMTEXT('LINESTRING(-122.12 47.67, -122.19 47.69)'),
  ST_GEOGFROMTEXT('LINESTRING(-122.12 47.67, -100.19 47.69)'),
  ST_GEOGFROMTEXT('LINESTRING(-122.12 47.67, -122.19 47.69)')]) as items;

/*---------------------------------------------------------*
 | results                                                 |
 +---------------------------------------------------------+
 | LINESTRING(-100.19 47.69, -122.12 47.67, -122.19 47.69) |
 *---------------------------------------------------------*/
```

[st-union]: #st_union

### `ST_WITHIN`

```zetasql
ST_WITHIN(geography_1, geography_2)
```

**Description**

Returns `TRUE` if no point of `geography_1` is outside of `geography_2` and
the interiors of `geography_1` and `geography_2` intersect.

Given two geographies `a` and `b`, `ST_WITHIN(a, b)` returns the same result
as [`ST_CONTAINS`][st-contains]`(b, a)`. Note the opposite order of arguments.

**Return type**

`BOOL`

[st-contains]: #st_contains

### `ST_X`

```zetasql
ST_X(point_geography_expression)
```

**Description**

Returns the longitude in degrees of the single-point input
`GEOGRAPHY`.

For any input `GEOGRAPHY` that isn't a single point,
including an empty `GEOGRAPHY`, `ST_X` returns an
error. Use the `SAFE.` prefix to obtain `NULL`.

**Return type**

`DOUBLE`

**Example**

The following example uses `ST_X` and `ST_Y` to extract coordinates from
single-point geographies.

```zetasql
WITH points AS
   (SELECT ST_GEOGPOINT(i, i + 1) AS p FROM UNNEST([0, 5, 12]) AS i)
 SELECT
   p,
   ST_X(p) as longitude,
   ST_Y(p) as latitude
FROM points;

/*--------------+-----------+----------*
 | p            | longitude | latitude |
 +--------------+-----------+----------+
 | POINT(0 1)   | 0.0       | 1.0      |
 | POINT(5 6)   | 5.0       | 6.0      |
 | POINT(12 13) | 12.0      | 13.0     |
 *--------------+-----------+----------*/
```

### `ST_Y`

```zetasql
ST_Y(point_geography_expression)
```

**Description**

Returns the latitude in degrees of the single-point input
`GEOGRAPHY`.

For any input `GEOGRAPHY` that isn't a single point,
including an empty `GEOGRAPHY`, `ST_Y` returns an
error. Use the `SAFE.` prefix to return `NULL` instead.

**Return type**

`DOUBLE`

**Example**

See [`ST_X`][st-x] for example usage.

[st-x]: #st_x

## Hash functions

ZetaSQL supports the following hash functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#farm_fingerprint"><code>FARM_FINGERPRINT</code></a>
</td>
  <td>
    Computes the fingerprint of a <code>STRING</code> or
    <code>BYTES</code> value, using the FarmHash Fingerprint64 algorithm.
  </td>
</tr>

<tr>
  <td><a href="#md5"><code>MD5</code></a>
</td>
  <td>
    Computes the hash of a <code>STRING</code> or
    <code>BYTES</code> value, using the MD5 algorithm.
  </td>
</tr>

<tr>
  <td><a href="#sha1"><code>SHA1</code></a>
</td>
  <td>
    Computes the hash of a <code>STRING</code> or
    <code>BYTES</code> value, using the SHA-1 algorithm.
  </td>
</tr>

<tr>
  <td><a href="#sha256"><code>SHA256</code></a>
</td>
  <td>
    Computes the hash of a <code>STRING</code> or
    <code>BYTES</code> value, using the SHA-256 algorithm.
  </td>
</tr>

<tr>
  <td><a href="#sha512"><code>SHA512</code></a>
</td>
  <td>
    Computes the hash of a <code>STRING</code> or
    <code>BYTES</code> value, using the SHA-512 algorithm.
  </td>
</tr>

  </tbody>
</table>

### `FARM_FINGERPRINT`

```
FARM_FINGERPRINT(value)
```

**Description**

Computes the fingerprint of the `STRING` or `BYTES` input using the
`Fingerprint64` function from the
[open-source FarmHash library][hash-link-to-farmhash-github]. The output
of this function for a particular input will never change.

**Return type**

INT64

**Examples**

```zetasql
WITH example AS (
  SELECT 1 AS x, "foo" AS y, true AS z UNION ALL
  SELECT 2 AS x, "apple" AS y, false AS z UNION ALL
  SELECT 3 AS x, "" AS y, true AS z
)
SELECT
  *,
  FARM_FINGERPRINT(CONCAT(CAST(x AS STRING), y, CAST(z AS STRING)))
    AS row_fingerprint
FROM example;
/*---+-------+-------+----------------------*
 | x | y     | z     | row_fingerprint      |
 +---+-------+-------+----------------------+
 | 1 | foo   | true  | -1541654101129638711 |
 | 2 | apple | false | 2794438866806483259  |
 | 3 |       | true  | -4880158226897771312 |
 *---+-------+-------+----------------------*/
```

[hash-link-to-farmhash-github]: https://github.com/google/farmhash

### `MD5`

```
MD5(input)
```

**Description**

Computes the hash of the input using the
[MD5 algorithm][hash-link-to-md5-wikipedia]. The input can either be
`STRING` or `BYTES`. The string version treats the input as an array of bytes.

This function returns 16 bytes.

Warning: MD5 is no longer considered secure.
For increased security use another hashing function.

**Return type**

`BYTES`

**Example**

```zetasql
SELECT MD5("Hello World") as md5;

/*-------------------------------------------------*
 | md5                                             |
 +-------------------------------------------------+
 | \xb1\n\x8d\xb1d\xe0uA\x05\xb7\xa9\x9b\xe7.?\xe5 |
 *-------------------------------------------------*/
```

[hash-link-to-md5-wikipedia]: https://en.wikipedia.org/wiki/MD5

### `SHA1`

```
SHA1(input)
```

**Description**

Computes the hash of the input using the
[SHA-1 algorithm][hash-link-to-sha-1-wikipedia]. The input can either be
`STRING` or `BYTES`. The string version treats the input as an array of bytes.

This function returns 20 bytes.

Warning: SHA1 is no longer considered secure.
For increased security, use another hashing function.

**Return type**

`BYTES`

**Example**

```zetasql
SELECT SHA1("Hello World") as sha1;

/*-----------------------------------------------------------*
 | sha1                                                      |
 +-----------------------------------------------------------+
 | \nMU\xa8\xd7x\xe5\x02/\xabp\x19w\xc5\xd8@\xbb\xc4\x86\xd0 |
 *-----------------------------------------------------------*/
```

[hash-link-to-sha-1-wikipedia]: https://en.wikipedia.org/wiki/SHA-1

### `SHA256`

```
SHA256(input)
```

**Description**

Computes the hash of the input using the
[SHA-256 algorithm][hash-link-to-sha-2-wikipedia]. The input can either be
`STRING` or `BYTES`. The string version treats the input as an array of bytes.

This function returns 32 bytes.

**Return type**

`BYTES`

**Example**

```zetasql
SELECT SHA256("Hello World") as sha256;
```

[hash-link-to-sha-2-wikipedia]: https://en.wikipedia.org/wiki/SHA-2

### `SHA512`

```
SHA512(input)
```

**Description**

Computes the hash of the input using the
[SHA-512 algorithm][hash-link-to-sha-2-wikipedia]. The input can either be
`STRING` or `BYTES`. The string version treats the input as an array of bytes.

This function returns 64 bytes.

**Return type**

`BYTES`

**Example**

```zetasql
SELECT SHA512("Hello World") as sha512;
```

[hash-link-to-sha-2-wikipedia]: https://en.wikipedia.org/wiki/SHA-2

## HyperLogLog++ functions 
<a id="hll_functions"></a>

The [HyperLogLog++ algorithm (HLL++)][hll-sketches] estimates
[cardinality][cardinality] from sketches.

HLL++ functions are approximate aggregate functions.
Approximate aggregation typically requires less
memory than exact aggregation functions,
like [`COUNT(DISTINCT)`][count-distinct], but also introduces statistical error.
This makes HLL++ functions appropriate for large data streams for
which linear memory usage is impractical, as well as for data that is
already approximate.

A data sketch is a compact summary of a data aggregation. If you don't need
materialized sketches, you can alternatively use an
[approximate aggregate function with system-defined precision][approx-functions-reference],
such as [`APPROX_COUNT_DISTINCT`][approx-count-distinct]. However,
`APPROX_COUNT_DISTINCT` doesn't allow partial aggregations, re-aggregations,
and custom precision.

ZetaSQL supports the following HLL++ functions:

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#hll_countextract"><code>HLL_COUNT.EXTRACT</code></a>
</td>
  <td>
    Extracts a cardinality estimate of an HLL++ sketch.
  </td>
</tr>

<tr>
  <td><a href="#hll_countinit"><code>HLL_COUNT.INIT</code></a>
</td>
  <td>
    Aggregates values of the same underlying type into a new HLL++ sketch.
  </td>
</tr>

<tr>
  <td><a href="#hll_countmerge"><code>HLL_COUNT.MERGE</code></a>
</td>
  <td>
    Merges HLL++ sketches of the same underlying type into a new sketch, and
    then gets the cardinality of the new sketch.
  </td>
</tr>

<tr>
  <td><a href="#hll_countmerge_partial"><code>HLL_COUNT.MERGE_PARTIAL</code></a>
</td>
  <td>
    Merges HLL++ sketches of the same underlying type into a new sketch.
  </td>
</tr>

  </tbody>
</table>

### `HLL_COUNT.EXTRACT`

```
HLL_COUNT.EXTRACT(sketch)
```

**Description**

A scalar function that extracts a cardinality estimate of a single
[HLL++][hll-link-to-research-whitepaper] sketch.

If `sketch` is `NULL`, this function returns a cardinality estimate of `0`.

**Supported input types**

`BYTES`

**Return type**

`INT64`

**Example**

The following query returns the number of distinct users for each country who
have at least one invoice.

```zetasql
SELECT
  country,
  HLL_COUNT.EXTRACT(HLL_sketch) AS distinct_customers_with_open_invoice
FROM
  (
    SELECT
      country,
      HLL_COUNT.INIT(customer_id) AS hll_sketch
    FROM
      UNNEST(
        ARRAY<STRUCT<country STRING, customer_id STRING, invoice_id STRING>>[
          ('UA', 'customer_id_1', 'invoice_id_11'),
          ('BR', 'customer_id_3', 'invoice_id_31'),
          ('CZ', 'customer_id_2', 'invoice_id_22'),
          ('CZ', 'customer_id_2', 'invoice_id_23'),
          ('BR', 'customer_id_3', 'invoice_id_31'),
          ('UA', 'customer_id_2', 'invoice_id_24')])
    GROUP BY country
  );

/*---------+--------------------------------------*
 | country | distinct_customers_with_open_invoice |
 +---------+--------------------------------------+
 | UA      |                                    2 |
 | BR      |                                    1 |
 | CZ      |                                    1 |
 *---------+--------------------------------------*/
```

[hll-link-to-research-whitepaper]: https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/40671.pdf

### `HLL_COUNT.INIT`

```
HLL_COUNT.INIT(input [, precision])
```

**Description**

An aggregate function that takes one or more `input` values and aggregates them
into a [HLL++][hll-link-to-research-whitepaper] sketch. Each sketch
is represented using the `BYTES` data type. You can then merge sketches using
`HLL_COUNT.MERGE` or `HLL_COUNT.MERGE_PARTIAL`. If no merging is needed,
you can extract the final count of distinct values from the sketch using
`HLL_COUNT.EXTRACT`.

This function supports an optional parameter, `precision`. This parameter
defines the accuracy of the estimate at the cost of additional memory required
to process the sketches or store them on disk. The range for this value is
`10` to `24`. The default value is `15`. For more information about precision,
see [Precision for sketches][precision_hll].

If the input is `NULL`, this function returns `NULL`.

For more information, see [HyperLogLog in Practice: Algorithmic Engineering of
a State of The Art Cardinality Estimation Algorithm][hll-link-to-research-whitepaper].

**Supported input types**

+ `INT64`
+ `UINT64`
+ `NUMERIC`
+ `BIGNUMERIC`
+ `STRING`
+ `BYTES`

**Return type**

`BYTES`

**Example**

The following query creates HLL++ sketches that count the number of distinct
users with at least one invoice per country.

```zetasql
SELECT
  country,
  HLL_COUNT.INIT(customer_id, 10)
    AS hll_sketch
FROM
  UNNEST(
    ARRAY<STRUCT<country STRING, customer_id STRING, invoice_id STRING>>[
      ('UA', 'customer_id_1', 'invoice_id_11'),
      ('CZ', 'customer_id_2', 'invoice_id_22'),
      ('CZ', 'customer_id_2', 'invoice_id_23'),
      ('BR', 'customer_id_3', 'invoice_id_31'),
      ('UA', 'customer_id_2', 'invoice_id_24')])
GROUP BY country;

/*---------+------------------------------------------------------------------------------------*
 | country | hll_sketch                                                                         |
 +---------+------------------------------------------------------------------------------------+
 | UA      | "\010p\020\002\030\002 \013\202\007\r\020\002\030\n \0172\005\371\344\001\315\010" |
 | CZ      | "\010p\020\002\030\002 \013\202\007\013\020\001\030\n \0172\003\371\344\001"       |
 | BR      | "\010p\020\001\030\002 \013\202\007\013\020\001\030\n \0172\003\202\341\001"       |
 *---------+------------------------------------------------------------------------------------*/
```

[hll-link-to-research-whitepaper]: https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/40671.pdf

[precision_hll]: https://github.com/google/zetasql/blob/master/docs/sketches.md#precision_hll

### `HLL_COUNT.MERGE`

```
HLL_COUNT.MERGE(sketch)
```

**Description**

An aggregate function that returns the cardinality of several
[HLL++][hll-link-to-research-whitepaper] sketches by computing their union.

Each `sketch` must be initialized on the same type. Attempts to merge sketches
for different types results in an error. For example, you can't merge a sketch
initialized from `INT64` data with one initialized from `STRING` data.

If the merged sketches were initialized with different precisions, the precision
will be downgraded to the lowest precision involved in the merge.

This function ignores `NULL` values when merging sketches. If the merge happens
over zero rows or only over `NULL` values, the function returns `0`.

**Supported input types**

`BYTES`

**Return type**

`INT64`

**Example**

 The following query counts the number of distinct users across all countries
 who have at least one invoice.

```zetasql
SELECT HLL_COUNT.MERGE(hll_sketch) AS distinct_customers_with_open_invoice
FROM
  (
    SELECT
      country,
      HLL_COUNT.INIT(customer_id) AS hll_sketch
    FROM
      UNNEST(
        ARRAY<STRUCT<country STRING, customer_id STRING, invoice_id STRING>>[
          ('UA', 'customer_id_1', 'invoice_id_11'),
          ('BR', 'customer_id_3', 'invoice_id_31'),
          ('CZ', 'customer_id_2', 'invoice_id_22'),
          ('CZ', 'customer_id_2', 'invoice_id_23'),
          ('BR', 'customer_id_3', 'invoice_id_31'),
          ('UA', 'customer_id_2', 'invoice_id_24')])
    GROUP BY country
  );

/*--------------------------------------*
 | distinct_customers_with_open_invoice |
 +--------------------------------------+
 |                                    3 |
 *--------------------------------------*/
```

[hll-link-to-research-whitepaper]: https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/40671.pdf

### `HLL_COUNT.MERGE_PARTIAL`

```
HLL_COUNT.MERGE_PARTIAL(sketch)
```

**Description**

An aggregate function that takes one or more
[HLL++][hll-link-to-research-whitepaper] `sketch`
inputs and merges them into a new sketch.

Each `sketch` must be initialized on the same type. Attempts to merge sketches
for different types results in an error. For example, you can't merge a sketch
initialized from `INT64` data with one initialized from `STRING` data.

If the merged sketches were initialized with different precisions, the precision
will be downgraded to the lowest precision involved in the merge. For example,
if `MERGE_PARTIAL` encounters sketches of precision 14 and 15, the returned new
sketch will have precision 14.

This function returns `NULL` if there is no input or all inputs are `NULL`.

**Supported input types**

`BYTES`

**Return type**

`BYTES`

**Example**

The following query returns an HLL++ sketch that counts the number of distinct
users who have at least one invoice across all countries.

```zetasql
SELECT HLL_COUNT.MERGE_PARTIAL(HLL_sketch) AS distinct_customers_with_open_invoice
FROM
  (
    SELECT
      country,
      HLL_COUNT.INIT(customer_id) AS hll_sketch
    FROM
      UNNEST(
        ARRAY<STRUCT<country STRING, customer_id STRING, invoice_id STRING>>[
          ('UA', 'customer_id_1', 'invoice_id_11'),
          ('BR', 'customer_id_3', 'invoice_id_31'),
          ('CZ', 'customer_id_2', 'invoice_id_22'),
          ('CZ', 'customer_id_2', 'invoice_id_23'),
          ('BR', 'customer_id_3', 'invoice_id_31'),
          ('UA', 'customer_id_2', 'invoice_id_24')])
    GROUP BY country
  );

/*----------------------------------------------------------------------------------------------*
 | distinct_customers_with_open_invoice                                                         |
 +----------------------------------------------------------------------------------------------+
 | "\010p\020\006\030\002 \013\202\007\020\020\003\030\017 \0242\010\320\2408\352}\244\223\002" |
 *----------------------------------------------------------------------------------------------*/
```

[hll-link-to-research-whitepaper]: https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/40671.pdf

[hll-sketches]: https://en.wikipedia.org/wiki/HyperLogLog

[cardinality]: https://en.wikipedia.org/wiki/Cardinality

[count-distinct]: #count

[approx-count-distinct]: #approx_count_distinct

[approx-functions-reference]: #approximate_aggregate_functions

## Interval functions

ZetaSQL supports the following interval functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#extract"><code>EXTRACT</code></a>
</td>
  <td>
    Extracts part of an <code>INTERVAL</code> value.
  </td>
</tr>

<tr>
  <td><a href="#justify_days"><code>JUSTIFY_DAYS</code></a>
</td>
  <td>
    Normalizes the day part of an <code>INTERVAL</code> value.
  </td>
</tr>

<tr>
  <td><a href="#justify_hours"><code>JUSTIFY_HOURS</code></a>
</td>
  <td>
    Normalizes the time part of an <code>INTERVAL</code> value.
  </td>
</tr>

<tr>
  <td><a href="#justify_interval"><code>JUSTIFY_INTERVAL</code></a>
</td>
  <td>
    Normalizes the day and time parts of an <code>INTERVAL</code> value.
  </td>
</tr>

<tr>
  <td><a href="#make_interval"><code>MAKE_INTERVAL</code></a>
</td>
  <td>
    Constructs an <code>INTERVAL</code> value.
  </td>
</tr>

  </tbody>
</table>

### `EXTRACT`

```zetasql
EXTRACT(part FROM interval_expression)
```

**Description**

Returns the value corresponding to the specified date part. The `part` must be
one of `YEAR`, `MONTH`, `DAY`, `HOUR`, `MINUTE`, `SECOND`, `MILLISECOND` or
`MICROSECOND`.

**Return Data Type**

`INTERVAL`

**Examples**

In the following example, different parts of two intervals are extracted.

```zetasql
SELECT
  EXTRACT(YEAR FROM i) AS year,
  EXTRACT(MONTH FROM i) AS month,
  EXTRACT(DAY FROM i) AS day,
  EXTRACT(HOUR FROM i) AS hour,
  EXTRACT(MINUTE FROM i) AS minute,
  EXTRACT(SECOND FROM i) AS second,
  EXTRACT(MILLISECOND FROM i) AS milli,
  EXTRACT(MICROSECOND FROM i) AS micro
FROM
  UNNEST([INTERVAL '1-2 3 4:5:6.789999' YEAR TO SECOND,
          INTERVAL '0-13 370 48:61:61' YEAR TO SECOND]) AS i

/*------+-------+-----+------+--------+--------+-------+--------*
 | year | month | day | hour | minute | second | milli | micro  |
 +------+-------+-----+------+--------+--------+-------+--------+
 | 1    | 2     | 3   | 4    | 5      | 6      | 789   | 789999 |
 | 1    | 1     | 370 | 49   | 2      | 1      | 0     | 0      |
 *------+-------+-----+------+--------+--------+-------+--------*/
```

When a negative sign precedes the time part in an interval, the negative sign
distributes over the hours, minutes, and seconds. For example:

```zetasql
SELECT
  EXTRACT(HOUR FROM i) AS hour,
  EXTRACT(MINUTE FROM i) AS minute
FROM
  UNNEST([INTERVAL '10 -12:30' DAY TO MINUTE]) AS i

/*------+--------*
 | hour | minute |
 +------+--------+
 | -12  | -30    |
 *------+--------*/
```

When a negative sign precedes the year and month part in an interval, the
negative sign distributes over the years and months. For example:

```zetasql
SELECT
  EXTRACT(YEAR FROM i) AS year,
  EXTRACT(MONTH FROM i) AS month
FROM
  UNNEST([INTERVAL '-22-6 10 -12:30' YEAR TO MINUTE]) AS i

/*------+--------*
 | year | month  |
 +------+--------+
 | -22  | -6     |
 *------+--------*/
```

### `JUSTIFY_DAYS`

```zetasql
JUSTIFY_DAYS(interval_expression)
```

**Description**

Normalizes the day part of the interval to the range from -29 to 29 by
incrementing/decrementing the month or year part of the interval.

**Return Data Type**

`INTERVAL`

**Example**

```zetasql
SELECT
  JUSTIFY_DAYS(INTERVAL 29 DAY) AS i1,
  JUSTIFY_DAYS(INTERVAL -30 DAY) AS i2,
  JUSTIFY_DAYS(INTERVAL 31 DAY) AS i3,
  JUSTIFY_DAYS(INTERVAL -65 DAY) AS i4,
  JUSTIFY_DAYS(INTERVAL 370 DAY) AS i5

/*--------------+--------------+-------------+---------------+--------------*
 | i1           | i2           | i3          | i4            | i5           |
 +--------------+--------------+-------------+---------------+--------------+
 | 0-0 29 0:0:0 | -0-1 0 0:0:0 | 0-1 1 0:0:0 | -0-2 -5 0:0:0 | 1-0 10 0:0:0 |
 *--------------+--------------+-------------+---------------+--------------*/
```

### `JUSTIFY_HOURS`

```zetasql
JUSTIFY_HOURS(interval_expression)
```

**Description**

Normalizes the time part of the interval to the range from -23:59:59.999999 to
23:59:59.999999 by incrementing/decrementing the day part of the interval.

**Return Data Type**

`INTERVAL`

**Example**

```zetasql
SELECT
  JUSTIFY_HOURS(INTERVAL 23 HOUR) AS i1,
  JUSTIFY_HOURS(INTERVAL -24 HOUR) AS i2,
  JUSTIFY_HOURS(INTERVAL 47 HOUR) AS i3,
  JUSTIFY_HOURS(INTERVAL -12345 MINUTE) AS i4

/*--------------+--------------+--------------+-----------------*
 | i1           | i2           | i3           | i4              |
 +--------------+--------------+--------------+-----------------+
 | 0-0 0 23:0:0 | 0-0 -1 0:0:0 | 0-0 1 23:0:0 | 0-0 -8 -13:45:0 |
 *--------------+--------------+--------------+-----------------*/
```

### `JUSTIFY_INTERVAL`

```zetasql
JUSTIFY_INTERVAL(interval_expression)
```

**Description**

Normalizes the days and time parts of the interval.

**Return Data Type**

`INTERVAL`

**Example**

```zetasql
SELECT JUSTIFY_INTERVAL(INTERVAL '29 49:00:00' DAY TO SECOND) AS i

/*-------------*
 | i           |
 +-------------+
 | 0-1 1 1:0:0 |
 *-------------*/
```

### `MAKE_INTERVAL`

```zetasql
MAKE_INTERVAL(
  [ [ year => ] value ]
  [, [ month => ] value ]
  [, [ day => ] value ]
  [, [ hour => ] value ]
  [, [ minute => ] value ]
  [, [ second => ] value ]
)
```

**Description**

Constructs an [`INTERVAL`][interval-type] object using `INT64` values
representing the year, month, day, hour, minute, and second. All arguments are
optional, `0` by default, and can be [named arguments][named-arguments].

**Return Data Type**

`INTERVAL`

**Example**

```zetasql
SELECT
  MAKE_INTERVAL(1, 6, 15) AS i1,
  MAKE_INTERVAL(hour => 10, second => 20) AS i2,
  MAKE_INTERVAL(1, minute => 5, day => 2) AS i3

/*--------------+---------------+-------------*
 | i1           | i2            | i3          |
 +--------------+---------------+-------------+
 | 1-6 15 0:0:0 | 0-0 0 10:0:20 | 1-0 2 0:5:0 |
 *--------------+---------------+-------------*/
```

[interval-type]: https://github.com/google/zetasql/blob/master/docs/data-types.md#interval_type

[named-arguments]: https://github.com/google/zetasql/blob/master/docs/functions-reference.md#named_arguments

## JSON functions

ZetaSQL supports the following functions, which can retrieve and
transform JSON data.

### Categories

The JSON functions are grouped into the following categories based on their
behavior:

<!-- disableFinding(LINK_ID) -->
<table>
  <thead>
    <tr>
      <td>Category</td>
      <td width='300px'>Functions</td>
      <td>Description</td>
    </tr>
  </thead>
  <tbody>
    
    <tr>
      <td><a id="extractors"></a>
        
        Standard extractors
        
      </td>
      <td>
        
        <a href="#json_query"><code>JSON_QUERY</code></a><br>
        <a href="#json_value"><code>JSON_VALUE</code></a><br>
        
        
        <a href="#json_query_array"><code>JSON_QUERY_ARRAY</code></a><br>
        
        
        <a href="#json_value_array"><code>JSON_VALUE_ARRAY</code></a><br>
        
      </td>
      <td>
        Functions that extract JSON data.
      </td>
    </tr>
    
    
    <tr>
      <td><a id="extractors_legacy"></a>
        
        Legacy extractors
        
      </td>
      <td>
        
        <a href="#json_extract"><code>JSON_EXTRACT</code></a><br>
        <a href="#json_extract_scalar"><code>JSON_EXTRACT_SCALAR</code></a><br>
        
        
        <a href="#json_extract_array"><code>JSON_EXTRACT_ARRAY</code></a><br>
        
        
        <a href="#json_extract_string_array"><code>JSON_EXTRACT_STRING_ARRAY</code></a><br>
        
      </td>
      <td>
        Functions that extract JSON data.<br>
        
        While these functions are supported by ZetaSQL, we recommend
        using the <a href="#extractors">standard extractor functions</a>.
        
      </td>
    </tr>
    
    
    <tr>
      <td><a id="lax_converters"></a>Lax converters</td>
      <td>
        
        <a href="#lax_bool"><code>LAX_BOOL</code></a><br>
        
        
        <a href="#lax_bool_array"><code>LAX_BOOL_ARRAY</code></a><br>
        
        
        <a href="#lax_double"><code>LAX_DOUBLE</code></a><br>
        
        
        <a href="#lax_double_array"><code>LAX_DOUBLE_ARRAY</code></a><br>
        
        
        <a href="#lax_float"><code>LAX_FLOAT</code></a><br>
        
        
        <a href="#lax_float_array"><code>LAX_FLOAT_ARRAY</code></a><br>
        
        
        <a href="#lax_int32"><code>LAX_INT32</code></a><br>
        
        
        <a href="#lax_int32_array"><code>LAX_INT32_ARRAY</code></a><br>
        
        
        <a href="#lax_int64"><code>LAX_INT64</code></a><br>
        
        
        <a href="#lax_int64_array"><code>LAX_INT64_ARRAY</code></a><br>
        
        
        <a href="#lax_string"><code>LAX_STRING</code></a><br>
        
        
        <a href="#lax_string_array"><code>LAX_STRING_ARRAY</code></a><br>
        
        
        <a href="#lax_uint32"><code>LAX_UINT32</code></a><br>
        
        
        <a href="#lax_uint32_array"><code>LAX_UINT32_ARRAY</code></a><br>
        
        
        <a href="#lax_uint64"><code>LAX_UINT64</code></a><br>
        
        
        <a href="#lax_uint64_array"><code>LAX_UINT64_ARRAY</code></a><br>
        
      </td>
      <td>
        Functions that flexibly convert a JSON value to a SQL value without
        returning errors.
      </td>
    </tr>
    
    
    <tr>
      <td><a id="converters"></a>Converters</td>
      <td>
        
        <a href="#bool_for_json"><code>BOOL</code></a><br>
        
        
        <a href="#bool_array_for_json"><code>BOOL_ARRAY</code></a><br>
        
        
        <a href="#double_for_json"><code>DOUBLE</code></a><br>
        
        
        <a href="#double_array_for_json"><code>DOUBLE_ARRAY</code></a><br>
        
        
        <a href="#float_for_json"><code>FLOAT</code></a><br>
        
        
        <a href="#float_array_for_json"><code>FLOAT_ARRAY</code></a><br>
        
        
        <a href="#int32_for_json"><code>INT32</code></a><br>
        
        
        <a href="#int32_array_for_json"><code>INT32_ARRAY</code></a><br>
        
        
        <a href="#int64_for_json"><code>INT64</code></a><br>
        
        
        <a href="#int64_array_for_json"><code>INT64_ARRAY</code></a><br>
        
        
        <a href="#string_for_json"><code>STRING</code></a><br>
        
        
        <a href="#string_array_for_json"><code>STRING_ARRAY</code></a><br>
        
        
        <a href="#uint32_for_json"><code>UINT32</code></a><br>
        
        
        <a href="#uint32_array_for_json"><code>UINT32_ARRAY</code></a><br>
        
        
        <a href="#uint64_for_json"><code>UINT64</code></a><br>
        
        
        <a href="#uint64_array_for_json"><code>UINT64_ARRAY</code></a><br>
        
      </td>
      <td>
        Functions that convert a JSON value to a SQL value.
      </td>
    </tr>
    
    
    <tr>
      <td><a id="other_converters"></a>Other converters</td>
      <td>
        
        <a href="#parse_json"><code>PARSE_JSON</code></a><br>
        
        
        <a href="#to_json"><code>TO_JSON</code></a><br>
        
        
        <a href="#safe_to_json"><code>SAFE_TO_JSON</code></a><br>
        
        
        <a href="#to_json_string"><code>TO_JSON_STRING</code></a><br>
        
      </td>
      <td>
        Other conversion functions from or to JSON.
      </td>
    </tr>
    
    
    <tr>
      <td><a id="constructors"></a>Constructors</td>
      <td>
        <a href="#json_array"><code>JSON_ARRAY</code></a><br>
        <a href="#json_object"><code>JSON_OBJECT</code></a><br>
      </td>
      <td>
        Functions that create JSON.
      </td>
    </tr>
    
    
    <tr>
      <td><a id="mutators"></a>Mutators</td>
      <td>
        
        <a href="#json_array_append"><code>JSON_ARRAY_APPEND</code></a><br>
        
        
        <a href="#json_array_insert"><code>JSON_ARRAY_INSERT</code></a><br>
        
        
        <a href="#json_remove"><code>JSON_REMOVE</code></a><br>
        
        
        <a href="#json_set"><code>JSON_SET</code></a><br>
        
        
        <a href="#json_strip_nulls"><code>JSON_STRIP_NULLS</code></a><br>
        
      </td>
      <td>
        Functions that mutate existing JSON.
      </td>
    </tr>
    
    
    <tr>
      <td><a id="accessors"></a>Accessors</td>
      <td>
        
        
        <a href="#json_type"><code>JSON_TYPE</code></a><br>
        
      </td>
      <td>
        Functions that provide access to JSON properties.
      </td>
    </tr>
    
    <tr>
      <td><a id="predicates"></a>Predicates</td>
      <td>
        
        <a href="#json_contains"><code>JSON_CONTAINS</code></a><br>
        
      </td>
      <td>
        Functions that return <code>BOOL</code> when checking JSON documents for
        certain properties.
      </td>
    </tr>
    
  </tbody>
</table>
<!-- enableFinding(LINK_ID) -->

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#bool_for_json"><code>BOOL</code></a>
</td>
  <td>
    Converts a JSON boolean to a SQL <code>BOOL</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#bool_array_for_json"><code>BOOL_ARRAY</code></a>
</td>
  <td>
    Converts a JSON array of booleans to a
    SQL <code>ARRAY&lt;BOOL&gt;</code> value.
    
  </td>
</tr>

<tr>
  <td>
  
  <a href="#double_for_json"><code>DOUBLE</code></a>

  
  </td>
  <td>
    Converts a JSON number to a SQL
    <code>DOUBLE</code> value.
  </td>
</tr>

<tr>
  <td>
    
      <a href="#double_array_for_json"><code>DOUBLE_ARRAY</code></a>

    
  </td>
  <td> Converts a JSON array of numbers to a SQL <code>ARRAY&lt;DOUBLE&gt;</code> value.</td>
</tr>

<tr>
  <td>
    
      <a href="#float_for_json"><code>FLOAT</code></a>

    
  </td>
  <td> Converts a JSON number to a SQL <code>FLOAT</code> value.</td>
</tr>

<tr>
  <td>
    
      <a href="#float_array_for_json"><code>FLOAT_ARRAY</code></a>

    
  </td>
  <td>Converts a JSON array of numbers to a SQL <code>ARRAY&lt;FLOAT&gt;</code> value.</td>
</tr>

<tr>
  <td><a href="#int32_for_json"><code>INT32</code></a>
</td>
  <td>
    Converts a JSON number to a SQL <code>INT32</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#int32_array_for_json"><code>INT32_ARRAY</code></a>
</td>
  <td>
    Converts a JSON number to a SQL <code>ARRAY&lt;INT32&gt;</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#int64_for_json"><code>INT64</code></a>
</td>
  <td>
    Converts a JSON number to a SQL <code>INT64</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#int64_array_for_json"><code>INT64_ARRAY</code></a>
</td>
  <td>
    Converts a JSON array of numbers to a
    SQL <code>ARRAY&lt;INT64&gt;</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#json_array"><code>JSON_ARRAY</code></a>
</td>
  <td>
    Creates a JSON array.
    
  </td>
</tr>

<tr>
  <td><a href="#json_array_append"><code>JSON_ARRAY_APPEND</code></a>
</td>
  <td>
    Appends JSON data to the end of a JSON array.
    
  </td>
</tr>

<tr>
  <td><a href="#json_array_insert"><code>JSON_ARRAY_INSERT</code></a>
</td>
  <td>
    Inserts JSON data into a JSON array.
    
  </td>
</tr>

<tr>
  <td><a href="#json_contains"><code>JSON_CONTAINS</code></a>
</td>
  <td>
    Checks if a JSON document contains another JSON document.
    
  </td>
</tr>

<tr>
  <td><a href="#json_extract"><code>JSON_EXTRACT</code></a>
</td>
  <td>
    (Deprecated)
    Extracts a JSON value and converts it to a SQL
    JSON-formatted <code>STRING</code>
     or
    <code>JSON</code>
    
    value.
  </td>
</tr>

<tr>
  <td><a href="#json_extract_array"><code>JSON_EXTRACT_ARRAY</code></a>
</td>
  <td>
    (Deprecated)
    Extracts a JSON array and converts it to
    a SQL <code>ARRAY&lt;JSON-formatted STRING&gt;</code>
     or
    <code>ARRAY&lt;JSON&gt;</code>
    
    value.
    
  </td>
</tr>

<tr>
  <td><a href="#json_extract_scalar"><code>JSON_EXTRACT_SCALAR</code></a>
</td>
  <td>
    (Deprecated)
    Extracts a JSON scalar value and converts it to a SQL
    <code>STRING</code> value.
  </td>
</tr>

<tr>
  <td><a href="#json_extract_string_array"><code>JSON_EXTRACT_STRING_ARRAY</code></a>
</td>
  <td>
    (Deprecated)
    Extracts a JSON array of scalar values and converts it to a SQL
    <code>ARRAY&lt;STRING&gt;</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#json_object"><code>JSON_OBJECT</code></a>
</td>
  <td>Creates a JSON object.</td>
</tr>

<tr>
  <td><a href="#json_query"><code>JSON_QUERY</code></a>
</td>
  <td>
    Extracts a JSON value and converts it to a SQL
    JSON-formatted <code>STRING</code>
     or
    <code>JSON</code>
    
    value.
  </td>
</tr>

<tr>
  <td><a href="#json_query_array"><code>JSON_QUERY_ARRAY</code></a>
</td>
  <td>
    Extracts a JSON array and converts it to
    a SQL <code>ARRAY&lt;JSON-formatted STRING&gt;</code>
     or
    <code>ARRAY&lt;JSON&gt;</code>
    
    value.
    
  </td>
</tr>

<tr>
  <td><a href="#json_remove"><code>JSON_REMOVE</code></a>
</td>
  <td>Produces JSON with the specified JSON data removed.</td>
</tr>

<tr>
  <td><a href="#json_set"><code>JSON_SET</code></a>
</td>
  <td>Inserts or replaces JSON data.</td>
</tr>

<tr>
  <td><a href="#json_strip_nulls"><code>JSON_STRIP_NULLS</code></a>
</td>
  <td>Removes JSON nulls from JSON objects and JSON arrays.</td>
</tr>

<tr>
  <td><a href="#json_type"><code>JSON_TYPE</code></a>
</td>
  <td>
    Gets the JSON type of the outermost JSON value and converts the name of
    this type to a SQL <code>STRING</code> value.
  </td>
</tr>

<tr>
  <td><a href="#json_value"><code>JSON_VALUE</code></a>
</td>
  <td>
    Extracts a JSON scalar value and converts it to a SQL
    <code>STRING</code> value.
  </td>
</tr>

<tr>
  <td><a href="#json_value_array"><code>JSON_VALUE_ARRAY</code></a>
</td>
  <td>
    Extracts a JSON array of scalar values and converts it to a SQL
    <code>ARRAY&lt;STRING&gt;</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#lax_bool"><code>LAX_BOOL</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a SQL <code>BOOL</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#lax_bool_array"><code>LAX_BOOL_ARRAY</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;BOOL&gt;</code> value.
    
  </td>
</tr>

<tr>
  <td>
  
  <a href="#lax_double"><code>LAX_DOUBLE</code></a>

  
  </td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>DOUBLE</code> value.
    
  </td>
</tr>

<tr>
  <td>
    
      <a href="#lax_double_array"><code>LAX_DOUBLE_ARRAY</code></a>

    
  </td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;DOUBLE&gt;</code> value.
    
  </td>
</tr>

<tr>
  <td>
    
      <a href="#lax_float"><code>LAX_FLOAT</code></a>

    
  </td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>FLOAT</code> value.
    
  </td>
</tr>

<tr>
  <td>
    
      <a href="#lax_float_array"><code>LAX_FLOAT_ARRAY</code></a>

    
  </td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&gt;FLOAT&lt;</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#lax_int32"><code>LAX_INT32</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a SQL <code>INT32</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#lax_int32_array"><code>LAX_INT32_ARRAY</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;INT32&gt;</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#lax_int64"><code>LAX_INT64</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a SQL <code>INT64</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#lax_int64_array"><code>LAX_INT64_ARRAY</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;INT64&gt;</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#lax_string"><code>LAX_STRING</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a SQL <code>STRING</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#lax_string_array"><code>LAX_STRING_ARRAY</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;STRING&gt;</code>value.
    
  </td>
</tr>

<tr>
  <td><a href="#lax_uint32"><code>LAX_UINT32</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a SQL <code>UINT32</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#lax_uint32_array"><code>LAX_UINT32_ARRAY</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;UINT32&gt;</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#lax_uint64"><code>LAX_UINT64</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a SQL <code>UINT64</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#lax_uint64_array"><code>LAX_UINT64_ARRAY</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;UINT64&gt;</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#parse_json"><code>PARSE_JSON</code></a>
</td>
  <td>
    Converts a JSON-formatted <code>STRING</code> value to a
    <code>JSON</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#safe_to_json"><code>SAFE_TO_JSON</code></a>
</td>
  <td>
    Similar to the `TO_JSON` function, but for each unsupported field in the
    input argument, produces a JSON null instead of an error.
  </td>
</tr>

<tr>
  <td><a href="#string_for_json"><code>STRING</code> (JSON)</a>
</td>
  <td>
    Converts a JSON string to a SQL <code>STRING</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#string_array_for_json"><code>STRING_ARRAY</code></a>
</td>
  <td>
    Converts a JSON array of strings to a SQL <code>ARRAY&lt;STRING&gt;</code>
    value.
    
  </td>
</tr>

<tr>
  <td><a href="#to_json"><code>TO_JSON</code></a>
</td>
  <td>
    Converts a SQL value to a JSON value.
    
  </td>
</tr>

<tr>
  <td><a href="#to_json_string"><code>TO_JSON_STRING</code></a>
</td>
  <td>
    Converts a SQL value to a JSON-formatted <code>STRING</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#uint32_for_json"><code>UINT32</code></a>
</td>
  <td>
    Converts a JSON number to a SQL <code>UINT32</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#uint32_array_for_json"><code>UINT32_ARRAY</code></a>
</td>
  <td>
    Converts a JSON number to a
    SQL <code>ARRAY&lt;UINT32&gt;</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#uint64_for_json"><code>UINT64</code></a>
</td>
  <td>
    Converts a JSON number to a SQL <code>UINT64</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#uint64_array_for_json"><code>UINT64_ARRAY</code></a>
</td>
  <td>
    Converts a JSON number to a SQL <code>ARRAY&lt;UINT64&gt;</code> value.
    
  </td>
</tr>

  </tbody>
</table>

### `BOOL` 
<a id="bool_for_json"></a>

```zetasql
BOOL(json_expr)
```

**Description**

Converts a JSON boolean to a SQL `BOOL` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON 'true'
    ```

    If the JSON value isn't a boolean, an error is produced. If the expression
    is SQL `NULL`, the function returns SQL `NULL`.

**Return type**

`BOOL`

**Examples**

```zetasql
SELECT BOOL(JSON 'true') AS vacancy;

/*---------*
 | vacancy |
 +---------+
 | true    |
 *---------*/
```

```zetasql
SELECT BOOL(JSON_QUERY(JSON '{"hotel class": "5-star", "vacancy": true}', "$.vacancy")) AS vacancy;

/*---------*
 | vacancy |
 +---------+
 | true    |
 *---------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if JSON isn't of type bool.
SELECT BOOL(JSON '123') AS result; -- Throws an error
SELECT BOOL(JSON 'null') AS result; -- Throws an error
SELECT SAFE.BOOL(JSON '123') AS result; -- Returns a SQL NULL
```

### `BOOL_ARRAY` 
<a id="bool_array_for_json"></a>

```zetasql
BOOL_ARRAY(json_expr)
```

**Description**

Converts a JSON array of booleans to a SQL `ARRAY<BOOL>` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[true]'
    ```

    If the JSON value isn't an array of booleans, an error is produced. If the
    expression is SQL `NULL`, the function returns SQL `NULL`.

**Return type**

`ARRAY<BOOL>`

**Examples**

```zetasql
SELECT BOOL_ARRAY(JSON '[true, false]') AS vacancies;

/*---------------*
 | vacancies     |
 +---------------+
 | [true, false] |
 *---------------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if the JSON isn't an array of booleans.
SELECT BOOL_ARRAY(JSON '[123]') AS result; -- Throws an error
SELECT BOOL_ARRAY(JSON '[null]') AS result; -- Throws an error
SELECT BOOL_ARRAY(JSON 'null') AS result; -- Throws an error
```

### `DOUBLE` 
<a id="double_for_json"></a>

```zetasql
DOUBLE(
  json_expr
  [, wide_number_mode => { 'exact' | 'round' } ]
)
```

**Description**

Converts a JSON number to a SQL `DOUBLE` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '9.8'
    ```

    If the JSON value isn't a number, an error is produced. If the expression
    is a SQL `NULL`, the function returns SQL `NULL`.
+   `wide_number_mode`: A named argument with a `STRING` value.
    Defines what happens with a number that can't be
    represented as a `DOUBLE` without loss of
    precision. This argument accepts one of the two case-sensitive values:

    +   `exact`: The function fails if the result can't be represented as a
        `DOUBLE` without loss of precision.
    +   `round` (default): The numeric value stored in JSON will be rounded to
        `DOUBLE`. If such rounding isn't possible,
        the function fails.

**Return type**

`DOUBLE`

**Examples**

```zetasql
SELECT DOUBLE(JSON '9.8') AS velocity;

/*----------*
 | velocity |
 +----------+
 | 9.8      |
 *----------*/
```

```zetasql
SELECT DOUBLE(JSON_QUERY(JSON '{"vo2_max": 39.1, "age": 18}', "$.vo2_max")) AS vo2_max;

/*---------*
 | vo2_max |
 +---------+
 | 39.1    |
 *---------*/
```

```zetasql
SELECT DOUBLE(JSON '18446744073709551615', wide_number_mode=>'round') as result;

/*------------------------*
 | result                 |
 +------------------------+
 | 1.8446744073709552e+19 |
 *------------------------*/
```

```zetasql
SELECT DOUBLE(JSON '18446744073709551615') as result;

/*------------------------*
 | result                 |
 +------------------------+
 | 1.8446744073709552e+19 |
 *------------------------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if JSON isn't of type DOUBLE.
SELECT DOUBLE(JSON '"strawberry"') AS result;
SELECT DOUBLE(JSON 'null') AS result;

-- An error is thrown because `wide_number_mode` is case-sensitive and not "exact" or "round".
SELECT DOUBLE(JSON '123.4', wide_number_mode=>'EXACT') as result;
SELECT DOUBLE(JSON '123.4', wide_number_mode=>'exac') as result;

-- An error is thrown because the number can't be converted to DOUBLE without loss of precision
SELECT DOUBLE(JSON '18446744073709551615', wide_number_mode=>'exact') as result;

-- Returns a SQL NULL
SELECT SAFE.DOUBLE(JSON '"strawberry"') AS result;
```

### `DOUBLE_ARRAY` 
<a id="double_array_for_json"></a>

```zetasql
DOUBLE_ARRAY(
  json_expr
  [, wide_number_mode => { 'exact' | 'round' } ]
)
```

**Description**

Converts a JSON array of numbers to a SQL `ARRAY<DOUBLE>` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[9.8]'
    ```

    If the JSON value isn't an array of numbers, an error is produced. If the
    expression is a SQL `NULL`, the function returns SQL `NULL`.
+   `wide_number_mode`: A named argument that takes a `STRING` value. Defines
    what happens with a number that can't be represented as a
    `DOUBLE` without loss of precision. This argument accepts
    one of the two case-sensitive values:

    +   `exact`: The function fails if the result can't be represented as a
        `DOUBLE` without loss of precision.
    +   `round` (default): The numeric value stored in JSON will be rounded to
        `DOUBLE`. If such rounding isn't possible, the
        function fails.

**Return type**

`ARRAY<DOUBLE>`

**Examples**

```zetasql
SELECT DOUBLE_ARRAY(JSON '[9, 9.8]') AS velocities;

/*-------------*
 | velocities  |
 +-------------+
 | [9.0, 9.8]  |
 *-------------*/
```

```zetasql
SELECT DOUBLE_ARRAY(JSON '[18446744073709551615]', wide_number_mode=>'round') as result;

/*--------------------------*
 | result                   |
 +--------------------------+
 | [1.8446744073709552e+19] |
 *--------------------------*/
```

```zetasql
SELECT DOUBLE_ARRAY(JSON '[18446744073709551615]') as result;

/*--------------------------*
 | result                   |
 +--------------------------+
 | [1.8446744073709552e+19] |
 *--------------------------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if the JSON isn't an array of numbers.
SELECT DOUBLE_ARRAY(JSON '["strawberry"]') AS result;
SELECT DOUBLE_ARRAY(JSON '[null]') AS result;
SELECT DOUBLE_ARRAY(JSON 'null') AS result;

-- An error is thrown because `wide_number_mode` is case-sensitive and not "exact" or "round".
SELECT DOUBLE_ARRAY(JSON '[123.4]', wide_number_mode=>'EXACT') as result;
SELECT DOUBLE_ARRAY(JSON '[123.4]', wide_number_mode=>'exac') as result;

-- An error is thrown because the number can't be converted to DOUBLE without loss of precision
SELECT DOUBLE_ARRAY(JSON '[18446744073709551615]', wide_number_mode=>'exact') as result;
```

### `FLOAT` 
<a id="float_for_json"></a>

```zetasql
FLOAT(
  json_expr
  [, [ wide_number_mode => ] { 'exact' | 'round' } ]
)
```

**Description**

Converts a JSON number to a SQL `FLOAT` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '9.8'
    ```

    If the JSON value isn't a number, an error is produced. If the expression
    is a SQL `NULL`, the function returns SQL `NULL`.
+   `wide_number_mode`: A named argument with a `STRING` value. Defines what
    happens with a number that can't be represented as a
    `FLOAT` without loss of precision. This argument accepts
    one of the two case-sensitive values:

    +   `exact`: The function fails if the result can't be represented as a
        `FLOAT` without loss of precision.
    +   `round` (default): The numeric value stored in JSON will be rounded to
        `FLOAT`. If such rounding isn't possible, the function
        fails.

**Return type**

`FLOAT`

**Examples**

```zetasql
SELECT FLOAT(JSON '9.8') AS velocity;

/*----------*
 | velocity |
 +----------+
 | 9.8      |
 *----------*/
```

```zetasql
SELECT FLOAT(JSON_QUERY(JSON '{"vo2_max": 39.1, "age": 18}', "$.vo2_max")) AS vo2_max;

/*---------*
 | vo2_max |
 +---------+
 | 39.1    |
 *---------*/
```

```zetasql
SELECT FLOAT(JSON '16777217', wide_number_mode=>'round') as result;

/*------------*
 | result     |
 +------------+
 | 16777216.0 |
 *------------*/
```

```zetasql
SELECT FLOAT(JSON '16777216') as result;

/*------------*
 | result     |
 +------------+
 | 16777216.0 |
 *------------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if JSON isn't of type FLOAT.
SELECT FLOAT(JSON '"strawberry"') AS result;
SELECT FLOAT(JSON 'null') AS result;

-- An error is thrown because `wide_number_mode` is case-sensitive and not "exact" or "round".
SELECT FLOAT(JSON '123.4', wide_number_mode=>'EXACT') as result;
SELECT FLOAT(JSON '123.4', wide_number_mode=>'exac') as result;

-- An error is thrown because the number can't be converted to FLOAT without loss of precision
SELECT FLOAT(JSON '16777217', wide_number_mode=>'exact') as result;

-- Returns a SQL NULL
SELECT SAFE.FLOAT(JSON '"strawberry"') AS result;
```

### `FLOAT_ARRAY` 
<a id="float_array_for_json"></a>

```zetasql
FLOAT_ARRAY(
  json_expr
  [, wide_number_mode => { 'exact' | 'round' } ]
)
```

**Description**

Converts a JSON array of numbers to a SQL `ARRAY<FLOAT>` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[9.8]'
    ```

    If the JSON value isn't an array of numbers, an error is produced. If the
    expression is a SQL `NULL`, the function returns SQL `NULL`.
+   `wide_number_mode`: A named argument with a `STRING` value. Defines
    what happens with a number that can't be represented as a
    `FLOAT` without loss of precision. This argument accepts
    one of the two case-sensitive values:

    +   `exact`: The function fails if the result can't be represented as a
        `FLOAT` without loss of precision.
    +   `round` (default): The numeric value stored in JSON will be rounded to
        `FLOAT`. If such rounding isn't possible, the function
        fails.

**Return type**

`ARRAY<FLOAT>`

**Examples**

```zetasql
SELECT FLOAT_ARRAY(JSON '[9, 9.8]') AS velocities;

/*-------------*
 | velocities  |
 +-------------+
 | [9.0, 9.8]  |
 *-------------*/
```

```zetasql
SELECT FLOAT_ARRAY(JSON '[16777217]', wide_number_mode=>'round') as result;

/*--------------*
 | result       |
 +--------------+
 | [16777216.0] |
 *--------------*/
```

```zetasql
SELECT FLOAT_ARRAY(JSON '[16777216]') as result;

/*--------------*
 | result       |
 +--------------+
 | [16777216.0] |
 *--------------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if the JSON isn't an array of numbers in FLOAT domain.
SELECT FLOAT_ARRAY(JSON '["strawberry"]') AS result;
SELECT FLOAT_ARRAY(JSON '[null]') AS result;
SELECT FLOAT_ARRAY(JSON 'null') AS result;

-- An error is thrown because `wide_number_mode` is case-sensitive and not "exact" or "round".
SELECT FLOAT_ARRAY(JSON '[123.4]', wide_number_mode=>'EXACT') as result;
SELECT FLOAT_ARRAY(JSON '[123.4]', wide_number_mode=>'exac') as result;

-- An error is thrown because the number can't be converted to FLOAT without loss of precision
SELECT FLOAT_ARRAY(JSON '[16777217]', wide_number_mode=>'exact') as result;
```

### `INT32` 
<a id="int32_for_json"></a>

```zetasql
INT32(json_expr)
```

**Description**

Converts a JSON number to a SQL `INT32` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '999'
    ```

    If the JSON value isn't a number, or the JSON number isn't in the SQL
    `INT32` domain, an error is produced. If the expression is SQL `NULL`, the
    function returns SQL `NULL`.

**Return type**

`INT32`

**Examples**

```zetasql
SELECT INT32(JSON '2005') AS flight_number;

/*---------------*
 | flight_number |
 +---------------+
 | 2005          |
 *---------------*/
```

```zetasql
SELECT INT32(JSON_QUERY(JSON '{"gate": "A4", "flight_number": 2005}', "$.flight_number")) AS flight_number;

/*---------------*
 | flight_number |
 +---------------+
 | 2005          |
 *---------------*/
```

```zetasql
SELECT INT32(JSON '10.0') AS score;

/*-------*
 | score |
 +-------+
 | 10    |
 *-------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if JSON isn't a number or can't be converted to a 64-bit integer.
SELECT INT32(JSON '10.1') AS result;  -- Throws an error
SELECT INT32(JSON '"strawberry"') AS result; -- Throws an error
SELECT INT32(JSON 'null') AS result; -- Throws an error
SELECT SAFE.INT32(JSON '"strawberry"') AS result;  -- Returns a SQL NULL
```

### `INT32_ARRAY` 
<a id="int32_array_for_json"></a>

```zetasql
INT32_ARRAY(json_expr)
```

**Description**

Converts a JSON number to a SQL `INT32_ARRAY` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[999]'
    ```

    If the JSON value isn't an array of numbers, or the JSON numbers aren't in
    the SQL `INT32` domain, an error is produced. If the expression is SQL
    `NULL`, the function returns SQL `NULL`.

**Return type**

`ARRAY<INT32>`

**Examples**

```zetasql
SELECT INT32_ARRAY(JSON '[2005, 2003]') AS flight_numbers;

/*----------------*
 | flight_numbers |
 +----------------+
 | [2005, 2003]   |
 *----------------*/
```

```zetasql
SELECT INT32_ARRAY(JSON '[10.0]') AS scores;

/*--------*
 | scores |
 +--------+
 | [10]   |
 *--------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if the JSON isn't an array of numbers in INT32 domain.
SELECT INT32_ARRAY(JSON '[10.1]') AS result;  -- Throws an error
SELECT INT32_ARRAY(JSON '["strawberry"]') AS result; -- Throws an error
SELECT INT32_ARRAY(JSON '[null]') AS result; -- Throws an error
SELECT INT32_ARRAY(JSON 'null') AS result; -- Throws an error
```

### `INT64` 
<a id="int64_for_json"></a>

```zetasql
INT64(json_expr)
```

**Description**

Converts a JSON number to a SQL `INT64` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '999'
    ```

    If the JSON value isn't a number, or the JSON number isn't in the SQL
    `INT64` domain, an error is produced. If the expression is SQL `NULL`, the
    function returns SQL `NULL`.

**Return type**

`INT64`

**Examples**

```zetasql
SELECT INT64(JSON '2005') AS flight_number;

/*---------------*
 | flight_number |
 +---------------+
 | 2005          |
 *---------------*/
```

```zetasql
SELECT INT64(JSON_QUERY(JSON '{"gate": "A4", "flight_number": 2005}', "$.flight_number")) AS flight_number;

/*---------------*
 | flight_number |
 +---------------+
 | 2005          |
 *---------------*/
```

```zetasql
SELECT INT64(JSON '10.0') AS score;

/*-------*
 | score |
 +-------+
 | 10    |
 *-------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if JSON isn't a number or can't be converted to a 64-bit integer.
SELECT INT64(JSON '10.1') AS result;  -- Throws an error
SELECT INT64(JSON '"strawberry"') AS result; -- Throws an error
SELECT INT64(JSON 'null') AS result; -- Throws an error
SELECT SAFE.INT64(JSON '"strawberry"') AS result;  -- Returns a SQL NULL
```

### `INT64_ARRAY` 
<a id="int64_array_for_json"></a>

```zetasql
INT64_ARRAY(json_expr)
```

**Description**

Converts a JSON array of numbers to a SQL `INT64_ARRAY` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[999]'
    ```

    If the JSON value isn't an array of numbers, or the JSON numbers aren't in
    the SQL `INT64` domain, an error is produced. If the expression is SQL
    `NULL`, the function returns SQL `NULL`.

**Return type**

`ARRAY<INT64>`

**Examples**

```zetasql
SELECT INT64_ARRAY(JSON '[2005, 2003]') AS flight_numbers;

/*----------------*
 | flight_numbers |
 +----------------+
 | [2005, 2003]   |
 *----------------*/
```

```zetasql
SELECT INT64_ARRAY(JSON '[10.0]') AS scores;

/*--------*
 | scores |
 +--------+
 | [10]   |
 *--------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if the JSON isn't an array of numbers in INT64 domain.
SELECT INT64_ARRAY(JSON '[10.1]') AS result;  -- Throws an error
SELECT INT64_ARRAY(JSON '["strawberry"]') AS result; -- Throws an error
SELECT INT64_ARRAY(JSON '[null]') AS result; -- Throws an error
SELECT INT64_ARRAY(JSON 'null') AS result; -- Throws an error
```

### `JSON_ARRAY`

```zetasql
JSON_ARRAY([value][, ...])
```

**Description**

Creates a JSON array from zero or more SQL values.

Arguments:

+   `value`: A [JSON encoding-supported][json-encodings] value to add
    to a JSON array.

**Return type**

`JSON`

**Examples**

The following query creates a JSON array with one value in it:

```zetasql
SELECT JSON_ARRAY(10) AS json_data

/*-----------*
 | json_data |
 +-----------+
 | [10]      |
 *-----------*/
```

You can create a JSON array with an empty JSON array in it. For example:

```zetasql
SELECT JSON_ARRAY([]) AS json_data

/*-----------*
 | json_data |
 +-----------+
 | [[]]      |
 *-----------*/
```

```zetasql
SELECT JSON_ARRAY(10, 'foo', NULL) AS json_data

/*-----------------*
 | json_data       |
 +-----------------+
 | [10,"foo",null] |
 *-----------------*/
```

```zetasql
SELECT JSON_ARRAY(STRUCT(10 AS a, 'foo' AS b)) AS json_data

/*----------------------*
 | json_data            |
 +----------------------+
 | [{"a":10,"b":"foo"}] |
 *----------------------*/
```

```zetasql
SELECT JSON_ARRAY(10, ['foo', 'bar'], [20, 30]) AS json_data

/*----------------------------*
 | json_data                  |
 +----------------------------+
 | [10,["foo","bar"],[20,30]] |
 *----------------------------*/
```

```zetasql
SELECT JSON_ARRAY(10, [JSON '20', JSON '"foo"']) AS json_data

/*-----------------*
 | json_data       |
 +-----------------+
 | [10,[20,"foo"]] |
 *-----------------*/
```

You can create an empty JSON array. For example:

```zetasql
SELECT JSON_ARRAY() AS json_data

/*-----------*
 | json_data |
 +-----------+
 | []        |
 *-----------*/
```

### `JSON_ARRAY_APPEND`

```zetasql
JSON_ARRAY_APPEND(
  json_expr,
  json_path_value_pair[, ...]
  [, append_each_element => { TRUE | FALSE } ]
)

json_path_value_pair:
  json_path, value
```

Appends JSON data to the end of a JSON array.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '["a", "b", "c"]'
    ```
+   `json_path_value_pair`: A value and the [JSONPath][JSONPath-format] for
    that value. This includes:

    +   `json_path`: Append `value` at this [JSONPath][JSONPath-format]
        in `json_expr`.

    +   `value`: A [JSON encoding-supported][json-encodings] value to
        append.
+   `append_each_element`: A named argument with a `BOOL` value.

    +   If `TRUE` (default), and `value` is a SQL array,
        appends each element individually.

    +   If `FALSE,` and `value` is a SQL array, appends
        the array as one element.

Details:

+   Path value pairs are evaluated left to right. The JSON produced by
    evaluating one pair becomes the JSON against which the next pair
    is evaluated.
+   The operation is ignored if the path points to a JSON non-array value that
    isn't a JSON null.
+   If `json_path` points to a JSON null, the JSON null is replaced by a
    JSON array that contains `value`.
+   If the path exists but has an incompatible type at any given path token,
    the path value pair operation is ignored.
+   The function applies all path value pair append operations even if an
    individual path value pair operation is invalid. For invalid operations,
    the operation is ignored and the function continues to process the rest of
    the path value pairs.
+   If any `json_path` is an invalid [JSONPath][JSONPath-format], an error is
    produced.
+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   If `append_each_element` is SQL `NULL`, the function returns `json_expr`.
+   If `json_path` is SQL `NULL`, the `json_path_value_pair` operation is
    ignored.

**Return type**

`JSON`

**Examples**

In the following example, path `$` is matched and appends `1`.

```zetasql
SELECT JSON_ARRAY_APPEND(JSON '["a", "b", "c"]', '$', 1) AS json_data

/*-----------------*
 | json_data       |
 +-----------------+
 | ["a","b","c",1] |
 *-----------------*/
```

In the following example, `append_each_element` defaults to `TRUE`, so
`[1, 2]` is appended as individual elements.

```zetasql
SELECT JSON_ARRAY_APPEND(JSON '["a", "b", "c"]', '$', [1, 2]) AS json_data

/*-------------------*
 | json_data         |
 +-------------------+
 | ["a","b","c",1,2] |
 *-------------------*/
```

In the following example, `append_each_element` is `FALSE`, so
`[1, 2]` is appended as one element.

```zetasql
SELECT JSON_ARRAY_APPEND(
  JSON '["a", "b", "c"]',
  '$', [1, 2],
  append_each_element=>FALSE) AS json_data

/*---------------------*
 | json_data           |
 +---------------------+
 | ["a","b","c",[1,2]] |
 *---------------------*/
```

In the following example, `append_each_element` is `FALSE`, so
`[1, 2]` and `[3, 4]` are each appended as one element.

```zetasql
SELECT JSON_ARRAY_APPEND(
  JSON '["a", ["b"], "c"]',
  '$[1]', [1, 2],
  '$[1][1]', [3, 4],
  append_each_element=>FALSE) AS json_data

/*-----------------------------*
 | json_data                   |
 +-----------------------------+
 | ["a",["b",[1,2,[3,4]]],"c"] |
 *-----------------------------*/
```

In the following example, the first path `$[1]` appends `[1, 2]` as single
elements, and then the second path `$[1][1]` isn't a valid path to an array,
so the second operation is ignored.

```zetasql
SELECT JSON_ARRAY_APPEND(
  JSON '["a", ["b"], "c"]',
  '$[1]', [1, 2],
  '$[1][1]', [3, 4]) AS json_data

/*---------------------*
 | json_data           |
 +---------------------+
 | ["a",["b",1,2],"c"] |
 *---------------------*/
```

In the following example, path `$.a` is matched and appends `2`.

```zetasql
SELECT JSON_ARRAY_APPEND(JSON '{"a": [1]}', '$.a', 2) AS json_data

/*-------------*
 | json_data   |
 +-------------+
 | {"a":[1,2]} |
 *-------------*/
```

In the following example, a value is appended into a JSON null.

```zetasql
SELECT JSON_ARRAY_APPEND(JSON '{"a": null}', '$.a', 10)

/*------------*
 | json_data  |
 +------------+
 | {"a":[10]} |
 *------------*/
```

In the following example, path `$.a` isn't an array, so the operation is
ignored.

```zetasql
SELECT JSON_ARRAY_APPEND(JSON '{"a": 1}', '$.a', 2) AS json_data

/*-----------*
 | json_data |
 +-----------+
 | {"a":1}   |
 *-----------*/
```

In the following example, path `$.b` doesn't exist, so the operation is
ignored.

```zetasql
SELECT JSON_ARRAY_APPEND(JSON '{"a": 1}', '$.b', 2) AS json_data

/*-----------*
 | json_data |
 +-----------+
 | {"a":1}   |
 *-----------*/
```

### `JSON_ARRAY_INSERT`

```zetasql
JSON_ARRAY_INSERT(
  json_expr,
  json_path_value_pair[, ...]
  [, insert_each_element => { TRUE | FALSE } ]
)

json_path_value_pair:
  json_path, value
```

Produces a new JSON value that's created by inserting JSON data into
a JSON array.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '["a", "b", "c"]'
    ```
+   `json_path_value_pair`: A value and the [JSONPath][JSONPath-format] for
    that value. This includes:

    +   `json_path`: Insert `value` at this [JSONPath][JSONPath-format]
        in `json_expr`.

    +   `value`: A [JSON encoding-supported][json-encodings] value to
        insert.
+   `insert_each_element`: A named argument with a `BOOL` value.

    +   If `TRUE` (default), and `value` is a SQL array,
        inserts each element individually.

    +   If `FALSE,` and `value` is a SQL array, inserts
        the array as one element.

Details:

+   Path value pairs are evaluated left to right. The JSON produced by
    evaluating one pair becomes the JSON against which the next pair
    is evaluated.
+   The operation is ignored if the path points to a JSON non-array value that
    isn't a JSON null.
+   If `json_path` points to a JSON null, the JSON null is replaced by a
    JSON array of the appropriate size and padded on the left with JSON nulls.
+   If the path exists but has an incompatible type at any given path token,
    the path value pair operator is ignored.
+   The function applies all path value pair append operations even if an
    individual path value pair operation is invalid. For invalid operations,
    the operation is ignored and the function continues to process the rest of
    the path value pairs.
+   If the array index in `json_path` is larger than the size of the array, the
    function extends the length of the array to the index, fills in
    the array with JSON nulls, then adds `value` at the index.
+   If any `json_path` is an invalid [JSONPath][JSONPath-format], an error is
    produced.
+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   If `insert_each_element` is SQL `NULL`, the function returns `json_expr`.
+   If `json_path` is SQL `NULL`, the `json_path_value_pair` operation is
    ignored.

**Return type**

`JSON`

**Examples**

In the following example, path `$[1]` is matched and inserts `1`.

```zetasql
SELECT JSON_ARRAY_INSERT(JSON '["a", ["b", "c"], "d"]', '$[1]', 1) AS json_data

/*-----------------------*
 | json_data             |
 +-----------------------+
 | ["a",1,["b","c"],"d"] |
 *-----------------------*/
```

In the following example, path `$[1][0]` is matched and inserts `1`.

```zetasql
SELECT JSON_ARRAY_INSERT(JSON '["a", ["b", "c"], "d"]', '$[1][0]', 1) AS json_data

/*-----------------------*
 | json_data             |
 +-----------------------+
 | ["a",[1,"b","c"],"d"] |
 *-----------------------*/
```

In the following example, `insert_each_element` defaults to `TRUE`, so
`[1, 2]` is inserted as individual elements.

```zetasql
SELECT JSON_ARRAY_INSERT(JSON '["a", "b", "c"]', '$[1]', [1, 2]) AS json_data

/*-------------------*
 | json_data         |
 +-------------------+
 | ["a",1,2,"b","c"] |
 *-------------------*/
```

In the following example, `insert_each_element` is `FALSE`, so `[1, 2]` is
inserted as one element.

```zetasql
SELECT JSON_ARRAY_INSERT(
  JSON '["a", "b", "c"]',
  '$[1]', [1, 2],
  insert_each_element=>FALSE) AS json_data

/*---------------------*
 | json_data           |
 +---------------------+
 | ["a",[1,2],"b","c"] |
 *---------------------*/
```

In the following example, path `$[7]` is larger than the length of the
matched array, so the array is extended with JSON nulls and `"e"` is inserted at
the end of the array.

```zetasql
SELECT JSON_ARRAY_INSERT(JSON '["a", "b", "c", "d"]', '$[7]', "e") AS json_data

/*--------------------------------------*
 | json_data                            |
 +--------------------------------------+
 | ["a","b","c","d",null,null,null,"e"] |
 *--------------------------------------*/
```

In the following example, path `$.a` is an object, so the operation is ignored.

```zetasql
SELECT JSON_ARRAY_INSERT(JSON '{"a": {}}', '$.a[0]', 2) AS json_data

/*-----------*
 | json_data |
 +-----------+
 | {"a":{}}  |
 *-----------*/
```

In the following example, path `$` doesn't specify a valid array position,
so the operation is ignored.

```zetasql
SELECT JSON_ARRAY_INSERT(JSON '[1, 2]', '$', 3) AS json_data

/*-----------*
 | json_data |
 +-----------+
 | [1,2]     |
 *-----------*/
```

In the following example, a value is inserted into a JSON null.

```zetasql
SELECT JSON_ARRAY_INSERT(JSON '{"a": null}', '$.a[2]', 10) AS json_data

/*----------------------*
 | json_data            |
 +----------------------+
 | {"a":[null,null,10]} |
 *----------------------*/
```

In the following example, the operation is ignored because you can't insert
data into a JSON number.

```zetasql
SELECT JSON_ARRAY_INSERT(JSON '1', '$[0]', 'r1') AS json_data

/*-----------*
 | json_data |
 +-----------+
 | 1         |
 *-----------*/
```

### `JSON_CONTAINS`

```zetasql
JSON_CONTAINS(json_expr, json_expr)
```

**Description**

Checks if a JSON document contains another JSON document. This function returns
`true` if the first parameter JSON document contains the second parameter JSON
document; otherwise the function returns `false`. If any input argument is
`NULL`, a `NULL` value is returned.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '{"class": {"students": [{"name": "Jane"}]}}'
    ```

Details:

+   The structure and data of the contained document must match a portion of the
    containing document. This function determines if the smaller JSON document
    is part of the larger JSON document.
+   JSON scalars: A JSON scalar value (like a string, number, bool, or JSON null
    ) contains only itself.
+   JSON objects:

    +   An object contains another object if the first object contains all the
        key-value pairs present in the second JSON object.
    +   When checking for object containment, extra key-value pairs in the
        containing object don't prevent a match.
    +   Any JSON object can contain an empty object.
+   JSON arrays:

    +   An array contains another array if every element of the second array is
        contained by some element of the first.
    +   Duplicate elements in arrays are treated as if they appear only once.
    +   The order of elements within JSON arrays isn't significant for
        containment checks.
    +   Any array can contain an empty array.
    +   As a special case, a top-level array can contain a scalar value.

**Return type**

`BOOL`

**Examples**

In the following example, a JSON scalar value (a string) contains only itself:

```zetasql
SELECT JSON_CONTAINS(JSON '"a"', JSON '"a"') AS result;

/*----------*
 |  result  |
 +----------+
 |   true   |
 *----------*/
```

The following examples check if a JSON object contains another JSON object:

```zetasql
SELECT
    JSON_CONTAINS(JSON '{"a": {"b": 1}, "c": 2}', JSON '{"b": 1}') AS result1,
    JSON_CONTAINS(JSON '{"a": {"b": 1}, "c": 2}', JSON '{"a": {"b": 1}}') AS result2,
    JSON_CONTAINS(JSON '{"a": {"b": 1, "d": 3}, "c": 2}', JSON '{"a": {"b": 1}}') AS result3;

/*----------*----------*----------*
 |  result1 |  result2 |  result3 |
 +----------+----------+----------+
 |   false  |   true   |   true   |
 *----------*----------*----------*/
```

The following examples check if a JSON array contains another JSON array. An
array contains another array if the first JSON array contains all the elements
present in the second array. The order of elements doesn't matter.

Also, if the array is a top-level array, it can contain a scalar value.

```zetasql
SELECT
    JSON_CONTAINS(JSON '[1, 2, 3]', JSON '[2]') AS result1,
    JSON_CONTAINS(JSON '[1, 2, 3]', JSON '2') AS result2;

/*----------*----------*
 |  result1 |  result2 |
 +----------+----------+
 |   true   |   true   |
 *----------*----------*/
```

```zetasql
SELECT
    JSON_CONTAINS(JSON '[[1, 2, 3]]', JSON '2') AS result1,
    JSON_CONTAINS(JSON '[[1, 2, 3]]', JSON '[2]') AS result2,
    JSON_CONTAINS(JSON '[[1, 2, 3]]', JSON '[[2]]') AS result3;

/*----------*----------*----------*
 |  result1 |  result2 |  result3 |
 +----------+----------+----------+
 |   false  |   false  |   true   |
 *----------*----------*----------*/
```

The following examples check if a JSON array contains a JSON object:

```zetasql
SELECT
    JSON_CONTAINS(JSON '[{"a":0}, {"b":1, "c":2}]', JSON '[{"b":1}]') AS result1,
    JSON_CONTAINS(JSON '[{"a":0}, {"b":1, "c":2}]', JSON '{"b":1}') AS results2,
    JSON_CONTAINS(JSON '[{"a":0}, {"b":1, "c":2}]', JSON '[{"a":0, "b":1}]') AS results3;

/*----------*----------*----------*
 |  result1 |  result2 |  result3 |
 +----------+----------+----------+
 |   true   |   false  |   false  |
 *----------*----------*----------*/
```

### `JSON_EXTRACT`

Note: This function is deprecated. Consider using [JSON_QUERY][json-query].

```zetasql
JSON_EXTRACT(json_string_expr, json_path)
```

```zetasql
JSON_EXTRACT(json_expr, json_path)
```

**Description**

Extracts a JSON value and converts it to a
SQL JSON-formatted `STRING` or `JSON` value.
This function uses single quotes and brackets to escape invalid
[JSONPath][JSONPath-format] characters in JSON keys. For example: `['a.b']`.

Arguments:

+   `json_string_expr`: A JSON-formatted string. For example:

    ```
    '{"class": {"students": [{"name": "Jane"}]}}'
    ```

    Extracts a SQL `NULL` when a JSON-formatted string `null` is encountered.
    For example:

    ```zetasql
    SELECT JSON_EXTRACT("null", "$") -- Returns a SQL NULL
    ```
+   `json_expr`: JSON. For example:

    ```
    JSON '{"class": {"students": [{"name": "Jane"}]}}'
    ```

    Extracts a JSON `null` when a JSON `null` is encountered.

    ```zetasql
    SELECT JSON_EXTRACT(JSON 'null', "$") -- Returns a JSON 'null'
    ```
+   `json_path`: The [JSONPath][JSONPath-format]. This identifies the data that
    you want to obtain from the input.

There are differences between the JSON-formatted string and JSON input types.
For details, see [Differences between the JSON and JSON-formatted STRING types][differences-json-and-string].

**Return type**

+ `json_string_expr`: A JSON-formatted `STRING`
+ `json_expr`: `JSON`

**Examples**

In the following example, JSON data is extracted and returned as JSON.

```zetasql
SELECT
  JSON_EXTRACT(JSON '{"class": {"students": [{"id": 5}, {"id": 12}]}}', '$.class')
  AS json_data;

/*-----------------------------------*
 | json_data                         |
 +-----------------------------------+
 | {"students":[{"id":5},{"id":12}]} |
 *-----------------------------------*/
```

In the following examples, JSON data is extracted and returned as
JSON-formatted strings.

```zetasql
SELECT JSON_EXTRACT(
  '{"class": {"students": [{"name": "Jane"}]}}',
  '$') AS json_text_string;

/*-----------------------------------------------------------*
 | json_text_string                                          |
 +-----------------------------------------------------------+
 | {"class":{"students":[{"name":"Jane"}]}}                  |
 *-----------------------------------------------------------*/
```

```zetasql
SELECT JSON_EXTRACT(
  '{"class": {"students": []}}',
  '$') AS json_text_string;

/*-----------------------------------------------------------*
 | json_text_string                                          |
 +-----------------------------------------------------------+
 | {"class":{"students":[]}}                                 |
 *-----------------------------------------------------------*/
```

```zetasql
SELECT JSON_EXTRACT(
  '{"class": {"students": [{"name": "John"}, {"name": "Jamie"}]}}',
  '$') AS json_text_string;

/*-----------------------------------------------------------*
 | json_text_string                                          |
 +-----------------------------------------------------------+
 | {"class":{"students":[{"name":"John"},{"name":"Jamie"}]}} |
 *-----------------------------------------------------------*/
```

```zetasql
SELECT JSON_EXTRACT(
  '{"class": {"students": [{"name": "Jane"}]}}',
  '$.class.students[0]') AS first_student;

/*-----------------*
 | first_student   |
 +-----------------+
 | {"name":"Jane"} |
 *-----------------*/
```

```zetasql
SELECT JSON_EXTRACT(
  '{"class": {"students": []}}',
  '$.class.students[0]') AS first_student;

/*-----------------*
 | first_student   |
 +-----------------+
 | NULL            |
 *-----------------*/
```

```zetasql
SELECT JSON_EXTRACT(
  '{"class": {"students": [{"name": "John"}, {"name": "Jamie"}]}}',
  '$.class.students[0]') AS first_student;

/*-----------------*
 | first_student   |
 +-----------------+
 | {"name":"John"} |
 *-----------------*/
```

```zetasql
SELECT JSON_EXTRACT(
  '{"class": {"students": [{"name": "Jane"}]}}',
  '$.class.students[1].name') AS second_student;

/*----------------*
 | second_student |
 +----------------+
 | NULL           |
 *----------------*/
```

```zetasql
SELECT JSON_EXTRACT(
  '{"class": {"students": []}}',
  '$.class.students[1].name') AS second_student;

/*----------------*
 | second_student |
 +----------------+
 | NULL           |
 *----------------*/
```

```zetasql
SELECT JSON_EXTRACT(
  '{"class": {"students": [{"name": "John"}, {"name": null}]}}',
  '$.class.students[1].name') AS second_student;

/*----------------*
 | second_student |
 +----------------+
 | NULL           |
 *----------------*/
```

```zetasql
SELECT JSON_EXTRACT(
  '{"class": {"students": [{"name": "John"}, {"name": "Jamie"}]}}',
  '$.class.students[1].name') AS second_student;

/*----------------*
 | second_student |
 +----------------+
 | "Jamie"        |
 *----------------*/
```

```zetasql
SELECT JSON_EXTRACT(
  '{"class": {"students": [{"name": "Jane"}]}}',
  "$.class['students']") AS student_names;

/*------------------------------------*
 | student_names                      |
 +------------------------------------+
 | [{"name":"Jane"}]                  |
 *------------------------------------*/
```

```zetasql
SELECT JSON_EXTRACT(
  '{"class": {"students": []}}',
  "$.class['students']") AS student_names;

/*------------------------------------*
 | student_names                      |
 +------------------------------------+
 | []                                 |
 *------------------------------------*/
```

```zetasql
SELECT JSON_EXTRACT(
  '{"class": {"students": [{"name": "John"}, {"name": "Jamie"}]}}',
  "$.class['students']") AS student_names;

/*------------------------------------*
 | student_names                      |
 +------------------------------------+
 | [{"name":"John"},{"name":"Jamie"}] |
 *------------------------------------*/
```

```zetasql
SELECT JSON_EXTRACT('{"a": null}', "$.a"); -- Returns a SQL NULL
SELECT JSON_EXTRACT('{"a": null}', "$.b"); -- Returns a SQL NULL
```

```zetasql
SELECT JSON_EXTRACT(JSON '{"a": null}', "$.a"); -- Returns a JSON 'null'
SELECT JSON_EXTRACT(JSON '{"a": null}', "$.b"); -- Returns a SQL NULL
```

[json-query]: #json_query

[JSONPath-format]: #JSONPath_format

[differences-json-and-string]: #differences_json_and_string

### `JSON_EXTRACT_ARRAY`

Note: This function is deprecated. Consider using
[JSON_QUERY_ARRAY][json-query-array].

```zetasql
JSON_EXTRACT_ARRAY(json_string_expr[, json_path])
```

```zetasql
JSON_EXTRACT_ARRAY(json_expr[, json_path])
```

**Description**

Extracts a JSON array and converts it to
a SQL `ARRAY<JSON-formatted STRING>` or
`ARRAY<JSON>` value.
This function uses single quotes and brackets to escape invalid
[JSONPath][JSONPath-format] characters in JSON keys. For example: `['a.b']`.

Arguments:

+   `json_string_expr`: A JSON-formatted string. For example:

    ```
    '["a", "b", {"key": "c"}]'
    ```
+   `json_expr`: JSON. For example:

    ```
    JSON '["a", "b", {"key": "c"}]'
    ```
+   `json_path`: The [JSONPath][JSONPath-format]. This identifies the data that
    you want to obtain from the input. If this optional parameter isn't
    provided, then the JSONPath `$` symbol is applied, which means that all of
    the data is analyzed.

There are differences between the JSON-formatted string and JSON input types.
For details, see [Differences between the JSON and JSON-formatted STRING types][differences-json-and-string].

**Return type**

+ `json_string_expr`: `ARRAY<JSON-formatted STRING>`
+ `json_expr`: `ARRAY<JSON>`

**Examples**

This extracts items in JSON to an array of `JSON` values:

```zetasql
SELECT JSON_EXTRACT_ARRAY(
  JSON '{"fruits":["apples","oranges","grapes"]}','$.fruits'
  ) AS json_array;

/*---------------------------------*
 | json_array                      |
 +---------------------------------+
 | ["apples", "oranges", "grapes"] |
 *---------------------------------*/
```

This extracts the items in a JSON-formatted string to a string array:

```zetasql
SELECT JSON_EXTRACT_ARRAY('[1,2,3]') AS string_array;

/*--------------*
 | string_array |
 +--------------+
 | [1, 2, 3]    |
 *--------------*/
```

This extracts a string array and converts it to an integer array:

```zetasql
SELECT ARRAY(
  SELECT CAST(integer_element AS INT64)
  FROM UNNEST(
    JSON_EXTRACT_ARRAY('[1,2,3]','$')
  ) AS integer_element
) AS integer_array;

/*---------------*
 | integer_array |
 +---------------+
 | [1, 2, 3]     |
 *---------------*/
```

This extracts string values in a JSON-formatted string to an array:

```zetasql
-- Doesn't strip the double quotes
SELECT JSON_EXTRACT_ARRAY('["apples", "oranges", "grapes"]', '$') AS string_array;

/*---------------------------------*
 | string_array                    |
 +---------------------------------+
 | ["apples", "oranges", "grapes"] |
 *---------------------------------*/

-- Strips the double quotes
SELECT ARRAY(
  SELECT JSON_EXTRACT_SCALAR(string_element, '$')
  FROM UNNEST(JSON_EXTRACT_ARRAY('["apples","oranges","grapes"]','$')) AS string_element
) AS string_array;

/*---------------------------*
 | string_array              |
 +---------------------------+
 | [apples, oranges, grapes] |
 *---------------------------*/
```

This extracts only the items in the `fruit` property to an array:

```zetasql
SELECT JSON_EXTRACT_ARRAY(
  '{"fruit": [{"apples": 5, "oranges": 10}, {"apples": 2, "oranges": 4}], "vegetables": [{"lettuce": 7, "kale": 8}]}',
  '$.fruit'
) AS string_array;

/*-------------------------------------------------------*
 | string_array                                          |
 +-------------------------------------------------------+
 | [{"apples":5,"oranges":10}, {"apples":2,"oranges":4}] |
 *-------------------------------------------------------*/
```

These are equivalent:

```zetasql
SELECT JSON_EXTRACT_ARRAY('{"fruits": ["apples", "oranges", "grapes"]}', '$[fruits]') AS string_array;

SELECT JSON_EXTRACT_ARRAY('{"fruits": ["apples", "oranges", "grapes"]}', '$.fruits') AS string_array;

-- The queries above produce the following result:
/*---------------------------------*
 | string_array                    |
 +---------------------------------+
 | ["apples", "oranges", "grapes"] |
 *---------------------------------*/
```

In cases where a JSON key uses invalid JSONPath characters, you can escape those
characters using single quotes and brackets, `[' ']`. For example:

```zetasql
SELECT JSON_EXTRACT_ARRAY('{"a.b": {"c": ["world"]}}', "$['a.b'].c") AS hello;

/*-----------*
 | hello     |
 +-----------+
 | ["world"] |
 *-----------*/
```

The following examples explore how invalid requests and empty arrays are
handled:

+  If a JSONPath is invalid, an error is thrown.
+  If a JSON-formatted string is invalid, the output is NULL.
+  It's okay to have empty arrays in the JSON-formatted string.

```zetasql
-- An error is thrown if you provide an invalid JSONPath.
SELECT JSON_EXTRACT_ARRAY('["foo", "bar", "baz"]', 'INVALID_JSONPath') AS result;

-- If the JSONPath doesn't refer to an array, then NULL is returned.
SELECT JSON_EXTRACT_ARRAY('{"a": "foo"}', '$.a') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If a key that doesn't exist is specified, then the result is NULL.
SELECT JSON_EXTRACT_ARRAY('{"a": "foo"}', '$.b') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- Empty arrays in JSON-formatted strings are supported.
SELECT JSON_EXTRACT_ARRAY('{"a": "foo", "b": []}', '$.b') AS result;

/*--------*
 | result |
 +--------+
 | []     |
 *--------*/
```

[json-query-array]: #json_query_array

[JSONPath-format]: #JSONPath_format

[differences-json-and-string]: #differences_json_and_string

### `JSON_EXTRACT_SCALAR`

Note: This function is deprecated. Consider using [JSON_VALUE][json-value].

```zetasql
JSON_EXTRACT_SCALAR(json_string_expr[, json_path])
```

```zetasql
JSON_EXTRACT_SCALAR(json_expr[, json_path])
```

**Description**

Extracts a JSON scalar value and converts it to a SQL `STRING` value.
In addition, this function:

+   Removes the outermost quotes and unescapes the return values.
+   Returns a SQL `NULL` if a non-scalar value is selected.
+   Uses single quotes and brackets to escape invalid [JSONPath][JSONPath-format]
    characters in JSON keys. For example: `['a.b']`.

Arguments:

+   `json_string_expr`: A JSON-formatted string. For example:

    ```
    '{"name": "Jane", "age": "6"}'
    ```
+   `json_expr`: JSON. For example:

    ```
    JSON '{"name": "Jane", "age": "6"}'
    ```
+   `json_path`: The [JSONPath][JSONPath-format]. This identifies the data that
    you want to obtain from the input. If this optional parameter isn't
    provided, then the JSONPath `$` symbol is applied, which means that all of
    the data is analyzed.

    If `json_path` returns a JSON `null` or a non-scalar value (in other words,
    if `json_path` refers to an object or an array), then a SQL `NULL` is
    returned.

There are differences between the JSON-formatted string and JSON input types.
For details, see [Differences between the JSON and JSON-formatted STRING types][differences-json-and-string].

**Return type**

`STRING`

**Examples**

In the following example, `age` is extracted.

```zetasql
SELECT JSON_EXTRACT_SCALAR(JSON '{"name": "Jakob", "age": "6" }', '$.age') AS scalar_age;

/*------------*
 | scalar_age |
 +------------+
 | 6          |
 *------------*/
```

The following example compares how results are returned for the `JSON_EXTRACT`
and `JSON_EXTRACT_SCALAR` functions.

```zetasql
SELECT JSON_EXTRACT('{"name": "Jakob", "age": "6" }', '$.name') AS json_name,
  JSON_EXTRACT_SCALAR('{"name": "Jakob", "age": "6" }', '$.name') AS scalar_name,
  JSON_EXTRACT('{"name": "Jakob", "age": "6" }', '$.age') AS json_age,
  JSON_EXTRACT_SCALAR('{"name": "Jakob", "age": "6" }', '$.age') AS scalar_age;

/*-----------+-------------+----------+------------*
 | json_name | scalar_name | json_age | scalar_age |
 +-----------+-------------+----------+------------+
 | "Jakob"   | Jakob       | "6"      | 6          |
 *-----------+-------------+----------+------------*/
```

```zetasql
SELECT JSON_EXTRACT('{"fruits": ["apple", "banana"]}', '$.fruits') AS json_extract,
  JSON_EXTRACT_SCALAR('{"fruits": ["apple", "banana"]}', '$.fruits') AS json_extract_scalar;

/*--------------------+---------------------*
 | json_extract       | json_extract_scalar |
 +--------------------+---------------------+
 | ["apple","banana"] | NULL                |
 *--------------------+---------------------*/
```

In cases where a JSON key uses invalid JSONPath characters, you can escape those
characters using single quotes and brackets, `[' ']`. For example:

```zetasql
SELECT JSON_EXTRACT_SCALAR('{"a.b": {"c": "world"}}', "$['a.b'].c") AS hello;

/*-------*
 | hello |
 +-------+
 | world |
 *-------*/
```

[json-value]: #json_value

[JSONPath-format]: #JSONPath_format

[differences-json-and-string]: #differences_json_and_string

### `JSON_EXTRACT_STRING_ARRAY`

Note: This function is deprecated. Consider using
[JSON_VALUE_ARRAY][json-value-array].

```zetasql
JSON_EXTRACT_STRING_ARRAY(json_string_expr[, json_path])
```

```zetasql
JSON_EXTRACT_STRING_ARRAY(json_expr[, json_path])
```

**Description**

Extracts a JSON array of scalar values and converts it to a SQL `ARRAY<STRING>`
value. In addition, this function:

+   Removes the outermost quotes and unescapes the values.
+   Returns a SQL `NULL` if the selected value isn't an array or
    not an array containing only scalar values.
+   Uses single quotes and brackets to escape invalid [JSONPath][JSONPath-format]
    characters in JSON keys. For example: `['a.b']`.

Arguments:

+   `json_string_expr`: A JSON-formatted string. For example:

    ```
    '["apples", "oranges", "grapes"]'
    ```
+   `json_expr`: JSON. For example:

    ```
    JSON '["apples", "oranges", "grapes"]'
    ```
+   `json_path`: The [JSONPath][JSONPath-format]. This identifies the data that
    you want to obtain from the input. If this optional parameter isn't
    provided, then the JSONPath `$` symbol is applied, which means that all of
    the data is analyzed.

There are differences between the JSON-formatted string and JSON input types.
For details, see [Differences between the JSON and JSON-formatted STRING types][differences-json-and-string].

Caveats:

+ A JSON `null` in the input array produces a SQL `NULL` as the output for that
  JSON `null`.
+ If a JSONPath matches an array that contains scalar objects and a JSON `null`,
  then the output is an array of the scalar objects and a SQL `NULL`.

**Return type**

`ARRAY<STRING>`

**Examples**

This extracts items in JSON to a string array:

```zetasql
SELECT JSON_EXTRACT_STRING_ARRAY(
  JSON '{"fruits": ["apples", "oranges", "grapes"]}', '$.fruits'
  ) AS string_array;

/*---------------------------*
 | string_array              |
 +---------------------------+
 | [apples, oranges, grapes] |
 *---------------------------*/
```

The following example compares how results are returned for the
`JSON_EXTRACT_ARRAY` and `JSON_EXTRACT_STRING_ARRAY` functions.

```zetasql
SELECT JSON_EXTRACT_ARRAY('["apples", "oranges"]') AS json_array,
JSON_EXTRACT_STRING_ARRAY('["apples", "oranges"]') AS string_array;

/*-----------------------+-------------------*
 | json_array            | string_array      |
 +-----------------------+-------------------+
 | ["apples", "oranges"] | [apples, oranges] |
 *-----------------------+-------------------*/
```

This extracts the items in a JSON-formatted string to a string array:

```zetasql
-- Strips the double quotes
SELECT JSON_EXTRACT_STRING_ARRAY('["foo", "bar", "baz"]', '$') AS string_array;

/*-----------------*
 | string_array    |
 +-----------------+
 | [foo, bar, baz] |
 *-----------------*/
```

This extracts a string array and converts it to an integer array:

```zetasql
SELECT ARRAY(
  SELECT CAST(integer_element AS INT64)
  FROM UNNEST(
    JSON_EXTRACT_STRING_ARRAY('[1, 2, 3]', '$')
  ) AS integer_element
) AS integer_array;

/*---------------*
 | integer_array |
 +---------------+
 | [1, 2, 3]     |
 *---------------*/
```

These are equivalent:

```zetasql
SELECT JSON_EXTRACT_STRING_ARRAY('{"fruits": ["apples", "oranges", "grapes"]}', '$[fruits]') AS string_array;

SELECT JSON_EXTRACT_STRING_ARRAY('{"fruits": ["apples", "oranges", "grapes"]}', '$.fruits') AS string_array;

-- The queries above produce the following result:
/*---------------------------*
 | string_array              |
 +---------------------------+
 | [apples, oranges, grapes] |
 *---------------------------*/
```

In cases where a JSON key uses invalid JSONPath characters, you can escape those
characters using single quotes and brackets: `[' ']`. For example:

```zetasql
SELECT JSON_EXTRACT_STRING_ARRAY('{"a.b": {"c": ["world"]}}', "$['a.b'].c") AS hello;

/*---------*
 | hello   |
 +---------+
 | [world] |
 *---------*/
```

The following examples explore how invalid requests and empty arrays are
handled:

```zetasql
-- An error is thrown if you provide an invalid JSONPath.
SELECT JSON_EXTRACT_STRING_ARRAY('["foo", "bar", "baz"]', 'INVALID_JSONPath') AS result;

-- If the JSON formatted string is invalid, then NULL is returned.
SELECT JSON_EXTRACT_STRING_ARRAY('}}', '$') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If the JSON document is NULL, then NULL is returned.
SELECT JSON_EXTRACT_STRING_ARRAY(NULL, '$') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If a JSONPath doesn't match anything, then the output is NULL.
SELECT JSON_EXTRACT_STRING_ARRAY('{"a": ["foo", "bar", "baz"]}', '$.b') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If a JSONPath matches an object that isn't an array, then the output is NULL.
SELECT JSON_EXTRACT_STRING_ARRAY('{"a": "foo"}', '$') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If a JSONPath matches an array of non-scalar objects, then the output is NULL.
SELECT JSON_EXTRACT_STRING_ARRAY('{"a": [{"b": "foo", "c": 1}, {"b": "bar", "c":2}], "d": "baz"}', '$.a') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If a JSONPath matches an array of mixed scalar and non-scalar objects, then the output is NULL.
SELECT JSON_EXTRACT_STRING_ARRAY('{"a": [10, {"b": 20}]', '$.a') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If a JSONPath matches an empty JSON array, then the output is an empty array instead of NULL.
SELECT JSON_EXTRACT_STRING_ARRAY('{"a": "foo", "b": []}', '$.b') AS result;

/*--------*
 | result |
 +--------+
 | []     |
 *--------*/

-- In the following query, the JSON null input is returned as a
-- SQL NULL in the output.
SELECT JSON_EXTRACT_STRING_ARRAY('["world", 1, null]') AS result;

/*------------------*
 | result           |
 +------------------+
 | [world, 1, NULL] |
 *------------------*/

```

[json-value-array]: #json_value_array

[JSONPath-format]: #JSONPath_format

[differences-json-and-string]: #differences_json_and_string

### `JSON_OBJECT`

+   [Signature 1](#json_object_signature1):
    `JSON_OBJECT([json_key, json_value][, ...])`
+   [Signature 2](#json_object_signature2):
    `JSON_OBJECT(json_key_array, json_value_array)`

#### Signature 1 
<a id="json_object_signature1"></a>

```zetasql
JSON_OBJECT([json_key, json_value][, ...])
```

**Description**

Creates a JSON object, using key-value pairs.

Arguments:

+   `json_key`: A `STRING` value that represents a key.
+   `json_value`: A [JSON encoding-supported][json-encodings] value.

Details:

+   If two keys are passed in with the same name, only the first key-value pair
    is preserved.
+   The order of key-value pairs isn't preserved.
+   If `json_key` is `NULL`, an error is produced.

**Return type**

`JSON`

**Examples**

You can create an empty JSON object by passing in no JSON keys and values.
For example:

```zetasql
SELECT JSON_OBJECT() AS json_data

/*-----------*
 | json_data |
 +-----------+
 | {}        |
 *-----------*/
```

You can create a JSON object by passing in key-value pairs. For example:

```zetasql
SELECT JSON_OBJECT('foo', 10, 'bar', TRUE) AS json_data

/*-----------------------*
 | json_data             |
 +-----------------------+
 | {"bar":true,"foo":10} |
 *-----------------------*/
```

```zetasql
SELECT JSON_OBJECT('foo', 10, 'bar', ['a', 'b']) AS json_data

/*----------------------------*
 | json_data                  |
 +----------------------------+
 | {"bar":["a","b"],"foo":10} |
 *----------------------------*/
```

```zetasql
SELECT JSON_OBJECT('a', NULL, 'b', JSON 'null') AS json_data

/*---------------------*
 | json_data           |
 +---------------------+
 | {"a":null,"b":null} |
 *---------------------*/
```

```zetasql
SELECT JSON_OBJECT('a', 10, 'a', 'foo') AS json_data

/*-----------*
 | json_data |
 +-----------+
 | {"a":10}  |
 *-----------*/
```

```zetasql
WITH Items AS (SELECT 'hello' AS key, 'world' AS value)
SELECT JSON_OBJECT(key, value) AS json_data FROM Items

/*-------------------*
 | json_data         |
 +-------------------+
 | {"hello":"world"} |
 *-------------------*/
```

An error is produced if a SQL `NULL` is passed in for a JSON key.

```zetasql
-- Error: A key can't be NULL.
SELECT JSON_OBJECT(NULL, 1) AS json_data
```

An error is produced if the number of JSON keys and JSON values don't match:

```zetasql
-- Error: No matching signature for function JSON_OBJECT for argument types:
-- STRING, INT64, STRING
SELECT JSON_OBJECT('a', 1, 'b') AS json_data
```

#### Signature 2 
<a id="json_object_signature2"></a>

```zetasql
JSON_OBJECT(json_key_array, json_value_array)
```

Creates a JSON object, using an array of keys and values.

Arguments:

+   `json_key_array`: An array of zero or more `STRING` keys.
+   `json_value_array`: An array of zero or more
    [JSON encoding-supported][json-encodings] values.

Details:

+   If two keys are passed in with the same name, only the first key-value pair
    is preserved.
+   The order of key-value pairs isn't preserved.
+   The number of keys must match the number of values, otherwise an error is
    produced.
+   If any argument is `NULL`, an error is produced.
+   If a key in `json_key_array` is `NULL`, an error is produced.

**Return type**

`JSON`

**Examples**

You can create an empty JSON object by passing in an empty array of
keys and values. For example:

```zetasql
SELECT JSON_OBJECT(CAST([] AS ARRAY<STRING>), []) AS json_data

/*-----------*
 | json_data |
 +-----------+
 | {}        |
 *-----------*/
```

You can create a JSON object by passing in an array of keys and an array of
values. For example:

```zetasql
SELECT JSON_OBJECT(['a', 'b'], [10, NULL]) AS json_data

/*-------------------*
 | json_data         |
 +-------------------+
 | {"a":10,"b":null} |
 *-------------------*/
```

```zetasql
SELECT JSON_OBJECT(['a', 'b'], [JSON '10', JSON '"foo"']) AS json_data

/*--------------------*
 | json_data          |
 +--------------------+
 | {"a":10,"b":"foo"} |
 *--------------------*/
```

```zetasql
SELECT
  JSON_OBJECT(
    ['a', 'b'],
    [STRUCT(10 AS id, 'Red' AS color), STRUCT(20 AS id, 'Blue' AS color)])
    AS json_data

/*------------------------------------------------------------*
 | json_data                                                  |
 +------------------------------------------------------------+
 | {"a":{"color":"Red","id":10},"b":{"color":"Blue","id":20}} |
 *------------------------------------------------------------*/
```

```zetasql
SELECT
  JSON_OBJECT(
    ['a', 'b'],
    [TO_JSON(10), TO_JSON(['foo', 'bar'])])
    AS json_data

/*----------------------------*
 | json_data                  |
 +----------------------------+
 | {"a":10,"b":["foo","bar"]} |
 *----------------------------*/
```

The following query groups by `id` and then creates an array of keys and
values from the rows with the same `id`:

```zetasql
WITH
  Fruits AS (
    SELECT 0 AS id, 'color' AS json_key, 'red' AS json_value UNION ALL
    SELECT 0, 'fruit', 'apple' UNION ALL
    SELECT 1, 'fruit', 'banana' UNION ALL
    SELECT 1, 'ripe', 'true'
  )
SELECT JSON_OBJECT(ARRAY_AGG(json_key), ARRAY_AGG(json_value)) AS json_data
FROM Fruits
GROUP BY id

/*----------------------------------*
 | json_data                        |
 +----------------------------------+
 | {"color":"red","fruit":"apple"}  |
 | {"fruit":"banana","ripe":"true"} |
 *----------------------------------*/
```

An error is produced if the size of the JSON keys and values arrays don't
match:

```zetasql
-- Error: The number of keys and values must match.
SELECT JSON_OBJECT(['a', 'b'], [10]) AS json_data
```

An error is produced if the array of JSON keys or JSON values is a SQL `NULL`.

```zetasql
-- Error: The keys array can't be NULL.
SELECT JSON_OBJECT(CAST(NULL AS ARRAY<STRING>), [10, 20]) AS json_data
```

```zetasql
-- Error: The values array can't be NULL.
SELECT JSON_OBJECT(['a', 'b'], CAST(NULL AS ARRAY<INT64>)) AS json_data
```

[json-encodings]: #json_encodings

### `JSON_QUERY`

```zetasql
JSON_QUERY(json_string_expr, json_path)
```

```zetasql
JSON_QUERY(json_expr, json_path)
```

**Description**

Extracts a JSON value and converts it to a SQL
JSON-formatted `STRING` or
`JSON` value.
This function uses double quotes to escape invalid
[JSONPath][JSONPath-format] characters in JSON keys. For example: `"a.b"`.

Arguments:

+   `json_string_expr`: A JSON-formatted string. For example:

    ```
    '{"class": {"students": [{"name": "Jane"}]}}'
    ```

    Extracts a SQL `NULL` when a JSON-formatted string `null` is encountered.
    For example:

    ```zetasql
    SELECT JSON_QUERY("null", "$") -- Returns a SQL NULL
    ```
+   `json_expr`: JSON. For example:

    ```
    JSON '{"class": {"students": [{"name": "Jane"}]}}'
    ```

    Extracts a JSON `null` when a JSON `null` is encountered.

    ```zetasql
    SELECT JSON_QUERY(JSON 'null', "$") -- Returns a JSON 'null'
    ```
+   `json_path`: The [JSONPath][JSONPath-format]. This identifies the data that
    you want to obtain from the input.

There are differences between the JSON-formatted string and JSON input types.
For details, see [Differences between the JSON and JSON-formatted STRING types][differences-json-and-string].

**Return type**

+ `json_string_expr`: A JSON-formatted `STRING`
+ `json_expr`: `JSON`

**Examples**

In the following example, JSON data is extracted and returned as JSON.

```zetasql
SELECT
  JSON_QUERY(
    JSON '{"class": {"students": [{"id": 5}, {"id": 12}]}}',
    '$.class') AS json_data;

/*-----------------------------------*
 | json_data                         |
 +-----------------------------------+
 | {"students":[{"id":5},{"id":12}]} |
 *-----------------------------------*/
```

In the following examples, JSON data is extracted and returned as
JSON-formatted strings.

```zetasql
SELECT
  JSON_QUERY('{"class": {"students": [{"name": "Jane"}]}}', '$') AS json_text_string;

/*-----------------------------------------------------------*
 | json_text_string                                          |
 +-----------------------------------------------------------+
 | {"class":{"students":[{"name":"Jane"}]}}                  |
 *-----------------------------------------------------------*/
```

```zetasql
SELECT JSON_QUERY('{"class": {"students": []}}', '$') AS json_text_string;

/*-----------------------------------------------------------*
 | json_text_string                                          |
 +-----------------------------------------------------------+
 | {"class":{"students":[]}}                                 |
 *-----------------------------------------------------------*/
```

```zetasql
SELECT
  JSON_QUERY(
    '{"class": {"students": [{"name": "John"},{"name": "Jamie"}]}}',
    '$') AS json_text_string;

/*-----------------------------------------------------------*
 | json_text_string                                          |
 +-----------------------------------------------------------+
 | {"class":{"students":[{"name":"John"},{"name":"Jamie"}]}} |
 *-----------------------------------------------------------*/
```

```zetasql
SELECT
  JSON_QUERY(
    '{"class": {"students": [{"name": "Jane"}]}}',
    '$.class.students[0]') AS first_student;

/*-----------------*
 | first_student   |
 +-----------------+
 | {"name":"Jane"} |
 *-----------------*/
```

```zetasql
SELECT
  JSON_QUERY('{"class": {"students": []}}', '$.class.students[0]') AS first_student;

/*-----------------*
 | first_student   |
 +-----------------+
 | NULL            |
 *-----------------*/
```

```zetasql
SELECT
  JSON_QUERY(
    '{"class": {"students": [{"name": "John"}, {"name": "Jamie"}]}}',
    '$.class.students[0]') AS first_student;

/*-----------------*
 | first_student   |
 +-----------------+
 | {"name":"John"} |
 *-----------------*/
```

```zetasql
SELECT
  JSON_QUERY(
    '{"class": {"students": [{"name": "Jane"}]}}',
    '$.class.students[1].name') AS second_student;

/*----------------*
 | second_student |
 +----------------+
 | NULL           |
 *----------------*/
```

```zetasql
SELECT
  JSON_QUERY(
    '{"class": {"students": []}}',
    '$.class.students[1].name') AS second_student;

/*----------------*
 | second_student |
 +----------------+
 | NULL           |
 *----------------*/
```

```zetasql
SELECT
  JSON_QUERY(
    '{"class": {"students": [{"name": "John"}, {"name": null}]}}',
    '$.class.students[1].name') AS second_student;

/*----------------*
 | second_student |
 +----------------+
 | NULL           |
 *----------------*/
```

```zetasql
SELECT
  JSON_QUERY(
    '{"class": {"students": [{"name": "John"}, {"name": "Jamie"}]}}',
    '$.class.students[1].name') AS second_student;

/*----------------*
 | second_student |
 +----------------+
 | "Jamie"        |
 *----------------*/
```

```zetasql
SELECT
  JSON_QUERY(
    '{"class": {"students": [{"name": "Jane"}]}}',
    '$.class."students"') AS student_names;

/*------------------------------------*
 | student_names                      |
 +------------------------------------+
 | [{"name":"Jane"}]                  |
 *------------------------------------*/
```

```zetasql
SELECT
  JSON_QUERY(
    '{"class": {"students": []}}',
    '$.class."students"') AS student_names;

/*------------------------------------*
 | student_names                      |
 +------------------------------------+
 | []                                 |
 *------------------------------------*/
```

```zetasql
SELECT
  JSON_QUERY(
    '{"class": {"students": [{"name": "John"}, {"name": "Jamie"}]}}',
    '$.class."students"') AS student_names;

/*------------------------------------*
 | student_names                      |
 +------------------------------------+
 | [{"name":"John"},{"name":"Jamie"}] |
 *------------------------------------*/
```

```zetasql
SELECT JSON_QUERY('{"a": null}', "$.a"); -- Returns a SQL NULL
SELECT JSON_QUERY('{"a": null}', "$.b"); -- Returns a SQL NULL
```

```zetasql
SELECT JSON_QUERY(JSON '{"a": null}', "$.a"); -- Returns a JSON 'null'
SELECT JSON_QUERY(JSON '{"a": null}', "$.b"); -- Returns a SQL NULL
```

[JSONPath-format]: #JSONPath_format

[differences-json-and-string]: #differences_json_and_string

[JSONPath-mode]: #JSONPath_mode

### `JSON_QUERY_ARRAY`

```zetasql
JSON_QUERY_ARRAY(json_string_expr[, json_path])
```

```zetasql
JSON_QUERY_ARRAY(json_expr[, json_path])
```

**Description**

Extracts a JSON array and converts it to
a SQL `ARRAY<JSON-formatted STRING>` or
`ARRAY<JSON>` value.
In addition, this function uses double quotes to escape invalid
[JSONPath][JSONPath-format] characters in JSON keys. For example: `"a.b"`.

Arguments:

+   `json_string_expr`: A JSON-formatted string. For example:

    ```
    '["a", "b", {"key": "c"}]'
    ```
+   `json_expr`: JSON. For example:

    ```
    JSON '["a", "b", {"key": "c"}]'
    ```
+   `json_path`: The [JSONPath][JSONPath-format]. This identifies the data that
    you want to obtain from the input. If this optional parameter isn't
    provided, then the JSONPath `$` symbol is applied, which means that all of
    the data is analyzed.

There are differences between the JSON-formatted string and JSON input types.
For details, see [Differences between the JSON and JSON-formatted STRING types][differences-json-and-string].

**Return type**

+ `json_string_expr`: `ARRAY<JSON-formatted STRING>`
+ `json_expr`: `ARRAY<JSON>`

**Examples**

This extracts items in JSON to an array of `JSON` values:

```zetasql
SELECT JSON_QUERY_ARRAY(
  JSON '{"fruits": ["apples", "oranges", "grapes"]}', '$.fruits'
  ) AS json_array;

/*---------------------------------*
 | json_array                      |
 +---------------------------------+
 | ["apples", "oranges", "grapes"] |
 *---------------------------------*/
```

This extracts the items in a JSON-formatted string to a string array:

```zetasql
SELECT JSON_QUERY_ARRAY('[1, 2, 3]') AS string_array;

/*--------------*
 | string_array |
 +--------------+
 | [1, 2, 3]    |
 *--------------*/
```

This extracts a string array and converts it to an integer array:

```zetasql
SELECT ARRAY(
  SELECT CAST(integer_element AS INT64)
  FROM UNNEST(
    JSON_QUERY_ARRAY('[1, 2, 3]','$')
  ) AS integer_element
) AS integer_array;

/*---------------*
 | integer_array |
 +---------------+
 | [1, 2, 3]     |
 *---------------*/
```

This extracts string values in a JSON-formatted string to an array:

```zetasql
-- Doesn't strip the double quotes
SELECT JSON_QUERY_ARRAY('["apples", "oranges", "grapes"]', '$') AS string_array;

/*---------------------------------*
 | string_array                    |
 +---------------------------------+
 | ["apples", "oranges", "grapes"] |
 *---------------------------------*/
```

```zetasql
-- Strips the double quotes
SELECT ARRAY(
  SELECT JSON_VALUE(string_element, '$')
  FROM UNNEST(JSON_QUERY_ARRAY('["apples", "oranges", "grapes"]', '$')) AS string_element
) AS string_array;

/*---------------------------*
 | string_array              |
 +---------------------------+
 | [apples, oranges, grapes] |
 *---------------------------*/
```

This extracts only the items in the `fruit` property to an array:

```zetasql
SELECT JSON_QUERY_ARRAY(
  '{"fruit": [{"apples": 5, "oranges": 10}, {"apples": 2, "oranges": 4}], "vegetables": [{"lettuce": 7, "kale": 8}]}',
  '$.fruit'
) AS string_array;

/*-------------------------------------------------------*
 | string_array                                          |
 +-------------------------------------------------------+
 | [{"apples":5,"oranges":10}, {"apples":2,"oranges":4}] |
 *-------------------------------------------------------*/
```

These are equivalent:

```zetasql
SELECT JSON_QUERY_ARRAY('{"fruits": ["apples", "oranges", "grapes"]}', '$.fruits') AS string_array;

SELECT JSON_QUERY_ARRAY('{"fruits": ["apples", "oranges", "grapes"]}', '$."fruits"') AS string_array;

-- The queries above produce the following result:
/*---------------------------------*
 | string_array                    |
 +---------------------------------+
 | ["apples", "oranges", "grapes"] |
 *---------------------------------*/
```

In cases where a JSON key uses invalid JSONPath characters, you can escape those
characters using double quotes: `" "`. For example:

```zetasql
SELECT JSON_QUERY_ARRAY('{"a.b": {"c": ["world"]}}', '$."a.b".c') AS hello;

/*-----------*
 | hello     |
 +-----------+
 | ["world"] |
 *-----------*/
```

The following examples show how invalid requests and empty arrays are handled:

```zetasql
-- An error is returned if you provide an invalid JSONPath.
SELECT JSON_QUERY_ARRAY('["foo", "bar", "baz"]', 'INVALID_JSONPath') AS result;

-- If the JSONPath doesn't refer to an array, then NULL is returned.
SELECT JSON_QUERY_ARRAY('{"a": "foo"}', '$.a') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If a key that doesn't exist is specified, then the result is NULL.
SELECT JSON_QUERY_ARRAY('{"a": "foo"}', '$.b') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- Empty arrays in JSON-formatted strings are supported.
SELECT JSON_QUERY_ARRAY('{"a": "foo", "b": []}', '$.b') AS result;

/*--------*
 | result |
 +--------+
 | []     |
 *--------*/
```

[JSONPath-format]: #JSONPath_format

[differences-json-and-string]: #differences_json_and_string

### `JSON_REMOVE`

```zetasql
JSON_REMOVE(json_expr, json_path[, ...])
```

Produces a new SQL `JSON` value with the specified JSON data removed.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '{"class": {"students": [{"name": "Jane"}]}}'
    ```
+   `json_path`: Remove data at this [JSONPath][JSONPath-format] in `json_expr`.

Details:

+   Paths are evaluated left to right. The JSON produced by evaluating the
    first path is the JSON for the next path.
+   The operation ignores non-existent paths and continue processing the rest
    of the paths.
+   For each path, the entire matched JSON subtree is deleted.
+   If the path matches a JSON object key, this function deletes the
    key-value pair.
+   If the path matches an array element, this function deletes the specific
    element from the matched array.
+   If removing the path results in an empty JSON object or empty JSON array,
    the empty structure is preserved.
+   If `json_path` is `$` or an invalid [JSONPath][JSONPath-format], an error is
    produced.
+   If `json_path` is SQL `NULL`, the path operation is ignored.

**Return type**

`JSON`

**Examples**

In the following example, the path `$[1]` is matched and removes
`["b", "c"]`.

```zetasql
SELECT JSON_REMOVE(JSON '["a", ["b", "c"], "d"]', '$[1]') AS json_data

/*-----------*
 | json_data |
 +-----------+
 | ["a","d"] |
 *-----------*/
```

You can use the field access operator to pass JSON data into this function.
For example:

```zetasql
WITH T AS (SELECT JSON '{"a": {"b": 10, "c": 20}}' AS data)
SELECT JSON_REMOVE(data.a, '$.b') AS json_data FROM T

/*-----------*
 | json_data |
 +-----------+
 | {"c":20}  |
 *-----------*/
```

In the following example, the first path `$[1]` is matched and removes
`["b", "c"]`. Then, the second path `$[1]` is matched and removes `"d"`.

```zetasql
SELECT JSON_REMOVE(JSON '["a", ["b", "c"], "d"]', '$[1]', '$[1]') AS json_data

/*-----------*
 | json_data |
 +-----------+
 | ["a"]     |
 *-----------*/
```

The structure of an empty array is preserved when all elements are deleted
from it. For example:

```zetasql
SELECT JSON_REMOVE(JSON '["a", ["b", "c"], "d"]', '$[1]', '$[1]', '$[0]') AS json_data

/*-----------*
 | json_data |
 +-----------+
 | []        |
 *-----------*/
```

In the following example, the path `$.a.b.c` is matched and removes the
`"c":"d"` key-value pair from the JSON object.

```zetasql
SELECT JSON_REMOVE(JSON '{"a": {"b": {"c": "d"}}}', '$.a.b.c') AS json_data

/*----------------*
 | json_data      |
 +----------------+
 | {"a":{"b":{}}} |
 *----------------*/
```

In the following example, the path `$.a.b` is matched and removes the
`"b": {"c":"d"}` key-value pair from the JSON object.

```zetasql
SELECT JSON_REMOVE(JSON '{"a": {"b": {"c": "d"}}}', '$.a.b') AS json_data

/*-----------*
 | json_data |
 +-----------+
 | {"a":{}}  |
 *-----------*/
```

In the following example, the path `$.b` isn't valid, so the operation makes
no changes.

```zetasql
SELECT JSON_REMOVE(JSON '{"a": 1}', '$.b') AS json_data

/*-----------*
 | json_data |
 +-----------+
 | {"a":1}   |
 *-----------*/
```

In the following example, path `$.a.b` and `$.b` don't exist, so those
operations are ignored, but the others are processed.

```zetasql
SELECT JSON_REMOVE(JSON '{"a": [1, 2, 3]}', '$.a[0]', '$.a.b', '$.b', '$.a[0]') AS json_data

/*-----------*
 | json_data |
 +-----------+
 | {"a":[3]} |
 *-----------*/
```

If you pass in `$` as the path, an error is produced. For example:

```zetasql
-- Error: The JSONPath can't be '$'
SELECT JSON_REMOVE(JSON '{}', '$') AS json_data
```

In the following example, the operation is ignored because you can't remove
data from a JSON null.

```zetasql
SELECT JSON_REMOVE(JSON 'null', '$.a.b') AS json_data

/*-----------*
 | json_data |
 +-----------+
 | null      |
 *-----------*/
```

### `JSON_SET`

```zetasql
JSON_SET(
  json_expr,
  json_path_value_pair[, ...]
  [, create_if_missing => { TRUE | FALSE } ]
)

json_path_value_pair:
  json_path, value
```

Produces a new SQL `JSON` value with the specified JSON data inserted
or replaced.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '{"class": {"students": [{"name": "Jane"}]}}'
    ```
+   `json_path_value_pair`: A value and the [JSONPath][JSONPath-format] for
    that value. This includes:

    +   `json_path`: Insert or replace `value` at this [JSONPath][JSONPath-format]
        in `json_expr`.

    +   `value`: A [JSON encoding-supported][json-encodings] value to
        insert.
+   `create_if_missing`: A named argument that takes a `BOOL` value.

    +   If `TRUE` (default), replaces or inserts data if the path doesn't exist.

    +   If `FALSE`, only existing JSONPath values are replaced. If the path
        doesn't exist, the set operation is ignored.

Details:

+   Path value pairs are evaluated left to right. The JSON produced by
    evaluating one pair becomes the JSON against which the next pair
    is evaluated.
+   If a matched path has an existing value, it overwrites the existing data
    with `value`.
+   If `create_if_missing` is `TRUE`:

      +  If a path doesn't exist, the remainder of the path is recursively
         created.
      +  If the matched path prefix points to a JSON null, the remainder of the
         path is recursively created, and `value` is inserted.
      +  If a path token points to a JSON array and the specified index is
         _larger_ than the size of the array, pads the JSON array with JSON
         nulls, recursively creates the remainder of the path at the specified
         index, and inserts the path value pair.
+   This function applies all path value pair set operations even if an
    individual path value pair operation is invalid. For invalid operations,
    the operation is ignored and the function continues to process the rest
    of the path value pairs.
+   If the path exists but has an incompatible type at any given path
    token, no update happens for that specific path value pair.
+   If any `json_path` is an invalid [JSONPath][JSONPath-format], an error is
    produced.
+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   If `json_path` is SQL `NULL`, the `json_path_value_pair` operation is
    ignored.
+   If `create_if_missing` is SQL `NULL`, the set operation is ignored.

**Return type**

`JSON`

**Examples**

In the following example, the path `$` matches the entire `JSON` value
and replaces it with `{"b": 2, "c": 3}`.

```zetasql
SELECT JSON_SET(JSON '{"a": 1}', '$', JSON '{"b": 2, "c": 3}') AS json_data

/*---------------*
 | json_data     |
 +---------------+
 | {"b":2,"c":3} |
 *---------------*/
```

In the following example, `create_if_missing` is `FALSE` and the path `$.b`
doesn't exist, so the set operation is ignored.

```zetasql
SELECT JSON_SET(
  JSON '{"a": 1}',
  "$.b", 999,
  create_if_missing => false) AS json_data

/*------------*
 | json_data  |
 +------------+
 | '{"a": 1}' |
 *------------*/
```

In the following example, `create_if_missing` is `TRUE` and the path `$.a`
exists, so the value is replaced.

```zetasql
SELECT JSON_SET(
  JSON '{"a": 1}',
  "$.a", 999,
  create_if_missing => false) AS json_data

/*--------------*
 | json_data    |
 +--------------+
 | '{"a": 999}' |
 *--------------*/
```

In the following example, the path `$.a` is matched, but `$.a.b` doesn't
exist, so the new path and the value are inserted.

```zetasql
SELECT JSON_SET(JSON '{"a": {}}', '$.a.b', 100) AS json_data

/*-----------------*
 | json_data       |
 +-----------------+
 | {"a":{"b":100}} |
 *-----------------*/
```

In the following example, the path prefix `$` points to a JSON null, so the
remainder of the path is created for the value `100`.

```zetasql
SELECT JSON_SET(JSON 'null', '$.a.b', 100) AS json_data

/*-----------------*
 | json_data       |
 +-----------------+
 | {"a":{"b":100}} |
 *-----------------*/
```

In the following example, the path `$.a.c` implies that the value at `$.a` is
a JSON object but it's not. This part of the operation is ignored, but the other
parts of the operation are completed successfully.

```zetasql
SELECT JSON_SET(
  JSON '{"a": 1}',
  '$.b', 2,
  '$.a.c', 100,
  '$.d', 3) AS json_data

/*---------------------*
 | json_data           |
 +---------------------+
 | {"a":1,"b":2,"d":3} |
 *---------------------*/
```

In the following example, the path `$.a[2]` implies that the value for `$.a` is
an array, but it's not, so the operation is ignored for that value.

```zetasql
SELECT JSON_SET(
  JSON '{"a": 1}',
  '$.a[2]', 100,
  '$.b', 2) AS json_data

/*---------------*
 | json_data     |
 +---------------+
 | {"a":1,"b":2} |
 *---------------*/
```

In the following example, the path `$[1]` is matched and replaces the
array element value with `foo`.

```zetasql
SELECT JSON_SET(JSON '["a", ["b", "c"], "d"]', '$[1]', "foo") AS json_data

/*-----------------*
 | json_data       |
 +-----------------+
 | ["a","foo","d"] |
 *-----------------*/
```

In the following example, the path `$[1][0]` is matched and replaces the
array element value with `foo`.

```zetasql
SELECT JSON_SET(JSON '["a", ["b", "c"], "d"]', '$[1][0]', "foo") AS json_data

/*-----------------------*
 | json_data             |
 +-----------------------+
 | ["a",["foo","c"],"d"] |
 *-----------------------*/
```

In the following example, the path prefix `$` points to a JSON null, so the
remainder of the path is created. The resulting array is padded with
JSON nulls and appended with `foo`.

```zetasql
SELECT JSON_SET(JSON 'null', '$[0][3]', "foo")

/*--------------------------*
 | json_data                |
 +--------------------------+
 | [[null,null,null,"foo"]] |
 *--------------------------*/
```

In the following example, the path `$[1]` is matched, the matched array is
extended since `$[1][4]` is larger than the existing array, and then `foo` is
inserted in the array.

```zetasql
SELECT JSON_SET(JSON '["a", ["b", "c"], "d"]', '$[1][4]', "foo") AS json_data

/*-------------------------------------*
 | json_data                           |
 +-------------------------------------+
 | ["a",["b","c",null,null,"foo"],"d"] |
 *-------------------------------------*/
```

In the following example, the path `$[1][0][0]` implies that the value of
`$[1][0]` is an array, but it isn't, so the operation is ignored.

```zetasql
SELECT JSON_SET(JSON '["a", ["b", "c"], "d"]', '$[1][0][0]', "foo") AS json_data

/*---------------------*
 | json_data           |
 +---------------------+
 | ["a",["b","c"],"d"] |
 *---------------------*/
```

In the following example, the path `$[1][2]` is larger than the length of
the matched array. The array length is extended and the remainder of the path
is recursively created. The operation continues to the path `$[1][2][1]`
and inserts `foo`.

```zetasql
SELECT JSON_SET(JSON '["a", ["b", "c"], "d"]', '$[1][2][1]', "foo") AS json_data

/*----------------------------------*
 | json_data                        |
 +----------------------------------+
 | ["a",["b","c",[null,"foo"]],"d"] |
 *----------------------------------*/
```

In the following example, because the `JSON` object is empty, key `b` is
inserted, and the remainder of the path is recursively created.

```zetasql
SELECT JSON_SET(JSON '{}', '$.b[2].d', 100) AS json_data

/*-----------------------------*
 | json_data                   |
 +-----------------------------+
 | {"b":[null,null,{"d":100}]} |
 *-----------------------------*/
```

In the following example, multiple values are set.

```zetasql
SELECT JSON_SET(
  JSON '{"a": 1, "b": {"c":3}, "d": [4]}',
  '$.a', 'v1',
  '$.b.e', 'v2',
  '$.d[2]', 'v3') AS json_data

/*---------------------------------------------------*
 | json_data                                         |
 +---------------------------------------------------+
 | {"a":"v1","b":{"c":3,"e":"v2"},"d":[4,null,"v3"]} |
 *---------------------------------------------------*/
```

### `JSON_STRIP_NULLS`

```zetasql
JSON_STRIP_NULLS(
  json_expr
  [, json_path ]
  [, include_arrays => { TRUE | FALSE } ]
  [, remove_empty => { TRUE | FALSE } ]
)
```

Recursively removes JSON nulls from JSON objects and JSON arrays.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '{"a": null, "b": "c"}'
    ```
+   `json_path`: Remove JSON nulls at this [JSONPath][JSONPath-format] for
    `json_expr`.
+   `include_arrays`: A named argument that's either
     `TRUE` (default) or `FALSE`. If `TRUE` or omitted, the function removes
     JSON nulls from JSON arrays. If `FALSE`, doesn't.
+   `remove_empty`: A named argument that's either
     `TRUE` or `FALSE` (default). If `TRUE`, the function removes empty
     JSON objects after JSON nulls are removed. If `FALSE` or omitted, doesn't.

    If `remove_empty` is `TRUE` and `include_arrays` is `TRUE` or omitted,
    the function additionally removes empty JSON arrays.

Details:

+   If a value is a JSON null, the associated key-value pair is removed.
+   If `remove_empty` is set to `TRUE`, the function recursively removes empty
    containers after JSON nulls are removed.
+   If the function generates JSON with nothing in it, the function returns a
    JSON null.
+   If `json_path` is an invalid [JSONPath][JSONPath-format], an error is
    produced.
+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   If `json_path`, `include_arrays`, or `remove_empty` is SQL `NULL`, the
    function returns `json_expr`.

**Return type**

`JSON`

**Examples**

In the following example, all JSON nulls are removed.

```zetasql
SELECT JSON_STRIP_NULLS(JSON '{"a": null, "b": "c"}') AS json_data

/*-----------*
 | json_data |
 +-----------+
 | {"b":"c"} |
 *-----------*/
```

In the following example, all JSON nulls are removed from a JSON array.

```zetasql
SELECT JSON_STRIP_NULLS(JSON '[1, null, 2, null]') AS json_data

/*-----------*
 | json_data |
 +-----------+
 | [1,2]     |
 *-----------*/
```

In the following example, `include_arrays` is set as `FALSE` so that JSON nulls
aren't removed from JSON arrays.

```zetasql
SELECT JSON_STRIP_NULLS(JSON '[1, null, 2, null]', include_arrays=>FALSE) AS json_data

/*-----------------*
 | json_data       |
 +-----------------+
 | [1,null,2,null] |
 *-----------------*/
```

In the following example, `remove_empty` is omitted and defaults to
`FALSE`, and the empty structures are retained.

```zetasql
SELECT JSON_STRIP_NULLS(JSON '[1, null, 2, null, [null]]') AS json_data

/*-----------*
 | json_data |
 +-----------+
 | [1,2,[]]  |
 *-----------*/
```

In the following example, `remove_empty` is set as `TRUE`, and the
empty structures are removed.

```zetasql
SELECT JSON_STRIP_NULLS(
  JSON '[1, null, 2, null, [null]]',
  remove_empty=>TRUE) AS json_data

/*-----------*
 | json_data |
 +-----------+
 | [1,2]     |
 *-----------*/
```

In the following examples, `remove_empty` is set as `TRUE`, and the
empty structures are removed. Because no JSON data is left the function
returns JSON null.

```zetasql
SELECT JSON_STRIP_NULLS(JSON '{"a": null}', remove_empty=>TRUE) AS json_data

/*-----------*
 | json_data |
 +-----------+
 | null      |
 *-----------*/
```

```zetasql
SELECT JSON_STRIP_NULLS(JSON '{"a": [null]}', remove_empty=>TRUE) AS json_data

/*-----------*
 | json_data |
 +-----------+
 | null      |
 *-----------*/
```

In the following example, empty structures are removed for JSON objects,
but not JSON arrays.

```zetasql
SELECT JSON_STRIP_NULLS(
  JSON '{"a": {"b": {"c": null}}, "d": [null], "e": [], "f": 1}',
  include_arrays=>FALSE,
  remove_empty=>TRUE) AS json_data

/*---------------------------*
 | json_data                 |
 +---------------------------+
 | {"d":[null],"e":[],"f":1} |
 *---------------------------*/
```

In the following example, empty structures are removed for both JSON objects,
and JSON arrays.

```zetasql
SELECT JSON_STRIP_NULLS(
  JSON '{"a": {"b": {"c": null}}, "d": [null], "e": [], "f": 1}',
  remove_empty=>TRUE) AS json_data

/*-----------*
 | json_data |
 +-----------+
 | {"f":1}   |
 *-----------*/
```

In the following example, because no JSON data is left, the function returns a
JSON null.

```zetasql
SELECT JSON_STRIP_NULLS(JSON 'null') AS json_data

/*-----------*
 | json_data |
 +-----------+
 | null      |
 *-----------*/
```

### `JSON_TYPE` 
<a id="json_type"></a>

```zetasql
JSON_TYPE(json_expr)
```

**Description**

Gets the JSON type of the outermost JSON value and converts the name of
this type to a SQL `STRING` value. The names of these JSON types can be
returned: `object`, `array`, `string`, `number`, `boolean`, `null`

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '{"name": "sky", "color": "blue"}'
    ```

    If this expression is SQL `NULL`, the function returns SQL `NULL`. If the
    extracted JSON value isn't a valid JSON type, an error is produced.

**Return type**

`STRING`

**Examples**

```zetasql
SELECT json_val, JSON_TYPE(json_val) AS type
FROM
  UNNEST(
    [
      JSON '"apple"',
      JSON '10',
      JSON '3.14',
      JSON 'null',
      JSON '{"city": "New York", "State": "NY"}',
      JSON '["apple", "banana"]',
      JSON 'false'
    ]
  ) AS json_val;

/*----------------------------------+---------*
 | json_val                         | type    |
 +----------------------------------+---------+
 | "apple"                          | string  |
 | 10                               | number  |
 | 3.14                             | number  |
 | null                             | null    |
 | {"State":"NY","city":"New York"} | object  |
 | ["apple","banana"]               | array   |
 | false                            | boolean |
 *----------------------------------+---------*/
```

### `JSON_VALUE`

```zetasql
JSON_VALUE(json_string_expr[, json_path])
```

```zetasql
JSON_VALUE(json_expr[, json_path])
```

**Description**

Extracts a JSON scalar value and converts it to a SQL `STRING` value.
In addition, this function:

+   Removes the outermost quotes and unescapes the values.
+   Returns a SQL `NULL` if a non-scalar value is selected.
+   Uses double quotes to escape invalid [JSONPath][JSONPath-format] characters
    in JSON keys. For example: `"a.b"`.

Arguments:

+   `json_string_expr`: A JSON-formatted string. For example:

    ```
    '{"name": "Jakob", "age": "6"}'
    ```
+   `json_expr`: JSON. For example:

    ```
    JSON '{"name": "Jane", "age": "6"}'
    ```
+   `json_path`: The [JSONPath][JSONPath-format]. This identifies the data that
    you want to obtain from the input. If this optional parameter isn't
    provided, then the JSONPath `$` symbol is applied, which means that all of
    the data is analyzed.

    If `json_path` returns a JSON `null` or a non-scalar value (in other words,
    if `json_path` refers to an object or an array), then a SQL `NULL` is
    returned.

There are differences between the JSON-formatted string and JSON input types.
For details, see [Differences between the JSON and JSON-formatted STRING types][differences-json-and-string].

**Return type**

`STRING`

**Examples**

In the following example, JSON data is extracted and returned as a scalar value.

```zetasql
SELECT JSON_VALUE(JSON '{"name": "Jakob", "age": "6" }', '$.age') AS scalar_age;

/*------------*
 | scalar_age |
 +------------+
 | 6          |
 *------------*/
```

The following example compares how results are returned for the `JSON_QUERY`
and `JSON_VALUE` functions.

```zetasql
SELECT JSON_QUERY('{"name": "Jakob", "age": "6"}', '$.name') AS json_name,
  JSON_VALUE('{"name": "Jakob", "age": "6"}', '$.name') AS scalar_name,
  JSON_QUERY('{"name": "Jakob", "age": "6"}', '$.age') AS json_age,
  JSON_VALUE('{"name": "Jakob", "age": "6"}', '$.age') AS scalar_age;

/*-----------+-------------+----------+------------*
 | json_name | scalar_name | json_age | scalar_age |
 +-----------+-------------+----------+------------+
 | "Jakob"   | Jakob       | "6"      | 6          |
 *-----------+-------------+----------+------------*/
```

```zetasql
SELECT JSON_QUERY('{"fruits": ["apple", "banana"]}', '$.fruits') AS json_query,
  JSON_VALUE('{"fruits": ["apple", "banana"]}', '$.fruits') AS json_value;

/*--------------------+------------*
 | json_query         | json_value |
 +--------------------+------------+
 | ["apple","banana"] | NULL       |
 *--------------------+------------*/
```

In cases where a JSON key uses invalid JSONPath characters, you can escape those
characters using double quotes. For example:

```zetasql
SELECT JSON_VALUE('{"a.b": {"c": "world"}}', '$."a.b".c') AS hello;

/*-------*
 | hello |
 +-------+
 | world |
 *-------*/
```

[JSONPath-format]: #JSONPath_format

[differences-json-and-string]: #differences_json_and_string

### `JSON_VALUE_ARRAY`

```zetasql
JSON_VALUE_ARRAY(json_string_expr[, json_path])
```

```zetasql
JSON_VALUE_ARRAY(json_expr[, json_path])
```

**Description**

Extracts a JSON array of scalar values and converts it to a SQL
`ARRAY<STRING>` value.
In addition, this function:

+   Removes the outermost quotes and unescapes the values.
+   Returns a SQL `NULL` if the selected value isn't an array or
    not an array containing only scalar values.
+   Uses double quotes to escape invalid [JSONPath][JSONPath-format] characters
    in JSON keys. For example: `"a.b"`.

Arguments:

+   `json_string_expr`: A JSON-formatted string. For example:

    ```
    '["apples", "oranges", "grapes"]'
    ```
+   `json_expr`: JSON. For example:

    ```
    JSON '["apples", "oranges", "grapes"]'
    ```
+   `json_path`: The [JSONPath][JSONPath-format]. This identifies the data that
    you want to obtain from the input. If this optional parameter isn't
    provided, then the JSONPath `$` symbol is applied, which means that all of
    the data is analyzed.

There are differences between the JSON-formatted string and JSON input types.
For details, see [Differences between the JSON and JSON-formatted STRING types][differences-json-and-string].

Caveats:

+ A JSON `null` in the input array produces a SQL `NULL` as the output for that
  JSON `null`.
+ If a JSONPath matches an array that contains scalar objects and a JSON `null`,
  then the output is an array of the scalar objects and a SQL `NULL`.

**Return type**

`ARRAY<STRING>`

**Examples**

This extracts items in JSON to a string array:

```zetasql
SELECT JSON_VALUE_ARRAY(
  JSON '{"fruits": ["apples", "oranges", "grapes"]}', '$.fruits'
  ) AS string_array;

/*---------------------------*
 | string_array              |
 +---------------------------+
 | [apples, oranges, grapes] |
 *---------------------------*/
```

The following example compares how results are returned for the
`JSON_QUERY_ARRAY` and `JSON_VALUE_ARRAY` functions.

```zetasql
SELECT JSON_QUERY_ARRAY('["apples", "oranges"]') AS json_array,
       JSON_VALUE_ARRAY('["apples", "oranges"]') AS string_array;

/*-----------------------+-------------------*
 | json_array            | string_array      |
 +-----------------------+-------------------+
 | ["apples", "oranges"] | [apples, oranges] |
 *-----------------------+-------------------*/
```

This extracts the items in a JSON-formatted string to a string array:

```zetasql
-- Strips the double quotes
SELECT JSON_VALUE_ARRAY('["foo", "bar", "baz"]', '$') AS string_array;

/*-----------------*
 | string_array    |
 +-----------------+
 | [foo, bar, baz] |
 *-----------------*/
```

This extracts a string array and converts it to an integer array:

```zetasql
SELECT ARRAY(
  SELECT CAST(integer_element AS INT64)
  FROM UNNEST(
    JSON_VALUE_ARRAY('[1, 2, 3]', '$')
  ) AS integer_element
) AS integer_array;

/*---------------*
 | integer_array |
 +---------------+
 | [1, 2, 3]     |
 *---------------*/
```

These are equivalent:

```zetasql
SELECT JSON_VALUE_ARRAY('{"fruits": ["apples", "oranges", "grapes"]}', '$.fruits') AS string_array;
SELECT JSON_VALUE_ARRAY('{"fruits": ["apples", "oranges", "grapes"]}', '$."fruits"') AS string_array;

-- The queries above produce the following result:
/*---------------------------*
 | string_array              |
 +---------------------------+
 | [apples, oranges, grapes] |
 *---------------------------*/
```

In cases where a JSON key uses invalid JSONPath characters, you can escape those
characters using double quotes: `" "`. For example:

```zetasql
SELECT JSON_VALUE_ARRAY('{"a.b": {"c": ["world"]}}', '$."a.b".c') AS hello;

/*---------*
 | hello   |
 +---------+
 | [world] |
 *---------*/
```

The following examples explore how invalid requests and empty arrays are
handled:

```zetasql
-- An error is thrown if you provide an invalid JSONPath.
SELECT JSON_VALUE_ARRAY('["foo", "bar", "baz"]', 'INVALID_JSONPath') AS result;

-- If the JSON-formatted string is invalid, then NULL is returned.
SELECT JSON_VALUE_ARRAY('}}', '$') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If the JSON document is NULL, then NULL is returned.
SELECT JSON_VALUE_ARRAY(NULL, '$') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If a JSONPath doesn't match anything, then the output is NULL.
SELECT JSON_VALUE_ARRAY('{"a": ["foo", "bar", "baz"]}', '$.b') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If a JSONPath matches an object that isn't an array, then the output is NULL.
SELECT JSON_VALUE_ARRAY('{"a": "foo"}', '$') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If a JSONPath matches an array of non-scalar objects, then the output is NULL.
SELECT JSON_VALUE_ARRAY('{"a": [{"b": "foo", "c": 1}, {"b": "bar", "c": 2}], "d": "baz"}', '$.a') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If a JSONPath matches an array of mixed scalar and non-scalar objects,
-- then the output is NULL.
SELECT JSON_VALUE_ARRAY('{"a": [10, {"b": 20}]', '$.a') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/

-- If a JSONPath matches an empty JSON array, then the output is an empty array instead of NULL.
SELECT JSON_VALUE_ARRAY('{"a": "foo", "b": []}', '$.b') AS result;

/*--------*
 | result |
 +--------+
 | []     |
 *--------*/

-- In the following query, the JSON null input is returned as a
-- SQL NULL in the output.
SELECT JSON_VALUE_ARRAY('["world", null, 1]') AS result;

/*------------------*
 | result           |
 +------------------+
 | [world, NULL, 1] |
 *------------------*/

```

[JSONPath-format]: #JSONPath_format

[differences-json-and-string]: #differences_json_and_string

### `LAX_BOOL` 
<a id="lax_bool"></a>

```zetasql
LAX_BOOL(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `BOOL` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON 'true'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>BOOL</code></th>
  </tr>
  <tr>
    <td>boolean</td>
    <td>
      If the JSON boolean is <code>true</code>, returns <code>TRUE</code>.
      Otherwise, returns <code>FALSE</code>.
    </td>
  </tr>
  <tr>
    <td>string</td>
    <td>
      If the JSON string is <code>'true'</code>, returns <code>TRUE</code>.
      If the JSON string is <code>'false'</code>, returns <code>FALSE</code>.
      If the JSON string is any other value or has whitespace in it,
      returns <code>NULL</code>.
      This conversion is case-insensitive.
    </td>
  </tr>
  <tr>
    <td>number</td>
    <td>
      If the JSON number is a representation of <code>0</code>,
      returns <code>FALSE</code>. Otherwise, returns <code>TRUE</code>.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`BOOL`

**Examples**

Example with input that's a JSON boolean:

```zetasql
SELECT LAX_BOOL(JSON 'true') AS result;

/*--------*
 | result |
 +--------+
 | true   |
 *--------*/
```

Examples with inputs that are JSON strings:

```zetasql
SELECT LAX_BOOL(JSON '"true"') AS result;

/*--------*
 | result |
 +--------+
 | TRUE   |
 *--------*/
```

```zetasql
SELECT LAX_BOOL(JSON '"true "') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_BOOL(JSON '"foo"') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

Examples with inputs that are JSON numbers:

```zetasql
SELECT LAX_BOOL(JSON '10') AS result;

/*--------*
 | result |
 +--------+
 | TRUE   |
 *--------*/
```

```zetasql
SELECT LAX_BOOL(JSON '0') AS result;

/*--------*
 | result |
 +--------+
 | FALSE  |
 *--------*/
```

```zetasql
SELECT LAX_BOOL(JSON '0.0') AS result;

/*--------*
 | result |
 +--------+
 | FALSE  |
 *--------*/
```

```zetasql
SELECT LAX_BOOL(JSON '-1.1') AS result;

/*--------*
 | result |
 +--------+
 | TRUE   |
 *--------*/
```

### `LAX_BOOL_ARRAY` 
<a id="lax_bool_array"></a>

```zetasql
LAX_BOOL_ARRAY(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `ARRAY<BOOL>` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[true]'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>ARRAY&lt;BOOL&gt;</code></th>
  </tr>
  <tr>
    <td>array</td>
    <td>
      Converts every element according to <a href="#lax_bool"><code>LAX_BOOL</code></a> conversion rules.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`ARRAY<BOOL>`

**Examples**

Example with input that's a JSON array of booleans:

```zetasql
SELECT LAX_BOOL_ARRAY(JSON '[true, false]') AS result;

/*---------------*
 | result        |
 +---------------+
 | [true, false] |
 *---------------*/
```

Examples with inputs that are JSON arrays of strings:

```zetasql
SELECT LAX_BOOL_ARRAY(JSON '["true", "false", "TRue", "FaLse"]') AS result;

/*----------------------------*
 | result                     |
 +----------------------------+
 | [true, false, true, false] |
 *----------------------------*/
```

```zetasql
SELECT LAX_BOOL_ARRAY(JSON '["true ", "foo", "null", ""]') AS result;

/*-------------------------*
 | result                  |
 +-------------------------+
 | [NULL, NULL, NULL, NULL |
 *-------------------------*/
```

Examples with input that's JSON array of numbers:

```zetasql
SELECT LAX_BOOL_ARRAY(JSON '[10, 0, 0.0, -1.1]') AS result;

/*--------------------------*
 | result                   |
 +--------------------------+
 | TRUE, FALSE, FALSE, TRUE |
 *--------------------------*/
```

Example with input that's JSON array of other types:

```zetasql
SELECT LAX_BOOL_ARRAY(JSON '[null, {"foo": 1}, [1]]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Examples with inputs that aren't JSON arrays:

```zetasql
SELECT LAX_BOOL_ARRAY(NULL) AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_BOOL_ARRAY(JSON 'null') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_BOOL_ARRAY(JSON 'true') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `LAX_DOUBLE` 
<a id="lax_double"></a>

```zetasql
LAX_DOUBLE(json_expr)
```

**Description**

Attempts to convert a JSON value to a
SQL `DOUBLE` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '9.8'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>DOUBLE</code></th>
  </tr>
  <tr>
    <td>boolean</td>
    <td>
      <code>NULL</code>
    </td>
  </tr>
  <tr>
    <td>string</td>
    <td>
      If the JSON string represents a JSON number, parses it as
      a <code>BIGNUMERIC</code> value, and then safe casts the result as a
      <code>DOUBLE</code> value.
      If the JSON string can't be converted, returns <code>NULL</code>.
    </td>
  </tr>
  <tr>
    <td>number</td>
    <td>
      Casts the JSON number as a
      <code>DOUBLE</code> value.
      Large JSON numbers are rounded.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`DOUBLE`

**Examples**

Examples with inputs that are JSON numbers:

```zetasql
SELECT LAX_DOUBLE(JSON '9.8') AS result;

/*--------*
 | result |
 +--------+
 | 9.8    |
 *--------*/
```

```zetasql
SELECT LAX_DOUBLE(JSON '9') AS result;

/*--------*
 | result |
 +--------+
 | 9.0    |
 *--------*/
```

```zetasql
SELECT LAX_DOUBLE(JSON '9007199254740993') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | 9007199254740992.0 |
 *--------------------*/
```

```zetasql
SELECT LAX_DOUBLE(JSON '1e100') AS result;

/*--------*
 | result |
 +--------+
 | 1e+100 |
 *--------*/
```

Examples with inputs that are JSON booleans:

```zetasql
SELECT LAX_DOUBLE(JSON 'true') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_DOUBLE(JSON 'false') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

Examples with inputs that are JSON strings:

```zetasql
SELECT LAX_DOUBLE(JSON '"10"') AS result;

/*--------*
 | result |
 +--------+
 | 10.0   |
 *--------*/
```

```zetasql
SELECT LAX_DOUBLE(JSON '"1.1"') AS result;

/*--------*
 | result |
 +--------+
 | 1.1    |
 *--------*/
```

```zetasql
SELECT LAX_DOUBLE(JSON '"1.1e2"') AS result;

/*--------*
 | result |
 +--------+
 | 110.0  |
 *--------*/
```

```zetasql
SELECT LAX_DOUBLE(JSON '"9007199254740993"') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | 9007199254740992.0 |
 *--------------------*/
```

```zetasql
SELECT LAX_DOUBLE(JSON '"+1.5"') AS result;

/*--------*
 | result |
 +--------+
 | 1.5    |
 *--------*/
```

```zetasql
SELECT LAX_DOUBLE(JSON '"NaN"') AS result;

/*--------*
 | result |
 +--------+
 | NaN    |
 *--------*/
```

```zetasql
SELECT LAX_DOUBLE(JSON '"Inf"') AS result;

/*----------*
 | result   |
 +----------+
 | Infinity |
 *----------*/
```

```zetasql
SELECT LAX_DOUBLE(JSON '"-InfiNiTY"') AS result;

/*-----------*
 | result    |
 +-----------+
 | -Infinity |
 *-----------*/
```

```zetasql
SELECT LAX_DOUBLE(JSON '"foo"') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `LAX_DOUBLE_ARRAY` 
<a id="lax_double_array"></a>

```zetasql
LAX_DOUBLE_ARRAY(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `ARRAY<DOUBLE>`
value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[9.8]'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>ARRAY&lt;DOUBLE&gt;</code></th>
  </tr>
  <tr>
    <td>array</td>
    <td>
      Converts every element according to
      <a href="#lax_double"><code>LAX_DOUBLE</code></a>
      conversion rules.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`ARRAY<DOUBLE>`

**Examples**

Examples with inputs that are JSON arrays of numbers:

```zetasql
SELECT LAX_DOUBLE_ARRAY(JSON '[9.8, 9]') AS result;

/*-------------*
 | result      |
 +-------------+
 | [9.8, 9.0,] |
 *-------------*/
```

```zetasql
SELECT LAX_DOUBLE_ARRAY(JSON '[9007199254740993, -9007199254740993]') AS result;

/*-------------------------------------------*
 | result                                    |
 +-------------------------------------------+
 | [9007199254740992.0, -9007199254740992.0] |
 *-------------------------------------------*/
```

```zetasql
SELECT LAX_DOUBLE_ARRAY(JSON '[-1.79769e+308, 2.22507e-308, 1.79769e+308, 1e100]') AS result;

/*-----------------------------------------------------*
 | result                                              |
 +-----------------------------------------------------+
 | [-1.79769e+308, 2.22507e-308, 1.79769e+308, 1e+100] |
 *-----------------------------------------------------*/
```

Example with inputs that's JSON array of booleans:

```zetasql
SELECT LAX_DOUBLE_ARRAY(JSON '[true, false]') AS result;

/*----------------*
 | result         |
 +----------------+
 | [NULL, NULL]   |
 *----------------*/
```

Examples with inputs that are JSON arrays of strings:

```zetasql
SELECT LAX_DOUBLE_ARRAY(JSON '["10", "1.1", "1.1e2", "+1.5"]') AS result;

/*-------------------------*
 | result                  |
 +-------------------------+
 | [10.0, 1.1, 110.0, 1.5] |
 *-------------------------*/
```

```zetasql
SELECT LAX_DOUBLE_ARRAY(JSON '["9007199254740993"]') AS result;

/*----------------------*
 | result               |
 +----------------------+
 | [9007199254740992.0] |
 *----------------------*/
```

```zetasql
SELECT LAX_DOUBLE_ARRAY(JSON '["NaN", "Inf", "-InfiNiTY"]') AS result;

/*----------------------------*
 | result                     |
 +----------------------------+
 | [NaN, Infinity, -Infinity] |
 *----------------------------*/
```

```zetasql
SELECT LAX_DOUBLE_ARRAY(JSON '["foo", "null", ""]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Example with input that's JSON array of other types:

```zetasql
SELECT LAX_DOUBLE_ARRAY(JSON '[null, {"foo": 1}, [1]]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Examples with inputs that aren't JSON arrays:

```zetasql
SELECT LAX_DOUBLE_ARRAY(NULL) AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_DOUBLE_ARRAY(JSON 'null') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_DOUBLE_ARRAY(JSON '9.8') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `LAX_FLOAT` 
<a id="lax_float"></a>

```zetasql
LAX_FLOAT(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `FLOAT` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '9.8'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>FLOAT</code></th>
  </tr>
  <tr>
    <td>boolean</td>
    <td>
      <code>NULL</code>
    </td>
  </tr>
  <tr>
    <td>string</td>
    <td>
      If the JSON string represents a JSON number, parses it as
      a <code>BIGNUMERIC</code> value, and then safe casts the result as a
      <code>FLOAT</code> value.
      If the JSON string can't be converted, returns <code>NULL</code>.
    </td>
  </tr>
  <tr>
    <td>number</td>
    <td>
      Casts the JSON number as a
      <code>FLOAT</code> value.
      Large JSON numbers are rounded.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`FLOAT`

**Examples**

Examples with inputs that are JSON numbers:

```zetasql
SELECT LAX_FLOAT(JSON '9.8') AS result;

/*--------*
 | result |
 +--------+
 | 9.8    |
 *--------*/
```

```zetasql
SELECT LAX_FLOAT(JSON '9') AS result;

/*--------*
 | result |
 +--------+
 | 9.0    |
 *--------*/
```

```zetasql
SELECT LAX_FLOAT(JSON '16777217') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | 16777216.0         |
 *--------------------*/
```

```zetasql
SELECT LAX_FLOAT(JSON '1e100') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

Examples with inputs that are JSON booleans:

```zetasql
SELECT LAX_FLOAT(JSON 'true') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_FLOAT(JSON 'false') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

Examples with inputs that are JSON strings:

```zetasql
SELECT LAX_FLOAT(JSON '"10"') AS result;

/*--------*
 | result |
 +--------+
 | 10.0   |
 *--------*/
```

```zetasql
SELECT LAX_FLOAT(JSON '"1.1"') AS result;

/*--------*
 | result |
 +--------+
 | 1.1    |
 *--------*/
```

```zetasql
SELECT LAX_FLOAT(JSON '"1.1e2"') AS result;

/*--------*
 | result |
 +--------+
 | 110.0  |
 *--------*/
```

```zetasql
SELECT LAX_FLOAT(JSON '"16777217"') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | 16777216.0         |
 *--------------------*/
```

```zetasql
SELECT LAX_FLOAT(JSON '"+1.5"') AS result;

/*--------*
 | result |
 +--------+
 | 1.5    |
 *--------*/
```

```zetasql
SELECT LAX_FLOAT(JSON '"NaN"') AS result;

/*--------*
 | result |
 +--------+
 | NaN    |
 *--------*/
```

```zetasql
SELECT LAX_FLOAT(JSON '"Inf"') AS result;

/*----------*
 | result   |
 +----------+
 | Infinity |
 *----------*/
```

```zetasql
SELECT LAX_FLOAT(JSON '"-InfiNiTY"') AS result;

/*-----------*
 | result    |
 +-----------+
 | -Infinity |
 *-----------*/
```

```zetasql
SELECT LAX_FLOAT(JSON '"foo"') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `LAX_FLOAT_ARRAY` 
<a id="lax_float_array"></a>

```zetasql
LAX_FLOAT_ARRAY(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `ARRAY<FLOAT>` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[9.8, 9]'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>ARRAY&lt;FLOAT&gt;</code></th>
  </tr>
<tr>
    <td>array</td>
    <td>
      Converts every element according to
      <a href="#lax_float"><code>LAX_FLOAT_ARRAY</code></a>
      conversion rules.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`ARRAY<FLOAT>`

**Examples**

Examples with inputs that are JSON arrays of numbers:

```zetasql
SELECT LAX_FLOAT_ARRAY(JSON '[9.8, 9]') AS result;

/*------------*
 | result     |
 +------------+
 | [9.8, 9.0] |
 *------------*/
```

```zetasql
SELECT LAX_FLOAT_ARRAY(JSON '[16777217, -16777217]') AS result;

/*---------------------------*
 | result                    |
 +---------------------------+
 | [16777216.0, -16777216.0] |
 *---------------------------*/
```

```zetasql
SELECT LAX_FLOAT_ARRAY(JSON '[-3.40282e+38, 1.17549e-38, 3.40282e+38]') AS result;

/*------------------------------------------*
 | result                                   |
 +------------------------------------------+
 | [-3.40282e+38, 1.17549e-38, 3.40282e+38] |
 *------------------------------------------*/
```

```zetasql
SELECT LAX_FLOAT_ARRAY(JSON '[-1.79769e+308, 2.22507e-308, 1.79769e+308, 1e100]') AS result;

/*-----------------------*
 | result                |
 +-----------------------+
 | [NULL, 0, NULL, NULL] |
 *-----------------------*/
```

Example with inputs that's JSON array of booleans:

```zetasql
SELECT LAX_FLOAT_ARRAY(JSON '[true, false]') AS result;

/*----------------*
 | result         |
 +----------------+
 | [NULL, NULL]   |
 *----------------*/
```

Examples with inputs that are JSON arrays of strings:

```zetasql
SELECT LAX_FLOAT_ARRAY(JSON '["10", "1.1", "1.1e2", "+1.5"]') AS result;

/*-------------------------*
 | result                  |
 +-------------------------+
 | [10.0, 1.1, 110.0, 1.5] |
 *------------------------*/
```

```zetasql
SELECT LAX_FLOAT_ARRAY(JSON '["16777217"]') AS result;

/*--------------*
 | result       |
 +--------------+
 | [16777216.0] |
 *--------------*/
```

```zetasql
SELECT LAX_FLOAT_ARRAY(JSON '["NaN", "Inf", "-InfiNiTY"]') AS result;

/*----------------------------*
 | result                     |
 +----------------------------+
 | [NaN, Infinity, -Infinity] |
 *----------------------------*/
```

```zetasql
SELECT LAX_FLOAT_ARRAY(JSON '["foo", "null", ""]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Example with input that's JSON array of other types:

```zetasql
SELECT LAX_FLOAT_ARRAY(JSON '[null, {"foo": 1}, [1]]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Examples with inputs that aren't JSON arrays:

```zetasql
SELECT LAX_FLOAT_ARRAY(NULL) AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_FLOAT_ARRAY(JSON 'null') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_FLOAT_ARRAY(JSON '9.8') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `LAX_INT32` 
<a id="lax_int32"></a>

```zetasql
LAX_INT32(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `INT32` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '999'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>INT32</code></th>
  </tr>
  <tr>
    <td>boolean</td>
    <td>
      If the JSON boolean is <code>true</code>, returns <code>1</code>.
      If <code>false</code>, returns <code>0</code>.
    </td>
  </tr>
  <tr>
    <td>string</td>
    <td>
      If the JSON string represents a JSON number, parses it as
      a <code>BIGNUMERIC</code> value, and then safe casts the results as an
      <code>INT32</code> value.
      If the JSON string can't be converted, returns <code>NULL</code>.
    </td>
  </tr>
  <tr>
    <td>number</td>
    <td>
      Casts the JSON number as an <code>INT32</code> value.
      If the JSON number can't be converted, returns <code>NULL</code>.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`INT32`

**Examples**

Examples with inputs that are JSON numbers:

```zetasql
SELECT LAX_INT32(JSON '10') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_INT32(JSON '10.0') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_INT32(JSON '1.1') AS result;

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

```zetasql
SELECT LAX_INT32(JSON '3.5') AS result;

/*--------*
 | result |
 +--------+
 | 4      |
 *--------*/
```

```zetasql
SELECT LAX_INT32(JSON '1.1e2') AS result;

/*--------*
 | result |
 +--------+
 | 110    |
 *--------*/
```

```zetasql
SELECT LAX_INT32(JSON '1e100') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

Examples with inputs that are JSON booleans:

```zetasql
SELECT LAX_INT32(JSON 'true') AS result;

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

```zetasql
SELECT LAX_INT32(JSON 'false') AS result;

/*--------*
 | result |
 +--------+
 | 0      |
 *--------*/
```

Examples with inputs that are JSON strings:

```zetasql
SELECT LAX_INT32(JSON '"10"') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_INT32(JSON '"1.1"') AS result;

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

```zetasql
SELECT LAX_INT32(JSON '"1.1e2"') AS result;

/*--------*
 | result |
 +--------+
 | 110    |
 *--------*/
```

```zetasql
SELECT LAX_INT32(JSON '"+1.5"') AS result;

/*--------*
 | result |
 +--------+
 | 2      |
 *--------*/
```

```zetasql
SELECT LAX_INT32(JSON '"1e100"') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_INT32(JSON '"foo"') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `LAX_INT32_ARRAY` 
<a id="lax_int32_array"></a>

```zetasql
LAX_INT32_ARRAY(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `ARRAY<INT32>` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[999, 12]'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>ARRAY&lt;INT32&gt;</code></th>
  </tr>
  <tr>
    <td>array</td>
    <td>
      Converts every element according to <a href="#lax_int32"><code>LAX_INT32</code></a> conversion rules.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`ARRAY<INT32>`

**Examples**

Examples with inputs that are JSON arrays of numbers:

```zetasql
SELECT LAX_INT32_ARRAY(JSON '[10, 10.0, 1.1, 3.5, 1.1e2]') AS result;

/*---------------------*
 | result              |
 +---------------------+
 | [10, 10, 1, 4, 110] |
 *---------------- ----*/
```

```zetasql
SELECT LAX_INT32_ARRAY(JSON '[1e100]') AS result;

/*--------*
 | result |
 +--------+
 | [NULL] |
 *--------*/
```

Example with inputs that's JSON array of booleans:

```zetasql
SELECT LAX_INT32_ARRAY(JSON '[true, false]') AS result;

/*--------*
 | result |
 +--------+
 | [1, 0] |
 *--------*/
```

Examples with inputs that are JSON strings:

```zetasql
SELECT LAX_INT32_ARRAY(JSON '["10", "1.1", "1.1e2", "+1.5"]') AS result;

/*-----------------*
 | result          |
 +-----------------+
 | [10, 1, 110, 2] |
 *-----------------*/
```

```zetasql
SELECT LAX_INT32_ARRAY(JSON '["1e100"]') AS result;

/*--------*
 | result |
 +--------+
 | [NULL] |
 *--------*/
```

```zetasql
SELECT LAX_INT32_ARRAY(JSON '["foo", "null", ""]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Example with input that's JSON array of other types:

```zetasql
SELECT LAX_INT32_ARRAY(JSON '[null, {"foo": 1}, [1]]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Examples with inputs that aren't JSON arrays:

```zetasql
SELECT LAX_INT32_ARRAY(NULL) AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_INT32_ARRAY(JSON 'null') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_INT32_ARRAY(JSON '9.8') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `LAX_INT64` 
<a id="lax_int64"></a>

```zetasql
LAX_INT64(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `INT64` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '999'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>INT64</code></th>
  </tr>
  <tr>
    <td>boolean</td>
    <td>
      If the JSON boolean is <code>true</code>, returns <code>1</code>.
      If <code>false</code>, returns <code>0</code>.
    </td>
  </tr>
  <tr>
    <td>string</td>
    <td>
      If the JSON string represents a JSON number, parses it as
      a <code>BIGNUMERIC</code> value, and then safe casts the results as an
      <code>INT64</code> value.
      If the JSON string can't be converted, returns <code>NULL</code>.
    </td>
  </tr>
  <tr>
    <td>number</td>
    <td>
      Casts the JSON number as an <code>INT64</code> value.
      If the JSON number can't be converted, returns <code>NULL</code>.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`INT64`

**Examples**

Examples with inputs that are JSON numbers:

```zetasql
SELECT LAX_INT64(JSON '10') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_INT64(JSON '10.0') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_INT64(JSON '1.1') AS result;

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

```zetasql
SELECT LAX_INT64(JSON '3.5') AS result;

/*--------*
 | result |
 +--------+
 | 4      |
 *--------*/
```

```zetasql
SELECT LAX_INT64(JSON '1.1e2') AS result;

/*--------*
 | result |
 +--------+
 | 110    |
 *--------*/
```

```zetasql
SELECT LAX_INT64(JSON '1e100') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

Examples with inputs that are JSON booleans:

```zetasql
SELECT LAX_INT64(JSON 'true') AS result;

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

```zetasql
SELECT LAX_INT64(JSON 'false') AS result;

/*--------*
 | result |
 +--------+
 | 0      |
 *--------*/
```

Examples with inputs that are JSON strings:

```zetasql
SELECT LAX_INT64(JSON '"10"') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_INT64(JSON '"1.1"') AS result;

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

```zetasql
SELECT LAX_INT64(JSON '"1.1e2"') AS result;

/*--------*
 | result |
 +--------+
 | 110    |
 *--------*/
```

```zetasql
SELECT LAX_INT64(JSON '"+1.5"') AS result;

/*--------*
 | result |
 +--------+
 | 2      |
 *--------*/
```

```zetasql
SELECT LAX_INT64(JSON '"1e100"') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_INT64(JSON '"foo"') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `LAX_INT64_ARRAY` 
<a id="lax_int64_array"></a>

```zetasql
LAX_INT64_ARRAY(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `ARRAY<INT64>` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[999, 12]'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>ARRAY&lt;INT64&gt;</code></th>
  </tr>
  <tr>
    <td>array</td>
    <td>
      Converts every element according to <a href="#lax_int64"><code>LAX_INT64</code></a> conversion rules.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`ARRAY<INT64>`

**Examples**

Examples with inputs that are JSON arrays of numbers:

```zetasql
SELECT LAX_INT64_ARRAY(JSON '[10, 10.0, 1.1, 3.5, 1.1e2]') AS result;

/*---------------------*
 | result              |
 +---------------------+
 | [10, 10, 1, 4, 110] |
 *---------------------*/
```

```zetasql
SELECT LAX_INT64_ARRAY(JSON '[1e100]') AS result;

/*--------*
 | result |
 +--------+
 | [NULL] |
 *--------*/
```

Example with inputs that's JSON array of booleans:

```zetasql
SELECT LAX_INT64_ARRAY(JSON '[true, false]') AS result;

/*--------*
 | result |
 +--------+
 | [1, 0] |
 *--------*/
```

Examples with inputs that are JSON strings:

```zetasql
SELECT LAX_INT64_ARRAY(JSON '["10", "1.1", "1.1e2", "+1.5"]') AS result;

/*-----------------*
 | result          |
 +-----------------+
 | [10, 1, 110, 2] |
 *-----------------*/
```

```zetasql
SELECT LAX_INT64_ARRAY(JSON '["1e100"]') AS result;

/*--------*
 | result |
 +--------+
 | [NULL] |
 *--------*/
```

```zetasql
SELECT LAX_INT64_ARRAY(JSON '["foo", "null", ""]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Example with input that's JSON array of other types:

```zetasql
SELECT LAX_INT64_ARRAY(JSON '[null, {"foo": 1}, [1]]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Examples with inputs that aren't JSON arrays:

```zetasql
SELECT LAX_INT64_ARRAY(NULL) AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_INT64_ARRAY(JSON 'null') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_INT64_ARRAY(JSON '9.8') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `LAX_STRING` 
<a id="lax_string"></a>

```zetasql
LAX_STRING(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `STRING` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '"name"'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>STRING</code></th>
  </tr>
  <tr>
    <td>boolean</td>
    <td>
      If the JSON boolean is <code>true</code>, returns <code>'true'</code>.
      If <code>false</code>, returns <code>'false'</code>.
    </td>
  </tr>
  <tr>
    <td>string</td>
    <td>
      Returns the JSON string as a <code>STRING</code> value.
    </td>
  </tr>
  <tr>
    <td>number</td>
    <td>
      Returns the JSON number as a <code>STRING</code> value.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`STRING`

**Examples**

Examples with inputs that are JSON strings:

```zetasql
SELECT LAX_STRING(JSON '"purple"') AS result;

/*--------*
 | result |
 +--------+
 | purple |
 *--------*/
```

```zetasql
SELECT LAX_STRING(JSON '"10"') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

Examples with inputs that are JSON booleans:

```zetasql
SELECT LAX_STRING(JSON 'true') AS result;

/*--------*
 | result |
 +--------+
 | true   |
 *--------*/
```

```zetasql
SELECT LAX_STRING(JSON 'false') AS result;

/*--------*
 | result |
 +--------+
 | false  |
 *--------*/
```

Examples with inputs that are JSON numbers:

```zetasql
SELECT LAX_STRING(JSON '10.0') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_STRING(JSON '10') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_STRING(JSON '1e100') AS result;

/*--------*
 | result |
 +--------+
 | 1e+100 |
 *--------*/
```

### `LAX_STRING_ARRAY` 
<a id="lax_string_array"></a>

```zetasql
LAX_STRING_ARRAY(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `ARRAY<STRING>` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '["a", "b"]'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>STRING</code></th>
  </tr>
  <tr>
    <td>array</td>
    <td>
      Converts every element according to <a href="#lax_string"><code>LAX_STRING</code></a> conversion rules.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`ARRAY<STRING>`

**Examples**

Example with input that's a JSON array of strings:

```zetasql
SELECT LAX_STRING_ARRAY(JSON '["purple", "10"]') AS result;

/*--------------*
 | result       |
 +--------------+
 | [purple, 10] |
 *--------------*/
```

Example with input that's a JSON array of booleans:

```zetasql
SELECT LAX_STRING_ARRAY(JSON '[true, false]') AS result;

/*---------------*
 | result        |
 +---------------+
 | [true, false] |
 *---------------*/
```

Example with input that's a JSON array of numbers:

```zetasql
SELECT LAX_STRING_ARRAY(JSON '[10.0, 10, 1e100]') AS result;

/*------------------*
 | result           |
 +------------------+
 | [10, 10, 1e+100] |
 *------------------*/
```

Example with input that's a JSON array of other types:

```zetasql
SELECT LAX_STRING_ARRAY(JSON '[null, {"foo": 1}, [1]]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Examples with inputs that aren't JSON arrays:

```zetasql
SELECT LAX_STRING_ARRAY(NULL) AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_STRING_ARRAY(JSON 'null') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_STRING_ARRAY(JSON '9.8') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `LAX_UINT32` 
<a id="lax_uint32"></a>

```zetasql
LAX_UINT32(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `UINT32` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '999'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>UINT32</code></th>
  </tr>
  <tr>
    <td>boolean</td>
    <td>
      If the JSON boolean is <code>true</code>, returns <code>1</code>.
      If <code>false</code>, returns <code>0</code>.
    </td>
  </tr>
  <tr>
    <td>string</td>
    <td>
      If the JSON string represents a JSON number, parses it as
      a <code>BIGNUMERIC</code> value, and then safe casts the results as an
      <code>UINT32</code> value.
      If the JSON string can't be converted, returns <code>NULL</code>.
    </td>
  </tr>
  <tr>
    <td>number</td>
    <td>
      Casts the JSON number as an <code>UINT32</code> value.
      If the JSON number can't be converted, returns <code>NULL</code>.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`UINT32`

**Examples**

Examples with inputs that are JSON numbers:

```zetasql
SELECT LAX_UINT32(JSON '10') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_UINT32(JSON '10.0') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_UINT32(JSON '1.1') AS result;

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

```zetasql
SELECT LAX_UINT32(JSON '3.5') AS result;

/*--------*
 | result |
 +--------+
 | 4      |
 *--------*/
```

```zetasql
SELECT LAX_UINT32(JSON '1.1e2') AS result;

/*--------*
 | result |
 +--------+
 | 110    |
 *--------*/
```

```zetasql
SELECT LAX_UINT32(JSON '-1') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_UINT32(JSON '1e100') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

Examples with inputs that are JSON booleans:

```zetasql
SELECT LAX_UINT32(JSON 'true') AS result;

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

```zetasql
SELECT LAX_UINT32(JSON 'false') AS result;

/*--------*
 | result |
 +--------+
 | 0      |
 *--------*/
```

Examples with inputs that are JSON strings:

```zetasql
SELECT LAX_UINT32(JSON '"10"') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_UINT32(JSON '"1.1"') AS result;

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

```zetasql
SELECT LAX_UINT32(JSON '"1.1e2"') AS result;

/*--------*
 | result |
 +--------+
 | 110    |
 *--------*/
```

```zetasql
SELECT LAX_UINT32(JSON '"+1.5"') AS result;

/*--------*
 | result |
 +--------+
 | 2      |
 *--------*/
```

```zetasql
SELECT LAX_UINT32(JSON '"1e100"') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_UINT32(JSON '"foo"') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `LAX_UINT32_ARRAY` 
<a id="lax_uint32_array"></a>

```zetasql
LAX_UINT32_ARRAY(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `ARRAY<UINT32>` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[999, 12]'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>ARRAY&lt;UINT32&gt;</code></th>
  </tr>
  <tr>
    <td>array</td>
    <td>
      Converts every element according to
      <a href="#lax_uint32"><code>LAX_UINT32</code></a>
      conversion rules.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`ARRAY<UINT32>`

**Examples**

Examples with inputs that are JSON arrays of numbers:

```zetasql
SELECT LAX_UINT32_ARRAY(JSON '[10, 10.0, 1.1, 3.5, 1.1e2]') AS result;

/*---------------------*
 | result              |
 +---------------------+
 | [10, 10, 1, 4, 110] |
 *---------------------*/
```

```zetasql
SELECT LAX_UINT32_ARRAY(JSON '[1e100]') AS result;

/*--------*
 | result |
 +--------+
 | [NULL] |
 *--------*/
```

Example with inputs that's a JSON array of booleans:

```zetasql
SELECT LAX_UINT32_ARRAY(JSON '[true, false]') AS result;

/*--------*
 | result |
 +--------+
 | [1, 0] |
 *--------*/
```

Examples with inputs that are JSON strings:

```zetasql
SELECT LAX_UINT32_ARRAY(JSON '["10", "1.1", "1.1e2", "+1.5"]') AS result;

/*-----------------*
 | result          |
 +-----------------+
 | [10, 1, 110, 2] |
 *-----------------*/
```

```zetasql
SELECT LAX_UINT32_ARRAY(JSON '["1e100"]') AS result;

/*--------*
 | result |
 +--------+
 | [NULL] |
 *--------*/
```

```zetasql
SELECT LAX_UINT32_ARRAY(JSON '["foo", "null", ""]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Example with input that's a JSON array of other types:

```zetasql
SELECT LAX_UINT32_ARRAY(JSON '[null, {"foo": 1}, [1]]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Examples with inputs that aren't JSON arrays:

```zetasql
SELECT LAX_UINT32_ARRAY(NULL) AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_UINT32_ARRAY(JSON 'null') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_UINT32_ARRAY(JSON '9.8') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `LAX_UINT64` 
<a id="lax_uint64"></a>

```zetasql
LAX_UINT64(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `UINT64` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '999'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>UINT64</code></th>
  </tr>
  <tr>
    <td>boolean</td>
    <td>
      If the JSON boolean is <code>true</code>, returns <code>1</code>.
      If <code>false</code>, returns <code>0</code>.
    </td>
  </tr>
  <tr>
    <td>string</td>
    <td>
      If the JSON string represents a JSON number, parses it as
      a <code>BIGNUMERIC</code> value, and then safe casts the results as an
      <code>UINT64</code> value.
      If the JSON string can't be converted, returns <code>NULL</code>.
    </td>
  </tr>
  <tr>
    <td>number</td>
    <td>
      Casts the JSON number as an <code>UINT64</code> value.
      If the JSON number can't be converted, returns <code>NULL</code>.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`UINT64`

**Examples**

Examples with inputs that are JSON numbers:

```zetasql
SELECT LAX_UINT64(JSON '10') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_UINT64(JSON '10.0') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_UINT64(JSON '1.1') AS result;

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

```zetasql
SELECT LAX_UINT64(JSON '3.5') AS result;

/*--------*
 | result |
 +--------+
 | 4      |
 *--------*/
```

```zetasql
SELECT LAX_UINT64(JSON '1.1e2') AS result;

/*--------*
 | result |
 +--------+
 | 110    |
 *--------*/
```

```zetasql
SELECT LAX_UINT64(JSON '-1') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_UINT64(JSON '1e100') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

Examples with inputs that are JSON booleans:

```zetasql
SELECT LAX_UINT64(JSON 'true') AS result;

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

```zetasql
SELECT LAX_UINT64(JSON 'false') AS result;

/*--------*
 | result |
 +--------+
 | 0      |
 *--------*/
```

Examples with inputs that are JSON strings:

```zetasql
SELECT LAX_UINT64(JSON '"10"') AS result;

/*--------*
 | result |
 +--------+
 | 10     |
 *--------*/
```

```zetasql
SELECT LAX_UINT64(JSON '"1.1"') AS result;

/*--------*
 | result |
 +--------+
 | 1      |
 *--------*/
```

```zetasql
SELECT LAX_UINT64(JSON '"1.1e2"') AS result;

/*--------*
 | result |
 +--------+
 | 110    |
 *--------*/
```

```zetasql
SELECT LAX_UINT64(JSON '"+1.5"') AS result;

/*--------*
 | result |
 +--------+
 | 2      |
 *--------*/
```

```zetasql
SELECT LAX_UINT64(JSON '"1e100"') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_UINT64(JSON '"foo"') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `LAX_UINT64_ARRAY` 
<a id="lax_uint64_array"></a>

```zetasql
LAX_UINT64_ARRAY(json_expr)
```

**Description**

Attempts to convert a JSON value to a SQL `ARRAY<UINT64>` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[999, 12]'
    ```

Details:

+   If `json_expr` is SQL `NULL`, the function returns SQL `NULL`.
+   See the conversion rules in the next section for additional `NULL` handling.

**Conversion rules**

<table>
  <tr>
    <th width='200px'>From JSON type</th>
    <th>To SQL <code>ARRAY&lt;UINT64&gt;</code></th>
  </tr>
  <tr>
    <td>array</td>
    <td>
      Converts every element according to <a href="#lax_uint64"><code>LAX_UINT64</code></a> conversion rules.
    </td>
  </tr>
  <tr>
    <td>other type or null</td>
    <td><code>NULL</code></td>
  </tr>
</table>

**Return type**

`ARRAY<UINT64>`

**Examples**

Examples with inputs that are JSON arrays of numbers:

```zetasql
SELECT LAX_UINT64_ARRAY(JSON '[10, 10.0, 1.1, 3.5, 1.1e2]') AS result;

/*---------------------*
 | result              |
 +---------------------+
 | [10, 10, 1, 4, 110] |
 *---------------------*/
```

```zetasql
SELECT LAX_UINT64_ARRAY(JSON '[1e100]') AS result;

/*--------*
 | result |
 +--------+
 | [NULL] |
 *--------*/
```

Example with inputs that's a JSON array of booleans:

```zetasql
SELECT LAX_UINT64_ARRAY(JSON '[true, false]') AS result;

/*--------*
 | result |
 +--------+
 | [1, 0] |
 *--------*/
```

Examples with inputs that are JSON strings:

```zetasql
SELECT LAX_UINT64_ARRAY(JSON '["10", "1.1", "1.1e2", "+1.5"]') AS result;

/*-----------------*
 | result          |
 +-----------------+
 | [10, 1, 110, 2] |
 *-----------------*/
```

```zetasql
SELECT LAX_UINT64_ARRAY(JSON '["1e100"]') AS result;

/*--------*
 | result |
 +--------+
 | [NULL] |
 *--------*/
```

```zetasql
SELECT LAX_UINT64_ARRAY(JSON '["foo", "null", ""]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Example with input that's a JSON array of other types:

```zetasql
SELECT LAX_UINT64_ARRAY(JSON '[null, {"foo": 1}, [1]]') AS result;

/*--------------------*
 | result             |
 +--------------------+
 | [NULL, NULL, NULL] |
 *--------------------*/
```

Examples with inputs that aren't JSON arrays:

```zetasql
SELECT LAX_UINT64_ARRAY(NULL) AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_UINT64_ARRAY(JSON 'null') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

```zetasql
SELECT LAX_UINT64_ARRAY(JSON '9.8') AS result;

/*--------*
 | result |
 +--------+
 | NULL   |
 *--------*/
```

### `PARSE_JSON`

```zetasql
PARSE_JSON(
  json_string_expr
  [, wide_number_mode => { 'exact' | 'round' } ]
)
```

**Description**

Converts a JSON-formatted `STRING` value to a [`JSON` value](https://www.json.org/json-en.html).

Arguments:

+   `json_string_expr`: A JSON-formatted string. For example:

    ```
    '{"class": {"students": [{"name": "Jane"}]}}'
    ```
+   `wide_number_mode`: A named argument with a `STRING` value. Determines
    how to handle numbers that can't be stored in a `JSON` value without the
    loss of precision. If used, `wide_number_mode` must include one of the
    following values:

    +   `exact` (default): Only accept numbers that can be stored without loss
        of precision. If a number that can't be stored without loss of
        precision is encountered, the function throws an error.
    +   `round`: If a number that can't be stored without loss of precision is
        encountered, attempt to round it to a number that can be stored without
        loss of precision. If the number can't be rounded, the function throws
        an error.

    If a number appears in a JSON object or array, the `wide_number_mode`
    argument is applied to the number in the object or array.

Numbers from the following domains can be stored in JSON without loss of
precision:

+ 64-bit signed/unsigned integers, such as `INT64`
+ `DOUBLE`

**Return type**

`JSON`

**Examples**

In the following example, a JSON-formatted string is converted to `JSON`.

```zetasql
SELECT PARSE_JSON('{"coordinates": [10, 20], "id": 1}') AS json_data;

/*--------------------------------*
 | json_data                      |
 +--------------------------------+
 | {"coordinates":[10,20],"id":1} |
 *--------------------------------*/
```

The following queries fail because:

+ The number that was passed in can't be stored without loss of precision.
+ `wide_number_mode=>'exact'` is used implicitly in the first query and
  explicitly in the second query.

```zetasql
SELECT PARSE_JSON('{"id": 922337203685477580701}') AS json_data; -- fails
SELECT PARSE_JSON('{"id": 922337203685477580701}', wide_number_mode=>'exact') AS json_data; -- fails
```

The following query rounds the number to a number that can be stored in JSON.

```zetasql
SELECT PARSE_JSON('{"id": 922337203685477580701}', wide_number_mode=>'round') AS json_data;

/*------------------------------*
 | json_data                    |
 +------------------------------+
 | {"id":9.223372036854776e+20} |
 *------------------------------*/
```

You can also use valid JSON-formatted strings that don't represent name/value pairs. For example:

```zetasql
SELECT PARSE_JSON('6') AS json_data;

/*------------------------------*
 | json_data                    |
 +------------------------------+
 | 6                            |
 *------------------------------*/
```

```zetasql
SELECT PARSE_JSON('"red"') AS json_data;

/*------------------------------*
 | json_data                    |
 +------------------------------+
 | "red"                        |
 *------------------------------*/
```

### `SAFE_TO_JSON`

```zetasql
SAFE_TO_JSON(sql_value)
```

**Description**

Similar to the `TO_JSON` function, but for each unsupported field in the
input argument, produces a JSON null instead of an error.

Arguments:

+   `sql_value`: The SQL value to convert to a JSON value. You can review the
    ZetaSQL data types that this function supports and their
    [JSON encodings][json-encodings].

**Return type**

`JSON`

**Example**

The following queries are functionally the same, except that `SAFE_TO_JSON`
produces a JSON null instead of an error when a hypothetical unsupported
data type is encountered:

```zetasql
-- Produces a JSON null.
SELECT SAFE_TO_JSON(CAST(b'' AS UNSUPPORTED_TYPE)) as result;
```

```zetasql
-- Produces an error.
SELECT TO_JSON(CAST(b'' AS UNSUPPORTED_TYPE), stringify_wide_numbers=>TRUE) as result;
```

In the following query, the value for `ut` is ignored because the value is an
unsupported type:

```zetasql
SELECT SAFE_TO_JSON(STRUCT(CAST(b'' AS UNSUPPORTED_TYPE) AS ut) AS result;

/*--------------*
 | result       |
 +--------------+
 | {"ut": null} |
 *--------------*/
```

The following array produces a JSON null instead of an error because the data
type for the array isn't supported.

```zetasql
SELECT SAFE_TO_JSON([
        CAST(b'' AS UNSUPPORTED_TYPE),
        CAST(b'' AS UNSUPPORTED_TYPE),
        CAST(b'' AS UNSUPPORTED_TYPE),
    ]) AS result;

/*------------*
 | result     |
 +------------+
 | null       |
 *------------*/
```

[json-encodings]: #json_encodings

### `STRING` 
<a id="string_for_json"></a>

```zetasql
STRING(json_expr)
```

**Description**

Converts a JSON string to a SQL `STRING` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '"purple"'
    ```

    If the JSON value isn't a string, an error is produced. If the expression
    is SQL `NULL`, the function returns SQL `NULL`.

**Return type**

`STRING`

**Examples**

```zetasql
SELECT STRING(JSON '"purple"') AS color;

/*--------*
 | color  |
 +--------+
 | purple |
 *--------*/
```

```zetasql
SELECT STRING(JSON_QUERY(JSON '{"name": "sky", "color": "blue"}', "$.color")) AS color;

/*-------*
 | color |
 +-------+
 | blue  |
 *-------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if the JSON isn't of type string.
SELECT STRING(JSON '123') AS result; -- Throws an error
SELECT STRING(JSON 'null') AS result; -- Throws an error
SELECT SAFE.STRING(JSON '123') AS result; -- Returns a SQL NULL
```

### `STRING_ARRAY` 
<a id="string_array_for_json"></a>

```zetasql
STRING_ARRAY(json_expr)
```

**Description**

Converts a JSON array of strings to a SQL `ARRAY<STRING>` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '["purple", "blue"]'
    ```

    If the JSON value isn't an array of strings, an error is produced. If the
    expression is SQL `NULL`, the function returns SQL `NULL`.

**Return type**

`ARRAY<STRING>`

**Examples**

```zetasql
SELECT STRING_ARRAY(JSON '["purple", "blue"]') AS colors;

/*----------------*
 | colors         |
 +----------------+
 | [purple, blue] |
 *----------------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if the JSON isn't an array of strings.
SELECT STRING_ARRAY(JSON '[123]') AS result; -- Throws an error
SELECT STRING_ARRAY(JSON '[null]') AS result; -- Throws an error
SELECT STRING_ARRAY(JSON 'null') AS result; -- Throws an error
```

### `TO_JSON`

```zetasql
TO_JSON(
  sql_value
  [, stringify_wide_numbers => { TRUE | FALSE } ]
)
```

**Description**

Converts a SQL value to a JSON value.

Arguments:

+   `sql_value`: The SQL value to convert to a JSON value. You can review the
    ZetaSQL data types that this function supports and their
    JSON encodings [here][json-encodings].
+   `stringify_wide_numbers`: A named argument that's either
    `TRUE` or `FALSE` (default).

    +   If `TRUE`, numeric values outside of the
        `DOUBLE` type domain are encoded as strings.
    +   If `FALSE` (default), numeric values outside of the
    `DOUBLE` type domain aren't encoded as strings,
    but are stored as JSON numbers. If a numerical value can't be stored in
    JSON without loss of precision, an error is thrown.

    The following numerical data types are affected by the
    `stringify_wide_numbers` argument:
+ `INT64`
+ `UINT64`
+ `NUMERIC`
+ `BIGNUMERIC`

    If one of these numerical data types appears in a container data type
    such as an `ARRAY` or `STRUCT`, the `stringify_wide_numbers` argument is
    applied to the numerical data types in the container data type.

**Return type**

`JSON`

**Examples**

In the following example, the query converts rows in a table to JSON values.

```zetasql
With CoordinatesTable AS (
    (SELECT 1 AS id, [10, 20] AS coordinates) UNION ALL
    (SELECT 2 AS id, [30, 40] AS coordinates) UNION ALL
    (SELECT 3 AS id, [50, 60] AS coordinates))
SELECT TO_JSON(t) AS json_objects
FROM CoordinatesTable AS t;

/*--------------------------------*
 | json_objects                   |
 +--------------------------------+
 | {"coordinates":[10,20],"id":1} |
 | {"coordinates":[30,40],"id":2} |
 | {"coordinates":[50,60],"id":3} |
 *--------------------------------*/
```

In the following example, the query returns a large numerical value as a
JSON string.

```zetasql
SELECT TO_JSON(9007199254740993, stringify_wide_numbers=>TRUE) as stringify_on;

/*--------------------*
 | stringify_on       |
 +--------------------+
 | "9007199254740993" |
 *--------------------*/
```

In the following example, both queries return a large numerical value as a
JSON number.

```zetasql
SELECT TO_JSON(9007199254740993, stringify_wide_numbers=>FALSE) as stringify_off;
SELECT TO_JSON(9007199254740993) as stringify_off;

/*------------------*
 | stringify_off    |
 +------------------+
 | 9007199254740993 |
 *------------------*/
```

In the following example, only large numeric values are converted to
JSON strings.

```zetasql
With T1 AS (
  (SELECT 9007199254740993 AS id) UNION ALL
  (SELECT 2 AS id))
SELECT TO_JSON(t, stringify_wide_numbers=>TRUE) AS json_objects
FROM T1 AS t;

/*---------------------------*
 | json_objects              |
 +---------------------------+
 | {"id":"9007199254740993"} |
 | {"id":2}                  |
 *---------------------------*/
```

In this example, the values `9007199254740993` (`INT64`)
and `2.1` (`DOUBLE`) are converted
to the common supertype `DOUBLE`, which isn't
affected by the `stringify_wide_numbers` argument.

```zetasql
With T1 AS (
  (SELECT 9007199254740993 AS id) UNION ALL
  (SELECT 2.1 AS id))
SELECT TO_JSON(t, stringify_wide_numbers=>TRUE) AS json_objects
FROM T1 AS t;

/*------------------------------*
 | json_objects                 |
 +------------------------------+
 | {"id":9.007199254740992e+15} |
 | {"id":2.1}                   |
 *------------------------------*/
```

[json-encodings]: #json_encodings

### `TO_JSON_STRING`

```zetasql
TO_JSON_STRING(value[, pretty_print])
```

**Description**

Converts a SQL value to a JSON-formatted `STRING` value.

Arguments:

+   `value`: A SQL value. You can review the ZetaSQL data types that
    this function supports and their JSON encodings [here][json-encodings].
+   `pretty_print`: Optional boolean parameter. If `pretty_print` is `true`, the
    returned value is formatted for easy readability.

**Return type**

A JSON-formatted `STRING`

**Examples**

The following query converts a `STRUCT` value to a JSON-formatted string:

```zetasql
SELECT TO_JSON_STRING(STRUCT(1 AS id, [10,20] AS coordinates)) AS json_data

/*--------------------------------*
 | json_data                      |
 +--------------------------------+
 | {"id":1,"coordinates":[10,20]} |
 *--------------------------------*/
```

The following query converts a `STRUCT` value to a JSON-formatted string that is
easy to read:

```zetasql
SELECT TO_JSON_STRING(STRUCT(1 AS id, [10,20] AS coordinates), true) AS json_data

/*--------------------*
 | json_data          |
 +--------------------+
 | {                  |
 |   "id": 1,         |
 |   "coordinates": [ |
 |     10,            |
 |     20             |
 |   ]                |
 | }                  |
 *--------------------*/
```

[json-encodings]: #json_encodings

### `UINT32` 
<a id="uint32_for_json"></a>

```zetasql
UINT32(json_expr)
```

**Description**

Converts a JSON number to a SQL `UINT32` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '999'
    ```

    If the JSON value isn't a number, or the JSON number isn't in the SQL
    `UINT32` domain, an error is produced. If the expression is SQL `NULL`, the
    function returns SQL `NULL`.

**Return type**

`UINT32`

**Examples**

```zetasql
SELECT UINT32(JSON '2005') AS flight_number;

/*---------------*
 | flight_number |
 +---------------+
 | 2005          |
 *---------------*/
```

```zetasql
SELECT UINT32(JSON_QUERY(JSON '{"gate": "A4", "flight_number": 2005}', "$.flight_number")) AS flight_number;

/*---------------*
 | flight_number |
 +---------------+
 | 2005          |
 *---------------*/
```

```zetasql
SELECT UINT32(JSON '10.0') AS score;

/*-------*
 | score |
 +-------+
 | 10    |
 *-------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if JSON isn't a number or can't be converted to a 64-bit integer.
SELECT UINT32(JSON '10.1') AS result;  -- Throws an error
SELECT UINT32(JSON '-1') AS result;  -- Throws an error
SELECT UINT32(JSON '"strawberry"') AS result; -- Throws an error
SELECT UINT32(JSON 'null') AS result; -- Throws an error
SELECT SAFE.UINT32(JSON '"strawberry"') AS result;  -- Returns a SQL NULL
```

### `UINT32_ARRAY` 
<a id="uint32_array_for_json"></a>

```zetasql
UINT32_ARRAY(json_expr)
```

**Description**

Converts a JSON number to a SQL `UINT32_ARRAY` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[999, 12]'
    ```

    If the JSON value isn't an array of numbers, or the JSON numbers aren't in
    the SQL `UINT32` domain, an error is produced. If the expression is SQL
    `NULL`, the function returns SQL `NULL`.

**Return type**

`ARRAY<UINT32>`

**Examples**

```zetasql
SELECT UINT32_ARRAY(JSON '[2005, 2003]') AS flight_numbers;

/*----------------*
 | flight_numbers |
 +----------------+
 | [2005, 2003]   |
 *----------------*/
```

```zetasql
SELECT UINT32_ARRAY(JSON '[10.0]') AS scores;

/*--------*
 | scores |
 +--------+
 | [10]   |
 *--------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if the JSON isn't an array of numbers in UINT32 domain.
SELECT UINT32_ARRAY(JSON '[10.1]') AS result;  -- Throws an error
SELECT UINT32_ARRAY(JSON '[-1]') AS result;  -- Throws an error
SELECT UINT32_ARRAY(JSON '["strawberry"]') AS result; -- Throws an error
SELECT UINT32_ARRAY(JSON '[null]') AS result; -- Throws an error
SELECT UINT32_ARRAY(JSON 'null') AS result; -- Throws an error
```

### `UINT64` 
<a id="uint64_for_json"></a>

```zetasql
UINT64(json_expr)
```

**Description**

Converts a JSON number to a SQL `UINT64` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '999'
    ```

    If the JSON value isn't a number, or the JSON number isn't in the SQL
    `UINT64` domain, an error is produced. If the expression is SQL `NULL`, the
    function returns SQL `NULL`.

**Return type**

`UINT64`

**Examples**

```zetasql
SELECT UINT64(JSON '2005') AS flight_number;

/*---------------*
 | flight_number |
 +---------------+
 | 2005          |
 *---------------*/
```

```zetasql
SELECT UINT64(JSON_QUERY(JSON '{"gate": "A4", "flight_number": 2005}', "$.flight_number")) AS flight_number;

/*---------------*
 | flight_number |
 +---------------+
 | 2005          |
 *---------------*/
```

```zetasql
SELECT UINT64(JSON '10.0') AS score;

/*-------*
 | score |
 +-------+
 | 10    |
 *-------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if JSON isn't a number or can't be converted to a 64-bit integer.
SELECT UINT64(JSON '10.1') AS result;  -- Throws an error
SELECT UINT64(JSON '-1') AS result;  -- Throws an error
SELECT UINT64(JSON '"strawberry"') AS result; -- Throws an error
SELECT UINT64(JSON 'null') AS result; -- Throws an error
SELECT SAFE.UINT64(JSON '"strawberry"') AS result;  -- Returns a SQL NULL
```

### `UINT64_ARRAY` 
<a id="uint64_array_for_json"></a>

```zetasql
UINT64_ARRAY(json_expr)
```

**Description**

Converts a JSON number to a SQL `UINT64_ARRAY` value.

Arguments:

+   `json_expr`: JSON. For example:

    ```
    JSON '[999, 12]'
    ```

    If the JSON value isn't an array of numbers, or the JSON numbers aren't in
    the SQL `UINT64` domain, an error is produced. If the expression is SQL
    `NULL`, the function returns SQL `NULL`.

**Return type**

`ARRAY<UINT64>`

**Examples**

```zetasql
SELECT UINT64_ARRAY(JSON '[2005, 2003]') AS flight_numbers;

/*----------------*
 | flight_numbers |
 +----------------+
 | [2005, 2003]   |
 *----------------*/
```

```zetasql
SELECT UINT64_ARRAY(JSON '[10.0]') AS scores;

/*--------*
 | scores |
 +--------+
 | [10]   |
 *--------*/
```

The following examples show how invalid requests are handled:

```zetasql
-- An error is thrown if the JSON isn't an array of numbers in UINT64 domain.
SELECT UINT64_ARRAY(JSON '[10.1]') AS result;  -- Throws an error
SELECT UINT64_ARRAY(JSON '[-1]') AS result;  -- Throws an error
SELECT UINT64_ARRAY(JSON '["strawberry"]') AS result; -- Throws an error
SELECT UINT64_ARRAY(JSON '[null]') AS result; -- Throws an error
SELECT UINT64_ARRAY(JSON 'null') AS result; -- Throws an error
```

### Supplemental materials

### Differences between the JSON and JSON-formatted STRING types 
<a id="differences_json_and_string"></a>

Many JSON functions accept two input types:

+  [`JSON`][JSON-type] type
+  `STRING` type

The `STRING` version of the extraction functions behaves differently than the
`JSON` version, mainly because `JSON` type values are always validated whereas
JSON-formatted `STRING` type values aren't.

#### Non-validation of `STRING` inputs

The following `STRING` is invalid JSON because it's missing a trailing `}`:

```
{"hello": "world"
```

The JSON function reads the input from the beginning and stops as soon as the
field to extract is found, without reading the remainder of the input. A parsing
error isn't produced.

With the `JSON` type, however, `JSON '{"hello": "world"'` returns a parsing
error.

For example:

```zetasql
SELECT JSON_VALUE('{"hello": "world"', "$.hello") AS hello;

/*-------*
 | hello |
 +-------+
 | world |
 *-------*/
```

```zetasql
SELECT JSON_VALUE(JSON '{"hello": "world"', "$.hello") AS hello;
-- An error is returned: Invalid JSON literal: syntax error while parsing
-- object - unexpected end of input; expected '}'
```

#### No strict validation of extracted values

In the following examples, duplicated keys aren't removed when using a
JSON-formatted string. Similarly, keys order is preserved. For the `JSON`
type, `JSON '{"key": 1, "key": 2}'` will result in `JSON '{"key":1}'` during
parsing.

```zetasql
SELECT JSON_QUERY('{"key": 1, "key": 2}', "$") AS string;

/*-------------------*
 | string            |
 +-------------------+
 | {"key":1,"key":2} |
 *-------------------*/
```

```zetasql
SELECT JSON_QUERY(JSON '{"key": 1, "key": 2}', "$") AS json;

/*-----------*
 | json      |
 +-----------+
 | {"key":1} |
 *-----------*/
```

#### JSON `null`

When using a JSON-formatted `STRING` type in a JSON function, a JSON `null`
value is extracted as a SQL `NULL` value.

When using a JSON type in a JSON function, a JSON `null` value returns a JSON
`null` value.

```zetasql
WITH t AS (
  SELECT '{"name": null}' AS json_string, JSON '{"name": null}' AS json)
SELECT JSON_QUERY(json_string, "$.name") AS name_string,
  JSON_QUERY(json_string, "$.name") IS NULL AS name_string_is_null,
  JSON_QUERY(json, "$.name") AS name_json,
  JSON_QUERY(json, "$.name") IS NULL AS name_json_is_null
FROM t;

/*-------------+---------------------+-----------+-------------------*
 | name_string | name_string_is_null | name_json | name_json_is_null |
 +-------------+---------------------+-----------+-------------------+
 | NULL        | true                | null      | false             |
 *-------------+---------------------+-----------+-------------------*/
```

[JSON-type]: https://github.com/google/zetasql/blob/master/docs/data-types.md#json_type

### JSON encodings 
<a id="json_encodings"></a>

You can encode a SQL value as a JSON value with the following functions:

+ `TO_JSON_STRING`
+ `TO_JSON`
+ `JSON_SET` (uses `TO_JSON` encoding)
+ `JSON_ARRAY` (uses `TO_JSON` encoding)
+ `JSON_ARRAY_APPEND` (uses `TO_JSON` encoding)
+ `JSON_ARRAY_INSERT` (uses `TO_JSON` encoding)
+ `JSON_OBJECT` (uses `TO_JSON` encoding)

The following SQL to JSON encodings are supported:

<table>
  <thead>
    <tr>
      <th>From SQL</th>
      <th width='400px'>To JSON</th>
      <th>Examples</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NULL</td>
      <td>
        <p>null</p>
      </td>
      <td>
        SQL input: <code>NULL</code><br />
        JSON output: <code>null</code>
      </td>
    </tr>
    
    <tr>
      <td>BOOL</td>
      <td>boolean</td>
      <td>
        SQL input: <code>TRUE</code><br />
        JSON output: <code>true</code><br />
        <hr />
        SQL input: <code>FALSE</code><br />
        JSON output: <code>false</code><br />
      </td>
    </tr>
    
    
    <tr>
      <td>
        INT32<br/>
        UINT32
      </td>
      <td>integer</td>
      <td>
        SQL input: <code>-1</code><br />
        JSON output: <code>-1</code><br />
        <hr />
        SQL input: <code>0</code><br />
        JSON output: <code>0</code><br />
        <hr />
        SQL input: <code>12345678901</code><br />
        JSON output: <code>12345678901</code><br />
      </td>
    </tr>
    
    
    
    <tr>
      <td>
        INT64
        <br />UINT64
      </td>
      <td>
        <p>(TO_JSON_STRING only)</p>
        <p>number or string</p>
        <p>
          Encoded as a number when the value is in the range of
          [-2<sup>53</sup>, 2<sup>53</sup>], which is the range of
          integers that can be represented losslessly as IEEE 754
          double-precision floating point numbers. A value outside of this range
          is encoded as a string.
        </p>
      </td>
      <td>
        SQL input: <code>9007199254740992</code><br />
        JSON output: <code>9007199254740992</code><br />
        <hr />
        SQL input: <code>9007199254740993</code><br />
        JSON output: <code>"9007199254740993"</code><br />
      </td>
    </tr>
    
    
    
    
    <tr>
      <td>
        INT64
        <br />UINT64
      </td>
      <td>
        <p>(TO_JSON only)</p>
        <p>number or string</p>
        <p>
          If the <code>stringify_wide_numbers</code> argument
          is <code>TRUE</code> and the value is outside of the
          DOUBLE type domain, the value is
          encoded as a string. If the value can't be stored in
          JSON without loss of precision, the function fails.
          Otherwise, the value is encoded as a number.
        </p>
        <p>
          If the <code>stringify_wide_numbers</code> isn't used or is
          <code>FALSE</code>, numeric values outside of the
          `DOUBLE` type domain aren't
          encoded as strings, but are stored as JSON numbers. If a
          numerical value can't be stored in JSON without loss of precision,
          an error is thrown.
        </p>
      </td>
      <td>
        SQL input: <code>9007199254740992</code><br />
        JSON output: <code>9007199254740992</code><br />
        <hr />
        SQL input: <code>9007199254740993</code><br />
        JSON output: <code>9007199254740993</code><br />
        <hr />
        SQL input with stringify_wide_numbers=>TRUE:
        <code>9007199254740992</code><br />
        JSON output: <code>9007199254740992</code><br />
        <hr />
        SQL input with stringify_wide_numbers=>TRUE:
        <code>9007199254740993</code><br />
        JSON output: <code>"9007199254740993"</code><br />
      </td>
    </tr>
    
    
    
    
    <tr>
      <td>INTERVAL</td>
      <td>string</td>
      <td>
        SQL input: <code>INTERVAL '10:20:30.52' HOUR TO SECOND</code><br />
        JSON output: <code>"PT10H20M30.52S"</code><br />
        <hr />
        SQL input: <code>INTERVAL 1 SECOND</code><br />
        JSON output: <code>"PT1S"</code><br />
        <hr />
        <code>INTERVAL -25 MONTH</code><br />
        JSON output: <code>"P-2Y-1M"</code><br />
        <hr />
        <code>INTERVAL '1 5:30' DAY TO MINUTE</code><br />
        JSON output: <code>"P1DT5H30M"</code><br />
      </td>
    </tr>
    
    
    
    
    <tr>
      <td>
        NUMERIC
        <br/>BIGNUMERIC
      </td>
      <td>
        <p>(TO_JSON_STRING only)</p>
        <p>number or string</p>
        <p>
          Encoded as a number when the value is in the range of
          [-2<sup>53</sup>, 2<sup>53</sup>] and has no fractional
          part. A value outside of this range is encoded as a string.
        </p>
      </td>
      <td>
        SQL input: <code>-1</code><br />
        JSON output: <code>-1</code><br />
        <hr />
        SQL input: <code>0</code><br />
        JSON output: <code>0</code><br />
        <hr />
        SQL input: <code>9007199254740993</code><br />
        JSON output: <code>"9007199254740993"</code><br />
        <hr />
        SQL input: <code>123.56</code><br />
        JSON output: <code>"123.56"</code><br />
      </td>
    </tr>
    
    
    
    
    <tr>
      <td>
        NUMERIC
        <br/>BIGNUMERIC
      </td>
      <td>
        <p>(TO_JSON only)</p>
        <p>number or string</p>
        <p>
          If the <code>stringify_wide_numbers</code> argument
          is <code>TRUE</code> and the value is outside of the
          DOUBLE type domain, it's
          encoded as a string. Otherwise, it's encoded as a number.
        </p>
      </td>
      <td>
        SQL input: <code>-1</code><br />
        JSON output: <code>-1</code><br />
        <hr />
        SQL input: <code>0</code><br />
        JSON output: <code>0</code><br />
        <hr />
        SQL input: <code>9007199254740993</code><br />
        JSON output: <code>9007199254740993</code><br />
        <hr />
        SQL input: <code>123.56</code><br />
        JSON output: <code>123.56</code><br />
        <hr />
        SQL input with stringify_wide_numbers=>TRUE: <code>9007199254740993</code><br />
        JSON output: <code>"9007199254740993"</code><br />
        <hr />
        SQL input with stringify_wide_numbers=>TRUE: <code>123.56</code><br />
        JSON output: <code>123.56</code><br />
      </td>
    </tr>
    
    
    
    <tr>
      <td>
        FLOAT<br />
        DOUBLE
      </td>
      <td>
        <p>number or string</p>
        <p>
          <code>+/-inf</code> and <code>NaN</code> are encoded as
          <code>Infinity</code>, <code>-Infinity</code>, and <code>NaN</code>.
          Otherwise, this value is encoded as a number.
        </p>
      </td>
      <td>
        SQL input: <code>1.0</code><br />
        JSON output: <code>1</code><br />
        <hr />
        SQL input: <code>9007199254740993</code><br />
        JSON output: <code>9007199254740993</code><br />
        <hr />
        SQL input: <code>"+inf"</code><br />
        JSON output: <code>"Infinity"</code><br />
        <hr />
        SQL input: <code>"-inf"</code><br />
        JSON output: <code>"-Infinity"</code><br />
        <hr />
        SQL input: <code>"NaN"</code><br />
        JSON output: <code>"NaN"</code><br />
      </td>
    </tr>
    
    
    <tr>
      <td>STRING</td>
      <td>
        <p>string</p>
        <p>
          Encoded as a string, escaped according to the JSON standard.
          Specifically, <code>"</code>, <code>\,</code> and the control
          characters from <code>U+0000</code> to <code>U+001F</code> are
          escaped.
        </p>
      </td>
      <td>
        SQL input: <code>"abc"</code><br />
        JSON output: <code>"abc"</code><br />
        <hr />
        SQL input: <code>"\"abc\""</code><br />
        JSON output: <code>"\"abc\""</code><br />
      </td>
    </tr>
    
    
    <tr>
      <td>BYTES</td>
      <td>
        <p>string</p>
        <p>Uses RFC 4648 Base64 data encoding.</p>
      </td>
      <td>
        SQL input: <code>b"Google"</code><br />
        JSON output: <code>"R29vZ2xl"</code><br />
      </td>
    </tr>
    
    
    <tr>
      <td>ENUM</td>
      <td>
        <p>string</p>
        <p>
          Invalid enum values are encoded as their number, such as 0 or 42.
        </p>
      </td>
      <td>
        SQL input: <code>Color.Red</code><br />
        JSON output: <code>"Red"</code><br />
      </td>
    </tr>
    
    
    <tr>
      <td>DATE</td>
      <td>string</td>
      <td>
        SQL input: <code>DATE '2017-03-06'</code><br />
        JSON output: <code>"2017-03-06"</code><br />
      </td>
    </tr>
    
    
    <tr>
      <td>TIMESTAMP</td>
      <td>
        <p>string</p>
        <p>
          Encoded as ISO 8601 date and time, where T separates the date and
          time and Z (Zulu/UTC) represents the time zone.
        </p>
      </td>
      <td>
        SQL input: <code>TIMESTAMP '2017-03-06 12:34:56.789012'</code><br />
        JSON output: <code>"2017-03-06T12:34:56.789012Z"</code><br />
      </td>
    </tr>
    
    
    <tr>
      <td>DATETIME</td>
      <td>
        <p>string</p>
        <p>
          Encoded as ISO 8601 date and time, where T separates the date and
          time.
        </p>
      </td>
      <td>
        SQL input: <code>DATETIME '2017-03-06 12:34:56.789012'</code><br />
        JSON output: <code>"2017-03-06T12:34:56.789012"</code><br />
      </td>
    </tr>
    
    
    <tr>
      <td>TIME</td>
      <td>
        <p>string</p>
        <p>Encoded as ISO 8601 time.</p>
      </td>
      <td>
        SQL input: <code>TIME '12:34:56.789012'</code><br />
        JSON output: <code>"12:34:56.789012"</code><br />
      </td>
    </tr>
    
    
    <tr>
      <td>JSON</td>
      <td>
        <p>data of the input JSON</p>
      </td>
      <td>
        SQL input: <code>JSON '{"item": "pen", "price": 10}'</code><br />
        JSON output: <code>{"item":"pen", "price":10}</code><br />
        <hr />
        SQL input:<code>[1, 2, 3]</code><br />
        JSON output:<code>[1, 2, 3]</code><br />
      </td>
    </tr>
    
    
    <tr>
      <td>ARRAY</td>
      <td>
        <p>array</p>
        <p>
          Can contain zero or more elements.
        </p>
      </td>
      <td>
        SQL input: <code>["red", "blue", "green"]</code><br />
        JSON output: <code>["red","blue","green"]</code><br />
        <hr />
        SQL input:<code>[1, 2, 3]</code><br />
        JSON output:<code>[1,2,3]</code><br />
      </td>
    </tr>
    
    
    <tr>
      <td>STRUCT</td>
      <td>
        <p>object</p>
        <p>
          The object can contain zero or more key-value pairs.
          Each value is formatted according to its type.
        </p>
        <p>
          For <code>TO_JSON</code>, a field is
          included in the output string and any duplicates of this field are
          omitted.
          For <code>TO_JSON_STRING</code>,
          a field and any duplicates of this field are included in the
          output string.
        </p>
        <p>
          Anonymous fields are represented with <code>""</code>.
        </p>
        <p>
          Invalid UTF-8 field names might result in unparseable JSON. String
          values are escaped according to the JSON standard. Specifically,
          <code>"</code>, <code>\,</code> and the control characters from
          <code>U+0000</code> to <code>U+001F</code> are escaped.
        </p>
      </td>
      <td>
        SQL input: <code>STRUCT(12 AS purchases, TRUE AS inStock)</code><br />
        JSON output: <code>{"inStock": true,"purchases":12}</code><br />
      </td>
    </tr>
    
    
    <tr>
      <td>PROTO</td>
      <td>
        <p>object</p>
        <p>
          The object can contain zero or more key-value pairs.
          Each value is formatted according to its type.
        </p>
        <p>
          Field names with underscores are converted to camel case in accordance
          with
          <a href="https://developers.google.com/protocol-buffers/docs/proto3#json">
          protobuf json conversion</a>. Field values are formatted according to
          <a href="https://developers.google.com/protocol-buffers/docs/proto3#json">
          protobuf json conversion</a>. If a <code>field_value</code> is a
          non-empty repeated field or submessage, the elements and fields are
          indented to the appropriate level.
        </p>
        <ul>
          <li>
            Field names that aren't valid UTF-8 might result in unparseable
            JSON.
          </li>
          <li>Field annotations are ignored.</li>
          <li>Repeated fields are represented as arrays.</li>
          <li>Submessages are formatted as values of PROTO type.</li>
          <li>
            Extension fields are included in the output, where the extension
            field name is enclosed in brackets and prefixed with the full name
            of the extension type.
          </li>
          
        </ul>
      </td>
      <td>
        SQL input: <code>NEW Item(12 AS purchases,TRUE AS in_Stock)</code><br />
        JSON output: <code>{"purchases":12,"inStock": true}</code><br />
      </td>
    </tr>
    
    
    
    <tr>
      <td>GRAPH_ELEMENT</td>
      <td>
        <p>object</p>
        <p>
          The object can contain zero or more key-value pairs.
          Each value is formatted according to its type.
        </p>
        <p>
          For <code>TO_JSON</code>, graph
          element (node or edge) objects are supported.
        </p>
        <ul>
          <li>
            The graph element identifier is only valid within the scope of the
            same query response and can't be used to correlate entities across
            different queries.
          </li>
          <li>
            Field names that aren't valid UTF-8 might result in unparseable
            JSON.
          </li>
          <li>
            The result may include internal key-value pairs that aren't defined
            by the users.
          </li>
          <li>
            The conversion can fail if the object contains values of unsupported
            types.
          </li>
        </ul>
      </td>
      <td>
        SQL:
        <br />
<pre>GRAPH FinGraph
MATCH (p:Person WHERE p.name = 'Dana')
RETURN TO_JSON(p) AS dana_json;</pre>
        <br />
        JSON output (truncated):
        <br />
<pre>{"identifier":"ZGFuYQ==","kind":"node","labels":["Person"],"properties":{"id":2,"name":"Dana"}}</pre>
      </td>
    </tr>
    
    
    
    
    <tr>
      <td>RANGE</td>
      <td>
        <p>range</p>
        <p>
          Encoded as an object with a <code>start</code> and <code>end</code>
          value. Any unbounded part of the range is represented as
          <code>null</code>.
        </p>
      </td>
      <td>
        SQL input: <code>RANGE&lt;DATE&gt; '[2024-07-24, 2024-07-25)'</code><br />
        JSON output: <code>{"start":"2024-07-24","end":"2024-07-25"}</code><br />
        <hr />
        SQL input: <code>RANGE&lt;DATETIME&gt; '[2024-07-24 10:00:00, UNBOUNDED)'</code><br />
        JSON output: <code>{"start":"2024-07-24T10:00:00","end":null}</code><br />
      </td>
    </tr>
    
  </tbody>
</table>

### JSONPath format 
<a id="JSONPath_format"></a>

With the JSONPath format, you can identify the values you want to
obtain from a JSON-formatted string.

If a key in a JSON functions contains a JSON format operator, refer to each
JSON function for how to escape them.

A JSON function returns `NULL` if the JSONPath format doesn't match a value in
a JSON-formatted string. If the selected value for a scalar function isn't
scalar, such as an object or an array, the function returns `NULL`. If the
JSONPath format is invalid, an error is produced.

#### Operators for JSONPath

The JSONPath format supports these operators:

<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th width='300px'>Description</th>
      <th>Examples</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>$</code></td>
      <td>
        Root object or element. The JSONPath format must start with this
        operator, which refers to the outermost level of the
        JSON-formatted string.
      </td>
      <td>
        <p>
          JSON-formatted string:<br />
          <code>'{"class" : {"students" : [{"name" : "Jane"}]}}'</code>
        </p>
        <p>
          JSON path:<br />
          <code>"$"</code>
        </p>
        <p>
          JSON result:<br />
          <code>{"class":{"students":[{"name":"Jane"}]}}</code><br />
        </p>
      </td>
    </tr>
    <tr>
      <td><code>.</code></td>
      <td>
        Child operator. You can identify child values using dot-notation.
      </td>
      <td>
        <p>
          JSON-formatted string:<br />
          <code>'{"class" : {"students" : [{"name" : "Jane"}]}}'</code>
        </p>
        <p>
          JSON path:<br />
          <code>"$.class.students"</code>
        </p>
        <p>
          JSON result:<br />
          <code>[{"name":"Jane"}]</code>
        </p>
      </td>
    </tr>
    <tr>
      <td><code>[]</code></td>
      <td>
        Subscript operator. If the object is a JSON array, you can use
        brackets to specify the array index.
      </td>
      <td>
        <p>
          JSON-formatted string:<br />
          <code>'{"class" : {"students" : [{"name" : "Jane"}]}}'</code>
        </p>
        <p>
          JSON path:<br />
          <code>"$.class.students[0]"</code>
        </p>
        <p>
          JSON result:<br />
          <code>{"name":"Jane"}</code>
        </p>
      </td>
    </tr>

    <tr>
      <td>
        <code>[][]</code><br />
        <code>[][][]...</code>
      </td>
      <td>
        Child subscript operator. If the object is a JSON array within
        an array, you can use as many additional brackets as you need
        to specify the child array index.
      </td>
      <td>
        <p>
          JSON-formatted string:<br />
          <code>'{"a": [["b", "c"], "d"], "e":"f"}'</code>
        </p>
        <p>
          JSON path:<br />
          <code>"$.a[0][1]"</code>
        </p>
        <p>
          JSON result:<br />
          <code>"c"</code>
        </p>
      </td>
    </tr>

  </tbody>
</table>

## Mathematical functions

ZetaSQL supports mathematical functions.
All mathematical functions have the following behaviors:

+  They return `NULL` if any of the input parameters is `NULL`.
+  They return `NaN` if any of the arguments is `NaN`.

### Categories

<!-- disableFinding(LINK_ID) -->
<table>
  <thead>
    <tr>
      <th>Category</th>
      <th>Functions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Trigonometric</td>
      <td>
        <a href="#acos"><code>ACOS</code></a>&nbsp;&nbsp;
        <a href="#acosh"><code>ACOSH</code></a>&nbsp;&nbsp;
        <a href="#asin"><code>ASIN</code></a>&nbsp;&nbsp;
        <a href="#asinh"><code>ASINH</code></a>&nbsp;&nbsp;
        <a href="#atan"><code>ATAN</code></a>&nbsp;&nbsp;
        <a href="#atan2"><code>ATAN2</code></a>&nbsp;&nbsp;
        <a href="#atanh"><code>ATANH</code></a>&nbsp;&nbsp;
        <a href="#cos"><code>COS</code></a>&nbsp;&nbsp;
        <a href="#cosh"><code>COSH</code></a>&nbsp;&nbsp;
        <a href="#cot"><code>COT</code></a>&nbsp;&nbsp;
        <a href="#coth"><code>COTH</code></a>&nbsp;&nbsp;
        <a href="#csc"><code>CSC</code></a>&nbsp;&nbsp;
        <a href="#csch"><code>CSCH</code></a>&nbsp;&nbsp;
        <a href="#sec"><code>SEC</code></a>&nbsp;&nbsp;
        <a href="#sech"><code>SECH</code></a>&nbsp;&nbsp;
        <a href="#sin"><code>SIN</code></a>&nbsp;&nbsp;
        <a href="#sinh"><code>SINH</code></a>&nbsp;&nbsp;
        <a href="#tan"><code>TAN</code></a>&nbsp;&nbsp;
        <a href="#tanh"><code>TANH</code></a>&nbsp;&nbsp;
      </td>
    </tr>
    <tr>
      <td>
        Exponential and<br />
        logarithmic
      </td>
      <td>
        <a href="#exp"><code>EXP</code></a>&nbsp;&nbsp;
        <a href="#ln"><code>LN</code></a>&nbsp;&nbsp;
        <a href="#log"><code>LOG</code></a>&nbsp;&nbsp;
        <a href="#log10"><code>LOG10</code></a>&nbsp;&nbsp;
      </td>
    </tr>
    <tr>
      <td>
        Rounding and<br />
        truncation
      </td>
      <td>
        <a href="#ceil"><code>CEIL</code></a>&nbsp;&nbsp;
        <a href="#ceiling"><code>CEILING</code></a>&nbsp;&nbsp;
        <a href="#floor"><code>FLOOR</code></a>&nbsp;&nbsp;
        <a href="#round"><code>ROUND</code></a>&nbsp;&nbsp;
        <a href="#trunc"><code>TRUNC</code></a>&nbsp;&nbsp;
      </td>
    </tr>
    <tr>
      <td>
        Power and<br />
        root
      </td>
      <td>
        <a href="#cbrt"><code>CBRT</code></a>&nbsp;&nbsp;
        <a href="#pow"><code>POW</code></a>&nbsp;&nbsp;
        <a href="#power"><code>POWER</code></a>&nbsp;&nbsp;
        <a href="#sqrt"><code>SQRT</code></a>&nbsp;&nbsp;
      </td>
    </tr>
    <tr>
      <td>Sign</td>
      <td>
        <a href="#abs"><code>ABS</code></a>&nbsp;&nbsp;
        <a href="#sign"><code>SIGN</code></a>&nbsp;&nbsp;
      </td>
    </tr>
    
    <tr>
      <td>
        Distance
      </td>
      <td>
        
        
        
        
        <a href="#cosine_distance"><code>COSINE_DISTANCE</code></a>&nbsp;&nbsp;
        <a href="#euclidean_distance"><code>EUCLIDEAN_DISTANCE</code></a>&nbsp;&nbsp;
      </td>
    </tr>
    
    <tr>
      <td>
        Comparison
      </td>
      <td>
        <a href="#greatest"><code>GREATEST</code></a>&nbsp;&nbsp;
        <a href="#least"><code>LEAST</code></a>&nbsp;&nbsp;
      </td>
    </tr>
    
    <tr>
      <td>Random number generator</td>
      <td>
        <a href="#rand"><code>RAND</code></a>&nbsp;&nbsp;
      </td>
    </tr>
    
    <tr>
      <td>Arithmetic and error handling</td>
      <td>
        <a href="#div"><code>DIV</code></a>&nbsp;&nbsp;
        <a href="#ieee_divide"><code>IEEE_DIVIDE</code></a>&nbsp;&nbsp;
        <a href="#is_inf"><code>IS_INF</code></a>&nbsp;&nbsp;
        <a href="#is_nan"><code>IS_NAN</code></a>&nbsp;&nbsp;
        <a href="#mod"><code>MOD</code></a>&nbsp;&nbsp;
        <a href="#safe_add"><code>SAFE_ADD</code></a>&nbsp;&nbsp;
        <a href="#safe_divide"><code>SAFE_DIVIDE</code></a>&nbsp;&nbsp;
        <a href="#safe_multiply"><code>SAFE_MULTIPLY</code></a>&nbsp;&nbsp;
        <a href="#safe_negate"><code>SAFE_NEGATE</code></a>&nbsp;&nbsp;
        <a href="#safe_subtract"><code>SAFE_SUBTRACT</code></a>&nbsp;&nbsp;
      </td>
    </tr>
    
    <tr>
      <td>Bucket</td>
      <td>
        <a href="#range_bucket"><code>RANGE_BUCKET</code></a>&nbsp;&nbsp;
      </td>
    </tr>
    
    
    <tr>
      <td>Numerical constants</td>
      <td>
        <a href="#pi"><code>PI</code></a>&nbsp;&nbsp;
        <a href="#pi_bignumeric"><code>PI_BIGNUMERIC</code></a>&nbsp;&nbsp;
        <a href="#pi_numeric"><code>PI_NUMERIC</code></a>&nbsp;&nbsp;
      </td>
    </tr>
    
  </tbody>
</table>
<!-- enableFinding(LINK_ID) -->

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#abs"><code>ABS</code></a>
</td>
  <td>
    Computes the absolute value of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#acos"><code>ACOS</code></a>
</td>
  <td>
    Computes the inverse cosine of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#acosh"><code>ACOSH</code></a>
</td>
  <td>
    Computes the inverse hyperbolic cosine of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#asin"><code>ASIN</code></a>
</td>
  <td>
    Computes the inverse sine of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#asinh"><code>ASINH</code></a>
</td>
  <td>
    Computes the inverse hyperbolic sine of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#atan"><code>ATAN</code></a>
</td>
  <td>
    Computes the inverse tangent of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#atan2"><code>ATAN2</code></a>
</td>
  <td>
    Computes the inverse tangent of <code>X/Y</code>, using the signs of
    <code>X</code> and <code>Y</code> to determine the quadrant.
  </td>
</tr>

<tr>
  <td><a href="#atanh"><code>ATANH</code></a>
</td>
  <td>
    Computes the inverse hyperbolic tangent of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#avg"><code>AVG</code></a>
</td>
  <td>
    Gets the average of non-<code>NULL</code> values.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate_functions.md">Aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#dp_avg"><code>AVG</code> (Differential Privacy)</a>
</td>
  <td>
    <code>DIFFERENTIAL_PRIVACY</code>-supported <code>AVG</code>.<br/><br/>
    Gets the differentially-private average of non-<code>NULL</code>,
    non-<code>NaN</code> values in a query with a
    <code>DIFFERENTIAL_PRIVACY</code> clause.
    <br><br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate-dp-functions.md">Differential privacy functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#cbrt"><code>CBRT</code></a>
</td>
  <td>
    Computes the cube root of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#ceil"><code>CEIL</code></a>
</td>
  <td>
    Gets the smallest integral value that isn't less than <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#ceiling"><code>CEILING</code></a>
</td>
  <td>
    Synonym of <code>CEIL</code>.
  </td>
</tr>

<tr>
  <td><a href="#cos"><code>COS</code></a>
</td>
  <td>
    Computes the cosine of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#cosh"><code>COSH</code></a>
</td>
  <td>
    Computes the hyperbolic cosine of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#cosine_distance"><code>COSINE_DISTANCE</code></a>
</td>
  <td>Computes the cosine distance between two vectors.</td>
</tr>

<tr>
  <td><a href="#cot"><code>COT</code></a>
</td>
  <td>
    Computes the cotangent of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#coth"><code>COTH</code></a>
</td>
  <td>
    Computes the hyperbolic cotangent of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#csc"><code>CSC</code></a>
</td>
  <td>
    Computes the cosecant of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#csch"><code>CSCH</code></a>
</td>
  <td>
    Computes the hyperbolic cosecant of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#div"><code>DIV</code></a>
</td>
  <td>
    Divides integer <code>X</code> by integer <code>Y</code>.
  </td>
</tr>

<tr>
  <td><a href="#exp"><code>EXP</code></a>
</td>
  <td>
    Computes <code>e</code> to the power of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#euclidean_distance"><code>EUCLIDEAN_DISTANCE</code></a>
</td>
  <td>Computes the Euclidean distance between two vectors.</td>
</tr>

<tr>
  <td><a href="#floor"><code>FLOOR</code></a>
</td>
  <td>
    Gets the largest integral value that isn't greater than <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#greatest"><code>GREATEST</code></a>
</td>
  <td>
    Gets the greatest value among <code>X1,...,XN</code>.
  </td>
</tr>

<tr>
  <td><a href="#ieee_divide"><code>IEEE_DIVIDE</code></a>
</td>
  <td>
    Divides <code>X</code> by <code>Y</code>, but doesn't generate errors for
    division by zero or overflow.
  </td>
</tr>

<tr>
  <td><a href="#is_inf"><code>IS_INF</code></a>
</td>
  <td>
    Checks if <code>X</code> is positive or negative infinity.
  </td>
</tr>

<tr>
  <td><a href="#is_nan"><code>IS_NAN</code></a>
</td>
  <td>
    Checks if <code>X</code> is a <code>NaN</code> value.
  </td>
</tr>

<tr>
  <td><a href="#least"><code>LEAST</code></a>
</td>
  <td>
    Gets the least value among <code>X1,...,XN</code>.
  </td>
</tr>

<tr>
  <td><a href="#ln"><code>LN</code></a>
</td>
  <td>
    Computes the natural logarithm of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#log"><code>LOG</code></a>
</td>
  <td>
   Computes the natural logarithm of <code>X</code> or the logarithm of
   <code>X</code> to base <code>Y</code>.
  </td>
</tr>

<tr>
  <td><a href="#log10"><code>LOG10</code></a>
</td>
  <td>
    Computes the natural logarithm of <code>X</code> to base 10.
  </td>
</tr>

<tr>
  <td><a href="#max"><code>MAX</code></a>
</td>
  <td>
    Gets the maximum non-<code>NULL</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate_functions.md">Aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#mod"><code>MOD</code></a>
</td>
  <td>
    Gets the remainder of the division of <code>X</code> by <code>Y</code>.
  </td>
</tr>

<tr>
  <td><a href="#pi"><code>PI</code></a>
</td>
  <td>
    Produces the mathematical constant  as a
    <code>DOUBLE</code> value.
  </td>
</tr>

<tr>
  <td><a href="#pi_bignumeric"><code>PI_BIGNUMERIC</code></a>
</td>
  <td>
    Produces the mathematical constant  as a <code>BIGNUMERIC</code> value.
  </td>
</tr>

<tr>
  <td><a href="#pi_numeric"><code>PI_NUMERIC</code></a>
</td>
  <td>
    Produces the mathematical constant  as a <code>NUMERIC</code> value.
  </td>
</tr>

<tr>
  <td><a href="#pow"><code>POW</code></a>
</td>
  <td>
    Produces the value of <code>X</code> raised to the power of <code>Y</code>.
  </td>
</tr>

<tr>
  <td><a href="#power"><code>POWER</code></a>
</td>
  <td>
    Synonym of <code>POW</code>.
  </td>
</tr>

<tr>
  <td><a href="#rand"><code>RAND</code></a>
</td>
  <td>
    Generates a pseudo-random value of type
    <code>DOUBLE</code> in the range of
    <code>[0, 1)</code>.
  </td>
</tr>

<tr>
  <td><a href="#range_bucket"><code>RANGE_BUCKET</code></a>
</td>
  <td>
    Scans through a sorted array and returns the 0-based position
    of a point's upper bound.
    
  </td>
</tr>

<tr>
  <td><a href="#round"><code>ROUND</code></a>
</td>
  <td>
    Rounds <code>X</code> to the nearest integer or rounds <code>X</code>
    to <code>N</code> decimal places after the decimal point.
  </td>
</tr>

<tr>
  <td><a href="#safe_add"><code>SAFE_ADD</code></a>
</td>
  <td>
    Equivalent to the addition operator (<code>X + Y</code>), but returns
    <code>NULL</code> if overflow occurs.
  </td>
</tr>

<tr>
  <td><a href="#safe_divide"><code>SAFE_DIVIDE</code></a>
</td>
  <td>
    Equivalent to the division operator (<code>X / Y</code>), but returns
    <code>NULL</code> if an error occurs.
  </td>
</tr>

<tr>
  <td><a href="#safe_multiply"><code>SAFE_MULTIPLY</code></a>
</td>
  <td>
    Equivalent to the multiplication operator (<code>X * Y</code>),
    but returns <code>NULL</code> if overflow occurs.
  </td>
</tr>

<tr>
  <td><a href="#safe_negate"><code>SAFE_NEGATE</code></a>
</td>
  <td>
    Equivalent to the unary minus operator (<code>-X</code>), but returns
    <code>NULL</code> if overflow occurs.
  </td>
</tr>

<tr>
  <td><a href="#safe_subtract"><code>SAFE_SUBTRACT</code></a>
</td>
  <td>
    Equivalent to the subtraction operator (<code>X - Y</code>), but
    returns <code>NULL</code> if overflow occurs.
  </td>
</tr>

<tr>
  <td><a href="#sec"><code>SEC</code></a>
</td>
  <td>
    Computes the secant of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#sech"><code>SECH</code></a>
</td>
  <td>
    Computes the hyperbolic secant of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#sign"><code>SIGN</code></a>
</td>
  <td>
    Produces -1 , 0, or +1 for negative, zero, and positive arguments
    respectively.
  </td>
</tr>

<tr>
  <td><a href="#sin"><code>SIN</code></a>
</td>
  <td>
    Computes the sine of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#sinh"><code>SINH</code></a>
</td>
  <td>
    Computes the hyperbolic sine of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#sqrt"><code>SQRT</code></a>
</td>
  <td>
    Computes the square root of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#sum"><code>SUM</code></a>
</td>
  <td>
    Gets the sum of non-<code>NULL</code> values.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate_functions.md">Aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#dp_sum"><code>SUM</code> (Differential Privacy)</a>
</td>
  <td>
    <code>DIFFERENTIAL_PRIVACY</code>-supported <code>SUM</code>.<br/><br/>
    Gets the differentially-private sum of non-<code>NULL</code>,
    non-<code>NaN</code> values in a query with a
    <code>DIFFERENTIAL_PRIVACY</code> clause.
    <br><br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate-dp-functions.md">Differential privacy functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#tan"><code>TAN</code></a>
</td>
  <td>
    Computes the tangent of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#tanh"><code>TANH</code></a>
</td>
  <td>
    Computes the hyperbolic tangent of <code>X</code>.
  </td>
</tr>

<tr>
  <td><a href="#trunc"><code>TRUNC</code></a>
</td>
  <td>
    Rounds a number like <code>ROUND(X)</code> or <code>ROUND(X, N)</code>,
    but always rounds towards zero and never overflows.
  </td>
</tr>

  </tbody>
</table>

### `ABS`

```
ABS(X)
```

**Description**

Computes absolute value. Returns an error if the argument is an integer and the
output value can't be represented as the same type; this happens only for the
largest negative input value, which has no positive representation.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>ABS(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>25</td>
      <td>25</td>
    </tr>
    <tr>
      <td>-25</td>
      <td>25</td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>+inf</code></td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>INT32</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>UINT32</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>FLOAT</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `ACOS`

```
ACOS(X)
```

**Description**

Computes the principal value of the inverse cosine of X. The return value is in
the range [0,&pi;]. Generates an error if X is a value outside of the
range [-1, 1].

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>ACOS(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td>X &lt; -1</td>
      <td>Error</td>
    </tr>
    <tr>
      <td>X &gt; 1</td>
      <td>Error</td>
    </tr>
  </tbody>
</table>

### `ACOSH`

```
ACOSH(X)
```

**Description**

Computes the inverse hyperbolic cosine of X. Generates an error if X is a value
less than 1.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>ACOSH(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td>X &lt; 1</td>
      <td>Error</td>
    </tr>
  </tbody>
</table>

### `ASIN`

```
ASIN(X)
```

**Description**

Computes the principal value of the inverse sine of X. The return value is in
the range [-&pi;/2,&pi;/2]. Generates an error if X is outside of
the range [-1, 1].

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>ASIN(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td>X &lt; -1</td>
      <td>Error</td>
    </tr>
    <tr>
      <td>X &gt; 1</td>
      <td>Error</td>
    </tr>
  </tbody>
</table>

### `ASINH`

```
ASINH(X)
```

**Description**

Computes the inverse hyperbolic sine of X. Doesn't fail.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>ASINH(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>-inf</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
  </tbody>
</table>

### `ATAN`

```
ATAN(X)
```

**Description**

Computes the principal value of the inverse tangent of X. The return value is
in the range [-&pi;/2,&pi;/2]. Doesn't fail.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>ATAN(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td>&pi;/2</td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td>-&pi;/2</td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
  </tbody>
</table>

### `ATAN2`

```
ATAN2(X, Y)
```

**Description**

Calculates the principal value of the inverse tangent of X/Y using the signs of
the two arguments to determine the quadrant. The return value is in the range
[-&pi;,&pi;].

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>Y</th>
      <th>ATAN2(X, Y)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>NaN</code></td>
      <td>Any value</td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td>Any value</td>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <td>Positive Finite value</td>
      <td><code>-inf</code></td>
      <td>&pi;</td>
    </tr>
    <tr>
      <td>Negative Finite value</td>
      <td><code>-inf</code></td>
      <td>-&pi;</td>
    </tr>
    <tr>
      <td>Finite value</td>
      <td><code>+inf</code></td>
      <td>0.0</td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td>Finite value</td>
      <td>&pi;/2</td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td>Finite value</td>
      <td>-&pi;/2</td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td><code>-inf</code></td>
      <td>&frac34;&pi;</td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>-inf</code></td>
      <td>-&frac34;&pi;</td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
      <td>&pi;/4</td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>+inf</code></td>
      <td>-&pi;/4</td>
    </tr>
  </tbody>
</table>

### `ATANH`

```
ATANH(X)
```

**Description**

Computes the inverse hyperbolic tangent of X. Generates an error if X is outside
of the range (-1, 1).

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>ATANH(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td>X &lt; -1</td>
      <td>Error</td>
    </tr>
    <tr>
      <td>X &gt; 1</td>
      <td>Error</td>
    </tr>
  </tbody>
</table>

### `CBRT`

```
CBRT(X)
```

**Description**

Computes the cube root of `X`. `X` can be any data type
that [coerces to `DOUBLE`][conversion-rules].
Supports the `SAFE.` prefix.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>CBRT(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>inf</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>-inf</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>0</code></td>
      <td><code>0</code></td>
    </tr>
    <tr>
      <td><code>NULL</code></td>
      <td><code>NULL</code></td>
    </tr>
  </tbody>
</table>

**Return Data Type**

`DOUBLE`

**Example**

```zetasql
SELECT CBRT(27) AS cube_root;

/*--------------------*
 | cube_root          |
 +--------------------+
 | 3.0000000000000004 |
 *--------------------*/
```

[conversion-rules]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md

### `CEIL`

```
CEIL(X)
```

**Description**

Returns the smallest integral value that isn't less than X.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>CEIL(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <td>2.3</td>
      <td>3.0</td>
    </tr>
    <tr>
      <td>2.8</td>
      <td>3.0</td>
    </tr>
    <tr>
      <td>2.5</td>
      <td>3.0</td>
    </tr>
    <tr>
      <td>-2.3</td>
      <td>-2.0</td>
    </tr>
    <tr>
      <td>-2.8</td>
      <td>-2.0</td>
    </tr>
    <tr>
      <td>-2.5</td>
      <td>-2.0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>-inf</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `CEILING`

```
CEILING(X)
```

**Description**

Synonym of CEIL(X)

### `COS`

```
COS(X)
```

**Description**

Computes the cosine of X where X is specified in radians. Never fails.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>COS(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
  </tbody>
</table>

### `COSH`

```
COSH(X)
```

**Description**

Computes the hyperbolic cosine of X where X is specified in radians.
Generates an error if overflow occurs.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>COSH(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
  </tbody>
</table>

### `COSINE_DISTANCE`

```zetasql
COSINE_DISTANCE(vector1, vector2)
```

**Description**

Computes the [cosine distance][wiki-cosine-distance] between two vectors.

**Definitions**

+   `vector1`: A vector that's represented by an
    `ARRAY<T>` value or a sparse vector that is
    represented by an `ARRAY<STRUCT<dimension,magnitude>>` value.
+   `vector2`: A vector that's represented by an
    `ARRAY<T>` value or a sparse vector that is
    represented by an `ARRAY<STRUCT<dimension,magnitude>>` value.

**Details**

+   `ARRAY<T>` can be used to represent a vector. Each zero-based index in this
    array represents a dimension. The value for each element in this array
    represents a magnitude.

    `T` can represent the following and must be the same for both
    vectors:

    
    
    

    + `FLOAT`
    + `DOUBLE`

    
    

    In the following example vector, there are four dimensions. The magnitude
    is `10.0` for dimension `0`, `55.0` for dimension `1`, `40.0` for
    dimension `2`, and `34.0` for dimension `3`:

    ```
    [10.0, 55.0, 40.0, 34.0]
    ```
+   `ARRAY<STRUCT<dimension,magnitude>>` can be used to represent a
    sparse vector. With a sparse vector, you only need to include
    dimension-magnitude pairs for non-zero magnitudes. If a magnitude isn't
    present in the sparse vector, the magnitude is implicitly understood to be
    zero.

    For example, if you have a vector with 10,000 dimensions, but only 10
    dimensions have non-zero magnitudes, then the vector is a sparse vector.
    As a result, it's more efficient to describe a sparse vector by only
    mentioning its non-zero magnitudes.

    In `ARRAY<STRUCT<dimension,magnitude>>`, `STRUCT<dimension,magnitude>`
    represents a dimension-magnitude pair for each non-zero magnitude in a
    sparse vector. These parts need to be included for each dimension-magnitude
    pair:

    + `dimension`: A `STRING` or `INT64` value that represents a
      dimension in a vector.

    + `magnitude`: A `DOUBLE` value that represents a
      non-zero magnitude for a specific dimension in a vector.

    You don't need to include empty dimension-magnitude pairs in a
    sparse vector. For example, the following sparse vector and
    non-sparse vector are equivalent:

    ```zetasql
    -- sparse vector ARRAY<STRUCT<INT64, DOUBLE>>
    [(1, 10.0), (2, 30.0), (5, 40.0)]
    ```

    ```zetasql
    -- vector ARRAY<DOUBLE>
    [0.0, 10.0, 30.0, 0.0, 0.0, 40.0]
    ```

    In a sparse vector, dimension-magnitude pairs don't need to be in any
    particular order. The following sparse vectors are equivalent:

    ```zetasql
    [('a', 10.0), ('b', 30.0), ('d', 40.0)]
    ```

    ```zetasql
    [('d', 40.0), ('a', 10.0), ('b', 30.0)]
    ```
+   Both non-sparse vectors
    in this function must share the same dimensions, and if they don't, an error
    is produced.
+   A vector can't be a zero vector. A vector is a zero vector if it has
    no dimensions or all dimensions have a magnitude of `0`, such as `[]` or
    `[0.0, 0.0]`. If a zero vector is encountered, an error is produced.
+   An error is produced if a magnitude in a vector is `NULL`.
+   If a vector is `NULL`, `NULL` is returned.

**Return type**

`DOUBLE`

**Examples**

In the following example, non-sparsevectors
are used to compute the cosine distance:

```zetasql
SELECT COSINE_DISTANCE([1.0, 2.0], [3.0, 4.0]) AS results;

/*----------*
 | results  |
 +----------+
 | 0.016130 |
 *----------*/
```

In the following example, sparse vectors are used to compute the
cosine distance:

```zetasql
SELECT COSINE_DISTANCE(
 [(1, 1.0), (2, 2.0)],
 [(2, 4.0), (1, 3.0)]) AS results;

 /*----------*
  | results  |
  +----------+
  | 0.016130 |
  *----------*/
```

The ordering of numeric values in a vector doesn't impact the results
produced by this function. For example these queries produce the same results
even though the numeric values in each vector is in a different order:

```zetasql
SELECT COSINE_DISTANCE([1.0, 2.0], [3.0, 4.0]) AS results;
```

```zetasql
SELECT COSINE_DISTANCE([2.0, 1.0], [4.0, 3.0]) AS results;
```

```zetasql
SELECT COSINE_DISTANCE([(1, 1.0), (2, 2.0)], [(1, 3.0), (2, 4.0)]) AS results;
```

```zetasql
 /*----------*
  | results  |
  +----------+
  | 0.016130 |
  *----------*/
```

In the following example, the function can't compute cosine distance against
the first vector, which is a zero vector:

```zetasql
-- ERROR
SELECT COSINE_DISTANCE([0.0, 0.0], [3.0, 4.0]) AS results;
```

```zetasql
-- ERROR
SELECT COSINE_DISTANCE([(1, 0.0), (2, 0.0)], [(1, 3.0), (2, 4.0)]) AS results;
```

Both non-sparse vectors must have the same
dimensions. If not, an error is produced. In the following example, the
first vector has two dimensions and the second vector has three:

```zetasql
-- ERROR
SELECT COSINE_DISTANCE([9.0, 7.0], [8.0, 4.0, 5.0]) AS results;
```

If you use sparse vectors and you repeat a dimension, an error is
produced:

```zetasql
-- ERROR
SELECT COSINE_DISTANCE(
  [(1, 9.0), (2, 7.0), (2, 8.0)], [(1, 8.0), (2, 4.0), (3, 5.0)]) AS results;
```

[wiki-cosine-distance]: https://en.wikipedia.org/wiki/Cosine_similarity#Cosine_distance

### `COT`

```
COT(X)
```

**Description**

Computes the cotangent for the angle of `X`, where `X` is specified in radians.
`X` can be any data type
that [coerces to `DOUBLE`][conversion-rules].
Supports the `SAFE.` prefix.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>COT(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>0</code></td>
      <td><code>Error</code></td>
    </tr>
    <tr>
      <td><code>NULL</code></td>
      <td><code>NULL</code></td>
    </tr>
  </tbody>
</table>

**Return Data Type**

`DOUBLE`

**Example**

```zetasql
SELECT COT(1) AS a, SAFE.COT(0) AS b;

/*---------------------+------*
 | a                   | b    |
 +---------------------+------+
 | 0.64209261593433065 | NULL |
 *---------------------+------*/
```

[conversion-rules]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md

### `COTH`

```
COTH(X)
```

**Description**

Computes the hyperbolic cotangent for the angle of `X`, where `X` is specified
in radians. `X` can be any data type
that [coerces to `DOUBLE`][conversion-rules].
Supports the `SAFE.` prefix.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>COTH(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>1</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>-1</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>0</code></td>
      <td><code>Error</code></td>
    </tr>
    <tr>
      <td><code>NULL</code></td>
      <td><code>NULL</code></td>
    </tr>
  </tbody>
</table>

**Return Data Type**

`DOUBLE`

**Example**

```zetasql
SELECT COTH(1) AS a, SAFE.COTH(0) AS b;

/*----------------+------*
 | a              | b    |
 +----------------+------+
 | 1.313035285499 | NULL |
 *----------------+------*/
```

[conversion-rules]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md

### `CSC`

```
CSC(X)
```

**Description**

Computes the cosecant of the input angle, which is in radians.
`X` can be any data type
that [coerces to `DOUBLE`][conversion-rules].
Supports the `SAFE.` prefix.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>CSC(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>0</code></td>
      <td><code>Error</code></td>
    </tr>
    <tr>
      <td><code>NULL</code></td>
      <td><code>NULL</code></td>
    </tr>
  </tbody>
</table>

**Return Data Type**

`DOUBLE`

**Example**

```zetasql
SELECT CSC(100) AS a, CSC(-1) AS b, SAFE.CSC(0) AS c;

/*----------------+-----------------+------*
 | a              | b               | c    |
 +----------------+-----------------+------+
 | -1.97485753142 | -1.188395105778 | NULL |
 *----------------+-----------------+------*/
```

[conversion-rules]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md

### `CSCH`

```
CSCH(X)
```

**Description**

Computes the hyperbolic cosecant of the input angle, which is in radians.
`X` can be any data type
that [coerces to `DOUBLE`][conversion-rules].
Supports the `SAFE.` prefix.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>CSCH(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>0</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>0</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>0</code></td>
      <td><code>Error</code></td>
    </tr>
    <tr>
      <td><code>NULL</code></td>
      <td><code>NULL</code></td>
    </tr>
  </tbody>
</table>

**Return Data Type**

`DOUBLE`

**Example**

```zetasql
SELECT CSCH(0.5) AS a, CSCH(-2) AS b, SAFE.CSCH(0) AS c;

/*----------------+----------------+------*
 | a              | b              | c    |
 +----------------+----------------+------+
 | 1.919034751334 | -0.27572056477 | NULL |
 *----------------+----------------+------*/
```

[conversion-rules]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md

### `DIV`

```
DIV(X, Y)
```

**Description**

Returns the result of integer division of X by Y. Division by zero returns
an error. Division by -1 may overflow.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>Y</th>
      <th>DIV(X, Y)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>20</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <td>12</td>
      <td>-7</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>20</td>
      <td>3</td>
      <td>6</td>
    </tr>
    <tr>
      <td>0</td>
      <td>20</td>
      <td>0</td>
    </tr>
    <tr>
      <td>20</td>
      <td>0</td>
      <td>Error</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

The return data type is determined by the argument types with the following
table.
<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th>
</tr>
</thead>
<tbody>
<tr><th><code>INT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td></tr>
<tr><th><code>INT64</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td></tr>
<tr><th><code>UINT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td></tr>
<tr><th><code>UINT64</code></th><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td></tr>
<tr><th><code>NUMERIC</code></th><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td></tr>
<tr><th><code>BIGNUMERIC</code></th><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td></tr>
</tbody>

</table>

### `EXP`

```
EXP(X)
```

**Description**

Computes *e* to the power of X, also called the natural exponential function. If
the result underflows, this function returns a zero. Generates an error if the
result overflows.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>EXP(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td>0.0</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `EUCLIDEAN_DISTANCE`

```zetasql
EUCLIDEAN_DISTANCE(vector1, vector2)
```

**Description**

Computes the [Euclidean distance][wiki-euclidean-distance] between two vectors.

**Definitions**

+   `vector1`: A vector that's represented by an
    `ARRAY<T>` value or a sparse vector that is
    represented by an `ARRAY<STRUCT<dimension,magnitude>>` value.
+   `vector2`: A vector that's represented by an
    `ARRAY<T>` value or a sparse vector that is
    represented by an `ARRAY<STRUCT<dimension,magnitude>>` value.

**Details**

+   `ARRAY<T>` can be used to represent a vector. Each zero-based index in this
    array represents a dimension. The value for each element in this array
    represents a magnitude.

    `T` can represent the following and must be the same for both
    vectors:

    
    
    

    + `FLOAT`
    + `DOUBLE`

    
    

    In the following example vector, there are four dimensions. The magnitude
    is `10.0` for dimension `0`, `55.0` for dimension `1`, `40.0` for
    dimension `2`, and `34.0` for dimension `3`:

    ```
    [10.0, 55.0, 40.0, 34.0]
    ```
+   `ARRAY<STRUCT<dimension,magnitude>>` can be used to represent a
    sparse vector. With a sparse vector, you only need to include
    dimension-magnitude pairs for non-zero magnitudes. If a magnitude isn't
    present in the sparse vector, the magnitude is implicitly understood to be
    zero.

    For example, if you have a vector with 10,000 dimensions, but only 10
    dimensions have non-zero magnitudes, then the vector is a sparse vector.
    As a result, it's more efficient to describe a sparse vector by only
    mentioning its non-zero magnitudes.

    In `ARRAY<STRUCT<dimension,magnitude>>`, `STRUCT<dimension,magnitude>`
    represents a dimension-magnitude pair for each non-zero magnitude in a
    sparse vector. These parts need to be included for each dimension-magnitude
    pair:

    + `dimension`: A `STRING` or `INT64` value that represents a
      dimension in a vector.

    + `magnitude`: A `DOUBLE` value that represents a
      non-zero magnitude for a specific dimension in a vector.

    You don't need to include empty dimension-magnitude pairs in a
    sparse vector. For example, the following sparse vector and
    non-sparse vector are equivalent:

    ```zetasql
    -- sparse vector ARRAY<STRUCT<INT64, DOUBLE>>
    [(1, 10.0), (2, 30.0), (5, 40.0)]
    ```

    ```zetasql
    -- vector ARRAY<DOUBLE>
    [0.0, 10.0, 30.0, 0.0, 0.0, 40.0]
    ```

    In a sparse vector, dimension-magnitude pairs don't need to be in any
    particular order. The following sparse vectors are equivalent:

    ```zetasql
    [('a', 10.0), ('b', 30.0), ('d', 40.0)]
    ```

    ```zetasql
    [('d', 40.0), ('a', 10.0), ('b', 30.0)]
    ```
+   Both non-sparse vectors
    in this function must share the same dimensions, and if they don't, an error
    is produced.
+   A vector can be a zero vector. A vector is a zero vector if it has
    no dimensions or all dimensions have a magnitude of `0`, such as `[]` or
    `[0.0, 0.0]`.
+   An error is produced if a magnitude in a vector is `NULL`.
+   If a vector is `NULL`, `NULL` is returned.

**Return type**

`DOUBLE`

**Examples**

In the following example, non-sparse vectors
are used to compute the Euclidean distance:

```zetasql
SELECT EUCLIDEAN_DISTANCE([1.0, 2.0], [3.0, 4.0]) AS results;

/*----------*
 | results  |
 +----------+
 | 2.828    |
 *----------*/
```

In the following example, sparse vectors are used to compute the
Euclidean distance:

```zetasql
SELECT EUCLIDEAN_DISTANCE(
 [(1, 1.0), (2, 2.0)],
 [(2, 4.0), (1, 3.0)]) AS results;

 /*----------*
  | results  |
  +----------+
  | 2.828    |
  *----------*/
```

The ordering of magnitudes in a vector doesn't impact the results
produced by this function. For example these queries produce the same results
even though the magnitudes in each vector is in a different order:

```zetasql
SELECT EUCLIDEAN_DISTANCE([1.0, 2.0], [3.0, 4.0]);
```

```zetasql
SELECT EUCLIDEAN_DISTANCE([2.0, 1.0], [4.0, 3.0]);
```

```zetasql
SELECT EUCLIDEAN_DISTANCE([(1, 1.0), (2, 2.0)], [(1, 3.0), (2, 4.0)]) AS results;
```

```zetasql
 /*----------*
  | results  |
  +----------+
  | 2.828    |
  *----------*/
```

Both non-sparse vectors must have the same
dimensions. If not, an error is produced. In the following example, the first
vector has two dimensions and the second vector has three:

```zetasql
-- ERROR
SELECT EUCLIDEAN_DISTANCE([9.0, 7.0], [8.0, 4.0, 5.0]) AS results;
```

If you use sparse vectors and you repeat a dimension, an error is
produced:

```zetasql
-- ERROR
SELECT EUCLIDEAN_DISTANCE(
  [(1, 9.0), (2, 7.0), (2, 8.0)], [(1, 8.0), (2, 4.0), (3, 5.0)]) AS results;
```

[wiki-euclidean-distance]: https://en.wikipedia.org/wiki/Euclidean_distance

### `FLOOR`

```
FLOOR(X)
```

**Description**

Returns the largest integral value that isn't greater than X.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>FLOOR(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <td>2.3</td>
      <td>2.0</td>
    </tr>
    <tr>
      <td>2.8</td>
      <td>2.0</td>
    </tr>
    <tr>
      <td>2.5</td>
      <td>2.0</td>
    </tr>
    <tr>
      <td>-2.3</td>
      <td>-3.0</td>
    </tr>
    <tr>
      <td>-2.8</td>
      <td>-3.0</td>
    </tr>
    <tr>
      <td>-2.5</td>
      <td>-3.0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>-inf</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `GREATEST`

```
GREATEST(X1,...,XN)
```

**Description**

Returns the greatest value among `X1,...,XN`. If any argument is `NULL`, returns
`NULL`. Otherwise, in the case of floating-point arguments, if any argument is
`NaN`, returns `NaN`. In all other cases, returns the value among `X1,...,XN`
that has the greatest value according to the ordering used by the `ORDER BY`
clause. The arguments `X1, ..., XN` must be coercible to a common supertype, and
the supertype must support ordering.

<table>
  <thead>
    <tr>
      <th>X1,...,XN</th>
      <th>GREATEST(X1,...,XN)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>3,5,1</td>
      <td>5</td>
    </tr>
  </tbody>
</table>

This function supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

**Return Data Types**

Data type of the input values.

### `IEEE_DIVIDE`

```
IEEE_DIVIDE(X, Y)
```

**Description**

Divides X by Y; this function never fails. Returns
`DOUBLE` unless
both X and Y are `FLOAT`, in which case it returns
`FLOAT`. Unlike the division operator (/),
this function doesn't generate errors for division by zero or overflow.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>Y</th>
      <th>IEEE_DIVIDE(X, Y)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>20.0</td>
      <td>4.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <td>0.0</td>
      <td>25.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <td>25.0</td>
      <td>0.0</td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td>-25.0</td>
      <td>0.0</td>
      <td><code>-inf</code></td>
    </tr>
    <tr>
      <td>25.0</td>
      <td>-0.0</td>
      <td><code>-inf</code></td>
    </tr>
    <tr>
      <td>0.0</td>
      <td>0.0</td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td>0.0</td>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td>0.0</td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>-inf</code></td>
      <td><code>NaN</code></td>
    </tr>
  </tbody>
</table>

### `IS_INF`

```
IS_INF(X)
```

**Description**

Returns `TRUE` if the value is positive or negative infinity.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>IS_INF(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>TRUE</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>TRUE</code></td>
    </tr>
    <tr>
      <td>25</td>
      <td><code>FALSE</code></td>
    </tr>
  </tbody>
</table>

### `IS_NAN`

```
IS_NAN(X)
```

**Description**

Returns `TRUE` if the value is a `NaN` value.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>IS_NAN(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>NaN</code></td>
      <td><code>TRUE</code></td>
    </tr>
    <tr>
      <td>25</td>
      <td><code>FALSE</code></td>
    </tr>
  </tbody>
</table>

### `LEAST`

```
LEAST(X1,...,XN)
```

**Description**

Returns the least value among `X1,...,XN`. If any argument is `NULL`, returns
`NULL`. Otherwise, in the case of floating-point arguments, if any argument is
`NaN`, returns `NaN`. In all other cases, returns the value among `X1,...,XN`
that has the least value according to the ordering used by the `ORDER BY`
clause. The arguments `X1, ..., XN` must be coercible to a common supertype, and
the supertype must support ordering.

<table>
  <thead>
    <tr>
      <th>X1,...,XN</th>
      <th>LEAST(X1,...,XN)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>3,5,1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

This function supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

**Return Data Types**

Data type of the input values.

### `LN`

```
LN(X)
```

**Description**

Computes the natural logarithm of X. Generates an error if X is less than or
equal to zero.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>LN(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>1.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>X &lt;= 0</code></td>
      <td>Error</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `LOG`

```
LOG(X [, Y])
```

**Description**

If only X is present, `LOG` is a synonym of `LN`. If Y is also present,
`LOG` computes the logarithm of X to base Y.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>Y</th>
      <th>LOG(X, Y)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>100.0</td>
      <td>10.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td>Any value</td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td>Any value</td>
      <td><code>+inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td>0.0 &lt; Y &lt; 1.0</td>
      <td><code>-inf</code></td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td>Y &gt; 1.0</td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td>X &lt;= 0</td>
      <td>Any value</td>
      <td>Error</td>
    </tr>
    <tr>
      <td>Any value</td>
      <td>Y &lt;= 0</td>
      <td>Error</td>
    </tr>
    <tr>
      <td>Any value</td>
      <td>1.0</td>
      <td>Error</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table style="font-size:small">

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th><code>INT32</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>INT64</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT32</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT64</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>NUMERIC</code></th><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>BIGNUMERIC</code></th><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>FLOAT</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>DOUBLE</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `LOG10`

```
LOG10(X)
```

**Description**

Similar to `LOG`, but computes logarithm to base 10.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>LOG10(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>100.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td>X &lt;= 0</td>
      <td>Error</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `MOD`

```
MOD(X, Y)
```

**Description**

Modulo function: returns the remainder of the division of X by Y. Returned
value has the same sign as X. An error is generated if Y is 0.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>Y</th>
      <th>MOD(X, Y)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>25</td>
      <td>12</td>
      <td>1</td>
    </tr>
    <tr>
      <td>25</td>
      <td>0</td>
      <td>Error</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

The return data type is determined by the argument types with the following
table.
<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th>
</tr>
</thead>
<tbody>
<tr><th><code>INT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td></tr>
<tr><th><code>INT64</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td></tr>
<tr><th><code>UINT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td></tr>
<tr><th><code>UINT64</code></th><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td></tr>
<tr><th><code>NUMERIC</code></th><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td></tr>
<tr><th><code>BIGNUMERIC</code></th><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td></tr>
</tbody>

</table>

### `PI`

```zetasql
PI()
```

**Description**

Returns the mathematical constant `` as a `DOUBLE`
value.

**Return type**

`DOUBLE`

**Example**

```zetasql
SELECT PI() AS pi

/*--------------------*
 | pi                 |
 +--------------------+
 | 3.1415926535897931 |
 *--------------------*/
```

### `PI_BIGNUMERIC`

```zetasql
PI_BIGNUMERIC()
```

**Description**

Returns the mathematical constant `` as a `BIGNUMERIC` value.

**Return type**

`BIGNUMERIC`

**Example**

```zetasql
SELECT PI_BIGNUMERIC() AS pi

/*-----------------------------------------*
 | pi                                      |
 +-----------------------------------------+
 | 3.1415926535897932384626433832795028842 |
 *-----------------------------------------*/
```

### `PI_NUMERIC`

```zetasql
PI_NUMERIC()
```

**Description**

Returns the mathematical constant `` as a `NUMERIC` value.

**Return type**

`NUMERIC`

**Example**

```zetasql
SELECT PI_NUMERIC() AS pi

/*-------------*
 | pi          |
 +-------------+
 | 3.141592654 |
 *-------------*/
```

### `POW`

```
POW(X, Y)
```

**Description**

Returns the value of X raised to the power of Y. If the result underflows and
isn't representable, then the function returns a value of zero.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>Y</th>
      <th>POW(X, Y)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2.0</td>
      <td>3.0</td>
      <td>8.0</td>
    </tr>
    <tr>
      <td>1.0</td>
      <td>Any value including <code>NaN</code></td>
      <td>1.0</td>
    </tr>
    <tr>
      <td>Any value including <code>NaN</code></td>
      <td>0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <td>-1.0</td>
      <td><code>+inf</code></td>
      <td>1.0</td>
    </tr>
    <tr>
      <td>-1.0</td>
      <td><code>-inf</code></td>
      <td>1.0</td>
    </tr>
    <tr>
      <td>ABS(X) &lt; 1</td>
      <td><code>-inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td>ABS(X) &gt; 1</td>
      <td><code>-inf</code></td>
      <td>0.0</td>
    </tr>
    <tr>
      <td>ABS(X) &lt; 1</td>
      <td><code>+inf</code></td>
      <td>0.0</td>
    </tr>
    <tr>
      <td>ABS(X) &gt; 1</td>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td>Y &lt; 0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td>Y &gt; 0</td>
      <td><code>-inf</code> if Y is an odd integer, <code>+inf</code> otherwise</td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td>Y &lt; 0</td>
      <td>0</td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td>Y &gt; 0</td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td>Finite value &lt; 0</td>
      <td>Non-integer</td>
      <td>Error</td>
    </tr>
    <tr>
      <td>0</td>
      <td>Finite value &lt; 0</td>
      <td>Error</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

The return data type is determined by the argument types with the following
table.

<table style="font-size:small">

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th><code>INT32</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>INT64</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT32</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT64</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>NUMERIC</code></th><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>BIGNUMERIC</code></th><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>FLOAT</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>DOUBLE</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `POWER`

```
POWER(X, Y)
```

**Description**

Synonym of [`POW(X, Y)`][pow].

[pow]: #pow

### `RAND`

```
RAND()
```

**Description**

Generates a pseudo-random value of type `DOUBLE` in
the range of [0, 1), inclusive of 0 and exclusive of 1.

### `RANGE_BUCKET`

```zetasql
RANGE_BUCKET(point, boundaries_array)
```

**Description**

`RANGE_BUCKET` scans through a sorted array and returns the 0-based position
of the point's upper bound. This can be useful if you need to group your data to
build partitions, histograms, business-defined rules, and more.

`RANGE_BUCKET` follows these rules:

+  If the point exists in the array, returns the index of the next larger value.

   ```zetasql
   RANGE_BUCKET(20, [0, 10, 20, 30, 40]) -- 3 is return value
   RANGE_BUCKET(20, [0, 10, 20, 20, 40, 40]) -- 4 is return value
   ```
+  If the point doesn't exist in the array, but it falls between two values,
   returns the index of the larger value.

   ```zetasql
   RANGE_BUCKET(25, [0, 10, 20, 30, 40]) -- 3 is return value
   ```
+  If the point is smaller than the first value in the array, returns 0.

   ```zetasql
   RANGE_BUCKET(-10, [5, 10, 20, 30, 40]) -- 0 is return value
   ```
+  If the point is greater than or equal to the last value in the array,
   returns the length of the array.

   ```zetasql
   RANGE_BUCKET(80, [0, 10, 20, 30, 40]) -- 5 is return value
   ```
+  If the array is empty, returns 0.

   ```zetasql
   RANGE_BUCKET(80, []) -- 0 is return value
   ```
+  If the point is `NULL` or `NaN`, returns `NULL`.

   ```zetasql
   RANGE_BUCKET(NULL, [0, 10, 20, 30, 40]) -- NULL is return value
   ```
+  The data type for the point and array must be compatible.

   ```zetasql
   RANGE_BUCKET('a', ['a', 'b', 'c', 'd']) -- 1 is return value
   RANGE_BUCKET(1.2, [1, 1.2, 1.4, 1.6]) -- 2 is return value
   RANGE_BUCKET(1.2, [1, 2, 4, 6]) -- execution failure
   ```

Execution failure occurs when:

+  The array has a `NaN` or `NULL` value in it.

   ```zetasql
   RANGE_BUCKET(80, [NULL, 10, 20, 30, 40]) -- execution failure
   ```
+  The array isn't sorted in ascending order.

   ```zetasql
   RANGE_BUCKET(30, [10, 30, 20, 40, 50]) -- execution failure
   ```

**Parameters**

+  `point`: A generic value.
+  `boundaries_array`: A generic array of values.

Note: The data type for `point` and the element type of `boundaries_array`
must be equivalent. The data type must be [comparable][data-type-properties].

**Return Value**

`INT64`

**Examples**

In a table called `students`, check to see how many records would
exist in each `age_group` bucket, based on a student's age:

+  age_group 0 (age < 10)
+  age_group 1 (age >= 10, age < 20)
+  age_group 2 (age >= 20, age < 30)
+  age_group 3 (age >= 30)

```zetasql
WITH students AS
(
  SELECT 9 AS age UNION ALL
  SELECT 20 AS age UNION ALL
  SELECT 25 AS age UNION ALL
  SELECT 31 AS age UNION ALL
  SELECT 32 AS age UNION ALL
  SELECT 33 AS age
)
SELECT RANGE_BUCKET(age, [10, 20, 30]) AS age_group, COUNT(*) AS count
FROM students
GROUP BY 1

/*--------------+-------*
 | age_group    | count |
 +--------------+-------+
 | 0            | 1     |
 | 2            | 2     |
 | 3            | 3     |
 *--------------+-------*/
```

[data-type-properties]: https://github.com/google/zetasql/blob/master/docs/data-types.md#data_type_properties

### `ROUND`

```
ROUND(X [, N [, rounding_mode]])
```

**Description**

If only X is present, rounds X to the nearest integer. If N is present,
rounds X to N decimal places after the decimal point. If N is negative,
rounds off digits to the left of the decimal point. Rounds halfway cases
away from zero. Generates an error if overflow occurs.

If X is a `NUMERIC` or `BIGNUMERIC` type, then you can
explicitly set `rounding_mode`
to one of the following:

+   [`"ROUND_HALF_AWAY_FROM_ZERO"`][round-half-away-from-zero]: (Default) Rounds
    halfway cases away from zero.
+   [`"ROUND_HALF_EVEN"`][round-half-even]: Rounds halfway cases
    towards the nearest even digit.

If you set the `rounding_mode` and X isn't a `NUMERIC` or `BIGNUMERIC` type,
then the function generates an error.

<table>
  <thead>
    <tr>
      <th>Expression</th>
      <th>Return Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ROUND(2.0)</code></td>
      <td>2.0</td>
    </tr>
    <tr>
      <td><code>ROUND(2.3)</code></td>
      <td>2.0</td>
    </tr>
    <tr>
      <td><code>ROUND(2.8)</code></td>
      <td>3.0</td>
    </tr>
    <tr>
      <td><code>ROUND(2.5)</code></td>
      <td>3.0</td>
    </tr>
    <tr>
      <td><code>ROUND(-2.3)</code></td>
      <td>-2.0</td>
    </tr>
    <tr>
      <td><code>ROUND(-2.8)</code></td>
      <td>-3.0</td>
    </tr>
    <tr>
      <td><code>ROUND(-2.5)</code></td>
      <td>-3.0</td>
    </tr>
    <tr>
      <td><code>ROUND(0)</code></td>
      <td>0</td>
    </tr>
    <tr>
      <td><code>ROUND(+inf)</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>ROUND(-inf)</code></td>
      <td><code>-inf</code></td>
    </tr>
    <tr>
      <td><code>ROUND(NaN)</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>ROUND(123.7, -1)</code></td>
      <td>120.0</td>
    </tr>
    <tr>
      <td><code>ROUND(1.235, 2)</code></td>
      <td>1.24</td>
    </tr>
    <tr>
      <td><code>ROUND(NUMERIC "2.25", 1, "ROUND_HALF_EVEN")</code></td>
      <td>2.2</td>
    </tr>
    <tr>
      <td><code>ROUND(NUMERIC "2.35", 1, "ROUND_HALF_EVEN")</code></td>
      <td>2.4</td>
    </tr>
    <tr>
      <td><code>ROUND(NUMERIC "2.251", 1, "ROUND_HALF_EVEN")</code></td>
      <td>2.3</td>
    </tr>
    <tr>
      <td><code>ROUND(NUMERIC "-2.5", 0, "ROUND_HALF_EVEN")</code></td>
      <td>-2</td>
    </tr>
    <tr>
      <td><code>ROUND(NUMERIC "2.5", 0, "ROUND_HALF_AWAY_FROM_ZERO")</code></td>
      <td>3</td>
    </tr>
    <tr>
      <td><code>ROUND(NUMERIC "-2.5", 0, "ROUND_HALF_AWAY_FROM_ZERO")</code></td>
      <td>-3</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

[round-half-away-from-zero]: https://en.wikipedia.org/wiki/Rounding#Rounding_half_away_from_zero

[round-half-even]: https://en.wikipedia.org/wiki/Rounding#Rounding_half_to_even

### `SAFE_ADD`

```
SAFE_ADD(X, Y)
```

**Description**

Equivalent to the addition operator (`+`), but returns
`NULL` if overflow occurs.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>Y</th>
      <th>SAFE_ADD(X, Y)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>5</td>
      <td>4</td>
      <td>9</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table style="font-size:small">

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th><code>INT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>INT64</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT64</code></th><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>NUMERIC</code></th><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>BIGNUMERIC</code></th><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>FLOAT</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>DOUBLE</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `SAFE_DIVIDE`

```
SAFE_DIVIDE(X, Y)
```

**Description**

Equivalent to the division operator (`X / Y`), but returns
`NULL` if an error occurs, such as a division by zero error.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>Y</th>
      <th>SAFE_DIVIDE(X, Y)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>20</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <td>0</td>
      <td>20</td>
      <td><code>0</code></td>
    </tr>
    <tr>
      <td>20</td>
      <td>0</td>
      <td><code>NULL</code></td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table style="font-size:small">

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th><code>INT32</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>INT64</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT32</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT64</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>NUMERIC</code></th><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>BIGNUMERIC</code></th><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>FLOAT</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>DOUBLE</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `SAFE_MULTIPLY`

```
SAFE_MULTIPLY(X, Y)
```

**Description**

Equivalent to the multiplication operator (`*`), but returns
`NULL` if overflow occurs.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>Y</th>
      <th>SAFE_MULTIPLY(X, Y)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>20</td>
      <td>4</td>
      <td>80</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table style="font-size:small">

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th><code>INT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>INT64</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT64</code></th><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>NUMERIC</code></th><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>BIGNUMERIC</code></th><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>FLOAT</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>DOUBLE</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `SAFE_NEGATE`

```
SAFE_NEGATE(X)
```

**Description**

Equivalent to the unary minus operator (`-`), but returns
`NULL` if overflow occurs.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>SAFE_NEGATE(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>+1</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>-1</td>
      <td>+1</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>INT32</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>FLOAT</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `SAFE_SUBTRACT`

```
SAFE_SUBTRACT(X, Y)
```

**Description**

Returns the result of Y subtracted from X.
Equivalent to the subtraction operator (`-`), but returns
`NULL` if overflow occurs.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>Y</th>
      <th>SAFE_SUBTRACT(X, Y)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>5</td>
      <td>4</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table style="font-size:small">

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th><code>INT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>INT64</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT32</code></th><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>UINT64</code></th><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle">ERROR</td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>NUMERIC</code></th><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>BIGNUMERIC</code></th><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>FLOAT</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>DOUBLE</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `SEC`

```
SEC(X)
```

**Description**

Computes the secant for the angle of `X`, where `X` is specified in radians.
`X` can be any data type
that [coerces to `DOUBLE`][conversion-rules].

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>SEC(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>NULL</code></td>
      <td><code>NULL</code></td>
    </tr>
  </tbody>
</table>

**Return Data Type**

`DOUBLE`

**Example**

```zetasql
SELECT SEC(100) AS a, SEC(-1) AS b;

/*----------------+---------------*
 | a              | b             |
 +----------------+---------------+
 | 1.159663822905 | 1.85081571768 |
 *----------------+---------------*/
```

[conversion-rules]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md

### `SECH`

```
SECH(X)
```

**Description**

Computes the hyperbolic secant for the angle of `X`, where `X` is specified
in radians. `X` can be any data type
that [coerces to `DOUBLE`][conversion-rules].
Never produces an error.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>SECH(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>0</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>0</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>NULL</code></td>
      <td><code>NULL</code></td>
    </tr>
  </tbody>
</table>

**Return Data Type**

`DOUBLE`

**Example**

```zetasql
SELECT SECH(0.5) AS a, SECH(-2) AS b, SECH(100) AS c;

/*----------------+----------------+---------------------*
 | a              | b              | c                   |
 +----------------+----------------+---------------------+
 | 0.88681888397  | 0.265802228834 | 7.4401519520417E-44 |
 *----------------+----------------+---------------------*/
```

[conversion-rules]: https://github.com/google/zetasql/blob/master/docs/conversion_rules.md

### `SIGN`

```
SIGN(X)
```

**Description**

Returns `-1`, `0`, or `+1` for negative, zero and positive arguments
respectively. For floating point arguments, this function doesn't distinguish
between positive and negative zero.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>SIGN(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>25</td>
      <td>+1</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>-25</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>INT32</code></td><td style="vertical-align:middle"><code>INT64</code></td><td style="vertical-align:middle"><code>UINT32</code></td><td style="vertical-align:middle"><code>UINT64</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>FLOAT</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `SIN`

```
SIN(X)
```

**Description**

Computes the sine of X where X is specified in radians. Never fails.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>SIN(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
  </tbody>
</table>

### `SINH`

```
SINH(X)
```

**Description**

Computes the hyperbolic sine of X where X is specified in radians. Generates
an error if overflow occurs.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>SINH(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>-inf</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
  </tbody>
</table>

### `SQRT`

```
SQRT(X)
```

**Description**

Computes the square root of X. Generates an error if X is less than 0.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>SQRT(X)</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>25.0</code></td>
      <td><code>5.0</code></td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>X &lt; 0</code></td>
      <td>Error</td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

### `TAN`

```
TAN(X)
```

**Description**

Computes the tangent of X where X is specified in radians. Generates an error if
overflow occurs.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>TAN(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>NaN</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
  </tbody>
</table>

### `TANH`

```
TANH(X)
```

**Description**

Computes the hyperbolic tangent of X where X is specified in radians. Doesn't
fail.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>TANH(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+inf</code></td>
      <td>1.0</td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td>-1.0</td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
  </tbody>
</table>

### `TRUNC`

```
TRUNC(X [, N])
```

**Description**

If only X is present, `TRUNC` rounds X to the nearest integer whose absolute
value isn't greater than the absolute value of X. If N is also present, `TRUNC`
behaves like `ROUND(X, N)`, but always rounds towards zero and never overflows.

<table>
  <thead>
    <tr>
      <th>X</th>
      <th>TRUNC(X)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <td>2.3</td>
      <td>2.0</td>
    </tr>
    <tr>
      <td>2.8</td>
      <td>2.0</td>
    </tr>
    <tr>
      <td>2.5</td>
      <td>2.0</td>
    </tr>
    <tr>
      <td>-2.3</td>
      <td>-2.0</td>
    </tr>
    <tr>
      <td>-2.8</td>
      <td>-2.0</td>
    </tr>
    <tr>
      <td>-2.5</td>
      <td>-2.0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td><code>+inf</code></td>
      <td><code>+inf</code></td>
    </tr>
    <tr>
      <td><code>-inf</code></td>
      <td><code>-inf</code></td>
    </tr>
    <tr>
      <td><code>NaN</code></td>
      <td><code>NaN</code></td>
    </tr>
  </tbody>
</table>

**Return Data Type**

<table>

<thead>
<tr>
<th>INPUT</th><th><code>INT32</code></th><th><code>INT64</code></th><th><code>UINT32</code></th><th><code>UINT64</code></th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>FLOAT</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th>OUTPUT</th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

## Navigation functions

ZetaSQL supports navigation functions.
Navigation functions are a subset of window functions. To create a
window function call and learn about the syntax for window functions,
see [Window function_calls][window-function-calls].

Navigation functions generally compute some
`value_expression` over a different row in the window frame from the
current row. The `OVER` clause syntax varies across navigation functions.

For all navigation functions, the result data type is the same type as
`value_expression`.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#first_value"><code>FIRST_VALUE</code></a>
</td>
  <td>
    Gets a value for the first row in the current window frame.
    
  </td>
</tr>

<tr>
  <td><a href="#lag"><code>LAG</code></a>
</td>
  <td>
    Gets a value for a preceding row.
    
  </td>
</tr>

<tr>
  <td><a href="#last_value"><code>LAST_VALUE</code></a>
</td>
  <td>
    Gets a value for the last row in the current window frame.
    
  </td>
</tr>

<tr>
  <td><a href="#lead"><code>LEAD</code></a>
</td>
  <td>
    Gets a value for a subsequent row.
    
  </td>
</tr>

<tr>
  <td><a href="#nth_value"><code>NTH_VALUE</code></a>
</td>
  <td>
    Gets a value for the Nth row of the current window frame.
    
  </td>
</tr>

<tr>
  <td><a href="#percentile_cont"><code>PERCENTILE_CONT</code></a>
</td>
  <td>
    Computes the specified percentile for a value, using
    linear interpolation.
    
  </td>
</tr>

<tr>
  <td><a href="#percentile_disc"><code>PERCENTILE_DISC</code></a>
</td>
  <td>
    Computes the specified percentile for a discrete value.
    
  </td>
</tr>

  </tbody>
</table>

### `FIRST_VALUE`

```zetasql
FIRST_VALUE (value_expression [{RESPECT | IGNORE} NULLS])
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  ORDER BY expression [ { ASC | DESC }  ] [, ...]
  [ window_frame_clause ]

```

**Description**

Returns the value of the `value_expression` for the first row in the current
window frame.

This function includes `NULL` values in the calculation unless `IGNORE NULLS` is
present. If `IGNORE NULLS` is present, the function excludes `NULL` values from
the calculation.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

`value_expression` can be any data type that an expression can return.

**Return Data Type**

Same type as `value_expression`.

**Examples**

The following example computes the fastest time for each division.

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'
  UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'
  UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')
SELECT name,
  FORMAT_TIMESTAMP('%X', finish_time) AS finish_time,
  division,
  FORMAT_TIMESTAMP('%X', fastest_time) AS fastest_time,
  TIMESTAMP_DIFF(finish_time, fastest_time, SECOND) AS delta_in_seconds
FROM (
  SELECT name,
  finish_time,
  division,
  FIRST_VALUE(finish_time)
    OVER (PARTITION BY division ORDER BY finish_time ASC
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS fastest_time
  FROM finishers);

/*-----------------+-------------+----------+--------------+------------------*
 | name            | finish_time | division | fastest_time | delta_in_seconds |
 +-----------------+-------------+----------+--------------+------------------+
 | Carly Forte     | 03:08:58    | F25-29   | 03:08:58     | 0                |
 | Sophia Liu      | 02:51:45    | F30-34   | 02:51:45     | 0                |
 | Nikki Leith     | 02:59:01    | F30-34   | 02:51:45     | 436              |
 | Jen Edwards     | 03:06:36    | F30-34   | 02:51:45     | 891              |
 | Meghan Lederer  | 03:07:41    | F30-34   | 02:51:45     | 956              |
 | Lauren Reasoner | 03:10:14    | F30-34   | 02:51:45     | 1109             |
 | Lisa Stelzner   | 02:54:11    | F35-39   | 02:54:11     | 0                |
 | Lauren Matthews | 03:01:17    | F35-39   | 02:54:11     | 426              |
 | Desiree Berry   | 03:05:42    | F35-39   | 02:54:11     | 691              |
 | Suzy Slane      | 03:06:24    | F35-39   | 02:54:11     | 733              |
 *-----------------+-------------+----------+--------------+------------------*/
```

### `LAG`

```zetasql
LAG (value_expression[, offset [, default_expression]])
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  ORDER BY expression [ { ASC | DESC }  ] [, ...]

```

**Description**

Returns the value of the `value_expression` on a preceding row. Changing the
`offset` value changes which preceding row is returned; the default value is
`1`, indicating the previous row in the window frame. An error occurs if
`offset` is NULL or a negative value.

The optional `default_expression` is used if there isn't a row in the window
frame at the specified offset. This expression must be a constant expression and
its type must be implicitly coercible to the type of `value_expression`. If left
unspecified, `default_expression` defaults to NULL.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

+ `value_expression` can be any data type that can be returned from an
  expression.
+ `offset` must be a non-negative integer literal or parameter.
+ `default_expression` must be compatible with the value expression type.

**Return Data Type**

Same type as `value_expression`.

**Examples**

The following example illustrates a basic use of the `LAG` function.

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'
  UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'
  UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')
SELECT name,
  finish_time,
  division,
  LAG(name)
    OVER (PARTITION BY division ORDER BY finish_time ASC) AS preceding_runner
FROM finishers;

/*-----------------+-------------+----------+------------------*
 | name            | finish_time | division | preceding_runner |
 +-----------------+-------------+----------+------------------+
 | Carly Forte     | 03:08:58    | F25-29   | NULL             |
 | Sophia Liu      | 02:51:45    | F30-34   | NULL             |
 | Nikki Leith     | 02:59:01    | F30-34   | Sophia Liu       |
 | Jen Edwards     | 03:06:36    | F30-34   | Nikki Leith      |
 | Meghan Lederer  | 03:07:41    | F30-34   | Jen Edwards      |
 | Lauren Reasoner | 03:10:14    | F30-34   | Meghan Lederer   |
 | Lisa Stelzner   | 02:54:11    | F35-39   | NULL             |
 | Lauren Matthews | 03:01:17    | F35-39   | Lisa Stelzner    |
 | Desiree Berry   | 03:05:42    | F35-39   | Lauren Matthews  |
 | Suzy Slane      | 03:06:24    | F35-39   | Desiree Berry    |
 *-----------------+-------------+----------+------------------*/
```

This next example uses the optional `offset` parameter.

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'
  UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'
  UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')
SELECT name,
  finish_time,
  division,
  LAG(name, 2)
    OVER (PARTITION BY division ORDER BY finish_time ASC) AS two_runners_ahead
FROM finishers;

/*-----------------+-------------+----------+-------------------*
 | name            | finish_time | division | two_runners_ahead |
 +-----------------+-------------+----------+-------------------+
 | Carly Forte     | 03:08:58    | F25-29   | NULL              |
 | Sophia Liu      | 02:51:45    | F30-34   | NULL              |
 | Nikki Leith     | 02:59:01    | F30-34   | NULL              |
 | Jen Edwards     | 03:06:36    | F30-34   | Sophia Liu        |
 | Meghan Lederer  | 03:07:41    | F30-34   | Nikki Leith       |
 | Lauren Reasoner | 03:10:14    | F30-34   | Jen Edwards       |
 | Lisa Stelzner   | 02:54:11    | F35-39   | NULL              |
 | Lauren Matthews | 03:01:17    | F35-39   | NULL              |
 | Desiree Berry   | 03:05:42    | F35-39   | Lisa Stelzner     |
 | Suzy Slane      | 03:06:24    | F35-39   | Lauren Matthews   |
 *-----------------+-------------+----------+-------------------*/
```

The following example replaces NULL values with a default value.

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'
  UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'
  UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')
SELECT name,
  finish_time,
  division,
  LAG(name, 2, 'Nobody')
    OVER (PARTITION BY division ORDER BY finish_time ASC) AS two_runners_ahead
FROM finishers;

/*-----------------+-------------+----------+-------------------*
 | name            | finish_time | division | two_runners_ahead |
 +-----------------+-------------+----------+-------------------+
 | Carly Forte     | 03:08:58    | F25-29   | Nobody            |
 | Sophia Liu      | 02:51:45    | F30-34   | Nobody            |
 | Nikki Leith     | 02:59:01    | F30-34   | Nobody            |
 | Jen Edwards     | 03:06:36    | F30-34   | Sophia Liu        |
 | Meghan Lederer  | 03:07:41    | F30-34   | Nikki Leith       |
 | Lauren Reasoner | 03:10:14    | F30-34   | Jen Edwards       |
 | Lisa Stelzner   | 02:54:11    | F35-39   | Nobody            |
 | Lauren Matthews | 03:01:17    | F35-39   | Nobody            |
 | Desiree Berry   | 03:05:42    | F35-39   | Lisa Stelzner     |
 | Suzy Slane      | 03:06:24    | F35-39   | Lauren Matthews   |
 *-----------------+-------------+----------+-------------------*/
```

### `LAST_VALUE`

```zetasql
LAST_VALUE (value_expression [{RESPECT | IGNORE} NULLS])
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  ORDER BY expression [ { ASC | DESC }  ] [, ...]
  [ window_frame_clause ]

```

**Description**

Returns the value of the `value_expression` for the last row in the current
window frame.

This function includes `NULL` values in the calculation unless `IGNORE NULLS` is
present. If `IGNORE NULLS` is present, the function excludes `NULL` values from
the calculation.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

`value_expression` can be any data type that an expression can return.

**Return Data Type**

Same type as `value_expression`.

**Examples**

The following example computes the slowest time for each division.

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'
  UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'
  UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')
SELECT name,
  FORMAT_TIMESTAMP('%X', finish_time) AS finish_time,
  division,
  FORMAT_TIMESTAMP('%X', slowest_time) AS slowest_time,
  TIMESTAMP_DIFF(slowest_time, finish_time, SECOND) AS delta_in_seconds
FROM (
  SELECT name,
  finish_time,
  division,
  LAST_VALUE(finish_time)
    OVER (PARTITION BY division ORDER BY finish_time ASC
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS slowest_time
  FROM finishers);

/*-----------------+-------------+----------+--------------+------------------*
 | name            | finish_time | division | slowest_time | delta_in_seconds |
 +-----------------+-------------+----------+--------------+------------------+
 | Carly Forte     | 03:08:58    | F25-29   | 03:08:58     | 0                |
 | Sophia Liu      | 02:51:45    | F30-34   | 03:10:14     | 1109             |
 | Nikki Leith     | 02:59:01    | F30-34   | 03:10:14     | 673              |
 | Jen Edwards     | 03:06:36    | F30-34   | 03:10:14     | 218              |
 | Meghan Lederer  | 03:07:41    | F30-34   | 03:10:14     | 153              |
 | Lauren Reasoner | 03:10:14    | F30-34   | 03:10:14     | 0                |
 | Lisa Stelzner   | 02:54:11    | F35-39   | 03:06:24     | 733              |
 | Lauren Matthews | 03:01:17    | F35-39   | 03:06:24     | 307              |
 | Desiree Berry   | 03:05:42    | F35-39   | 03:06:24     | 42               |
 | Suzy Slane      | 03:06:24    | F35-39   | 03:06:24     | 0                |
 *-----------------+-------------+----------+--------------+------------------*/
```

### `LEAD`

```zetasql
LEAD (value_expression[, offset [, default_expression]])
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  ORDER BY expression [ { ASC | DESC }  ] [, ...]

```

**Description**

Returns the value of the `value_expression` on a subsequent row. Changing the
`offset` value changes which subsequent row is returned; the default value is
`1`, indicating the next row in the window frame. An error occurs if `offset` is
NULL or a negative value.

The optional `default_expression` is used if there isn't a row in the window
frame at the specified offset. This expression must be a constant expression and
its type must be implicitly coercible to the type of `value_expression`. If left
unspecified, `default_expression` defaults to NULL.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

+ `value_expression` can be any data type that can be returned from an
  expression.
+ `offset` must be a non-negative integer literal or parameter.
+ `default_expression` must be compatible with the value expression type.

**Return Data Type**

Same type as `value_expression`.

**Examples**

The following example illustrates a basic use of the `LEAD` function.

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'
  UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'
  UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')
SELECT name,
  finish_time,
  division,
  LEAD(name)
    OVER (PARTITION BY division ORDER BY finish_time ASC) AS followed_by
FROM finishers;

/*-----------------+-------------+----------+-----------------*
 | name            | finish_time | division | followed_by     |
 +-----------------+-------------+----------+-----------------+
 | Carly Forte     | 03:08:58    | F25-29   | NULL            |
 | Sophia Liu      | 02:51:45    | F30-34   | Nikki Leith     |
 | Nikki Leith     | 02:59:01    | F30-34   | Jen Edwards     |
 | Jen Edwards     | 03:06:36    | F30-34   | Meghan Lederer  |
 | Meghan Lederer  | 03:07:41    | F30-34   | Lauren Reasoner |
 | Lauren Reasoner | 03:10:14    | F30-34   | NULL            |
 | Lisa Stelzner   | 02:54:11    | F35-39   | Lauren Matthews |
 | Lauren Matthews | 03:01:17    | F35-39   | Desiree Berry   |
 | Desiree Berry   | 03:05:42    | F35-39   | Suzy Slane      |
 | Suzy Slane      | 03:06:24    | F35-39   | NULL            |
 *-----------------+-------------+----------+-----------------*/
```

This next example uses the optional `offset` parameter.

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'
  UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'
  UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')
SELECT name,
  finish_time,
  division,
  LEAD(name, 2)
    OVER (PARTITION BY division ORDER BY finish_time ASC) AS two_runners_back
FROM finishers;

/*-----------------+-------------+----------+------------------*
 | name            | finish_time | division | two_runners_back |
 +-----------------+-------------+----------+------------------+
 | Carly Forte     | 03:08:58    | F25-29   | NULL             |
 | Sophia Liu      | 02:51:45    | F30-34   | Jen Edwards      |
 | Nikki Leith     | 02:59:01    | F30-34   | Meghan Lederer   |
 | Jen Edwards     | 03:06:36    | F30-34   | Lauren Reasoner  |
 | Meghan Lederer  | 03:07:41    | F30-34   | NULL             |
 | Lauren Reasoner | 03:10:14    | F30-34   | NULL             |
 | Lisa Stelzner   | 02:54:11    | F35-39   | Desiree Berry    |
 | Lauren Matthews | 03:01:17    | F35-39   | Suzy Slane       |
 | Desiree Berry   | 03:05:42    | F35-39   | NULL             |
 | Suzy Slane      | 03:06:24    | F35-39   | NULL             |
 *-----------------+-------------+----------+------------------*/
```

The following example replaces NULL values with a default value.

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'
  UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'
  UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')
SELECT name,
  finish_time,
  division,
  LEAD(name, 2, 'Nobody')
    OVER (PARTITION BY division ORDER BY finish_time ASC) AS two_runners_back
FROM finishers;

/*-----------------+-------------+----------+------------------*
 | name            | finish_time | division | two_runners_back |
 +-----------------+-------------+----------+------------------+
 | Carly Forte     | 03:08:58    | F25-29   | Nobody           |
 | Sophia Liu      | 02:51:45    | F30-34   | Jen Edwards      |
 | Nikki Leith     | 02:59:01    | F30-34   | Meghan Lederer   |
 | Jen Edwards     | 03:06:36    | F30-34   | Lauren Reasoner  |
 | Meghan Lederer  | 03:07:41    | F30-34   | Nobody           |
 | Lauren Reasoner | 03:10:14    | F30-34   | Nobody           |
 | Lisa Stelzner   | 02:54:11    | F35-39   | Desiree Berry    |
 | Lauren Matthews | 03:01:17    | F35-39   | Suzy Slane       |
 | Desiree Berry   | 03:05:42    | F35-39   | Nobody           |
 | Suzy Slane      | 03:06:24    | F35-39   | Nobody           |
 *-----------------+-------------+----------+------------------*/
```

### `NTH_VALUE`

```zetasql
NTH_VALUE (value_expression, constant_integer_expression [{RESPECT | IGNORE} NULLS])
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  ORDER BY expression [ { ASC | DESC }  ] [, ...]
  [ window_frame_clause ]

```

**Description**

Returns the value of `value_expression` at the Nth row of the current window
frame, where Nth is defined by `constant_integer_expression`. Returns NULL if
there is no such row.

This function includes `NULL` values in the calculation unless `IGNORE NULLS` is
present. If `IGNORE NULLS` is present, the function excludes `NULL` values from
the calculation.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

+ `value_expression` can be any data type that can be returned from an
  expression.
+ `constant_integer_expression` can be any constant expression that returns an
  integer.

**Return Data Type**

Same type as `value_expression`.

**Examples**

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'
  UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'
  UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')
SELECT name,
  FORMAT_TIMESTAMP('%X', finish_time) AS finish_time,
  division,
  FORMAT_TIMESTAMP('%X', fastest_time) AS fastest_time,
  FORMAT_TIMESTAMP('%X', second_fastest) AS second_fastest
FROM (
  SELECT name,
  finish_time,
  division,finishers,
  FIRST_VALUE(finish_time)
    OVER w1 AS fastest_time,
  NTH_VALUE(finish_time, 2)
    OVER w1 as second_fastest
  FROM finishers
  WINDOW w1 AS (
    PARTITION BY division ORDER BY finish_time ASC
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING));

/*-----------------+-------------+----------+--------------+----------------*
 | name            | finish_time | division | fastest_time | second_fastest |
 +-----------------+-------------+----------+--------------+----------------+
 | Carly Forte     | 03:08:58    | F25-29   | 03:08:58     | NULL           |
 | Sophia Liu      | 02:51:45    | F30-34   | 02:51:45     | 02:59:01       |
 | Nikki Leith     | 02:59:01    | F30-34   | 02:51:45     | 02:59:01       |
 | Jen Edwards     | 03:06:36    | F30-34   | 02:51:45     | 02:59:01       |
 | Meghan Lederer  | 03:07:41    | F30-34   | 02:51:45     | 02:59:01       |
 | Lauren Reasoner | 03:10:14    | F30-34   | 02:51:45     | 02:59:01       |
 | Lisa Stelzner   | 02:54:11    | F35-39   | 02:54:11     | 03:01:17       |
 | Lauren Matthews | 03:01:17    | F35-39   | 02:54:11     | 03:01:17       |
 | Desiree Berry   | 03:05:42    | F35-39   | 02:54:11     | 03:01:17       |
 | Suzy Slane      | 03:06:24    | F35-39   | 02:54:11     | 03:01:17       |
 *-----------------+-------------+----------+--------------+----------------*/
```

### `PERCENTILE_CONT`

```zetasql
PERCENTILE_CONT (value_expression, percentile [{RESPECT | IGNORE} NULLS])
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]

```

**Description**

Computes the specified percentile value for the value_expression, with linear
interpolation.

This function ignores NULL
values if
`RESPECT NULLS` is absent. If `RESPECT NULLS` is present:

+ Interpolation between two `NULL` values returns `NULL`.
+ Interpolation between a `NULL` value and a non-`NULL` value returns the
  non-`NULL` value.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

`PERCENTILE_CONT` can be used with differential privacy. To learn more, see
[Differentially private aggregate functions][dp-functions].

**Supported Argument Types**

+ `value_expression` and `percentile` must have one of the following types:
   + `NUMERIC`
   + `BIGNUMERIC`
   + `DOUBLE`
+ `percentile` must be a literal in the range `[0, 1]`.

**Return Data Type**

The return data type is determined by the argument types with the following
table.
<table>

<thead>
<tr>
<th>INPUT</th><th><code>NUMERIC</code></th><th><code>BIGNUMERIC</code></th><th><code>DOUBLE</code></th>
</tr>
</thead>
<tbody>
<tr><th><code>NUMERIC</code></th><td style="vertical-align:middle"><code>NUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>BIGNUMERIC</code></th><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>BIGNUMERIC</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
<tr><th><code>DOUBLE</code></th><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td><td style="vertical-align:middle"><code>DOUBLE</code></td></tr>
</tbody>

</table>

**Examples**

The following example computes the value for some percentiles from a column of
values while ignoring nulls.

```zetasql
SELECT
  PERCENTILE_CONT(x, 0) OVER() AS min,
  PERCENTILE_CONT(x, 0.01) OVER() AS percentile1,
  PERCENTILE_CONT(x, 0.5) OVER() AS median,
  PERCENTILE_CONT(x, 0.9) OVER() AS percentile90,
  PERCENTILE_CONT(x, 1) OVER() AS max
FROM UNNEST([0, 3, NULL, 1, 2]) AS x LIMIT 1;

 /*-----+-------------+--------+--------------+-----*
  | min | percentile1 | median | percentile90 | max |
  +-----+-------------+--------+--------------+-----+
  | 0   | 0.03        | 1.5    | 2.7          | 3   |
  *-----+-------------+--------+--------------+-----*/
```

The following example computes the value for some percentiles from a column of
values while respecting nulls.

```zetasql
SELECT
  PERCENTILE_CONT(x, 0 RESPECT NULLS) OVER() AS min,
  PERCENTILE_CONT(x, 0.01 RESPECT NULLS) OVER() AS percentile1,
  PERCENTILE_CONT(x, 0.5 RESPECT NULLS) OVER() AS median,
  PERCENTILE_CONT(x, 0.9 RESPECT NULLS) OVER() AS percentile90,
  PERCENTILE_CONT(x, 1 RESPECT NULLS) OVER() AS max
FROM UNNEST([0, 3, NULL, 1, 2]) AS x LIMIT 1;

/*------+-------------+--------+--------------+-----*
 | min  | percentile1 | median | percentile90 | max |
 +------+-------------+--------+--------------+-----+
 | NULL | 0           | 1      | 2.6          | 3   |
 *------+-------------+--------+--------------+-----*/
```

[dp-functions]: #aggregate-dp-functions

### `PERCENTILE_DISC`

```zetasql
PERCENTILE_DISC (value_expression, percentile [{RESPECT | IGNORE} NULLS])
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]

```

**Description**

Computes the specified percentile value for a discrete `value_expression`. The
returned value is the first sorted value of `value_expression` with cumulative
distribution greater than or equal to the given `percentile` value.

This function ignores `NULL`
values unless
`RESPECT NULLS` is present.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Supported Argument Types**

+ `value_expression` can be any orderable type.
+ `percentile` must be a literal in the range `[0, 1]`, with one of the
  following types:
   + `NUMERIC`
   + `BIGNUMERIC`
   + `DOUBLE`

**Return Data Type**

Same type as `value_expression`.

**Examples**

The following example computes the value for some percentiles from a column of
values while ignoring nulls.

```zetasql
SELECT
  x,
  PERCENTILE_DISC(x, 0) OVER() AS min,
  PERCENTILE_DISC(x, 0.5) OVER() AS median,
  PERCENTILE_DISC(x, 1) OVER() AS max
FROM UNNEST(['c', NULL, 'b', 'a']) AS x;

/*------+-----+--------+-----*
 | x    | min | median | max |
 +------+-----+--------+-----+
 | c    | a   | b      | c   |
 | NULL | a   | b      | c   |
 | b    | a   | b      | c   |
 | a    | a   | b      | c   |
 *------+-----+--------+-----*/
```

The following example computes the value for some percentiles from a column of
values while respecting nulls.

```zetasql
SELECT
  x,
  PERCENTILE_DISC(x, 0 RESPECT NULLS) OVER() AS min,
  PERCENTILE_DISC(x, 0.5 RESPECT NULLS) OVER() AS median,
  PERCENTILE_DISC(x, 1 RESPECT NULLS) OVER() AS max
FROM UNNEST(['c', NULL, 'b', 'a']) AS x;

/*------+------+--------+-----*
 | x    | min  | median | max |
 +------+------+--------+-----+
 | c    | NULL | a      | c   |
 | NULL | NULL | a      | c   |
 | b    | NULL | a      | c   |
 | a    | NULL | a      | c   |
 *------+------+--------+-----*/

```

[sketches]: https://github.com/google/zetasql/blob/master/docs/sketches.md

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

## Net functions

ZetaSQL supports the following Net functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#net_format_ip"><code>NET.FORMAT_IP</code></a>
</td>
  <td>
    (Deprecated) Converts an
    IPv4 address from an <code>INT64</code> value to a
    <code>STRING</code> value.
  </td>
</tr>

<tr>
  <td><a href="#net_format_packed_ip"><code>NET.FORMAT_PACKED_IP</code></a>
</td>
  <td>
    (Deprecated) Converts an
    IPv4 or IPv6 address from a <code>BYTES</code> value to a
    <code>STRING</code> value.
  </td>
</tr>

<tr>
  <td><a href="#nethost"><code>NET.HOST</code></a>
</td>
  <td>
   Gets the hostname from a URL.
  </td>
</tr>

<tr>
  <td><a href="#netip_from_string"><code>NET.IP_FROM_STRING</code></a>
</td>
  <td>
    Converts an IPv4 or IPv6 address from a <code>STRING</code> value to
    a <code>BYTES</code> value in network byte order.
  </td>
</tr>

<tr>
  <td><a href="#netip_in_net"><code>NET.IP_IN_NET</code></a>
</td>
  <td>
    Checks if an IP address is in a subnet.
  </td>
</tr>

<tr>
  <td><a href="#netip_net_mask"><code>NET.IP_NET_MASK</code></a>
</td>
  <td>
    Gets a network mask.
  </td>
</tr>

<tr>
  <td><a href="#netip_to_string"><code>NET.IP_TO_STRING</code></a>
</td>
  <td>
    Converts an IPv4 or IPv6 address from a <code>BYTES</code> value in
    network byte order to a <code>STRING</code> value.
  </td>
</tr>

<tr>
  <td><a href="#netip_trunc"><code>NET.IP_TRUNC</code></a>
</td>
  <td>
    Converts a <code>BYTES</code>  IPv4 or IPv6 address in
    network byte order to a <code>BYTES</code> subnet address.
  </td>
</tr>

<tr>
  <td><a href="#netipv4_from_int64"><code>NET.IPV4_FROM_INT64</code></a>
</td>
  <td>
    Converts an IPv4 address from an <code>INT64</code> value to a
    <code>BYTES</code> value in network byte order.
  </td>
</tr>

<tr>
  <td><a href="#netipv4_to_int64"><code>NET.IPV4_TO_INT64</code></a>
</td>
  <td>
    Converts an IPv4 address from a <code>BYTES</code> value in network
    byte order to an <code>INT64</code> value.
  </td>
</tr>

<tr>
  <td><a href="#netmake_net"><code>NET.MAKE_NET</code></a>
</td>
  <td>
    Takes a IPv4 or IPv6 address and the prefix length, and produces a
    CIDR subnet.
  </td>
</tr>

<tr>
  <td><a href="#net_parse_ip"><code>NET.PARSE_IP</code></a>
</td>
  <td>
    (Deprecated) Converts an
    IPv4 address from a <code>STRING</code> value to an
    <code>INT64</code> value.
  </td>
</tr>

<tr>
  <td><a href="#net_parse_packed_ip"><code>NET.PARSE_PACKED_IP</code></a>
</td>
  <td>
    (Deprecated) Converts an
    IPv4 or IPv6 address from a <code>STRING</code> value to a
    <code>BYTES</code> value.
  </td>
</tr>

<tr>
  <td><a href="#netpublic_suffix"><code>NET.PUBLIC_SUFFIX</code></a>
</td>
  <td>
    Gets the public suffix from a URL.
  </td>
</tr>

<tr>
  <td><a href="#netreg_domain"><code>NET.REG_DOMAIN</code></a>
</td>
  <td>
    Gets the registered or registrable domain from a URL.
  </td>
</tr>

<tr>
  <td><a href="#netsafe_ip_from_string"><code>NET.SAFE_IP_FROM_STRING</code></a>
</td>
  <td>
    Similar to the <code>NET.IP_FROM_STRING</code>, but returns
    <code>NULL</code> instead of producing an error if the input is invalid.
  </td>
</tr>

  </tbody>
</table>

### `NET.FORMAT_IP` (DEPRECATED) 
<a id="net_format_ip"></a>

```
NET.FORMAT_IP(integer)
```

**Description**

This function is deprecated. It's the same as
[`NET.IP_TO_STRING`][net-link-to-ip-to-string]`(`[`NET.IPV4_FROM_INT64`][net-link-to-ipv4-from-int64]`(integer))`,
except that this function doesn't allow negative input values.

**Return Data Type**

STRING

[net-link-to-ip-to-string]: #netip_to_string

[net-link-to-ipv4-from-int64]: #netipv4_from_int64

### `NET.FORMAT_PACKED_IP` (DEPRECATED) 
<a id="net_format_packed_ip"></a>

```
NET.FORMAT_PACKED_IP(bytes_value)
```

**Description**

This function is deprecated. It's the same as [`NET.IP_TO_STRING`][net-link-to-ip-to-string].

**Return Data Type**

STRING

[net-link-to-ip-to-string]: #netip_to_string

### `NET.HOST`

```
NET.HOST(url)
```

**Description**

Takes a URL as a `STRING` value and returns the host. For best results, URL
values should comply with the format as defined by
[RFC 3986][net-link-to-rfc-3986-appendix-a]. If the URL value doesn't comply
with RFC 3986 formatting, this function makes a best effort to parse the input
and return a relevant result. If the function can't parse the input, it
returns `NULL`.

Note: The function doesn't perform any normalization.

**Return Data Type**

`STRING`

**Example**

```zetasql
SELECT
  FORMAT("%T", input) AS input,
  description,
  FORMAT("%T", NET.HOST(input)) AS host,
  FORMAT("%T", NET.PUBLIC_SUFFIX(input)) AS suffix,
  FORMAT("%T", NET.REG_DOMAIN(input)) AS domain
FROM (
  SELECT "" AS input, "invalid input" AS description
  UNION ALL SELECT "http://abc.xyz", "standard URL"
  UNION ALL SELECT "//user:password@a.b:80/path?query",
                   "standard URL with relative scheme, port, path and query, but no public suffix"
  UNION ALL SELECT "https://[::1]:80", "standard URL with IPv6 host"
  UNION ALL SELECT "http://..", "standard URL with internationalized domain name"
  UNION ALL SELECT "    www.Example.Co.UK    ",
                   "non-standard URL with spaces, upper case letters, and without scheme"
  UNION ALL SELECT "mailto:?to=&subject=&body=", "URI rather than URL--unsupported"
);
```

| input                                                               | description                                                                   | host               | suffix  | domain         |
|---------------------------------------------------------------------|-------------------------------------------------------------------------------|--------------------|---------|----------------|
| ""                                                                  | invalid input                                                                 | NULL               | NULL    | NULL           |
| "http://abc.xyz"                                                    | standard URL                                                                  | "abc.xyz"          | "xyz"   | "abc.xyz"      |
| "//user:password@a.b:80/path?query"                                 | standard URL with relative scheme, port, path and query, but no public suffix | "a.b"              | NULL    | NULL           |
| "https://[::1]:80"                                                  | standard URL with IPv6 host                                                   | "[::1]"            | NULL    | NULL           |
| "http://.."                                              | standard URL with internationalized domain name                               | ".."    | ""  | "."    |
| "&nbsp;&nbsp;&nbsp;&nbsp;www.Example.Co.UK&nbsp;&nbsp;&nbsp;&nbsp;" | non-standard URL with spaces, upper case letters, and without scheme          | "www.Example.Co.UK"| "Co.UK" | "Example.Co.UK"|
| "mailto:?to=&subject=&body="                                        | URI rather than URL--unsupported                                              | "mailto"           | NULL    | NULL           |

[net-link-to-rfc-3986-appendix-a]: https://tools.ietf.org/html/rfc3986#appendix-A

### `NET.IP_FROM_STRING`

```
NET.IP_FROM_STRING(addr_str)
```

**Description**

Converts an IPv4 or IPv6 address from text (STRING) format to binary (BYTES)
format in network byte order.

This function supports the following formats for `addr_str`:

+ IPv4: Dotted-quad format. For example, `10.1.2.3`.
+ IPv6: Colon-separated format. For example,
  `1234:5678:90ab:cdef:1234:5678:90ab:cdef`. For more examples, see the
  [IP Version 6 Addressing Architecture][net-link-to-ipv6-rfc].

This function doesn't support [CIDR notation][net-link-to-cidr-notation], such as `10.1.2.3/32`.

If this function receives a `NULL` input, it returns `NULL`. If the input is
considered invalid, an `OUT_OF_RANGE` error occurs.

**Return Data Type**

BYTES

**Example**

```zetasql
SELECT
  addr_str, FORMAT("%T", NET.IP_FROM_STRING(addr_str)) AS ip_from_string
FROM UNNEST([
  '48.49.50.51',
  '::1',
  '3031:3233:3435:3637:3839:4041:4243:4445',
  '::ffff:192.0.2.128'
]) AS addr_str;

/*---------------------------------------------------------------------------------------------------------------*
 | addr_str                                | ip_from_string                                                      |
 +---------------------------------------------------------------------------------------------------------------+
 | 48.49.50.51                             | b"0123"                                                             |
 | ::1                                     | b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01" |
 | 3031:3233:3435:3637:3839:4041:4243:4445 | b"0123456789@ABCDE"                                                 |
 | ::ffff:192.0.2.128                      | b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xc0\x00\x02\x80" |
 *---------------------------------------------------------------------------------------------------------------*/
```

[net-link-to-ipv6-rfc]: http://www.ietf.org/rfc/rfc2373.txt

[net-link-to-cidr-notation]: https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing

### `NET.IP_IN_NET`

```
NET.IP_IN_NET(address, subnet)
```

**Description**

Takes an IP address and a subnet CIDR as STRING and returns true if the IP
address is contained in the subnet.

This function supports the following formats for `address` and `subnet`:

+ IPv4: Dotted-quad format. For example, `10.1.2.3`.
+ IPv6: Colon-separated format. For example,
  `1234:5678:90ab:cdef:1234:5678:90ab:cdef`. For more examples, see the
  [IP Version 6 Addressing Architecture][net-link-to-ipv6-rfc].
+ CIDR (IPv4): Dotted-quad format. For example, `10.1.2.0/24`
+ CIDR (IPv6): Colon-separated format. For example, `1:2::/48`.

If this function receives a `NULL` input, it returns `NULL`. If the input is
considered invalid, an `OUT_OF_RANGE` error occurs.

**Return Data Type**

BOOL

[net-link-to-ipv6-rfc]: http://www.ietf.org/rfc/rfc2373.txt

### `NET.IP_NET_MASK`

```
NET.IP_NET_MASK(num_output_bytes, prefix_length)
```

**Description**

Returns a network mask: a byte sequence with length equal to `num_output_bytes`,
where the first `prefix_length` bits are set to 1 and the other bits are set to
0. `num_output_bytes` and `prefix_length` are INT64.
This function throws an error if `num_output_bytes` isn't 4 (for IPv4) or 16
(for IPv6). It also throws an error if `prefix_length` is negative or greater
than `8 * num_output_bytes`.

**Return Data Type**

BYTES

**Example**

```zetasql
SELECT x, y, FORMAT("%T", NET.IP_NET_MASK(x, y)) AS ip_net_mask
FROM UNNEST([
  STRUCT(4 as x, 0 as y),
  (4, 20),
  (4, 32),
  (16, 0),
  (16, 1),
  (16, 128)
]);

/*--------------------------------------------------------------------------------*
 | x  | y   | ip_net_mask                                                         |
 +--------------------------------------------------------------------------------+
 | 4  | 0   | b"\x00\x00\x00\x00"                                                 |
 | 4  | 20  | b"\xff\xff\xf0\x00"                                                 |
 | 4  | 32  | b"\xff\xff\xff\xff"                                                 |
 | 16 | 0   | b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" |
 | 16 | 1   | b"\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" |
 | 16 | 128 | b"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff" |
 *--------------------------------------------------------------------------------*/
```

### `NET.IP_TO_STRING`

```
NET.IP_TO_STRING(addr_bin)
```

**Description**
Converts an IPv4 or IPv6 address from binary (BYTES) format in network byte
order to text (STRING) format.

If the input is 4 bytes, this function returns an IPv4 address as a STRING. If
the input is 16 bytes, it returns an IPv6 address as a STRING.

If this function receives a `NULL` input, it returns `NULL`. If the input has
a length different from 4 or 16, an `OUT_OF_RANGE` error occurs.

**Return Data Type**

STRING

**Example**

```zetasql
SELECT FORMAT("%T", x) AS addr_bin, NET.IP_TO_STRING(x) AS ip_to_string
FROM UNNEST([
  b"0123",
  b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
  b"0123456789@ABCDE",
  b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xc0\x00\x02\x80"
]) AS x;

/*---------------------------------------------------------------------------------------------------------------*
 | addr_bin                                                            | ip_to_string                            |
 +---------------------------------------------------------------------------------------------------------------+
 | b"0123"                                                             | 48.49.50.51                             |
 | b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01" | ::1                                     |
 | b"0123456789@ABCDE"                                                 | 3031:3233:3435:3637:3839:4041:4243:4445 |
 | b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xc0\x00\x02\x80" | ::ffff:192.0.2.128                      |
 *---------------------------------------------------------------------------------------------------------------*/
```

### `NET.IP_TRUNC`

```
NET.IP_TRUNC(addr_bin, prefix_length)
```

**Description**
Takes `addr_bin`, an IPv4 or IPv6 address in binary (BYTES) format in network
byte order, and returns a subnet address in the same format. The result has the
same length as `addr_bin`, where the first `prefix_length` bits are equal to
those in `addr_bin` and the remaining bits are 0.

This function throws an error if `LENGTH(addr_bin)` isn't 4 or 16, or if
`prefix_len` is negative or greater than `LENGTH(addr_bin) * 8`.

**Return Data Type**

BYTES

**Example**

```zetasql
SELECT
  FORMAT("%T", x) as addr_bin, prefix_length,
  FORMAT("%T", NET.IP_TRUNC(x, prefix_length)) AS ip_trunc
FROM UNNEST([
  STRUCT(b"\xAA\xBB\xCC\xDD" as x, 0 as prefix_length),
  (b"\xAA\xBB\xCC\xDD", 11), (b"\xAA\xBB\xCC\xDD", 12),
  (b"\xAA\xBB\xCC\xDD", 24), (b"\xAA\xBB\xCC\xDD", 32),
  (b'0123456789@ABCDE', 80)
]);

/*-----------------------------------------------------------------------------*
 | addr_bin            | prefix_length | ip_trunc                              |
 +-----------------------------------------------------------------------------+
 | b"\xaa\xbb\xcc\xdd" | 0             | b"\x00\x00\x00\x00"                   |
 | b"\xaa\xbb\xcc\xdd" | 11            | b"\xaa\xa0\x00\x00"                   |
 | b"\xaa\xbb\xcc\xdd" | 12            | b"\xaa\xb0\x00\x00"                   |
 | b"\xaa\xbb\xcc\xdd" | 24            | b"\xaa\xbb\xcc\x00"                   |
 | b"\xaa\xbb\xcc\xdd" | 32            | b"\xaa\xbb\xcc\xdd"                   |
 | b"0123456789@ABCDE" | 80            | b"0123456789\x00\x00\x00\x00\x00\x00" |
 *-----------------------------------------------------------------------------*/
```

### `NET.IPV4_FROM_INT64`

```
NET.IPV4_FROM_INT64(integer_value)
```

**Description**

Converts an IPv4 address from integer format to binary (BYTES) format in network
byte order. In the integer input, the least significant bit of the IP address is
stored in the least significant bit of the integer, regardless of host or client
architecture. For example, `1` means `0.0.0.1`, and `0x1FF` means `0.0.1.255`.

This function checks that either all the most significant 32 bits are 0, or all
the most significant 33 bits are 1 (sign-extended from a 32-bit integer).
In other words, the input should be in the range `[-0x80000000, 0xFFFFFFFF]`;
otherwise, this function throws an error.

This function doesn't support IPv6.

**Return Data Type**

BYTES

**Example**

```zetasql
SELECT x, x_hex, FORMAT("%T", NET.IPV4_FROM_INT64(x)) AS ipv4_from_int64
FROM (
  SELECT CAST(x_hex AS INT64) x, x_hex
  FROM UNNEST(["0x0", "0xABCDEF", "0xFFFFFFFF", "-0x1", "-0x2"]) AS x_hex
);

/*-----------------------------------------------*
 | x          | x_hex      | ipv4_from_int64     |
 +-----------------------------------------------+
 | 0          | 0x0        | b"\x00\x00\x00\x00" |
 | 11259375   | 0xABCDEF   | b"\x00\xab\xcd\xef" |
 | 4294967295 | 0xFFFFFFFF | b"\xff\xff\xff\xff" |
 | -1         | -0x1       | b"\xff\xff\xff\xff" |
 | -2         | -0x2       | b"\xff\xff\xff\xfe" |
 *-----------------------------------------------*/
```

### `NET.IPV4_TO_INT64`

```
NET.IPV4_TO_INT64(addr_bin)
```

**Description**

Converts an IPv4 address from binary (BYTES) format in network byte order to
integer format. In the integer output, the least significant bit of the IP
address is stored in the least significant bit of the integer, regardless of
host or client architecture. For example, `1` means `0.0.0.1`, and `0x1FF` means
`0.0.1.255`. The output is in the range `[0, 0xFFFFFFFF]`.

If the input length isn't 4, this function throws an error.

This function doesn't support IPv6.

**Return Data Type**

INT64

**Example**

```zetasql
SELECT
  FORMAT("%T", x) AS addr_bin,
  FORMAT("0x%X", NET.IPV4_TO_INT64(x)) AS ipv4_to_int64
FROM
UNNEST([b"\x00\x00\x00\x00", b"\x00\xab\xcd\xef", b"\xff\xff\xff\xff"]) AS x;

/*-------------------------------------*
 | addr_bin            | ipv4_to_int64 |
 +-------------------------------------+
 | b"\x00\x00\x00\x00" | 0x0           |
 | b"\x00\xab\xcd\xef" | 0xABCDEF      |
 | b"\xff\xff\xff\xff" | 0xFFFFFFFF    |
 *-------------------------------------*/
```

### `NET.MAKE_NET`

```
NET.MAKE_NET(address, prefix_length)
```

**Description**

Takes an IPv4 or IPv6 address as STRING and an integer representing the prefix
length (the number of leading 1-bits in the network mask). Returns a
STRING representing the [CIDR subnet][net-link-to-cidr-notation] with the given prefix length.

The value of `prefix_length` must be greater than or equal to 0. A smaller value
means a bigger subnet, covering more IP addresses. The result CIDR subnet must
be no smaller than `address`, meaning that the value of `prefix_length` must be
less than or equal to the prefix length in `address`. See the effective upper
bound below.

This function supports the following formats for `address`:

+ IPv4: Dotted-quad format, such as `10.1.2.3`. The value of `prefix_length`
  must be less than or equal to 32.
+ IPv6: Colon-separated format, such as
  `1234:5678:90ab:cdef:1234:5678:90ab:cdef`. The value of `prefix_length` must
  be less than or equal to 128.
+ CIDR (IPv4): Dotted-quad format, such as `10.1.2.0/24`.
  The value of `prefix_length` must be less than or equal to the number after
  the slash in `address` (24 in the example), which must be less than or equal
  to 32.
+ CIDR (IPv6): Colon-separated format, such as `1:2::/48`.
  The value of `prefix_length` must be less than or equal to the number after
  the slash in `address` (48 in the example), which must be less than or equal
  to 128.

If this function receives a `NULL` input, it returns `NULL`. If the input is
considered invalid, an `OUT_OF_RANGE` error occurs.

**Return Data Type**

STRING

[net-link-to-cidr-notation]: https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing

### `NET.PARSE_IP` (DEPRECATED) 
<a id="net_parse_ip"></a>

```
NET.PARSE_IP(addr_str)
```

**Description**

This function is deprecated. It's the same as
[`NET.IPV4_TO_INT64`][net-link-to-ipv4-to-int64]`(`[`NET.IP_FROM_STRING`][net-link-to-ip-from-string]`(addr_str))`,
except that this function truncates the input at the first `'\x00'` character,
if any, while `NET.IP_FROM_STRING` treats `'\x00'` as invalid.

**Return Data Type**

INT64

[net-link-to-ip-to-string]: #netip_to_string

[net-link-to-ipv4-to-int64]: #netipv4_to_int64

### `NET.PARSE_PACKED_IP` (DEPRECATED) 
<a id="net_parse_packed_ip"></a>

```
NET.PARSE_PACKED_IP(addr_str)
```

**Description**

This function is deprecated. It's the same as
[`NET.IP_FROM_STRING`][net-link-to-ip-from-string], except that this function truncates
the input at the first `'\x00'` character, if any, while `NET.IP_FROM_STRING`
treats `'\x00'` as invalid.

**Return Data Type**

BYTES

[net-link-to-ip-from-string]: #netip_from_string

### `NET.PUBLIC_SUFFIX`

```
NET.PUBLIC_SUFFIX(url)
```

**Description**

Takes a URL as a `STRING` value and returns the public suffix (such as `com`,
`org`, or `net`). A public suffix is an ICANN domain registered at
[publicsuffix.org][net-link-to-public-suffix]. For best results, URL values
should comply with the format as defined by
[RFC 3986][net-link-to-rfc-3986-appendix-a]. If the URL value doesn't comply
with RFC 3986 formatting, this function makes a best effort to parse the input
and return a relevant result.

This function returns `NULL` if any of the following is true:

+ It can't parse the host from the input;
+ The parsed host contains adjacent dots in the middle
  (not leading or trailing);
+ The parsed host doesn't contain any public suffix.

Before looking up the public suffix, this function temporarily normalizes the
host by converting uppercase English letters to lowercase and encoding all
non-ASCII characters with [Punycode][net-link-to-punycode].
The function then returns the public suffix as part of the original host instead
of the normalized host.

Note: The function doesn't perform
[Unicode normalization][unicode-normalization].

Note: The public suffix data at
[publicsuffix.org][net-link-to-public-suffix] also contains
private domains. This function ignores the private domains.

Note: The public suffix data may change over time. Consequently, input that
produces a `NULL` result now may produce a non-`NULL` value in the future.

**Return Data Type**

`STRING`

**Example**

```zetasql
SELECT
  FORMAT("%T", input) AS input,
  description,
  FORMAT("%T", NET.HOST(input)) AS host,
  FORMAT("%T", NET.PUBLIC_SUFFIX(input)) AS suffix,
  FORMAT("%T", NET.REG_DOMAIN(input)) AS domain
FROM (
  SELECT "" AS input, "invalid input" AS description
  UNION ALL SELECT "http://abc.xyz", "standard URL"
  UNION ALL SELECT "//user:password@a.b:80/path?query",
                   "standard URL with relative scheme, port, path and query, but no public suffix"
  UNION ALL SELECT "https://[::1]:80", "standard URL with IPv6 host"
  UNION ALL SELECT "http://..", "standard URL with internationalized domain name"
  UNION ALL SELECT "    www.Example.Co.UK    ",
                   "non-standard URL with spaces, upper case letters, and without scheme"
  UNION ALL SELECT "mailto:?to=&subject=&body=", "URI rather than URL--unsupported"
);
```

| input                                                              | description                                                                   | host               | suffix  | domain         |
|--------------------------------------------------------------------|-------------------------------------------------------------------------------|--------------------|---------|----------------|
| ""                                                                 | invalid input                                                                 | NULL               | NULL    | NULL           |
| "http://abc.xyz"                                                   | standard URL                                                                  | "abc.xyz"          | "xyz"   | "abc.xyz"      |
| "//user:password@a.b:80/path?query"                                | standard URL with relative scheme, port, path and query, but no public suffix | "a.b"              | NULL    | NULL           |
| "https://[::1]:80"                                                 | standard URL with IPv6 host                                                   | "[::1]"            | NULL    | NULL           |
| "http://.."                                            | standard URL with internationalized domain name                               | ".."    | ""  | "."     |
| "&nbsp;&nbsp;&nbsp;&nbsp;www.Example.Co.UK&nbsp;&nbsp;&nbsp;&nbsp;"| non-standard URL with spaces, upper case letters, and without scheme          | "www.Example.Co.UK"| "Co.UK" | "Example.Co.UK |
| "mailto:?to=&subject=&body="                                       | URI rather than URL--unsupported                                              | "mailto"           | NULL    | NULL           |

[unicode-normalization]: https://en.wikipedia.org/wiki/Unicode_equivalence

[net-link-to-punycode]: https://en.wikipedia.org/wiki/Punycode

[net-link-to-public-suffix]: https://publicsuffix.org/list/

[net-link-to-rfc-3986-appendix-a]: https://tools.ietf.org/html/rfc3986#appendix-A

### `NET.REG_DOMAIN`

```
NET.REG_DOMAIN(url)
```

**Description**

Takes a URL as a string and returns the registered or registrable domain (the
[public suffix](#netpublic_suffix) plus one preceding label), as a
string. For best results, URL values should comply with the format as defined by
[RFC 3986][net-link-to-rfc-3986-appendix-a]. If the URL value doesn't comply
with RFC 3986 formatting, this function makes a best effort to parse the input
and return a relevant result.

This function returns `NULL` if any of the following is true:

+ It can't parse the host from the input;
+ The parsed host contains adjacent dots in the middle
  (not leading or trailing);
+ The parsed host doesn't contain any public suffix;
+ The parsed host contains only a public suffix without any preceding label.

Before looking up the public suffix, this function temporarily normalizes the
host by converting uppercase English letters to lowercase and encoding all
non-ASCII characters with [Punycode][net-link-to-punycode]. The function then
returns the registered or registerable domain as part of the original host
instead of the normalized host.

Note: The function doesn't perform
[Unicode normalization][unicode-normalization].

Note: The public suffix data at
[publicsuffix.org][net-link-to-public-suffix] also contains
private domains. This function doesn't treat a private domain as a public
suffix. For example, if `us.com` is a private domain in the public suffix data,
`NET.REG_DOMAIN("foo.us.com")` returns `us.com` (the public suffix `com` plus
the preceding label `us`) rather than `foo.us.com` (the private domain `us.com`
plus the preceding label `foo`).

Note: The public suffix data may change over time.
Consequently, input that produces a `NULL` result now may produce a non-`NULL`
value in the future.

**Return Data Type**

`STRING`

**Example**

```zetasql
SELECT
  FORMAT("%T", input) AS input,
  description,
  FORMAT("%T", NET.HOST(input)) AS host,
  FORMAT("%T", NET.PUBLIC_SUFFIX(input)) AS suffix,
  FORMAT("%T", NET.REG_DOMAIN(input)) AS domain
FROM (
  SELECT "" AS input, "invalid input" AS description
  UNION ALL SELECT "http://abc.xyz", "standard URL"
  UNION ALL SELECT "//user:password@a.b:80/path?query",
                   "standard URL with relative scheme, port, path and query, but no public suffix"
  UNION ALL SELECT "https://[::1]:80", "standard URL with IPv6 host"
  UNION ALL SELECT "http://..", "standard URL with internationalized domain name"
  UNION ALL SELECT "    www.Example.Co.UK    ",
                   "non-standard URL with spaces, upper case letters, and without scheme"
  UNION ALL SELECT "mailto:?to=&subject=&body=", "URI rather than URL--unsupported"
);
```

| input                                                              | description                                                                   | host               | suffix  | domain         |
|--------------------------------------------------------------------|-------------------------------------------------------------------------------|--------------------|---------|----------------|
| ""                                                                 | invalid input                                                                 | NULL               | NULL    | NULL           |
| "http://abc.xyz"                                                   | standard URL                                                                  | "abc.xyz"          | "xyz"   | "abc.xyz"      |
| "//user:password@a.b:80/path?query"                                | standard URL with relative scheme, port, path and query, but no public suffix | "a.b"              | NULL    | NULL           |
| "https://[::1]:80"                                                 | standard URL with IPv6 host                                                   | "[::1]"            | NULL    | NULL           |
| "http://.."                                            | standard URL with internationalized domain name                               | ".."    | ""  | "."  |
| "&nbsp;&nbsp;&nbsp;&nbsp;www.Example.Co.UK&nbsp;&nbsp;&nbsp;&nbsp;"| non-standard URL with spaces, upper case letters, and without scheme          | "www.Example.Co.UK"| "Co.UK" | "Example.Co.UK"|
| "mailto:?to=&subject=&body="                                       | URI rather than URL--unsupported                                              | "mailto"           | NULL    | NULL           |

[unicode-normalization]: https://en.wikipedia.org/wiki/Unicode_equivalence

[net-link-to-public-suffix]: https://publicsuffix.org/list/

[net-link-to-punycode]: https://en.wikipedia.org/wiki/Punycode

[net-link-to-rfc-3986-appendix-a]: https://tools.ietf.org/html/rfc3986#appendix-A

### `NET.SAFE_IP_FROM_STRING`

```
NET.SAFE_IP_FROM_STRING(addr_str)
```

**Description**

Similar to [`NET.IP_FROM_STRING`][net-link-to-ip-from-string], but returns `NULL`
instead of throwing an error if the input is invalid.

**Return Data Type**

BYTES

**Example**

```zetasql
SELECT
  addr_str,
  FORMAT("%T", NET.SAFE_IP_FROM_STRING(addr_str)) AS safe_ip_from_string
FROM UNNEST([
  '48.49.50.51',
  '::1',
  '3031:3233:3435:3637:3839:4041:4243:4445',
  '::ffff:192.0.2.128',
  '48.49.50.51/32',
  '48.49.50',
  '::wxyz'
]) AS addr_str;

/*---------------------------------------------------------------------------------------------------------------*
 | addr_str                                | safe_ip_from_string                                                 |
 +---------------------------------------------------------------------------------------------------------------+
 | 48.49.50.51                             | b"0123"                                                             |
 | ::1                                     | b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01" |
 | 3031:3233:3435:3637:3839:4041:4243:4445 | b"0123456789@ABCDE"                                                 |
 | ::ffff:192.0.2.128                      | b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xc0\x00\x02\x80" |
 | 48.49.50.51/32                          | NULL                                                                |
 | 48.49.50                                | NULL                                                                |
 | ::wxyz                                  | NULL                                                                |
 *---------------------------------------------------------------------------------------------------------------*/
```

[net-link-to-ip-from-string]: #netip_from_string

## Numbering functions

ZetaSQL supports numbering functions.
Numbering functions are a subset of window functions. To create a
window function call and learn about the syntax for window functions,
see [Window function calls][window-function-calls].

Numbering functions assign values to each row based on their position
within the specified window. The `OVER` clause syntax varies across
numbering functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#cume_dist"><code>CUME_DIST</code></a>
</td>
  <td>
    Gets the cumulative distribution (relative position (0,1]) of each row
    within a window.
    
  </td>
</tr>

<tr>
  <td><a href="#dense_rank"><code>DENSE_RANK</code></a>
</td>
  <td>
    Gets the dense rank (1-based, no gaps) of each row within a window.
    
  </td>
</tr>

<tr>
  <td>
    
    <a href="#is_first"><code>IS_FIRST</code></a>

    
  </td>
  <td>
        Returns <code>true</code> if this row is in the first <code>k</code> rows (1-based) within the window.
    
  </td>
</tr>

<tr>
  <td><a href="#IS_LAST"><code>IS_LAST</code></a>
</td>
  <td>
        Returns <code>true</code> if this row is in the last <code>k</code> rows (1-based) within the window.
    
  </td>
</tr>

<tr>
  <td><a href="#ntile"><code>NTILE</code></a>
</td>
  <td>
    Gets the quantile bucket number (1-based) of each row within a window.
    
  </td>
</tr>

<tr>
  <td><a href="#percent_rank"><code>PERCENT_RANK</code></a>
</td>
  <td>
    Gets the percentile rank (from 0 to 1) of each row within a window.
    
  </td>
</tr>

<tr>
  <td><a href="#rank"><code>RANK</code></a>
</td>
  <td>
    Gets the rank (1-based) of each row within a window.
    
  </td>
</tr>

<tr>
  <td><a href="#row_number"><code>ROW_NUMBER</code></a>
</td>
  <td>
    Gets the sequential row number (1-based) of each row within a window.
    
  </td>
</tr>

  </tbody>
</table>

### `CUME_DIST`

```zetasql
CUME_DIST()
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  ORDER BY expression [ { ASC | DESC }  ] [, ...]

```

**Description**

Return the relative rank of a row defined as NP/NR. NP is defined to be the
number of rows that either precede or are peers with the current row. NR is the
number of rows in the partition.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Return Type**

`DOUBLE`

**Example**

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 2:59:01', 'F30-34')
SELECT name,
  finish_time,
  division,
  CUME_DIST() OVER (PARTITION BY division ORDER BY finish_time ASC) AS finish_rank
FROM finishers;

/*-----------------+------------------------+----------+-------------*
 | name            | finish_time            | division | finish_rank |
 +-----------------+------------------------+----------+-------------+
 | Sophia Liu      | 2016-10-18 09:51:45+00 | F30-34   | 0.25        |
 | Meghan Lederer  | 2016-10-18 09:59:01+00 | F30-34   | 0.75        |
 | Nikki Leith     | 2016-10-18 09:59:01+00 | F30-34   | 0.75        |
 | Jen Edwards     | 2016-10-18 10:06:36+00 | F30-34   | 1           |
 | Lisa Stelzner   | 2016-10-18 09:54:11+00 | F35-39   | 0.25        |
 | Lauren Matthews | 2016-10-18 10:01:17+00 | F35-39   | 0.5         |
 | Desiree Berry   | 2016-10-18 10:05:42+00 | F35-39   | 0.75        |
 | Suzy Slane      | 2016-10-18 10:06:24+00 | F35-39   | 1           |
 *-----------------+------------------------+----------+-------------*/
```

### `DENSE_RANK`

```zetasql
DENSE_RANK()
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  ORDER BY expression [ { ASC | DESC }  ] [, ...]

```

**Description**

Returns the ordinal (1-based) rank of each row within the window partition.
All peer rows receive the same rank value, and the subsequent rank value is
incremented by one.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Return Type**

`INT64`

**Examples**

```zetasql
WITH Numbers AS
 (SELECT 1 as x
  UNION ALL SELECT 2
  UNION ALL SELECT 2
  UNION ALL SELECT 5
  UNION ALL SELECT 8
  UNION ALL SELECT 10
  UNION ALL SELECT 10
)
SELECT x,
  DENSE_RANK() OVER (ORDER BY x ASC) AS dense_rank
FROM Numbers

/*-------------------------*
 | x          | dense_rank |
 +-------------------------+
 | 1          | 1          |
 | 2          | 2          |
 | 2          | 2          |
 | 5          | 3          |
 | 8          | 4          |
 | 10         | 5          |
 | 10         | 5          |
 *-------------------------*/
```

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 2:59:01', 'F30-34')
SELECT name,
  finish_time,
  division,
  DENSE_RANK() OVER (PARTITION BY division ORDER BY finish_time ASC) AS finish_rank
FROM finishers;

/*-----------------+------------------------+----------+-------------*
 | name            | finish_time            | division | finish_rank |
 +-----------------+------------------------+----------+-------------+
 | Sophia Liu      | 2016-10-18 09:51:45+00 | F30-34   | 1           |
 | Meghan Lederer  | 2016-10-18 09:59:01+00 | F30-34   | 2           |
 | Nikki Leith     | 2016-10-18 09:59:01+00 | F30-34   | 2           |
 | Jen Edwards     | 2016-10-18 10:06:36+00 | F30-34   | 3           |
 | Lisa Stelzner   | 2016-10-18 09:54:11+00 | F35-39   | 1           |
 | Lauren Matthews | 2016-10-18 10:01:17+00 | F35-39   | 2           |
 | Desiree Berry   | 2016-10-18 10:05:42+00 | F35-39   | 3           |
 | Suzy Slane      | 2016-10-18 10:06:24+00 | F35-39   | 4           |
 *-----------------+------------------------+----------+-------------*/
```

### `IS_FIRST`

```zetasql
IS_FIRST(k)
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]

```

**Description**

Returns `true` if the current row is in the first `k` rows (1-based) in the
window; otherwise, returns `false`. This function doesn't require the `ORDER BY`
clause.

**Details**

* The `k` value must be positive; otherwise, a runtime error is raised.
* If `k` is 0, the scenario is considered a degenerate case where the result is always `false`.
* If `k` is `NULL`, the result is `NULL`.
* Disallows the window framing clause, similar to the `ROW_NUMBER` function.
* If any rows are tied or if `ORDER BY` is omitted, the result is non-deterministic.
  If the `ORDER BY` clause is unspecified or if all rows are tied, the
  result is equivalent to `ANY-k`.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Return Type**

`BOOL`

**Examples**

```zetasql
WITH Numbers AS
 (SELECT 1 as x
  UNION ALL SELECT 2
  UNION ALL SELECT 2
  UNION ALL SELECT 5
  UNION ALL SELECT 8
  UNION ALL SELECT 10
  UNION ALL SELECT 10
)
SELECT x,
  IS_FIRST(2) OVER (ORDER BY x) AS is_first
FROM Numbers

/*-------------------------*
 | x          | is_first   |
 +-------------------------+
 | 1          | true       |
 | 2          | true       |
 | 2          | false      |
 | 5          | false      |
 | 8          | false      |
 | 10         | false      |
 | 10         | false      |
 *-------------------------*/
```

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 2:59:01', 'F30-34')
SELECT name,
  finish_time,
  division,
  IS_FIRST(2) OVER (PARTITION BY division ORDER BY finish_time ASC) AS is_first
FROM finishers;

/*-----------------+------------------------+----------+-------------*
 | name            | finish_time            | division | finish_rank |
 +-----------------+------------------------+----------+-------------+
 | Sophia Liu      | 2016-10-18 09:51:45+00 | F30-34   | true        |
 | Meghan Lederer  | 2016-10-18 09:59:01+00 | F30-34   | true        |
 | Nikki Leith     | 2016-10-18 09:59:01+00 | F30-34   | false       |
 | Jen Edwards     | 2016-10-18 10:06:36+00 | F30-34   | false       |
 | Lisa Stelzner   | 2016-10-18 09:54:11+00 | F35-39   | true        |
 | Lauren Matthews | 2016-10-18 10:01:17+00 | F35-39   | true        |
 | Desiree Berry   | 2016-10-18 10:05:42+00 | F35-39   | false       |
 | Suzy Slane      | 2016-10-18 10:06:24+00 | F35-39   | false       |
 *-----------------+------------------------+----------+-------------*/
```

### `IS_LAST`

```zetasql
IS_LAST(k)
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]

```

**Description**

Returns `true` if the current row is in the last `k` rows (1-based) in the
window; otherwise, returns `false`. This function doesn't require the `ORDER BY`
clause.

**Details**

* The `k` value must be positive; otherwise, a runtime error is raised.
* If `k` is 0, the scenario is considered a degenerate case where the result is always `false`.
* If `k` is `NULL`, the result is `NULL`.
* Disallows the window framing clause, similar to the `ROW_NUMBER` function.
* If any rows are tied or if `ORDER BY` is omitted, the result is non-deterministic.
  If the `ORDER BY` clause is unspecified or if all rows are tied, the
  result is equivalent to `ANY-k`.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Return Type**

`BOOL`

**Examples**

```zetasql
WITH Numbers AS
 (SELECT 1 as x
  UNION ALL SELECT 2
  UNION ALL SELECT 2
  UNION ALL SELECT 5
  UNION ALL SELECT 10
  UNION ALL SELECT 10
  UNION ALL SELECT 10
)
SELECT x,
  IS_LAST(2) OVER (ORDER BY x) AS is_last
FROM Numbers

/*-------------------------*
 | x          | is_last    |
 +-------------------------+
 | 1          | false      |
 | 2          | false      |
 | 2          | false      |
 | 5          | false      |
 | 10         | false      |
 | 10         | true       |
 | 10         | true       |
 *-------------------------*/
```

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 2:59:01', 'F30-34')
SELECT name,
  finish_time,
  division,
  IS_LAST(2) OVER (PARTITION BY division ORDER BY finish_time ASC) AS is_last
FROM finishers;

/*-----------------+------------------------+----------+-------------*
 | name            | finish_time            | division | finish_rank |
 +-----------------+------------------------+----------+-------------+
 | Sophia Liu      | 2016-10-18 09:51:45+00 | F30-34   | false       |
 | Meghan Lederer  | 2016-10-18 09:59:01+00 | F30-34   | false       |
 | Nikki Leith     | 2016-10-18 09:59:01+00 | F30-34   | true        |
 | Jen Edwards     | 2016-10-18 10:06:36+00 | F30-34   | true        |
 | Lisa Stelzner   | 2016-10-18 09:54:11+00 | F35-39   | false       |
 | Lauren Matthews | 2016-10-18 10:01:17+00 | F35-39   | false       |
 | Desiree Berry   | 2016-10-18 10:05:42+00 | F35-39   | true        |
 | Suzy Slane      | 2016-10-18 10:06:24+00 | F35-39   | true        |
 *-----------------+------------------------+----------+-------------*/
```

### `NTILE`

```zetasql
NTILE(constant_integer_expression)
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  ORDER BY expression [ { ASC | DESC }  ] [, ...]

```

**Description**

This function divides the rows into `constant_integer_expression`
buckets based on row ordering and returns the 1-based bucket number that is
assigned to each row. The number of rows in the buckets can differ by at most 1.
The remainder values (the remainder of number of rows divided by buckets) are
distributed one for each bucket, starting with bucket 1. If
`constant_integer_expression` evaluates to NULL, 0 or negative, an
error is provided.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Return Type**

`INT64`

**Example**

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 2:59:01', 'F30-34')
SELECT name,
  finish_time,
  division,
  NTILE(3) OVER (PARTITION BY division ORDER BY finish_time ASC) AS finish_rank
FROM finishers;

/*-----------------+------------------------+----------+-------------*
 | name            | finish_time            | division | finish_rank |
 +-----------------+------------------------+----------+-------------+
 | Sophia Liu      | 2016-10-18 09:51:45+00 | F30-34   | 1           |
 | Meghan Lederer  | 2016-10-18 09:59:01+00 | F30-34   | 1           |
 | Nikki Leith     | 2016-10-18 09:59:01+00 | F30-34   | 2           |
 | Jen Edwards     | 2016-10-18 10:06:36+00 | F30-34   | 3           |
 | Lisa Stelzner   | 2016-10-18 09:54:11+00 | F35-39   | 1           |
 | Lauren Matthews | 2016-10-18 10:01:17+00 | F35-39   | 1           |
 | Desiree Berry   | 2016-10-18 10:05:42+00 | F35-39   | 2           |
 | Suzy Slane      | 2016-10-18 10:06:24+00 | F35-39   | 3           |
 *-----------------+------------------------+----------+-------------*/
```

### `PERCENT_RANK`

```zetasql
PERCENT_RANK()
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  ORDER BY expression [ { ASC | DESC }  ] [, ...]

```

**Description**

Return the percentile rank of a row defined as (RK-1)/(NR-1), where RK is
the `RANK` of the row and NR is the number of rows in the partition.
Returns 0 if NR=1.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Return Type**

`DOUBLE`

**Example**

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 2:59:01', 'F30-34')
SELECT name,
  finish_time,
  division,
  PERCENT_RANK() OVER (PARTITION BY division ORDER BY finish_time ASC) AS finish_rank
FROM finishers;

/*-----------------+------------------------+----------+---------------------*
 | name            | finish_time            | division | finish_rank         |
 +-----------------+------------------------+----------+---------------------+
 | Sophia Liu      | 2016-10-18 09:51:45+00 | F30-34   | 0                   |
 | Meghan Lederer  | 2016-10-18 09:59:01+00 | F30-34   | 0.33333333333333331 |
 | Nikki Leith     | 2016-10-18 09:59:01+00 | F30-34   | 0.33333333333333331 |
 | Jen Edwards     | 2016-10-18 10:06:36+00 | F30-34   | 1                   |
 | Lisa Stelzner   | 2016-10-18 09:54:11+00 | F35-39   | 0                   |
 | Lauren Matthews | 2016-10-18 10:01:17+00 | F35-39   | 0.33333333333333331 |
 | Desiree Berry   | 2016-10-18 10:05:42+00 | F35-39   | 0.66666666666666663 |
 | Suzy Slane      | 2016-10-18 10:06:24+00 | F35-39   | 1                   |
 *-----------------+------------------------+----------+---------------------*/
```

### `RANK`

```zetasql
RANK()
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  ORDER BY expression [ { ASC | DESC }  ] [, ...]

```

**Description**

Returns the ordinal (1-based) rank of each row within the ordered partition.
All peer rows receive the same rank value. The next row or set of peer rows
receives a rank value which increments by the number of peers with the previous
rank value, instead of `DENSE_RANK`, which always increments by 1.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Return Type**

`INT64`

**Examples**

```zetasql
WITH Numbers AS
 (SELECT 1 as x
  UNION ALL SELECT 2
  UNION ALL SELECT 2
  UNION ALL SELECT 5
  UNION ALL SELECT 8
  UNION ALL SELECT 10
  UNION ALL SELECT 10
)
SELECT x,
  RANK() OVER (ORDER BY x ASC) AS rank
FROM Numbers

/*-------------------------*
 | x          | rank       |
 +-------------------------+
 | 1          | 1          |
 | 2          | 2          |
 | 2          | 2          |
 | 5          | 4          |
 | 8          | 5          |
 | 10         | 6          |
 | 10         | 6          |
 *-------------------------*/
```

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 2:59:01', 'F30-34')
SELECT name,
  finish_time,
  division,
  RANK() OVER (PARTITION BY division ORDER BY finish_time ASC) AS finish_rank
FROM finishers;

/*-----------------+------------------------+----------+-------------*
 | name            | finish_time            | division | finish_rank |
 +-----------------+------------------------+----------+-------------+
 | Sophia Liu      | 2016-10-18 09:51:45+00 | F30-34   | 1           |
 | Meghan Lederer  | 2016-10-18 09:59:01+00 | F30-34   | 2           |
 | Nikki Leith     | 2016-10-18 09:59:01+00 | F30-34   | 2           |
 | Jen Edwards     | 2016-10-18 10:06:36+00 | F30-34   | 4           |
 | Lisa Stelzner   | 2016-10-18 09:54:11+00 | F35-39   | 1           |
 | Lauren Matthews | 2016-10-18 10:01:17+00 | F35-39   | 2           |
 | Desiree Berry   | 2016-10-18 10:05:42+00 | F35-39   | 3           |
 | Suzy Slane      | 2016-10-18 10:06:24+00 | F35-39   | 4           |
 *-----------------+------------------------+----------+-------------*/
```

### `ROW_NUMBER`

```zetasql
ROW_NUMBER()
OVER over_clause

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]

```

**Description**

Returns the sequential row ordinal (1-based) of each row for each ordered
partition. The order of row numbers within their peer group is
non-deterministic.

Doesn't require the `ORDER BY` clause. If the `ORDER BY` clause is unspecified
then the result is non-deterministic.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Return Type**

`INT64`

**Examples**

```zetasql
WITH Numbers AS
 (SELECT 1 as x
  UNION ALL SELECT 2
  UNION ALL SELECT 2
  UNION ALL SELECT 5
  UNION ALL SELECT 8
  UNION ALL SELECT 10
  UNION ALL SELECT 10
)
SELECT x,
  ROW_NUMBER() OVER (ORDER BY x) AS row_num
FROM Numbers

/*-------------------------*
 | x          | row_num    |
 +-------------------------+
 | 1          | 1          |
 | 2          | 2          |
 | 2          | 3          |
 | 5          | 4          |
 | 8          | 5          |
 | 10         | 6          |
 | 10         | 7          |
 *-------------------------*/
```

```zetasql
WITH finishers AS
 (SELECT 'Sophia Liu' as name,
  TIMESTAMP '2016-10-18 2:51:45' as finish_time,
  'F30-34' as division
  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'
  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'
  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'
  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'
  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'
  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'
  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 2:59:01', 'F30-34')
SELECT name,
  finish_time,
  division,
  ROW_NUMBER() OVER (PARTITION BY division ORDER BY finish_time ASC) AS finish_rank
FROM finishers;

/*-----------------+------------------------+----------+-------------*
 | name            | finish_time            | division | finish_rank |
 +-----------------+------------------------+----------+-------------+
 | Sophia Liu      | 2016-10-18 09:51:45+00 | F30-34   | 1           |
 | Meghan Lederer  | 2016-10-18 09:59:01+00 | F30-34   | 2           |
 | Nikki Leith     | 2016-10-18 09:59:01+00 | F30-34   | 3           |
 | Jen Edwards     | 2016-10-18 10:06:36+00 | F30-34   | 4           |
 | Lisa Stelzner   | 2016-10-18 09:54:11+00 | F35-39   | 1           |
 | Lauren Matthews | 2016-10-18 10:01:17+00 | F35-39   | 2           |
 | Desiree Berry   | 2016-10-18 10:05:42+00 | F35-39   | 3           |
 | Suzy Slane      | 2016-10-18 10:06:24+00 | F35-39   | 4           |
 *-----------------+------------------------+----------+-------------*/
```

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

## Protocol buffer functions

ZetaSQL supports the following protocol buffer functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#enum_value_descriptor_proto"><code>ENUM_VALUE_DESCRIPTOR_PROTO</code></a>
</td>
  <td>
    Gets the enum value descriptor proto
    (<code>proto2.EnumValueDescriptorProto</code>) for an enum.
  </td>
</tr>

<tr>
  <td><a href="#proto_extract"><code>EXTRACT</code></a>
</td>
  <td>
    Extracts a value or metadata from a protocol buffer.
  </td>
</tr>

<tr>
  <td><a href="#filter_fields"><code>FILTER_FIELDS</code></a>
</td>
  <td>
    Removed unwanted fields from a protocol buffer.
  </td>
</tr>

<tr>
  <td><a href="#from_proto"><code>FROM_PROTO</code></a>
</td>
  <td>
    Converts a protocol buffer value into ZetaSQL value.
    
  </td>
</tr>

<tr>
  <td><a href="#proto_default_if_null"><code>PROTO_DEFAULT_IF_NULL</code></a>
</td>
  <td>
    Produces the default protocol buffer field value if the
    protocol buffer field is <code>NULL</code>. Otherwise, returns the
    protocol buffer field value.
  </td>
</tr>

<tr>
  <td><a href="#proto_map_contains_key"><code>PROTO_MAP_CONTAINS_KEY</code></a>
</td>
  <td>
    Checks if a protocol buffer map field contains a given key.
  </td>
</tr>

<tr>
  <td><a href="#proto_modify_map"><code>PROTO_MODIFY_MAP</code></a>
</td>
  <td>
    Modifies a protocol buffer map field.
  </td>
</tr>

<tr>
  <td><a href="#replace_fields"><code>REPLACE_FIELDS</code></a>
</td>
  <td>
    Replaces the values in one or more protocol buffer fields.
  </td>
</tr>

<tr>
  <td><a href="#to_proto"><code>TO_PROTO</code></a>
</td>
  <td>
    Converts a ZetaSQL value into a protocol buffer value.
    
  </td>
</tr>

  </tbody>
</table>

### `ENUM_VALUE_DESCRIPTOR_PROTO`

```zetasql
ENUM_VALUE_DESCRIPTOR_PROTO(proto_enum)
```

**Description**

Gets the enum value descriptor proto
(`proto2.EnumValueDescriptorProto`) for an enum.

**Definitions**

+   `proto_enum`: An `ENUM` value that contains the descriptor to retrieve.

**Return type**

`proto2.EnumValueDescriptorProto PROTO`

**Example**

The following query gets the `ideally_enabled` and `in_development` options from
the value descriptors in the `LanguageFeature` enum, and then produces query
results that are based on these value descriptors.

```zetasql
WITH
  EnabledFeatures AS (
    SELECT CAST(999991 AS zetasql.LanguageFeature) AS feature UNION ALL
    SELECT CAST(999992 AS zetasql.LanguageFeature) AS feature
  )
SELECT
  CAST(feature AS STRING) AS feature_enum_name,
  CAST(feature AS INT64) AS feature_enum_id,
  IFNULL(
    ENUM_VALUE_DESCRIPTOR_PROTO(feature).options.(zetasql.language_feature_options).ideally_enabled,
    TRUE) AS feature_is_ideally_enabled,
  IFNULL(
    ENUM_VALUE_DESCRIPTOR_PROTO(feature).options.(zetasql.language_feature_options).in_development,
    FALSE) AS feature_is_in_development
FROM
  EnabledFeatures;

/*-------------------------------------------------+-----------------+----------------------------+---------------------------*
 | feature_enum_name                               | feature_enum_id | feature_is_ideally_enabled | feature_is_in_development |
 +-------------------------------------------------+-----------------+----------------------------+---------------------------+
 | FEATURE_TEST_IDEALLY_ENABLED_BUT_IN_DEVELOPMENT | 999991          | TRUE                       | TRUE                      |
 | FEATURE_TEST_IDEALLY_DISABLED                   | 999992          | FALSE                      | FALSE                     |
 *-------------------------------------------------+-----------------+----------------------------+---------------------------*/
```

### `EXTRACT` 
<a id="proto_extract"></a>

```zetasql
EXTRACT( extraction_type (proto_field) FROM proto_expression )

extraction_type:
  { FIELD | RAW | HAS | ONEOF_CASE }
```

**Description**

Extracts a value from a protocol buffer. `proto_expression` represents the
expression that returns a protocol buffer, `proto_field` represents the field of
the protocol buffer to extract from, and `extraction_type` determines the type
of data to return.

You can access most simple proto message fields idiomatically using the
[dot operator][dot-operator]. `EXTRACT` is a more general way to access fields
that can handle most cases. For instance, `EXTRACT` can access the values of
fields made ambiguous by tag reuse.

**Extraction Types**

You can choose the type of information to get with `EXTRACT`. Your choices are:

+  `FIELD`: Extract a value from a protocol buffer field.
+  `RAW`: Extract an uninterpreted value from a
    protocol buffer field. Raw values
    ignore any ZetaSQL type annotations.
+  `HAS`: Returns `TRUE` if a protocol buffer field is set in a proto message;
   otherwise, `FALSE`. Alternatively, use [`has_x`][has-value] to perform this
   task.
+  `ONEOF_CASE`: Returns the name of the set protocol buffer field in a Oneof.
   If no field is set, returns an empty string.

**Return Type**

The return type depends upon the extraction type in the query.

+  `FIELD`: Protocol buffer field type.
+  `RAW`: Protocol buffer field
    type. Format annotations are
    ignored.
+  `HAS`: `BOOL`
+  `ONEOF_CASE`: `STRING`

**Examples**

The examples in this section reference two protocol buffers called `Album` and
`Chart`, and one table called `AlbumList`.

```proto
message Album {
  optional string album_name = 1;
  repeated string song = 2;
  oneof group_name {
    string solo = 3;
    string duet = 4;
    string band = 5;
  }
}
```

```proto
message Chart {
  optional int64 date = 1 [(zetasql.format) = DATE];
  optional string chart_name = 2;
  optional int64 rank = 3;
}
```

```zetasql
WITH AlbumList AS (
  SELECT
    NEW Album(
      'Alana Yah' AS solo,
      'New Moon' AS album_name,
      ['Sandstorm','Wait'] AS song) AS album_col,
    NEW Chart(
      'Billboard' AS chart_name,
      '2016-04-23' AS date,
      1 AS rank) AS chart_col
    UNION ALL
  SELECT
    NEW Album(
      'The Roadlands' AS band,
      'Grit' AS album_name,
      ['The Way', 'Awake', 'Lost Things'] AS song) AS album_col,
    NEW Chart(
      'Billboard' AS chart_name,
      1 as rank) AS chart_col
)
SELECT * FROM AlbumList
```

The following example extracts the album names from a table called `AlbumList`
that contains a proto-typed column called `Album`.

```zetasql
SELECT EXTRACT(FIELD(album_name) FROM album_col) AS name_of_album
FROM AlbumList

/*------------------*
 | name_of_album    |
 +------------------+
 | New Moon         |
 | Grit             |
 *------------------*/
```

A table called `AlbumList` contains a proto-typed column called `Chart`.
`Chart` contains a field called `date`, which can store an integer. The
`date` field has an annotated format called `DATE` assigned to it, which means
that when you extract the value in this field, it returns a `DATE`, not an
`INT64`.

If you would like to return the value for `date` as an `INT64`, not
as a `DATE`, use the `RAW` extraction type in your query. For example:

```zetasql
SELECT
  EXTRACT(RAW(date) FROM chart_col) AS raw_date,
  EXTRACT(FIELD(date) FROM chart_col) AS formatted_date
FROM AlbumList

/*----------+----------------*
 | raw_date | formatted_date |
 +----------+----------------+
 | 16914    | 2016-04-23     |
 | 0        | 1970-01-01     |
 *----------+----------------*/
```

The following example checks to see if release dates exist in a table called
`AlbumList` that contains a protocol buffer called `Chart`.

```zetasql
SELECT EXTRACT(HAS(date) FROM chart_col) AS has_release_date
FROM AlbumList

/*------------------*
 | has_release_date |
 +------------------+
 | TRUE             |
 | FALSE            |
 *------------------*/
```

The following example extracts the group name that's assigned to an artist in
a table called `AlbumList`. The group name is set for exactly one
protocol buffer field inside of the `group_name` Oneof. The `group_name` Oneof
exists inside the `Album` protocol buffer.

```zetasql
SELECT EXTRACT(ONEOF_CASE(group_name) FROM album_col) AS artist_type
FROM AlbumList;

/*-------------*
 | artist_type |
 +-------------+
 | solo        |
 | band        |
 *-------------*/
```

[dot-operator]: https://github.com/google/zetasql/blob/master/docs/operators.md#field_access_operator

[has-value]: https://github.com/google/zetasql/blob/master/docs/protocol-buffers.md#checking_if_a_field_has_a_value

### `FILTER_FIELDS`

```zetasql
FILTER_FIELDS(
  proto_expression,
  proto_field_list
  [, reset_cleared_required_fields => { TRUE | FALSE } ]
)

proto_field_list:
  {+|-}proto_field_path[, ...]
```

**Description**

Takes a protocol buffer and a list of its fields to include or exclude.
Returns a version of that protocol buffer with unwanted fields removed.
Returns `NULL` if the protocol buffer is `NULL`.

Input values:

+ `proto_expression`: The protocol buffer to filter.
+ `proto_field_list`: The fields to exclude or include in the resulting
  protocol buffer.
+ `+`: Include a protocol buffer field and its children in the results.
+ `-`: Exclude a protocol buffer field and its children in the results.
+ `proto_field_path`: The protocol buffer field to include or exclude.
  If the field represents an [extension][querying-proto-extensions], you can use
  syntax for that extension in the path.
+ `reset_cleared_required_fields`: Named argument with a `BOOL` value.
  If not explicitly set, `FALSE` is used implicitly.
  If `FALSE`, you must include all protocol buffer `required` fields in the
  `FILTER_FIELDS` function. If `TRUE`, you don't need to include all required
  protocol buffer fields and the value of required fields
  defaults to these values:

  Type                    | Default value
  ----------------------- | --------
  Floating point          | `0.0`
  Integer                 | `0`
  Boolean                 | `FALSE`
  String, byte            | `""`
  Protocol buffer message | Empty message

Protocol buffer field expression behavior:

+ The first field in `proto_field_list` determines the default
  inclusion/exclusion. By default, when you include the first field, all other
  fields are excluded. Or by default, when you exclude the first field, all
  other fields are included.
+ A required field in the protocol buffer can't be excluded explicitly or
  implicitly, unless you have the
  `RESET_CLEARED_REQUIRED_FIELDS` named argument set as `TRUE`.
+ If a field is included, its child fields and descendants are implicitly
  included in the results.
+ If a field is excluded, its child fields and descendants are
  implicitly excluded in the results.
+ A child field must be listed after its parent field in the argument list,
  but doesn't need to come right after the parent field.

Caveats:

+ If you attempt to exclude/include a field that already has been
  implicitly excluded/included, an error is produced.
+ If you attempt to explicitly include/exclude a field that has already
  implicitly been included/excluded, an error is produced.

**Return type**

Type of `proto_expression`

**Examples**

The examples in this section reference a protocol buffer called `Award` and
a table called `MusicAwards`.

```proto
message Award {
  required int32 year = 1;
  optional int32 month = 2;
  repeated Type type = 3;

  message Type {
    optional string award_name = 1;
    optional string category = 2;
  }
}
```

```zetasql
WITH
  MusicAwards AS (
    SELECT
      CAST(
        '''
        year: 2001
        month: 9
        type { award_name: 'Best Artist' category: 'Artist' }
        type { award_name: 'Best Album' category: 'Album' }
        '''
        AS zetasql.examples.music.Award) AS award_col
    UNION ALL
    SELECT
      CAST(
        '''
        year: 2001
        month: 12
        type { award_name: 'Best Song' category: 'Song' }
        '''
        AS zetasql.examples.music.Award) AS award_col
  )
SELECT *
FROM MusicAwards

/*---------------------------------------------------------*
 | award_col                                               |
 +---------------------------------------------------------+
 | {                                                       |
 |   year: 2001                                            |
 |   month: 9                                              |
 |   type { award_name: "Best Artist" category: "Artist" } |
 |   type { award_name: "Best Album" category: "Album" }   |
 | }                                                       |
 | {                                                       |
 |   year: 2001                                            |
 |   month: 12                                             |
 |   type { award_name: "Best Song" category: "Song" }     |
 | }                                                       |
 *---------------------------------------------------------*/
```

The following example returns protocol buffers that only include the `year`
field.

```zetasql
SELECT FILTER_FIELDS(award_col, +year) AS filtered_fields
FROM MusicAwards

/*-----------------*
 | filtered_fields |
 +-----------------+
 | {year: 2001}    |
 | {year: 2001}    |
 *-----------------*/
```

The following example returns protocol buffers that include all but the `type`
field.

```zetasql
SELECT FILTER_FIELDS(award_col, -type) AS filtered_fields
FROM MusicAwards

/*------------------------*
 | filtered_fields        |
 +------------------------+
 | {year: 2001 month: 9}  |
 | {year: 2001 month: 12} |
 *------------------------*/
```

The following example returns protocol buffers that only include the `year` and
`type.award_name` fields.

```zetasql
SELECT FILTER_FIELDS(award_col, +year, +type.award_name) AS filtered_fields
FROM MusicAwards

/*--------------------------------------*
 | filtered_fields                      |
 +--------------------------------------+
 | {                                    |
 |   year: 2001                         |
 |   type { award_name: "Best Artist" } |
 |   type { award_name: "Best Album" }  |
 | }                                    |
 | {                                    |
 |   year: 2001                         |
 |   type { award_name: "Best Song" }   |
 | }                                    |
 *--------------------------------------*/
```

The following example returns the `year` and `type` fields, but excludes the
`award_name` field in the `type` field.

```zetasql
SELECT FILTER_FIELDS(award_col, +year, +type, -type.award_name) AS filtered_fields
FROM MusicAwards

/*---------------------------------*
 | filtered_fields                 |
 +---------------------------------+
 | {                               |
 |   year: 2001                    |
 |   type { category: "Artist" }   |
 |   type { category: "Album" }    |
 | }                               |
 | {                               |
 |   year: 2001                    |
 |   type { category: "Song" }     |
 | }                               |
 *---------------------------------*/
```

The following example produces an error because `year` is a required field
and can't be excluded explicitly or implicitly from the results.

```zetasql
SELECT FILTER_FIELDS(award_col, -year) AS filtered_fields
FROM MusicAwards

-- Error
```

The following example produces an error because when `year` was included,
`month` was implicitly excluded. You can't explicitly exclude a field that
has already been implicitly excluded.

```zetasql
SELECT FILTER_FIELDS(award_col, +year, -month) AS filtered_fields
FROM MusicAwards

-- Error
```

When `RESET_CLEARED_REQUIRED_FIELDS` is set as `TRUE`, `FILTER_FIELDS` doesn't
need to include required fields. In the example below, `MusicAwards` has a
required field called `year`, but this isn't added as an argument for
`FILTER_FIELDS`. `year` is added to the results with its default value, `0`.

```zetasql
SELECT FILTER_FIELDS(
  award_col,
  +month,
  RESET_CLEARED_REQUIRED_FIELDS => TRUE) AS filtered_fields
FROM MusicAwards;

/*---------------------------------*
 | filtered_fields                 |
 +---------------------------------+
 | {                               |
 |   year: 0,                      |
 |   month: 9                      |
 | }                               |
 | {                               |
 |   year: 0,                      |
 |   month: 12                     |
 | }                               |
 *---------------------------------*/
```

[querying-proto-extensions]: https://github.com/google/zetasql/blob/master/docs/protocol-buffers.md#extensions

### `FROM_PROTO`

```zetasql
FROM_PROTO(expression)
```

**Description**

Returns a ZetaSQL value. The valid `expression` types are defined
in the table below, along with the return types that they produce.
Other input `expression` types are invalid. If `expression` can't be converted
to a valid value, an error is returned.

<table width="100%">
  <thead>
    <tr>
      <th width="50%"><code>expression</code> type</th>
      <th width="50%">Return type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <ul>
        <li>INT32</li>
        <li>google.protobuf.Int32Value</li>
        </ul>
      </td>
      <td>INT32</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>UINT32</li>
        <li>google.protobuf.UInt32Value</li>
        </ul>
      </td>
      <td>UINT32</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>INT64</li>
        <li>google.protobuf.Int64Value</li>
        </ul>
      </td>
      <td>INT64</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>UINT64</li>
        <li>google.protobuf.UInt64Value</li>
        </ul>
      </td>
      <td>UINT64</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>FLOAT</li>
        <li>google.protobuf.FloatValue</li>
        </ul>
      </td>
      <td>FLOAT</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>DOUBLE</li>
        <li>google.protobuf.DoubleValue</li>
        </ul>
      </td>
      <td>DOUBLE</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>BOOL</li>
        <li>google.protobuf.BoolValue</li>
        </ul>
      </td>
      <td>BOOL</td>
    </tr>
    <tr>
      <td>
        <ul>
          <li>STRING</li>
          <li>
            google.protobuf.StringValue
            <p>
            Note: The <code>StringValue</code>
            value field must be
            UTF-8 encoded.
            </p>
          </li>
        </ul>
      </td>
      <td>STRING</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>BYTES</li>
        <li>google.protobuf.BytesValue</li>
        </ul>
      </td>
      <td>BYTES</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>DATE</li>
        <li>google.type.Date</li>
        </ul>
      </td>
      <td>DATE</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>TIME</li>
        <li>
          google.type.TimeOfDay

          

          

        </li>
        </ul>
      </td>
      <td>TIME</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>TIMESTAMP</li>
        <li>
          google.protobuf.Timestamp

          

          

        </li>
        </ul>
      </td>
      <td>TIMESTAMP</td>
    </tr>
  </tbody>
</table>

**Return Type**

The return type depends upon the `expression` type. See the return types
in the table above.

**Examples**

Convert a `google.type.Date` type into a `DATE` type.

```zetasql
SELECT FROM_PROTO(
  new google.type.Date(
    2019 as year,
    10 as month,
    30 as day
  )
)

/*------------*
 | $col1      |
 +------------+
 | 2019-10-30 |
 *------------*/
```

Pass in and return a `DATE` type.

```zetasql
SELECT FROM_PROTO(DATE '2019-10-30')

/*------------*
 | $col1      |
 +------------+
 | 2019-10-30 |
 *------------*/
```

### `PROTO_DEFAULT_IF_NULL`

```zetasql
PROTO_DEFAULT_IF_NULL(proto_field_expression)
```

**Description**

Evaluates any expression that results in a proto field access.
If the `proto_field_expression` evaluates to `NULL`, returns the default
value for the field. Otherwise, returns the field value.

Stipulations:

+ The expression can't resolve to a required field.
+ The expression can't resolve to a message field.
+ The expression must resolve to a regular proto field access, not
  a virtual field.
+ The expression can't access a field with
  `zetasql.use_defaults=false`.

**Return Type**

Type of `proto_field_expression`.

**Example**

In the following example, each book in a library has a country of origin. If
the country isn't set, the country defaults to unknown.

In this statement, table `library_books` contains a column named `book`,
whose type is `Book`.

```zetasql
SELECT PROTO_DEFAULT_IF_NULL(book.country) AS origin FROM library_books;
```

`Book` is a type that contains a field called `country`.

```proto
message Book {
  optional string country = 4 [default = 'Unknown'];
}
```

This is the result if `book.country` evaluates to `Canada`.

```zetasql
/*-----------------*
 | origin          |
 +-----------------+
 | Canada          |
 *-----------------*/
```

This is the result if `book` is `NULL`. Since `book` is `NULL`,
`book.country` evaluates to `NULL` and therefore the function result is the
default value for `country`.

```zetasql
/*-----------------*
 | origin          |
 +-----------------+
 | Unknown         |
 *-----------------*/
```

### `PROTO_MAP_CONTAINS_KEY`

```zetasql
PROTO_MAP_CONTAINS_KEY(proto_map_field_expression, key)
```

**Description**

Returns whether a [protocol buffer map field][proto-map] contains a given key.

Input values:

+ `proto_map_field_expression`: A protocol buffer map field.
+ `key`: A key in the protocol buffer map field.

`NULL` handling:

+ If `map_field` is `NULL`, returns `NULL`.
+ If `key` is `NULL`, returns `FALSE`.

**Return type**

`BOOL`

**Examples**

To illustrate the use of this function, consider the protocol buffer message
`Item`:

```proto
message Item {
  optional map<string, int64> purchased = 1;
};
```

In the following example, the function returns `TRUE` when the key is
present, `FALSE` otherwise.

```zetasql
SELECT
  PROTO_MAP_CONTAINS_KEY(m.purchased, 'A') AS contains_a,
  PROTO_MAP_CONTAINS_KEY(m.purchased, 'B') AS contains_b
FROM
  (SELECT AS VALUE CAST("purchased { key: 'A' value: 2 }" AS Item)) AS m;

/*------------+------------*
 | contains_a | contains_b |
 +------------+------------+
 | TRUE       | FALSE      |
 *------------+------------*/
```

[proto-map]: https://developers.google.com/protocol-buffers/docs/proto3#maps

### `PROTO_MODIFY_MAP`

```zetasql
PROTO_MODIFY_MAP(proto_map_field_expression, key_value_pair[, ...])

key_value_pair:
  key, value
```

**Description**

Modifies a [protocol buffer map field][proto-map] and returns the modified map
field.

Input values:

+ `proto_map_field_expression`: A protocol buffer map field.
+ `key_value_pair`: A key-value pair in the protocol buffer map field.

Modification behavior:

+ If the key isn't already in the map field, adds the key and its value to the
  map field.
+ If the key is already in the map field, replaces its value.
+ If the key is in the map field and the value is `NULL`, removes the key and
  its value from the map field.

`NULL` handling:

+ If `key` is `NULL`, produces an error.
+ If the same `key` appears more than once, produces an error.
+ If `map` is `NULL`, `map` is treated as empty.

**Return type**

In the input protocol buffer map field, `V` as represented in `map<K,V>`.

**Examples**

To illustrate the use of this function, consider the protocol buffer message
`Item`:

```proto
message Item {
  optional map<string, int64> purchased = 1;
};
```

In the following example, the query deletes key `A`, replaces `B`, and adds
`C` in a map field called `purchased`.

```zetasql
SELECT
  PROTO_MODIFY_MAP(m.purchased, 'A', NULL, 'B', 4, 'C', 6) AS result_map
FROM
  (SELECT AS VALUE CAST("purchased { key: 'A' value: 2 } purchased { key: 'B' value: 3}" AS Item)) AS m;

/*---------------------------------------------*
 | result_map                                  |
 +---------------------------------------------+
 | { key: 'B' value: 4 } { key: 'C' value: 6 } |
 *---------------------------------------------*/
```

[proto-map]: https://developers.google.com/protocol-buffers/docs/proto3#maps

### `REPLACE_FIELDS`

```zetasql
REPLACE_FIELDS(proto_expression, value AS field_path [, ... ])
```

**Description**

Returns a copy of a protocol buffer, replacing the values in one or more fields.
`field_path` is a delimited path to the protocol buffer field that's replaced.
When using `replace_fields`, the following limitations apply:

+   If `value` is `NULL`, it un-sets `field_path` or returns an error if the
    last component of `field_path` is a required field.
+   Replacing subfields will succeed only if the message containing the field is
    set.
+   Replacing subfields of repeated field isn't allowed.
+   A repeated field can be replaced with an `ARRAY` value.

**Return type**

Type of `proto_expression`

**Examples**

The following example uses protocol buffer messages `Book` and `BookDetails`.

```
message Book {
  required string title = 1;
  repeated string reviews = 2;
  optional BookDetails details = 3;
};

message BookDetails {
  optional string author = 1;
  optional int32 chapters = 2;
};
```

This statement replaces the values of the field `title` and subfield `chapters`
of proto type `Book`. Note that field `details` must be set for the statement
to succeed.

```zetasql
SELECT REPLACE_FIELDS(
  NEW Book(
    "The Hummingbird" AS title,
    NEW BookDetails(10 AS chapters) AS details),
  "The Hummingbird II" AS title,
  11 AS details.chapters)
AS proto;

/*-----------------------------------------------------------------------------*
 | proto                                                                       |
 +-----------------------------------------------------------------------------+
 |{title: "The Hummingbird II" details: {chapters: 11 }}                       |
 *-----------------------------------------------------------------------------*/
```

The function can replace value of repeated fields.

```zetasql
SELECT REPLACE_FIELDS(
  NEW Book("The Hummingbird" AS title,
    NEW BookDetails(10 AS chapters) AS details),
  ["A good read!", "Highly recommended."] AS reviews)
AS proto;

/*-----------------------------------------------------------------------------*
 | proto                                                                       |
 +-----------------------------------------------------------------------------+
 |{title: "The Hummingbird" review: "A good read" review: "Highly recommended."|
 | details: {chapters: 10 }}                                                   |
 *-----------------------------------------------------------------------------*/
```

The function can also set a field to `NULL`.

```zetasql
SELECT REPLACE_FIELDS(
  NEW Book("The Hummingbird" AS title,
    NEW BookDetails(10 AS chapters) AS details),
  NULL AS details)
AS proto;

/*-----------------------------------------------------------------------------*
 | proto                                                                       |
 +-----------------------------------------------------------------------------+
 |{title: "The Hummingbird" }                                                  |
 *-----------------------------------------------------------------------------*/
```

### `TO_PROTO`

```
TO_PROTO(expression)
```

**Description**

Returns a PROTO value. The valid `expression` types are defined in the
table below, along with the return types that they produce. Other input
`expression` types are invalid.

<table width="100%">
  <thead>
    <tr>
      <th width="50%"><code>expression</code> type</th>
      <th width="50%">Return type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <ul>
        <li>INT32</li>
        <li>google.protobuf.Int32Value</li>
        </ul>
      </td>
      <td>google.protobuf.Int32Value</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>UINT32</li>
        <li>google.protobuf.UInt32Value</li>
        </ul>
      </td>
      <td>google.protobuf.UInt32Value</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>INT64</li>
        <li>google.protobuf.Int64Value</li>
        </ul>
      </td>
      <td>google.protobuf.Int64Value</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>UINT64</li>
        <li>google.protobuf.UInt64Value</li>
        </ul>
      </td>
      <td>google.protobuf.UInt64Value</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>FLOAT</li>
        <li>google.protobuf.FloatValue</li>
        </ul>
      </td>
      <td>google.protobuf.FloatValue</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>DOUBLE</li>
        <li>google.protobuf.DoubleValue</li>
        </ul>
      </td>
      <td>google.protobuf.DoubleValue</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>BOOL</li>
        <li>google.protobuf.BoolValue</li>
        </ul>
      </td>
      <td>google.protobuf.BoolValue</td>
    </tr>
    <tr>
      <td>
        <ul>
          <li>STRING</li>
          <li>google.protobuf.StringValue</li>
        </ul>
      </td>
      <td>google.protobuf.StringValue</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>BYTES</li>
        <li>google.protobuf.BytesValue</li>
        </ul>
      </td>
      <td>google.protobuf.BytesValue</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>DATE</li>
        <li>google.type.Date</li>
        </ul>
      </td>
      <td>google.type.Date</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>TIME</li>
        <li>google.type.TimeOfDay</li>
        </ul>
      </td>
      <td>google.type.TimeOfDay</td>
    </tr>
    <tr>
      <td>
        <ul>
        <li>TIMESTAMP</li>
        <li>google.protobuf.Timestamp</li>
        </ul>
      </td>
      <td>google.protobuf.Timestamp</td>
    </tr>
  </tbody>
</table>

**Return Type**

The return type depends upon the `expression` type. See the return types
in the table above.

**Examples**

Convert a `DATE` type into a `google.type.Date` type.

```zetasql
SELECT TO_PROTO(DATE '2019-10-30')

/*--------------------------------*
 | $col1                          |
 +--------------------------------+
 | {year: 2019 month: 10 day: 30} |
 *--------------------------------*/
```

Pass in and return a `google.type.Date` type.

```zetasql
SELECT TO_PROTO(
  new google.type.Date(
    2019 as year,
    10 as month,
    30 as day
  )
)

/*--------------------------------*
 | $col1                          |
 +--------------------------------+
 | {year: 2019 month: 10 day: 30} |
 *--------------------------------*/
```

## Range functions

ZetaSQL supports the following range functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#generate_range_array"><code>GENERATE_RANGE_ARRAY</code></a>
</td>
  <td>
    Splits a range into an array of subranges.
    
  </td>
</tr>

<tr>
  <td><a href="#range"><code>RANGE</code></a>
</td>
  <td>
    Constructs a range of <code>DATE</code>, <code>DATETIME</code>,
    or <code>TIMESTAMP</code> values.
  </td>
</tr>

<tr>
  <td><a href="#range_bucket"><code>RANGE_BUCKET</code></a>
</td>
  <td>
    Scans through a sorted array and returns the 0-based position
    of a point's upper bound.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/mathematical_functions.md">Mathematical functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#range_contains"><code>RANGE_CONTAINS</code></a>
</td>
  <td>
  Signature 1: Checks if one range is in another range.
  <br /><br />
  Signature 2: Checks if a value is in a range.
  </td>
</tr>

<tr>
  <td><a href="#range_end"><code>RANGE_END</code></a>
</td>
  <td>Gets the upper bound of a range.</td>
</tr>

<tr>
  <td><a href="#range_intersect"><code>RANGE_INTERSECT</code></a>
</td>
  <td>Gets a segment of two ranges that intersect.</td>
</tr>

<tr>
  <td><a href="#range_overlaps"><code>RANGE_OVERLAPS</code></a>
</td>
  <td>Checks if two ranges overlap.</td>
</tr>

<tr>
  <td><a href="#range_sessionize"><code>RANGE_SESSIONIZE</code></a>
</td>
  <td>
    Produces a table of sessionized ranges.
    
  </td>
</tr>

<tr>
  <td><a href="#range_start"><code>RANGE_START</code></a>
</td>
  <td>Gets the lower bound of a range.</td>
</tr>

  </tbody>
</table>

### `GENERATE_RANGE_ARRAY`

```zetasql
GENERATE_RANGE_ARRAY(range_to_split, step_interval)
```

```zetasql
GENERATE_RANGE_ARRAY(range_to_split, step_interval, include_last_partial_range)
```

**Description**

Splits a range into an array of subranges.

**Definitions**

+   `range_to_split`: The `RANGE<T>` value to split.
+   `step_interval`: The `INTERVAL` value, which determines the maximum size of
    each subrange in the resulting array. An
    [interval single date and time part][interval-single]
    is supported, but an interval range of date and time parts isn't.

    +   If `range_to_split` is `RANGE<DATE>`, these interval
        date parts are supported: `YEAR` to `DAY`.

    +   If `range_to_split` is `RANGE<DATETIME>`, these interval
        date and time parts are supported: `YEAR` to `SECOND`.

    +   If `range_to_split` is `RANGE<TIMESTAMP>`, these interval
        date and time parts are supported: `DAY` to `SECOND`.
+   `include_last_partial_range`: A `BOOL` value, which determines whether or
    not to include the last subrange if it's a partial subrange.
    If this argument isn't specified, the default value is `TRUE`.

    +   `TRUE` (default): The last subrange is included, even if it's
        smaller than `step_interval`.

    +   `FALSE`: Exclude the last subrange if it's smaller than
        `step_interval`.

**Details**

Returns `NULL` if any input is` NULL`.

**Return type**

`ARRAY<RANGE<T>>`

**Examples**

In the following example, a date range between `2020-01-01` and `2020-01-06`
is split into an array of subranges that are one day long. There are
no partial ranges.

```zetasql
SELECT GENERATE_RANGE_ARRAY(
  RANGE(DATE '2020-01-01', DATE '2020-01-06'),
  INTERVAL 1 DAY) AS results;

/*----------------------------+
 | results                    |
 +----------------------------+
 | [                          |
 |  [2020-01-01, 2020-01-02), |
 |  [2020-01-02, 2020-01-03), |
 |  [2020-01-03, 2020-01-04), |
 |  [2020-01-04, 2020-01-05), |
 |  [2020-01-05, 2020-01-06), |
 | ]                          |
 +----------------------------*/
```

In the following examples, a date range between `2020-01-01` and `2020-01-06`
is split into an array of subranges that are two days long. The final subrange
is smaller than two days:

```zetasql
SELECT GENERATE_RANGE_ARRAY(
  RANGE(DATE '2020-01-01', DATE '2020-01-06'),
  INTERVAL 2 DAY) AS results;

/*----------------------------+
 | results                    |
 +----------------------------+
 | [                          |
 |  [2020-01-01, 2020-01-03), |
 |  [2020-01-03, 2020-01-05), |
 |  [2020-01-05, 2020-01-06)  |
 | ]                          |
 +----------------------------*/
```

```zetasql
SELECT GENERATE_RANGE_ARRAY(
  RANGE(DATE '2020-01-01', DATE '2020-01-06'),
  INTERVAL 2 DAY,
  TRUE) AS results;

/*----------------------------+
 | results                    |
 +----------------------------+
 | [                          |
 |  [2020-01-01, 2020-01-03), |
 |  [2020-01-03, 2020-01-05), |
 |  [2020-01-05, 2020-01-06)  |
 | ]                          |
 +----------------------------*/
```

In the following example, a date range between `2020-01-01` and `2020-01-06`
is split into an array of subranges that are two days long, but the final
subrange is excluded because it's smaller than two days:

```zetasql
SELECT GENERATE_RANGE_ARRAY(
  RANGE(DATE '2020-01-01', DATE '2020-01-06'),
  INTERVAL 2 DAY,
  FALSE) AS results;

/*----------------------------+
 | results                    |
 +----------------------------+
 | [                          |
 |  [2020-01-01, 2020-01-03), |
 |  [2020-01-03, 2020-01-05)  |
 | ]                          |
 +----------------------------*/
```

[interval-single]: https://github.com/google/zetasql/blob/master/docs/data-types.md#single_datetime_part_interval

### `RANGE`

```zetasql
RANGE(lower_bound, upper_bound)
```

**Description**

Constructs a range of [`DATE`][date-type], [`DATETIME`][datetime-type], or
[`TIMESTAMP`][timestamp-type] values.

**Definitions**

+   `lower_bound`: The range starts from this value. This can be a
    `DATE`, `DATETIME`, or `TIMESTAMP` value. If this value is `NULL`, the range
    doesn't include a lower bound.
+   `upper_bound`: The range ends before this value. This can be a
    `DATE`, `DATETIME`, or `TIMESTAMP` value. If this value is `NULL`, the range
    doesn't include an upper bound.

**Details**

`lower_bound` and `upper_bound` must be of the same data type.

Produces an error if `lower_bound` is greater than or equal to `upper_bound`.
To return `NULL` instead, add the `SAFE.` prefix to the function name.

**Return type**

`RANGE<T>`, where `T` is the same data type as the input.

**Examples**

The following query constructs a date range:

```zetasql
SELECT RANGE(DATE '2022-12-01', DATE '2022-12-31') AS results;

/*--------------------------+
 | results                  |
 +--------------------------+
 | [2022-12-01, 2022-12-31) |
 +--------------------------*/
```

The following query constructs a datetime range:

```zetasql
SELECT RANGE(DATETIME '2022-10-01 14:53:27',
             DATETIME '2022-10-01 16:00:00') AS results;

/*---------------------------------------------+
 | results                                     |
 +---------------------------------------------+
 | [2022-10-01 14:53:27, 2022-10-01T16:00:00)  |
 +---------------------------------------------*/
```

The following query constructs a timestamp range:

```zetasql
SELECT RANGE(TIMESTAMP '2022-10-01 14:53:27 America/Los_Angeles',
             TIMESTAMP '2022-10-01 16:00:00 America/Los_Angeles') AS results;

-- Results depend upon where this query was executed.
/*-----------------------------------------------------------------+
 | results                                                         |
 +-----------------------------------------------------------------+
 | [2022-10-01 21:53:27.000000+00, 2022-10-01 23:00:00.000000+00)  |
 +-----------------------------------------------------------------*/
```

The following query constructs a date range with no lower bound:

```zetasql
SELECT RANGE(NULL, DATE '2022-12-31') AS results;

/*-------------------------+
 | results                 |
 +-------------------------+
 | [UNBOUNDED, 2022-12-31) |
 +-------------------------*/
```

The following query constructs a date range with no upper bound:

```zetasql
SELECT RANGE(DATE '2022-10-01', NULL) AS results;

/*--------------------------+
 | results                  |
 +--------------------------+
 | [2022-10-01, UNBOUNDED)  |
 +--------------------------*/
```

[timestamp-type]: https://github.com/google/zetasql/blob/master/docs/data-types.md#timestamp_type

[date-type]: https://github.com/google/zetasql/blob/master/docs/data-types.md#date_type

[datetime-type]: https://github.com/google/zetasql/blob/master/docs/data-types.md#datetime_type

### `RANGE_CONTAINS`

+   [Signature 1][range_contains-sig1]: Checks if every value in one range is
    in another range.
+   [Signature 2][range_contains-sig2]: Checks if a value is in a range.

#### Signature 1

```zetasql
RANGE_CONTAINS(outer_range, inner_range)
```

**Description**

Checks if the inner range is in the outer range.

**Definitions**

+   `outer_range`: The `RANGE<T>` value to search within.
+   `inner_range`: The `RANGE<T>` value to search for in `outer_range`.

**Details**

Returns `TRUE` if `inner_range` exists in `outer_range`.
Otherwise, returns `FALSE`.

`T` must be of the same type for all inputs.

**Return type**

`BOOL`

**Examples**

In the following query, the inner range is in the outer range:

```zetasql
SELECT RANGE_CONTAINS(
  RANGE<DATE> '[2022-01-01, 2023-01-01)',
  RANGE<DATE> '[2022-04-01, 2022-07-01)') AS results;

/*---------+
 | results |
 +---------+
 | TRUE    |
 +---------*/
```

In the following query, the inner range isn't in the outer range:

```zetasql
SELECT RANGE_CONTAINS(
  RANGE<DATE> '[2022-01-01, 2023-01-01)',
  RANGE<DATE> '[2023-01-01, 2023-04-01)') AS results;

/*---------+
 | results |
 +---------+
 | FALSE   |
 +---------*/
```

#### Signature 2

```zetasql
RANGE_CONTAINS(range_to_search, value_to_find)
```

**Description**

Checks if a value is in a range.

**Definitions**

+   `range_to_search`: The `RANGE<T>` value to search within.
+   `value_to_find`: The value to search for in `range_to_search`.

**Details**

Returns `TRUE` if `value_to_find` exists in `range_to_search`.
Otherwise, returns `FALSE`.

The data type for `value_to_find` must be the same data type as `T`in
`range_to_search`.

**Return type**

`BOOL`

**Examples**

In the following query, the value `2022-04-01` is found in the range
`[2022-01-01, 2023-01-01)`:

```zetasql
SELECT RANGE_CONTAINS(
  RANGE<DATE> '[2022-01-01, 2023-01-01)',
  DATE '2022-04-01') AS results;

/*---------+
 | results |
 +---------+
 | TRUE    |
 +---------*/
```

In the following query, the value `2023-04-01` isn't found in the range
`[2022-01-01, 2023-01-01)`:

```zetasql
SELECT RANGE_CONTAINS(
  RANGE<DATE> '[2022-01-01, 2023-01-01)',
  DATE '2023-04-01') AS results;

/*---------+
 | results |
 +---------+
 | FALSE   |
 +---------*/
```

[range_contains-sig1]: #signature_1

[range_contains-sig2]: #signature_2

### `RANGE_END`

```zetasql
RANGE_END(range_to_check)
```

**Description**

Gets the upper bound of a range.

**Definitions**

+   `range_to_check`: The `RANGE<T>` value.

**Details**

Returns `NULL` if the upper bound in `range_value` is `UNBOUNDED`.

Returns `NULL` if `range_to_check` is `NULL`.

**Return type**

`T` in `range_value`

**Examples**

In the following query, the upper bound of the range is retrieved:

```zetasql
SELECT RANGE_END(RANGE<DATE> '[2022-12-01, 2022-12-31)') AS results;

/*------------+
 | results    |
 +------------+
 | 2022-12-31 |
 +------------*/
```

In the following query, the upper bound of the range is unbounded, so
`NULL` is returned:

```zetasql
SELECT RANGE_END(RANGE<DATE> '[2022-12-01, UNBOUNDED)') AS results;

/*------------+
 | results    |
 +------------+
 | NULL       |
 +------------*/
```

### `RANGE_INTERSECT`

```zetasql
RANGE_INTERSECT(range_a, range_b)
```

**Description**

Gets a segment of two ranges that intersect.

**Definitions**

+   `range_a`: The first `RANGE<T>` value.
+   `range_b`: The second `RANGE<T>` value.

**Details**

Returns `NULL` if any input is` NULL`.

Produces an error if `range_a` and `range_b` don't overlap. To return
`NULL` instead, add the `SAFE.` prefix to the function name.

`T` must be of the same type for all inputs.

**Return type**

`RANGE<T>`

**Examples**

```zetasql
SELECT RANGE_INTERSECT(
  RANGE<DATE> '[2022-02-01, 2022-09-01)',
  RANGE<DATE> '[2021-06-15, 2022-04-15)') AS results;

/*--------------------------+
 | results                  |
 +--------------------------+
 | [2022-02-01, 2022-04-15) |
 +--------------------------*/
```

```zetasql
SELECT RANGE_INTERSECT(
  RANGE<DATE> '[2022-02-01, UNBOUNDED)',
  RANGE<DATE> '[2021-06-15, 2022-04-15)') AS results;

/*--------------------------+
 | results                  |
 +--------------------------+
 | [2022-02-01, 2022-04-15) |
 +--------------------------*/
```

```zetasql
SELECT RANGE_INTERSECT(
  RANGE<DATE> '[2022-02-01, UNBOUNDED)',
  RANGE<DATE> '[2021-06-15, UNBOUNDED)') AS results;

/*-------------------------+
 | results                 |
 +-------------------------+
 | [2022-02-01, UNBOUNDED) |
 +-------------------------*/
```

### `RANGE_OVERLAPS`

```zetasql
RANGE_OVERLAPS(range_a, range_b)
```

**Description**

Checks if two ranges overlap.

**Definitions**

+   `range_a`: The first `RANGE<T>` value.
+   `range_b`: The second `RANGE<T>` value.

**Details**

Returns `TRUE` if a part of `range_a` intersects with `range_b`, otherwise
returns `FALSE`.

`T` must be of the same type for all inputs.

To get the part of the range that overlaps, use the
[`RANGE_INTERSECT`][range-intersect] function.

**Return type**

`BOOL`

**Examples**

In the following query, the first and second ranges overlap between
`2022-02-01` and `2022-04-15`:

```zetasql
SELECT RANGE_OVERLAPS(
  RANGE<DATE> '[2022-02-01, 2022-09-01)',
  RANGE<DATE> '[2021-06-15, 2022-04-15)') AS results;

/*---------+
 | results |
 +---------+
 | TRUE    |
 +---------*/
```

In the following query, the first and second ranges don't overlap:

```zetasql
SELECT RANGE_OVERLAPS(
  RANGE<DATE> '[2020-02-01, 2020-09-01)',
  RANGE<DATE> '[2021-06-15, 2022-04-15)') AS results;

/*---------+
 | results |
 +---------+
 | FALSE   |
 +---------*/
```

In the following query, the first and second ranges overlap between
`2022-02-01` and `UNBOUNDED`:

```zetasql
SELECT RANGE_OVERLAPS(
  RANGE<DATE> '[2022-02-01, UNBOUNDED)',
  RANGE<DATE> '[2021-06-15, UNBOUNDED)') AS results;

/*---------+
 | results |
 +---------+
 | TRUE    |
 +---------*/
```

[range-intersect]: #range_intersect

### `RANGE_SESSIONIZE`

```zetasql
RANGE_SESSIONIZE(
  TABLE table_name,
  range_column,
  partitioning_columns
)
```

```zetasql
RANGE_SESSIONIZE(
  TABLE table_name,
  range_column,
  partitioning_columns,
  sessionize_option
)
```

**Description**

Produces a table of sessionized ranges.

**Definitions**

+   `table_name`: A table expression that represents the name of the table to
    construct. This can represent any relation with `range_column`.
+   `range_column`: A `STRING` literal that indicates which `RANGE` column
    in a table contains the data to sessionize.
+   `partitioning_columns`: An `ARRAY<STRING>` literal that indicates which
    columns should partition the data before the data is sessionized.
+   `sessionize_option`: A `STRING` value that describes how order-adjacent
    ranges are sessionized. Your choices are as follows:

    +   `MEETS` (default): Ranges that meet or overlap are sessionized.

    +   `OVERLAPS`: Only a range that's overlapped by another range is
        sessionized.

    If this argument isn't provided, `MEETS` is used by default.

**Details**

This function produces a table that includes all columns in the
input table and an additional `RANGE` column called
`session_range`, which indicates the start and end of a session. The
start and end of each session is determined by the `sessionize_option`
argument.

**Return type**

`TABLE`

**Examples**

The examples in this section reference the following table called
`my_sessionized_range_table` in a dataset called `mydataset`:

```zetasql
INSERT mydataset.my_sessionized_range_table (emp_id, dept_id, duration)
VALUES(10, 1000, RANGE<DATE> '[2010-01-10, 2010-03-10)'),
      (10, 2000, RANGE<DATE> '[2010-03-10, 2010-07-15)'),
      (10, 2000, RANGE<DATE> '[2010-06-15, 2010-08-18)'),
      (20, 2000, RANGE<DATE> '[2010-03-10, 2010-07-20)'),
      (20, 1000, RANGE<DATE> '[2020-05-10, 2020-09-20)');

SELECT * FROM mydataset.my_sessionized_range_table ORDER BY emp_id;

/*--------+---------+--------------------------+
 | emp_id | dept_id | duration                 |
 +--------+---------+--------------------------+
 | 10     | 1000    | [2010-01-10, 2010-03-10) |
 | 10     | 2000    | [2010-03-10, 2010-07-15) |
 | 10     | 2000    | [2010-06-15, 2010-08-18) |
 | 20     | 2000    | [2010-03-10, 2010-07-20) |
 | 20     | 1000    | [2020-05-10, 2020-09-20) |
 +--------+---------+--------------------------*/
```

In the following query, a table of sessionized data is produced for
`my_sessionized_range_table`, and only ranges that meet or overlap are
sessionized:

```zetasql
SELECT
  emp_id, duration, session_range
FROM
  RANGE_SESSIONIZE(
    TABLE mydataset.my_sessionized_range_table,
    'duration',
    ['emp_id'])
ORDER BY emp_id;

/*--------+--------------------------+--------------------------+
 | emp_id | duration                 | session_range            |
 +--------+--------------------------+--------------------------+
 | 10     | [2010-01-10, 2010-03-10) | [2010-01-10, 2010-08-18) |
 | 10     | [2010-03-10, 2010-07-15) | [2010-01-10, 2010-08-18) |
 | 10     | [2010-06-15, 2010-08-18) | [2010-01-10, 2010-08-18) |
 | 20     | [2010-03-10, 2010-07-20) | [2010-03-10, 2010-07-20) |
 | 20     | [2020-05-10, 2020-09-20) | [2020-05-10, 2020-09-20) |
 +--------+-----------------------------------------------------*/
```

In the following query, a table of sessionized data is produced for
`my_sessionized_range_table`, and only a range that's overlapped by another
range is sessionized:

```zetasql
SELECT
  emp_id, duration, session_range
FROM
  RANGE_SESSIONIZE(
    TABLE mydataset.my_sessionized_range_table,
    'duration',
    ['emp_id'],
    'OVERLAPS')
ORDER BY emp_id;

/*--------+--------------------------+--------------------------+
 | emp_id | duration                 | session_range            |
 +--------+--------------------------+--------------------------+
 | 10     | [2010-03-10, 2010-07-15) | [2010-03-10, 2010-08-18) |
 | 10     | [2010-06-15, 2010-08-18) | [2010-03-10, 2010-08-18) |
 | 10     | [2010-01-10, 2010-03-10) | [2010-01-10, 2010-03-10) |
 | 20     | [2020-05-10, 2020-09-20) | [2020-05-10, 2020-09-20) |
 | 20     | [2010-03-10, 2010-07-20) | [2010-03-10, 2010-07-20) |
 +--------+-----------------------------------------------------*/
```

If you need to normalize sessionized data, you can use a query similar to the
following:

```zetasql
SELECT emp_id, session_range AS normalized FROM (
  SELECT emp_id, session_range
  FROM RANGE_SESSIONIZE(
    TABLE mydataset.my_sessionized_range_table,
    'duration',
    ['emp_id'],
    'MEETS')
)
GROUP BY emp_id, normalized;

/*--------+--------------------------+
 | emp_id | normalized               |
 +--------+--------------------------+
 | 20     | [2010-03-10, 2010-07-20) |
 | 10     | [2010-01-10, 2010-08-18) |
 | 20     | [2020-05-10, 2020-09-20) |
 +--------+--------------------------*/
```

### `RANGE_START`

```zetasql
RANGE_START(range_to_check)
```

**Description**

Gets the lower bound of a range.

**Definitions**

+   `range_to_check`: The `RANGE<T>` value.

**Details**

Returns `NULL` if the lower bound of `range_value` is `UNBOUNDED`.

Returns `NULL` if `range_to_check` is `NULL`.

**Return type**

`T` in `range_value`

**Examples**

In the following query, the lower bound of the range is retrieved:

```zetasql
SELECT RANGE_START(RANGE<DATE> '[2022-12-01, 2022-12-31)') AS results;

/*------------+
 | results    |
 +------------+
 | 2022-12-01 |
 +------------*/
```

In the following query, the lower bound of the range is unbounded, so
`NULL` is returned:

```zetasql
SELECT RANGE_START(RANGE<DATE> '[UNBOUNDED, 2022-12-31)') AS results;

/*------------+
 | results    |
 +------------+
 | NULL       |
 +------------*/
```

## Security functions

ZetaSQL supports the following security functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#session_user"><code>SESSION_USER</code></a>
</td>
  <td>
    Get the email address or principal identifier of the user that's running
    the query.
  </td>
</tr>

  </tbody>
</table>

### `SESSION_USER`

```
SESSION_USER()
```

**Description**

For first-party users, returns the email address of the user that's running the
query.
For third-party users, returns the
[principal identifier](https://cloud.google.com/iam/docs/principal-identifiers)
of the user that's running the query.
For more information about identities, see
[Principals](https://cloud.google.com/docs/authentication#principal).

**Return Data Type**

`STRING`

**Example**

```zetasql
SELECT SESSION_USER() as user;

/*----------------------*
 | user                 |
 +----------------------+
 | jdoe@example.com     |
 *----------------------*/
```

## Statistical aggregate functions

ZetaSQL supports statistical aggregate functions.
To learn about the syntax for aggregate function calls, see
[Aggregate function calls][agg-function-calls].

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#corr"><code>CORR</code></a>
</td>
  <td>
    Computes the Pearson coefficient of correlation of a set of number pairs.
    
  </td>
</tr>

<tr>
  <td><a href="#covar_pop"><code>COVAR_POP</code></a>
</td>
  <td>
    Computes the population covariance of a set of number pairs.
    
  </td>
</tr>

<tr>
  <td><a href="#covar_samp"><code>COVAR_SAMP</code></a>
</td>
  <td>
    Computes the sample covariance of a set of number pairs.
    
  </td>
</tr>

<tr>
  <td><a href="#stddev"><code>STDDEV</code></a>
</td>
  <td>
    An alias of the <code>STDDEV_SAMP</code> function.
    
  </td>
</tr>

<tr>
  <td><a href="#stddev_pop"><code>STDDEV_POP</code></a>
</td>
  <td>
    Computes the population (biased) standard deviation of the values.
    
  </td>
</tr>

<tr>
  <td><a href="#stddev_samp"><code>STDDEV_SAMP</code></a>
</td>
  <td>
    Computes the sample (unbiased) standard deviation of the values.
    
  </td>
</tr>

<tr>
  <td><a href="#var_pop"><code>VAR_POP</code></a>
</td>
  <td>
    Computes the population (biased) variance of the values.
    
  </td>
</tr>

<tr>
  <td><a href="#var_samp"><code>VAR_SAMP</code></a>
</td>
  <td>
    Computes the sample (unbiased) variance of the values.
    
  </td>
</tr>

<tr>
  <td><a href="#variance"><code>VARIANCE</code></a>
</td>
  <td>
    An alias of <code>VAR_SAMP</code>.
    
  </td>
</tr>

  </tbody>
</table>

### `CORR`

```zetasql
CORR(
  X1, X2
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns the [Pearson coefficient][stat-agg-link-to-pearson-coefficient]
of correlation of a set of number pairs. For each number pair, the first number
is the dependent variable and the second number is the independent variable.
The return result is between `-1` and `1`. A result of `0` indicates no
correlation.

All numeric types are supported. If the
input is `NUMERIC` or `BIGNUMERIC` then the internal aggregation is
stable with the final output converted to a `DOUBLE`.
Otherwise the input is converted to a `DOUBLE`
before aggregation, resulting in a potentially unstable result.

This function ignores any input pairs that contain one or more `NULL` values. If
there are fewer than two input pairs without `NULL` values, this function
returns `NULL`.

`NaN` is produced if:

+ Any input value is `NaN`
+ Any input value is positive infinity or negative infinity.
+ The variance of `X1` or `X2` is `0`.
+ The covariance of `X1` and `X2` is `0`.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Return Data Type**

`DOUBLE`

**Examples**

```zetasql
SELECT CORR(y, x) AS results
FROM
  UNNEST(
    [
      STRUCT(1.0 AS y, 5.0 AS x),
      (3.0, 9.0),
      (4.0, 7.0)]);

/*--------------------*
 | results            |
 +--------------------+
 | 0.6546536707079772 |
 *--------------------*/
```

```zetasql
SELECT CORR(y, x) AS results
FROM
  UNNEST(
    [
      STRUCT(1.0 AS y, 5.0 AS x),
      (3.0, 9.0),
      (4.0, NULL)]);

/*---------*
 | results |
 +---------+
 | 1       |
 *---------*/
```

```zetasql
SELECT CORR(y, x) AS results
FROM UNNEST([STRUCT(1.0 AS y, NULL AS x),(9.0, 3.0)])

/*---------*
 | results |
 +---------+
 | NULL    |
 *---------*/
```

```zetasql
SELECT CORR(y, x) AS results
FROM UNNEST([STRUCT(1.0 AS y, NULL AS x),(9.0, NULL)])

/*---------*
 | results |
 +---------+
 | NULL    |
 *---------*/
```

```zetasql
SELECT CORR(y, x) AS results
FROM
  UNNEST(
    [
      STRUCT(1.0 AS y, 5.0 AS x),
      (3.0, 9.0),
      (4.0, 7.0),
      (5.0, 1.0),
      (7.0, CAST('Infinity' as DOUBLE))])

/*---------*
 | results |
 +---------+
 | NaN     |
 *---------*/
```

```zetasql
SELECT CORR(x, y) AS results
FROM
  (
    SELECT 0 AS x, 0 AS y
    UNION ALL
    SELECT 0 AS x, 0 AS y
  )

/*---------*
 | results |
 +---------+
 | NaN     |
 *---------*/
```

[stat-agg-link-to-pearson-coefficient]: https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient

### `COVAR_POP`

```zetasql
COVAR_POP(
  X1, X2
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns the population [covariance][stat-agg-link-to-covariance] of
a set of number pairs. The first number is the dependent variable; the second
number is the independent variable. The return result is between `-Inf` and
`+Inf`.

All numeric types are supported. If the
input is `NUMERIC` or `BIGNUMERIC` then the internal aggregation is
stable with the final output converted to a `DOUBLE`.
Otherwise the input is converted to a `DOUBLE`
before aggregation, resulting in a potentially unstable result.

This function ignores any input pairs that contain one or more `NULL` values. If
there is no input pair without `NULL` values, this function returns `NULL`.
If there is exactly one input pair without `NULL` values, this function returns
`0`.

`NaN` is produced if:

+ Any input value is `NaN`
+ Any input value is positive infinity or negative infinity.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Return Data Type**

`DOUBLE`

**Examples**

```zetasql
SELECT COVAR_POP(y, x) AS results
FROM
  UNNEST(
    [
      STRUCT(1.0 AS y, 1.0 AS x),
      (2.0, 6.0),
      (9.0, 3.0),
      (2.0, 6.0),
      (9.0, 3.0)])

/*---------------------*
 | results             |
 +---------------------+
 | -1.6800000000000002 |
 *---------------------*/
```

```zetasql
SELECT COVAR_POP(y, x) AS results
FROM UNNEST([STRUCT(1.0 AS y, NULL AS x),(9.0, 3.0)])

/*---------*
 | results |
 +---------+
 | 0       |
 *---------*/
```

```zetasql
SELECT COVAR_POP(y, x) AS results
FROM UNNEST([STRUCT(1.0 AS y, NULL AS x),(9.0, NULL)])

/*---------*
 | results |
 +---------+
 | NULL    |
 *---------*/
```

```zetasql
SELECT COVAR_POP(y, x) AS results
FROM
  UNNEST(
    [
      STRUCT(1.0 AS y, 1.0 AS x),
      (2.0, 6.0),
      (9.0, 3.0),
      (2.0, 6.0),
      (NULL, 3.0)])

/*---------*
 | results |
 +---------+
 | -1      |
 *---------*/
```

```zetasql
SELECT COVAR_POP(y, x) AS results
FROM
  UNNEST(
    [
      STRUCT(1.0 AS y, 1.0 AS x),
      (2.0, 6.0),
      (9.0, 3.0),
      (2.0, 6.0),
      (CAST('Infinity' as DOUBLE), 3.0)])

/*---------*
 | results |
 +---------+
 | NaN     |
 *---------*/
```

[stat-agg-link-to-covariance]: https://en.wikipedia.org/wiki/Covariance

### `COVAR_SAMP`

```zetasql
COVAR_SAMP(
  X1, X2
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns the sample [covariance][stat-agg-link-to-covariance] of a
set of number pairs. The first number is the dependent variable; the second
number is the independent variable. The return result is between `-Inf` and
`+Inf`.

All numeric types are supported. If the
input is `NUMERIC` or `BIGNUMERIC` then the internal aggregation is
stable with the final output converted to a `DOUBLE`.
Otherwise the input is converted to a `DOUBLE`
before aggregation, resulting in a potentially unstable result.

This function ignores any input pairs that contain one or more `NULL` values. If
there are fewer than two input pairs without `NULL` values, this function
returns `NULL`.

`NaN` is produced if:

+ Any input value is `NaN`
+ Any input value is positive infinity or negative infinity.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

This function can be used with the
[`AGGREGATION_THRESHOLD` clause][agg-threshold-clause].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

[agg-threshold-clause]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#agg_threshold_clause

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Return Data Type**

`DOUBLE`

**Examples**

```zetasql
SELECT COVAR_SAMP(y, x) AS results
FROM
  UNNEST(
    [
      STRUCT(1.0 AS y, 1.0 AS x),
      (2.0, 6.0),
      (9.0, 3.0),
      (2.0, 6.0),
      (9.0, 3.0)])

/*---------*
 | results |
 +---------+
 | -2.1    |
 *---------*/
```

```zetasql
SELECT COVAR_SAMP(y, x) AS results
FROM
  UNNEST(
    [
      STRUCT(1.0 AS y, 1.0 AS x),
      (2.0, 6.0),
      (9.0, 3.0),
      (2.0, 6.0),
      (NULL, 3.0)])

/*----------------------*
 | results              |
 +----------------------+
 | --1.3333333333333333 |
 *----------------------*/
```

```zetasql
SELECT COVAR_SAMP(y, x) AS results
FROM UNNEST([STRUCT(1.0 AS y, NULL AS x),(9.0, 3.0)])

/*---------*
 | results |
 +---------+
 | NULL    |
 *---------*/
```

```zetasql
SELECT COVAR_SAMP(y, x) AS results
FROM UNNEST([STRUCT(1.0 AS y, NULL AS x),(9.0, NULL)])

/*---------*
 | results |
 +---------+
 | NULL    |
 *---------*/
```

```zetasql
SELECT COVAR_SAMP(y, x) AS results
FROM
  UNNEST(
    [
      STRUCT(1.0 AS y, 1.0 AS x),
      (2.0, 6.0),
      (9.0, 3.0),
      (2.0, 6.0),
      (CAST('Infinity' as DOUBLE), 3.0)])

/*---------*
 | results |
 +---------+
 | NaN     |
 *---------*/
```

[stat-agg-link-to-covariance]: https://en.wikipedia.org/wiki/Covariance

### `STDDEV`

```zetasql
STDDEV(
  [ DISTINCT ]
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

An alias of [STDDEV_SAMP][stat-agg-link-to-stddev-samp].

[stat-agg-link-to-stddev-samp]: #stddev_samp

### `STDDEV_POP`

```zetasql
STDDEV_POP(
  [ DISTINCT ]
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns the population (biased) standard deviation of the values. The return
result is between `0` and `+Inf`.

All numeric types are supported. If the
input is `NUMERIC` or `BIGNUMERIC` then the internal aggregation is
stable with the final output converted to a `DOUBLE`.
Otherwise the input is converted to a `DOUBLE`
before aggregation, resulting in a potentially unstable result.

This function ignores any `NULL` inputs. If all inputs are ignored, this
function returns `NULL`. If this function receives a single non-`NULL` input,
it returns `0`.

`NaN` is produced if:

+ Any input value is `NaN`
+ Any input value is positive infinity or negative infinity.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

This function can be used with the
[`AGGREGATION_THRESHOLD` clause][agg-threshold-clause].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

[agg-threshold-clause]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#agg_threshold_clause

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

`STDDEV_POP` can be used with differential privacy. To learn more, see
[Differentially private aggregate functions][dp-functions].

**Return Data Type**

`DOUBLE`

**Examples**

```zetasql
SELECT STDDEV_POP(x) AS results FROM UNNEST([10, 14, 18]) AS x

/*-------------------*
 | results           |
 +-------------------+
 | 3.265986323710904 |
 *-------------------*/
```

```zetasql
SELECT STDDEV_POP(x) AS results FROM UNNEST([10, 14, NULL]) AS x

/*---------*
 | results |
 +---------+
 | 2       |
 *---------*/
```

```zetasql
SELECT STDDEV_POP(x) AS results FROM UNNEST([10, NULL]) AS x

/*---------*
 | results |
 +---------+
 | 0       |
 *---------*/
```

```zetasql
SELECT STDDEV_POP(x) AS results FROM UNNEST([NULL]) AS x

/*---------*
 | results |
 +---------+
 | NULL    |
 *---------*/
```

```zetasql
SELECT STDDEV_POP(x) AS results FROM UNNEST([10, 14, CAST('Infinity' as DOUBLE)]) AS x

/*---------*
 | results |
 +---------+
 | NaN     |
 *---------*/
```

[dp-functions]: #aggregate-dp-functions

### `STDDEV_SAMP`

```zetasql
STDDEV_SAMP(
  [ DISTINCT ]
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns the sample (unbiased) standard deviation of the values. The return
result is between `0` and `+Inf`.

All numeric types are supported. If the
input is `NUMERIC` or `BIGNUMERIC` then the internal aggregation is
stable with the final output converted to a `DOUBLE`.
Otherwise the input is converted to a `DOUBLE`
before aggregation, resulting in a potentially unstable result.

This function ignores any `NULL` inputs. If there are fewer than two non-`NULL`
inputs, this function returns `NULL`.

`NaN` is produced if:

+ Any input value is `NaN`
+ Any input value is positive infinity or negative infinity.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

This function can be used with the
[`AGGREGATION_THRESHOLD` clause][agg-threshold-clause].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

[agg-threshold-clause]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#agg_threshold_clause

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Return Data Type**

`DOUBLE`

**Examples**

```zetasql
SELECT STDDEV_SAMP(x) AS results FROM UNNEST([10, 14, 18]) AS x

/*---------*
 | results |
 +---------+
 | 4       |
 *---------*/
```

```zetasql
SELECT STDDEV_SAMP(x) AS results FROM UNNEST([10, 14, NULL]) AS x

/*--------------------*
 | results            |
 +--------------------+
 | 2.8284271247461903 |
 *--------------------*/
```

```zetasql
SELECT STDDEV_SAMP(x) AS results FROM UNNEST([10, NULL]) AS x

/*---------*
 | results |
 +---------+
 | NULL    |
 *---------*/
```

```zetasql
SELECT STDDEV_SAMP(x) AS results FROM UNNEST([NULL]) AS x

/*---------*
 | results |
 +---------+
 | NULL    |
 *---------*/
```

```zetasql
SELECT STDDEV_SAMP(x) AS results FROM UNNEST([10, 14, CAST('Infinity' as DOUBLE)]) AS x

/*---------*
 | results |
 +---------+
 | NaN     |
 *---------*/
```

### `VAR_POP`

```zetasql
VAR_POP(
  [ DISTINCT ]
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns the population (biased) variance of the values. The return result is
between `0` and `+Inf`.

All numeric types are supported. If the
input is `NUMERIC` or `BIGNUMERIC` then the internal aggregation is
stable with the final output converted to a `DOUBLE`.
Otherwise the input is converted to a `DOUBLE`
before aggregation, resulting in a potentially unstable result.

This function ignores any `NULL` inputs. If all inputs are ignored, this
function returns `NULL`. If this function receives a single non-`NULL` input,
it returns `0`.

`NaN` is produced if:

+ Any input value is `NaN`
+ Any input value is positive infinity or negative infinity.

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

`VAR_POP` can be used with differential privacy. To learn more, see
[Differentially private aggregate functions][dp-functions].

**Return Data Type**

`DOUBLE`

**Examples**

```zetasql
SELECT VAR_POP(x) AS results FROM UNNEST([10, 14, 18]) AS x

/*--------------------*
 | results            |
 +--------------------+
 | 10.666666666666666 |
 *--------------------*/
```

```zetasql
SELECT VAR_POP(x) AS results FROM UNNEST([10, 14, NULL]) AS x

/*----------*
 | results |
 +---------+
 | 4       |
 *---------*/
```

```zetasql
SELECT VAR_POP(x) AS results FROM UNNEST([10, NULL]) AS x

/*----------*
 | results |
 +---------+
 | 0       |
 *---------*/
```

```zetasql
SELECT VAR_POP(x) AS results FROM UNNEST([NULL]) AS x

/*---------*
 | results |
 +---------+
 | NULL    |
 *---------*/
```

```zetasql
SELECT VAR_POP(x) AS results FROM UNNEST([10, 14, CAST('Infinity' as DOUBLE)]) AS x

/*---------*
 | results |
 +---------+
 | NaN     |
 *---------*/
```

[dp-functions]: #aggregate-dp-functions

### `VAR_SAMP`

```zetasql
VAR_SAMP(
  [ DISTINCT ]
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

Returns the sample (unbiased) variance of the values. The return result is
between `0` and `+Inf`.

All numeric types are supported. If the
input is `NUMERIC` or `BIGNUMERIC` then the internal aggregation is
stable with the final output converted to a `DOUBLE`.
Otherwise the input is converted to a `DOUBLE`
before aggregation, resulting in a potentially unstable result.

This function ignores any `NULL` inputs. If there are fewer than two non-`NULL`
inputs, this function returns `NULL`.

`NaN` is produced if:

+ Any input value is `NaN`
+ Any input value is positive infinity or negative infinity.

To learn more about the optional aggregate clauses that you can pass
into this function, see
[Aggregate function calls][aggregate-function-calls].

This function can be used with the
[`AGGREGATION_THRESHOLD` clause][agg-threshold-clause].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[aggregate-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

[agg-threshold-clause]: https://github.com/google/zetasql/blob/master/docs/query-syntax.md#agg_threshold_clause

<!-- mdlint on -->

To learn more about the `OVER` clause and how to use it, see
[Window function calls][window-function-calls].

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- mdlint on -->

**Return Data Type**

`DOUBLE`

**Examples**

```zetasql
SELECT VAR_SAMP(x) AS results FROM UNNEST([10, 14, 18]) AS x

/*---------*
 | results |
 +---------+
 | 16      |
 *---------*/
```

```zetasql
SELECT VAR_SAMP(x) AS results FROM UNNEST([10, 14, NULL]) AS x

/*---------*
 | results |
 +---------+
 | 8       |
 *---------*/
```

```zetasql
SELECT VAR_SAMP(x) AS results FROM UNNEST([10, NULL]) AS x

/*---------*
 | results |
 +---------+
 | NULL    |
 *---------*/
```

```zetasql
SELECT VAR_SAMP(x) AS results FROM UNNEST([NULL]) AS x

/*---------*
 | results |
 +---------+
 | NULL    |
 *---------*/
```

```zetasql
SELECT VAR_SAMP(x) AS results FROM UNNEST([10, 14, CAST('Infinity' as DOUBLE)]) AS x

/*---------*
 | results |
 +---------+
 | NaN     |
 *---------*/
```

### `VARIANCE`

```zetasql
VARIANCE(
  [ DISTINCT ]
  expression
  [ HAVING { MAX | MIN } expression2 ]
)
[ OVER over_clause ]

over_clause:
  { named_window | ( [ window_specification ] ) }

window_specification:
  [ named_window ]
  [ PARTITION BY partition_expression [, ...] ]
  [ ORDER BY expression [ { ASC | DESC }  ] [, ...] ]
  [ window_frame_clause ]

```

**Description**

An alias of [VAR_SAMP][stat-agg-link-to-var-samp].

[stat-agg-link-to-var-samp]: #var_samp

[agg-function-calls]: https://github.com/google/zetasql/blob/master/docs/aggregate-function-calls.md

## String functions

ZetaSQL supports string functions.
These string functions work on two different values:
`STRING` and `BYTES` data types. `STRING` values must be well-formed UTF-8.

Functions that return position values, such as [STRPOS][string-link-to-strpos],
encode those positions as `INT64`. The value `1`
refers to the first character (or byte), `2` refers to the second, and so on.
The value `0` indicates an invalid position. When working on `STRING` types, the
returned positions refer to character positions.

All string comparisons are done byte-by-byte, without regard to Unicode
canonical equivalence.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#array_to_string"><code>ARRAY_TO_STRING</code></a>
</td>
  <td>
    Produces a concatenation of the elements in an array as a
    <code>STRING</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/array_functions.md">Array functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#ascii"><code>ASCII</code></a>
</td>
  <td>
    Gets the ASCII code for the first character or byte in a <code>STRING</code>
    or <code>BYTES</code> value.
  </td>
</tr>

<tr>
  <td><a href="#byte_length"><code>BYTE_LENGTH</code></a>
</td>
  <td>
    Gets the number of <code>BYTES</code> in a <code>STRING</code> or
    <code>BYTES</code> value.
  </td>
</tr>

<tr>
  <td><a href="#char_length"><code>CHAR_LENGTH</code></a>
</td>
  <td>
    Gets the number of characters in a <code>STRING</code> value.
  </td>
</tr>

<tr>
  <td><a href="#character_length"><code>CHARACTER_LENGTH</code></a>
</td>
  <td>
    Synonym for <code>CHAR_LENGTH</code>.
  </td>
</tr>

<tr>
  <td><a href="#chr"><code>CHR</code></a>
</td>
  <td>
    Converts a Unicode code point to a character.
    
  </td>
</tr>

<tr>
  <td><a href="#code_points_to_bytes"><code>CODE_POINTS_TO_BYTES</code></a>
</td>
  <td>
    Converts an array of extended ASCII code points to a
    <code>BYTES</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#code_points_to_string"><code>CODE_POINTS_TO_STRING</code></a>
</td>
  <td>
    Converts an array of extended ASCII code points to a
    <code>STRING</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#collate"><code>COLLATE</code></a>
</td>
  <td>
    Combines a <code>STRING</code> value and a collation specification into a
    collation specification-supported <code>STRING</code> value.
  </td>
</tr>

<tr>
  <td><a href="#concat"><code>CONCAT</code></a>
</td>
  <td>
    Concatenates one or more <code>STRING</code> or <code>BYTES</code>
    values into a single result.
  </td>
</tr>

<tr>
  <td><a href="#edit_distance"><code>EDIT_DISTANCE</code></a>
</td>
  <td>
    Computes the Levenshtein distance between two <code>STRING</code>
    or <code>BYTES</code> values.
  </td>
</tr>

<tr>
  <td><a href="#ends_with"><code>ENDS_WITH</code></a>
</td>
  <td>
    Checks if a <code>STRING</code> or <code>BYTES</code> value is the suffix
    of another value.
  </td>
</tr>

<tr>
  <td><a href="#format_string"><code>FORMAT</code></a>
</td>
  <td>
    Formats data and produces the results as a <code>STRING</code> value.
  </td>
</tr>

<tr>
  <td><a href="#from_base32"><code>FROM_BASE32</code></a>
</td>
  <td>
    Converts a base32-encoded <code>STRING</code> value into a
    <code>BYTES</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#from_base64"><code>FROM_BASE64</code></a>
</td>
  <td>
    Converts a base64-encoded <code>STRING</code> value into a
    <code>BYTES</code> value.
    

  </td>
</tr>

<tr>
  <td><a href="#from_hex"><code>FROM_HEX</code></a>
</td>
  <td>
    Converts a hexadecimal-encoded <code>STRING</code> value into a
    <code>BYTES</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#initcap"><code>INITCAP</code></a>
</td>
  <td>
    Formats a <code>STRING</code> as proper case, which means that the first
    character in each word is uppercase and all other characters are lowercase.
  </td>
</tr>

<tr>
  <td><a href="#instr"><code>INSTR</code></a>
</td>
  <td>
    Finds the position of a subvalue inside another value, optionally starting
    the search at a given offset or occurrence.
  </td>
</tr>

<tr>
  <td><a href="#lax_string"><code>LAX_STRING</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a SQL <code>STRING</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lax_string_array"><code>LAX_STRING_ARRAY</code></a>
</td>
  <td>
    Attempts to convert a JSON value to a
    SQL <code>ARRAY&lt;STRING&gt;</code>value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#left"><code>LEFT</code></a>
</td>
  <td>
    Gets the specified leftmost portion from a <code>STRING</code> or
    <code>BYTES</code> value.
  </td>
</tr>

<tr>
  <td><a href="#length"><code>LENGTH</code></a>
</td>
  <td>
    Gets the length of a <code>STRING</code> or <code>BYTES</code> value.
  </td>
</tr>

<tr>
  <td><a href="#lower"><code>LOWER</code></a>
</td>
  <td>
    Formats alphabetic characters in a <code>STRING</code> value as
    lowercase.
    <br /><br />
    Formats ASCII characters in a <code>BYTES</code> value as
    lowercase.
  </td>
</tr>

<tr>
  <td><a href="#lpad"><code>LPAD</code></a>
</td>
  <td>
    Prepends a <code>STRING</code> or <code>BYTES</code> value with a pattern.
  </td>
</tr>

<tr>
  <td><a href="#ltrim"><code>LTRIM</code></a>
</td>
  <td>
    Identical to the <code>TRIM</code> function, but only removes leading
    characters.
  </td>
</tr>

<tr>
  <td><a href="#normalize"><code>NORMALIZE</code></a>
</td>
  <td>
    Case-sensitively normalizes the characters in a <code>STRING</code> value.
  </td>
</tr>

<tr>
  <td><a href="#normalize_and_casefold"><code>NORMALIZE_AND_CASEFOLD</code></a>
</td>
  <td>
    Case-insensitively normalizes the characters in a <code>STRING</code> value.
  </td>
</tr>

<tr>
  <td><a href="#octet_length"><code>OCTET_LENGTH</code></a>
</td>
  <td>
    Alias for <code>BYTE_LENGTH</code>.
  </td>
</tr>

<tr>
  <td><a href="#regexp_contains"><code>REGEXP_CONTAINS</code></a>
</td>
  <td>
    Checks if a value is a partial match for a regular expression.
  </td>
</tr>

<tr>
  <td><a href="#regexp_extract"><code>REGEXP_EXTRACT</code></a>
</td>
  <td>
    Produces a substring that matches a regular expression.
  </td>
</tr>

<tr>
  <td><a href="#regexp_extract_all"><code>REGEXP_EXTRACT_ALL</code></a>
</td>
  <td>
    Produces an array of all substrings that match a
    regular expression.
  </td>
</tr>

<tr>
  <td><a href="#regexp_instr"><code>REGEXP_INSTR</code></a>
</td>
  <td>
    Finds the position of a regular expression match in a value, optionally
    starting the search at a given offset or occurrence.
  </td>
</tr>

<tr>
  <td><a href="#regexp_match"><code>REGEXP_MATCH</code></a>
</td>
  <td>
    (Deprecated) Checks if a value is a full match for a regular expression.
  </td>
</tr>

<tr>
  <td><a href="#regexp_replace"><code>REGEXP_REPLACE</code></a>
</td>
  <td>
    Produces a <code>STRING</code> value where all substrings that match a
    regular expression are replaced with a specified value.
  </td>
</tr>

<tr>
  <td><a href="#regexp_substr"><code>REGEXP_SUBSTR</code></a>
</td>
  <td>
    Synonym for <code>REGEXP_EXTRACT</code>.
  </td>
</tr>

<tr>
  <td><a href="#repeat"><code>REPEAT</code></a>
</td>
  <td>
    Produces a <code>STRING</code> or <code>BYTES</code> value that consists of
    an original value, repeated.
  </td>
</tr>

<tr>
  <td><a href="#replace"><code>REPLACE</code></a>
</td>
  <td>
    Replaces all occurrences of a pattern with another pattern in a
    <code>STRING</code> or <code>BYTES</code> value.
  </td>
</tr>

<tr>
  <td><a href="#reverse"><code>REVERSE</code></a>
</td>
  <td>
    Reverses a <code>STRING</code> or <code>BYTES</code> value.
  </td>
</tr>

<tr>
  <td><a href="#right"><code>RIGHT</code></a>
</td>
  <td>
    Gets the specified rightmost portion from a <code>STRING</code> or
    <code>BYTES</code> value.
  </td>
</tr>

<tr>
  <td><a href="#rpad"><code>RPAD</code></a>
</td>
  <td>
    Appends a <code>STRING</code> or <code>BYTES</code> value with a pattern.
  </td>
</tr>

<tr>
  <td><a href="#rtrim"><code>RTRIM</code></a>
</td>
  <td>
    Identical to the <code>TRIM</code> function, but only removes trailing
    characters.
  </td>
</tr>

<tr>
  <td><a href="#safe_convert_bytes_to_string"><code>SAFE_CONVERT_BYTES_TO_STRING</code></a>
</td>
  <td>
    Converts a <code>BYTES</code> value to a <code>STRING</code> value and
    replace any invalid UTF-8 characters with the Unicode replacement character,
    <code>U+FFFD</code>.
    
  </td>
</tr>

<tr>
  <td><a href="#soundex"><code>SOUNDEX</code></a>
</td>
  <td>
    Gets the Soundex codes for words in a <code>STRING</code> value.
  </td>
</tr>

<tr>
  <td><a href="#split"><code>SPLIT</code></a>
</td>
  <td>
    Splits a <code>STRING</code> or <code>BYTES</code> value, using a delimiter.
  </td>
</tr>

<tr>
  <td><a href="#split_substr"><code>SPLIT_SUBSTR</code></a>
</td>
  <td>
    Returns the substring from an input string that's determined by a delimiter, a
    location that indicates the first split of the substring to return, and the
    number of splits to include.
  </td>
</tr>

<tr>
  <td><a href="#starts_with"><code>STARTS_WITH</code></a>
</td>
  <td>
    Checks if a <code>STRING</code> or <code>BYTES</code> value is a
    prefix of another value.
  </td>
</tr>

<tr>
  <td><a href="#string_for_json"><code>STRING</code> (JSON)</a>
</td>
  <td>
    Converts a JSON string to a SQL <code>STRING</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#string_array_for_json"><code>STRING_ARRAY</code></a>
</td>
  <td>
    Converts a JSON array of strings to a SQL <code>ARRAY&lt;STRING&gt;</code>
    value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/json_functions.md">JSON functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#string"><code>STRING</code> (Timestamp)</a>
</td>
  <td>
    Converts a <code>TIMESTAMP</code> value to a <code>STRING</code> value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/timestamp_functions.md">Timestamp functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#string_agg"><code>STRING_AGG</code></a>
</td>
  <td>
    Concatenates non-<code>NULL</code> <code>STRING</code> or
    <code>BYTES</code> values.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/aggregate_functions.md">Aggregate functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#strpos"><code>STRPOS</code></a>
</td>
  <td>
    Finds the position of the first occurrence of a subvalue inside another
    value.
  </td>
</tr>

<tr>
  <td><a href="#substr"><code>SUBSTR</code></a>
</td>
  <td>
    Gets a portion of a <code>STRING</code> or <code>BYTES</code> value.
  </td>
</tr>

<tr>
  <td><a href="#substring"><code>SUBSTRING</code></a>
</td>
  <td>Alias for <code>SUBSTR</code></td>
</tr>

<tr>
  <td><a href="#to_base32"><code>TO_BASE32</code></a>
</td>
  <td>
    Converts a <code>BYTES</code> value to a
    base32-encoded <code>STRING</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#to_base64"><code>TO_BASE64</code></a>
</td>
  <td>
    Converts a <code>BYTES</code> value to a
    base64-encoded <code>STRING</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#to_code_points"><code>TO_CODE_POINTS</code></a>
</td>
  <td>
    Converts a <code>STRING</code> or <code>BYTES</code> value into an array of
    extended ASCII code points.
    
  </td>
</tr>

<tr>
  <td><a href="#to_hex"><code>TO_HEX</code></a>
</td>
  <td>
    Converts a <code>BYTES</code> value to a
    hexadecimal <code>STRING</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#translate"><code>TRANSLATE</code></a>
</td>
  <td>
    Within a value, replaces each source character with the corresponding
    target character.
  </td>
</tr>

<tr>
  <td><a href="#trim"><code>TRIM</code></a>
</td>
  <td>
    Removes the specified leading and trailing Unicode code points or bytes
    from a <code>STRING</code> or <code>BYTES</code> value.
  </td>
</tr>

<tr>
  <td><a href="#unicode"><code>UNICODE</code></a>
</td>
  <td>
    Gets the Unicode code point for the first character in a value.
  </td>
</tr>

<tr>
  <td><a href="#upper"><code>UPPER</code></a>
</td>
  <td>
    Formats alphabetic characters in a <code>STRING</code> value as
    uppercase.
    <br /><br />
    Formats ASCII characters in a <code>BYTES</code> value as
    uppercase.
  </td>
</tr>

  </tbody>
</table>

### `ASCII`

```zetasql
ASCII(value)
```

**Description**

Returns the ASCII code for the first character or byte in `value`. Returns
`0` if `value` is empty or the ASCII code is `0` for the first character
or byte.

**Return type**

`INT64`

**Examples**

```zetasql
SELECT ASCII('abcd') as A, ASCII('a') as B, ASCII('') as C, ASCII(NULL) as D;

/*-------+-------+-------+-------*
 | A     | B     | C     | D     |
 +-------+-------+-------+-------+
 | 97    | 97    | 0     | NULL  |
 *-------+-------+-------+-------*/
```

### `BYTE_LENGTH`

```zetasql
BYTE_LENGTH(value)
```

**Description**

Gets the number of `BYTES` in a `STRING` or `BYTES` value,
regardless of whether the value is a `STRING` or `BYTES` type.

**Return type**

`INT64`

**Examples**

```zetasql
SELECT BYTE_LENGTH('') AS string_example;

/*----------------*
 | string_example |
 +----------------+
 | 10             |
 *----------------*/
```

```zetasql
SELECT BYTE_LENGTH(b'') AS bytes_example;

/*----------------*
 | bytes_example  |
 +----------------+
 | 10             |
 *----------------*/
```

### `CHAR_LENGTH`

```zetasql
CHAR_LENGTH(value)
```

**Description**

Gets the number of characters in a `STRING` value.

**Return type**

`INT64`

**Examples**

```zetasql
SELECT CHAR_LENGTH('') AS char_length;

/*-------------*
 | char_length |
 +-------------+
 | 5           |
 *------------ */
```

### `CHARACTER_LENGTH`

```zetasql
CHARACTER_LENGTH(value)
```

**Description**

Synonym for [CHAR_LENGTH][string-link-to-char-length].

**Return type**

`INT64`

**Examples**

```zetasql
SELECT
  '' AS characters,
  CHARACTER_LENGTH('') AS char_length_example

/*------------+---------------------*
 | characters | char_length_example |
 +------------+---------------------+
 |       |                   5 |
 *------------+---------------------*/
```

[string-link-to-char-length]: #char_length

### `CHR`

```zetasql
CHR(value)
```

**Description**

Takes a Unicode [code point][string-link-to-code-points-wikipedia] and returns
the character that matches the code point. Each valid code point should fall
within the range of [0, 0xD7FF] and [0xE000, 0x10FFFF]. Returns an empty string
if the code point is `0`. If an invalid Unicode code point is specified, an
error is returned.

To work with an array of Unicode code points, see
[`CODE_POINTS_TO_STRING`][string-link-to-codepoints-to-string]

**Return type**

`STRING`

**Examples**

```zetasql
SELECT CHR(65) AS A, CHR(255) AS B, CHR(513) AS C, CHR(1024)  AS D;

/*-------+-------+-------+-------*
 | A     | B     | C     | D     |
 +-------+-------+-------+-------+
 | A     |      |      |      |
 *-------+-------+-------+-------*/
```

```zetasql
SELECT CHR(97) AS A, CHR(0xF9B5) AS B, CHR(0) AS C, CHR(NULL) AS D;

/*-------+-------+-------+-------*
 | A     | B     | C     | D     |
 +-------+-------+-------+-------+
 | a     |     |       | NULL  |
 *-------+-------+-------+-------*/
```

[string-link-to-code-points-wikipedia]: https://en.wikipedia.org/wiki/Code_point

[string-link-to-codepoints-to-string]: #code_points_to_string

### `CODE_POINTS_TO_BYTES`

```zetasql
CODE_POINTS_TO_BYTES(ascii_code_points)
```

**Description**

Takes an array of extended ASCII
[code points][string-link-to-code-points-wikipedia]
as `ARRAY<INT64>` and returns `BYTES`.

To convert from `BYTES` to an array of code points, see
[TO_CODE_POINTS][string-link-to-code-points].

**Return type**

`BYTES`

**Examples**

The following is a basic example using `CODE_POINTS_TO_BYTES`.

```zetasql
SELECT CODE_POINTS_TO_BYTES([65, 98, 67, 100]) AS bytes;

/*----------*
 | bytes    |
 +----------+
 | AbCd     |
 *----------*/
```

The following example uses a rotate-by-13 places (ROT13) algorithm to encode a
string.

```zetasql
SELECT CODE_POINTS_TO_BYTES(ARRAY_AGG(
  (SELECT
      CASE
        WHEN chr BETWEEN b'a' and b'z'
          THEN TO_CODE_POINTS(b'a')[offset(0)] +
            MOD(code+13-TO_CODE_POINTS(b'a')[offset(0)],26)
        WHEN chr BETWEEN b'A' and b'Z'
          THEN TO_CODE_POINTS(b'A')[offset(0)] +
            MOD(code+13-TO_CODE_POINTS(b'A')[offset(0)],26)
        ELSE code
      END
   FROM
     (SELECT code, CODE_POINTS_TO_BYTES([code]) chr)
  ) ORDER BY OFFSET)) AS encoded_string
FROM UNNEST(TO_CODE_POINTS(b'Test String!')) code WITH OFFSET;

/*------------------*
 | encoded_string   |
 +------------------+
 | Grfg Fgevat!     |
 *------------------*/
```

[string-link-to-code-points-wikipedia]: https://en.wikipedia.org/wiki/Code_point

[string-link-to-code-points]: #to_code_points

### `CODE_POINTS_TO_STRING`

```zetasql
CODE_POINTS_TO_STRING(unicode_code_points)
```

**Description**

Takes an array of Unicode [code points][string-link-to-code-points-wikipedia]
as `ARRAY<INT64>` and returns a `STRING`.

To convert from a string to an array of code points, see
[TO_CODE_POINTS][string-link-to-code-points].

**Return type**

`STRING`

**Examples**

The following are basic examples using `CODE_POINTS_TO_STRING`.

```zetasql
SELECT CODE_POINTS_TO_STRING([65, 255, 513, 1024]) AS string;

/*--------*
 | string |
 +--------+
 | A   |
 *--------*/
```

```zetasql
SELECT CODE_POINTS_TO_STRING([97, 0, 0xF9B5]) AS string;

/*--------*
 | string |
 +--------+
 | a    |
 *--------*/
```

```zetasql
SELECT CODE_POINTS_TO_STRING([65, 255, NULL, 1024]) AS string;

/*--------*
 | string |
 +--------+
 | NULL   |
 *--------*/
```

The following example computes the frequency of letters in a set of words.

```zetasql
WITH Words AS (
  SELECT word
  FROM UNNEST(['foo', 'bar', 'baz', 'giraffe', 'llama']) AS word
)
SELECT
  CODE_POINTS_TO_STRING([code_point]) AS letter,
  COUNT(*) AS letter_count
FROM Words,
  UNNEST(TO_CODE_POINTS(word)) AS code_point
GROUP BY 1
ORDER BY 2 DESC;

/*--------+--------------*
 | letter | letter_count |
 +--------+--------------+
 | a      | 5            |
 | f      | 3            |
 | r      | 2            |
 | b      | 2            |
 | l      | 2            |
 | o      | 2            |
 | g      | 1            |
 | z      | 1            |
 | e      | 1            |
 | m      | 1            |
 | i      | 1            |
 *--------+--------------*/
```

[string-link-to-code-points-wikipedia]: https://en.wikipedia.org/wiki/Code_point

[string-link-to-code-points]: #to_code_points

### `COLLATE`

```zetasql
COLLATE(value, collate_specification)
```

Takes a `STRING` and a [collation specification][link-collation-spec]. Returns
a `STRING` with a collation specification. If `collate_specification` is empty,
returns a value with collation removed from the `STRING`.

The collation specification defines how the resulting `STRING` can be compared
and sorted. To learn more, see
[Working with collation][link-collation-concepts].

+ `collation_specification` must be a string literal, otherwise an error is
  thrown.
+ Returns `NULL` if `value` is `NULL`.

**Return type**

`STRING`

**Examples**

In this example, the weight of `a` is less than the weight of `Z`. This
is because the collate specification, `und:ci` assigns more weight to `Z`.

```zetasql
WITH Words AS (
  SELECT
    COLLATE('a', 'und:ci') AS char1,
    COLLATE('Z', 'und:ci') AS char2
)
SELECT ( Words.char1 < Words.char2 ) AS a_less_than_Z
FROM Words;

/*----------------*
 | a_less_than_Z  |
 +----------------+
 | TRUE           |
 *----------------*/
```

In this example, the weight of `a` is greater than the weight of `Z`. This
is because the default collate specification assigns more weight to `a`.

```zetasql
WITH Words AS (
  SELECT
    'a' AS char1,
    'Z' AS char2
)
SELECT ( Words.char1 < Words.char2 ) AS a_less_than_Z
FROM Words;

/*----------------*
 | a_less_than_Z  |
 +----------------+
 | FALSE          |
 *----------------*/
```

[link-collation-spec]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_spec_details

[link-collation-concepts]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md

### `CONCAT`

```zetasql
CONCAT(value1[, ...])
```

**Description**

Concatenates one or more values into a single result. All values must be
`BYTES` or data types that can be cast to `STRING`.

The function returns `NULL` if any input argument is `NULL`.

Note: You can also use the
[|| concatenation operator][string-link-to-operators] to concatenate
values into a string.

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT CONCAT('T.P.', ' ', 'Bar') as author;

/*---------------------*
 | author              |
 +---------------------+
 | T.P. Bar            |
 *---------------------*/
```

```zetasql
SELECT CONCAT('Summer', ' ', 1923) as release_date;

/*---------------------*
 | release_date        |
 +---------------------+
 | Summer 1923         |
 *---------------------*/
```

```zetasql

With Employees AS
  (SELECT
    'John' AS first_name,
    'Doe' AS last_name
  UNION ALL
  SELECT
    'Jane' AS first_name,
    'Smith' AS last_name
  UNION ALL
  SELECT
    'Joe' AS first_name,
    'Jackson' AS last_name)

SELECT
  CONCAT(first_name, ' ', last_name)
  AS full_name
FROM Employees;

/*---------------------*
 | full_name           |
 +---------------------+
 | John Doe            |
 | Jane Smith          |
 | Joe Jackson         |
 *---------------------*/
```

[string-link-to-operators]: #operators

### `EDIT_DISTANCE`

```zetasql
EDIT_DISTANCE(
  value1,
  value2,
  [ max_distance => max_distance_value ]
)
```

**Description**

Computes the [Levenshtein distance][l-distance] between two `STRING` or
`BYTES` values.

**Definitions**

+   `value1`: The first `STRING` or `BYTES` value to compare.
+   `value2`: The second `STRING` or `BYTES` value to compare.
+   `max_distance`: A named argument with a `INT64` value that's greater than
    or equal to zero. Represents the maximum distance between the two values
    to compute.

    If this distance is exceeded, the function returns this value.
    The default value for this argument is the maximum size of
    `value1` and `value2`.

**Details**

If `value1` or `value2` is `NULL`, `NULL` is returned.

You can only compare values of the same type. Otherwise, an error is produced.

**Return type**

`INT64`

**Examples**

In the following example, the first character in both strings is different:

```zetasql
SELECT EDIT_DISTANCE('a', 'b') AS results;

/*---------*
 | results |
 +---------+
 | 1       |
 *---------*/
```

In the following example, the first and second characters in both strings are
different:

```zetasql
SELECT EDIT_DISTANCE('aa', 'b') AS results;

/*---------*
 | results |
 +---------+
 | 2       |
 *---------*/
```

In the following example, only the first character in both strings is
different:

```zetasql
SELECT EDIT_DISTANCE('aa', 'ba') AS results;

/*---------*
 | results |
 +---------+
 | 1       |
 *---------*/
```

In the following example, the last six characters are different, but because
the maximum distance is `2`, this function exits early and returns `2`, the
maximum distance:

```zetasql
SELECT EDIT_DISTANCE('abcdefg', 'a', max_distance => 2) AS results;

/*---------*
 | results |
 +---------+
 | 2       |
 *---------*/
```

[l-distance]: https://en.wikipedia.org/wiki/Levenshtein_distance

### `ENDS_WITH`

```zetasql
ENDS_WITH(value, suffix)
```

**Description**

Takes two `STRING` or `BYTES` values. Returns `TRUE` if `suffix`
is a suffix of `value`.

This function supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

**Return type**

`BOOL`

**Examples**

```zetasql
SELECT ENDS_WITH('apple', 'e') as example

/*---------*
 | example |
 +---------+
 |    True |
 *---------*/
```

### `FORMAT` 
<a id="format_string"></a>

```zetasql
FORMAT(format_string_expression, data_type_expression[, ...])
```

**Description**

`FORMAT` formats a data type expression as a string.

+ `format_string_expression`: Can contain zero or more
  [format specifiers][format-specifiers]. Each format specifier is introduced
  by the `%` symbol, and must map to one or more of the remaining arguments.
  In general, this is a one-to-one mapping, except when the `*` specifier is
  present. For example, `%.*i` maps to two arguments&mdash;a length argument
  and a signed integer argument. If the number of arguments related to the
  format specifiers isn't the same as the number of arguments, an error occurs.
+ `data_type_expression`: The value to format as a string. This can be any
  ZetaSQL data type.

**Return type**

`STRING`

**Examples**

<table>
<tr>
<th>Description</th>
<th>Statement</th>
<th>Result</th>
</tr>
<tr>
<td>Simple integer</td>
<td>FORMAT('%d', 10)</td>
<td>10</td>
</tr>
<tr>
<td>Integer with left blank padding</td>
<td>FORMAT('|%10d|', 11)</td>
<td>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11|</td>
</tr>
<tr>
<td>Integer with left zero padding</td>
<td>FORMAT('+%010d+', 12)</td>
<td>+0000000012+</td>
</tr>
<tr>
<td>Integer with commas</td>
<td>FORMAT("%'d", 123456789)</td>
<td>123,456,789</td>
</tr>
<tr>
<td>STRING</td>
<td>FORMAT('-%s-', 'abcd efg')</td>
<td>-abcd efg-</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>FORMAT('%f %E', 1.1, 2.2)</td>
<td>1.100000&nbsp;2.200000E+00</td>
</tr>

<tr>
<td>DATE</td>
<td>FORMAT('%t', date '2015-09-01')</td>
<td>2015-09-01</td>
</tr>

<tr>
<td>TIMESTAMP</td>
<td>FORMAT('%t', timestamp '2015-09-01 12:34:56
America/Los_Angeles')</td>
<td>2015&#8209;09&#8209;01&nbsp;19:34:56+00</td>
</tr>
</table>

The `FORMAT()` function doesn't provide fully customizable formatting for all
types and values, nor formatting that's sensitive to locale.

If custom formatting is necessary for a type, you must first format it using
type-specific format functions, such as `FORMAT_DATE()` or `FORMAT_TIMESTAMP()`.
For example:

```zetasql
SELECT FORMAT('date: %s!', FORMAT_DATE('%B %d, %Y', date '2015-01-02'));
```

Returns

```
date: January 02, 2015!
```

#### Supported format specifiers 
<a id="format_specifiers"></a>

```
%[flags][width][.precision]specifier
```

A [format specifier][format-specifier-list] adds formatting when casting a
value to a string. It can optionally contain these sub-specifiers:

+ [Flags][flags]
+ [Width][width]
+ [Precision][precision]

Additional information about format specifiers:

+ [%g and %G behavior][g-and-g-behavior]
+ [%p and %P behavior][p-and-p-behavior]
+ [%t and %T behavior][t-and-t-behavior]
+ [Error conditions][error-format-specifiers]
+ [NULL argument handling][null-format-specifiers]
+ [Additional semantic rules][rules-format-specifiers]

##### Format specifiers 
<a id="format_specifier_list"></a>

<table>
 <tr>
    <td>Specifier</td>
    <td>Description</td>
    <td width="200px">Examples</td>
    <td>Types</td>
 </tr>
 <tr>
    <td><code>d</code> or <code>i</code></td>
    <td>Decimal integer</td>
    <td>392</td>
    <td>

<span><code>INT32</code></span><br /><span><code>INT64</code></span><br /><span><code>UINT32</code></span><br /><span><code>UINT64</code></span><br />
</td>
 </tr>

 <tr>
    <td><code>u</code></td>
    <td>Unsigned integer</td>
    <td>7235</td>
    <td>

<span><code>UINT32</code></span><br /><span><code>UINT64</code></span><br />
</td>
 </tr>

 <tr>
    <td><code>o</code></td>
    <td>
    Octal
    <br /><br />
    Note: If an <code>INT64</code> value is negative, an error is produced.
    </td>
    <td>610</td>
    <td>

<span><code>INT32</code></span><br /><span><code>INT64</code></span><br /><span><code>UINT32</code></span><br /><span><code>UINT64</code></span><br />
</td>
 </tr>
 <tr>
    <td><code>x</code></td>
    <td>
      Hexadecimal integer
      <br /><br />
      Note: If an <code>INT64</code> value is negative, an error is produced.
    </td>
    <td>7fa</td>
    <td>

<span><code>INT32</code></span><br /><span><code>INT64</code></span><br /><span><code>UINT32</code></span><br /><span><code>UINT64</code></span><br />
</td>
 </tr>
 <tr>
    <td><code>X</code></td>
    <td>
      Hexadecimal integer (uppercase)
      <br /><br />
      Note: If an <code>INT64</code> value is negative, an error is produced.
    </td>
    <td>7FA</td>
    <td>

<span><code>INT32</code></span><br /><span><code>INT64</code></span><br /><span><code>UINT32</code></span><br /><span><code>UINT64</code></span><br />

    </td>
 </tr>
 <tr>
    <td><code>f</code></td>
    <td>Decimal notation, in [-](integer part).(fractional part) for finite
        values, and in lowercase for non-finite values</td>
    <td>392.650000<br/>
    inf<br/>
    nan</td>
    <td>

<span><code>NUMERIC</code></span><br /><span><code>BIGNUMERIC</code></span><br /><span><code>FLOAT</code></span><br /><span><code>DOUBLE</code></span><br />
</td>
 </tr>
 <tr>
    <td><code>F</code></td>
    <td>Decimal notation, in [-](integer part).(fractional part) for finite
        values, and in uppercase for non-finite values</td>
    <td>392.650000<br/>
    INF<br/>
    NAN</td>
    <td>

<span><code>NUMERIC</code></span><br /><span><code>BIGNUMERIC</code></span><br /><span><code>FLOAT</code></span><br /><span><code>DOUBLE</code></span><br />
</td>
 </tr>
 <tr>
    <td><code>e</code></td>
    <td>Scientific notation (mantissa/exponent), lowercase</td>
    <td>3.926500e+02<br/>
    inf<br/>
    nan</td>
    <td>

<span><code>NUMERIC</code></span><br /><span><code>BIGNUMERIC</code></span><br /><span><code>FLOAT</code></span><br /><span><code>DOUBLE</code></span><br />
</td>
 </tr>
 <tr>
    <td><code>E</code></td>
    <td>Scientific notation (mantissa/exponent), uppercase</td>
    <td>3.926500E+02<br/>
    INF<br/>
    NAN</td>
    <td>

<span><code>NUMERIC</code></span><br /><span><code>BIGNUMERIC</code></span><br /><span><code>FLOAT</code></span><br /><span><code>DOUBLE</code></span><br />
</td>
 </tr>
 <tr>
    <td><code>g</code></td>
    <td>Either decimal notation or scientific notation, depending on the input
        value's exponent and the specified precision. Lowercase.
        See <a href="#g_and_g_behavior">%g and %G behavior</a> for details.</td>
    <td>392.65<br/>
      3.9265e+07<br/>
    inf<br/>
    nan</td>
    <td>

<span><code>NUMERIC</code></span><br /><span><code>BIGNUMERIC</code></span><br /><span><code>FLOAT</code></span><br /><span><code>DOUBLE</code></span><br />
</td>
 </tr>
 <tr>
    <td><code>G</code></td>
    <td>
      Either decimal notation or scientific notation, depending on the input
      value's exponent and the specified precision. Uppercase.
      See <a href="#g_and_g_behavior">%g and %G behavior</a> for details.
    </td>
    <td>
      392.65<br/>
      3.9265E+07<br/>
      INF<br/>
      NAN
    </td>
    <td>

<span><code>NUMERIC</code></span><br /><span><code>BIGNUMERIC</code></span><br /><span><code>FLOAT</code></span><br /><span><code>DOUBLE</code></span><br />
</td>
 </tr>

 <tr>
    <td><code>p</code></td>
    <td>
      
      Produces a one-line printable string representing a protocol buffer
      or JSON.
      
      See <a href="#p_and_p_behavior">%p and %P behavior</a>.
    </td>
    <td>
      
<pre>year: 2019 month: 10</pre>
      
      
<pre>{"month":10,"year":2019}</pre>
      
    </td>
    <td>

<span><code>JSON</code></span><br /><span><code>PROTO</code></span><br />
</td>
 </tr>

  <tr>
    <td><code>P</code></td>
    <td>
      
      Produces a multi-line printable string representing a protocol buffer
      or JSON.
      
      See <a href="#p_and_p_behavior">%p and %P behavior</a>.
    </td>
    <td>
      
<pre>
year: 2019
month: 10
</pre>
      
      
<pre>
{
  "month": 10,
  "year": 2019
}
</pre>
      
    </td>
    <td>

<span><code>JSON</code></span><br /><span><code>PROTO</code></span><br />
</td>
  </tr>

 <tr>
    <td><code>s</code></td>
    <td>String of characters</td>
    <td>sample</td>
    <td>

<span><code>STRING</code></span><br />
</td>
 </tr>
 <tr>
    <td><code>t</code></td>
    <td>
      Returns a printable string representing the value. Often looks
      similar to casting the argument to <code>STRING</code>.
      See <a href="#t_and_t_behavior">%t and %T behavior</a>.
    </td>
    <td>
      sample<br/>
      2014&#8209;01&#8209;01
    </td>
    <td>Any type</td>
 </tr>
 <tr>
    <td><code>T</code></td>
    <td>
      Produces a string that's a valid ZetaSQL constant with a
      similar type to the value's type (maybe wider, or maybe string).
      See <a href="#t_and_t_behavior">%t and %T behavior</a>.
    </td>
    <td>
      'sample'<br/>
      b'bytes&nbsp;sample'<br/>
      1234<br/>
      2.3<br/>
      date&nbsp;'2014&#8209;01&#8209;01'
    </td>
    <td>Any type</td>
 </tr>
 <tr>
    <td><code>%</code></td>
    <td>'%%' produces a single '%'</td>
    <td>%</td>
    <td>n/a</td>
 </tr>
</table>

The format specifier can optionally contain the sub-specifiers identified above
in the specifier prototype.

These sub-specifiers must comply with the following specifications.

##### Flags 
<a id="flags"></a>

<table>
 <tr>
    <td>Flags</td>
    <td>Description</td>
 </tr>
 <tr>
    <td><code>-</code></td>
    <td>Left-justify within the given field width; Right justification is the
default (see width sub-specifier)</td>
</tr>
 <tr>
    <td><code>+</code></td>
    <td>Forces to precede the result with a plus or minus sign (<code>+</code>
or <code>-</code>) even for positive numbers. By default, only negative numbers
are preceded with a <code>-</code> sign</td>
</tr>
 <tr>
    <td>&lt;space&gt;</td>
    <td>If no sign is going to be written, a blank space is inserted before the
value</td>
</tr>
 <tr>
    <td><code>#</code></td>
    <td><ul>
      <li>For `%o`, `%x`, and `%X`, this flag means to precede the
          value with 0, 0x or 0X respectively for values different than zero.</li>
      <li>For `%f`, `%F`, `%e`, and `%E`, this flag means to add the decimal
          point even when there is no fractional part, unless the value
          is non-finite.</li>
      <li>For `%g` and `%G`, this flag means to add the decimal point even
          when there is no fractional part unless the value is non-finite, and
          never remove the trailing zeros after the decimal point.</li>
      </ul>
   </td>
 </tr>
 <tr>
    <td><code>0</code></td>
    <td>
      Left-pads the number with zeroes (0) instead of spaces when padding is
      specified (see width sub-specifier)</td>
 </tr>
 <tr>
  <td><code>'</code></td>
  <td>
    <p>Formats integers using the appropriating grouping character.
       For example:</p>
    <ul>
      <li><code>FORMAT("%'d", 12345678)</code> returns <code>12,345,678</code></li>
      <li><code>FORMAT("%'x", 12345678)</code> returns <code>bc:614e</code></li>
      <li><code>FORMAT("%'o", 55555)</code> returns <code>15,4403</code></li>
      <p>This flag is only relevant for decimal, hex, and octal values.</p>
    </ul>
  </td>
 </tr>
</table>

Flags may be specified in any order. Duplicate flags aren't an error. When
flags aren't relevant for some element type, they are ignored.

##### Width 
<a id="width"></a>

<table>
  <tr>
    <td>Width</td>
    <td>Description</td>
  </tr>
  <tr>
    <td>&lt;number&gt;</td>
    <td>
      Minimum number of characters to be printed. If the value to be printed
      is shorter than this number, the result is padded with blank spaces.
      The value isn't truncated even if the result is larger
    </td>
  </tr>
  <tr>
    <td><code>*</code></td>
    <td>
      The width isn't specified in the format string, but as an additional
      integer value argument preceding the argument that has to be formatted
    </td>
  </tr>
</table>

##### Precision 
<a id="precision"></a>

<table>
 <tr>
    <td>Precision</td>
    <td>Description</td>
 </tr>
 <tr>
    <td><code>.</code>&lt;number&gt;</td>
    <td>
      <ul>
      <li>For integer specifiers `%d`, `%i`, `%o`, `%u`, `%x`, and `%X`:
          precision specifies the
          minimum number of digits to be written. If the value to be written is
          shorter than this number, the result is padded with trailing zeros.
          The value isn't truncated even if the result is longer. A precision
          of 0 means that no character is written for the value 0.</li>
      <li>For specifiers `%a`, `%A`, `%e`, `%E`, `%f`, and `%F`: this is the
          number of digits to be printed after the decimal point. The default
          value is 6.</li>
      <li>For specifiers `%g` and `%G`: this is the number of significant digits
          to be printed, before the removal of the trailing zeros after the
          decimal point. The default value is 6.</li>
      </ul>
   </td>
</tr>
 <tr>
    <td><code>.*</code></td>
    <td>
      The precision isn't specified in the format string, but as an
      additional integer value argument preceding the argument that has to be
      formatted
   </td>
  </tr>
</table>

##### %g and %G behavior 
<a id="g_and_g_behavior"></a>
The `%g` and `%G` format specifiers choose either the decimal notation (like
the `%f` and `%F` specifiers) or the scientific notation (like the `%e` and `%E`
specifiers), depending on the input value's exponent and the specified
[precision](#precision).

Let p stand for the specified [precision](#precision) (defaults to 6; 1 if the
specified precision is less than 1). The input value is first converted to
scientific notation with precision = (p - 1). If the resulting exponent part x
is less than -4 or no less than p, the scientific notation with precision =
(p - 1) is used; otherwise the decimal notation with precision = (p - 1 - x) is
used.

Unless [`#` flag](#flags) is present, the trailing zeros after the decimal point
are removed, and the decimal point is also removed if there is no digit after
it.

##### %p and %P behavior 
<a id="p_and_p_behavior"></a>

The `%p` format specifier produces a one-line printable string. The `%P`
format specifier produces a multi-line printable string. You can use these
format specifiers with the following data types:

<table>
  <tr>
    <td><strong>Type</strong></td>
    <td><strong>%p</strong></td>
    <td><strong>%P</strong></td>
  </tr>
  <tr>
    <td>PROTO</td>
    <td valign="top">
      <p>PROTO input:</p>
<pre>
message ReleaseDate {
 required int32 year = 1 [default=2019];
 required int32 month = 2 [default=10];
}</pre>
      <p>Produces a one-line printable string representing a protocol buffer:</p>
      <pre>year: 2019 month: 10</pre>
    </td>
    <td valign="top">
      <p>PROTO input:</p>
<pre>
message ReleaseDate {
 required int32 year = 1 [default=2019];
 required int32 month = 2 [default=10];
}</pre>
      <p>Produces a multi-line printable string representing a protocol buffer:</p>
<pre>
year: 2019
month: 10
</pre>
    </td>
  </tr>
  <tr>
    <td>JSON</td>
    <td valign="top">
      <p>JSON input:</p>
<pre>
JSON '
{
  "month": 10,
  "year": 2019
}
'</pre>
      <p>Produces a one-line printable string representing JSON:</p>
      <pre>{"month":10,"year":2019}</pre>
    </td>
    <td valign="top">
      <p>JSON input:</p>
<pre>
JSON '
{
  "month": 10,
  "year": 2019
}
'</pre>
      <p>Produces a multi-line printable string representing JSON:</p>
<pre>
{
  "month": 10,
  "year": 2019
}
</pre>
    </td>
  </tr>
</table>

##### %t and %T behavior 
<a id="t_and_t_behavior"></a>

The `%t` and `%T` format specifiers are defined for all types. The
[width](#width), [precision](#precision), and [flags](#flags) act as they do
for `%s`: the [width](#width) is the minimum width and the `STRING` will be
padded to that size, and [precision](#precision) is the maximum width
of content to show and the `STRING` will be truncated to that size, prior to
padding to width.

The `%t` specifier is always meant to be a readable form of the value.

The `%T` specifier is always a valid SQL literal of a similar type, such as a
wider numeric type. The literal will not include casts or a type name,
except for the special case of non-finite floating point values.

The `STRING` is formatted as follows:

<table>
  <tr>
    <td><strong>Type</strong></td>
    <td><strong>%t</strong></td>
    <td><strong>%T</strong></td>
  </tr>
  <tr>
    <td><code>NULL</code> of any type</td>
    <td>NULL</td>
    <td>NULL</td>
  </tr>
  <tr>
    <td>

<span><code>INT32</code></span><br /><span><code>INT64</code></span><br /><span><code>UINT32</code></span><br /><span><code>UINT64</code></span><br />
</td>
    <td>123</td>
    <td>123</td>
  </tr>

  <tr>
    <td>NUMERIC</td>
    <td>123.0  <em>(always with .0)</em></td>
    <td>NUMERIC "123.0"</td>
  </tr>
  <tr>

    <td>FLOAT, DOUBLE</td>

    <td>
      123.0  <em>(always with .0)</em><br/>
      123e+10<br/>
      <code>inf</code><br/>
      <code>-inf</code><br/>
      <code>NaN</code>
    </td>
    <td>
      123.0  <em>(always with .0)</em><br/>
      123e+10<br/>
      CAST("inf" AS &lt;type&gt;)<br/>
      CAST("-inf" AS &lt;type&gt;)<br/>
      CAST("nan" AS &lt;type&gt;)
    </td>
  </tr>
  <tr>
    <td>STRING</td>
    <td>unquoted string value</td>
    <td>quoted string literal</td>
  </tr>
  <tr>
    <td>BYTES</td>
    <td>
      unquoted escaped bytes<br/>
      e.g., abc\x01\x02
    </td>
    <td>
      quoted bytes literal<br/>
      e.g., b"abc\x01\x02"
    </td>
  </tr>
  <tr>
    <td>BOOL</td>
    <td>boolean value</td>
    <td>boolean value</td>
  </tr>

  <tr>
    <td>ENUM</td>
    <td>EnumName</td>
    <td>"EnumName"</td>
  </tr>
  <tr>
    <td>DATE</td>
    <td>2011-02-03</td>
    <td>DATE "2011-02-03"</td>
  </tr>
  <tr>
    <td>TIMESTAMP</td>
    <td>2011-02-03 04:05:06+00</td>
    <td>TIMESTAMP "2011-02-03 04:05:06+00"</td>
  </tr>
  <tr>
    <td>INTERVAL</td>
    <td>1-2 3 4:5:6.789</td>
    <td>INTERVAL "1-2 3 4:5:6.789" YEAR TO SECOND</td>
  </tr>
  <tr>
    <td>PROTO</td>
    <td>
      one-line printable string representing a protocol buffer.
    </td>
    <td>
      quoted string literal with one-line printable string representing a
      protocol buffer.
    </td>
  </tr>
  <tr>
    <td>ARRAY</td>
    <td>[value, value, ...]<br/>
    where values are formatted with %t</td>
    <td>[value, value, ...]<br/>
    where values are formatted with %T</td>
  </tr>
  <tr>
    <td>STRUCT</td>
    <td>(value, value, ...)<br/>
    where fields are formatted with %t</td>
    <td>(value, value, ...)<br/>
    where fields are formatted with %T<br/>
    <br/>
    Special cases:<br/>
    Zero fields: STRUCT()<br/>
    One field: STRUCT(value)</td>
  </tr>
  <tr>
    <td>JSON</td>
    <td>
      one-line printable string representing JSON.<br />
      <pre class="lang-json prettyprint">{"name":"apple","stock":3}</pre>
    </td>
    <td>
      one-line printable string representing a JSON literal.<br />
      <pre class="lang-sql prettyprint">JSON '{"name":"apple","stock":3}'</pre>
    </td>
  </tr>
</table>

##### Error conditions 
<a id="error_format_specifiers"></a>

If a format specifier is invalid, or isn't compatible with the related
argument type, or the wrong number or arguments are provided, then an error is
produced. For example, the following `<format_string>` expressions are invalid:

```zetasql
FORMAT('%s', 1)
```

```zetasql
FORMAT('%')
```

##### NULL argument handling 
<a id="null_format_specifiers"></a>

A `NULL` format string results in a `NULL` output `STRING`. Any other arguments
are ignored in this case.

The function generally produces a `NULL` value if a `NULL` argument is present.
For example, `FORMAT('%i', NULL_expression)` produces a `NULL STRING` as
output.

However, there are some exceptions: if the format specifier is %t or %T
(both of which produce `STRING`s that effectively match CAST and literal value
semantics), a `NULL` value produces 'NULL' (without the quotes) in the result
`STRING`. For example, the function:

```zetasql
FORMAT('00-%t-00', NULL_expression);
```

Returns

```zetasql
00-NULL-00
```

##### Additional semantic rules 
<a id="rules_format_specifiers"></a>

`DOUBLE` and
`FLOAT` values can be `+/-inf` or `NaN`.
When an argument has one of those values, the result of the format specifiers
`%f`, `%F`, `%e`, `%E`, `%g`, `%G`, and `%t` are `inf`, `-inf`, or `nan`
(or the same in uppercase) as appropriate. This is consistent with how
ZetaSQL casts these values to `STRING`. For `%T`,
ZetaSQL returns quoted strings for
`DOUBLE` values that don't have non-string literal
representations.

[format-specifiers]: #format_specifiers

[format-specifier-list]: #format_specifier_list

[flags]: #flags

[width]: #width

[precision]: #precision

[g-and-g-behavior]: #g_and_g_behavior

[p-and-p-behavior]: #p_and_p_behavior

[t-and-t-behavior]: #t_and_t_behavior

[error-format-specifiers]: #error_format_specifiers

[null-format-specifiers]: #null_format_specifiers

[rules-format-specifiers]: #rules_format_specifiers

### `FROM_BASE32`

```zetasql
FROM_BASE32(string_expr)
```

**Description**

Converts the base32-encoded input `string_expr` into `BYTES` format. To convert
`BYTES` to a base32-encoded `STRING`, use [TO_BASE32][string-link-to-base32].

**Return type**

`BYTES`

**Example**

```zetasql
SELECT FROM_BASE32('MFRGGZDF74======') AS byte_data;

/*-----------*
 | byte_data |
 +-----------+
 | abcde\xff |
 *-----------*/
```

[string-link-to-base32]: #to_base32

### `FROM_BASE64`

```zetasql
FROM_BASE64(string_expr)
```

**Description**

Converts the base64-encoded input `string_expr` into
`BYTES` format. To convert
`BYTES` to a base64-encoded `STRING`,
use [TO_BASE64][string-link-to-to-base64].

There are several base64 encodings in common use that vary in exactly which
alphabet of 65 ASCII characters are used to encode the 64 digits and padding.
See [RFC 4648][RFC-4648] for details. This
function expects the alphabet `[A-Za-z0-9+/=]`.

**Return type**

`BYTES`

**Example**

```zetasql
SELECT FROM_BASE64('/+A=') AS byte_data;

/*-----------*
 | byte_data |
 +-----------+
 | \377\340  |
 *-----------*/
```

To work with an encoding using a different base64 alphabet, you might need to
compose `FROM_BASE64` with the `REPLACE` function. For instance, the
`base64url` url-safe and filename-safe encoding commonly used in web programming
uses `-_=` as the last characters rather than `+/=`. To decode a
`base64url`-encoded string, replace `-` and `_` with `+` and `/` respectively.

```zetasql
SELECT FROM_BASE64(REPLACE(REPLACE('_-A=', '-', '+'), '_', '/')) AS binary;

/*-----------*
 | binary    |
 +-----------+
 | \377\340  |
 *-----------*/
```

[RFC-4648]: https://tools.ietf.org/html/rfc4648#section-4

[string-link-to-to-base64]: #to_base64

### `FROM_HEX`

```zetasql
FROM_HEX(string)
```

**Description**

Converts a hexadecimal-encoded `STRING` into `BYTES` format. Returns an error
if the input `STRING` contains characters outside the range
`(0..9, A..F, a..f)`. The lettercase of the characters doesn't matter. If the
input `STRING` has an odd number of characters, the function acts as if the
input has an additional leading `0`. To convert `BYTES` to a hexadecimal-encoded
`STRING`, use [TO_HEX][string-link-to-to-hex].

**Return type**

`BYTES`

**Example**

```zetasql
WITH Input AS (
  SELECT '00010203aaeeefff' AS hex_str UNION ALL
  SELECT '0AF' UNION ALL
  SELECT '666f6f626172'
)
SELECT hex_str, FROM_HEX(hex_str) AS bytes_str
FROM Input;

/*------------------+----------------------------------*
 | hex_str          | bytes_str                        |
 +------------------+----------------------------------+
 | 0AF              | \x00\xaf                         |
 | 00010203aaeeefff | \x00\x01\x02\x03\xaa\xee\xef\xff |
 | 666f6f626172     | foobar                           |
 *------------------+----------------------------------*/
```

[string-link-to-to-hex]: #to_hex

### `INITCAP`

```zetasql
INITCAP(value[, delimiters])
```

**Description**

Takes a `STRING` and returns it with the first character in each word in
uppercase and all other characters in lowercase. Non-alphabetic characters
remain the same.

`delimiters` is an optional string argument that's used to override the default
set of characters used to separate words. If `delimiters` isn't specified, it
defaults to the following characters: \
`<whitespace> [ ] ( ) { } / | \ < > ! ? @ " ^ # $ & ~ _ , . : ; * % + -`

If `value` or `delimiters` is `NULL`, the function returns `NULL`.

**Return type**

`STRING`

**Examples**

```zetasql
SELECT
  'Hello World-everyone!' AS value,
  INITCAP('Hello World-everyone!') AS initcap_value

/*-------------------------------+-------------------------------*
 | value                         | initcap_value                 |
 +-------------------------------+-------------------------------+
 | Hello World-everyone!         | Hello World-Everyone!         |
 *-------------------------------+-------------------------------*/
```

```zetasql
SELECT
  'Apples1oranges2pears' as value,
  '12' AS delimiters,
  INITCAP('Apples1oranges2pears' , '12') AS initcap_value

/*----------------------+------------+----------------------*
 | value                | delimiters | initcap_value        |
 +----------------------+------------+----------------------+
 | Apples1oranges2pears | 12         | Apples1Oranges2Pears |
 *----------------------+------------+----------------------*/
```

### `INSTR`

```zetasql
INSTR(value, subvalue[, position[, occurrence]])
```

**Description**

Returns the lowest 1-based position of `subvalue` in `value`.
`value` and `subvalue` must be the same type, either
`STRING` or `BYTES`.

If `position` is specified, the search starts at this position in
`value`, otherwise it starts at `1`, which is the beginning of
`value`. If `position` is negative, the function searches backwards
from the end of `value`, with `-1` indicating the last character.
`position` is of type `INT64` and can't be `0`.

If `occurrence` is specified, the search returns the position of a specific
instance of `subvalue` in `value`. If not specified, `occurrence`
defaults to `1` and returns the position of the first occurrence.
For `occurrence` > `1`, the function includes overlapping occurrences.
`occurrence` is of type `INT64` and must be positive.

This function supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

Returns `0` if:

+ No match is found.
+ If `occurrence` is greater than the number of matches found.
+ If `position` is greater than the length of `value`.

Returns `NULL` if:

+ Any input argument is `NULL`.

Returns an error if:

+ `position` is `0`.
+ `occurrence` is `0` or negative.

**Return type**

`INT64`

**Examples**

```zetasql
SELECT
  'banana' AS value, 'an' AS subvalue, 1 AS position, 1 AS occurrence,
  INSTR('banana', 'an', 1, 1) AS instr;

/*--------------+--------------+----------+------------+-------*
 | value        | subvalue     | position | occurrence | instr |
 +--------------+--------------+----------+------------+-------+
 | banana       | an           | 1        | 1          | 2     |
 *--------------+--------------+----------+------------+-------*/
```

```zetasql
SELECT
  'banana' AS value, 'an' AS subvalue, 1 AS position, 2 AS occurrence,
  INSTR('banana', 'an', 1, 2) AS instr;

/*--------------+--------------+----------+------------+-------*
 | value        | subvalue     | position | occurrence | instr |
 +--------------+--------------+----------+------------+-------+
 | banana       | an           | 1        | 2          | 4     |
 *--------------+--------------+----------+------------+-------*/
```

```zetasql
SELECT
  'banana' AS value, 'an' AS subvalue, 1 AS position, 3 AS occurrence,
  INSTR('banana', 'an', 1, 3) AS instr;

/*--------------+--------------+----------+------------+-------*
 | value        | subvalue     | position | occurrence | instr |
 +--------------+--------------+----------+------------+-------+
 | banana       | an           | 1        | 3          | 0     |
 *--------------+--------------+----------+------------+-------*/
```

```zetasql
SELECT
  'banana' AS value, 'an' AS subvalue, 3 AS position, 1 AS occurrence,
  INSTR('banana', 'an', 3, 1) AS instr;

/*--------------+--------------+----------+------------+-------*
 | value        | subvalue     | position | occurrence | instr |
 +--------------+--------------+----------+------------+-------+
 | banana       | an           | 3        | 1          | 4     |
 *--------------+--------------+----------+------------+-------*/
```

```zetasql
SELECT
  'banana' AS value, 'an' AS subvalue, -1 AS position, 1 AS occurrence,
  INSTR('banana', 'an', -1, 1) AS instr;

/*--------------+--------------+----------+------------+-------*
 | value        | subvalue     | position | occurrence | instr |
 +--------------+--------------+----------+------------+-------+
 | banana       | an           | -1       | 1          | 4     |
 *--------------+--------------+----------+------------+-------*/
```

```zetasql
SELECT
  'banana' AS value, 'an' AS subvalue, -3 AS position, 1 AS occurrence,
  INSTR('banana', 'an', -3, 1) AS instr;

/*--------------+--------------+----------+------------+-------*
 | value        | subvalue     | position | occurrence | instr |
 +--------------+--------------+----------+------------+-------+
 | banana       | an           | -3       | 1          | 4     |
 *--------------+--------------+----------+------------+-------*/
```

```zetasql
SELECT
  'banana' AS value, 'ann' AS subvalue, 1 AS position, 1 AS occurrence,
  INSTR('banana', 'ann', 1, 1) AS instr;

/*--------------+--------------+----------+------------+-------*
 | value        | subvalue     | position | occurrence | instr |
 +--------------+--------------+----------+------------+-------+
 | banana       | ann          | 1        | 1          | 0     |
 *--------------+--------------+----------+------------+-------*/
```

```zetasql
SELECT
  'helloooo' AS value, 'oo' AS subvalue, 1 AS position, 1 AS occurrence,
  INSTR('helloooo', 'oo', 1, 1) AS instr;

/*--------------+--------------+----------+------------+-------*
 | value        | subvalue     | position | occurrence | instr |
 +--------------+--------------+----------+------------+-------+
 | helloooo     | oo           | 1        | 1          | 5     |
 *--------------+--------------+----------+------------+-------*/
```

```zetasql
SELECT
  'helloooo' AS value, 'oo' AS subvalue, 1 AS position, 2 AS occurrence,
  INSTR('helloooo', 'oo', 1, 2) AS instr;

/*--------------+--------------+----------+------------+-------*
 | value        | subvalue     | position | occurrence | instr |
 +--------------+--------------+----------+------------+-------+
 | helloooo     | oo           | 1        | 2          | 6     |
 *--------------+--------------+----------+------------+-------*/
```

### `LEFT`

```zetasql
LEFT(value, length)
```

**Description**

Returns a `STRING` or `BYTES` value that consists of the specified
number of leftmost characters or bytes from `value`. The `length` is an
`INT64` that specifies the length of the returned
value. If `value` is of type `BYTES`, `length` is the number of leftmost bytes
to return. If `value` is `STRING`, `length` is the number of leftmost characters
to return.

If `length` is 0, an empty `STRING` or `BYTES` value will be
returned. If `length` is negative, an error will be returned. If `length`
exceeds the number of characters or bytes from `value`, the original `value`
will be returned.

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT LEFT('banana', 3) AS results

/*---------*
 | results |
  +--------+
 | ban     |
 *---------*/
```

```zetasql
SELECT LEFT(b'\xab\xcd\xef\xaa\xbb', 3) AS results

/*--------------*
 | results      |
 +--------------+
 | \xab\xcd\xef |
 *--------------*/
```

### `LENGTH`

```zetasql
LENGTH(value)
```

**Description**

Returns the length of the `STRING` or `BYTES` value. The returned
value is in characters for `STRING` arguments and in bytes for the `BYTES`
argument.

**Return type**

`INT64`

**Examples**

```zetasql
SELECT
  LENGTH('') AS string_example,
  LENGTH(CAST('' AS BYTES)) AS bytes_example;

/*----------------+---------------*
 | string_example | bytes_example |
 +----------------+---------------+
 | 5              | 10            |
 *----------------+---------------*/
```

### `LOWER`

```zetasql
LOWER(value)
```

**Description**

For `STRING` arguments, returns the original string with all alphabetic
characters in lowercase. Mapping between lowercase and uppercase is done
according to the
[Unicode Character Database][string-link-to-unicode-character-definitions]
without taking into account language-specific mappings.

For `BYTES` arguments, the argument is treated as ASCII text, with all bytes
greater than 127 left intact.

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT
  LOWER('FOO BAR BAZ') AS example
FROM items;

/*-------------*
 | example     |
 +-------------+
 | foo bar baz |
 *-------------*/
```

[string-link-to-unicode-character-definitions]: http://unicode.org/ucd/

### `LPAD`

```zetasql
LPAD(original_value, return_length[, pattern])
```

**Description**

Returns a `STRING` or `BYTES` value that consists of `original_value` prepended
with `pattern`. The `return_length` is an `INT64` that
specifies the length of the returned value. If `original_value` is of type
`BYTES`, `return_length` is the number of bytes. If `original_value` is
of type `STRING`, `return_length` is the number of characters.

The default value of `pattern` is a blank space.

Both `original_value` and `pattern` must be the same data type.

If `return_length` is less than or equal to the `original_value` length, this
function returns the `original_value` value, truncated to the value of
`return_length`. For example, `LPAD('hello world', 7);` returns `'hello w'`.

If `original_value`, `return_length`, or `pattern` is `NULL`, this function
returns `NULL`.

This function returns an error if:

+ `return_length` is negative
+ `pattern` is empty

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT FORMAT('%T', LPAD('c', 5)) AS results

/*---------*
 | results |
 +---------+
 | "    c" |
 *---------*/
```

```zetasql
SELECT LPAD('b', 5, 'a') AS results

/*---------*
 | results |
 +---------+
 | aaaab   |
 *---------*/
```

```zetasql
SELECT LPAD('abc', 10, 'ghd') AS results

/*------------*
 | results    |
 +------------+
 | ghdghdgabc |
 *------------*/
```

```zetasql
SELECT LPAD('abc', 2, 'd') AS results

/*---------*
 | results |
 +---------+
 | ab      |
 *---------*/
```

```zetasql
SELECT FORMAT('%T', LPAD(b'abc', 10, b'ghd')) AS results

/*---------------*
 | results       |
 +---------------+
 | b"ghdghdgabc" |
 *---------------*/
```

### `LTRIM`

```zetasql
LTRIM(value1[, value2])
```

**Description**

Identical to [TRIM][string-link-to-trim], but only removes leading characters.

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT CONCAT('#', LTRIM('   apple   '), '#') AS example

/*-------------*
 | example     |
 +-------------+
 | #apple   #  |
 *-------------*/
```

```zetasql
SELECT LTRIM('***apple***', '*') AS example

/*-----------*
 | example   |
 +-----------+
 | apple***  |
 *-----------*/
```

```zetasql
SELECT LTRIM('xxxapplexxx', 'xyz') AS example

/*-----------*
 | example   |
 +-----------+
 | applexxx  |
 *-----------*/
```

[string-link-to-trim]: #trim

### `NORMALIZE`

```zetasql
NORMALIZE(value[, normalization_mode])
```

**Description**

Takes a string value and returns it as a normalized string. If you don't
provide a normalization mode, `NFC` is used.

[Normalization][string-link-to-normalization-wikipedia] is used to ensure that
two strings are equivalent. Normalization is often used in situations in which
two strings render the same on the screen but have different Unicode code
points.

`NORMALIZE` supports four optional normalization modes:

| Value   | Name                                           | Description|
|---------|------------------------------------------------|------------|
| `NFC`   | Normalization Form Canonical Composition       | Decomposes and recomposes characters by canonical equivalence.|
| `NFKC`  | Normalization Form Compatibility Composition   | Decomposes characters by compatibility, then recomposes them by canonical equivalence.|
| `NFD`   | Normalization Form Canonical Decomposition     | Decomposes characters by canonical equivalence, and multiple combining characters are arranged in a specific order.|
| `NFKD`  | Normalization Form Compatibility Decomposition | Decomposes characters by compatibility, and multiple combining characters are arranged in a specific order.|

**Return type**

`STRING`

**Examples**

The following example normalizes different language characters:

```zetasql
SELECT
  NORMALIZE('\u00ea') as a,
  NORMALIZE('\u0065\u0302') as b,
  NORMALIZE('\u00ea') = NORMALIZE('\u0065\u0302') as normalized;

/*---+---+------------*
 | a | b | normalized |
 +---+---+------------+
 |  |  | TRUE       |
 *---+---+------------*/
```
The following examples normalize different space characters:

```zetasql
SELECT NORMALIZE('Raha\u2004Mahan', NFKC) AS normalized_name

/*-----------------*
 | normalized_name |
 +-----------------+
 | Raha Mahan      |
 *-----------------*/
```

```zetasql
SELECT NORMALIZE('Raha\u2005Mahan', NFKC) AS normalized_name

/*-----------------*
 | normalized_name |
 +-----------------+
 | Raha Mahan      |
 *-----------------*/
```

```zetasql
SELECT NORMALIZE('Raha\u2006Mahan', NFKC) AS normalized_name

/*-----------------*
 | normalized_name |
 +-----------------+
 | Raha Mahan      |
 *-----------------*/
```

```zetasql
SELECT NORMALIZE('Raha Mahan', NFKC) AS normalized_name

/*-----------------*
 | normalized_name |
 +-----------------+
 | Raha Mahan      |
 *-----------------*/
```

[string-link-to-normalization-wikipedia]: https://en.wikipedia.org/wiki/Unicode_equivalence#Normalization

### `NORMALIZE_AND_CASEFOLD`

```zetasql
NORMALIZE_AND_CASEFOLD(value[, normalization_mode])
```

**Description**

Takes a string value and returns it as a normalized string. If you don't
provide a normalization mode, `NFC` is used.

[Normalization][string-link-to-normalization-wikipedia] is used to ensure that
two strings are equivalent. Normalization is often used in situations in which
two strings render the same on the screen but have different Unicode code
points.

[Case folding][string-link-to-case-folding-wikipedia] is used for the caseless
comparison of strings. If you need to compare strings and case shouldn't be
considered, use `NORMALIZE_AND_CASEFOLD`, otherwise use
[`NORMALIZE`][string-link-to-normalize].

`NORMALIZE_AND_CASEFOLD` supports four optional normalization modes:

| Value   | Name                                           | Description|
|---------|------------------------------------------------|------------|
| `NFC`   | Normalization Form Canonical Composition       | Decomposes and recomposes characters by canonical equivalence.|
| `NFKC`  | Normalization Form Compatibility Composition   | Decomposes characters by compatibility, then recomposes them by canonical equivalence.|
| `NFD`   | Normalization Form Canonical Decomposition     | Decomposes characters by canonical equivalence, and multiple combining characters are arranged in a specific order.|
| `NFKD`  | Normalization Form Compatibility Decomposition | Decomposes characters by compatibility, and multiple combining characters are arranged in a specific order.|

**Return type**

`STRING`

**Examples**

```zetasql
SELECT
  NORMALIZE('The red barn') = NORMALIZE('The Red Barn') AS normalized,
  NORMALIZE_AND_CASEFOLD('The red barn')
    = NORMALIZE_AND_CASEFOLD('The Red Barn') AS normalized_with_case_folding;

/*------------+------------------------------*
 | normalized | normalized_with_case_folding |
 +------------+------------------------------+
 | FALSE      | TRUE                         |
 *------------+------------------------------*/
```

```zetasql
SELECT
  '\u2168' AS a,
  'IX' AS b,
  NORMALIZE_AND_CASEFOLD('\u2168', NFD)=NORMALIZE_AND_CASEFOLD('IX', NFD) AS nfd,
  NORMALIZE_AND_CASEFOLD('\u2168', NFC)=NORMALIZE_AND_CASEFOLD('IX', NFC) AS nfc,
  NORMALIZE_AND_CASEFOLD('\u2168', NFKD)=NORMALIZE_AND_CASEFOLD('IX', NFKD) AS nkfd,
  NORMALIZE_AND_CASEFOLD('\u2168', NFKC)=NORMALIZE_AND_CASEFOLD('IX', NFKC) AS nkfc;

/*---+----+-------+-------+------+------*
 | a | b  | nfd   | nfc   | nkfd | nkfc |
 +---+----+-------+-------+------+------+
 |  | IX | false | false | true | true |
 *---+----+-------+-------+------+------*/
```

```zetasql
SELECT
  '\u0041\u030A' AS a,
  '\u00C5' AS b,
  NORMALIZE_AND_CASEFOLD('\u0041\u030A', NFD)=NORMALIZE_AND_CASEFOLD('\u00C5', NFD) AS nfd,
  NORMALIZE_AND_CASEFOLD('\u0041\u030A', NFC)=NORMALIZE_AND_CASEFOLD('\u00C5', NFC) AS nfc,
  NORMALIZE_AND_CASEFOLD('\u0041\u030A', NFKD)=NORMALIZE_AND_CASEFOLD('\u00C5', NFKD) AS nkfd,
  NORMALIZE_AND_CASEFOLD('\u0041\u030A', NFKC)=NORMALIZE_AND_CASEFOLD('\u00C5', NFKC) AS nkfc;

/*---+----+-------+-------+------+------*
 | a | b  | nfd   | nfc   | nkfd | nkfc |
 +---+----+-------+-------+------+------+
 | A |   | true  | true  | true | true |
 *---+----+-------+-------+------+------*/
```

[string-link-to-normalization-wikipedia]: https://en.wikipedia.org/wiki/Unicode_equivalence#Normalization

[string-link-to-case-folding-wikipedia]: https://en.wikipedia.org/wiki/Letter_case#Case_folding

[string-link-to-normalize]: #normalize

### `OCTET_LENGTH`

```zetasql
OCTET_LENGTH(value)
```

Alias for [`BYTE_LENGTH`][byte-length].

[byte-length]: #byte_length

### `REGEXP_CONTAINS`

```zetasql
REGEXP_CONTAINS(value, regexp)
```

**Description**

Returns `TRUE` if `value` is a partial match for the regular expression,
`regexp`.

If the `regexp` argument is invalid, the function returns an error.

You can search for a full match by using `^` (beginning of text) and `$` (end of
text). Due to regular expression operator precedence, it's good practice to use
parentheses around everything between `^` and `$`.

Note: ZetaSQL provides regular expression support using the
[re2][string-link-to-re2] library; see that documentation for its
regular expression syntax.

**Return type**

`BOOL`

**Examples**

The following queries check to see if an email is valid:

```zetasql
SELECT
  'foo@example.com' AS email,
  REGEXP_CONTAINS('foo@example.com', r'@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+') AS is_valid

/*-----------------+----------*
 | email           | is_valid |
 +-----------------+----------+
 | foo@example.com | TRUE     |
 *-----------------+----------*/
 ```

 ```zetasql
SELECT
  'www.example.net' AS email,
  REGEXP_CONTAINS('www.example.net', r'@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+') AS is_valid

/*-----------------+----------*
 | email           | is_valid |
 +-----------------+----------+
 | www.example.net | FALSE    |
 *-----------------+----------*/
 ```

The following queries check to see if an email is valid. They
perform a full match, using `^` and `$`. Due to regular expression operator
precedence, it's good practice to use parentheses around everything between `^`
and `$`.

```zetasql
SELECT
  'a@foo.com' AS email,
  REGEXP_CONTAINS('a@foo.com', r'^([\w.+-]+@foo\.com|[\w.+-]+@bar\.org)$') AS valid_email_address,
  REGEXP_CONTAINS('a@foo.com', r'^[\w.+-]+@foo\.com|[\w.+-]+@bar\.org$') AS without_parentheses;

/*----------------+---------------------+---------------------*
 | email          | valid_email_address | without_parentheses |
 +----------------+---------------------+---------------------+
 | a@foo.com      | true                | true                |
 *----------------+---------------------+---------------------*/
```

```zetasql
SELECT
  'a@foo.computer' AS email,
  REGEXP_CONTAINS('a@foo.computer', r'^([\w.+-]+@foo\.com|[\w.+-]+@bar\.org)$') AS valid_email_address,
  REGEXP_CONTAINS('a@foo.computer', r'^[\w.+-]+@foo\.com|[\w.+-]+@bar\.org$') AS without_parentheses;

/*----------------+---------------------+---------------------*
 | email          | valid_email_address | without_parentheses |
 +----------------+---------------------+---------------------+
 | a@foo.computer | false               | true                |
 *----------------+---------------------+---------------------*/
```

```zetasql
SELECT
  'b@bar.org' AS email,
  REGEXP_CONTAINS('b@bar.org', r'^([\w.+-]+@foo\.com|[\w.+-]+@bar\.org)$') AS valid_email_address,
  REGEXP_CONTAINS('b@bar.org', r'^[\w.+-]+@foo\.com|[\w.+-]+@bar\.org$') AS without_parentheses;

/*----------------+---------------------+---------------------*
 | email          | valid_email_address | without_parentheses |
 +----------------+---------------------+---------------------+
 | b@bar.org      | true                | true                |
 *----------------+---------------------+---------------------*/
```

```zetasql
SELECT
  '!b@bar.org' AS email,
  REGEXP_CONTAINS('!b@bar.org', r'^([\w.+-]+@foo\.com|[\w.+-]+@bar\.org)$') AS valid_email_address,
  REGEXP_CONTAINS('!b@bar.org', r'^[\w.+-]+@foo\.com|[\w.+-]+@bar\.org$') AS without_parentheses;

/*----------------+---------------------+---------------------*
 | email          | valid_email_address | without_parentheses |
 +----------------+---------------------+---------------------+
 | !b@bar.org     | false               | true                |
 *----------------+---------------------+---------------------*/
```

```zetasql
SELECT
  'c@buz.net' AS email,
  REGEXP_CONTAINS('c@buz.net', r'^([\w.+-]+@foo\.com|[\w.+-]+@bar\.org)$') AS valid_email_address,
  REGEXP_CONTAINS('c@buz.net', r'^[\w.+-]+@foo\.com|[\w.+-]+@bar\.org$') AS without_parentheses;

/*----------------+---------------------+---------------------*
 | email          | valid_email_address | without_parentheses |
 +----------------+---------------------+---------------------+
 | c@buz.net      | false               | false               |
 *----------------+---------------------+---------------------*/
```

[string-link-to-re2]: https://github.com/google/re2/wiki/Syntax

### `REGEXP_EXTRACT`

```zetasql
REGEXP_EXTRACT(value, regexp[, position[, occurrence]])
```

**Description**

Returns the substring in `value` that matches the
[re2 regular expression][string-link-to-re2], `regexp`.
Returns `NULL` if there is no match.

If the regular expression contains a capturing group (`(...)`), and there is a
match for that capturing group, that match is returned. If there
are multiple matches for a capturing group, the first match is returned.

If `position` is specified, the search starts at this
position in `value`, otherwise it starts at the beginning of `value`. The
`position` must be a positive integer and can't be 0. If `position` is greater
than the length of `value`, `NULL` is returned.

If `occurrence` is specified, the search returns a specific occurrence of the
`regexp` in `value`, otherwise returns the first match. If `occurrence` is
greater than the number of matches found, `NULL` is returned. For
`occurrence` > 1, the function searches for additional occurrences beginning
with the character following the previous occurrence.

Returns an error if:

+ The regular expression is invalid
+ The regular expression has more than one capturing group
+ The `position` isn't a positive integer
+ The `occurrence` isn't a positive integer

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT REGEXP_EXTRACT('foo@example.com', r'^[a-zA-Z0-9_.+-]+') AS user_name

/*-----------*
 | user_name |
 +-----------+
 | foo       |
 *-----------*/
```

```zetasql
SELECT REGEXP_EXTRACT('foo@example.com', r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.([a-zA-Z0-9-.]+$)')

/*------------------*
 | top_level_domain |
 +------------------+
 | com              |
 *------------------*/
```

```zetasql
SELECT
  REGEXP_EXTRACT('ab', '.b') AS result_a,
  REGEXP_EXTRACT('ab', '(.)b') AS result_b,
  REGEXP_EXTRACT('xyztb', '(.)+b') AS result_c,
  REGEXP_EXTRACT('ab', '(z)?b') AS result_d

/*-------------------------------------------*
 | result_a | result_b | result_c | result_d |
 +-------------------------------------------+
 | ab       | a        | t        | NULL     |
 *-------------------------------------------*/
```

```zetasql
WITH example AS
(SELECT 'Hello Helloo and Hellooo' AS value, 'H?ello+' AS regex, 1 as position,
1 AS occurrence UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 1, 2 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 1, 3 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 1, 4 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 2, 1 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 3, 1 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 3, 2 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 3, 3 UNION ALL
SELECT 'Hello Helloo and Hellooo', 'H?ello+', 20, 1 UNION ALL
SELECT 'cats&dogs&rabbits' ,'\\w+&', 1, 2 UNION ALL
SELECT 'cats&dogs&rabbits', '\\w+&', 2, 3
)
SELECT value, regex, position, occurrence, REGEXP_EXTRACT(value, regex,
position, occurrence) AS regexp_value FROM example;

/*--------------------------+---------+----------+------------+--------------*
 | value                    | regex   | position | occurrence | regexp_value |
 +--------------------------+---------+----------+------------+--------------+
 | Hello Helloo and Hellooo | H?ello+ | 1        | 1          | Hello        |
 | Hello Helloo and Hellooo | H?ello+ | 1        | 2          | Helloo       |
 | Hello Helloo and Hellooo | H?ello+ | 1        | 3          | Hellooo      |
 | Hello Helloo and Hellooo | H?ello+ | 1        | 4          | NULL         |
 | Hello Helloo and Hellooo | H?ello+ | 2        | 1          | ello         |
 | Hello Helloo and Hellooo | H?ello+ | 3        | 1          | Helloo       |
 | Hello Helloo and Hellooo | H?ello+ | 3        | 2          | Hellooo      |
 | Hello Helloo and Hellooo | H?ello+ | 3        | 3          | NULL         |
 | Hello Helloo and Hellooo | H?ello+ | 20       | 1          | NULL         |
 | cats&dogs&rabbits        | \w+&    | 1        | 2          | dogs&        |
 | cats&dogs&rabbits        | \w+&    | 2        | 3          | NULL         |
 *--------------------------+---------+----------+------------+--------------*/
```

[string-link-to-re2]: https://github.com/google/re2/wiki/Syntax

### `REGEXP_EXTRACT_ALL`

```zetasql
REGEXP_EXTRACT_ALL(value, regexp)
```

**Description**

Returns an array of all substrings of `value` that match the
[re2 regular expression][string-link-to-re2], `regexp`. Returns an empty array
if there is no match.

If the regular expression contains a capturing group (`(...)`), and there is a
match for that capturing group, that match is added to the results.

The `REGEXP_EXTRACT_ALL` function only returns non-overlapping matches. For
example, using this function to extract `ana` from `banana` returns only one
substring, not two.

Returns an error if:

+ The regular expression is invalid
+ The regular expression has more than one capturing group

**Return type**

`ARRAY<STRING>` or `ARRAY<BYTES>`

**Examples**

```zetasql
SELECT REGEXP_EXTRACT_ALL('Try `func(x)` or `func(y)`', '`(.+?)`') AS example

/*--------------------*
 | example            |
 +--------------------+
 | [func(x), func(y)] |
 *--------------------*/
```

[string-link-to-re2]: https://github.com/google/re2/wiki/Syntax

### `REGEXP_INSTR`

```zetasql
REGEXP_INSTR(source_value, regexp [, position[, occurrence, [occurrence_position]]])
```

**Description**

Returns the lowest 1-based position of a regular expression, `regexp`, in
`source_value`. `source_value` and `regexp` must be the same type, either
`STRING` or `BYTES`.

If `position` is specified, the search starts at this position in
`source_value`, otherwise it starts at `1`, which is the beginning of
`source_value`. `position` is of type `INT64` and must be positive.

If `occurrence` is specified, the search returns the position of a specific
instance of `regexp` in `source_value`. If not specified, `occurrence` defaults
to `1` and returns the position of the first occurrence. For `occurrence` > 1,
the function searches for the next, non-overlapping occurrence.
`occurrence` is of type `INT64` and must be positive.

You can optionally use `occurrence_position` to specify where a position
in relation to an `occurrence` starts. Your choices are:

+  `0`: Returns the start position of `occurrence`.
+  `1`: Returns the end position of `occurrence` + `1`. If the
   end of the occurrence is at the end of `source_value `,
   `LENGTH(source_value) + 1` is returned.

Returns `0` if:

+ No match is found.
+ If `occurrence` is greater than the number of matches found.
+ If `position` is greater than the length of `source_value`.
+ The regular expression is empty.

Returns `NULL` if:

+ `position` is `NULL`.
+ `occurrence` is `NULL`.

Returns an error if:

+ `position` is `0` or negative.
+ `occurrence` is `0` or negative.
+ `occurrence_position` is neither `0` nor `1`.
+ The regular expression is invalid.
+ The regular expression has more than one capturing group.

**Return type**

`INT64`

**Examples**

```zetasql
SELECT
  REGEXP_INSTR('ab@cd-ef',  '@[^-]*') AS instr_a,
  REGEXP_INSTR('ab@d-ef',   '@[^-]*') AS instr_b,
  REGEXP_INSTR('abc@cd-ef', '@[^-]*') AS instr_c,
  REGEXP_INSTR('abc-ef',    '@[^-]*') AS instr_d,

/*---------------------------------------*
 | instr_a | instr_b | instr_c | instr_d |
 +---------------------------------------+
 | 3       | 3       | 4       | 0       |
 *---------------------------------------*/
```

```zetasql
SELECT
  REGEXP_INSTR('a@cd-ef b@cd-ef', '@[^-]*', 1) AS instr_a,
  REGEXP_INSTR('a@cd-ef b@cd-ef', '@[^-]*', 2) AS instr_b,
  REGEXP_INSTR('a@cd-ef b@cd-ef', '@[^-]*', 3) AS instr_c,
  REGEXP_INSTR('a@cd-ef b@cd-ef', '@[^-]*', 4) AS instr_d,

/*---------------------------------------*
 | instr_a | instr_b | instr_c | instr_d |
 +---------------------------------------+
 | 2       | 2       | 10      | 10      |
 *---------------------------------------*/
```

```zetasql
SELECT
  REGEXP_INSTR('a@cd-ef b@cd-ef c@cd-ef', '@[^-]*', 1, 1) AS instr_a,
  REGEXP_INSTR('a@cd-ef b@cd-ef c@cd-ef', '@[^-]*', 1, 2) AS instr_b,
  REGEXP_INSTR('a@cd-ef b@cd-ef c@cd-ef', '@[^-]*', 1, 3) AS instr_c

/*-----------------------------*
 | instr_a | instr_b | instr_c |
 +-----------------------------+
 | 2       | 10      | 18      |
 *-----------------------------*/
```

```zetasql
SELECT
  REGEXP_INSTR('a@cd-ef', '@[^-]*', 1, 1, 0) AS instr_a,
  REGEXP_INSTR('a@cd-ef', '@[^-]*', 1, 1, 1) AS instr_b

/*-------------------*
 | instr_a | instr_b |
 +-------------------+
 | 2       | 5       |
 *-------------------*/
```

### `REGEXP_MATCH` (Deprecated) 
<a id="regexp_match"></a>

```zetasql
REGEXP_MATCH(value, regexp)
```

**Description**

Returns `TRUE` if `value` is a full match for the regular expression, `regexp`.

If the `regexp` argument is invalid, the function returns an error.

This function is deprecated. When possible, use
[`REGEXP_CONTAINS`][regexp-contains] to find a partial match for a
regular expression.

Note: ZetaSQL provides regular expression support using the
[re2][string-link-to-re2] library; see that documentation for its
regular expression syntax.

**Return type**

`BOOL`

**Examples**

```zetasql
WITH email_addresses AS
  (SELECT 'foo@example.com' as email
  UNION ALL
  SELECT 'bar@example.org' as email
  UNION ALL
  SELECT 'notavalidemailaddress' as email)

SELECT
  email,
  REGEXP_MATCH(email,
               r'[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+')
               AS valid_email_address
FROM email_addresses;

/*-----------------------+---------------------*
 | email                 | valid_email_address |
 +-----------------------+---------------------+
 | foo@example.com       | true                |
 | bar@example.org       | true                |
 | notavalidemailaddress | false               |
 *-----------------------+---------------------*/
```

[string-link-to-re2]: https://github.com/google/re2/wiki/Syntax

[regexp-contains]: #regexp_contains

### `REGEXP_REPLACE`

```zetasql
REGEXP_REPLACE(value, regexp, replacement)
```

**Description**

Returns a `STRING` where all substrings of `value` that
match regular expression `regexp` are replaced with `replacement`.

You can use backslashed-escaped digits (\1 to \9) within the `replacement`
argument to insert text matching the corresponding parenthesized group in the
`regexp` pattern. Use \0 to refer to the entire matching text.

To add a backslash in your regular expression, you must first escape it. For
example, `SELECT REGEXP_REPLACE('abc', 'b(.)', 'X\\1');` returns `aXc`. You can
also use [raw strings][string-link-to-lexical-literals] to remove one layer of
escaping, for example `SELECT REGEXP_REPLACE('abc', 'b(.)', r'X\1');`.

The `REGEXP_REPLACE` function only replaces non-overlapping matches. For
example, replacing `ana` within `banana` results in only one replacement, not
two.

If the `regexp` argument isn't a valid regular expression, this function
returns an error.

Note: ZetaSQL provides regular expression support using the
[re2][string-link-to-re2] library; see that documentation for its
regular expression syntax.

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT REGEXP_REPLACE('# Heading', r'^# ([a-zA-Z0-9\s]+$)', '<h1>\\1</h1>') AS html

/*--------------------------*
 | html                     |
 +--------------------------+
 | <h1>Heading</h1>         |
 *--------------------------*/
```

[string-link-to-re2]: https://github.com/google/re2/wiki/Syntax

[string-link-to-lexical-literals]: https://github.com/google/zetasql/blob/master/docs/lexical.md#string_and_bytes_literals

### `REGEXP_SUBSTR`

```zetasql
REGEXP_SUBSTR(value, regexp[, position[, occurrence]])
```

**Description**

Synonym for [REGEXP_EXTRACT][string-link-to-regex].

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
WITH example AS
(SELECT 'Hello World Helloo' AS value, 'H?ello+' AS regex, 1 AS position, 1 AS
occurrence
)
SELECT value, regex, position, occurrence, REGEXP_SUBSTR(value, regex,
position, occurrence) AS regexp_value FROM example;

/*--------------------+---------+----------+------------+--------------*
 | value              | regex   | position | occurrence | regexp_value |
 +--------------------+---------+----------+------------+--------------+
 | Hello World Helloo | H?ello+ | 1        | 1          | Hello        |
 *--------------------+---------+----------+------------+--------------*/
```

[string-link-to-regex]: #regexp_extract

### `REPEAT`

```zetasql
REPEAT(original_value, repetitions)
```

**Description**

Returns a `STRING` or `BYTES` value that consists of `original_value`, repeated.
The `repetitions` parameter specifies the number of times to repeat
`original_value`. Returns `NULL` if either `original_value` or `repetitions`
are `NULL`.

This function returns an error if the `repetitions` value is negative.

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT REPEAT('abc', 3) AS results

/*-----------*
 | results   |
 |-----------|
 | abcabcabc |
 *-----------*/
```

```zetasql
SELECT REPEAT('abc', NULL) AS results

/*---------*
 | results |
 |---------|
 | NULL    |
 *---------*/
```

```zetasql
SELECT REPEAT(NULL, 3) AS results

/*---------*
 | results |
 |---------|
 | NULL    |
 *---------*/
```

### `REPLACE`

```zetasql
REPLACE(original_value, from_pattern, to_pattern)
```

**Description**

Replaces all occurrences of `from_pattern` with `to_pattern` in
`original_value`. If `from_pattern` is empty, no replacement is made.

This function supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
WITH desserts AS
  (SELECT 'apple pie' as dessert
  UNION ALL
  SELECT 'blackberry pie' as dessert
  UNION ALL
  SELECT 'cherry pie' as dessert)

SELECT
  REPLACE (dessert, 'pie', 'cobbler') as example
FROM desserts;

/*--------------------*
 | example            |
 +--------------------+
 | apple cobbler      |
 | blackberry cobbler |
 | cherry cobbler     |
 *--------------------*/
```

### `REVERSE`

```zetasql
REVERSE(value)
```

**Description**

Returns the reverse of the input `STRING` or `BYTES`.

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT REVERSE('abc') AS results

/*---------*
 | results |
 +---------+
 | cba     |
 *---------*/
```

```zetasql
SELECT FORMAT('%T', REVERSE(b'1a3')) AS results

/*---------*
 | results |
 +---------+
 | b"3a1"  |
 *---------*/
```

### `RIGHT`

```zetasql
RIGHT(value, length)
```

**Description**

Returns a `STRING` or `BYTES` value that consists of the specified
number of rightmost characters or bytes from `value`. The `length` is an
`INT64` that specifies the length of the returned
value. If `value` is `BYTES`, `length` is the number of rightmost bytes to
return. If `value` is `STRING`, `length` is the number of rightmost characters
to return.

If `length` is 0, an empty `STRING` or `BYTES` value will be
returned. If `length` is negative, an error will be returned. If `length`
exceeds the number of characters or bytes from `value`, the original `value`
will be returned.

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT 'apple' AS example, RIGHT('apple', 3) AS right_example

/*---------+---------------*
 | example | right_example |
 +---------+---------------+
 | apple   | ple           |
 *---------+---------------*/
```

```zetasql
SELECT b'apple' AS example, RIGHT(b'apple', 3) AS right_example

/*----------------------+---------------*
 | example              | right_example |
 +----------------------+---------------+
 | apple                | ple           |
 *----------------------+---------------*
```

### `RPAD`

```zetasql
RPAD(original_value, return_length[, pattern])
```

**Description**

Returns a `STRING` or `BYTES` value that consists of `original_value` appended
with `pattern`. The `return_length` parameter is an
`INT64` that specifies the length of the
returned value. If `original_value` is `BYTES`,
`return_length` is the number of bytes. If `original_value` is `STRING`,
`return_length` is the number of characters.

The default value of `pattern` is a blank space.

Both `original_value` and `pattern` must be the same data type.

If `return_length` is less than or equal to the `original_value` length, this
function returns the `original_value` value, truncated to the value of
`return_length`. For example, `RPAD('hello world', 7);` returns `'hello w'`.

If `original_value`, `return_length`, or `pattern` is `NULL`, this function
returns `NULL`.

This function returns an error if:

+ `return_length` is negative
+ `pattern` is empty

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT FORMAT('%T', RPAD('c', 5)) AS results

/*---------*
 | results |
 +---------+
 | "c    " |
 *---------*/
```

```zetasql
SELECT RPAD('b', 5, 'a') AS results

/*---------*
 | results |
 +---------+
 | baaaa   |
 *---------*/
```

```zetasql
SELECT RPAD('abc', 10, 'ghd') AS results

/*------------*
 | results    |
 +------------+
 | abcghdghdg |
 *------------*/
```

```zetasql
SELECT RPAD('abc', 2, 'd') AS results

/*---------*
 | results |
 +---------+
 | ab      |
 *---------*/
```

```zetasql
SELECT FORMAT('%T', RPAD(b'abc', 10, b'ghd')) AS results

/*---------------*
 | results       |
 +---------------+
 | b"abcghdghdg" |
 *---------------*/
```

### `RTRIM`

```zetasql
RTRIM(value1[, value2])
```

**Description**

Identical to [TRIM][string-link-to-trim], but only removes trailing characters.

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT RTRIM('***apple***', '*') AS example

/*-----------*
 | example   |
 +-----------+
 | ***apple  |
 *-----------*/
```

```zetasql
SELECT RTRIM('applexxz', 'xyz') AS example

/*---------*
 | example |
 +---------+
 | apple   |
 *---------*/
```

[string-link-to-trim]: #trim

### `SAFE_CONVERT_BYTES_TO_STRING`

```zetasql
SAFE_CONVERT_BYTES_TO_STRING(value)
```

**Description**

Converts a sequence of `BYTES` to a `STRING`. Any invalid UTF-8 characters are
replaced with the Unicode replacement character, `U+FFFD`.

**Return type**

`STRING`

**Examples**

The following statement returns the Unicode replacement character, &#65533;.

```zetasql
SELECT SAFE_CONVERT_BYTES_TO_STRING(b'\xc2') as safe_convert;
```

### `SOUNDEX`

```zetasql
SOUNDEX(value)
```

**Description**

Returns a `STRING` that represents the
[Soundex][string-link-to-soundex-wikipedia] code for `value`.

SOUNDEX produces a phonetic representation of a string. It indexes words by
sound, as pronounced in English. It's typically used to help determine whether
two strings, such as the family names _Levine_ and _Lavine_, or the words _to_
and _too_, have similar English-language pronunciation.

The result of the SOUNDEX consists of a letter followed by 3 digits. Non-latin
characters are ignored. If the remaining string is empty after removing
non-Latin characters, an empty `STRING` is returned.

**Return type**

`STRING`

**Examples**

```zetasql
SELECT 'Ashcraft' AS value, SOUNDEX('Ashcraft') AS soundex

/*----------------------+---------*
 | value                | soundex |
 +----------------------+---------+
 | Ashcraft             | A261    |
 *----------------------+---------*/
```

[string-link-to-soundex-wikipedia]: https://en.wikipedia.org/wiki/Soundex

### `SPLIT`

```zetasql
SPLIT(value[, delimiter])
```

**Description**

Splits a `STRING` or `BYTES` value, using a delimiter. The `delimiter` argument
must be a literal character or sequence of characters. You can't split with a
regular expression.

For `STRING`, the default delimiter is the comma `,`.

For `BYTES`, you must specify a delimiter.

Splitting on an empty delimiter produces an array of UTF-8 characters for
`STRING` values, and an array of `BYTES` for `BYTES` values.

Splitting an empty `STRING` returns an
`ARRAY` with a single empty
`STRING`.

This function supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

**Return type**

`ARRAY<STRING>` or `ARRAY<BYTES>`

**Examples**

```zetasql
WITH letters AS
  (SELECT '' as letter_group
  UNION ALL
  SELECT 'a' as letter_group
  UNION ALL
  SELECT 'b c d' as letter_group)

SELECT SPLIT(letter_group, ' ') as example
FROM letters;

/*----------------------*
 | example              |
 +----------------------+
 | []                   |
 | [a]                  |
 | [b, c, d]            |
 *----------------------*/
```

### `SPLIT_SUBSTR`

```zetasql
SPLIT_SUBSTR(value, delimiter, start_split[, count])
```

**Description**

Returns a substring from an input `STRING` that's determined by a delimiter, a
location that indicates the first split of the substring to return, and the
number of splits to include in the returned substring.

The `value` argument is the supplied `STRING` value from which a substring is
returned.

The `delimiter` argument is the delimiter used to split the input `STRING`. It
must be a literal character or sequence of characters.

+ The `delimiter` argument can't be a regular expression.
+ Delimiter matching is from left to right.
+ If the delimiter is a sequence of characters, then two instances of the
  delimiter in the input string can't overlap. For example, if the delimiter is
  `**`, then the delimiters in the string `aa***bb***cc` are:
    + The first two asterisks after `aa`.
    + The first two asterisks after `bb`.

The `start_split` argument is an integer that specifies the first split of the
substring to return.

+ If `start_split` is `1`, then the returned substring starts from the first
  split.
+ If `start_split` is `0` or less than the negative of the number of splits,
  then `start_split` is treated as if it's `1` and returns a substring that
  starts with the first split.
+ If `start_split` is greater than the number of splits, then an empty string is
  returned.
+ If `start_split` is negative, then the splits are counted from the end of the
  input string. If `start_split` is `-1`, then the last split in the input
  string is returned.

The optional `count` argument is an integer that specifies the maximum number
of splits to include in the returned substring.

+ If `count` isn't specified, then the substring from the `start_split`
  position to the end of the input string is returned.
+ If `count` is `0`, an empty string is returned.
+ If `count` is negative, an error is returned.
+ If the sum of `count` plus `start_split` is greater than the number of splits,
  then a substring from `start_split` to the end of the input string is
  returned.

This function supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

**Return type**

`STRING`

**Examples**

The following example returns an empty string because `count` is `0`:

```zetasql
SELECT SPLIT_SUBSTR("www.abc.xyz.com", ".", 1, 0) AS example

/*---------*
 | example |
 +---------+
 |         |
 *---------*/
```

The following example returns two splits starting with the first split:

```zetasql
SELECT SPLIT_SUBSTR("www.abc.xyz.com", ".", 1, 2) AS example

/*---------*
 | example |
 +---------+
 | www.abc |
 *---------*/
```

The following example returns one split starting with the first split:

```zetasql
SELECT SPLIT_SUBSTR("www.abc.xyz.com", ".", 1, 1) AS example

/*---------*
 | example |
 +---------+
 | www     |
 *---------*/
```

The following example returns splits from the right because `start_split` is a
negative value:

```zetasql
SELECT SPLIT_SUBSTR("www.abc.xyz.com", ".", -1, 1) AS example

/*---------*
 | example |
 +---------+
 | com     |
 *---------*/
```

The following example returns a substring with three splits, starting with the
first split:

```zetasql
SELECT SPLIT_SUBSTR("www.abc.xyz.com", ".", 1, 3) AS example

/*-------------*
 | example     |
 +-------------+
 | www.abc.xyz |
 *------------*/
```

If `start_split` is zero, then it's treated as if it's `1`. The following
example returns three substrings starting with the first split:

```zetasql
SELECT SPLIT_SUBSTR("www.abc.xyz.com", ".", 0, 3) AS example

/*-------------*
 | example     |
 +-------------+
 | www.abc.xyz |
 *------------*/
```

If `start_split` is greater than the number of splits, then an empty string is
returned:

```zetasql
SELECT SPLIT_SUBSTR("www.abc.xyz.com", ".", 5, 3) AS example

/*---------*
 | example |
 +---------+
 |         |
 *--------*/
```

In the following example, the `start_split` value (`-5`) is less than the
negative of the number of splits (`-4`), so `start_split` is treated as `1`:

```zetasql
SELECT SPLIT_SUBSTR("www.abc.xyz.com", ".", -5, 3) AS example

/*-------------*
 | example     |
 +-------------+
 | www.abc.xyz |
 *------------*/
```

In the following example, the substring from `start_split` to the end of the
string is returned because `count` isn't specified:

```zetasql
SELECT SPLIT_SUBSTR("www.abc.xyz.com", ".", 3) AS example

/*---------*
 | example |
 +---------+
 | xyz.com |
 *--------*/
```

The following two examples demonstrate how `SPLIT_SUBSTR` works with a
multi-character delimiter that has overlapping matches in the input string. In
each example, the input string contains instances of three asterisks in a row
(`***`) and the delimiter is two asterisks (`**`).

```zetasql
SELECT SPLIT_SUBSTR('aaa***bbb***ccc', '**', 1, 2) AS example

/*-----------*
 | example   |
 +-----------+
 | aaa***bbb |
 *----------*/
```

```zetasql
SELECT SPLIT_SUBSTR('aaa***bbb***ccc', '**', 2, 2) AS example

/*------------*
 | example    |
 +------------+
 | *bbb***ccc |
 *-----------*/
```

### `STARTS_WITH`

```zetasql
STARTS_WITH(value, prefix)
```

**Description**

Takes two `STRING` or `BYTES` values. Returns `TRUE` if `prefix` is a
prefix of `value`.

This function supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

**Return type**

`BOOL`

**Examples**

```zetasql
SELECT STARTS_WITH('bar', 'b') AS example

/*---------*
 | example |
 +---------+
 |    True |
 *---------*/
```

### `STRPOS`

```zetasql
STRPOS(value, subvalue)
```

**Description**

Takes two `STRING` or `BYTES` values. Returns the 1-based position of the first
occurrence of `subvalue` inside `value`. Returns `0` if `subvalue` isn't found.

This function supports specifying [collation][collation].

[collation]: https://github.com/google/zetasql/blob/master/docs/collation-concepts.md#collate_about

**Return type**

`INT64`

**Examples**

```zetasql
SELECT STRPOS('foo@example.com', '@') AS example

/*---------*
 | example |
 +---------+
 |       4 |
 *---------*/
```

### `SUBSTR`

```zetasql
SUBSTR(value, position[, length])
```

**Description**

Gets a portion (substring) of the supplied `STRING` or `BYTES` value.

The `position` argument is an integer specifying the starting position of the
substring.

+ If `position` is `1`, the substring starts from the first character or byte.
+ If `position` is `0` or less than `-LENGTH(value)`, `position` is set to `1`,
  and the substring starts from the first character or byte.
+ If `position` is greater than the length of `value`, the function produces
  an empty substring.
+ If `position` is negative, the function counts from the end of `value`,
  with `-1` indicating the last character or byte.

The `length` argument specifies the maximum number of characters or bytes to
return.

+ If `length` isn't specified, the function produces a substring that starts
  at the specified position and ends at the last character or byte of `value`.
+ If `length` is `0`, the function produces an empty substring.
+ If `length` is negative, the function produces an error.
+ The returned substring may be shorter than `length`, for example, when
  `length` exceeds the length of `value`, or when the starting position of the
  substring plus `length` is greater than the length of `value`.

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT SUBSTR('apple', 2) AS example

/*---------*
 | example |
 +---------+
 | pple    |
 *---------*/
```

```zetasql
SELECT SUBSTR('apple', 2, 2) AS example

/*---------*
 | example |
 +---------+
 | pp      |
 *---------*/
```

```zetasql
SELECT SUBSTR('apple', -2) AS example

/*---------*
 | example |
 +---------+
 | le      |
 *---------*/
```

```zetasql
SELECT SUBSTR('apple', 1, 123) AS example

/*---------*
 | example |
 +---------+
 | apple   |
 *---------*/
```

```zetasql
SELECT SUBSTR('apple', 123) AS example

/*---------*
 | example |
 +---------+
 |         |
 *---------*/
```

```zetasql
SELECT SUBSTR('apple', 123, 5) AS example

/*---------*
 | example |
 +---------+
 |         |
 *---------*/
```

### `SUBSTRING`

```zetasql
SUBSTRING(value, position[, length])
```

Alias for [`SUBSTR`][substr].

[substr]: #substr

### `TO_BASE32`

```zetasql
TO_BASE32(bytes_expr)
```

**Description**

Converts a sequence of `BYTES` into a base32-encoded `STRING`. To convert a
base32-encoded `STRING` into `BYTES`, use [FROM_BASE32][string-link-to-from-base32].

**Return type**

`STRING`

**Example**

```zetasql
SELECT TO_BASE32(b'abcde\xFF') AS base32_string;

/*------------------*
 | base32_string    |
 +------------------+
 | MFRGGZDF74====== |
 *------------------*/
```

[string-link-to-from-base32]: #from_base32

### `TO_BASE64`

```zetasql
TO_BASE64(bytes_expr)
```

**Description**

Converts a sequence of `BYTES` into a base64-encoded `STRING`. To convert a
base64-encoded `STRING` into `BYTES`, use [FROM_BASE64][string-link-to-from-base64].

There are several base64 encodings in common use that vary in exactly which
alphabet of 65 ASCII characters are used to encode the 64 digits and padding.
See [RFC 4648][RFC-4648] for details. This
function adds padding and uses the alphabet `[A-Za-z0-9+/=]`.

**Return type**

`STRING`

**Example**

```zetasql
SELECT TO_BASE64(b'\377\340') AS base64_string;

/*---------------*
 | base64_string |
 +---------------+
 | /+A=          |
 *---------------*/
```

To work with an encoding using a different base64 alphabet, you might need to
compose `TO_BASE64` with the `REPLACE` function. For instance, the
`base64url` url-safe and filename-safe encoding commonly used in web programming
uses `-_=` as the last characters rather than `+/=`. To encode a
`base64url`-encoded string, replace `+` and `/` with `-` and `_` respectively.

```zetasql
SELECT REPLACE(REPLACE(TO_BASE64(b'\377\340'), '+', '-'), '/', '_') as websafe_base64;

/*----------------*
 | websafe_base64 |
 +----------------+
 | _-A=           |
 *----------------*/
```

[string-link-to-from-base64]: #from_base64

[RFC-4648]: https://tools.ietf.org/html/rfc4648#section-4

### `TO_CODE_POINTS`

```zetasql
TO_CODE_POINTS(value)
```

**Description**

Takes a `STRING` or `BYTES` value and returns an array of `INT64` values that
represent code points or extended ASCII character values.

+ If `value` is a `STRING`, each element in the returned array represents a
  [code point][string-link-to-code-points-wikipedia]. Each code point falls
  within the range of [0, 0xD7FF] and [0xE000, 0x10FFFF].
+ If `value` is `BYTES`, each element in the array is an extended ASCII
  character value in the range of [0, 255].

To convert from an array of code points to a `STRING` or `BYTES`, see
[CODE_POINTS_TO_STRING][string-link-to-codepoints-to-string] or
[CODE_POINTS_TO_BYTES][string-link-to-codepoints-to-bytes].

**Return type**

`ARRAY<INT64>`

**Examples**

The following examples get the code points for each element in an array of
words.

```zetasql
SELECT
  'foo' AS word,
  TO_CODE_POINTS('foo') AS code_points

/*---------+------------------------------------*
 | word    | code_points                        |
 +---------+------------------------------------+
 | foo     | [102, 111, 111]                    |
 *---------+------------------------------------*/
```

```zetasql
SELECT
  'bar' AS word,
  TO_CODE_POINTS('bar') AS code_points

/*---------+------------------------------------*
 | word    | code_points                        |
 +---------+------------------------------------+
 | bar     | [98, 97, 114]                      |
 *---------+------------------------------------*/
```

```zetasql
SELECT
  'baz' AS word,
  TO_CODE_POINTS('baz') AS code_points

/*---------+------------------------------------*
 | word    | code_points                        |
 +---------+------------------------------------+
 | baz     | [98, 97, 122]                      |
 *---------+------------------------------------*/
```

```zetasql
SELECT
  'giraffe' AS word,
  TO_CODE_POINTS('giraffe') AS code_points

/*---------+------------------------------------*
 | word    | code_points                        |
 +---------+------------------------------------+
 | giraffe | [103, 105, 114, 97, 102, 102, 101] |
 *---------+------------------------------------*/
```

```zetasql
SELECT
  'llama' AS word,
  TO_CODE_POINTS('llama') AS code_points

/*---------+------------------------------------*
 | word    | code_points                        |
 +---------+------------------------------------+
 | llama   | [108, 108, 97, 109, 97]            |
 *---------+------------------------------------*/
```

The following examples convert integer representations of `BYTES` to their
corresponding ASCII character values.

```zetasql
SELECT
  b'\x66\x6f\x6f' AS bytes_value,
  TO_CODE_POINTS(b'\x66\x6f\x6f') AS bytes_value_as_integer

/*------------------+------------------------*
 | bytes_value      | bytes_value_as_integer |
 +------------------+------------------------+
 | foo              | [102, 111, 111]        |
 *------------------+------------------------*/
```

```zetasql
SELECT
  b'\x00\x01\x10\xff' AS bytes_value,
  TO_CODE_POINTS(b'\x00\x01\x10\xff') AS bytes_value_as_integer

/*------------------+------------------------*
 | bytes_value      | bytes_value_as_integer |
 +------------------+------------------------+
 | \x00\x01\x10\xff | [0, 1, 16, 255]        |
 *------------------+------------------------*/
```

The following example demonstrates the difference between a `BYTES` result and a
`STRING` result. Notice that the character `` is represented as a two-byte
Unicode sequence. As a result, the `BYTES` version of `TO_CODE_POINTS` returns
an array with two elements, while the `STRING` version returns an array with a
single element.

```zetasql
SELECT TO_CODE_POINTS(b'') AS b_result, TO_CODE_POINTS('') AS s_result;

/*------------+----------*
 | b_result   | s_result |
 +------------+----------+
 | [196, 128] | [256]    |
 *------------+----------*/
```

[string-link-to-code-points-wikipedia]: https://en.wikipedia.org/wiki/Code_point

[string-link-to-codepoints-to-string]: #code_points_to_string

[string-link-to-codepoints-to-bytes]: #code_points_to_bytes

### `TO_HEX`

```zetasql
TO_HEX(bytes)
```

**Description**

Converts a sequence of `BYTES` into a hexadecimal `STRING`. Converts each byte
in the `STRING` as two hexadecimal characters in the range
`(0..9, a..f)`. To convert a hexadecimal-encoded
`STRING` to `BYTES`, use [FROM_HEX][string-link-to-from-hex].

**Return type**

`STRING`

**Example**

```zetasql
SELECT
  b'\x00\x01\x02\x03\xAA\xEE\xEF\xFF' AS byte_string,
  TO_HEX(b'\x00\x01\x02\x03\xAA\xEE\xEF\xFF') AS hex_string

/*----------------------------------+------------------*
 | byte_string                      | hex_string       |
 +----------------------------------+------------------+
 | \x00\x01\x02\x03\xaa\xee\xef\xff | 00010203aaeeefff |
 *----------------------------------+------------------*/
```

[string-link-to-from-hex]: #from_hex

### `TRANSLATE`

```zetasql
TRANSLATE(expression, source_characters, target_characters)
```

**Description**

In `expression`, replaces each character in `source_characters` with the
corresponding character in `target_characters`. All inputs must be the same
type, either `STRING` or `BYTES`.

+ Each character in `expression` is translated at most once.
+ A character in `expression` that isn't present in `source_characters` is left
  unchanged in `expression`.
+ A character in `source_characters` without a corresponding character in
  `target_characters` is omitted from the result.
+ A duplicate character in `source_characters` results in an error.

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT TRANSLATE('This is a cookie', 'sco', 'zku') AS translate

/*------------------*
 | translate        |
 +------------------+
 | Thiz iz a kuukie |
 *------------------*/
```

### `TRIM`

```zetasql
TRIM(value_to_trim[, set_of_characters_to_remove])
```

**Description**

Takes a `STRING` or `BYTES` value to trim.

If the value to trim is a `STRING`, removes from this value all leading and
trailing Unicode code points in `set_of_characters_to_remove`.
The set of code points is optional. If it isn't specified, all
whitespace characters are removed from the beginning and end of the
value to trim.

If the value to trim is `BYTES`, removes from this value all leading and
trailing bytes in `set_of_characters_to_remove`. The set of bytes is required.

**Return type**

+ `STRING` if `value_to_trim` is a `STRING` value.
+ `BYTES` if `value_to_trim` is a `BYTES` value.

**Examples**

In the following example, all leading and trailing whitespace characters are
removed from `item` because `set_of_characters_to_remove` isn't specified.

```zetasql
SELECT CONCAT('#', TRIM( '   apple   '), '#') AS example

/*----------*
 | example  |
 +----------+
 | #apple#  |
 *----------*/
```

In the following example, all leading and trailing `*` characters are removed
from '***apple***'.

```zetasql
SELECT TRIM('***apple***', '*') AS example

/*---------*
 | example |
 +---------+
 | apple   |
 *---------*/
```

In the following example, all leading and trailing `x`, `y`, and `z` characters
are removed from 'xzxapplexxy'.

```zetasql
SELECT TRIM('xzxapplexxy', 'xyz') as example

/*---------*
 | example |
 +---------+
 | apple   |
 *---------*/
```

In the following example, examine how `TRIM` interprets characters as
Unicode code-points. If your trailing character set contains a combining
diacritic mark over a particular letter, `TRIM` might strip the
same diacritic mark from a different letter.

```zetasql
SELECT
  TRIM('abaW', 'Y') AS a,
  TRIM('Waba', 'Y') AS b,
  TRIM('aba', 'Y') AS c,
  TRIM('aba', 'Y') AS d

/*------+------+------+------*
 | a    | b    | c    | d    |
 +------+------+------+------+
 | abaW | Waba | aba | aba |
 *------+------+------+------*/
```

In the following example, all leading and trailing `b'n'`, `b'a'`, `b'\xab'`
bytes are removed from `item`.

```zetasql
SELECT b'apple', TRIM(b'apple', b'na\xab') AS example

/*----------------------+------------------*
 | item                 | example          |
 +----------------------+------------------+
 | apple                | pple             |
 *----------------------+------------------*/
```

### `UNICODE`

```zetasql
UNICODE(value)
```

**Description**

Returns the Unicode [code point][string-code-point] for the first character in
`value`. Returns `0` if `value` is empty, or if the resulting Unicode code
point is `0`.

**Return type**

`INT64`

**Examples**

```zetasql
SELECT UNICODE('bcd') as A, UNICODE('') as B, UNICODE('') as C, UNICODE(NULL) as D;

/*-------+-------+-------+-------*
 | A     | B     | C     | D     |
 +-------+-------+-------+-------+
 | 226   | 226   | 0     | NULL  |
 *-------+-------+-------+-------*/
```

[string-code-point]: https://en.wikipedia.org/wiki/Code_point

### `UPPER`

```zetasql
UPPER(value)
```

**Description**

For `STRING` arguments, returns the original string with all alphabetic
characters in uppercase. Mapping between uppercase and lowercase is done
according to the
[Unicode Character Database][string-link-to-unicode-character-definitions]
without taking into account language-specific mappings.

For `BYTES` arguments, the argument is treated as ASCII text, with all bytes
greater than 127 left intact.

**Return type**

`STRING` or `BYTES`

**Examples**

```zetasql
SELECT UPPER('foo') AS example

/*---------*
 | example |
 +---------+
 | FOO     |
 *---------*/
```

[string-link-to-unicode-character-definitions]: http://unicode.org/ucd/

[string-link-to-strpos]: #strpos

## Time functions

ZetaSQL supports the following time functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#current_time"><code>CURRENT_TIME</code></a>
</td>
  <td>
    Returns the current time as a <code>TIME</code> value.
  </td>
</tr>

<tr>
  <td><a href="#extract"><code>EXTRACT</code></a>
</td>
  <td>
    Extracts part of a <code>TIME</code> value.
  </td>
</tr>

<tr>
  <td><a href="#format_time"><code>FORMAT_TIME</code></a>
</td>
  <td>
    Formats a <code>TIME</code> value according to the specified format string.
  </td>
</tr>

<tr>
  <td><a href="#parse_time"><code>PARSE_TIME</code></a>
</td>
  <td>
    Converts a <code>STRING</code> value to a <code>TIME</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#time"><code>TIME</code></a>
</td>
  <td>
    Constructs a <code>TIME</code> value.
  </td>
</tr>

<tr>
  <td><a href="#time_add"><code>TIME_ADD</code></a>
</td>
  <td>
    Adds a specified time interval to a <code>TIME</code> value.
  </td>
</tr>

<tr>
  <td><a href="#time_diff"><code>TIME_DIFF</code></a>
</td>
  <td>
    Gets the number of unit boundaries between two <code>TIME</code> values at
    a particular time granularity.
  </td>
</tr>

<tr>
  <td><a href="#time_sub"><code>TIME_SUB</code></a>
</td>
  <td>
    Subtracts a specified time interval from a <code>TIME</code> value.
  </td>
</tr>

<tr>
  <td><a href="#time_trunc"><code>TIME_TRUNC</code></a>
</td>
  <td>
    Truncates a <code>TIME</code> value at a particular granularity.
  </td>
</tr>

  </tbody>
</table>

### `CURRENT_TIME`

```zetasql
CURRENT_TIME([time_zone])
```

```zetasql
CURRENT_TIME
```

**Description**

Returns the current time as a `TIME` object. Parentheses are optional when
called with no arguments.

This function supports an optional `time_zone` parameter.
See [Time zone definitions][time-link-to-timezone-definitions] for information
on how to specify a time zone.

The current time value is set at the start of the query statement that contains
this function. All invocations of `CURRENT_TIME()` within a query statement
yield the same value.

**Return Data Type**

`TIME`

**Example**

```zetasql
SELECT CURRENT_TIME() as now;

/*----------------------------*
 | now                        |
 +----------------------------+
 | 15:31:38.776361            |
 *----------------------------*/
```

[time-link-to-timezone-definitions]: #timezone_definitions

### `EXTRACT`

```zetasql
EXTRACT(part FROM time_expression)
```

**Description**

Returns a value that corresponds to the specified `part` from
a supplied `time_expression`.

Allowed `part` values are:

+ `NANOSECOND`
  (if the SQL engine supports it)
+ `MICROSECOND`
+ `MILLISECOND`
+ `SECOND`
+ `MINUTE`
+ `HOUR`

Returned values truncate lower order time periods. For example, when extracting
seconds, `EXTRACT` truncates the millisecond and microsecond values.

**Return Data Type**

`INT64`

**Example**

In the following example, `EXTRACT` returns a value corresponding to the `HOUR`
time part.

```zetasql
SELECT EXTRACT(HOUR FROM TIME "15:30:00") as hour;

/*------------------*
 | hour             |
 +------------------+
 | 15               |
 *------------------*/
```

### `FORMAT_TIME`

```zetasql
FORMAT_TIME(format_string, time_expr)
```

**Description**

Formats a `TIME` value according to the specified format string.

**Definitions**

+   `format_string`: A `STRING` value that contains the
    [format elements][time-format-elements] to use with `time_expr`.
+   `time_expr`: A `TIME` value that represents the time to format.

**Return Data Type**

`STRING`

**Example**

```zetasql
SELECT FORMAT_TIME("%R", TIME "15:30:00") as formatted_time;

/*----------------*
 | formatted_time |
 +----------------+
 | 15:30          |
 *----------------*/
```

[time-format-elements]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#format_elements_date_time

### `PARSE_TIME`

```zetasql
PARSE_TIME(format_string, time_string)
```

**Description**

Converts a `STRING` value to a `TIME` value.

**Definitions**

+   `format_string`: A `STRING` value that contains the
    [format elements][time-format-elements] to use with `time_string`.
+   `time_string`: A `STRING` value that represents the time to parse.

**Details**

Each element in `time_string` must have a corresponding element in
`format_string`. The location of each element in `format_string` must match the
location of each element in `time_string`.

```zetasql
-- This works because elements on both sides match.
SELECT PARSE_TIME("%I:%M:%S", "07:30:00");

-- This produces an error because the seconds element is in different locations.
SELECT PARSE_TIME("%S:%I:%M", "07:30:00");

-- This produces an error because one of the seconds elements is missing.
SELECT PARSE_TIME("%I:%M", "07:30:00");

-- This works because %T can find all matching elements in time_string.
SELECT PARSE_TIME("%T", "07:30:00");
```

The following additional considerations apply when using the `PARSE_TIME`
function:

+ Unspecified fields. Any unspecified field is initialized from
  `00:00:00.0`. For instance, if `seconds` is unspecified then it
  defaults to `00`, and so on.
+ Whitespace. One or more consecutive white spaces in the format string
  matches zero or more consecutive white spaces in the `TIME` string. In
  addition, leading and trailing white spaces in the `TIME` string are always
  allowed, even if they aren't in the format string.
+ Format precedence. When two (or more) format elements have overlapping
  information, the last one generally overrides any earlier ones.
+ Format divergence. `%p` can be used with `am`, `AM`, `pm`, and `PM`.

**Return Data Type**

`TIME`

**Example**

```zetasql
SELECT PARSE_TIME("%H", "15") as parsed_time;

/*-------------*
 | parsed_time |
 +-------------+
 | 15:00:00    |
 *-------------*/
```

```zetasql
SELECT PARSE_TIME('%I:%M:%S %p', '2:23:38 pm') AS parsed_time;

/*-------------*
 | parsed_time |
 +-------------+
 | 14:23:38    |
 *-------------*/
```

[time-format-elements]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#format_elements_date_time

### `TIME`

```zetasql
1. TIME(hour, minute, second)
2. TIME(timestamp, [time_zone])
3. TIME(datetime)
```

**Description**

1. Constructs a `TIME` object using `INT64`
   values representing the hour, minute, and second.
2. Constructs a `TIME` object using a `TIMESTAMP` object. It supports an
   optional
   parameter to [specify a time zone][time-link-to-timezone-definitions]. If no
   time zone is specified, the default time zone, which is implementation defined, is
   used.
3. Constructs a `TIME` object using a
   `DATETIME` object.

**Return Data Type**

`TIME`

**Example**

```zetasql
SELECT
  TIME(15, 30, 00) as time_hms,
  TIME(TIMESTAMP "2008-12-25 15:30:00+08", "America/Los_Angeles") as time_tstz;

/*----------+-----------*
 | time_hms | time_tstz |
 +----------+-----------+
 | 15:30:00 | 23:30:00  |
 *----------+-----------*/
```

```zetasql
SELECT TIME(DATETIME "2008-12-25 15:30:00.000000") AS time_dt;

/*----------*
 | time_dt  |
 +----------+
 | 15:30:00 |
 *----------*/
```

[time-link-to-timezone-definitions]: #timezone_definitions

### `TIME_ADD`

```zetasql
TIME_ADD(time_expression, INTERVAL int64_expression part)
```

**Description**

Adds `int64_expression` units of `part` to the `TIME` object.

`TIME_ADD` supports the following values for `part`:

+ `NANOSECOND`
  (if the SQL engine supports it)
+ `MICROSECOND`
+ `MILLISECOND`
+ `SECOND`
+ `MINUTE`
+ `HOUR`

This function automatically adjusts when values fall outside of the 00:00:00 to
24:00:00 boundary. For example, if you add an hour to `23:30:00`, the returned
value is `00:30:00`.

**Return Data Types**

`TIME`

**Example**

```zetasql
SELECT
  TIME "15:30:00" as original_time,
  TIME_ADD(TIME "15:30:00", INTERVAL 10 MINUTE) as later;

/*-----------------------------+------------------------*
 | original_time               | later                  |
 +-----------------------------+------------------------+
 | 15:30:00                    | 15:40:00               |
 *-----------------------------+------------------------*/
```

### `TIME_DIFF`

```zetasql
TIME_DIFF(end_time, start_time, granularity)
```

**Description**

Gets the number of unit boundaries between two `TIME` values (`end_time` -
`start_time`) at a particular time granularity.

**Definitions**

+   `start_time`: The starting `TIME` value.
+   `end_time`: The ending `TIME` value.
+   `granularity`: The time part that represents the granularity. If
    you passed in `TIME` values for the first arguments, `granularity` can
    be:

    
    + `NANOSECOND`
      (if the SQL engine supports it)
    + `MICROSECOND`
    + `MILLISECOND`
    + `SECOND`
    + `MINUTE`
    + `HOUR`

**Details**

If `end_time` is earlier than `start_time`, the output is negative.
Produces an error if the computation overflows, such as if the difference
in nanoseconds
between the two `TIME` values overflows.

Note: The behavior of the this function follows the type of arguments passed in.
For example, `TIME_DIFF(TIMESTAMP, TIMESTAMP, PART)`
behaves like `TIMESTAMP_DIFF(TIMESTAMP, TIMESTAMP, PART)`.

**Return Data Type**

`INT64`

**Example**

```zetasql
SELECT
  TIME "15:30:00" as first_time,
  TIME "14:35:00" as second_time,
  TIME_DIFF(TIME "15:30:00", TIME "14:35:00", MINUTE) as difference;

/*----------------------------+------------------------+------------------------*
 | first_time                 | second_time            | difference             |
 +----------------------------+------------------------+------------------------+
 | 15:30:00                   | 14:35:00               | 55                     |
 *----------------------------+------------------------+------------------------*/
```

### `TIME_SUB`

```zetasql
TIME_SUB(time_expression, INTERVAL int64_expression part)
```

**Description**

Subtracts `int64_expression` units of `part` from the `TIME` object.

`TIME_SUB` supports the following values for `part`:

+ `NANOSECOND`
  (if the SQL engine supports it)
+ `MICROSECOND`
+ `MILLISECOND`
+ `SECOND`
+ `MINUTE`
+ `HOUR`

This function automatically adjusts when values fall outside of the 00:00:00 to
24:00:00 boundary. For example, if you subtract an hour from `00:30:00`, the
returned value is `23:30:00`.

**Return Data Type**

`TIME`

**Example**

```zetasql
SELECT
  TIME "15:30:00" as original_date,
  TIME_SUB(TIME "15:30:00", INTERVAL 10 MINUTE) as earlier;

/*-----------------------------+------------------------*
 | original_date               | earlier                |
 +-----------------------------+------------------------+
 | 15:30:00                    | 15:20:00               |
 *-----------------------------+------------------------*/
```

### `TIME_TRUNC`

```zetasql
TIME_TRUNC(time_value, time_granularity)
```

**Description**

Truncates a `TIME` value at a particular granularity.

**Definitions**

+ `time_value`: The `TIME` value to truncate.
+ `time_granularity`: The truncation granularity for a `TIME` value.
  [Time granularities][time-trunc-granularity-time] can be used.

<a id="time_trunc_granularity_time"></a>

**Time granularity definitions**

  + `NANOSECOND`: If used, nothing is truncated from the value.

  + `MICROSECOND`: The nearest lesser than or equal microsecond.

  + `MILLISECOND`: The nearest lesser than or equal millisecond.

  + `SECOND`: The nearest lesser than or equal second.

  + `MINUTE`: The nearest lesser than or equal minute.

  + `HOUR`: The nearest lesser than or equal hour.

**Details**

The resulting value is always rounded to the beginning of `granularity`.

**Return Data Type**

`TIME`

**Example**

```zetasql
SELECT
  TIME "15:30:00" as original,
  TIME_TRUNC(TIME "15:30:00", HOUR) as truncated;

/*----------------------------+------------------------*
 | original                   | truncated              |
 +----------------------------+------------------------+
 | 15:30:00                   | 15:00:00               |
 *----------------------------+------------------------*/
```

[time-trunc-granularity-time]: #time_trunc_granularity_time

[time-to-string]: #cast

## Time series functions

ZetaSQL supports the following time series functions.

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#date_bucket"><code>DATE_BUCKET</code></a>
</td>
  <td>
    Gets the lower bound of the date bucket that contains a date.
  </td>
</tr>

<tr>
  <td><a href="#datetime_bucket"><code>DATETIME_BUCKET</code></a>
</td>
  <td>
    Gets the lower bound of the datetime bucket that contains a datetime.
  </td>
</tr>

<tr>
  <td><a href="#timestamp_bucket"><code>TIMESTAMP_BUCKET</code></a>
</td>
  <td>
    Gets the lower bound of the timestamp bucket that contains a timestamp.
  </td>
</tr>

  </tbody>
</table>

### `DATE_BUCKET`

```zetasql
DATE_BUCKET(date_in_bucket, bucket_width)
```

```zetasql
DATE_BUCKET(date_in_bucket, bucket_width, bucket_origin_date)
```

**Description**

Gets the lower bound of the date bucket that contains a date.

**Definitions**

+   `date_in_bucket`: A `DATE` value that you can use to look up a date bucket.
+   `bucket_width`: An `INTERVAL` value that represents the width of
    a date bucket. A [single interval][interval-single] with
    [date parts][interval-parts] is supported.
+   `bucket_origin_date`: A `DATE` value that represents a point in time. All
    buckets expand left and right from this point. If this argument isn't set,
    `1950-01-01` is used by default.

**Return type**

`DATE`

**Examples**

In the following example, the origin is omitted and the default origin,
`1950-01-01` is used. All buckets expand in both directions from the origin,
and the size of each bucket is two days. The lower bound of the bucket in
which `my_date` belongs is returned.

```zetasql
WITH some_dates AS (
  SELECT DATE '1949-12-29' AS my_date UNION ALL
  SELECT DATE '1949-12-30' UNION ALL
  SELECT DATE '1949-12-31' UNION ALL
  SELECT DATE '1950-01-01' UNION ALL
  SELECT DATE '1950-01-02' UNION ALL
  SELECT DATE '1950-01-03'
)
SELECT DATE_BUCKET(my_date, INTERVAL 2 DAY) AS bucket_lower_bound
FROM some_dates;

/*--------------------+
 | bucket_lower_bound |
 +--------------------+
 | 1949-12-28         |
 | 1949-12-30         |
 | 1949-12-30         |
 | 1950-01-01         |
 | 1950-01-01         |
 | 1950-01-03         |
 +--------------------*/

-- Some date buckets that originate from 1950-01-01:
-- + Bucket: ...
-- + Bucket: [1949-12-28, 1949-12-30)
-- + Bucket: [1949-12-30, 1950-01-01)
-- + Origin: [1950-01-01]
-- + Bucket: [1950-01-01, 1950-01-03)
-- + Bucket: [1950-01-03, 1950-01-05)
-- + Bucket: ...
```

In the following example, the origin has been changed to `2000-12-24`,
and all buckets expand in both directions from this point. The size of each
bucket is seven days. The lower bound of the bucket in which `my_date` belongs
is returned:

```zetasql
WITH some_dates AS (
  SELECT DATE '2000-12-20' AS my_date UNION ALL
  SELECT DATE '2000-12-21' UNION ALL
  SELECT DATE '2000-12-22' UNION ALL
  SELECT DATE '2000-12-23' UNION ALL
  SELECT DATE '2000-12-24' UNION ALL
  SELECT DATE '2000-12-25'
)
SELECT DATE_BUCKET(
  my_date,
  INTERVAL 7 DAY,
  DATE '2000-12-24') AS bucket_lower_bound
FROM some_dates;

/*--------------------+
 | bucket_lower_bound |
 +--------------------+
 | 2000-12-17         |
 | 2000-12-17         |
 | 2000-12-17         |
 | 2000-12-17         |
 | 2000-12-24         |
 | 2000-12-24         |
 +--------------------*/

-- Some date buckets that originate from 2000-12-24:
-- + Bucket: ...
-- + Bucket: [2000-12-10, 2000-12-17)
-- + Bucket: [2000-12-17, 2000-12-24)
-- + Origin: [2000-12-24]
-- + Bucket: [2000-12-24, 2000-12-31)
-- + Bucket: [2000-12-31, 2000-01-07)
-- + Bucket: ...
```

[interval-single]: https://github.com/google/zetasql/blob/master/docs/data-types.md#single_datetime_part_interval

[interval-range]: https://github.com/google/zetasql/blob/master/docs/data-types.md#range_datetime_part_interval

[interval-parts]: https://github.com/google/zetasql/blob/master/docs/data-types.md#interval_datetime_parts

### `DATETIME_BUCKET`

```zetasql
DATETIME_BUCKET(datetime_in_bucket, bucket_width)
```

```zetasql
DATETIME_BUCKET(datetime_in_bucket, bucket_width, bucket_origin_datetime)
```

**Description**

Gets the lower bound of the datetime bucket that contains a datetime.

**Definitions**

+   `datetime_in_bucket`: A `DATETIME` value that you can use to look up a
    datetime bucket.
+   `bucket_width`: An `INTERVAL` value that represents the width of
    a datetime bucket. A [single interval][interval-single] with
    [date and time parts][interval-parts] is supported.
+   `bucket_origin_datetime`: A `DATETIME` value that represents a point in
    time. All buckets expand left and right from this point. If this argument
    isn't set, `1950-01-01 00:00:00` is used by default.

**Return type**

`DATETIME`

**Examples**

In the following example, the origin is omitted and the default origin,
`1950-01-01 00:00:00` is used. All buckets expand in both directions from the
origin, and the size of each bucket is 12 hours. The lower bound of the bucket
in which `my_datetime` belongs is returned:

```zetasql
WITH some_datetimes AS (
  SELECT DATETIME '1949-12-30 13:00:00' AS my_datetime UNION ALL
  SELECT DATETIME '1949-12-31 00:00:00' UNION ALL
  SELECT DATETIME '1949-12-31 13:00:00' UNION ALL
  SELECT DATETIME '1950-01-01 00:00:00' UNION ALL
  SELECT DATETIME '1950-01-01 13:00:00' UNION ALL
  SELECT DATETIME '1950-01-02 00:00:00'
)
SELECT DATETIME_BUCKET(my_datetime, INTERVAL 12 HOUR) AS bucket_lower_bound
FROM some_datetimes;

/*---------------------+
 | bucket_lower_bound  |
 +---------------------+
 | 1949-12-30 12:00:00 |
 | 1949-12-31 00:00:00 |
 | 1949-12-31 12:00:00 |
 | 1950-01-01 00:00:00 |
 | 1950-01-01 12:00:00 |
 | 1950-01-02 00:00:00 |
 +---------------------*/

-- Some datetime buckets that originate from 1950-01-01 00:00:00:
-- + Bucket: ...
-- + Bucket: [1949-12-30 00:00:00, 1949-12-30 12:00:00)
-- + Bucket: [1949-12-30 12:00:00, 1950-01-01 00:00:00)
-- + Origin: [1950-01-01 00:00:00]
-- + Bucket: [1950-01-01 00:00:00, 1950-01-01 12:00:00)
-- + Bucket: [1950-01-01 12:00:00, 1950-02-00 00:00:00)
-- + Bucket: ...
```

In the following example, the origin has been changed to `2000-12-24 12:00:00`,
and all buckets expand in both directions from this point. The size of each
bucket is seven days. The lower bound of the bucket in which `my_datetime`
belongs is returned:

```zetasql
WITH some_datetimes AS (
  SELECT DATETIME '2000-12-20 00:00:00' AS my_datetime UNION ALL
  SELECT DATETIME '2000-12-21 00:00:00' UNION ALL
  SELECT DATETIME '2000-12-22 00:00:00' UNION ALL
  SELECT DATETIME '2000-12-23 00:00:00' UNION ALL
  SELECT DATETIME '2000-12-24 00:00:00' UNION ALL
  SELECT DATETIME '2000-12-25 00:00:00'
)
SELECT DATETIME_BUCKET(
  my_datetime,
  INTERVAL 7 DAY,
  DATETIME '2000-12-22 12:00:00') AS bucket_lower_bound
FROM some_datetimes;

/*--------------------+
 | bucket_lower_bound |
 +--------------------+
 | 2000-12-15 12:00:00 |
 | 2000-12-15 12:00:00 |
 | 2000-12-15 12:00:00 |
 | 2000-12-22 12:00:00 |
 | 2000-12-22 12:00:00 |
 | 2000-12-22 12:00:00 |
 +--------------------*/

-- Some datetime buckets that originate from 2000-12-22 12:00:00:
-- + Bucket: ...
-- + Bucket: [2000-12-08 12:00:00, 2000-12-15 12:00:00)
-- + Bucket: [2000-12-15 12:00:00, 2000-12-22 12:00:00)
-- + Origin: [2000-12-22 12:00:00]
-- + Bucket: [2000-12-22 12:00:00, 2000-12-29 12:00:00)
-- + Bucket: [2000-12-29 12:00:00, 2000-01-05 12:00:00)
-- + Bucket: ...
```

[interval-single]: https://github.com/google/zetasql/blob/master/docs/data-types.md#single_datetime_part_interval

[interval-parts]: https://github.com/google/zetasql/blob/master/docs/data-types.md#interval_datetime_parts

### `TIMESTAMP_BUCKET`

```zetasql
TIMESTAMP_BUCKET(timestamp_in_bucket, bucket_width)
```

```zetasql
TIMESTAMP_BUCKET(timestamp_in_bucket, bucket_width, bucket_origin_timestamp)
```

**Description**

Gets the lower bound of the timestamp bucket that contains a timestamp.

**Definitions**

+   `timestamp_in_bucket`: A `TIMESTAMP` value that you can use to look up a
    timestamp bucket.
+   `bucket_width`: An `INTERVAL` value that represents the width of
    a timestamp bucket. A [single interval][interval-single] with
    [date and time parts][interval-parts] is supported.
+   `bucket_origin_timestamp`: A `TIMESTAMP` value that represents a point in
    time. All buckets expand left and right from this point. If this argument
    isn't set, `1950-01-01 00:00:00` is used by default.

**Return type**

`TIMESTAMP`

**Examples**

In the following example, the origin is omitted and the default origin,
`1950-01-01 00:00:00` is used. All buckets expand in both directions from the
origin, and the size of each bucket is 12 hours. The default time zone,
which is implementation defined, is included in the results. The lower bound of the
bucket in which `my_timestamp` belongs is returned:

```zetasql
WITH some_timestamps AS (
  SELECT TIMESTAMP '1949-12-30 13:00:00.00' AS my_timestamp UNION ALL
  SELECT TIMESTAMP '1949-12-31 00:00:00.00' UNION ALL
  SELECT TIMESTAMP '1949-12-31 13:00:00.00' UNION ALL
  SELECT TIMESTAMP '1950-01-01 00:00:00.00' UNION ALL
  SELECT TIMESTAMP '1950-01-01 13:00:00.00' UNION ALL
  SELECT TIMESTAMP '1950-01-02 00:00:00.00'
)
SELECT TIMESTAMP_BUCKET(my_timestamp, INTERVAL 12 HOUR) AS bucket_lower_bound
FROM some_timestamps;

-- Display of results may differ, depending upon the environment and
-- time zone where this query was executed.
/*---------------------------------------------+
 | bucket_lower_bound                          |
 +---------------------------------------------+
 | 1949-12-30 12:00:00.000 America/Los_Angeles |
 | 1949-12-31 00:00:00.000 America/Los_Angeles |
 | 1949-12-31 12:00:00.000 America/Los_Angeles |
 | 1950-01-01 00:00:00.000 America/Los_Angeles |
 | 1950-01-01 12:00:00.000 America/Los_Angeles |
 | 1950-01-02 00:00:00.000 America/Los_Angeles |
 +---------------------------------------------*/

-- Some timestamp buckets that originate from 1950-01-01 00:00:00:
-- + Bucket: ...
-- + Bucket: [1949-12-30 00:00:00.00 UTC, 1949-12-30 12:00:00.00 UTC)
-- + Bucket: [1949-12-30 12:00:00.00 UTC, 1950-01-01 00:00:00.00 UTC)
-- + Origin: [1950-01-01 00:00:00.00 UTC]
-- + Bucket: [1950-01-01 00:00:00.00 UTC, 1950-01-01 12:00:00.00 UTC)
-- + Bucket: [1950-01-01 12:00:00.00 UTC, 1950-02-00 00:00:00.00 UTC)
-- + Bucket: ...
```

In the following example, the origin has been changed to `2000-12-24 12:00:00`,
and all buckets expand in both directions from this point. The size of each
bucket is seven days. The default time zone, which is implementation defined, is included
in the results. The lower bound of the bucket in which `my_timestamp`
belongs is returned:

```zetasql
WITH some_timestamps AS (
  SELECT TIMESTAMP '2000-12-20 00:00:00.00' AS my_timestamp UNION ALL
  SELECT TIMESTAMP '2000-12-21 00:00:00.00' UNION ALL
  SELECT TIMESTAMP '2000-12-22 00:00:00.00' UNION ALL
  SELECT TIMESTAMP '2000-12-23 00:00:00.00' UNION ALL
  SELECT TIMESTAMP '2000-12-24 00:00:00.00' UNION ALL
  SELECT TIMESTAMP '2000-12-25 00:00:00.00'
)
SELECT TIMESTAMP_BUCKET(
  my_timestamp,
  INTERVAL 7 DAY,
  TIMESTAMP '2000-12-22 12:00:00.00') AS bucket_lower_bound
FROM some_timestamps;

-- Display of results may differ, depending upon the environment and
-- time zone where this query was executed.
/*---------------------------------------------+
 | bucket_lower_bound                          |
 +---------------------------------------------+
 | 2000-12-15 12:00:00.000 America/Los_Angeles |
 | 2000-12-15 12:00:00.000 America/Los_Angeles |
 | 2000-12-15 12:00:00.000 America/Los_Angeles |
 | 2000-12-22 12:00:00.000 America/Los_Angeles |
 | 2000-12-22 12:00:00.000 America/Los_Angeles |
 | 2000-12-22 12:00:00.000 America/Los_Angeles |
 +---------------------------------------------*/

-- Some timestamp buckets that originate from 2000-12-22 12:00:00:
-- + Bucket: ...
-- + Bucket: [2000-12-08 12:00:00.00 UTC, 2000-12-15 12:00:00.00 UTC)
-- + Bucket: [2000-12-15 12:00:00.00 UTC, 2000-12-22 12:00:00.00 UTC)
-- + Origin: [2000-12-22 12:00:00.00 UTC]
-- + Bucket: [2000-12-22 12:00:00.00 UTC, 2000-12-29 12:00:00.00 UTC)
-- + Bucket: [2000-12-29 12:00:00.00 UTC, 2000-01-05 12:00:00.00 UTC)
-- + Bucket: ...
```

[interval-single]: https://github.com/google/zetasql/blob/master/docs/data-types.md#single_datetime_part_interval

[interval-parts]: https://github.com/google/zetasql/blob/master/docs/data-types.md#interval_datetime_parts

## Timestamp functions

ZetaSQL supports the following timestamp functions.

IMPORTANT: Before working with these functions, you need to understand
the difference between the formats in which timestamps are stored and displayed,
and how time zones are used for the conversion between these formats.
To learn more, see
[How time zones work with timestamp functions][timestamp-link-to-timezone-definitions].

NOTE: These functions return a runtime error if overflow occurs; result
values are bounded by the defined [`DATE` range][data-types-link-to-date_type]
and [`TIMESTAMP` range][data-types-link-to-timestamp_type].

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#current_timestamp"><code>CURRENT_TIMESTAMP</code></a>
</td>
  <td>
    Returns the current date and time as a <code>TIMESTAMP</code> object.
  </td>
</tr>

<tr>
  <td><a href="#extract"><code>EXTRACT</code></a>
</td>
  <td>
    Extracts part of a <code>TIMESTAMP</code> value.
  </td>
</tr>

<tr>
  <td><a href="#format_timestamp"><code>FORMAT_TIMESTAMP</code></a>
</td>
  <td>
    Formats a <code>TIMESTAMP</code> value according to the specified
    format string.
  </td>
</tr>

<tr>
  <td><a href="#generate_timestamp_array"><code>GENERATE_TIMESTAMP_ARRAY</code></a>
</td>
  <td>
    Generates an array of timestamps in a range.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/array_functions.md">Array functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#parse_timestamp"><code>PARSE_TIMESTAMP</code></a>
</td>
  <td>
    Converts a <code>STRING</code> value to a <code>TIMESTAMP</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#string"><code>STRING</code> (Timestamp)</a>
</td>
  <td>
    Converts a <code>TIMESTAMP</code> value to a <code>STRING</code> value.
    
  </td>
</tr>

<tr>
  <td><a href="#timestamp"><code>TIMESTAMP</code></a>
</td>
  <td>
    Constructs a <code>TIMESTAMP</code> value.
  </td>
</tr>

<tr>
  <td><a href="#timestamp_add"><code>TIMESTAMP_ADD</code></a>
</td>
  <td>
    Adds a specified time interval to a <code>TIMESTAMP</code> value.
  </td>
</tr>

<tr>
  <td><a href="#timestamp_diff"><code>TIMESTAMP_DIFF</code></a>
</td>
  <td>
    Gets the number of unit boundaries between two <code>TIMESTAMP</code> values
    at a particular time granularity.
  </td>
</tr>

<tr>
  <td><a href="#timestamp_from_unix_micros"><code>TIMESTAMP_FROM_UNIX_MICROS</code></a>
</td>
  <td>
    Similar to <code>TIMESTAMP_MICROS</code>, except that additionally, a
    <code>TIMESTAMP</code> value can be passed in.
  </td>
</tr>

<tr>
  <td><a href="#timestamp_from_unix_millis"><code>TIMESTAMP_FROM_UNIX_MILLIS</code></a>
</td>
  <td>
    Similar to <code>TIMESTAMP_MILLIS</code>, except that additionally, a
    <code>TIMESTAMP</code> value can be passed in.
  </td>
</tr>

<tr>
  <td><a href="#timestamp_from_unix_seconds"><code>TIMESTAMP_FROM_UNIX_SECONDS</code></a>
</td>
  <td>
    Similar to <code>TIMESTAMP_SECONDS</code>, except that additionally, a
    <code>TIMESTAMP</code> value can be passed in.
  </td>
</tr>

<tr>
  <td><a href="#timestamp_micros"><code>TIMESTAMP_MICROS</code></a>
</td>
  <td>
    Converts the number of microseconds since
    1970-01-01 00:00:00 UTC to a <code>TIMESTAMP</code>.
    
  </td>
</tr>

<tr>
  <td><a href="#timestamp_millis"><code>TIMESTAMP_MILLIS</code></a>
</td>
  <td>
    Converts the number of milliseconds since
    1970-01-01 00:00:00 UTC to a <code>TIMESTAMP</code>.
    
  </td>
</tr>

<tr>
  <td><a href="#timestamp_seconds"><code>TIMESTAMP_SECONDS</code></a>
</td>
  <td>
    Converts the number of seconds since
    1970-01-01 00:00:00 UTC to a <code>TIMESTAMP</code>.
    
  </td>
</tr>

<tr>
  <td><a href="#timestamp_sub"><code>TIMESTAMP_SUB</code></a>
</td>
  <td>
    Subtracts a specified time interval from a <code>TIMESTAMP</code> value.
  </td>
</tr>

<tr>
  <td><a href="#timestamp_trunc"><code>TIMESTAMP_TRUNC</code></a>
</td>
  <td>
    
    Truncates a <code>TIMESTAMP</code> or
    <code>DATETIME</code> value at a particular
    granularity.
    
  </td>
</tr>

<tr>
  <td><a href="#unix_micros"><code>UNIX_MICROS</code></a>
</td>
  <td>
    Converts a <code>TIMESTAMP</code> value to the number of microseconds since
    1970-01-01 00:00:00 UTC.
    
  </td>
</tr>

<tr>
  <td><a href="#unix_millis"><code>UNIX_MILLIS</code></a>
</td>
  <td>
    Converts a <code>TIMESTAMP</code> value to the number of milliseconds
    since 1970-01-01 00:00:00 UTC.
    
  </td>
</tr>

<tr>
  <td><a href="#unix_seconds"><code>UNIX_SECONDS</code></a>
</td>
  <td>
    Converts a <code>TIMESTAMP</code> value to the number of seconds since
    1970-01-01 00:00:00 UTC.
    
  </td>
</tr>

  </tbody>
</table>

### `CURRENT_TIMESTAMP`

```zetasql
CURRENT_TIMESTAMP()
```

```zetasql
CURRENT_TIMESTAMP
```

**Description**

Returns the current date and time as a timestamp object. The timestamp is
continuous, non-ambiguous, has exactly 60 seconds per minute and doesn't repeat
values over the leap second. Parentheses are optional.

This function handles leap seconds by smearing them across a window of 20 hours
around the inserted leap second.

The current timestamp value is set at the start of the query statement that
contains this function. All invocations of `CURRENT_TIMESTAMP()` within a query
statement yield the same value.

**Supported Input Types**

Not applicable

**Result Data Type**

`TIMESTAMP`

**Examples**

```zetasql
SELECT CURRENT_TIMESTAMP() AS now;

/*---------------------------------------------*
 | now                                         |
 +---------------------------------------------+
 | 2020-06-02 17:00:53.110 America/Los_Angeles |
 *---------------------------------------------*/
```

### `EXTRACT`

```zetasql
EXTRACT(part FROM timestamp_expression [AT TIME ZONE time_zone])
```

**Description**

Returns a value that corresponds to the specified `part` from
a supplied `timestamp_expression`. This function supports an optional
`time_zone` parameter. See
[Time zone definitions][timestamp-link-to-timezone-definitions] for information
on how to specify a time zone.

Allowed `part` values are:

+ `NANOSECOND`
  (if the SQL engine supports it)
+ `MICROSECOND`
+ `MILLISECOND`
+ `SECOND`
+ `MINUTE`
+ `HOUR`
+ `DAYOFWEEK`: Returns values in the range [1,7] with Sunday as the first day of
   of the week.
+ `DAY`
+ `DAYOFYEAR`
+ `WEEK`: Returns the week number of the date in the range [0, 53]. Weeks begin
  with Sunday, and dates prior to the first Sunday of the year are in week
  0.
+ `WEEK(<WEEKDAY>)`: Returns the week number of `timestamp_expression` in the
  range [0, 53]. Weeks begin on `WEEKDAY`. `datetime`s prior to the first
  `WEEKDAY` of the year are in week 0. Valid values for `WEEKDAY` are `SUNDAY`,
  `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, and `SATURDAY`.
+ `ISOWEEK`: Returns the [ISO 8601 week][ISO-8601-week]
  number of the `datetime_expression`. `ISOWEEK`s begin on Monday. Return values
  are in the range [1, 53]. The first `ISOWEEK` of each ISO year begins on the
  Monday before the first Thursday of the Gregorian calendar year.
+ `MONTH`
+ `QUARTER`
+ `YEAR`
+ `ISOYEAR`: Returns the [ISO 8601][ISO-8601]
  week-numbering year, which is the Gregorian calendar year containing the
  Thursday of the week to which `date_expression` belongs.
+ `DATE`
+ `DATETIME`
+ `TIME`

Returned values truncate lower order time periods. For example, when extracting
seconds, `EXTRACT` truncates the millisecond and microsecond values.

**Return Data Type**

`INT64`, except in the following cases:

+ If `part` is `DATE`, the function returns a `DATE` object.

**Examples**

In the following example, `EXTRACT` returns a value corresponding to the `DAY`
time part.

```zetasql
SELECT
  EXTRACT(
    DAY
    FROM TIMESTAMP('2008-12-25 05:30:00+00') AT TIME ZONE 'UTC')
    AS the_day_utc,
  EXTRACT(
    DAY
    FROM TIMESTAMP('2008-12-25 05:30:00+00') AT TIME ZONE 'America/Los_Angeles')
    AS the_day_california

/*-------------+--------------------*
 | the_day_utc | the_day_california |
 +-------------+--------------------+
 | 25          | 24                 |
 *-------------+--------------------*/
```

In the following examples, `EXTRACT` returns values corresponding to different
time parts from a column of type `TIMESTAMP`.

```zetasql
SELECT
  EXTRACT(ISOYEAR FROM TIMESTAMP("2005-01-03 12:34:56+00")) AS isoyear,
  EXTRACT(ISOWEEK FROM TIMESTAMP("2005-01-03 12:34:56+00")) AS isoweek,
  EXTRACT(YEAR FROM TIMESTAMP("2005-01-03 12:34:56+00")) AS year,
  EXTRACT(WEEK FROM TIMESTAMP("2005-01-03 12:34:56+00")) AS week

-- Display of results may differ, depending upon the environment and
-- time zone where this query was executed.
/*---------+---------+------+------*
 | isoyear | isoweek | year | week |
 +---------+---------+------+------+
 | 2005    | 1       | 2005 | 1    |
 *---------+---------+------+------*/
```

```zetasql
SELECT
  TIMESTAMP("2007-12-31 12:00:00+00") AS timestamp_value,
  EXTRACT(ISOYEAR FROM TIMESTAMP("2007-12-31 12:00:00+00")) AS isoyear,
  EXTRACT(ISOWEEK FROM TIMESTAMP("2007-12-31 12:00:00+00")) AS isoweek,
  EXTRACT(YEAR FROM TIMESTAMP("2007-12-31 12:00:00+00")) AS year,
  EXTRACT(WEEK FROM TIMESTAMP("2007-12-31 12:00:00+00")) AS week

-- Display of results may differ, depending upon the environment and time zone
-- where this query was executed.
/*---------+---------+------+------*
 | isoyear | isoweek | year | week |
 +---------+---------+------+------+
 | 2008    | 1       | 2007 | 52    |
 *---------+---------+------+------*/
```

```zetasql
SELECT
  TIMESTAMP("2009-01-01 12:00:00+00") AS timestamp_value,
  EXTRACT(ISOYEAR FROM TIMESTAMP("2009-01-01 12:00:00+00")) AS isoyear,
  EXTRACT(ISOWEEK FROM TIMESTAMP("2009-01-01 12:00:00+00")) AS isoweek,
  EXTRACT(YEAR FROM TIMESTAMP("2009-01-01 12:00:00+00")) AS year,
  EXTRACT(WEEK FROM TIMESTAMP("2009-01-01 12:00:00+00")) AS week

-- Display of results may differ, depending upon the environment and time zone
-- where this query was executed.
/*---------+---------+------+------*
 | isoyear | isoweek | year | week |
 +---------+---------+------+------+
 | 2009    | 1       | 2009 | 0    |
 *---------+---------+------+------*/
```

```zetasql
SELECT
  TIMESTAMP("2009-12-31 12:00:00+00") AS timestamp_value,
  EXTRACT(ISOYEAR FROM TIMESTAMP("2009-12-31 12:00:00+00")) AS isoyear,
  EXTRACT(ISOWEEK FROM TIMESTAMP("2009-12-31 12:00:00+00")) AS isoweek,
  EXTRACT(YEAR FROM TIMESTAMP("2009-12-31 12:00:00+00")) AS year,
  EXTRACT(WEEK FROM TIMESTAMP("2009-12-31 12:00:00+00")) AS week

-- Display of results may differ, depending upon the environment and time zone
-- where this query was executed.
/*---------+---------+------+------*
 | isoyear | isoweek | year | week |
 +---------+---------+------+------+
 | 2009    | 53      | 2009 | 52   |
 *---------+---------+------+------*/
```

```zetasql
SELECT
  TIMESTAMP("2017-01-02 12:00:00+00") AS timestamp_value,
  EXTRACT(ISOYEAR FROM TIMESTAMP("2017-01-02 12:00:00+00")) AS isoyear,
  EXTRACT(ISOWEEK FROM TIMESTAMP("2017-01-02 12:00:00+00")) AS isoweek,
  EXTRACT(YEAR FROM TIMESTAMP("2017-01-02 12:00:00+00")) AS year,
  EXTRACT(WEEK FROM TIMESTAMP("2017-01-02 12:00:00+00")) AS week

-- Display of results may differ, depending upon the environment and time zone
-- where this query was executed.
/*---------+---------+------+------*
 | isoyear | isoweek | year | week |
 +---------+---------+------+------+
 | 2017    | 1       | 2017 | 1    |
 *---------+---------+------+------*/
```

```zetasql
SELECT
  TIMESTAMP("2017-05-26 12:00:00+00") AS timestamp_value,
  EXTRACT(ISOYEAR FROM TIMESTAMP("2017-05-26 12:00:00+00")) AS isoyear,
  EXTRACT(ISOWEEK FROM TIMESTAMP("2017-05-26 12:00:00+00")) AS isoweek,
  EXTRACT(YEAR FROM TIMESTAMP("2017-05-26 12:00:00+00")) AS year,
  EXTRACT(WEEK FROM TIMESTAMP("2017-05-26 12:00:00+00")) AS week

-- Display of results may differ, depending upon the environment and time zone
-- where this query was executed.
/*---------+---------+------+------*
 | isoyear | isoweek | year | week |
 +---------+---------+------+------+
 | 2017    | 21      | 2017 | 21   |
 *---------+---------+------+------*/
```

In the following example, `timestamp_expression` falls on a Monday. `EXTRACT`
calculates the first column using weeks that begin on Sunday, and it calculates
the second column using weeks that begin on Monday.

```zetasql
SELECT
  EXTRACT(WEEK(SUNDAY) FROM TIMESTAMP("2017-11-06 00:00:00+00")) AS week_sunday,
  EXTRACT(WEEK(MONDAY) FROM TIMESTAMP("2017-11-06 00:00:00+00")) AS week_monday

-- Display of results may differ, depending upon the environment and time zone
-- where this query was executed.
/*-------------+---------------*
 | week_sunday | week_monday   |
 +-------------+---------------+
 | 45          | 44            |
 *-------------+---------------*/
```

[ISO-8601]: https://en.wikipedia.org/wiki/ISO_8601

[ISO-8601-week]: https://en.wikipedia.org/wiki/ISO_week_date

[timestamp-link-to-timezone-definitions]: #timezone_definitions

### `FORMAT_TIMESTAMP`

```zetasql
FORMAT_TIMESTAMP(format_string, timestamp_expr[, time_zone])
```

**Description**

Formats a `TIMESTAMP` value according to the specified format string.

**Definitions**

+   `format_string`: A `STRING` value that contains the
    [format elements][timestamp-format-elements] to use with
    `timestamp_expr`.
+   `timestamp_expr`: A `TIMESTAMP` value that represents the timestamp to format.
+   `time_zone`: A `STRING` value that represents a time zone. For more
    information about how to use a time zone with a timestamp, see
    [Time zone definitions][timestamp-link-to-timezone-definitions].

**Return Data Type**

`STRING`

**Examples**

```zetasql
SELECT FORMAT_TIMESTAMP("%c", TIMESTAMP "2050-12-25 15:30:55+00", "UTC")
  AS formatted;

/*--------------------------*
 | formatted                |
 +--------------------------+
 | Sun Dec 25 15:30:55 2050 |
 *--------------------------*/
```

```zetasql
SELECT FORMAT_TIMESTAMP("%b-%d-%Y", TIMESTAMP "2050-12-25 15:30:55+00")
  AS formatted;

/*-------------*
 | formatted   |
 +-------------+
 | Dec-25-2050 |
 *-------------*/
```

```zetasql
SELECT FORMAT_TIMESTAMP("%b %Y", TIMESTAMP "2050-12-25 15:30:55+00")
  AS formatted;

/*-------------*
 | formatted   |
 +-------------+
 | Dec 2050    |
 *-------------*/
```

```zetasql
SELECT FORMAT_TIMESTAMP("%Y-%m-%dT%H:%M:%SZ", TIMESTAMP "2050-12-25 15:30:55", "UTC")
  AS formatted;

/*+---------------------*
 |      formatted       |
 +----------------------+
 | 2050-12-25T15:30:55Z |
 *----------------------*/
```

[timestamp-format-elements]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#format_elements_date_time

[timestamp-link-to-timezone-definitions]: #timezone_definitions

### `PARSE_TIMESTAMP`

```zetasql
PARSE_TIMESTAMP(format_string, timestamp_string[, time_zone])
```

**Description**

Converts a `STRING` value to a `TIMESTAMP` value.

**Definitions**

+   `format_string`: A `STRING` value that contains the
    [format elements][timestamp-format-elements] to use with `timestamp_string`.
+   `timestamp_string`: A `STRING` value that represents the timestamp to parse.
+   `time_zone`: A `STRING` value that represents a time zone. For more
    information about how to use a time zone with a timestamp, see
    [Time zone definitions][timestamp-link-to-timezone-definitions].

**Details**

Each element in `timestamp_string` must have a corresponding element in
`format_string`. The location of each element in `format_string` must match the
location of each element in `timestamp_string`.

```zetasql
-- This works because elements on both sides match.
SELECT PARSE_TIMESTAMP("%a %b %e %I:%M:%S %Y", "Thu Dec 25 07:30:00 2008");

-- This produces an error because the year element is in different locations.
SELECT PARSE_TIMESTAMP("%a %b %e %Y %I:%M:%S", "Thu Dec 25 07:30:00 2008");

-- This produces an error because one of the year elements is missing.
SELECT PARSE_TIMESTAMP("%a %b %e %I:%M:%S", "Thu Dec 25 07:30:00 2008");

-- This works because %c can find all matching elements in timestamp_string.
SELECT PARSE_TIMESTAMP("%c", "Thu Dec 25 07:30:00 2008");
```

The following additional considerations apply when using the `PARSE_TIMESTAMP`
function:

+ Unspecified fields. Any unspecified field is initialized from `1970-01-01
  00:00:00.0`. This initialization value uses the time zone specified by the
  function's time zone argument, if present. If not, the initialization value
  uses the default time zone, which is implementation defined. For instance, if the year
  is unspecified then it defaults to `1970`, and so on.
+ Case insensitivity. Names, such as `Monday`, `February`, and so on, are
  case insensitive.
+ Whitespace. One or more consecutive white spaces in the format string
  matches zero or more consecutive white spaces in the timestamp string. In
  addition, leading and trailing white spaces in the timestamp string are always
  allowed, even if they aren't in the format string.
+ Format precedence. When two (or more) format elements have overlapping
  information (for example both `%F` and `%Y` affect the year), the last one
  generally overrides any earlier ones, with some exceptions (see the
  descriptions of `%s`, `%C`, and `%y`).
+ Format divergence. `%p` can be used with `am`, `AM`, `pm`, and `PM`.
+   Mixed ISO and non-ISO elements. The ISO format elements are `%G`, `%g`,
    `%J`, and `%V`. When these ISO elements are used together with other non-ISO
    elements, the ISO elements are ignored, resulting in different values. For
    example, the function arguments `('%g %J', '8405')` return a value with the
    year `1984`, whereas the arguments `('%g %j', '8405')` return a value with
    the year `1970` because the ISO element `%g` is ignored.
+   Numeric values after `%G` input values. Any input string value that
    corresponds to the `%G` format element requires a whitespace or non-digit
    character as a separator from numeric values that follow. This is a known
    issue in ZetaSQL. For example, the function arguments `('%G
    %V','2020 50')` or `('%G-%V','2020-50')` work, but not `('%G%V','202050')`.
    For input values before the corresponding `%G` value, no separator is
    needed. For example, the arguments `('%V%G','502020')` work. The separator
    after the `%G` values identifies the end of the specified ISO year value so
    that the function can parse properly.

**Return Data Type**

`TIMESTAMP`

**Example**

```zetasql
SELECT PARSE_TIMESTAMP("%c", "Thu Dec 25 07:30:00 2008") AS parsed;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*---------------------------------------------*
 | parsed                                      |
 +---------------------------------------------+
 | 2008-12-25 07:30:00.000 America/Los_Angeles |
 *---------------------------------------------*/
```

[timestamp-format-elements]: https://github.com/google/zetasql/blob/master/docs/format-elements.md#format_elements_date_time

[timestamp-link-to-timezone-definitions]: #timezone_definitions

### `STRING`

```zetasql
STRING(timestamp_expression[, time_zone])
```

**Description**

Converts a timestamp to a string. Supports an optional
parameter to specify a time zone. See
[Time zone definitions][timestamp-link-to-timezone-definitions] for information
on how to specify a time zone.

**Return Data Type**

`STRING`

**Example**

```zetasql
SELECT STRING(TIMESTAMP "2008-12-25 15:30:00+00", "UTC") AS string;

/*-------------------------------*
 | string                        |
 +-------------------------------+
 | 2008-12-25 15:30:00+00        |
 *-------------------------------*/
```

[timestamp-link-to-timezone-definitions]: #timezone_definitions

### `TIMESTAMP`

```zetasql
TIMESTAMP(string_expression[, time_zone])
TIMESTAMP(date_expression[, time_zone])
TIMESTAMP(datetime_expression[, time_zone])
```

**Description**

+  `string_expression[, time_zone]`: Converts a string to a
   timestamp. `string_expression` must include a
   timestamp literal.
   If `string_expression` includes a time zone in the timestamp literal,
   don't include an explicit `time_zone`
   argument.
+  `date_expression[, time_zone]`: Converts a date to a timestamp.
   The value returned is the earliest timestamp that falls within
   the given date.
+  `datetime_expression[, time_zone]`: Converts a
   datetime to a timestamp.

This function supports an optional
parameter to [specify a time zone][timestamp-link-to-timezone-definitions]. If
no time zone is specified, the default time zone, which is implementation defined,
is used.

**Return Data Type**

`TIMESTAMP`

**Examples**

```zetasql
SELECT TIMESTAMP("2008-12-25 15:30:00+00") AS timestamp_str;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*---------------------------------------------*
 | timestamp_str                               |
 +---------------------------------------------+
 | 2008-12-25 07:30:00.000 America/Los_Angeles |
 *---------------------------------------------*/
```

```zetasql
SELECT TIMESTAMP("2008-12-25 15:30:00", "America/Los_Angeles") AS timestamp_str;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*---------------------------------------------*
 | timestamp_str                               |
 +---------------------------------------------+
 | 2008-12-25 15:30:00.000 America/Los_Angeles |
 *---------------------------------------------*/
```

```zetasql
SELECT TIMESTAMP("2008-12-25 15:30:00 UTC") AS timestamp_str;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*---------------------------------------------*
 | timestamp_str                               |
 +---------------------------------------------+
 | 2008-12-25 07:30:00.000 America/Los_Angeles |
 *---------------------------------------------*/
```

```zetasql
SELECT TIMESTAMP(DATETIME "2008-12-25 15:30:00") AS timestamp_datetime;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*---------------------------------------------*
 | timestamp_datetime                          |
 +---------------------------------------------+
 | 2008-12-25 15:30:00.000 America/Los_Angeles |
 *---------------------------------------------*/
```

```zetasql
SELECT TIMESTAMP(DATE "2008-12-25") AS timestamp_date;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*---------------------------------------------*
 | timestamp_date                              |
 +---------------------------------------------+
 | 2008-12-25 00:00:00.000 America/Los_Angeles |
 *---------------------------------------------*/
```

[timestamp-link-to-timezone-definitions]: #timezone_definitions

### `TIMESTAMP_ADD`

```zetasql
TIMESTAMP_ADD(timestamp_expression, INTERVAL int64_expression date_part)
```

**Description**

Adds `int64_expression` units of `date_part` to the timestamp, independent of
any time zone.

`TIMESTAMP_ADD` supports the following values for `date_part`:

+ `NANOSECOND`
  (if the SQL engine supports it)
+ `MICROSECOND`
+ `MILLISECOND`
+ `SECOND`
+ `MINUTE`
+ `HOUR`. Equivalent to 60 `MINUTE` parts.
+ `DAY`. Equivalent to 24 `HOUR` parts.

**Return Data Types**

`TIMESTAMP`

**Example**

```zetasql
SELECT
  TIMESTAMP("2008-12-25 15:30:00+00") AS original,
  TIMESTAMP_ADD(TIMESTAMP "2008-12-25 15:30:00+00", INTERVAL 10 MINUTE) AS later;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*---------------------------------------------+---------------------------------------------*
 | original                                    | later                                       |
 +---------------------------------------------+---------------------------------------------+
 | 2008-12-25 07:30:00.000 America/Los_Angeles | 2008-12-25 07:40:00.000 America/Los_Angeles |
 *---------------------------------------------+---------------------------------------------*/
```

### `TIMESTAMP_DIFF`

```zetasql
TIMESTAMP_DIFF(end_timestamp, start_timestamp, granularity)
```

**Description**

Gets the number of unit boundaries between two `TIMESTAMP` values
(`end_timestamp` - `start_timestamp`) at a particular time granularity.

**Definitions**

+   `start_timestamp`: The starting `TIMESTAMP` value.
+   `end_timestamp`: The ending `TIMESTAMP` value.
+   `granularity`: The timestamp part that represents the granularity. If
    you passed in `TIMESTAMP` values for the first arguments, `granularity` can
    be:

    
    + `NANOSECOND`
      (if the SQL engine supports it)
    + `MICROSECOND`
    + `MILLISECOND`
    + `SECOND`
    + `MINUTE`
    + `HOUR`. Equivalent to 60 `MINUTE`s.
    + `DAY`. Equivalent to 24 `HOUR`s.

**Details**

If `end_timestamp` is earlier than `start_timestamp`, the output is negative.
Produces an error if the computation overflows, such as if the difference
in nanoseconds
between the two `TIMESTAMP` values overflows.

Note: The behavior of the this function follows the type of arguments passed in.
For example, `TIMESTAMP_DIFF(DATE, DATE, PART)`
behaves like `DATE_DIFF(DATE, DATE, PART)`.

**Return Data Type**

`INT64`

**Example**

```zetasql
SELECT
  TIMESTAMP("2010-07-07 10:20:00+00") AS later_timestamp,
  TIMESTAMP("2008-12-25 15:30:00+00") AS earlier_timestamp,
  TIMESTAMP_DIFF(TIMESTAMP "2010-07-07 10:20:00+00", TIMESTAMP "2008-12-25 15:30:00+00", HOUR) AS hours;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*---------------------------------------------+---------------------------------------------+-------*
 | later_timestamp                             | earlier_timestamp                           | hours |
 +---------------------------------------------+---------------------------------------------+-------+
 | 2010-07-07 03:20:00.000 America/Los_Angeles | 2008-12-25 07:30:00.000 America/Los_Angeles | 13410 |
 *---------------------------------------------+---------------------------------------------+-------*/
```

In the following example, the first timestamp occurs before the
second timestamp, resulting in a negative output.

```zetasql
SELECT TIMESTAMP_DIFF(TIMESTAMP "2018-08-14", TIMESTAMP "2018-10-14", DAY) AS negative_diff;

/*---------------*
 | negative_diff |
 +---------------+
 | -61           |
 *---------------*/
```

In this example, the result is 0 because only the number of whole specified
`HOUR` intervals are included.

```zetasql
SELECT TIMESTAMP_DIFF("2001-02-01 01:00:00", "2001-02-01 00:00:01", HOUR) AS diff;

/*---------------*
 | diff          |
 +---------------+
 | 0             |
 *---------------*/
```

### `TIMESTAMP_FROM_UNIX_MICROS`

```zetasql
TIMESTAMP_FROM_UNIX_MICROS(int64_expression)
```

```zetasql
TIMESTAMP_FROM_UNIX_MICROS(timestamp_expression)
```

**Description**

Interprets `int64_expression` as the number of microseconds since
1970-01-01 00:00:00 UTC and returns a timestamp. If a timestamp is passed in,
the same timestamp is returned.

**Return Data Type**

`TIMESTAMP`

**Example**

```zetasql
SELECT TIMESTAMP_FROM_UNIX_MICROS(1230219000000000) AS timestamp_value;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*------------------------*
 | timestamp_value        |
 +------------------------+
 | 2008-12-25 15:30:00+00 |
 *------------------------*/
```

### `TIMESTAMP_FROM_UNIX_MILLIS`

```zetasql
TIMESTAMP_FROM_UNIX_MILLIS(int64_expression)
```

```zetasql
TIMESTAMP_FROM_UNIX_MILLIS(timestamp_expression)
```

**Description**

Interprets `int64_expression` as the number of milliseconds since
1970-01-01 00:00:00 UTC and returns a timestamp. If a timestamp is passed in,
the same timestamp is returned.

**Return Data Type**

`TIMESTAMP`

**Example**

```zetasql
SELECT TIMESTAMP_FROM_UNIX_MILLIS(1230219000000) AS timestamp_value;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*------------------------*
 | timestamp_value        |
 +------------------------+
 | 2008-12-25 15:30:00+00 |
 *------------------------*/
```

### `TIMESTAMP_FROM_UNIX_SECONDS`

```zetasql
TIMESTAMP_FROM_UNIX_SECONDS(int64_expression)
```

```zetasql
TIMESTAMP_FROM_UNIX_SECONDS(timestamp_expression)
```

**Description**

Interprets `int64_expression` as the number of seconds since
1970-01-01 00:00:00 UTC and returns a timestamp. If a timestamp is passed in,
the same timestamp is returned.

**Return Data Type**

`TIMESTAMP`

**Example**

```zetasql
SELECT TIMESTAMP_FROM_UNIX_SECONDS(1230219000) AS timestamp_value;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*------------------------*
 | timestamp_value        |
 +------------------------+
 | 2008-12-25 15:30:00+00 |
 *------------------------*/
```

### `TIMESTAMP_MICROS`

```zetasql
TIMESTAMP_MICROS(int64_expression)
```

**Description**

Interprets `int64_expression` as the number of microseconds since 1970-01-01
00:00:00 UTC and returns a timestamp.

**Return Data Type**

`TIMESTAMP`

**Example**

```zetasql
SELECT TIMESTAMP_MICROS(1230219000000000) AS timestamp_value;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*------------------------*
 | timestamp_value        |
 +------------------------+
 | 2008-12-25 15:30:00+00 |
 *------------------------*/
```

### `TIMESTAMP_MILLIS`

```zetasql
TIMESTAMP_MILLIS(int64_expression)
```

**Description**

Interprets `int64_expression` as the number of milliseconds since 1970-01-01
00:00:00 UTC and returns a timestamp.

**Return Data Type**

`TIMESTAMP`

**Example**

```zetasql
SELECT TIMESTAMP_MILLIS(1230219000000) AS timestamp_value;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*------------------------*
 | timestamp_value        |
 +------------------------+
 | 2008-12-25 15:30:00+00 |
 *------------------------*/
```

### `TIMESTAMP_SECONDS`

```zetasql
TIMESTAMP_SECONDS(int64_expression)
```

**Description**

Interprets `int64_expression` as the number of seconds since 1970-01-01 00:00:00
UTC and returns a timestamp.

**Return Data Type**

`TIMESTAMP`

**Example**

```zetasql
SELECT TIMESTAMP_SECONDS(1230219000) AS timestamp_value;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*------------------------*
 | timestamp_value        |
 +------------------------+
 | 2008-12-25 15:30:00+00 |
 *------------------------*/
```

### `TIMESTAMP_SUB`

```zetasql
TIMESTAMP_SUB(timestamp_expression, INTERVAL int64_expression date_part)
```

**Description**

Subtracts `int64_expression` units of `date_part` from the timestamp,
independent of any time zone.

`TIMESTAMP_SUB` supports the following values for `date_part`:

+ `NANOSECOND`
  (if the SQL engine supports it)
+ `MICROSECOND`
+ `MILLISECOND`
+ `SECOND`
+ `MINUTE`
+ `HOUR`. Equivalent to 60 `MINUTE` parts.
+ `DAY`. Equivalent to 24 `HOUR` parts.

**Return Data Type**

`TIMESTAMP`

**Example**

```zetasql
SELECT
  TIMESTAMP("2008-12-25 15:30:00+00") AS original,
  TIMESTAMP_SUB(TIMESTAMP "2008-12-25 15:30:00+00", INTERVAL 10 MINUTE) AS earlier;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*---------------------------------------------+---------------------------------------------*
 | original                                    | earlier                                     |
 +---------------------------------------------+---------------------------------------------+
 | 2008-12-25 07:30:00.000 America/Los_Angeles | 2008-12-25 07:20:00.000 America/Los_Angeles |
 *---------------------------------------------+---------------------------------------------*/
```

### `TIMESTAMP_TRUNC`

```zetasql
TIMESTAMP_TRUNC(timestamp_value, timestamp_granularity[, time_zone])
```

```zetasql
TIMESTAMP_TRUNC(datetime_value, datetime_granularity)
```

**Description**

Truncates a `TIMESTAMP` or `DATETIME` value at a particular granularity.

**Definitions**

+ `timestamp_value`: A `TIMESTAMP` value to truncate.
+ `timestamp_granularity`: The truncation granularity for a `TIMESTAMP` value.
  [Date granularities][timestamp-trunc-granularity-date] and
  [time granularities][timestamp-trunc-granularity-time] can be used.
+ `time_zone`: A time zone to use with the `TIMESTAMP` value.
  [Time zone parts][timestamp-time-zone-parts] can be used.
  Use this argument if you want to use a time zone other than
  the default time zone, which is implementation defined, as part of the
  truncate operation.

      Note: When truncating a timestamp to `MINUTE`
    or `HOUR` parts, this function determines the civil time of the
    timestamp in the specified (or default) time zone
    and subtracts the minutes and seconds (when truncating to `HOUR`) or the
    seconds (when truncating to `MINUTE`) from that timestamp.
    While this provides intuitive results in most cases, the result is
    non-intuitive near daylight savings transitions that aren't hour-aligned.
+ `datetime_value`: A `DATETIME` value to truncate.
+ `datetime_granularity`: The truncation granularity for a `DATETIME` value.
  [Date granularities][timestamp-trunc-granularity-date] and
  [time granularities][timestamp-trunc-granularity-time] can be used.

<a id="timestamp_trunc_granularity_date"></a>

**Date granularity definitions**

  + `DAY`: The day in the Gregorian calendar year that contains the
    value to truncate.

  + `WEEK`: The first day in the week that contains the
    value to truncate. Weeks begin on Sundays. `WEEK` is equivalent to
    `WEEK(SUNDAY)`.

  + `WEEK(WEEKDAY)`: The first day in the week that contains the
    value to truncate. Weeks begin on `WEEKDAY`. `WEEKDAY` must be one of the
     following: `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`,
     or `SATURDAY`.

  + `ISOWEEK`: The first day in the [ISO 8601 week][ISO-8601-week] that contains
    the value to truncate. The ISO week begins on
    Monday. The first ISO week of each ISO year contains the first Thursday of the
    corresponding Gregorian calendar year.

  + `MONTH`: The first day in the month that contains the
    value to truncate.

  + `QUARTER`: The first day in the quarter that contains the
    value to truncate.

  + `YEAR`: The first day in the year that contains the
    value to truncate.

  + `ISOYEAR`: The first day in the [ISO 8601][ISO-8601] week-numbering year
    that contains the value to truncate. The ISO year is the
    Monday of the first week where Thursday belongs to the corresponding
    Gregorian calendar year.

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[ISO-8601]: https://en.wikipedia.org/wiki/ISO_8601

[ISO-8601-week]: https://en.wikipedia.org/wiki/ISO_week_date

<!-- mdlint on -->

<a id="timestamp_trunc_granularity_time"></a>

**Time granularity definitions**

  + `NANOSECOND`: If used, nothing is truncated from the value.

  + `MICROSECOND`: The nearest lesser than or equal microsecond.

  + `MILLISECOND`: The nearest lesser than or equal millisecond.

  + `SECOND`: The nearest lesser than or equal second.

  + `MINUTE`: The nearest lesser than or equal minute.

  + `HOUR`: The nearest lesser than or equal hour.

<a id="timestamp_time_zone_parts"></a>

**Time zone part definitions**

+ `MINUTE`
+ `HOUR`
+ `DAY`
+ `WEEK`
+ `WEEK(<WEEKDAY>)`
+ `ISOWEEK`
+ `MONTH`
+ `QUARTER`
+ `YEAR`
+ `ISOYEAR`

**Details**

The resulting value is always rounded to the beginning of `granularity`.

**Return Data Type**

The same data type as the first argument passed into this function.

**Examples**

```zetasql
SELECT
  TIMESTAMP_TRUNC(TIMESTAMP "2008-12-25 15:30:00+00", DAY, "UTC") AS utc,
  TIMESTAMP_TRUNC(TIMESTAMP "2008-12-25 15:30:00+00", DAY, "America/Los_Angeles") AS la;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*---------------------------------------------+---------------------------------------------*
 | utc                                         | la                                          |
 +---------------------------------------------+---------------------------------------------+
 | 2008-12-24 16:00:00.000 America/Los_Angeles | 2008-12-25 00:00:00.000 America/Los_Angeles |
 *---------------------------------------------+---------------------------------------------*/
```

In the following example, `timestamp_expression` has a time zone offset of +12.
The first column shows the `timestamp_expression` in UTC time. The second
column shows the output of `TIMESTAMP_TRUNC` using weeks that start on Monday.
Because the `timestamp_expression` falls on a Sunday in UTC, `TIMESTAMP_TRUNC`
truncates it to the preceding Monday. The third column shows the same function
with the optional [Time zone definition][timestamp-link-to-timezone-definitions]
argument 'Pacific/Auckland'. Here, the function truncates the
`timestamp_expression` using New Zealand Daylight Time, where it falls on a
Monday.

```zetasql
SELECT
  timestamp_value AS timestamp_value,
  TIMESTAMP_TRUNC(timestamp_value, WEEK(MONDAY), "UTC") AS utc_truncated,
  TIMESTAMP_TRUNC(timestamp_value, WEEK(MONDAY), "Pacific/Auckland") AS nzdt_truncated
FROM (SELECT TIMESTAMP("2017-11-06 00:00:00+12") AS timestamp_value);

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*---------------------------------------------+---------------------------------------------+---------------------------------------------*
 | timestamp_value                             | utc_truncated                               | nzdt_truncated                              |
 +---------------------------------------------+---------------------------------------------+---------------------------------------------+
 | 2017-11-05 04:00:00.000 America/Los_Angeles | 2017-10-29 17:00:00.000 America/Los_Angeles | 2017-11-05 03:00:00.000 America/Los_Angeles |
 *---------------------------------------------+---------------------------------------------+---------------------------------------------*/
```

In the following example, the original `timestamp_expression` is in the
Gregorian calendar year 2015. However, `TIMESTAMP_TRUNC` with the `ISOYEAR` date
part truncates the `timestamp_expression` to the beginning of the ISO year, not
the Gregorian calendar year. The first Thursday of the 2015 calendar year was
2015-01-01, so the ISO year 2015 begins on the preceding Monday, 2014-12-29.
Therefore the ISO year boundary preceding the `timestamp_expression`
2015-06-15 00:00:00+00 is 2014-12-29.

```zetasql
SELECT
  TIMESTAMP_TRUNC("2015-06-15 00:00:00+00", ISOYEAR) AS isoyear_boundary,
  EXTRACT(ISOYEAR FROM TIMESTAMP "2015-06-15 00:00:00+00") AS isoyear_number;

-- Display of results may differ, depending upon the environment and time zone where this query was executed.
/*---------------------------------------------+----------------*
 | isoyear_boundary                            | isoyear_number |
 +---------------------------------------------+----------------+
 | 2014-12-29 00:00:00.000 America/Los_Angeles | 2015           |
 *---------------------------------------------+----------------*/
```

[timestamp-link-to-timezone-definitions]: #timezone_definitions

[timestamp-trunc-granularity-date]: #timestamp_trunc_granularity_date

[timestamp-trunc-granularity-time]: #timestamp_trunc_granularity_time

[timestamp-time-zone-parts]: #timestamp_time_zone_parts

### `UNIX_MICROS`

```zetasql
UNIX_MICROS(timestamp_expression)
```

**Description**

Returns the number of microseconds since `1970-01-01 00:00:00 UTC`.
Truncates higher levels of precision by
rounding down to the beginning of the microsecond.

**Return Data Type**

`INT64`

**Examples**

```zetasql
SELECT UNIX_MICROS(TIMESTAMP "2008-12-25 15:30:00+00") AS micros;

/*------------------*
 | micros           |
 +------------------+
 | 1230219000000000 |
 *------------------*/
```

```zetasql
SELECT UNIX_MICROS(TIMESTAMP "1970-01-01 00:00:00.0000018+00") AS micros;

/*------------------*
 | micros           |
 +------------------+
 | 1                |
 *------------------*/
```

### `UNIX_MILLIS`

```zetasql
UNIX_MILLIS(timestamp_expression)
```

**Description**

Returns the number of milliseconds since `1970-01-01 00:00:00 UTC`. Truncates
higher levels of precision by rounding down to the beginning of the millisecond.

**Return Data Type**

`INT64`

**Examples**

```zetasql
SELECT UNIX_MILLIS(TIMESTAMP "2008-12-25 15:30:00+00") AS millis;

/*---------------*
 | millis        |
 +---------------+
 | 1230219000000 |
 *---------------*/
```

```zetasql
SELECT UNIX_MILLIS(TIMESTAMP "1970-01-01 00:00:00.0018+00") AS millis;

/*---------------*
 | millis        |
 +---------------+
 | 1             |
 *---------------*/
```

### `UNIX_SECONDS`

```zetasql
UNIX_SECONDS(timestamp_expression)
```

**Description**

Returns the number of seconds since `1970-01-01 00:00:00 UTC`. Truncates higher
levels of precision by rounding down to the beginning of the second.

**Return Data Type**

`INT64`

**Examples**

```zetasql
SELECT UNIX_SECONDS(TIMESTAMP "2008-12-25 15:30:00+00") AS seconds;

/*------------*
 | seconds    |
 +------------+
 | 1230219000 |
 *------------*/
```

```zetasql
SELECT UNIX_SECONDS(TIMESTAMP "1970-01-01 00:00:01.8+00") AS seconds;

/*------------*
 | seconds    |
 +------------+
 | 1          |
 *------------*/
```

### Supplemental materials

### How time zones work with timestamp functions 
<a id="timezone_definitions"></a>

A timestamp represents an absolute point in time, independent of any time
zone. However, when a timestamp value is displayed, it's usually converted to
a human-readable format consisting of a civil date and time
(YYYY-MM-DD HH:MM:SS)
and a time zone. This isn't the internal representation of the
`TIMESTAMP`; it's only a human-understandable way to describe the point in time
that the timestamp represents.

Some timestamp functions have a time zone argument. A time zone is needed to
convert between civil time (YYYY-MM-DD HH:MM:SS) and the absolute time
represented by a timestamp.
A function like `PARSE_TIMESTAMP` takes an input string that represents a
civil time and returns a timestamp that represents an absolute time. A
time zone is needed for this conversion. A function like `EXTRACT` takes an
input timestamp (absolute time) and converts it to civil time in order to
extract a part of that civil time. This conversion requires a time zone.
If no time zone is specified, the default time zone, which is implementation defined,
is used.

Certain date and timestamp functions allow you to override the default time zone
and specify a different one. You can specify a time zone by either supplying
the time zone name (for example, `America/Los_Angeles`)
or time zone offset from UTC (for example, -08).

To learn more about how time zones work with the `TIMESTAMP` type, see
[Time zones][data-types-timezones].

[data-types-timezones]: https://github.com/google/zetasql/blob/master/docs/data-types.md#time_zones

[data-types-timezones]: https://github.com/google/zetasql/blob/master/docs/data-types.md#time_zones

[timestamp-link-to-timezone-definitions]: #timezone_definitions

[data-types-link-to-date_type]: https://github.com/google/zetasql/blob/master/docs/data-types.md#date_type

[data-types-link-to-timestamp_type]: https://github.com/google/zetasql/blob/master/docs/data-types.md#timestamp_type

## Window functions

ZetaSQL supports the following
[window functions][window-function-calls].

### Function list

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Summary</th>
    </tr>
  </thead>
  <tbody>

<tr>
  <td><a href="#cume_dist"><code>CUME_DIST</code></a>
</td>
  <td>
    Gets the cumulative distribution (relative position (0,1]) of each row
    within a window.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/numbering_functions.md">Numbering functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#dense_rank"><code>DENSE_RANK</code></a>
</td>
  <td>
    Gets the dense rank (1-based, no gaps) of each row within a window.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/numbering_functions.md">Numbering functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#first_value"><code>FIRST_VALUE</code></a>
</td>
  <td>
    Gets a value for the first row in the current window frame.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/navigation_functions.md">Navigation functions</a>.

  </td>
</tr>

<tr>
  <td>
    
    <a href="#is_first"><code>IS_FIRST</code></a>

    
  </td>
  <td>
        Returns <code>true</code> if this row is in the first <code>k</code> rows (1-based) within the window.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/numbering_functions.md">Numbering functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#IS_LAST"><code>IS_LAST</code></a>
</td>
  <td>
        Returns <code>true</code> if this row is in the last <code>k</code> rows (1-based) within the window.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/numbering_functions.md">Numbering functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lag"><code>LAG</code></a>
</td>
  <td>
    Gets a value for a preceding row.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/navigation_functions.md">Navigation functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#last_value"><code>LAST_VALUE</code></a>
</td>
  <td>
    Gets a value for the last row in the current window frame.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/navigation_functions.md">Navigation functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#lead"><code>LEAD</code></a>
</td>
  <td>
    Gets a value for a subsequent row.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/navigation_functions.md">Navigation functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#nth_value"><code>NTH_VALUE</code></a>
</td>
  <td>
    Gets a value for the Nth row of the current window frame.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/navigation_functions.md">Navigation functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#ntile"><code>NTILE</code></a>
</td>
  <td>
    Gets the quantile bucket number (1-based) of each row within a window.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/numbering_functions.md">Numbering functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#percent_rank"><code>PERCENT_RANK</code></a>
</td>
  <td>
    Gets the percentile rank (from 0 to 1) of each row within a window.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/numbering_functions.md">Numbering functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#percentile_cont"><code>PERCENTILE_CONT</code></a>
</td>
  <td>
    Computes the specified percentile for a value, using
    linear interpolation.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/navigation_functions.md">Navigation functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#percentile_disc"><code>PERCENTILE_DISC</code></a>
</td>
  <td>
    Computes the specified percentile for a discrete value.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/navigation_functions.md">Navigation functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#rank"><code>RANK</code></a>
</td>
  <td>
    Gets the rank (1-based) of each row within a window.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/numbering_functions.md">Numbering functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#row_number"><code>ROW_NUMBER</code></a>
</td>
  <td>
    Gets the sequential row number (1-based) of each row within a window.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/numbering_functions.md">Numbering functions</a>.

  </td>
</tr>

<tr>
  <td><a href="#st_clusterdbscan"><code>ST_CLUSTERDBSCAN</code></a>
</td>
  <td>
    Performs DBSCAN clustering on a group of <code>GEOGRAPHY</code> values and
    produces a 0-based cluster number for this row.
    <br>For more information, see <a href="https://github.com/google/zetasql/blob/master/docs/geography_functions.md">Geography functions</a>.

  </td>
</tr>

  </tbody>
</table>

[window-function-calls]: https://github.com/google/zetasql/blob/master/docs/window-function-calls.md

<!-- enableFinding(G3DOC_ATTRIBUTE) -->

<!-- mdlint off(WHITESPACE_LINE_LENGTH) -->

[subqueries]: https://github.com/google/zetasql/blob/master/docs/subqueries.md

[function-calls]: https://github.com/google/zetasql/blob/master/docs/functions-reference.md

<!-- mdlint on -->

