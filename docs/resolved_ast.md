<!-- resolved_ast.md GENERATED FROM
  -- https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/resolved_ast.md.template
  -- by
  -- https://github.com/google/zetasql/blob/master/docs/staging/dictionaries/zetasql/generate_resolved_ast.sh
  -->

# ZetaSQL Resolved AST

## The ZetaSQL Resolved AST

The ZetaSQL analyzer produces an abstract syntax tree (AST). The nodes of this
AST (ResolveAST) are generated by
[https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/gen_resolved_ast.py] for both C++
and Java using bazel genrules. This document provides a summary of the nodes and
their hierarchy.

### C++ { #ResolvedNode}

The base class `ResolvedNode` is defined in
[https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/resolved_node.h](https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/resolved_node.h)

The generated classes are specified in
[https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/gen_resolved_ast.py](https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/gen_resolved_ast.py)
See that file for comments on specific nodes and fields.

### Java

The base class `ResolvedNode` is defined in
[https://github.com/google/zetasql/blob/master/java/com/google/zetasql/resolvedast/ResolvedNode.java](https://github.com/google/zetasql/blob/master/java/com/google/zetasql/resolvedast/ResolvedNode.java)

The generated classes are specified in
[https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/gen_resolved_ast.py](https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/gen_resolved_ast.py)
See that file for comments on specific nodes and fields.

## Resolved AST Node Hierarchy

<p><pre><code>
<a href="#ResolvedNode">ResolvedNode</a>
  <a href="#ResolvedArgument">ResolvedArgument</a>
    <a href="#ResolvedAggregateHavingModifier">ResolvedAggregateHavingModifier</a>
    <a href="#ResolvedAlterAction">ResolvedAlterAction</a>
      <a href="#ResolvedAddColumnAction">ResolvedAddColumnAction</a>
      <a href="#ResolvedAddConstraintAction">ResolvedAddConstraintAction</a>
      <a href="#ResolvedAlterColumnDropNotNullAction">ResolvedAlterColumnDropNotNullAction</a>
      <a href="#ResolvedAlterColumnOptionsAction">ResolvedAlterColumnOptionsAction</a>
      <a href="#ResolvedAlterColumnSetDataTypeAction">ResolvedAlterColumnSetDataTypeAction</a>
      <a href="#ResolvedDropColumnAction">ResolvedDropColumnAction</a>
      <a href="#ResolvedDropConstraintAction">ResolvedDropConstraintAction</a>
      <a href="#ResolvedDropPrimaryKeyAction">ResolvedDropPrimaryKeyAction</a>
      <a href="#ResolvedFilterUsingAction">ResolvedFilterUsingAction</a>
      <a href="#ResolvedGrantToAction">ResolvedGrantToAction</a>
      <a href="#ResolvedRenameToAction">ResolvedRenameToAction</a>
      <a href="#ResolvedRevokeFromAction">ResolvedRevokeFromAction</a>
      <a href="#ResolvedSetAsAction">ResolvedSetAsAction</a>
      <a href="#ResolvedSetOptionsAction">ResolvedSetOptionsAction</a>
    <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>
    <a href="#ResolvedArgumentDef">ResolvedArgumentDef</a>
    <a href="#ResolvedArgumentList">ResolvedArgumentList</a>
    <a href="#ResolvedAssertRowsModified">ResolvedAssertRowsModified</a>
    <a href="#ResolvedColumnAnnotations">ResolvedColumnAnnotations</a>
    <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>
    <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>
    <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>
    <a href="#ResolvedConnection">ResolvedConnection</a>
    <a href="#ResolvedConstraint">ResolvedConstraint</a>
      <a href="#ResolvedCheckConstraint">ResolvedCheckConstraint</a>
      <a href="#ResolvedForeignKey">ResolvedForeignKey</a>
    <a href="#ResolvedDMLValue">ResolvedDMLValue</a>
    <a href="#ResolvedDescriptor">ResolvedDescriptor</a>
    <a href="#ResolvedExecuteImmediateArgument">ResolvedExecuteImmediateArgument</a>
    <a href="#ResolvedExtendedCast">ResolvedExtendedCast</a>
    <a href="#ResolvedExtendedCastElement">ResolvedExtendedCastElement</a>
    <a href="#ResolvedFilterFieldArg">ResolvedFilterFieldArg</a>
    <a href="#ResolvedFunctionArgument">ResolvedFunctionArgument</a>
    <a href="#ResolvedFunctionSignatureHolder">ResolvedFunctionSignatureHolder</a>
    <a href="#ResolvedGeneratedColumnInfo">ResolvedGeneratedColumnInfo</a>
    <a href="#ResolvedGroupingSet">ResolvedGroupingSet</a>
    <a href="#ResolvedIndexItem">ResolvedIndexItem</a>
    <a href="#ResolvedInlineLambda">ResolvedInlineLambda</a>
    <a href="#ResolvedInsertRow">ResolvedInsertRow</a>
    <a href="#ResolvedMakeProtoField">ResolvedMakeProtoField</a>
    <a href="#ResolvedMergeWhen">ResolvedMergeWhen</a>
    <a href="#ResolvedModel">ResolvedModel</a>
    <a href="#ResolvedOption">ResolvedOption</a>
    <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>
    <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>
    <a href="#ResolvedPivotColumn">ResolvedPivotColumn</a>
    <a href="#ResolvedPrimaryKey">ResolvedPrimaryKey</a>
    <a href="#ResolvedPrivilege">ResolvedPrivilege</a>
    <a href="#ResolvedReplaceFieldItem">ResolvedReplaceFieldItem</a>
    <a href="#ResolvedReturningClause">ResolvedReturningClause</a>
    <a href="#ResolvedSetOperationItem">ResolvedSetOperationItem</a>
    <a href="#ResolvedTableAndColumnInfo">ResolvedTableAndColumnInfo</a>
    <a href="#ResolvedUnnestItem">ResolvedUnnestItem</a>
    <a href="#ResolvedUnpivotArg">ResolvedUnpivotArg</a>
    <a href="#ResolvedUpdateArrayItem">ResolvedUpdateArrayItem</a>
    <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>
    <a href="#ResolvedWindowFrame">ResolvedWindowFrame</a>
    <a href="#ResolvedWindowFrameExpr">ResolvedWindowFrameExpr</a>
    <a href="#ResolvedWindowOrdering">ResolvedWindowOrdering</a>
    <a href="#ResolvedWindowPartitioning">ResolvedWindowPartitioning</a>
    <a href="#ResolvedWithEntry">ResolvedWithEntry</a>
    <a href="#ResolvedWithPartitionColumns">ResolvedWithPartitionColumns</a>
  <a href="#ResolvedExpr">ResolvedExpr</a>
    <a href="#ResolvedArgumentRef">ResolvedArgumentRef</a>
    <a href="#ResolvedCast">ResolvedCast</a>
    <a href="#ResolvedColumnRef">ResolvedColumnRef</a>
    <a href="#ResolvedConstant">ResolvedConstant</a>
    <a href="#ResolvedDMLDefault">ResolvedDMLDefault</a>
    <a href="#ResolvedExpressionColumn">ResolvedExpressionColumn</a>
    <a href="#ResolvedFilterField">ResolvedFilterField</a>
    <a href="#ResolvedFlatten">ResolvedFlatten</a>
    <a href="#ResolvedFlattenedArg">ResolvedFlattenedArg</a>
    <a href="#ResolvedFunctionCallBase">ResolvedFunctionCallBase</a>
      <a href="#ResolvedFunctionCall">ResolvedFunctionCall</a>
      <a href="#ResolvedNonScalarFunctionCallBase">ResolvedNonScalarFunctionCallBase</a>
        <a href="#ResolvedAggregateFunctionCall">ResolvedAggregateFunctionCall</a>
        <a href="#ResolvedAnalyticFunctionCall">ResolvedAnalyticFunctionCall</a>
    <a href="#ResolvedGetJsonField">ResolvedGetJsonField</a>
    <a href="#ResolvedGetProtoField">ResolvedGetProtoField</a>
    <a href="#ResolvedGetStructField">ResolvedGetStructField</a>
    <a href="#ResolvedLiteral">ResolvedLiteral</a>
    <a href="#ResolvedMakeProto">ResolvedMakeProto</a>
    <a href="#ResolvedMakeStruct">ResolvedMakeStruct</a>
    <a href="#ResolvedParameter">ResolvedParameter</a>
    <a href="#ResolvedReplaceField">ResolvedReplaceField</a>
    <a href="#ResolvedSubqueryExpr">ResolvedSubqueryExpr</a>
    <a href="#ResolvedSystemVariable">ResolvedSystemVariable</a>
  <a href="#ResolvedScan">ResolvedScan</a>
    <a href="#ResolvedAggregateScanBase">ResolvedAggregateScanBase</a>
      <a href="#ResolvedAggregateScan">ResolvedAggregateScan</a>
      <a href="#ResolvedAnonymizedAggregateScan">ResolvedAnonymizedAggregateScan</a>
    <a href="#ResolvedAnalyticScan">ResolvedAnalyticScan</a>
    <a href="#ResolvedArrayScan">ResolvedArrayScan</a>
    <a href="#ResolvedFilterScan">ResolvedFilterScan</a>
    <a href="#ResolvedGroupRowsScan">ResolvedGroupRowsScan</a>
    <a href="#ResolvedJoinScan">ResolvedJoinScan</a>
    <a href="#ResolvedLimitOffsetScan">ResolvedLimitOffsetScan</a>
    <a href="#ResolvedOrderByScan">ResolvedOrderByScan</a>
    <a href="#ResolvedPivotScan">ResolvedPivotScan</a>
    <a href="#ResolvedProjectScan">ResolvedProjectScan</a>
    <a href="#ResolvedRecursiveRefScan">ResolvedRecursiveRefScan</a>
    <a href="#ResolvedRecursiveScan">ResolvedRecursiveScan</a>
    <a href="#ResolvedRelationArgumentScan">ResolvedRelationArgumentScan</a>
    <a href="#ResolvedSampleScan">ResolvedSampleScan</a>
    <a href="#ResolvedSetOperationScan">ResolvedSetOperationScan</a>
    <a href="#ResolvedSingleRowScan">ResolvedSingleRowScan</a>
    <a href="#ResolvedTVFScan">ResolvedTVFScan</a>
    <a href="#ResolvedTableScan">ResolvedTableScan</a>
    <a href="#ResolvedUnpivotScan">ResolvedUnpivotScan</a>
    <a href="#ResolvedWithRefScan">ResolvedWithRefScan</a>
    <a href="#ResolvedWithScan">ResolvedWithScan</a>
  <a href="#ResolvedStatement">ResolvedStatement</a>
    <a href="#ResolvedAbortBatchStmt">ResolvedAbortBatchStmt</a>
    <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a>
      <a href="#ResolvedAlterAllRowAccessPoliciesStmt">ResolvedAlterAllRowAccessPoliciesStmt</a>
      <a href="#ResolvedAlterDatabaseStmt">ResolvedAlterDatabaseStmt</a>
      <a href="#ResolvedAlterEntityStmt">ResolvedAlterEntityStmt</a>
      <a href="#ResolvedAlterMaterializedViewStmt">ResolvedAlterMaterializedViewStmt</a>
      <a href="#ResolvedAlterRowAccessPolicyStmt">ResolvedAlterRowAccessPolicyStmt</a>
      <a href="#ResolvedAlterSchemaStmt">ResolvedAlterSchemaStmt</a>
      <a href="#ResolvedAlterTableStmt">ResolvedAlterTableStmt</a>
      <a href="#ResolvedAlterViewStmt">ResolvedAlterViewStmt</a>
    <a href="#ResolvedAlterTableSetOptionsStmt">ResolvedAlterTableSetOptionsStmt</a>
    <a href="#ResolvedAnalyzeStmt">ResolvedAnalyzeStmt</a>
    <a href="#ResolvedAssertStmt">ResolvedAssertStmt</a>
    <a href="#ResolvedAssignmentStmt">ResolvedAssignmentStmt</a>
    <a href="#ResolvedBeginStmt">ResolvedBeginStmt</a>
    <a href="#ResolvedCallStmt">ResolvedCallStmt</a>
    <a href="#ResolvedCloneDataStmt">ResolvedCloneDataStmt</a>
    <a href="#ResolvedCommitStmt">ResolvedCommitStmt</a>
    <a href="#ResolvedCreateDatabaseStmt">ResolvedCreateDatabaseStmt</a>
    <a href="#ResolvedCreateRowAccessPolicyStmt">ResolvedCreateRowAccessPolicyStmt</a>
    <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a>
      <a href="#ResolvedCreateConstantStmt">ResolvedCreateConstantStmt</a>
      <a href="#ResolvedCreateEntityStmt">ResolvedCreateEntityStmt</a>
      <a href="#ResolvedCreateFunctionStmt">ResolvedCreateFunctionStmt</a>
      <a href="#ResolvedCreateIndexStmt">ResolvedCreateIndexStmt</a>
      <a href="#ResolvedCreateModelStmt">ResolvedCreateModelStmt</a>
      <a href="#ResolvedCreateProcedureStmt">ResolvedCreateProcedureStmt</a>
      <a href="#ResolvedCreateSchemaStmt">ResolvedCreateSchemaStmt</a>
      <a href="#ResolvedCreateSnapshotTableStmt">ResolvedCreateSnapshotTableStmt</a>
      <a href="#ResolvedCreateTableFunctionStmt">ResolvedCreateTableFunctionStmt</a>
      <a href="#ResolvedCreateTableStmtBase">ResolvedCreateTableStmtBase</a>
        <a href="#ResolvedCreateExternalTableStmt">ResolvedCreateExternalTableStmt</a>
        <a href="#ResolvedCreateTableAsSelectStmt">ResolvedCreateTableAsSelectStmt</a>
        <a href="#ResolvedCreateTableStmt">ResolvedCreateTableStmt</a>
      <a href="#ResolvedCreateViewBase">ResolvedCreateViewBase</a>
        <a href="#ResolvedCreateMaterializedViewStmt">ResolvedCreateMaterializedViewStmt</a>
        <a href="#ResolvedCreateViewStmt">ResolvedCreateViewStmt</a>
    <a href="#ResolvedDefineTableStmt">ResolvedDefineTableStmt</a>
    <a href="#ResolvedDeleteStmt">ResolvedDeleteStmt</a>
    <a href="#ResolvedDescribeStmt">ResolvedDescribeStmt</a>
    <a href="#ResolvedDropFunctionStmt">ResolvedDropFunctionStmt</a>
    <a href="#ResolvedDropMaterializedViewStmt">ResolvedDropMaterializedViewStmt</a>
    <a href="#ResolvedDropRowAccessPolicyStmt">ResolvedDropRowAccessPolicyStmt</a>
    <a href="#ResolvedDropSearchIndexStmt">ResolvedDropSearchIndexStmt</a>
    <a href="#ResolvedDropSnapshotTableStmt">ResolvedDropSnapshotTableStmt</a>
    <a href="#ResolvedDropStmt">ResolvedDropStmt</a>
    <a href="#ResolvedDropTableFunctionStmt">ResolvedDropTableFunctionStmt</a>
    <a href="#ResolvedExecuteImmediateStmt">ResolvedExecuteImmediateStmt</a>
    <a href="#ResolvedExplainStmt">ResolvedExplainStmt</a>
    <a href="#ResolvedExportDataStmt">ResolvedExportDataStmt</a>
    <a href="#ResolvedExportModelStmt">ResolvedExportModelStmt</a>
    <a href="#ResolvedGrantOrRevokeStmt">ResolvedGrantOrRevokeStmt</a>
      <a href="#ResolvedGrantStmt">ResolvedGrantStmt</a>
      <a href="#ResolvedRevokeStmt">ResolvedRevokeStmt</a>
    <a href="#ResolvedImportStmt">ResolvedImportStmt</a>
    <a href="#ResolvedInsertStmt">ResolvedInsertStmt</a>
    <a href="#ResolvedMergeStmt">ResolvedMergeStmt</a>
    <a href="#ResolvedModuleStmt">ResolvedModuleStmt</a>
    <a href="#ResolvedQueryStmt">ResolvedQueryStmt</a>
    <a href="#ResolvedRenameStmt">ResolvedRenameStmt</a>
    <a href="#ResolvedRollbackStmt">ResolvedRollbackStmt</a>
    <a href="#ResolvedRunBatchStmt">ResolvedRunBatchStmt</a>
    <a href="#ResolvedSetTransactionStmt">ResolvedSetTransactionStmt</a>
    <a href="#ResolvedShowStmt">ResolvedShowStmt</a>
    <a href="#ResolvedStartBatchStmt">ResolvedStartBatchStmt</a>
    <a href="#ResolvedTruncateStmt">ResolvedTruncateStmt</a>
    <a href="#ResolvedUpdateStmt">ResolvedUpdateStmt</a>
</code></pre></p>

## Node Details

NOTE: This documentation includes only the public field accessors. It excludes
constructors, setters, and boilerplate implementation of virtual methods from
the base class.

### ResolvedArgument
<a id="ResolvedArgument"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Argument nodes are not self-contained nodes in the tree.  They exist
// only to describe parameters to another node (e.g. columns in an OrderBy).
// This node is here for organizational purposes only, to cluster these
// argument nodes.</font>
class ResolvedArgument : public <a href="#ResolvedNode">ResolvedNode</a> {
};
</code></pre></p>

### ResolvedExpr
<a id="ResolvedExpr"></a>

<p><pre><code class="lang-c++">
class ResolvedExpr : public <a href="#ResolvedNode">ResolvedNode</a> {
  bool IsExpression() const final { return true; }

  AnnotatedType annotated_type() const {
    return {type(), type_annotation_map()};
  }

  const Type* type() const;

  const AnnotationMap* type_annotation_map() const;
};
</code></pre></p>

### ResolvedLiteral
<a id="ResolvedLiteral"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Any literal value, including NULL literals.
// There is a special-cased constructor here that gets the type from the
// Value.</font>
class ResolvedLiteral : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_LITERAL;

  const Value&amp; value() const;

<font color="brown">  // If true, then the literal is explicitly typed and cannot be used
  // for literal coercions.
  //
  // This exists mainly for resolver bookkeeping and should be ignored
  // by engines.</font>
  bool has_explicit_type() const;

<font color="brown">  // Distinct ID of the literal, if it is a floating point value,
  // within the resolved AST. When coercing from floating point
  // to NUMERIC, the resolver uses the float_literal_id to find the
  // original image of the literal to avoid precision loss. An ID of 0
  // represents a literal without a cached image.</font>
  int float_literal_id() const;

<font color="brown">  // Indicates whether ReplaceLiteralsByParameters() should leave
  // this literal value in place, rather than replace it with a query
  // parameter.</font>
  bool preserve_in_literal_remover() const;
};
</code></pre></p>

### ResolvedParameter
<a id="ResolvedParameter"></a>

<p><pre><code class="lang-c++">
class ResolvedParameter : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PARAMETER;

<font color="brown">  // If non-empty, the name of the parameter.
  //
  // A ResolvedParameter will have either a name or a position but not
  // both.</font>
  const std::string&amp; name() const;

<font color="brown">  // If non-zero, the 1-based position of the positional parameter.
  //
  // A ResolvedParameter will have either a name or a position but not
  // both.</font>
  int position() const;

<font color="brown">  // If true, then the parameter has no specified type.
  //
  // This exists mainly for resolver bookkeeping and should be ignored
  // by engines.</font>
  bool is_untyped() const;
};
</code></pre></p>

### ResolvedExpressionColumn
<a id="ResolvedExpressionColumn"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents a column when analyzing a standalone expression.
// This is only used when the analyzer was called using AnalyzeExpression.
// Expression column names and types come from
// AnalyzerOptions::AddExpressionColumn.
// &lt;name&gt; will always be in lowercase.</font>
class ResolvedExpressionColumn : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXPRESSION_COLUMN;

  const std::string&amp; name() const;
};
</code></pre></p>

### ResolvedColumnRef
<a id="ResolvedColumnRef"></a>

<p><pre><code class="lang-c++">
<font color="brown">// An expression referencing the value of some column visible in the
// current Scan node.
//
// If &lt;is_correlated&gt; is false, this must be a column visible in the Scan
// containing this expression, either because it was produced inside that
// Scan or it is on the &lt;column_list&gt; of some child of this Scan.
//
// If &lt;is_correlated&gt; is true, this references a column from outside a
// subquery that is visible as a correlated column inside.
// The column referenced here must show up on the parameters list for the
// subquery.  See ResolvedSubqueryExpr.</font>
class ResolvedColumnRef : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_COLUMN_REF;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const;

  bool is_correlated() const;
};
</code></pre></p>

### ResolvedConstant
<a id="ResolvedConstant"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A reference to a named constant.</font>
class ResolvedConstant : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CONSTANT;

<font color="brown">  // The matching Constant from the Catalog.</font>
  const Constant* constant() const;
};
</code></pre></p>

### ResolvedSystemVariable
<a id="ResolvedSystemVariable"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A reference to a system variable.</font>
class ResolvedSystemVariable : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SYSTEM_VARIABLE;

<font color="brown">  // Path to system variable.</font>
  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;
};
</code></pre></p>

### ResolvedInlineLambda
<a id="ResolvedInlineLambda"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A lambda expression, used inline as a function argument.
// This represents both the definition of the lambda and the resolution of
// its templated signature and body for this function call.
// Currently can only be used as an argument of a function.
//
// &lt;argument_list&gt; defines the argument types and names for the lambda, and
// creates new ResolvedColumns which can be used to reference the arguments
// inside &lt;body&gt;.
//
// The return type of the lambda function is the type of &lt;body&gt;.
//
// In addition to the &lt;argument_list&gt;, the body of a lambda expression can
// reference columns visible to the scope of the function call for which this
// lambda is provided as an argument. Columns in this scope accessed by the
// body are stored in &lt;parameter_list&gt;.
//
// For example, the following query
//   SELECT ARRAY_FILTER([1,2,3], e -&gt; e = key) FROM KeyValue;
// would have a lambda with &lt;parameter_list&gt; [&#39;key&#39;] and &lt;argument_list&gt;
// [&#39;e&#39;].
//
// &lt;body&gt; is the body expression of the lambda. The expression can only
// reference columns in &lt;parameter_list&gt; and &lt;argument_list&gt;.</font>
class ResolvedInlineLambda : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_INLINE_LAMBDA;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; argument_list() const;
  int argument_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> argument_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; parameter_list() const;
  int parameter_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* parameter_list(int i) const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* body() const;
};
</code></pre></p>

### ResolvedFilterFieldArg
<a id="ResolvedFilterFieldArg"></a>

<p><pre><code class="lang-c++">
<font color="brown">// An argument to the FILTER_FIELDS() function which specifies a sign to show
// inclusion/exclusion status and a field path to include or exclude.</font>
class ResolvedFilterFieldArg : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FILTER_FIELD_ARG;

<font color="brown">  // True if we want to include this proto path in the resulting proto
  // (though we may still remove paths below it).
  // If False, we will remove this path (but may still include paths
  // below it).</font>
  bool include() const;

<font color="brown">  // A vector of FieldDescriptors that denotes the path to a proto
  // field that will be include or exclude.</font>
  const std::vector&lt;const google::protobuf::FieldDescriptor*&gt;&amp; field_descriptor_path() const;
  int field_descriptor_path_size() const;
  const google::protobuf::FieldDescriptor* field_descriptor_path(int i) const;
};
</code></pre></p>

### ResolvedFilterField
<a id="ResolvedFilterField"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Represents a call to the FILTER_FIELDS() function. This function can be
// used to modify a proto, prune fields and output the resulting proto. The
// SQL syntax for this function is
//   FILTER_FIELDS(&lt;expr&gt;, &lt;filter_field_arg_list&gt;).
//
// &lt;expr&gt; must have proto type. &lt;filter_field_arg&gt; contains a sign (&#39;+&#39; or
// &#39;-&#39;) and a field path starting from the proto.
//
// For example:
//   FILTER_FIELDS(proto, +field1, -field1.field2)
// means the resulting proto only contains field1.* except field1.field2.*.
//
// Field paths are evaluated and processed in order,
// ```
//   IF filter_field_arg_list[0].include:
//     CLEAR all fields
//   FOR filter_field_arg IN filter_field_arg_list:
//     IF filter_field_arg.include:
//       UNCLEAR filter_field_arg.field_descriptor_path (and all children)
//     ELSE:
//       CLEAR filter_field_arg.field_descriptor_path (and all children)
// ```
//
// The order of field_field args have following constraints:
// 1. There must be at least one filter_field arg.
// 2. Args for ancestor fields must precede descendants.
// 3. Each arg must have opposite `include` compared to the last preceding
//    ancestor field.
//
// See (broken link) for more detail.</font>
class ResolvedFilterField : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FILTER_FIELD;

<font color="brown">  // The proto to modify.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // The list of field paths to include or exclude. The path starts
  // from the proto type of &lt;expr&gt;.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedFilterFieldArg">ResolvedFilterFieldArg</a>&gt;&gt;&amp; filter_field_arg_list() const;
  int filter_field_arg_list_size() const;
  const <a href="#ResolvedFilterFieldArg">ResolvedFilterFieldArg</a>* filter_field_arg_list(int i) const;
};
</code></pre></p>

### ResolvedFunctionCallBase
<a id="ResolvedFunctionCallBase"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Common base class for scalar and aggregate function calls.
//
// &lt;argument_list&gt; contains a list of arguments of type ResolvedExpr.
//
// &lt;generic_argument_list&gt; contains an alternative list of generic arguments.
// This is used for function calls that accept non-expression arguments (i.e.
// arguments that aren&#39;t part of the type system, like lambdas).
//
// If all arguments of this function call are ResolvedExprs, &lt;argument_list&gt;
// is used. If any of the argument is not a ResolvedExpr,
// &lt;generic_argument_list&gt; will be used. Only one of &lt;argument_list&gt; or
// &lt;generic_argument_list&gt; can be non-empty.</font>
class ResolvedFunctionCallBase : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  typedef ResolvedFunctionCallBaseEnums::ErrorMode ErrorMode;
  static const ErrorMode DEFAULT_ERROR_MODE = ResolvedFunctionCallBaseEnums::DEFAULT_ERROR_MODE;
  static const ErrorMode SAFE_ERROR_MODE = ResolvedFunctionCallBaseEnums::SAFE_ERROR_MODE;

<font color="brown">  // The matching Function from the Catalog.</font>
  const Function* function() const;

<font color="brown">  // The concrete FunctionSignature reflecting the matching Function
  // signature and the function&#39;s resolved input &lt;argument_list&gt;.
  // The function has the mode AGGREGATE iff it is an aggregate
  // function, in which case this node must be either
  // ResolvedAggregateFunctionCall or ResolvedAnalyticFunctionCall.</font>
  const FunctionSignature&amp; signature() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; argument_list() const;
  int argument_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* argument_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedFunctionArgument">ResolvedFunctionArgument</a>&gt;&gt;&amp; generic_argument_list() const;
  int generic_argument_list_size() const;
  const <a href="#ResolvedFunctionArgument">ResolvedFunctionArgument</a>* generic_argument_list(int i) const;

<font color="brown">  // If error_mode=SAFE_ERROR_MODE, and if this function call returns a
  // semantic error (based on input data, not transient server
  // problems), return NULL instead of an error. This is used for
  // functions called using SAFE, as in SAFE.FUNCTION(...).</font>
  ErrorMode error_mode() const;

<font color="brown">  // Function call hints.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; hint_list() const;
  int hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* hint_list(int i) const;
};
</code></pre></p>

### ResolvedFunctionCall
<a id="ResolvedFunctionCall"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A regular function call.  The signature will always have mode SCALAR.
// Most scalar expressions show up as FunctionCalls using builtin signatures.</font>
class ResolvedFunctionCall : public <a href="#ResolvedFunctionCallBase">ResolvedFunctionCallBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FUNCTION_CALL;

<font color="brown">  // This contains optional custom information about a particular
  // function call.
  //
  // If some Function subclass requires computing additional
  // information at resolving time, that extra information can be
  // stored as a subclass of ResolvedFunctionCallInfo here.
  // For example, TemplatedSQLFunction stores the resolved template
  // body here as a TemplatedSQLFunctionCall.
  //
  // This field is ignorable because for most types of function calls,
  // there is no extra information to consider besides the arguments
  // and other fields from ResolvedFunctionCallBase.</font>
  const std::shared_ptr&lt;<a href="#ResolvedFunctionCallInfo">ResolvedFunctionCallInfo</a>&gt;&amp; function_call_info() const;
};
</code></pre></p>

### ResolvedNonScalarFunctionCallBase
<a id="ResolvedNonScalarFunctionCallBase"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Common base class for scalar and aggregate function calls.</font>
class ResolvedNonScalarFunctionCallBase : public <a href="#ResolvedFunctionCallBase">ResolvedFunctionCallBase</a> {
  typedef ResolvedNonScalarFunctionCallBaseEnums::NullHandlingModifier NullHandlingModifier;
  static const NullHandlingModifier DEFAULT_NULL_HANDLING = ResolvedNonScalarFunctionCallBaseEnums::DEFAULT_NULL_HANDLING;
  static const NullHandlingModifier IGNORE_NULLS = ResolvedNonScalarFunctionCallBaseEnums::IGNORE_NULLS;
  static const NullHandlingModifier RESPECT_NULLS = ResolvedNonScalarFunctionCallBaseEnums::RESPECT_NULLS;

<font color="brown">  // Apply DISTINCT to the stream of input values before calling
  // function.</font>
  bool distinct() const;

<font color="brown">  // Apply IGNORE/RESPECT NULLS filtering to the stream of input
  // values.</font>
  NullHandlingModifier null_handling_modifier() const;

<font color="brown">  // Holds a table subquery defined in WITH GROUP_ROWS(...) that is
  // evaluated over the input rows of a ResolvedAggregateScan
  // corresponding to the current group. The function itself is
  // evaluated over the rows returned from the subquery.
  //
  // The subquery should refer to a special TVF GROUP_ROWS(), which
  // resolves as ResolvedGroupRowsScan. The subquery will be run for
  // each group produced by ResolvedAggregateScan.
  //
  // GROUP_ROWS() produces a row for each source row in the
  // ResolvedAggregateScan&#39;s input that matches current group.
  //
  // The subquery cannot reference any ResolvedColumns from the outer
  // query except what comes in via &lt;with_group_rows_parameter_list&gt;,
  // and GROUP_ROWS().
  //
  // The subquery can return more than one column, and these columns
  // can be referenced by the function.
  //
  // The subquery can be correlated. In this case the
  // &lt;with_group_rows_parameter_list&gt; gives the set of ResolvedColumns
  // from outside the subquery that are used inside. The subuery cannot
  // refer to correlated columns that are used as aggregation input in
  // the immediate outer query. The same rules apply to
  // &lt;with_group_rows_parameter_list&gt; as in ResolvedSubqueryExpr.</font>
  const <a href="#ResolvedScan">ResolvedScan</a>* with_group_rows_subquery() const;

<font color="brown">  // Correlated parameters to &lt;with_group_rows_subquery&gt;</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; with_group_rows_parameter_list() const;
  int with_group_rows_parameter_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* with_group_rows_parameter_list(int i) const;
};
</code></pre></p>

### ResolvedAggregateFunctionCall
<a id="ResolvedAggregateFunctionCall"></a>

<p><pre><code class="lang-c++">
<font color="brown">// An aggregate function call.  The signature always has mode AGGREGATE.
// This node only ever shows up as the outer function call in a
// ResolvedAggregateScan::aggregate_list.</font>
class ResolvedAggregateFunctionCall : public <a href="#ResolvedNonScalarFunctionCallBase">ResolvedNonScalarFunctionCallBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_AGGREGATE_FUNCTION_CALL;

<font color="brown">  // Apply HAVING MAX/MIN filtering to the stream of input values.</font>
  const <a href="#ResolvedAggregateHavingModifier">ResolvedAggregateHavingModifier</a>* having_modifier() const;

<font color="brown">  // Apply ordering to the stream of input values before calling
  // function.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>&gt;&gt;&amp; order_by_item_list() const;
  int order_by_item_list_size() const;
  const <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>* order_by_item_list(int i) const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* limit() const;

<font color="brown">  // This contains optional custom information about a particular
  // function call. Functions may introduce subclasses of this class to
  // add custom information as needed on a per-function basis.
  //
  // This field is ignorable because for most types of function calls,
  // there is no extra information to consider besides the arguments
  // and other fields from ResolvedFunctionCallBase. However, for
  // example, the TemplateSQLFunction in
  // zetasql/public/templated_sql_function.h defines the
  // TemplatedSQLFunctionCall subclass which includes the
  // fully-resolved function body in context of the actual concrete
  // types of the arguments provided to the function call.</font>
  const std::shared_ptr&lt;<a href="#ResolvedFunctionCallInfo">ResolvedFunctionCallInfo</a>&gt;&amp; function_call_info() const;
};
</code></pre></p>

### ResolvedAnalyticFunctionCall
<a id="ResolvedAnalyticFunctionCall"></a>

<p><pre><code class="lang-c++">
<font color="brown">// An analytic function call. The mode of the function is either AGGREGATE
// or ANALYTIC. This node only ever shows up as a function call in a
// ResolvedAnalyticFunctionGroup::analytic_function_list. Its associated
// window is not under this node but as a sibling of its parent node.
//
// &lt;window_frame&gt; can be NULL.</font>
class ResolvedAnalyticFunctionCall : public <a href="#ResolvedNonScalarFunctionCallBase">ResolvedNonScalarFunctionCallBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ANALYTIC_FUNCTION_CALL;

  const <a href="#ResolvedWindowFrame">ResolvedWindowFrame</a>* window_frame() const;
};
</code></pre></p>

### ResolvedExtendedCastElement
<a id="ResolvedExtendedCastElement"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Describes a leaf extended cast of ResolvedExtendedCast. See the comment
// for element_list field of ResolvedExtendedCast for more details.</font>
class ResolvedExtendedCastElement : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXTENDED_CAST_ELEMENT;

  const Type* from_type() const;

  const Type* to_type() const;

  const Function* function() const;
};
</code></pre></p>

### ResolvedExtendedCast
<a id="ResolvedExtendedCast"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Describes overall cast operation between two values where at least one
// value&#39;s type is or contains an extended type (e.g. on a struct field).</font>
class ResolvedExtendedCast : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXTENDED_CAST;

<font color="brown">  // Stores the list of leaf extended casts required as elements of
  // this cast.  Each element is a cast where at least one of the input
  // or output is an extended type. For structs or arrays, the elements
  // will be casts for the field or element types. For structs, there
  // can be multiple cast elements (one for each distinct pair of field
  // types). For non-struct types, there will be just a single element.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExtendedCastElement">ResolvedExtendedCastElement</a>&gt;&gt;&amp; element_list() const;
  int element_list_size() const;
  const <a href="#ResolvedExtendedCastElement">ResolvedExtendedCastElement</a>* element_list(int i) const;
};
</code></pre></p>

### ResolvedCast
<a id="ResolvedCast"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A cast expression, casting the result of an input expression to the
// target Type.
//
// Valid casts are defined in the CastHashMap (see cast.cc), which identifies
// valid from-Type, to-Type pairs.  Consumers can access it through
// GetZetaSQLCasts().</font>
class ResolvedCast : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CAST;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // Whether to return NULL if the cast fails. This is set to true for
  // SAFE_CAST.</font>
  bool return_null_on_error() const;

<font color="brown">  // If at least one of types involved in this cast is or contains an
  // extended (TYPE_EXTENDED) type, this field contains information
  // necessary to execute this cast.</font>
  const <a href="#ResolvedExtendedCast">ResolvedExtendedCast</a>* extended_cast() const;

<font color="brown">  // The format string specified by the optional FORMAT clause. It is
  // nullptr when the clause does not exist.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* format() const;

<font color="brown">  // The time zone expression by the optional AT TIME ZONE clause. It
  // is nullptr when the clause does not exist.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* time_zone() const;

<font color="brown">  // Contains the TypeParametersProto, which stores the type parameters
  // if specified in a cast. If there are no type parameters, this
  // proto will be empty.
  //
  // If type parameters are specified, the result of the cast should
  // conform to the type parameters. Engines are expected to enforce
  // type parameter constraints by erroring out or truncating the cast
  // result, depending on the output type.
  //
  // For example:
  //   CAST(&#34;ABC&#34; as STRING(2)) should error out
  //   CAST(1234 as NUMERIC(2)) should error out
  //   CAST(1.234 as NUMERIC(2,1)) should return a NumericValue of 1.2
  //
  // See (broken link) for more details.</font>
  const TypeParameters&amp; type_parameters() const;
};
</code></pre></p>

### ResolvedMakeStruct
<a id="ResolvedMakeStruct"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Construct a struct value.  &lt;type&gt; is always a StructType.
// &lt;field_list&gt; matches 1:1 with the fields in &lt;type&gt; position-wise.
// Each field&#39;s type will match the corresponding field in &lt;type&gt;.</font>
class ResolvedMakeStruct : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MAKE_STRUCT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; field_list() const;
  int field_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* field_list(int i) const;
};
</code></pre></p>

### ResolvedMakeProto
<a id="ResolvedMakeProto"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Construct a proto value.  &lt;type&gt; is always a ProtoType.
// &lt;field_list&gt; is a vector of (FieldDescriptor, expr) pairs to write.
// &lt;field_list&gt; will contain all required fields, and no duplicate fields.</font>
class ResolvedMakeProto : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MAKE_PROTO;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedMakeProtoField">ResolvedMakeProtoField</a>&gt;&gt;&amp; field_list() const;
  int field_list_size() const;
  const <a href="#ResolvedMakeProtoField">ResolvedMakeProtoField</a>* field_list(int i) const;
};
</code></pre></p>

### ResolvedMakeProtoField
<a id="ResolvedMakeProtoField"></a>

<p><pre><code class="lang-c++">
<font color="brown">// One field assignment in a ResolvedMakeProto expression.
// The type of expr will match with the zetasql type of the proto field.
// The type will be an array iff the field is repeated.
//
// For NULL values of &lt;expr&gt;, the proto field should be cleared.
//
// If any value of &lt;expr&gt; cannot be written into the field, this query
// should fail.</font>
class ResolvedMakeProtoField : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MAKE_PROTO_FIELD;

  const google::protobuf::FieldDescriptor* field_descriptor() const;

<font color="brown">  // Provides the Format annotation that should be used when building
  // this field.  The annotation specifies both the ZetaSQL type and
  // the encoding format for this field.</font>
  FieldFormat::Format format() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;
};
</code></pre></p>

### ResolvedGetStructField
<a id="ResolvedGetStructField"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Get the field in position &lt;field_idx&gt; (0-based) from &lt;expr&gt;, which has a
// STRUCT type.</font>
class ResolvedGetStructField : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GET_STRUCT_FIELD;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

  int field_idx() const;
};
</code></pre></p>

### ResolvedGetProtoField
<a id="ResolvedGetProtoField"></a>

<p><pre><code class="lang-c++">
class ResolvedGetProtoField : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GET_PROTO_FIELD;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // The proto2 FieldDescriptor to extract.  This provides the tag
  // number and wire type.  Additional decoding may be necessary if any
  // of the other modifiers below are set.  Consumers should use those
  // ZetaSQL-computed modifiers rather than examining field
  // annotations directly.
  //
  // The field is an extension field iff
  // field_descriptor-&gt;is_extension() is true.  NOTE: The extended
  // descriptor&#39;s full_name must match the &lt;expr&gt;&#39;s type&#39;s full_name,
  // but may not be the same Descriptor. Extension FieldDescriptors may
  // come from a different DescriptorPool.
  //
  // The field is required if field_descriptor-&gt;is_required().  If the
  // field is required and not present, an error should result.</font>
  const google::protobuf::FieldDescriptor* field_descriptor() const;

<font color="brown">  // Default value to use when the proto field is not set. The default
  // may be NULL (e.g. for proto2 fields with a use_defaults=false
  // annotation).
  //
  // This will not be filled in (the Value will be uninitialized) if
  // get_has_bit is true, or the field is required.
  //
  // If field_descriptor-&gt;is_required() and the field is not present,
  // the engine should return an error.
  //
  // If the &lt;expr&gt; itself returns NULL, then extracting a field should
  // also return NULL, unless &lt;return_default_value_when_unset&gt; is
  // true. In that case, the default value is returned.
  //
  // TODO Make un-ignorable after clients migrate to start
  // using it.</font>
  const Value&amp; default_value() const;

<font color="brown">  // Indicates whether to return a bool indicating if a value was
  // present, rather than return the value (or NULL). Never set for
  // repeated fields. This field cannot be set if
  // &lt;return_default_value_when_unset&gt; is true, and vice versa.
  // Expression type will be BOOL.</font>
  bool get_has_bit() const;

<font color="brown">  // Provides the Format annotation that should be used when reading
  // this field.  The annotation specifies both the ZetaSQL type and
  // the encoding format for this field. This cannot be set when
  // get_has_bit is true.</font>
  FieldFormat::Format format() const;

<font color="brown">  // Indicates that the default value should be returned if &lt;expr&gt;
  // (the parent message) is NULL.  Note that this does *not* affect
  // the return value when the extracted field itself is unset, in
  // which case the return value depends on the extracted field&#39;s
  // annotations (e.g., use_field_defaults).
  //
  // This can only be set for non-message fields. If the field is a
  // proto2 field, then it must be annotated with
  // zetasql.use_defaults=true. This cannot be set when &lt;get_has_bit&gt;
  // is true or the field is required.</font>
  bool return_default_value_when_unset() const;
};
</code></pre></p>

### ResolvedGetJsonField
<a id="ResolvedGetJsonField"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Get the field &lt;field_name&gt; from &lt;expr&gt;, which has a JSON type.</font>
class ResolvedGetJsonField : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GET_JSON_FIELD;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

  const std::string&amp; field_name() const;
};
</code></pre></p>

### ResolvedFlatten
<a id="ResolvedFlatten"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Constructs an initial input ARRAY&lt;T&gt; from expr. For each get_field_list
// expr, we evaluate the expression once with each array input element and
// use the output as a new array of inputs for the next get_field_list expr.
// If the result of a single expr is an array, we add each element from that
// array as input to the next step instead of adding the array itself.
//
// The array elements are evaluated and kept in order. For example, if only
// expr is an array, the result will be equivalent to that array having the
// get_field_list evaluated on each array element retaining order.</font>
class ResolvedFlatten : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FLATTEN;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // List of &#39;get&#39; fields to evaluate in order (0 or more struct get
  // fields followed by 0 or more proto or json get fields) starting
  // from expr. Each get is evaluated N times where N is the number of
  // array elements from the previous get (or expr for the first
  // expression) generated.
  //
  // The &#39;get&#39; fields may either be a ResolvedGet*Field or an array
  // offset function around a ResolvedGet*Field.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; get_field_list() const;
  int get_field_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* get_field_list(int i) const;
};
</code></pre></p>

### ResolvedFlattenedArg
<a id="ResolvedFlattenedArg"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Argument for a child of ResolvedFlatten. This is a placeholder to indicate
// that it will be invoked once for each array element from ResolvedFlatten&#39;s
// expr or previous get_field_list entry.</font>
class ResolvedFlattenedArg : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FLATTENED_ARG;

};
</code></pre></p>

### ResolvedReplaceFieldItem
<a id="ResolvedReplaceFieldItem"></a>

<p><pre><code class="lang-c++">
<font color="brown">// An argument to the REPLACE_FIELDS() function which specifies a field path
// and a value that this field will be set to. The field path to be modified
// can be constructed through the &lt;struct_index_path&gt; and &lt;proto_field_path&gt;
// fields. These vectors correspond to field paths in a STRUCT and PROTO,
// respectively. At least one of these vectors must be non-empty.
//
// If only &lt;struct_index_path&gt; is non-empty, then the field path only
// references top-level and nested struct fields.
//
// If only &lt;proto_field_path&gt; is non-empty, then the field path only
// references top-level and nested message fields.
//
// If both &lt;struct_index_path&gt; and &lt;proto_field_path&gt; are non-empty, then the
// field path should be expanded starting with &lt;struct_index_path&gt;. The last
// field in &lt;struct_index_path&gt; will be the proto from which the first field
// in &lt;proto_field_path&gt; is extracted.
//
// &lt;expr&gt; and the field to be modified must be the same type.</font>
class ResolvedReplaceFieldItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_REPLACE_FIELD_ITEM;

<font color="brown">  // The value that the final field in &lt;proto_field_path&gt; will be set
  // to.
  //
  // If &lt;expr&gt; is NULL, the field will be unset. If &lt;proto_field_path&gt;
  // is a required field, the engine must return an error if it is set
  // to NULL.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // A vector of integers that denotes the path to a struct field that
  // will be modified. The integer values in this vector correspond to
  // field positions (0-based) in a STRUCT. If &lt;proto_field_path&gt;
  // is also non-empty, then the field corresponding to the last index
  // in this vector should be of proto type.</font>
  const std::vector&lt;int&gt;&amp; struct_index_path() const;
  int struct_index_path_size() const;
  int struct_index_path(int i) const;

<font color="brown">  // A vector of FieldDescriptors that denotes the path to a proto
  // field that will be modified. If &lt;struct_index_path&gt; is also
  // non-empty, then the first element in this vector should be a
  // subfield of the proto corresponding to the last element in
  // &lt;struct_index_path&gt;.</font>
  const std::vector&lt;const google::protobuf::FieldDescriptor*&gt;&amp; proto_field_path() const;
  int proto_field_path_size() const;
  const google::protobuf::FieldDescriptor* proto_field_path(int i) const;
};
</code></pre></p>

### ResolvedReplaceField
<a id="ResolvedReplaceField"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Represents a call to the REPLACE_FIELDS() function. This function
// can be used to copy a proto or struct, modify a few fields and
// output the resulting proto or struct. The SQL syntax for this
// function is REPLACE_FIELDS(&lt;expr&gt;, &lt;replace_field_item_list&gt;).
//
// See (broken link) for more detail.</font>
class ResolvedReplaceField : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_REPLACE_FIELD;

<font color="brown">  // The proto/struct to modify.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // The list of field paths to be modified along with their new
  // values.
  //
  // Engines must check at evaluation time that the modifications in
  // &lt;replace_field_item_list&gt; obey the following rules
  // regarding updating protos in ZetaSQL:
  // - Modifying a subfield of a NULL-valued proto-valued field is an
  //   error.
  // - Clearing a required field or subfield is an error.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedReplaceFieldItem">ResolvedReplaceFieldItem</a>&gt;&gt;&amp; replace_field_item_list() const;
  int replace_field_item_list_size() const;
  const <a href="#ResolvedReplaceFieldItem">ResolvedReplaceFieldItem</a>* replace_field_item_list(int i) const;
};
</code></pre></p>

### ResolvedSubqueryExpr
<a id="ResolvedSubqueryExpr"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A subquery in an expression (not a FROM clause).  The subquery runs
// in the context of a single input row and produces a single output value.
//
// Correlated subqueries can be thought of like functions, with a parameter
// list.  The &lt;parameter_list&gt; gives the set of ResolvedColumns from outside
// the subquery that are used inside.
//
// Inside the subquery, the only allowed references to values outside the
// subquery are to the named ColumnRefs listed in &lt;parameter_list&gt;.
// Any reference to one of these parameters will be represented as a
// ResolvedColumnRef with &lt;is_correlated&gt; set to true.
//
// These parameters are only visible through one level of expression
// subquery.  An expression subquery inside an expression has to list
// parameters again if parameters from the outer query are passed down
// further.  (This does not apply for table subqueries inside an expression
// subquery.  Table subqueries are never indicated in the resolved AST, so
// Scan nodes inside an expression query may have come from a nested table
// subquery, and they can still reference the expression subquery&#39;s
// parameters.)
//
// An empty &lt;parameter_list&gt; means that the subquery is uncorrelated.  It is
// permissable to run an uncorrelated subquery only once and reuse the result.
// TODO Do we want to specify semantics more firmly here?
//
// The semantics vary based on SubqueryType:
//   SCALAR
//     Usage: ( &lt;subquery&gt; )
//     If the subquery produces zero rows, the output value is NULL.
//     If the subquery produces exactly one row, that row is the output value.
//     If the subquery produces more than one row, raise a runtime error.
//
//   ARRAY
//     Usage: ARRAY( &lt;subquery&gt; )
//     The subquery produces an array value with zero or more rows, with
//     one array element per subquery row produced.
//
//   EXISTS
//     Usage: EXISTS( &lt;subquery&gt; )
//     The output type is always bool.  The result is true if the subquery
//     produces at least one row, and false otherwise.
//
//   IN
//     Usage: &lt;in_expr&gt; [NOT] IN ( &lt;subquery&gt; )
//     The output type is always bool.  The result is true when &lt;in_expr&gt; is
//     equal to at least one row, and false otherwise.  The &lt;subquery&gt; row
//     contains only one column, and the types of &lt;in_expr&gt; and the
//     subquery column must exactly match a built-in signature for the
//     &#39;$equals&#39; comparison function (they must be the same type or one
//     must be INT64 and the other UINT64).  NOT will be expressed as a $not
//     FunctionCall wrapping this SubqueryExpr.
//
// The subquery for a SCALAR or ARRAY or IN subquery must have exactly one
// output column.
// The output type for a SCALAR or ARRAY subquery is that column&#39;s type or
// an array of that column&#39;s type.  (The subquery scan may include a Project
// with a MakeStruct or MakeProto expression to construct a single value
// from multiple columns.)</font>
class ResolvedSubqueryExpr : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SUBQUERY_EXPR;

  typedef ResolvedSubqueryExprEnums::SubqueryType SubqueryType;
  static const SubqueryType SCALAR = ResolvedSubqueryExprEnums::SCALAR;
  static const SubqueryType ARRAY = ResolvedSubqueryExprEnums::ARRAY;
  static const SubqueryType EXISTS = ResolvedSubqueryExprEnums::EXISTS;
  static const SubqueryType IN = ResolvedSubqueryExprEnums::IN;

  SubqueryType subquery_type() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; parameter_list() const;
  int parameter_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* parameter_list(int i) const;

<font color="brown">  // Field is only populated for subquery of type IN.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* in_expr() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* subquery() const;

<font color="brown">  // Note: Hints currently happen only for EXISTS or IN subquery but
  // not for ARRAY or SCALAR subquery.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; hint_list() const;
  int hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* hint_list(int i) const;
};
</code></pre></p>

### ResolvedScan
<a id="ResolvedScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Common superclass for all Scans, which are nodes that produce rows
// (e.g. scans, joins, table subqueries).  A query&#39;s FROM clause is
// represented as a single Scan that composes all input sources into
// a single row stream.
//
// Each Scan has a &lt;column_list&gt; that says what columns are produced.
// The Scan logically produces a stream of output rows, where each row
// has exactly these columns.
//
// Each Scan may have an attached &lt;hint_list&gt;, storing each hint as
// a ResolvedOption.
//
// If &lt;is_ordered&gt; is true, this Scan produces an ordered output, either
// by generating order itself (OrderByScan) or by preserving the order
// of its single input scan (LimitOffsetScan, ProjectScan, or WithScan).</font>
class ResolvedScan : public <a href="#ResolvedNode">ResolvedNode</a> {
  bool IsScan() const final { return true; }

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; column_list() const;
  int column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> column_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; hint_list() const;
  int hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* hint_list(int i) const;

  bool is_ordered() const;
};
</code></pre></p>

### ResolvedModel
<a id="ResolvedModel"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Represents a machine learning model as a TVF argument.
// &lt;model&gt; is the machine learning model object known to the resolver
// (usually through the catalog).</font>
class ResolvedModel : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MODEL;

  const Model* model() const;
};
</code></pre></p>

### ResolvedConnection
<a id="ResolvedConnection"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Represents a connection object as a TVF argument.
// &lt;connection&gt; is the connection object encapsulated metadata to connect to
// an external data source.</font>
class ResolvedConnection : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CONNECTION;

  const Connection* connection() const;
};
</code></pre></p>

### ResolvedDescriptor
<a id="ResolvedDescriptor"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Represents a descriptor object as a TVF argument.
// A descriptor is basically a list of unresolved column names, written
//   DESCRIPTOR(column1, column2)
//
// &lt;descriptor_column_name_list&gt; contains the column names.
//
// If FunctionArgumentTypeOptions.get_resolve_descriptor_names_table_offset()
// is true, then &lt;descriptor_column_list&gt; contains resolved columns from
// the sibling ResolvedFunctionArgument of scan type, and will match
// positionally with &lt;descriptor_column_name_list&gt;.</font>
class ResolvedDescriptor : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DESCRIPTOR;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; descriptor_column_list() const;
  int descriptor_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> descriptor_column_list(int i) const;

  const std::vector&lt;std::string&gt;&amp; descriptor_column_name_list() const;
  int descriptor_column_name_list_size() const;
  std::string descriptor_column_name_list(int i) const;
};
</code></pre></p>

### ResolvedSingleRowScan
<a id="ResolvedSingleRowScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Scan that produces a single row with no columns.  Used for queries without
// a FROM clause, where all output comes from the select list.</font>
class ResolvedSingleRowScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SINGLE_ROW_SCAN;

};
</code></pre></p>

### ResolvedTableScan
<a id="ResolvedTableScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Scan a Table.
// The &lt;column_list&gt;[i] should be matched to a Table column by
// &lt;table&gt;.GetColumn(&lt;column_index_list&gt;[i]).
//
// If AnalyzerOptions::prune_unused_columns is true, the &lt;column_list&gt; and
// &lt;column_index_list&gt; will include only columns that were referenced
// in the user query. (SELECT * counts as referencing all columns.)
// This column_list can then be used for column-level ACL checking on tables.
// Pruning has no effect on value tables (the value is never pruned).
//
// for_system_time_expr when non NULL resolves to TIMESTAMP used in
// FOR SYSTEM_TIME AS OF clause. The expression is expected to be constant
// and no columns are visible to it.
//
// &lt;column_index_list&gt; This list matches 1-1 with the &lt;column_list&gt;, and
// identifies the ordinal of the corresponding column in the &lt;table&gt;&#39;s
// column list.
//
// If provided, &lt;alias&gt; refers to an explicit alias which was used to
// reference a Table in the user query. If the Table was given an implicitly
// generated alias, then defaults to &#34;&#34;.
//
// TODO: Enforce &lt;column_index_list&gt; in the constructor arg list. For
// historical reasons, some clients match &lt;column_list&gt; to Table columns by
// ResolvedColumn name. This violates the ResolvedColumn contract, which
// explicitly states that the ResolvedColumn name has no semantic meaning.
// All code building a ResolvedTableScan should always
// set_column_index_list() immediately after construction.</font>
class ResolvedTableScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_TABLE_SCAN;

  const Table* table() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* for_system_time_expr() const;

  const std::vector&lt;int&gt;&amp; column_index_list() const;
  int column_index_list_size() const;
  int column_index_list(int i) const;

  const std::string&amp; alias() const;
};
</code></pre></p>

### ResolvedJoinScan
<a id="ResolvedJoinScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A Scan that joins two input scans.
// The &lt;column_list&gt; will contain columns selected from the union
// of the input scan&#39;s &lt;column_lists&gt;.
// When the join is a LEFT/RIGHT/FULL join, ResolvedColumns that came from
// the non-joined side get NULL values.</font>
class ResolvedJoinScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_JOIN_SCAN;

  typedef ResolvedJoinScanEnums::JoinType JoinType;
  static const JoinType INNER = ResolvedJoinScanEnums::INNER;
  static const JoinType LEFT = ResolvedJoinScanEnums::LEFT;
  static const JoinType RIGHT = ResolvedJoinScanEnums::RIGHT;
  static const JoinType FULL = ResolvedJoinScanEnums::FULL;

  JoinType join_type() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* left_scan() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* right_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* join_expr() const;
};
</code></pre></p>

### ResolvedArrayScan
<a id="ResolvedArrayScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Scan an array value, produced from some expression.
//
// If input_scan is NULL, this scans the given array value and produces
// one row per array element.  This can occur when using UNNEST(expression).
//
// If &lt;input_scan&gt; is non-NULL, for each row in the stream produced by
// input_scan, this evaluates the expression &lt;array_expr&gt; (which must return
// an array type) and then produces a stream with one row per array element.
//
// If &lt;join_expr&gt; is non-NULL, then this condition is evaluated as an ON
// clause for the array join.  The named column produced in &lt;array_expr&gt;
// may be used inside &lt;join_expr&gt;.
//
// If the array is empty (after evaluating &lt;join_expr&gt;), then
// 1. If &lt;is_outer&gt; is false, the scan produces zero rows.
// 2. If &lt;is_outer&gt; is true, the scan produces one row with a NULL value for
//    the &lt;element_column&gt;.
//
// &lt;element_column&gt; is the new column produced by this scan that stores the
// array element value for each row.
//
// If present, &lt;array_offset_column&gt; defines the column produced by this
// scan that stores the array offset (0-based) for the corresponding
// &lt;element_column&gt;.
//
// This node&#39;s column_list can have columns from input_scan, &lt;element_column&gt;
// and &lt;array_offset_column&gt;.</font>
class ResolvedArrayScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ARRAY_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* array_expr() const;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; element_column() const;

  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* array_offset_column() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* join_expr() const;

  bool is_outer() const;
};
</code></pre></p>

### ResolvedColumnHolder
<a id="ResolvedColumnHolder"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This wrapper is used for an optional ResolvedColumn inside another node.</font>
class ResolvedColumnHolder : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_COLUMN_HOLDER;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const;
};
</code></pre></p>

### ResolvedFilterScan
<a id="ResolvedFilterScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Scan rows from input_scan, and emit all rows where filter_expr
// evaluates to true.  filter_expr is always of type bool.
// This node&#39;s column_list will be a subset of input_scan&#39;s column_list.</font>
class ResolvedFilterScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FILTER_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* filter_expr() const;
};
</code></pre></p>

### ResolvedGroupingSet
<a id="ResolvedGroupingSet"></a>

<p><pre><code class="lang-c++">
<font color="brown">// List of group by columns that form a grouping set.
//
// Columns must come from group_by_list in ResolvedAggregateScan.
// group_by_column_list will not contain any duplicates. There may be more
// than one ResolvedGroupingSet in the ResolvedAggregateScan with the same
// columns, however.</font>
class ResolvedGroupingSet : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GROUPING_SET;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; group_by_column_list() const;
  int group_by_column_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* group_by_column_list(int i) const;
};
</code></pre></p>

### ResolvedAggregateScanBase
<a id="ResolvedAggregateScanBase"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Base class for aggregation scans. Apply aggregation to rows produced from
// input_scan, and output aggregated rows.
//
// Group by keys in &lt;group_by_list&gt;.  If &lt;group_by_list&gt; is empty,
// aggregate all input rows into one output row.
//
// Compute all aggregations in &lt;aggregate_list&gt;.  All expressions in
// &lt;aggregate_list&gt; have a ResolvedAggregateFunctionCall with mode
// Function::AGGREGATE as their outermost node.
//
// The output &lt;column_list&gt; contains only columns produced from
// &lt;group_by_list&gt; and &lt;aggregate_list&gt;.  No other columns are visible after
// aggregation.</font>
class ResolvedAggregateScanBase : public <a href="#ResolvedScan">ResolvedScan</a> {
  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; group_by_list() const;
  int group_by_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* group_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; aggregate_list() const;
  int aggregate_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* aggregate_list(int i) const;
};
</code></pre></p>

### ResolvedAggregateScan
<a id="ResolvedAggregateScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Apply aggregation to rows produced from input_scan, and output aggregated
// rows.
//
// For each item in &lt;grouping_set_list&gt;, output additional rows computing the
// same &lt;aggregate_list&gt; over the input rows using a particular grouping set.
// The aggregation input values, including &lt;input_scan&gt;, computed columns in
// &lt;group_by_list&gt;, and aggregate function arguments in &lt;aggregate_list&gt;,
// should be computed just once and then reused as aggregation input for each
// grouping set. (This ensures that ROLLUP rows have correct totals, even
// with non-stable functions in the input.) For each grouping set, the
// &lt;group_by_list&gt; elements not included in the &lt;group_by_column_list&gt; are
// replaced with NULL.
//
// &lt;rollup_column_list&gt; is the original list of columns from
// GROUP BY ROLLUP(...), if there was a ROLLUP clause, and is used only for
// rebuilding equivalent SQL for the resolved AST. Engines should refer to
// &lt;grouping_set_list&gt; rather than &lt;rollup_column_list&gt;.</font>
class ResolvedAggregateScan : public <a href="#ResolvedAggregateScanBase">ResolvedAggregateScanBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_AGGREGATE_SCAN;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGroupingSet">ResolvedGroupingSet</a>&gt;&gt;&amp; grouping_set_list() const;
  int grouping_set_list_size() const;
  const <a href="#ResolvedGroupingSet">ResolvedGroupingSet</a>* grouping_set_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; rollup_column_list() const;
  int rollup_column_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* rollup_column_list(int i) const;
};
</code></pre></p>

### ResolvedAnonymizedAggregateScan
<a id="ResolvedAnonymizedAggregateScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Apply differentially private aggregation (anonymization) to rows produced
// from input_scan, and output anonymized rows.
// Spec: (broken link)
//
// &lt;k_threshold_expr&gt; when non-null, points to a function call in
// the &lt;aggregate_list&gt; and adds a filter that acts like:
//   HAVING &lt;k_threshold_expr&gt; &gt;= &lt;implementation-defined k-threshold&gt;
// omitting any rows that would not pass this condition.
// TODO: Update this comment after splitting the rewriter out
// into a separate stage.
//
// &lt;anonymization_option_list&gt; provides user-specified options, and
// requires that option names are one of: delta, epsilon, kappa, or
// k_threshold.</font>
class ResolvedAnonymizedAggregateScan : public <a href="#ResolvedAggregateScanBase">ResolvedAggregateScanBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ANONYMIZED_AGGREGATE_SCAN;

  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* k_threshold_expr() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; anonymization_option_list() const;
  int anonymization_option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* anonymization_option_list(int i) const;
};
</code></pre></p>

### ResolvedSetOperationItem
<a id="ResolvedSetOperationItem"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This is one input item in a ResolvedSetOperation.
// The &lt;output_column_list&gt; matches 1:1 with the ResolvedSetOperation&#39;s
// &lt;column_list&gt; and specifies how columns from &lt;scan&gt; map to output columns.
// Each column from &lt;scan&gt; can map to zero or more output columns.</font>
class ResolvedSetOperationItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SET_OPERATION_ITEM;

  const <a href="#ResolvedScan">ResolvedScan</a>* scan() const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> output_column_list(int i) const;
};
</code></pre></p>

### ResolvedSetOperationScan
<a id="ResolvedSetOperationScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Apply a set operation (specified by &lt;op_type&gt;) on two or more input scans.
//
// &lt;scan_list&gt; will have at least two elements.
//
// &lt;column_list&gt; is a set of new ResolvedColumns created by this scan.
// Each input ResolvedSetOperationItem has an &lt;output_column_list&gt; which
// matches 1:1 with &lt;column_list&gt; and specifies how the input &lt;scan&gt;&#39;s
// columns map into the final &lt;column_list&gt;.
//
// - Results of {UNION, INTERSECT, EXCEPT} ALL can include duplicate rows.
//   More precisely, with two input scans, if a given row R appears exactly
//   m times in first input and n times in second input (m &gt;= 0, n &gt;= 0):
//   For UNION ALL, R will appear exactly m + n times in the result.
//   For INTERSECT ALL, R will appear exactly min(m, n) in the result.
//   For EXCEPT ALL, R will appear exactly max(m - n, 0) in the result.
//
// - Results of {UNION, INTERSECT, EXCEPT} DISTINCT cannot contain any
//   duplicate rows. For UNION and INTERSECT, the DISTINCT is computed
//   after the result above is computed.  For EXCEPT DISTINCT, row R will
//   appear once in the output if m &gt; 0 and n = 0.
//
// - For n (&gt;2) input scans, the above operations generalize so the output is
//   the same as if the inputs were combined incrementally from left to right.</font>
class ResolvedSetOperationScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SET_OPERATION_SCAN;

  typedef ResolvedSetOperationScanEnums::SetOperationType SetOperationType;
  static const SetOperationType UNION_ALL = ResolvedSetOperationScanEnums::UNION_ALL;
  static const SetOperationType UNION_DISTINCT = ResolvedSetOperationScanEnums::UNION_DISTINCT;
  static const SetOperationType INTERSECT_ALL = ResolvedSetOperationScanEnums::INTERSECT_ALL;
  static const SetOperationType INTERSECT_DISTINCT = ResolvedSetOperationScanEnums::INTERSECT_DISTINCT;
  static const SetOperationType EXCEPT_ALL = ResolvedSetOperationScanEnums::EXCEPT_ALL;
  static const SetOperationType EXCEPT_DISTINCT = ResolvedSetOperationScanEnums::EXCEPT_DISTINCT;

  SetOperationType op_type() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedSetOperationItem">ResolvedSetOperationItem</a>&gt;&gt;&amp; input_item_list() const;
  int input_item_list_size() const;
  const <a href="#ResolvedSetOperationItem">ResolvedSetOperationItem</a>* input_item_list(int i) const;
};
</code></pre></p>

### ResolvedOrderByScan
<a id="ResolvedOrderByScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Apply ordering to rows produced from input_scan, and output ordered
// rows.
//
// The &lt;order_by_item_list&gt; must not be empty.  Each element identifies
// a sort column and indicates direction (ascending or descending).
//
// Order Preservation:
//   A ResolvedScan produces an ordered output if it has &lt;is_ordered&gt;=true.
//   If &lt;is_ordered&gt;=false, the scan may discard order.  This can happen
//   even for a ResolvedOrderByScan, if it is the top-level scan in a
//   subquery (which discards order).
//
// The following Scan nodes may have &lt;is_ordered&gt;=true, producing or
// propagating an ordering:
//   * ResolvedOrderByScan
//   * ResolvedLimitOffsetScan
//   * ResolvedProjectScan
//   * ResolvedWithScan
// Other Scan nodes will always discard ordering.</font>
class ResolvedOrderByScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ORDER_BY_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>&gt;&gt;&amp; order_by_item_list() const;
  int order_by_item_list_size() const;
  const <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>* order_by_item_list(int i) const;
};
</code></pre></p>

### ResolvedLimitOffsetScan
<a id="ResolvedLimitOffsetScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Apply a LIMIT and optional OFFSET to the rows from input_scan. Emit all
// rows after OFFSET rows have been scanned and up to LIMIT total rows
// emitted. The offset is the number of rows to skip.
// E.g., OFFSET 1 means to skip one row, so the first row emitted will be the
// second ROW, provided the LIMIT is greater than zero.
//
// The arguments to LIMIT &lt;int64&gt; OFFSET &lt;int64&gt; must be non-negative
// integer literals or (possibly casted) query parameters.  Query
// parameter values must be checked at run-time by ZetaSQL compliant
// backend systems.
//
// OFFSET is optional and the absence of OFFSET implies OFFSET 0.</font>
class ResolvedLimitOffsetScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_LIMIT_OFFSET_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* limit() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* offset() const;
};
</code></pre></p>

### ResolvedWithRefScan
<a id="ResolvedWithRefScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Scan the subquery defined in a WITH statement.
// See ResolvedWithScan for more detail.
// The column_list produced here will match 1:1 with the column_list produced
// by the referenced subquery and will given a new unique name to each
// column produced for this scan.</font>
class ResolvedWithRefScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WITH_REF_SCAN;

  const std::string&amp; with_query_name() const;
};
</code></pre></p>

### ResolvedAnalyticScan
<a id="ResolvedAnalyticScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Apply analytic functions to rows produced from input_scan.
//
// The set of analytic functions are partitioned into a list of analytic
// function groups &lt;function_group_list&gt; by the window PARTITION BY and the
// window ORDER BY.
//
// The output &lt;column_list&gt; contains all columns from &lt;input_scan&gt;,
// one column per analytic function. It may also conain partitioning/ordering
// expression columns if they reference to select columns.</font>
class ResolvedAnalyticScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ANALYTIC_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>&gt;&gt;&amp; function_group_list() const;
  int function_group_list_size() const;
  const <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>* function_group_list(int i) const;
};
</code></pre></p>

### ResolvedSampleScan
<a id="ResolvedSampleScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Samples rows from &lt;input_scan&gt;.
// Specs: (broken link)
// Specs for WITH WEIGHT and PARTITION BY: (broken link)
//
// &lt;method&gt; is the identifier for the sampling algorithm and will always be
// in lowercase.
// For example BERNOULLI, RESERVOIR, SYSTEM. Engines can also support their
// own implementation-specific set of sampling algorithms.
//
// &lt;size&gt; and &lt;unit&gt; specifies the sample size.
// If &lt;unit&gt; is &#34;ROWS&#34;, &lt;size&gt; must be an &lt;int64&gt; and non-negative.
// If &lt;unit&gt; is &#34;PERCENT&#34;, &lt;size&gt; must either be a &lt;double&gt; or an &lt;int64&gt; and
// in the range [0, 100].
// &lt;size&gt; can only be a literal value or a (possibly casted) parameter.
//
// &lt;repeatable_argument&gt; is present if we had a REPEATABLE(&lt;argument&gt;) in the
// TABLESAMPLE clause and can only be a literal value or a (possibly
// casted) parameter.
//
// If present, &lt;weight_column&gt; defines the column produced by this scan that
// stores the scaling weight for the corresponding sampled row.
//
// &lt;partition_by_list&gt; can be empty. If &lt;partition_by_list&gt; is not empty,
// &lt;unit&gt; must be ROWS and &lt;method&gt; must be RESERVOIR.</font>
class ResolvedSampleScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SAMPLE_SCAN;

  typedef ResolvedSampleScanEnums::SampleUnit SampleUnit;
  static const SampleUnit ROWS = ResolvedSampleScanEnums::ROWS;
  static const SampleUnit PERCENT = ResolvedSampleScanEnums::PERCENT;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::string&amp; method() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* size() const;

  SampleUnit unit() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* repeatable_argument() const;

  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* weight_column() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; partition_by_list() const;
  int partition_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* partition_by_list(int i) const;
};
</code></pre></p>

### ResolvedComputedColumn
<a id="ResolvedComputedColumn"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This is used when an expression is computed and given a name (a new
// ResolvedColumn) that can be referenced elsewhere.  The new ResolvedColumn
// can appear in a column_list or in ResolvedColumnRefs in other expressions,
// when appropriate.  This node is not an expression itself - it is a
// container that holds an expression.</font>
class ResolvedComputedColumn : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_COMPUTED_COLUMN;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;
};
</code></pre></p>

### ResolvedOrderByItem
<a id="ResolvedOrderByItem"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents one column of an ORDER BY clause, with the requested
// ordering direction.
//
// &lt;collation_name&gt; is the ORDER BY COLLATE expression, and could be a string
// literal or query parameter.  &lt;collation_name&gt; could only be set when the
// FEATURE_V_1_1_ORDER_BY_COLLATE is enabled.
// See (broken link) for COLLATE clause.
// &lt;collation&gt; (only set when FEATURE_V_1_3_COLLATION_SUPPORT is enabled) is
// the derived collation to use.  It comes from the &lt;column_ref&gt; and COLLATE
// clause.  It is unset if COLLATE is present and set to a parameter.
// See (broken link) for general Collation Support.
// When both features are enabled, if &lt;collation_name&gt; is present and is
// - a parameter, then &lt;collation&gt; is empty
// - a non-parameter, then &lt;collation&gt; is set to the same collation
// An engine which supports both features could read the fields as:
//   If &lt;collation&gt; is set then use it, otherwise use &lt;collation_name&gt;, which
//   must be a query parameter if set.
//
// &lt;null_order&gt; indicates the ordering of NULL values relative to non-NULL
// values. NULLS_FIRST indicates that NULLS sort prior to non-NULL values,
// and NULLS_LAST indicates that NULLS sort after non-NULL values.</font>
class ResolvedOrderByItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ORDER_BY_ITEM;

  typedef ResolvedOrderByItemEnums::NullOrderMode NullOrderMode;
  static const NullOrderMode ORDER_UNSPECIFIED = ResolvedOrderByItemEnums::ORDER_UNSPECIFIED;
  static const NullOrderMode NULLS_FIRST = ResolvedOrderByItemEnums::NULLS_FIRST;
  static const NullOrderMode NULLS_LAST = ResolvedOrderByItemEnums::NULLS_LAST;

  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* column_ref() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* collation_name() const;

  bool is_descending() const;

  NullOrderMode null_order() const;

  const <a href="#ResolvedCollation">ResolvedCollation</a>&amp; collation() const;
};
</code></pre></p>

### ResolvedColumnAnnotations
<a id="ResolvedColumnAnnotations"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This is used in CREATE TABLE statements to provide column annotations
// such as NOT NULL, type parameters, and OPTIONS().
//
// This class is recursive. It mirrors the structure of the column type
// except that child_list might be truncated.
//
// For ARRAY:
//   If the element or its subfield has annotations, then child_list.size()
//   is 1, and child_list(0) stores the element annotations.
//   Otherwise child_list is empty.
// For STRUCT:
//   If the i-th field has annotations then child_list(i) stores the
//   field annotations.
//   Otherwise either child_list.size() &lt;= i or child_list(i) is trivial.
//   If none of the fields and none of their subfields has annotations, then
//   child_list is empty.
// For other types, child_list is empty.</font>
class ResolvedColumnAnnotations : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_COLUMN_ANNOTATIONS;

  // Get the full TypeParameters object for these annotations given a
  // type, including parameters on nested fields.
  zetasql_base::StatusOr<TypeParameters> GetFullTypeParameters(
      const Type* type) const;

  bool not_null() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnAnnotations">ResolvedColumnAnnotations</a>&gt;&gt;&amp; child_list() const;
  int child_list_size() const;
  const <a href="#ResolvedColumnAnnotations">ResolvedColumnAnnotations</a>* child_list(int i) const;

<font color="brown">  // child_list in &lt;type_parameters&gt; is not used in here.
  // Instead we use child_list of this node (ResolvedColumnAnnotations)
  // to store type parameters of subfields of STRUCT or ARRAY. Users
  // can access the full type parameters with child_list by calling
  // ResolvedColumnDefinition.getFullTypeParameters() function.</font>
  const TypeParameters&amp; type_parameters() const;
};
</code></pre></p>

### ResolvedGeneratedColumnInfo
<a id="ResolvedGeneratedColumnInfo"></a>

<p><pre><code class="lang-c++">
<font color="brown">// &lt;expression&gt; indicates the expression that defines the column. The type of
// the expression will always match the type of the column.
//   - The &lt;expression&gt; can contain ResolvedColumnRefs corresponding to
//   ResolvedColumnDefinition.&lt;column&gt; for any of the
//   ResolvedColumnDefinitions in the enclosing statement.
//   - The expression can never include a subquery.
//
// &lt;stored_mode&gt; is the mode of a generated column: Values are:
//   - &#39;NON_STORED&#39;: The &lt;expression&gt; must always be evaluated at read time.
//   - &#39;STORED&#39;: The &lt;expression&gt; should be pre-emptively computed at write
//        time (to save work at read time) and must not call any volatle
//        function (e.g. RAND).
//   - &#39;STORED_VOLATILE&#39;: The &lt;expression&gt; must be computed at write time and
//        may call volatile functions (e.g. RAND).
// See (broken link) and
// (broken link).</font>
class ResolvedGeneratedColumnInfo : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GENERATED_COLUMN_INFO;

  typedef ResolvedGeneratedColumnInfoEnums::StoredMode StoredMode;
  static const StoredMode NON_STORED = ResolvedGeneratedColumnInfoEnums::NON_STORED;
  static const StoredMode STORED = ResolvedGeneratedColumnInfoEnums::STORED;
  static const StoredMode STORED_VOLATILE = ResolvedGeneratedColumnInfoEnums::STORED_VOLATILE;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expression() const;

  StoredMode stored_mode() const;
};
</code></pre></p>

### ResolvedColumnDefinition
<a id="ResolvedColumnDefinition"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This is used in CREATE TABLE statements to provide an explicit column
// definition.
//
// if &lt;is_hidden&gt; is TRUE, then the column won&#39;t show up in SELECT * queries.
//
// if &lt;generated_column_info&gt; is non-NULL, then this column is a generated
// column.
//
// if &lt;default_expression&gt; is non-NULL, then this column contains a default
// value expression. The expression type should always match the column type.
//   - &lt;default_expression&gt; cannot contain any references to another column.
//   - &lt;default_expression&gt; cannot include a subquery, aggregation, or window
//     function.
//
// &lt;generated_column_info&gt; and &lt;default_expression&gt; cannot both be set at the
// same time.
//
// &lt;column&gt; defines an ID for the column, which may appear in expressions in
// the PARTITION BY, CLUSTER BY clause or &lt;generated_column_info&gt; if either
// is present.</font>
class ResolvedColumnDefinition : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_COLUMN_DEFINITION;

  // Get the full TypeParameters object for this column, including
  // parameters on nested fields. <annotations.type_parameters> includes
  // only parameters on the outermost type.
  zetasql_base::StatusOr<TypeParameters> GetFullTypeParameters() const;

  const std::string&amp; name() const;

  const Type* type() const;

  const <a href="#ResolvedColumnAnnotations">ResolvedColumnAnnotations</a>* annotations() const;

  bool is_hidden() const;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const;

  const <a href="#ResolvedGeneratedColumnInfo">ResolvedGeneratedColumnInfo</a>* generated_column_info() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* default_expression() const;
};
</code></pre></p>

### ResolvedPrimaryKey
<a id="ResolvedPrimaryKey"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents the PRIMARY KEY constraint on a table.
// &lt;column_offset_list&gt; provides the offsets of the column definitions that
//                      comprise the primary key. This is empty when a
//                      0-element primary key is defined.
//
// &lt;unenforced&gt; specifies whether the constraint is unenforced.</font>
class ResolvedPrimaryKey : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PRIMARY_KEY;

  const std::vector&lt;int&gt;&amp; column_offset_list() const;
  int column_offset_list_size() const;
  int column_offset_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  bool unenforced() const;
};
</code></pre></p>

### ResolvedConstraint
<a id="ResolvedConstraint"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Intermediate class for resolved constraints.</font>
class ResolvedConstraint : public <a href="#ResolvedArgument">ResolvedArgument</a> {
};
</code></pre></p>

### ResolvedForeignKey
<a id="ResolvedForeignKey"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents the FOREIGN KEY constraint on a table. It is of the form:
//
//   CONSTRAINT &lt;constraint_name&gt;
//   FOREIGN KEY &lt;referencing_column_offset_list&gt;
//   REFERENCES &lt;referenced_table&gt; &lt;referenced_column_offset_list&gt;
//   &lt;match_mode&gt;
//   &lt;update_action&gt;
//   &lt;delete_action&gt;
//   &lt;enforced&gt;
//   &lt;option_list&gt;
//
// &lt;constraint_name&gt; uniquely identifies the constraint.
//
// &lt;referencing_column_offset_list&gt; provides the offsets of the column
// definitions for the table defining the foreign key.
//
// &lt;referenced_table&gt; identifies the table this constraint references.
//
// &lt;referenced_column_offset_list&gt; provides the offsets of the column
// definitions for the table referenced by the foreign key.
//
// &lt;match_mode&gt; specifies how referencing keys with null values are handled.
//
// &lt;update_action&gt; specifies what action to take, if any, when a referenced
// value is updated.
//
// &lt;delete_action&gt; specifies what action to take, if any, when a row with a
// referenced values is deleted.
//
// &lt;enforced&gt; specifies whether or not the constraint is enforced.
//
// &lt;option_list&gt; for foreign key table constraints. Empty for foreign key
// column attributes (see instead ResolvedColumnAnnotations).
//
// &lt;referencing_column_list&gt; provides the names for the foreign key&#39;s
// referencing columns.</font>
class ResolvedForeignKey : public <a href="#ResolvedConstraint">ResolvedConstraint</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FOREIGN_KEY;

  typedef ResolvedForeignKeyEnums::MatchMode MatchMode;
  typedef ResolvedForeignKeyEnums::ActionOperation ActionOperation;
  static const MatchMode SIMPLE = ResolvedForeignKeyEnums::SIMPLE;
  static const MatchMode FULL = ResolvedForeignKeyEnums::FULL;
  static const MatchMode NOT_DISTINCT = ResolvedForeignKeyEnums::NOT_DISTINCT;
  static const ActionOperation NO_ACTION = ResolvedForeignKeyEnums::NO_ACTION;
  static const ActionOperation RESTRICT = ResolvedForeignKeyEnums::RESTRICT;
  static const ActionOperation CASCADE = ResolvedForeignKeyEnums::CASCADE;
  static const ActionOperation SET_NULL = ResolvedForeignKeyEnums::SET_NULL;

  const std::string&amp; constraint_name() const;

  const std::vector&lt;int&gt;&amp; referencing_column_offset_list() const;
  int referencing_column_offset_list_size() const;
  int referencing_column_offset_list(int i) const;

  const Table* referenced_table() const;

  const std::vector&lt;int&gt;&amp; referenced_column_offset_list() const;
  int referenced_column_offset_list_size() const;
  int referenced_column_offset_list(int i) const;

  MatchMode match_mode() const;

  ActionOperation update_action() const;

  ActionOperation delete_action() const;

  bool enforced() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::string&gt;&amp; referencing_column_list() const;
  int referencing_column_list_size() const;
  std::string referencing_column_list(int i) const;
};
</code></pre></p>

### ResolvedCheckConstraint
<a id="ResolvedCheckConstraint"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents the CHECK constraint on a table. It is of the form:
//
//   CONSTRAINT &lt;constraint_name&gt;
//   CHECK &lt;expression&gt;
//   &lt;enforced&gt;
//   &lt;option_list&gt;
//
// &lt;constraint_name&gt; uniquely identifies the constraint.
//
// &lt;expression&gt; defines a boolean expression to be evaluated when the row is
// updated. If the result is FALSE, update to the row is not allowed.
//
// &lt;enforced&gt; specifies whether or not the constraint is enforced.
//
// &lt;option_list&gt; list of options for check constraint.
//
// See (broken link).</font>
class ResolvedCheckConstraint : public <a href="#ResolvedConstraint">ResolvedConstraint</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CHECK_CONSTRAINT;

  const std::string&amp; constraint_name() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expression() const;

  bool enforced() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedOutputColumn
<a id="ResolvedOutputColumn"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This is used in ResolvedQueryStmt to provide a user-visible name
// for each output column.</font>
class ResolvedOutputColumn : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_OUTPUT_COLUMN;

  const std::string&amp; name() const;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const;
};
</code></pre></p>

### ResolvedProjectScan
<a id="ResolvedProjectScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A Project node computes new expression values, and possibly drops
// columns from the input Scan&#39;s column_list.
//
// Each entry in &lt;expr_list&gt; is a new column computed from an expression.
//
// The column_list can include any columns from input_scan, plus these
// newly computed columns.
//
// NOTE: This scan will propagate the is_ordered property of &lt;input_scan&gt;
// by default.  To make this scan unordered, call set_is_ordered(false).</font>
class ResolvedProjectScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PROJECT_SCAN;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; expr_list() const;
  int expr_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* expr_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;
};
</code></pre></p>

### ResolvedTVFScan
<a id="ResolvedTVFScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This scan represents a call to a table-valued function (TVF). Each TVF
// returns an entire output relation instead of a single scalar value. The
// enclosing query may refer to the TVF as if it were a table subquery. The
// TVF may accept scalar arguments and/or other input relations.
//
// Scalar arguments work the same way as arguments for non-table-valued
// functions: in the resolved AST, their types are equal to the required
// argument types specified in the function signature.
//
// The function signature may also include relation arguments, and any such
// relation argument may specify a required schema. If such a required schema
// is present, then in the resolved AST, the ResolvedScan for each relational
// ResolvedFunctionArgument is guaranteed to have the same number of columns
// as the required schema, and the provided columns match position-wise with
// the required columns. Each provided column has the same name and type as
// the corresponding required column.
//
// If AnalyzerOptions::prune_unused_columns is true, the &lt;column_list&gt; and
// &lt;column_index_list&gt; will include only columns that were referenced
// in the user query. (SELECT * counts as referencing all columns.)
// Pruning has no effect on value tables (the value is never pruned).
//
// &lt;column_list&gt; is a set of new ResolvedColumns created by this scan.
// The &lt;column_list&gt;[i] should be matched to the related TVFScan&#39;s output
// relation column by
// &lt;signature&gt;.result_schema().column(&lt;column_index_list&gt;[i]).
//
// &lt;tvf&gt; The TableValuedFunction entry that the catalog returned for this TVF
//       scan. Contains non-concrete function signatures which may include
//       arguments with templated types.
// &lt;signature&gt; The concrete table function signature for this TVF call,
//             including the types of all scalar arguments and the
//             number and types of columns of all table-valued
//             arguments. An engine may also subclass this object to
//             provide extra custom information and return an instance
//             of the subclass from the TableValuedFunction::Resolve
//             method.
// &lt;argument_list&gt; The vector of resolved concrete arguments for this TVF
//                 call, including the default values or NULLs injected for
//                 the omitted arguments (Note the NULL injection is a
//                 temporary solution to handle omitted named arguments. This
//                 is subject to change by upcoming CLs).
//
// &lt;column_index_list&gt; This list matches 1-1 with the &lt;column_list&gt;, and
// identifies the index of the corresponding column in the &lt;signature&gt;&#39;s
// result relation column list.
//
// &lt;alias&gt; The AS alias for the scan, or empty if none.
// &lt;function_call_signature&gt; The FunctionSignature object from the
//                           &lt;tvf-&gt;signatures()&gt; list that matched the
//                           current call. The TVFScan&#39;s
//                           &lt;FunctionSignature::ConcreteArgument&gt; list
//                           matches 1:1 to &lt;argument_list&gt;, while its
//                           &lt;FunctionSignature::arguments&gt; list still has
//                           the full argument list.
//                           The analyzer only sets this field when
//                           it could be ambiguous for an engine to figure
//                           out the actual arguments provided, e.g., when
//                           there are arguments omitted from the call. When
//                           it is provided, engines may use this object to
//                           check for the argument names and omitted
//                           arguments. SQLBuilder may also need this object
//                           in cases when the named argument notation is
//                           required for this call.</font>
class ResolvedTVFScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_TVFSCAN;

  const TableValuedFunction* tvf() const;

  const std::shared_ptr&lt;TVFSignature&gt;&amp; signature() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedFunctionArgument">ResolvedFunctionArgument</a>&gt;&gt;&amp; argument_list() const;
  int argument_list_size() const;
  const <a href="#ResolvedFunctionArgument">ResolvedFunctionArgument</a>* argument_list(int i) const;

  const std::vector&lt;int&gt;&amp; column_index_list() const;
  int column_index_list_size() const;
  int column_index_list(int i) const;

  const std::string&amp; alias() const;

  const std::shared_ptr&lt;FunctionSignature&gt;&amp; function_call_signature() const;
};
</code></pre></p>

### ResolvedGroupRowsScan
<a id="ResolvedGroupRowsScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// ResolvedGroupRowsScan represents a call to a special TVF GROUP_ROWS().
// It can only show up inside WITH GROUP_ROWS clause, which is resolved as
// the field with_group_rows_subquery in ResolvedNonScalarFunctionCallBase
// ResolvedGroupRowsScan. This scan produces rows corresponding to the input
// of ResolvedAggregateScan that belong to the current group.
//
// &lt;input_column_list&gt; is a list of new columns created to store values
// coming from the input of the aggregate scan. ResolvedComputedColumn can
// only hold ResolvedColumnRef&#39;s and can reference anything from the
// pre-aggregation scan.
//
// &lt;alias&gt; is the alias of the scan or empty if none.</font>
class ResolvedGroupRowsScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GROUP_ROWS_SCAN;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; input_column_list() const;
  int input_column_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* input_column_list(int i) const;

  const std::string&amp; alias() const;
};
</code></pre></p>

### ResolvedFunctionArgument
<a id="ResolvedFunctionArgument"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents a generic argument to a function. The argument can be
// semantically an expression, relation, model, connection or descriptor.
// Only one of the five fields will be set.
//
// &lt;expr&gt; represents a scalar function argument.
// &lt;scan&gt; represents a table-typed argument.
// &lt;model&gt; represents a ML model function argument.
// &lt;connection&gt; represents a connection object function argument.
// &lt;descriptor_arg&gt; represents a descriptor object function argument.
//
// This node could be used in multiple places:
// * ResolvedTVFScan supports all of these.
// * ResolvedFunctionCall supports only &lt;expr&gt;.
// * ResolvedCallStmt supports only &lt;expr&gt;.
//
// If the argument has type &lt;scan&gt;, &lt;argument_column_list&gt; maps columns from
// &lt;scan&gt; into specific columns of the argument&#39;s input schema, matching
// those columns positionally. i.e. &lt;scan&gt;&#39;s column_list may have fewer
// columns or out-of-order columns, and this vector maps those columns into
// specific input columns.</font>
class ResolvedFunctionArgument : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FUNCTION_ARGUMENT;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* scan() const;

  const <a href="#ResolvedModel">ResolvedModel</a>* model() const;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;

  const <a href="#ResolvedDescriptor">ResolvedDescriptor</a>* descriptor_arg() const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; argument_column_list() const;
  int argument_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> argument_column_list(int i) const;

  const <a href="#ResolvedInlineLambda">ResolvedInlineLambda</a>* inline_lambda() const;
};
</code></pre></p>

### ResolvedStatement
<a id="ResolvedStatement"></a>

<p><pre><code class="lang-c++">
<font color="brown">// The superclass of all ZetaSQL statements.</font>
class ResolvedStatement : public <a href="#ResolvedNode">ResolvedNode</a> {
  typedef ResolvedStatementEnums::ObjectAccess ObjectAccess;
  static const ObjectAccess NONE = ResolvedStatementEnums::NONE;
  static const ObjectAccess READ = ResolvedStatementEnums::READ;
  static const ObjectAccess WRITE = ResolvedStatementEnums::WRITE;
  static const ObjectAccess READ_WRITE = ResolvedStatementEnums::READ_WRITE;

  bool IsStatement() const final { return true; }

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; hint_list() const;
  int hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* hint_list(int i) const;
};
</code></pre></p>

### ResolvedExplainStmt
<a id="ResolvedExplainStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// An Explain statement. This is always the root of a statement hierarchy.
// Its child may be any statement type except another ResolvedExplainStmt.
//
// It is implementation dependent what action a back end system takes for an
// ExplainStatement.</font>
class ResolvedExplainStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXPLAIN_STMT;

  const <a href="#ResolvedStatement">ResolvedStatement</a>* statement() const;
};
</code></pre></p>

### ResolvedQueryStmt
<a id="ResolvedQueryStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A SQL query statement.  This is the outermost query statement that runs
// and produces rows of output, like a SELECT.  (The contained query may be
// a Scan corresponding to a non-Select top-level operation like UNION ALL
// or WITH.)
//
// &lt;output_column_list&gt; gives the user-visible column names that should be
// returned in the API or query tools.  There may be duplicate names, and
// multiple output columns may reference the same column from &lt;query&gt;.</font>
class ResolvedQueryStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_QUERY_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

<font color="brown">  // If true, the result of this query is a value table. Rather than
  // producing rows with named columns, it produces rows with a single
  // unnamed value type.  output_column_list will have exactly one
  // column, with an empty name. See (broken link).</font>
  bool is_value_table() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;
};
</code></pre></p>

### ResolvedCreateDatabaseStmt
<a id="ResolvedCreateDatabaseStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//   CREATE DATABASE &lt;name&gt; [OPTIONS (...)]
// &lt;name_path&gt; is a vector giving the identifier path in the database name.
// &lt;option_list&gt; specifies the options of the database.</font>
class ResolvedCreateDatabaseStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_DATABASE_STMT;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedCreateStatement
<a id="ResolvedCreateStatement"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Common superclass for CREATE statements with standard modifiers like
//         CREATE [OR REPLACE] [TEMP|TEMPORARY|PUBLIC|PRIVATE] &lt;object type&gt;
//         [IF NOT EXISTS] &lt;name&gt; ...
//
// &lt;name_path&gt; is a vector giving the identifier path in the table name.
// &lt;create_scope&gt; is the relevant scope, i.e., DEFAULT, TEMP, PUBLIC,
//                or PRIVATE.  PUBLIC/PRIVATE are only valid in module
//                resolution context, see (broken link)
//                for details.
// &lt;create_mode&gt; indicates if this was CREATE, CREATE OR REPLACE, or
//               CREATE IF NOT EXISTS.</font>
class ResolvedCreateStatement : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  typedef ResolvedCreateStatementEnums::CreateScope CreateScope;
  typedef ResolvedCreateStatementEnums::CreateMode CreateMode;
  typedef ResolvedCreateStatementEnums::SqlSecurity SqlSecurity;
  typedef ResolvedCreateStatementEnums::DeterminismLevel DeterminismLevel;
  static const CreateScope CREATE_DEFAULT_SCOPE = ResolvedCreateStatementEnums::CREATE_DEFAULT_SCOPE;
  static const CreateScope CREATE_PRIVATE = ResolvedCreateStatementEnums::CREATE_PRIVATE;
  static const CreateScope CREATE_PUBLIC = ResolvedCreateStatementEnums::CREATE_PUBLIC;
  static const CreateScope CREATE_TEMP = ResolvedCreateStatementEnums::CREATE_TEMP;
  static const CreateMode CREATE_DEFAULT = ResolvedCreateStatementEnums::CREATE_DEFAULT;
  static const CreateMode CREATE_OR_REPLACE = ResolvedCreateStatementEnums::CREATE_OR_REPLACE;
  static const CreateMode CREATE_IF_NOT_EXISTS = ResolvedCreateStatementEnums::CREATE_IF_NOT_EXISTS;
  static const SqlSecurity SQL_SECURITY_UNSPECIFIED = ResolvedCreateStatementEnums::SQL_SECURITY_UNSPECIFIED;
  static const SqlSecurity SQL_SECURITY_DEFINER = ResolvedCreateStatementEnums::SQL_SECURITY_DEFINER;
  static const SqlSecurity SQL_SECURITY_INVOKER = ResolvedCreateStatementEnums::SQL_SECURITY_INVOKER;
  static const DeterminismLevel DETERMINISM_UNSPECIFIED = ResolvedCreateStatementEnums::DETERMINISM_UNSPECIFIED;
  static const DeterminismLevel DETERMINISM_DETERMINISTIC = ResolvedCreateStatementEnums::DETERMINISM_DETERMINISTIC;
  static const DeterminismLevel DETERMINISM_NOT_DETERMINISTIC = ResolvedCreateStatementEnums::DETERMINISM_NOT_DETERMINISTIC;
  static const DeterminismLevel DETERMINISM_IMMUTABLE = ResolvedCreateStatementEnums::DETERMINISM_IMMUTABLE;
  static const DeterminismLevel DETERMINISM_STABLE = ResolvedCreateStatementEnums::DETERMINISM_STABLE;
  static const DeterminismLevel DETERMINISM_VOLATILE = ResolvedCreateStatementEnums::DETERMINISM_VOLATILE;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  CreateScope create_scope() const;

  CreateMode create_mode() const;
};
</code></pre></p>

### ResolvedIndexItem
<a id="ResolvedIndexItem"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Represents one of indexed items in CREATE INDEX statement, with the
// ordering direction specified.</font>
class ResolvedIndexItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_INDEX_ITEM;

  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* column_ref() const;

  bool descending() const;
};
</code></pre></p>

### ResolvedUnnestItem
<a id="ResolvedUnnestItem"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This is used in CREATE INDEX STMT to represent the unnest operation
// performed on the base table. The produced element columns or array offset
// columns (optional) can appear in other ResolvedUnnestItem or index keys.
//
// &lt;array_expr&gt; is the expression of the array field, e.g., t.array_field.
// &lt;element_column&gt; is the new column produced by this unnest item that
//                  stores the array element value for each row.
// &lt;array_offset_column&gt; is optional. If present, it defines the column
//                       produced by this unnest item that stores the array
//                       offset (0-based) for the corresponding
//                       &lt;element_column&gt;.</font>
class ResolvedUnnestItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UNNEST_ITEM;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* array_expr() const;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; element_column() const;

  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* array_offset_column() const;
};
</code></pre></p>

### ResolvedCreateIndexStmt
<a id="ResolvedCreateIndexStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
// CREATE [OR REPLACE] [UNIQUE] [SEARCH] INDEX [IF NOT EXISTS]
//  &lt;index_name_path&gt; ON &lt;table_name_path&gt;
// [STORING (Expression, ...)]
// [UNNEST(path_expression) [[AS] alias] [WITH OFFSET [[AS] alias]], ...]
// (path_expression [ASC|DESC], ...) [OPTIONS (name=value, ...)];
//
// &lt;table_name_path&gt; is the name of table being indexed.
// &lt;table_scan&gt; is a TableScan on the table being indexed.
// &lt;is_unique&gt; specifies if the index has unique entries.
// &lt;is_search&gt; specifies if the index is for search.
// &lt;index_item_list&gt; has the columns being indexed, specified as references
//                   to &#39;computed_columns_list&#39; entries or the columns of
//                   &#39;table_scan&#39;.
// &lt;storing_expression_list&gt; has the expressions in the storing clause.
// &lt;option_list&gt; has engine-specific directives for how and where to
//               materialize this index.
// &lt;computed_columns_list&gt; has computed columns derived from the columns of
//                         &#39;table_scan&#39; or &#39;unnest_expressions_list&#39;. For
//                         example, the extracted field (e.g., x.y.z).
// &lt;unnest_expressions_list&gt; has unnest expressions derived from
//                           &#39;table_scan&#39; or previous unnest expressions in
//                           the list. So the list order is significant.</font>
class ResolvedCreateIndexStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_INDEX_STMT;

  const std::vector&lt;std::string&gt;&amp; table_name_path() const;
  int table_name_path_size() const;
  std::string table_name_path(int i) const;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

  bool is_unique() const;

  bool is_search() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedIndexItem">ResolvedIndexItem</a>&gt;&gt;&amp; index_item_list() const;
  int index_item_list_size() const;
  const <a href="#ResolvedIndexItem">ResolvedIndexItem</a>* index_item_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; storing_expression_list() const;
  int storing_expression_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* storing_expression_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; computed_columns_list() const;
  int computed_columns_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* computed_columns_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUnnestItem">ResolvedUnnestItem</a>&gt;&gt;&amp; unnest_expressions_list() const;
  int unnest_expressions_list_size() const;
  const <a href="#ResolvedUnnestItem">ResolvedUnnestItem</a>* unnest_expressions_list(int i) const;
};
</code></pre></p>

### ResolvedCreateSchemaStmt
<a id="ResolvedCreateSchemaStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
// CREATE [OR REPLACE] SCHEMA [IF NOT EXISTS] &lt;name&gt;
// [OPTIONS (name=value, ...)];
//
// &lt;option_list&gt; engine-specific options.</font>
class ResolvedCreateSchemaStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_SCHEMA_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedCreateTableStmtBase
<a id="ResolvedCreateTableStmtBase"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//   CREATE [TEMP] TABLE &lt;name&gt; [(column type, ...) | LIKE &lt;name_path&gt;]
//   [PARTITION BY expr, ...] [CLUSTER BY expr, ...]
//   [OPTIONS (...)]
//
// &lt;option_list&gt; has engine-specific directives for how and where to
//               materialize this table.
// &lt;column_definition_list&gt; has the names and types of the columns in the
//                          created table. If &lt;is_value_table&gt; is true, it
//                          must contain exactly one column, with a generated
//                          name such as &#34;$struct&#34;.
// &lt;pseudo_column_list&gt; is a list of some pseudo-columns expected to be
//                      present on the created table (provided by
//                      AnalyzerOptions::SetDdlPseudoColumns*).  These can be
//                      referenced in expressions in &lt;partition_by_list&gt; and
//                      &lt;cluster_by_list&gt;.
// &lt;primary_key&gt; specifies the PRIMARY KEY constraint on the table, it is
//               nullptr when no PRIMARY KEY is specified.
// &lt;foreign_key_list&gt; specifies the FOREIGN KEY constraints on the table.
// &lt;check_constraint_list&gt; specifies the CHECK constraints on the table.
// &lt;partition_by_list&gt; specifies the partitioning expressions for the table.
// &lt;cluster_by_list&gt; specifies the clustering expressions for the table.
// &lt;is_value_table&gt; specifies whether the table is a value table.
//                  See (broken link).
// &lt;like_table&gt; identifies the table in the LIKE &lt;name_path&gt;.
//              By default, all fields (column names, types, constraints,
//              keys, clustering etc.) will be inherited from the source
//              table. But if explicitly set, the explicit settings will
//              take precedence.</font>
class ResolvedCreateTableStmtBase : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>&gt;&gt;&amp; column_definition_list() const;
  int column_definition_list_size() const;
  const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>* column_definition_list(int i) const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; pseudo_column_list() const;
  int pseudo_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> pseudo_column_list(int i) const;

  const <a href="#ResolvedPrimaryKey">ResolvedPrimaryKey</a>* primary_key() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedForeignKey">ResolvedForeignKey</a>&gt;&gt;&amp; foreign_key_list() const;
  int foreign_key_list_size() const;
  const <a href="#ResolvedForeignKey">ResolvedForeignKey</a>* foreign_key_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedCheckConstraint">ResolvedCheckConstraint</a>&gt;&gt;&amp; check_constraint_list() const;
  int check_constraint_list_size() const;
  const <a href="#ResolvedCheckConstraint">ResolvedCheckConstraint</a>* check_constraint_list(int i) const;

  bool is_value_table() const;

  const Table* like_table() const;
};
</code></pre></p>

### ResolvedCreateTableStmt
<a id="ResolvedCreateTableStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//   CREATE [TEMP] TABLE &lt;name&gt;
//   [(column schema, ...) | LIKE &lt;name_path&gt; |
//       CLONE &lt;name_path&gt;
//           [FOR SYSTEM_TIME AS OF &lt;time_expr&gt;]
//           [WHERE &lt;where_clause&gt;]]
//   [PARTITION BY expr, ...] [CLUSTER BY expr, ...]
//   [OPTIONS (...)]
//
// &lt;clone_from&gt; the source data to clone data from.
//              ResolvedTableScan will represent the source table, with an
//              optional for_system_time_expr.
//              The ResolvedTableScan may be wrapped inside a
//              ResolvedFilterScan if the source table has a where clause.
//              No other Scan types are allowed here.
//              By default, all fields (column names, types, constraints,
//              partition, clustering, options etc.) will be inherited from
//              the source table. If table options are explicitly set, the
//              explicit options will take precedence.
//              The &#39;clone_from.column_list&#39; field may be set, but should be
//              ignored.
//              Cannot be value table.</font>
class ResolvedCreateTableStmt : public <a href="#ResolvedCreateTableStmtBase">ResolvedCreateTableStmtBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_TABLE_STMT;

  const <a href="#ResolvedScan">ResolvedScan</a>* clone_from() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; partition_by_list() const;
  int partition_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* partition_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; cluster_by_list() const;
  int cluster_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* cluster_by_list(int i) const;
};
</code></pre></p>

### ResolvedCreateTableAsSelectStmt
<a id="ResolvedCreateTableAsSelectStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//   CREATE [TEMP] TABLE &lt;name&gt; [(column schema, ...) | LIKE &lt;name_path&gt;]
//   [PARTITION BY expr, ...] [CLUSTER BY expr, ...] [OPTIONS (...)]
//   AS SELECT ...
//
// The &lt;output_column_list&gt; matches 1:1 with the &lt;column_definition_list&gt; in
// ResolvedCreateTableStmtBase, and maps ResolvedColumns produced by &lt;query&gt;
// into specific columns of the created table.  The output column names and
// types must match the column definition names and types.  If the table is
// a value table, &lt;output_column_list&gt; must have exactly one column, with a
// generated name such as &#34;$struct&#34;.
//
// &lt;output_column_list&gt; does not contain all table schema information that
// &lt;column_definition_list&gt; does. For example, NOT NULL annotations, column
// OPTIONS, and primary keys are only available in &lt;column_definition_list&gt;.
// Consumers are encouraged to read from &lt;column_definition_list&gt; rather
// than than &lt;output_column_list&gt; to determine the table schema, if possible.
//
// &lt;query&gt; is the query to run.</font>
class ResolvedCreateTableAsSelectStmt : public <a href="#ResolvedCreateTableStmtBase">ResolvedCreateTableStmtBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_TABLE_AS_SELECT_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; partition_by_list() const;
  int partition_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* partition_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; cluster_by_list() const;
  int cluster_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* cluster_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;
};
</code></pre></p>

### ResolvedCreateModelStmt
<a id="ResolvedCreateModelStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//   CREATE [TEMP] MODEL &lt;name&gt; [TRANSFORM(...)] [OPTIONS (...)] AS SELECT ..
//
// &lt;option_list&gt; has engine-specific directives for how to train this model.
// &lt;output_column_list&gt; matches 1:1 with the &lt;query&gt;&#39;s column_list and the
//                      &lt;column_definition_list&gt;, and identifies the names
//                      and types of the columns output from the select
//                      statement.
// &lt;query&gt; is the select statement.
// &lt;transform_input_column_list&gt; introduces new ResolvedColumns that have the
//   same names and types of the columns in the &lt;output_column_list&gt;. The
//   transform expressions resolve against these ResolvedColumns. It&#39;s only
//   set when &lt;transform_list&gt; is non-empty.
// &lt;transform_list&gt; is the list of ResolvedComputedColumn in TRANSFORM
//   clause.
// &lt;transform_output_column_list&gt; matches 1:1 with &lt;transform_list&gt; output.
//   It records the names of the output columns from TRANSFORM clause.
// &lt;transform_analytic_function_group_list&gt; is the list of
//   AnalyticFunctionGroup for analytic functions inside TRANSFORM clause.
//   It records the input expression of the analytic functions. It can
//   see all the columns from &lt;transform_input_column_list&gt;. The only valid
//   group is for the full, unbounded window generated from empty OVER()
//   clause.
//   For example, CREATE MODEL statement
//   &#34;create model Z
//     transform (max(c) over() as d)
//     options ()
//     as select 1 c, 2 b;&#34;
//   will generate transform_analytic_function_group_list:
//   +-transform_analytic_function_group_list=
//     +-AnalyticFunctionGroup
//       +-analytic_function_list=
//         +-d#5 :=
//           +-AnalyticFunctionCall(ZetaSQL:max(INT64) -&gt; INT64)
//             +-ColumnRef(type=INT64, column=Z.c#3)
//             +-window_frame=
//               +-WindowFrame(frame_unit=ROWS)
//                 +-start_expr=
//                 | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
//                 +-end_expr=
//                   +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)</font>
class ResolvedCreateModelStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_MODEL_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>&gt;&gt;&amp; transform_input_column_list() const;
  int transform_input_column_list_size() const;
  const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>* transform_input_column_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; transform_list() const;
  int transform_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* transform_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; transform_output_column_list() const;
  int transform_output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* transform_output_column_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>&gt;&gt;&amp; transform_analytic_function_group_list() const;
  int transform_analytic_function_group_list_size() const;
  const <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>* transform_analytic_function_group_list(int i) const;
};
</code></pre></p>

### ResolvedCreateViewBase
<a id="ResolvedCreateViewBase"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Common superclass for CREATE view/materialized view:
//   CREATE [TEMP|MATERIALIZED] [RECURSIVE] VIEW &lt;name&gt; [(...)]
//     [OPTIONS (...)]
//     AS SELECT ...
//
// &lt;option_list&gt; has engine-specific directives for options attached to
//               this view.
// &lt;output_column_list&gt; has the names and types of the columns in the
//                      created view, and maps from &lt;query&gt;&#39;s column_list
//                      to these output columns. If &lt;has_explicit_columns&gt; is
//                      true, names will be explicitly provided.
// &lt;has_explicit_columns&gt; If this is set, the statement includes an explicit
//   column name list. These column names should still be applied even if the
//   query changes or is re-resolved in the future. The view becomes invalid
//   if the query produces a different number of columns.
// &lt;query&gt; is the query to run.
// &lt;sql&gt; is the view query text.
// &lt;sql_security&gt; is the declared security mode for the function. Values
//    include &#39;INVOKER&#39;, &#39;DEFINER&#39;.
// &lt;recursive&gt; specifies whether or not the view is created with the
//   RECURSIVE keyword.
//
// Note that &lt;query&gt; and &lt;sql&gt; are both marked as IGNORABLE because
// an engine could look at either one (but might not look at both).
// An engine must look at one (and cannot ignore both) to be
// semantically valid, but there is currently no way to enforce that.
//
// The view must produce named columns with unique names.</font>
class ResolvedCreateViewBase : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

  bool has_explicit_columns() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;

  const std::string&amp; sql() const;

  SqlSecurity sql_security() const;

<font color="brown">  // If true, this view produces a value table. Rather than producing
  // rows with named columns, it produces rows with a single unnamed
  // value type.  output_column_list will have exactly one column, with
  // an empty name. See (broken link).</font>
  bool is_value_table() const;

<font color="brown">  // True if the view uses the RECURSIVE keyword. &lt;query&gt;
  // can be a ResolvedRecursiveScan only if this is true.</font>
  bool recursive() const;
};
</code></pre></p>

### ResolvedCreateViewStmt
<a id="ResolvedCreateViewStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
// CREATE [TEMP] VIEW &lt;name&gt; [(...)] [OPTIONS (...)] AS SELECT ...</font>
class ResolvedCreateViewStmt : public <a href="#ResolvedCreateViewBase">ResolvedCreateViewBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_VIEW_STMT;

};
</code></pre></p>

### ResolvedWithPartitionColumns
<a id="ResolvedWithPartitionColumns"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
// WITH PARTITION COLUMNS [(column schema, ...)]</font>
class ResolvedWithPartitionColumns : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WITH_PARTITION_COLUMNS;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>&gt;&gt;&amp; column_definition_list() const;
  int column_definition_list_size() const;
  const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>* column_definition_list(int i) const;
};
</code></pre></p>

### ResolvedCreateSnapshotTableStmt
<a id="ResolvedCreateSnapshotTableStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//   CREATE SNAPSHOT TABLE [IF NOT EXISTS] &lt;name&gt; [OPTIONS (...)]
//   CLONE &lt;name&gt;
//           [FOR SYSTEM_TIME AS OF &lt;time_expr&gt;]
//
// &lt;clone_from&gt; the source data to clone data from.
//              ResolvedTableScan will represent the source table, with an
//              optional for_system_time_expr.
//              The ResolvedTableScan may be wrapped inside a
//              ResolvedFilterScan if the source table has a where clause.
//              No other Scan types are allowed here.
//              By default, all fields (column names, types, constraints,
//              partition, clustering, options etc.) will be inherited from
//              the source table. If table options are explicitly set, the
//              explicit options will take precedence.
//              The &#39;clone_from.column_list&#39; field may be set, but should be
//              ignored.</font>
class ResolvedCreateSnapshotTableStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_SNAPSHOT_TABLE_STMT;

  const <a href="#ResolvedScan">ResolvedScan</a>* clone_from() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedCreateExternalTableStmt
<a id="ResolvedCreateExternalTableStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
// CREATE [TEMP] EXTERNAL TABLE &lt;name&gt; [(column type, ...)]
// [WITH PARTITION COLUMN [(column type, ...)]]
// [WITH CONNECTION connection_name]
// OPTIONS (...)</font>
class ResolvedCreateExternalTableStmt : public <a href="#ResolvedCreateTableStmtBase">ResolvedCreateTableStmtBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_EXTERNAL_TABLE_STMT;

  const <a href="#ResolvedWithPartitionColumns">ResolvedWithPartitionColumns</a>* with_partition_columns() const;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;
};
</code></pre></p>

### ResolvedExportModelStmt
<a id="ResolvedExportModelStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//   EXPORT MODEL &lt;model_name_path&gt; [WITH CONNECTION &lt;connection&gt;]
//   &lt;option_list&gt;
// which is used to export a model to a specific location.
// &lt;connection&gt; is the connection that the model is written to.
// &lt;option_list&gt; identifies user specified options to use when exporting the model.</font>
class ResolvedExportModelStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXPORT_MODEL_STMT;

  const std::vector&lt;std::string&gt;&amp; model_name_path() const;
  int model_name_path_size() const;
  std::string model_name_path(int i) const;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedExportDataStmt
<a id="ResolvedExportDataStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//   EXPORT DATA [WITH CONNECTION] &lt;connection&gt; (&lt;option_list&gt;) AS SELECT ...
// which is used to run a query and export its result somewhere
// without giving the result a table name.
// &lt;connection&gt; connection reference for accessing destination source.
// &lt;option_list&gt; has engine-specific directives for how and where to
//               materialize the query result.
// &lt;output_column_list&gt; has the names and types of the columns produced by
//                      the query, and maps from &lt;query&gt;&#39;s column_list
//                      to these output columns.  The engine may ignore
//                      the column names depending on the output format.
// &lt;query&gt; is the query to run.
//
// The query must produce named columns with unique names.</font>
class ResolvedExportDataStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXPORT_DATA_STMT;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

<font color="brown">  // If true, the result of this query is a value table. Rather than
  // producing rows with named columns, it produces rows with a single
  // unnamed value type.  output_column_list will have exactly one
  // column, with an empty name. See (broken link).</font>
  bool is_value_table() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;
};
</code></pre></p>

### ResolvedDefineTableStmt
<a id="ResolvedDefineTableStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: DEFINE TABLE name (...);
//
// &lt;name_path&gt; is a vector giving the identifier path in the table name.
// &lt;option_list&gt; has engine-specific options of how the table is defined.
//
// DEFINE TABLE normally has the same effect as CREATE TEMP EXTERNAL TABLE.</font>
class ResolvedDefineTableStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DEFINE_TABLE_STMT;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedDescribeStmt
<a id="ResolvedDescribeStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: DESCRIBE [&lt;object_type&gt;] &lt;name&gt; [FROM &lt;from_name_path&gt;];
//
// &lt;object_type&gt; is an optional string identifier,
//               e.g., &#34;INDEX&#34;, &#34;FUNCTION&#34;, &#34;TYPE&#34;, etc.
// &lt;name_path&gt; is a vector giving the identifier path for the object to be
//             described.
// &lt;from_name_path&gt; is an optional vector giving the identifier path of a
//                    containing object, e.g. a table.</font>
class ResolvedDescribeStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DESCRIBE_STMT;

  const std::string&amp; object_type() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::string&gt;&amp; from_name_path() const;
  int from_name_path_size() const;
  std::string from_name_path(int i) const;
};
</code></pre></p>

### ResolvedShowStmt
<a id="ResolvedShowStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: SHOW &lt;identifier&gt; [FROM &lt;name_path&gt;] [LIKE &lt;like_expr&gt;];
//
// &lt;identifier&gt; is a string that determines the type of objects to be shown,
//              e.g., TABLES, COLUMNS, INDEXES, STATUS,
// &lt;name_path&gt; is an optional path to an object from which &lt;identifier&gt;
//             objects will be shown, e.g., if &lt;identifier&gt; = INDEXES and
//             &lt;name&gt; = table_name, the indexes of &#34;table_name&#34; will be
//             shown,
// &lt;like_expr&gt; is an optional ResolvedLiteral of type string that if present
//             restricts the objects shown to have a name like this string.</font>
class ResolvedShowStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SHOW_STMT;

  const std::string&amp; identifier() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const <a href="#ResolvedLiteral">ResolvedLiteral</a>* like_expr() const;
};
</code></pre></p>

### ResolvedBeginStmt
<a id="ResolvedBeginStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: BEGIN [TRANSACTION] [ &lt;transaction_mode&gt; [, ...] ]
//
// Where transaction_mode is one of:
//      READ ONLY
//      READ WRITE
//      &lt;isolation_level&gt;
//
// &lt;isolation_level&gt; is a string vector storing the identifiers after
//       ISOLATION LEVEL. The strings inside vector could be one of the
//       SQL standard isolation levels:
//
//                   READ UNCOMMITTED
//                   READ COMMITTED
//                   READ REPEATABLE
//                   SERIALIZABLE
//
//       or could be arbitrary strings. ZetaSQL does not validate that
//       the string is valid.</font>
class ResolvedBeginStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_BEGIN_STMT;

  typedef ResolvedBeginStmtEnums::ReadWriteMode ReadWriteMode;
  static const ReadWriteMode MODE_UNSPECIFIED = ResolvedBeginStmtEnums::MODE_UNSPECIFIED;
  static const ReadWriteMode MODE_READ_ONLY = ResolvedBeginStmtEnums::MODE_READ_ONLY;
  static const ReadWriteMode MODE_READ_WRITE = ResolvedBeginStmtEnums::MODE_READ_WRITE;

  ReadWriteMode read_write_mode() const;

  const std::vector&lt;std::string&gt;&amp; isolation_level_list() const;
  int isolation_level_list_size() const;
  std::string isolation_level_list(int i) const;
};
</code></pre></p>

### ResolvedSetTransactionStmt
<a id="ResolvedSetTransactionStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: SET TRANSACTION &lt;transaction_mode&gt; [, ...]
//
// Where transaction_mode is one of:
//      READ ONLY
//      READ WRITE
//      &lt;isolation_level&gt;
//
// &lt;isolation_level&gt; is a string vector storing the identifiers after
//       ISOLATION LEVEL. The strings inside vector could be one of the
//       SQL standard isolation levels:
//
//                   READ UNCOMMITTED
//                   READ COMMITTED
//                   READ REPEATABLE
//                   SERIALIZABLE
//
//       or could be arbitrary strings. ZetaSQL does not validate that
//       the string is valid.</font>
class ResolvedSetTransactionStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SET_TRANSACTION_STMT;

  typedef ResolvedBeginStmt::ReadWriteMode ReadWriteMode;

  ReadWriteMode read_write_mode() const;

  const std::vector&lt;std::string&gt;&amp; isolation_level_list() const;
  int isolation_level_list_size() const;
  std::string isolation_level_list(int i) const;
};
</code></pre></p>

### ResolvedCommitStmt
<a id="ResolvedCommitStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: COMMIT [TRANSACTION];</font>
class ResolvedCommitStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_COMMIT_STMT;

};
</code></pre></p>

### ResolvedRollbackStmt
<a id="ResolvedRollbackStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: ROLLBACK [TRANSACTION];</font>
class ResolvedRollbackStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ROLLBACK_STMT;

};
</code></pre></p>

### ResolvedStartBatchStmt
<a id="ResolvedStartBatchStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: START BATCH [&lt;batch_type&gt;];
//
// &lt;batch_type&gt; is an optional string identifier that identifies the type of
//              the batch. (e.g. &#34;DML&#34; or &#34;DDL)</font>
class ResolvedStartBatchStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_START_BATCH_STMT;

  const std::string&amp; batch_type() const;
};
</code></pre></p>

### ResolvedRunBatchStmt
<a id="ResolvedRunBatchStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: RUN BATCH;</font>
class ResolvedRunBatchStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RUN_BATCH_STMT;

};
</code></pre></p>

### ResolvedAbortBatchStmt
<a id="ResolvedAbortBatchStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: ABORT BATCH;</font>
class ResolvedAbortBatchStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ABORT_BATCH_STMT;

};
</code></pre></p>

### ResolvedDropStmt
<a id="ResolvedDropStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: DROP &lt;object_type&gt; [IF EXISTS] &lt;name_path&gt; [&lt;drop_mode&gt;];
//
// &lt;object_type&gt; is an string identifier,
//               e.g., &#34;TABLE&#34;, &#34;VIEW&#34;, &#34;INDEX&#34;, &#34;FUNCTION&#34;, &#34;TYPE&#34;, etc.
// &lt;name_path&gt; is a vector giving the identifier path for the object to be
//             dropped.
// &lt;is_if_exists&gt; silently ignore the &#34;name_path does not exist&#34; error.
// &lt;drop_mode&gt; specifies drop mode RESTRICT/CASCASE, if any.</font>
class ResolvedDropStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_STMT;

  typedef ResolvedDropStmtEnums::DropMode DropMode;
  static const DropMode DROP_MODE_UNSPECIFIED = ResolvedDropStmtEnums::DROP_MODE_UNSPECIFIED;
  static const DropMode RESTRICT = ResolvedDropStmtEnums::RESTRICT;
  static const DropMode CASCADE = ResolvedDropStmtEnums::CASCADE;

  const std::string&amp; object_type() const;

  bool is_if_exists() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  DropMode drop_mode() const;
};
</code></pre></p>

### ResolvedDropMaterializedViewStmt
<a id="ResolvedDropMaterializedViewStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: DROP MATERIALIZED VIEW [IF EXISTS] &lt;name_path&gt;;
//
// &lt;name_path&gt; is a vector giving the identifier path for the object to be
//             dropped.
// &lt;is_if_exists&gt; silently ignore the &#34;name_path does not exist&#34; error.</font>
class ResolvedDropMaterializedViewStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_MATERIALIZED_VIEW_STMT;

  bool is_if_exists() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;
};
</code></pre></p>

### ResolvedDropSnapshotTableStmt
<a id="ResolvedDropSnapshotTableStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: DROP SNAPSHOT TABLE [IF EXISTS] &lt;name_path&gt;;
//
// &lt;name_path&gt; is a vector giving the identifier path for the object to be
//             dropped.
// &lt;is_if_exists&gt; silently ignore the &#34;name_path does not exist&#34; error.</font>
class ResolvedDropSnapshotTableStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_SNAPSHOT_TABLE_STMT;

  bool is_if_exists() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;
};
</code></pre></p>

### ResolvedRecursiveRefScan
<a id="ResolvedRecursiveRefScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Scan the previous iteration of the recursive alias currently being
// defined, from inside the recursive subquery which defines it. Such nodes
// can exist only in the recursive term of a ResolvedRecursiveScan node.
// The column_list produced here will match 1:1 with the column_list produced
// by the referenced subquery and will be given a new unique name to each
// column produced for this scan.</font>
class ResolvedRecursiveRefScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RECURSIVE_REF_SCAN;

};
</code></pre></p>

### ResolvedRecursiveScan
<a id="ResolvedRecursiveScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A recursive query inside a WITH RECURSIVE or RECURSIVE VIEW. A
// ResolvedRecursiveScan may appear in a resolved tree only as a top-level
// input scan of a ResolvedWithEntry or ResolvedCreateViewBase.
//
// Recursive queries must satisfy the form:
//     &lt;non-recursive-query&gt; UNION [ALL|DISTINCT] &lt;recursive-query&gt;
//
// where self-references to table being defined are allowed only in the
// &lt;recursive-query&gt; section.
//
// &lt;column_list&gt; is a set of new ResolvedColumns created by this scan.
// Each input ResolvedSetOperationItem has an &lt;output_column_list&gt; which
// matches 1:1 with &lt;column_list&gt; and specifies how the input &lt;scan&gt;&#39;s
// columns map into the final &lt;column_list&gt;.
//
// At runtime, a recursive scan is evaluated using an iterative process:
//
// Step 1: Evaluate the non-recursive term. If UNION DISTINCT
//   is specified, discard duplicates.
//
// Step 2:
//   Repeat until step 2 produces an empty result:
//     Evaluate the recursive term, binding the recursive table to the
//     new rows produced by previous step. If UNION DISTINCT is specified,
//     discard duplicate rows, as well as any rows which match any
//     previously-produced result.
//
// Step 3:
//   The final content of the recursive table is the UNION ALL of all results
//   produced (step 1, plus all iterations of step 2).
//
// ResolvedRecursiveScan only supports a recursive WITH entry which
//   directly references itself; ZetaSQL does not support mutual recursion
//   between multiple with-clause elements.
//
// See (broken link) for details.</font>
class ResolvedRecursiveScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RECURSIVE_SCAN;

  typedef ResolvedRecursiveScanEnums::RecursiveSetOperationType RecursiveSetOperationType;
  static const RecursiveSetOperationType UNION_ALL = ResolvedRecursiveScanEnums::UNION_ALL;
  static const RecursiveSetOperationType UNION_DISTINCT = ResolvedRecursiveScanEnums::UNION_DISTINCT;

  RecursiveSetOperationType op_type() const;

  const <a href="#ResolvedSetOperationItem">ResolvedSetOperationItem</a>* non_recursive_term() const;

  const <a href="#ResolvedSetOperationItem">ResolvedSetOperationItem</a>* recursive_term() const;
};
</code></pre></p>

### ResolvedWithScan
<a id="ResolvedWithScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents a SQL WITH query (or subquery) like
//   WITH [RECURSIVE] &lt;with_query_name1&gt; AS (&lt;with_subquery1&gt;),
//        &lt;with_query_name2&gt; AS (&lt;with_subquery2&gt;)
//   &lt;query&gt;;
//
// WITH entries are sorted in dependency order so that an entry can only
// reference entries earlier in &lt;with_entry_list&gt;, plus itself if the
// RECURSIVE keyword is used. If the RECURSIVE keyword is not used, this will
// be the same order as in the original query, since an entry which
// references itself or any entry later in the list is not allowed.
//
// If a WITH subquery is referenced multiple times, the full query should
// behave as if the subquery runs only once and its result is reused.
//
// There will be one ResolvedWithEntry here for each subquery in the SQL
// WITH statement, in the same order as in the query.
//
// Inside the resolved &lt;query&gt;, or any &lt;with_entry_list&gt; occurring after
// its definition, a &lt;with_query_name&gt; used as a table scan will be
// represented using a ResolvedWithRefScan.
//
// The &lt;with_query_name&gt; aliases are always unique within a query, and should
// be used to connect the ResolvedWithRefScan to the original query
// definition.  The subqueries are not inlined and duplicated into the tree.
//
// In ZetaSQL 1.0, WITH is allowed only on the outermost query and not in
// subqueries, so the ResolvedWithScan node can only occur as the outermost
// scan in a statement (e.g. a QueryStmt or CreateTableAsSelectStmt).
//
// In ZetaSQL 1.1 (language option FEATURE_V_1_1_WITH_ON_SUBQUERY), WITH
// is allowed on subqueries.  Then, ResolvedWithScan can occur anywhere in
// the tree.  The alias introduced by a ResolvedWithEntry is visible only
// in subsequent ResolvedWithEntry queries and in &lt;query&gt;.  The aliases used
// must be globally unique in the resolved AST however, so consumers do not
// need to implement any scoping for these names.  Because the aliases are
// unique, it is legal to collect all ResolvedWithEntries in the tree and
// treat them as if they were a single WITH clause at the outermost level.
//
// In ZetaSQL 1.3 (language option FEATURE_V_1_3_WITH_RECURSIVE), WITH
// RECURSIVE is supported, which allows any &lt;with_subquery&gt; to reference
// any &lt;with_query_name&gt;, regardless of order, including WITH entries which
// reference themself. Circular dependency chains of WITH entries are allowed
// only for direct self-references, and only when the corresponding
// &lt;with_subquery&gt; takes the form &#34;&lt;non-recursive-term&gt; UNION [ALL|DISTINCT]
// &lt;recursive-term&gt;&#34;, with all references to the current &lt;with_query_name&gt;
// confined to the recursive term.
//
// The subqueries inside ResolvedWithEntries cannot be correlated.
//
// If a WITH subquery is defined but never referenced, it will still be
// resolved and still show up here.  Query engines may choose not to run it.</font>
class ResolvedWithScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WITH_SCAN;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedWithEntry">ResolvedWithEntry</a>&gt;&gt;&amp; with_entry_list() const;
  int with_entry_list_size() const;
  const <a href="#ResolvedWithEntry">ResolvedWithEntry</a>* with_entry_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;

<font color="brown">  // True if the WITH clause uses the recursive keyword.</font>
  bool recursive() const;
};
</code></pre></p>

### ResolvedWithEntry
<a id="ResolvedWithEntry"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents one aliased subquery introduced in a WITH clause.
//
// The &lt;with_query_name&gt;s must be globally unique in the full resolved AST.
// The &lt;with_subquery&gt; cannot be correlated and cannot reference any
// columns from outside.  It may reference other WITH subqueries.
//
// See ResolvedWithScan for full details.</font>
class ResolvedWithEntry : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WITH_ENTRY;

  const std::string&amp; with_query_name() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* with_subquery() const;
};
</code></pre></p>

### ResolvedOption
<a id="ResolvedOption"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents one SQL hint key/value pair.
// The SQL syntax @{ key1=value1, key2=value2, some_db.key3=value3 }
// will expand to three ResolvedOptions.  Keyword hints (e.g. LOOKUP JOIN)
// are interpreted as shorthand, and will be expanded to a ResolvedOption
// attached to the appropriate node before any explicit long-form hints.
//
// ResolvedOptions are attached to the ResolvedScan corresponding to the
// operator that the SQL hint was associated with.
// See (broken link) for more detail.
// Hint semantics are implementation defined.
//
// Each hint is resolved as a [&lt;qualifier&gt;.]&lt;name&gt;:=&lt;value&gt; pair.
//   &lt;qualifier&gt; will be empty if no qualifier was present.
//   &lt;name&gt; is always non-empty.
//   &lt;value&gt; can be a ResolvedLiteral or a ResolvedParameter,
//           a cast of a ResolvedParameter (for typed hints only),
//           or a general expression (on constant inputs).
//
// If AllowedHintsAndOptions was set in AnalyzerOptions, and this hint or
// option was included there and had an expected type, the type of &lt;value&gt;
// will match that expected type.  Unknown hints (not listed in
// AllowedHintsAndOptions) are not stripped and will still show up here.
//
// If non-empty, &lt;qualifier&gt; should be interpreted as a target system name,
// and a database system should ignore any hints targeted to different
// systems.
//
// The SQL syntax allows using an identifier as a hint value.
// Such values are stored here as ResolvedLiterals with string type.</font>
class ResolvedOption : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_OPTION;

  const std::string&amp; qualifier() const;

  const std::string&amp; name() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* value() const;
};
</code></pre></p>

### ResolvedWindowPartitioning
<a id="ResolvedWindowPartitioning"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Window partitioning specification for an analytic function call.
//
// PARTITION BY keys in &lt;partition_by_list&gt;.</font>
class ResolvedWindowPartitioning : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WINDOW_PARTITIONING;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; partition_by_list() const;
  int partition_by_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* partition_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; hint_list() const;
  int hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* hint_list(int i) const;
};
</code></pre></p>

### ResolvedWindowOrdering
<a id="ResolvedWindowOrdering"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Window ordering specification for an analytic function call.
//
// ORDER BY items in &lt;order_by_list&gt;. There should be exactly one ORDER
// BY item if this is a window ORDER BY for a RANGE-based window.</font>
class ResolvedWindowOrdering : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WINDOW_ORDERING;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>&gt;&gt;&amp; order_by_item_list() const;
  int order_by_item_list_size() const;
  const <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>* order_by_item_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; hint_list() const;
  int hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* hint_list(int i) const;
};
</code></pre></p>

### ResolvedWindowFrame
<a id="ResolvedWindowFrame"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Window framing specification for an analytic function call.
//
// ROW-based window frames compute the frame based on physical offsets
// from the current row.
// RANGE-based window frames compute the frame based on a logical
// range of rows around the current row based on the current row&#39;s
// ORDER BY key value.
//
// &lt;start_expr&gt; and &lt;end_expr&gt; cannot be NULL. If the window frame
// is one-sided in the input query, the resolver will generate an
// implicit ending boundary.</font>
class ResolvedWindowFrame : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WINDOW_FRAME;

  typedef ResolvedWindowFrameEnums::FrameUnit FrameUnit;
  static const FrameUnit ROWS = ResolvedWindowFrameEnums::ROWS;
  static const FrameUnit RANGE = ResolvedWindowFrameEnums::RANGE;

  std::string GetFrameUnitString() const;
  static std::string FrameUnitToString(FrameUnit frame_unit);

  FrameUnit frame_unit() const;

  const <a href="#ResolvedWindowFrameExpr">ResolvedWindowFrameExpr</a>* start_expr() const;

  const <a href="#ResolvedWindowFrameExpr">ResolvedWindowFrameExpr</a>* end_expr() const;
};
</code></pre></p>

### ResolvedAnalyticFunctionGroup
<a id="ResolvedAnalyticFunctionGroup"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents a group of analytic function calls that shares PARTITION
// BY and ORDER BY.
//
// &lt;partition_by&gt; can be NULL. &lt;order_by&gt; may be NULL depending on the
// functions in &lt;analytic_function_list&gt; and the window frame unit. See
// (broken link) for more details.
//
// All expressions in &lt;analytic_function_list&gt; have a
// ResolvedAggregateFunctionCall with a function in mode
// Function::AGGREGATE or Function::ANALYTIC.</font>
class ResolvedAnalyticFunctionGroup : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ANALYTIC_FUNCTION_GROUP;

  const <a href="#ResolvedWindowPartitioning">ResolvedWindowPartitioning</a>* partition_by() const;

  const <a href="#ResolvedWindowOrdering">ResolvedWindowOrdering</a>* order_by() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; analytic_function_list() const;
  int analytic_function_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* analytic_function_list(int i) const;
};
</code></pre></p>

### ResolvedWindowFrameExpr
<a id="ResolvedWindowFrameExpr"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Window frame boundary expression that determines the first/last row of
// the moving window for each tuple.
//
// &lt;expression&gt; cannot be NULL if the type is OFFSET_PRECEDING
// or OFFSET_FOLLOWING. It must be a constant expression. If this is a
// boundary for a ROW-based window, it must be integer type. Otherwise,
// it must be numeric type and must match exactly the type of the window
// ordering expression.  See (broken link) for more
// details.</font>
class ResolvedWindowFrameExpr : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WINDOW_FRAME_EXPR;

  typedef ResolvedWindowFrameExprEnums::BoundaryType BoundaryType;
  static const BoundaryType UNBOUNDED_PRECEDING = ResolvedWindowFrameExprEnums::UNBOUNDED_PRECEDING;
  static const BoundaryType OFFSET_PRECEDING = ResolvedWindowFrameExprEnums::OFFSET_PRECEDING;
  static const BoundaryType CURRENT_ROW = ResolvedWindowFrameExprEnums::CURRENT_ROW;
  static const BoundaryType OFFSET_FOLLOWING = ResolvedWindowFrameExprEnums::OFFSET_FOLLOWING;
  static const BoundaryType UNBOUNDED_FOLLOWING = ResolvedWindowFrameExprEnums::UNBOUNDED_FOLLOWING;

  std::string GetBoundaryTypeString() const;
  static std::string BoundaryTypeToString(BoundaryType boundary_type);

  BoundaryType boundary_type() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expression() const;
};
</code></pre></p>

### ResolvedDMLValue
<a id="ResolvedDMLValue"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents a value inside an INSERT or UPDATE statement.
//
// The &lt;value&gt; is either an expression or a DMLDefault.
//
// For proto fields, NULL values mean the field should be cleared.</font>
class ResolvedDMLValue : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DMLVALUE;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* value() const;
};
</code></pre></p>

### ResolvedDMLDefault
<a id="ResolvedDMLDefault"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This is used to represent the value DEFAULT that shows up (in place of a
// value expression) in INSERT and UPDATE statements.
// For columns, engines should substitute the engine-defined default value
// for that column, or give an error.
// For proto fields, this always means to clear the field.
// This will never show up inside expressions other than ResolvedDMLValue.</font>
class ResolvedDMLDefault : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DMLDEFAULT;

};
</code></pre></p>

### ResolvedAssertStmt
<a id="ResolvedAssertStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents the ASSERT statement:
//   ASSERT &lt;expression&gt; [AS &lt;description&gt;];
//
// &lt;expression&gt; is any expression that returns a bool.
// &lt;description&gt; is an optional string literal used to give a more
// descriptive error message in case the ASSERT fails.</font>
class ResolvedAssertStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ASSERT_STMT;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expression() const;

  const std::string&amp; description() const;
};
</code></pre></p>

### ResolvedAssertRowsModified
<a id="ResolvedAssertRowsModified"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents the ASSERT ROWS MODIFIED clause on a DML statement.
// The value must be a literal or (possibly casted) parameter int64.
//
// The statement should fail if the number of rows updated does not
// exactly match this number.</font>
class ResolvedAssertRowsModified : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ASSERT_ROWS_MODIFIED;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* rows() const;
};
</code></pre></p>

### ResolvedInsertRow
<a id="ResolvedInsertRow"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents one row in the VALUES clause of an INSERT.</font>
class ResolvedInsertRow : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_INSERT_ROW;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedDMLValue">ResolvedDMLValue</a>&gt;&gt;&amp; value_list() const;
  int value_list_size() const;
  const <a href="#ResolvedDMLValue">ResolvedDMLValue</a>* value_list(int i) const;
};
</code></pre></p>

### ResolvedInsertStmt
<a id="ResolvedInsertStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents an INSERT statement, or a nested INSERT inside an
// UPDATE statement.
//
// For top-level INSERT statements, &lt;table_scan&gt; gives the table to
// scan and creates ResolvedColumns for its columns.  Those columns can be
// referenced in &lt;insert_column_list&gt;.
//
// For nested INSERTS, there is no &lt;table_scan&gt; or &lt;insert_column_list&gt;.
// There is implicitly a single column to insert, and its type is the
// element type of the array being updated in the ResolvedUpdateItem
// containing this statement.
//
// For nested INSERTs, alternate modes are not supported and &lt;insert_mode&gt;
// will always be set to OR_ERROR.
//
// The rows to insert come from &lt;row_list&gt; or the result of &lt;query&gt;.
// Exactly one of these must be present.
//
// If &lt;row_list&gt; is present, the columns in the row_list match
// positionally with &lt;insert_column_list&gt;.
//
// If &lt;query&gt; is present, &lt;query_output_column_list&gt; must also be present.
// &lt;query_output_column_list&gt; is the list of output columns produced by
// &lt;query&gt; that correspond positionally with the target &lt;insert_column_list&gt;
// on the output table.  For nested INSERTs with no &lt;insert_column_list&gt;,
// &lt;query_output_column_list&gt; must have exactly one column.
//
// &lt;query_parameter_list&gt; is set for nested INSERTs where &lt;query&gt; is set and
// references non-target values (columns or field values) from the table. It
// is only set when FEATURE_V_1_2_CORRELATED_REFS_IN_NESTED_DML is enabled.
//
// If &lt;returning&gt; is present, the INSERT statement will return newly inserted
// rows. &lt;returning&gt; can only occur on top-level statements.
//
// The returning clause has a &lt;output_column_list&gt; to represent the data
// sent back to clients. It can only acccess columns from the &lt;table_scan&gt;.</font>
class ResolvedInsertStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_INSERT_STMT;

  typedef ResolvedInsertStmtEnums::InsertMode InsertMode;
  static const InsertMode OR_ERROR = ResolvedInsertStmtEnums::OR_ERROR;
  static const InsertMode OR_IGNORE = ResolvedInsertStmtEnums::OR_IGNORE;
  static const InsertMode OR_REPLACE = ResolvedInsertStmtEnums::OR_REPLACE;
  static const InsertMode OR_UPDATE = ResolvedInsertStmtEnums::OR_UPDATE;

  std::string GetInsertModeString() const;
  static std::string InsertModeToString(InsertMode boundary_type);

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

<font color="brown">  // Behavior on duplicate rows (normally defined to mean duplicate
  // primary keys).</font>
  InsertMode insert_mode() const;

  const <a href="#ResolvedAssertRowsModified">ResolvedAssertRowsModified</a>* assert_rows_modified() const;

  const <a href="#ResolvedReturningClause">ResolvedReturningClause</a>* returning() const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; insert_column_list() const;
  int insert_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> insert_column_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; query_parameter_list() const;
  int query_parameter_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* query_parameter_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; query_output_column_list() const;
  int query_output_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> query_output_column_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedInsertRow">ResolvedInsertRow</a>&gt;&gt;&amp; row_list() const;
  int row_list_size() const;
  const <a href="#ResolvedInsertRow">ResolvedInsertRow</a>* row_list(int i) const;
};
</code></pre></p>

### ResolvedDeleteStmt
<a id="ResolvedDeleteStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents a DELETE statement or a nested DELETE inside an
// UPDATE statement.
//
// For top-level DELETE statements, &lt;table_scan&gt; gives the table to
// scan and creates ResolvedColumns for its columns.  Those columns can
// be referenced inside the &lt;where_expr&gt;.
//
// For nested DELETEs, there is no &lt;table_scan&gt;.  The &lt;where_expr&gt; can
// only reference:
//   (1) the element_column from the ResolvedUpdateItem containing this
//       statement,
//   (2) columns from the outer statements, and
//   (3) (optionally) &lt;array_offset_column&gt;, which represents the 0-based
//       offset of the array element being modified.
//
// &lt;where_expr&gt; is required.
//
// If &lt;returning&gt; is present, the DELETE statement will return deleted rows
// back. It can only occur on top-level statements.
//
// This returning clause has a &lt;output_column_list&gt; to represent the data
// sent back to clients. It can only acccess columns from the &lt;table_scan&gt;.</font>
class ResolvedDeleteStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DELETE_STMT;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

  const <a href="#ResolvedAssertRowsModified">ResolvedAssertRowsModified</a>* assert_rows_modified() const;

  const <a href="#ResolvedReturningClause">ResolvedReturningClause</a>* returning() const;

  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* array_offset_column() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* where_expr() const;
};
</code></pre></p>

### ResolvedUpdateItem
<a id="ResolvedUpdateItem"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents one item inside the SET clause of an UPDATE.
//
// The entity being updated is specified by &lt;target&gt;.
//
// For a regular
//   SET {target} = {expression} | DEFAULT
// clause (not including an array element update like SET a[OFFSET(0)] = 5),
// &lt;target&gt; and &lt;set_value&gt; will be present, and all other fields will be
// unset.
//
// For an array element update (e.g. SET a.b[&lt;expr&gt;].c = &lt;value&gt;),
//   - &lt;target&gt; is set to the array,
//   - &lt;element_column&gt; is a new ResolvedColumn that can be used inside the
//     update items to refer to the array element.
//   - &lt;array_update_list&gt; will have a node corresponding to the offset into
//     that array and the modification to that array element.
// For example, for SET a.b[&lt;expr&gt;].c = &lt;value&gt;, we have
//    ResolvedUpdateItem
//    +-&lt;target&gt; = a.b
//    +-&lt;element_column&gt; = &lt;x&gt;
//    +-&lt;array_update_list&gt;
//      +-ResolvedUpdateArrayItem
//        +-&lt;offset&gt; = &lt;expr&gt;
//        +-&lt;update_item&gt; = ResolvedUpdateItem
//          +-&lt;target&gt; = &lt;x&gt;.c
//          +-&lt;set_value&gt; = &lt;value&gt;
//
// The engine is required to fail the update if there are two elements of
// &lt;array_update_list&gt; corresponding to offset expressions that evaluate to
// the same value. These are considered to be conflicting updates.
//
// Multiple updates to the same array are always represented as multiple
// elements of &lt;array_update_list&gt; under a single ResolvedUpdateItem
// corresponding to that array. &lt;array_update_list&gt; will only have one
// element for modifications to an array-valued subfield of an array element.
// E.g., for SET a[&lt;expr1&gt;].b[&lt;expr2&gt;] = 5, a[&lt;expr3&gt;].b[&lt;expr4&gt;] = 6, we
// will have:
//     ResolvedUpdateItem
//     +-&lt;target&gt; = a
//     +-&lt;element_column&gt; = x
//     +-&lt;array_update_list&gt;
//       +-ResolvedUpdateArrayItem
//         +-&lt;offset&gt; = &lt;expr1&gt;
//         +-ResolvedUpdateItem for &lt;x&gt;.b[&lt;expr2&gt;] = 5
//       +-ResolvedUpdateArrayItem
//         +-&lt;offset&gt; = &lt;expr3&gt;
//         +-ResolvedUpdateItem for &lt;x&gt;.b[&lt;expr4&gt;] = 6
// The engine must give a runtime error if &lt;expr1&gt; and &lt;expr3&gt; evaluate to
// the same thing. Notably, it does not have to understand that the
// two ResolvedUpdateItems corresponding to &#34;b&#34; refer to the same array iff
// &lt;expr1&gt; and &lt;expr3&gt; evaluate to the same thing.
//
// TODO: Consider allowing the engine to execute an update like
// SET a[&lt;expr1&gt;].b = 1, a[&lt;expr2&gt;].c = 2 even if &lt;expr1&gt; == &lt;expr2&gt; since
// &#34;b&#34; and &#34;c&#34; do not overlap. Also consider allowing a more complex example
// like SET a[&lt;expr1&gt;].b[&lt;expr2&gt;] = ...,
// a[&lt;expr3&gt;].b[&lt;expr4&gt;].c[&lt;expr5&gt;] = ... even if &lt;expr1&gt; == &lt;expr3&gt;, as long
// as &lt;expr2&gt; != &lt;expr4&gt; in that case.
//
// For nested DML, &lt;target&gt; and &lt;element_column&gt; will both be set, and one or
// more of the nested statement lists will be non-empty. &lt;target&gt; must have
// ARRAY type, and &lt;element_column&gt; introduces a ResolvedColumn representing
// elements of that array. The nested statement lists will always be empty in
// a ResolvedUpdateItem child of a ResolvedUpdateArrayItem node.
//
// See (broken link) for more detail.</font>
class ResolvedUpdateItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UPDATE_ITEM;

<font color="brown">  // The target entity to be updated.
  //
  // This is an expression evaluated using the ResolvedColumns visible
  // inside this statement.  This expression can contain only
  // ResolvedColumnRefs, ResolvedGetProtoField and
  // ResolvedGetStructField nodes.
  //
  // In a top-level UPDATE, the expression always starts with a
  // ResolvedColumnRef referencing a column from the statement&#39;s
  // TableScan.
  //
  // In a nested UPDATE, the expression always starts with a
  // ResolvedColumnRef referencing the element_column from the
  // ResolvedUpdateItem containing this scan.
  //
  // This node is also used to represent a modification of a single
  // array element (when it occurs as a child of a
  // ResolvedUpdateArrayItem node).  In that case, the expression
  // starts with a ResolvedColumnRef referencing the &lt;element_column&gt;
  // from its grandparent ResolvedUpdateItem. (E.g., for &#34;SET a[&lt;expr&gt;]
  // = 5&#34;, the grandparent ResolvedUpdateItem has &lt;target&gt; &#34;a&#34;, the
  // parent ResolvedUpdateArrayItem has offset &lt;expr&gt;, and this node
  // has &lt;set_value&gt; 5 and target corresponding to the grandparent&#39;s
  // &lt;element_column&gt; field.)
  //
  // For either a nested UPDATE or an array modification, there may be
  // a path of field accesses after the initial ResolvedColumnRef,
  // represented by a chain of GetField nodes.
  //
  // NOTE: We use the same GetField nodes as we do for queries, but
  // they are not treated the same.  Here, they express a path inside
  // an object that is being mutated, so they have reference semantics.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* target() const;

<font color="brown">  // Set the target entity to this value.  The types must match.
  // This can contain the same columns that can appear in the
  // &lt;where_expr&gt; of the enclosing ResolvedUpdateStmt.
  //
  // This is mutually exclusive with all fields below, which are used
  // for nested updates only.</font>
  const <a href="#ResolvedDMLValue">ResolvedDMLValue</a>* set_value() const;

<font color="brown">  // The ResolvedColumn introduced to represent the elements of the
  // array being updated.  This works similarly to
  // ArrayScan::element_column.
  //
  // &lt;target&gt; must have array type, and this column has the array&#39;s
  // element type.
  //
  // This column can be referenced inside the nested statements below.</font>
  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* element_column() const;

<font color="brown">  // Array element modifications to apply. Each item runs on the value
  // of &lt;element_column&gt; specified by ResolvedUpdateArrayItem.offset.
  // This field is always empty if the analyzer option
  // FEATURE_V_1_2_ARRAY_ELEMENTS_WITH_SET is disabled.
  //
  // The engine must fail if two elements in this list have offset
  // expressions that evaluate to the same value.
  // TODO: Consider generalizing this to allow
  // SET a[&lt;expr1&gt;].b = ..., a[&lt;expr2&gt;].c = ...</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUpdateArrayItem">ResolvedUpdateArrayItem</a>&gt;&gt;&amp; array_update_list() const;
  int array_update_list_size() const;
  const <a href="#ResolvedUpdateArrayItem">ResolvedUpdateArrayItem</a>* array_update_list(int i) const;

<font color="brown">  // Nested DELETE statements to apply.  Each delete runs on one value
  // of &lt;element_column&gt; and may choose to delete that array element.
  //
  // DELETEs are applied before INSERTs or UPDATEs.
  //
  // It is legal for the same input element to match multiple DELETEs.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedDeleteStmt">ResolvedDeleteStmt</a>&gt;&gt;&amp; delete_list() const;
  int delete_list_size() const;
  const <a href="#ResolvedDeleteStmt">ResolvedDeleteStmt</a>* delete_list(int i) const;

<font color="brown">  // Nested UPDATE statements to apply.  Each update runs on one value
  // of &lt;element_column&gt; and may choose to update that array element.
  //
  // UPDATEs are applied after DELETEs and before INSERTs.
  //
  // It is an error if any element is matched by multiple UPDATEs.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUpdateStmt">ResolvedUpdateStmt</a>&gt;&gt;&amp; update_list() const;
  int update_list_size() const;
  const <a href="#ResolvedUpdateStmt">ResolvedUpdateStmt</a>* update_list(int i) const;

<font color="brown">  // Nested INSERT statements to apply.  Each insert will produce zero
  // or more values for &lt;element_column&gt;.
  //
  // INSERTs are applied after DELETEs and UPDATEs.
  //
  // For nested UPDATEs, insert_mode will always be the default, and
  // has no effect.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedInsertStmt">ResolvedInsertStmt</a>&gt;&gt;&amp; insert_list() const;
  int insert_list_size() const;
  const <a href="#ResolvedInsertStmt">ResolvedInsertStmt</a>* insert_list(int i) const;
};
</code></pre></p>

### ResolvedUpdateArrayItem
<a id="ResolvedUpdateArrayItem"></a>

<p><pre><code class="lang-c++">
<font color="brown">// For an array element modification, this node represents the offset
// expression and the modification, but not the array. E.g., for
// SET a[&lt;expr&gt;] = 5, this node represents a modification of &#34;= 5&#34; to offset
// &lt;expr&gt; of the array defined by the parent node.</font>
class ResolvedUpdateArrayItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UPDATE_ARRAY_ITEM;

<font color="brown">  // The array offset to be modified.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* offset() const;

<font color="brown">  // The modification to perform to the array element.</font>
  const <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>* update_item() const;
};
</code></pre></p>

### ResolvedUpdateStmt
<a id="ResolvedUpdateStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents an UPDATE statement, or a nested UPDATE inside an
// UPDATE statement.
//
// For top-level UPDATE statements, &lt;table_scan&gt; gives the table to
// scan and creates ResolvedColumns for its columns.  Those columns can be
// referenced in the &lt;update_item_list&gt;. The top-level UPDATE statement may
// also have &lt;from_scan&gt;, the output of which is joined with
// the &lt;table_scan&gt; using expressions in the &lt;where_expr&gt;. The columns
// exposed in the &lt;from_scan&gt; are visible in the right side of the
// expressions in the &lt;update_item_list&gt; and in the &lt;where_expr&gt;.
// &lt;array_offset_column&gt; is never set for top-level UPDATE statements.
//
// Top-level UPDATE statements will also have &lt;column_access_list&gt; populated.
// For each column, this vector indicates if the column was read and/or
// written. The columns in this vector match those of
// &lt;table_scan.column_list&gt;. If a column was not encountered when producing
// the resolved AST, then the value at that index will be
// ResolvedStatement::NONE.
//
// For nested UPDATEs, there is no &lt;table_scan&gt;.  The &lt;where_expr&gt; can
// only reference:
//   (1) the element_column from the ResolvedUpdateItem containing this
//       statement,
//   (2) columns from the outer statements, and
//   (3) (optionally) &lt;array_offset_column&gt;, which represents the 0-based
//       offset of the array element being modified.
// The left hand sides of the expressions in &lt;update_item_list&gt; can only
// reference (1). The right hand sides of those expressions can reference
// (1), (2), and (3).
//
// The updates in &lt;update_item_list&gt; will be non-overlapping.
// If there are multiple nested statements updating the same entity,
// they will be combined into one ResolvedUpdateItem.
//
// See (broken link) for more detail on nested DML.
//
// If &lt;returning&gt; is present, the UPDATE statement will return updated rows.
// &lt;returning&gt; can only occur on top-level statements.
//
// This returning clause has a &lt;output_column_list&gt; to represent the data
// sent back to clients. It can only access columns from the &lt;table_scan&gt;.
// The columns in &lt;from_scan&gt; are not allowed.
// TODO: allow columns in &lt;from_scan&gt; to be referenced.</font>
class ResolvedUpdateStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UPDATE_STMT;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

  const std::vector&lt;ObjectAccess&gt;&amp; column_access_list() const;
  int column_access_list_size() const;
  ObjectAccess column_access_list(int i) const;

  const <a href="#ResolvedAssertRowsModified">ResolvedAssertRowsModified</a>* assert_rows_modified() const;

  const <a href="#ResolvedReturningClause">ResolvedReturningClause</a>* returning() const;

  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* array_offset_column() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* where_expr() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>&gt;&gt;&amp; update_item_list() const;
  int update_item_list_size() const;
  const <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>* update_item_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* from_scan() const;
};
</code></pre></p>

### ResolvedMergeWhen
<a id="ResolvedMergeWhen"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This is used by ResolvedMergeStmt to represent one WHEN ... THEN clause
// within MERGE statement.
//
// There are three types of clauses, which are MATCHED, NOT_MATCHED_BY_SOURCE
// and NOT_MATCHED_BY_TARGET. The &lt;match_type&gt; must have one of these values.
//
// The &lt;match_expr&gt; defines an optional expression to apply to the join
// result of &lt;table_scan&gt; and &lt;from_scan&gt; of the parent ResolvedMergeStmt.
//
// Each ResolvedMergeWhen must define exactly one of three operations,
//   -- INSERT: &lt;action_type&gt; is ResolvedMergeWhen::INSERT.
//              Both &lt;insert_column_list&gt; and &lt;insert_row&gt; are non-empty.
//              The size of &lt;insert_column_list&gt; must be the same with the
//              value_list size of &lt;insert_row&gt;, and, the column data type
//              must match.
//   -- UPDATE: &lt;action_type&gt; is ResolvedMergeWhen::UPDATE.
//              &lt;update_item_list&gt; is non-empty.
//   -- DELETE: &lt;action_type&gt; is ResolvedMergeWhen::DELETE.
// The INSERT, UPDATE and DELETE operations are mutually exclusive.
//
// When &lt;match_type&gt; is MATCHED, &lt;action_type&gt; must be UPDATE or DELETE.
// When &lt;match_type&gt; is NOT_MATCHED_BY_TARGET, &lt;action_type&gt; must be INSERT.
// When &lt;match_type&gt; is NOT_MATCHED_BY_SOURCE, &lt;action_type&gt; must be UPDATE
// or DELETE.
//
// The column visibility within a ResolvedMergeWhen clause is defined as
// following,
//   -- When &lt;match_type&gt; is MATCHED,
//      -- All columns from &lt;table_scan&gt; and &lt;from_scan&gt; are allowed in
//         &lt;match_expr&gt;.
//      -- If &lt;action_type&gt; is UPDATE, only columns from &lt;table_scan&gt; are
//         allowed on left side of expressions in &lt;update_item_list&gt;.
//         All columns from &lt;table_scan&gt; and &lt;from_scan&gt; are allowed on right
//         side of expressions in &lt;update_item_list&gt;.
//   -- When &lt;match_type&gt; is NOT_MATCHED_BY_TARGET,
//      -- Only columns from &lt;from_scan&gt; are allowed in &lt;match_expr&gt;.
//      -- Only columns from &lt;table_scan&gt; are allowed in
//         &lt;insert_column_list&gt;.
//      -- Only columns from &lt;from_scan&gt; are allowed in &lt;insert_row&gt;.
//   -- When &lt;match_type&gt; is NOT_MATCHED_BY_SOURCE,
//      -- Only columns from &lt;table_scan&gt; are allowed in &lt;match_expr&gt;.
//      -- If &lt;action_type&gt; is UPDATE, only columns from &lt;table_scan&gt; are
//         allowed in &lt;update_item_list&gt;.</font>
class ResolvedMergeWhen : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MERGE_WHEN;

  typedef ResolvedMergeWhenEnums::MatchType MatchType;
  typedef ResolvedMergeWhenEnums::ActionType ActionType;
  static const MatchType MATCHED = ResolvedMergeWhenEnums::MATCHED;
  static const MatchType NOT_MATCHED_BY_SOURCE = ResolvedMergeWhenEnums::NOT_MATCHED_BY_SOURCE;
  static const MatchType NOT_MATCHED_BY_TARGET = ResolvedMergeWhenEnums::NOT_MATCHED_BY_TARGET;
  static const ActionType INSERT = ResolvedMergeWhenEnums::INSERT;
  static const ActionType UPDATE = ResolvedMergeWhenEnums::UPDATE;
  static const ActionType DELETE = ResolvedMergeWhenEnums::DELETE;

  MatchType match_type() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* match_expr() const;

  ActionType action_type() const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; insert_column_list() const;
  int insert_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> insert_column_list(int i) const;

  const <a href="#ResolvedInsertRow">ResolvedInsertRow</a>* insert_row() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>&gt;&gt;&amp; update_item_list() const;
  int update_item_list_size() const;
  const <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>* update_item_list(int i) const;
};
</code></pre></p>

### ResolvedMergeStmt
<a id="ResolvedMergeStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents a MERGE statement.
//
// &lt;table_scan&gt; gives the target table to scan and creates ResolvedColumns
// for its columns.
//
// &lt;column_access_list&gt; indicates for each column, whether it was read and/or
// written. The columns in this vector match those of
// &lt;table_scan.column_list&gt;. If a column was not encountered when producing
// the resolved AST, then the value at that index will be
// ResolvedStatement::NONE(0).
//
// The output of &lt;from_scan&gt; is joined with &lt;table_scan&gt; using the join
// expression &lt;merge_expr&gt;.
//
// The order of elements in &lt;when_clause_list&gt; matters, as they are executed
// sequentially. At most one of the &lt;when_clause_list&gt; clause will be applied
// to each row from &lt;table_scan&gt;.
//
// &lt;table_scan&gt;, &lt;from_scan&gt;, &lt;merge_expr&gt; and &lt;when_clause_list&gt; are
// required. &lt;when_clause_list&gt; must be non-empty.
//
// See (broken link) for more detail on MERGE statement.</font>
class ResolvedMergeStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MERGE_STMT;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

  const std::vector&lt;ObjectAccess&gt;&amp; column_access_list() const;
  int column_access_list_size() const;
  ObjectAccess column_access_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* from_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* merge_expr() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedMergeWhen">ResolvedMergeWhen</a>&gt;&gt;&amp; when_clause_list() const;
  int when_clause_list_size() const;
  const <a href="#ResolvedMergeWhen">ResolvedMergeWhen</a>* when_clause_list(int i) const;
};
</code></pre></p>

### ResolvedTruncateStmt
<a id="ResolvedTruncateStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents a TRUNCATE TABLE statement.
//
// Statement:
//   TRUNCATE TABLE &lt;table_name&gt; [WHERE &lt;boolean_expression&gt;]
//
// &lt;table_scan&gt; is a TableScan for the target table, which is used during
//              resolving and validation. Consumers can use either the table
//              object inside it or name_path to reference the table.
// &lt;where_expr&gt; boolean expression that can reference columns in
//              ResolvedColumns (which the TableScan creates); the
//              &lt;where_expr&gt; should always correspond to entire partitions,
//              and is optional.</font>
class ResolvedTruncateStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_TRUNCATE_STMT;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* where_expr() const;
};
</code></pre></p>

### ResolvedPrivilege
<a id="ResolvedPrivilege"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A grantable privilege.
//
// &lt;action_type&gt; is the type of privilege action, e.g. SELECT, INSERT, UPDATE
// or DELETE.
// &lt;unit_list&gt; is an optional list of units of the object (e.g. columns of a
// table) the privilege is restricted to. Privilege on the whole object
// should be granted/revoked if the list is empty.</font>
class ResolvedPrivilege : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PRIVILEGE;

  const std::string&amp; action_type() const;

  const std::vector&lt;std::string&gt;&amp; unit_list() const;
  int unit_list_size() const;
  std::string unit_list(int i) const;
};
</code></pre></p>

### ResolvedGrantOrRevokeStmt
<a id="ResolvedGrantOrRevokeStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Common superclass of GRANT/REVOKE statements.
//
// &lt;privilege_list&gt; is the list of privileges to be granted/revoked. ALL
// PRIVILEGES should be granted/fromed if it is empty.
// &lt;object_type&gt; is an optional string identifier, e.g., TABLE, VIEW.
// &lt;name_path&gt; is a vector of segments of the object identifier&#39;s pathname.
// &lt;grantee_list&gt; (DEPRECATED) is the list of grantees (strings).
// &lt;grantee_expr_list&gt; is the list of grantees, and may include parameters.
//
// Only one of &lt;grantee_list&gt; or &lt;grantee_expr_list&gt; will be populated,
// depending on whether or not the FEATURE_PARAMETERS_IN_GRANTEE_LIST
// is enabled.  The &lt;grantee_list&gt; is deprecated, and will be removed
// along with the corresponding FEATURE once all engines have migrated to
// use the &lt;grantee_expr_list&gt;.  Once &lt;grantee_expr_list&gt; is the only
// one, then it should be marked as NOT_IGNORABLE.</font>
class ResolvedGrantOrRevokeStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedPrivilege">ResolvedPrivilege</a>&gt;&gt;&amp; privilege_list() const;
  int privilege_list_size() const;
  const <a href="#ResolvedPrivilege">ResolvedPrivilege</a>* privilege_list(int i) const;

  const std::string&amp; object_type() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::string&gt;&amp; grantee_list() const;
  int grantee_list_size() const;
  std::string grantee_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; grantee_expr_list() const;
  int grantee_expr_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* grantee_expr_list(int i) const;
};
</code></pre></p>

### ResolvedGrantStmt
<a id="ResolvedGrantStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A GRANT statement. It represents the action to grant a list of privileges
// on a specific object to/from list of grantees.</font>
class ResolvedGrantStmt : public <a href="#ResolvedGrantOrRevokeStmt">ResolvedGrantOrRevokeStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRANT_STMT;

};
</code></pre></p>

### ResolvedRevokeStmt
<a id="ResolvedRevokeStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A REVOKE statement. It represents the action to revoke a list of
// privileges on a specific object to/from list of grantees.</font>
class ResolvedRevokeStmt : public <a href="#ResolvedGrantOrRevokeStmt">ResolvedGrantOrRevokeStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_REVOKE_STMT;

};
</code></pre></p>

### ResolvedAlterObjectStmt
<a id="ResolvedAlterObjectStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Common super class for statements:
//   ALTER &lt;object&gt; [IF EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;
//
// &lt;name_path&gt; is a vector giving the identifier path in the table &lt;name&gt;.
// &lt;alter_action_list&gt; is a vector of actions to be done to the object.
// &lt;is_if_exists&gt; silently ignores the &#34;name_path does not exist&#34; error.</font>
class ResolvedAlterObjectStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedAlterAction">ResolvedAlterAction</a>&gt;&gt;&amp; alter_action_list() const;
  int alter_action_list_size() const;
  const <a href="#ResolvedAlterAction">ResolvedAlterAction</a>* alter_action_list(int i) const;

  bool is_if_exists() const;
};
</code></pre></p>

### ResolvedAlterDatabaseStmt
<a id="ResolvedAlterDatabaseStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//   ALTER DATABASE [IF EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;
//
// This statement could be used to change the database level options.</font>
class ResolvedAlterDatabaseStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_DATABASE_STMT;

};
</code></pre></p>

### ResolvedAlterMaterializedViewStmt
<a id="ResolvedAlterMaterializedViewStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
// ALTER MATERIALIZED VIEW [IF EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;</font>
class ResolvedAlterMaterializedViewStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_MATERIALIZED_VIEW_STMT;

};
</code></pre></p>

### ResolvedAlterSchemaStmt
<a id="ResolvedAlterSchemaStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
// ALTER SCHEMA [IF NOT EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;;</font>
class ResolvedAlterSchemaStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_SCHEMA_STMT;

};
</code></pre></p>

### ResolvedAlterTableStmt
<a id="ResolvedAlterTableStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
// ALTER TABLE [IF EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;</font>
class ResolvedAlterTableStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_TABLE_STMT;

};
</code></pre></p>

### ResolvedAlterViewStmt
<a id="ResolvedAlterViewStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
// ALTER VIEW [IF EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;</font>
class ResolvedAlterViewStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_VIEW_STMT;

};
</code></pre></p>

### ResolvedAlterAction
<a id="ResolvedAlterAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A common super class for all actions in statement ALTER &lt;object&gt;</font>
class ResolvedAlterAction : public <a href="#ResolvedArgument">ResolvedArgument</a> {
};
</code></pre></p>

### ResolvedSetOptionsAction
<a id="ResolvedSetOptionsAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// SET OPTIONS action for ALTER &lt;object&gt; statement
//
// &lt;option_list&gt; has engine-specific directives that specify how to
//               alter the metadata for this object.</font>
class ResolvedSetOptionsAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SET_OPTIONS_ACTION;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedAddColumnAction
<a id="ResolvedAddColumnAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// ADD COLUMN action for ALTER TABLE statement</font>
class ResolvedAddColumnAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ADD_COLUMN_ACTION;

  bool is_if_not_exists() const;

  const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>* column_definition() const;
};
</code></pre></p>

### ResolvedAddConstraintAction
<a id="ResolvedAddConstraintAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// ADD CONSTRAINT for ALTER TABLE statement</font>
class ResolvedAddConstraintAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ADD_CONSTRAINT_ACTION;

  bool is_if_not_exists() const;

  const <a href="#ResolvedConstraint">ResolvedConstraint</a>* constraint() const;

  const Table* table() const;
};
</code></pre></p>

### ResolvedDropConstraintAction
<a id="ResolvedDropConstraintAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// DROP CONSTRAINT for ALTER TABLE statement</font>
class ResolvedDropConstraintAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_CONSTRAINT_ACTION;

  bool is_if_exists() const;

  const std::string&amp; name() const;
};
</code></pre></p>

### ResolvedDropPrimaryKeyAction
<a id="ResolvedDropPrimaryKeyAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// DROP PRIMARY KEY [IF EXISTS] for ALTER TABLE statement</font>
class ResolvedDropPrimaryKeyAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_PRIMARY_KEY_ACTION;

  bool is_if_exists() const;
};
</code></pre></p>

### ResolvedAlterColumnOptionsAction
<a id="ResolvedAlterColumnOptionsAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This ALTER action:
//   ALTER COLUMN [IF EXISTS] &lt;column&gt; SET OPTIONS &lt;options_list&gt;
//
// &lt;is_if_exists&gt; silently ignore the &#34;&lt;column&gt; not found&#34; error.
// &lt;column&gt; the name of the column.
// &lt;options_list&gt; has engine-specific directives that specify how to
//                alter the metadata for a column.</font>
class ResolvedAlterColumnOptionsAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_COLUMN_OPTIONS_ACTION;

  bool is_if_exists() const;

  const std::string&amp; column() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedAlterColumnDropNotNullAction
<a id="ResolvedAlterColumnDropNotNullAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This ALTER action:
//   ALTER COLUMN [IF EXISTS] &lt;column&gt; DROP NOT NULL
//
// Removes the NOT NULL constraint from the given column.
//
// &lt;is_if_exists&gt; silently ignore the &#34;&lt;column&gt; not found&#34; error.
// &lt;column&gt; is the name of the column.</font>
class ResolvedAlterColumnDropNotNullAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_COLUMN_DROP_NOT_NULL_ACTION;

  bool is_if_exists() const;

  const std::string&amp; column() const;
};
</code></pre></p>

### ResolvedAlterColumnSetDataTypeAction
<a id="ResolvedAlterColumnSetDataTypeAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// ALTER COLUMN SET DATA TYPE action for ALTER TABLE statement.</font>
class ResolvedAlterColumnSetDataTypeAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_COLUMN_SET_DATA_TYPE_ACTION;

<font color="brown">  // Indicates whether the IF EXISTS clause was included in the
  // ALTER COLUMN expression.</font>
  bool is_if_exists() const;

<font color="brown">  // The name of the column whose data type is changing.</font>
  const std::string&amp; column() const;

<font color="brown">  // The new type for the column.</font>
  const Type* updated_type() const;

<font color="brown">  // The new type parameters for the column, if the new type has
  // parameters. Note that unlike with CREATE TABLE, the child_list is
  // populated for ARRAY and STRUCT types.</font>
  const TypeParameters&amp; updated_type_parameters() const;
};
</code></pre></p>

### ResolvedDropColumnAction
<a id="ResolvedDropColumnAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// DROP COLUMN action for ALTER TABLE statement
//
// &lt;name&gt; is the name of the column to drop.</font>
class ResolvedDropColumnAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_COLUMN_ACTION;

  bool is_if_exists() const;

  const std::string&amp; name() const;
};
</code></pre></p>

### ResolvedSetAsAction
<a id="ResolvedSetAsAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// SET AS action for generic ALTER &lt;entity_type&gt; statement.
// Exactly one of &lt;entity_body_json&gt;, &lt;entity_body_text&gt; should be non-empty.
//
// &lt;entity_body_json&gt; is a JSON literal to be interpreted by engine.
// &lt;entity_body_text&gt; is a text literal to be interpreted by engine.</font>
class ResolvedSetAsAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SET_AS_ACTION;

  const std::string&amp; entity_body_json() const;

  const std::string&amp; entity_body_text() const;
};
</code></pre></p>

### ResolvedAlterTableSetOptionsStmt
<a id="ResolvedAlterTableSetOptionsStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//   ALTER TABLE [IF EXISTS] &lt;name&gt; SET OPTIONS (...)
//
// NOTE: This is deprecated in favor of ResolvedAlterTableStmt.
//
// &lt;name_path&gt; is a vector giving the identifier path in the table &lt;name&gt;.
// &lt;option_list&gt; has engine-specific directives that specify how to
//               alter the metadata for this table.
// &lt;is_if_exists&gt; silently ignore the &#34;name_path does not exist&#34; error.</font>
class ResolvedAlterTableSetOptionsStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_TABLE_SET_OPTIONS_STMT;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  bool is_if_exists() const;
};
</code></pre></p>

### ResolvedRenameStmt
<a id="ResolvedRenameStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: RENAME &lt;object_type&gt; &lt;old_name_path&gt; TO &lt;new_name_path&gt;;
//
// &lt;object_type&gt; is an string identifier,
//               e.g., &#34;TABLE&#34;, &#34;VIEW&#34;, &#34;INDEX&#34;, &#34;FUNCTION&#34;, &#34;TYPE&#34;, etc.
// &lt;old_name_path&gt; is a vector giving the identifier path for the object to
//                 be renamed.
// &lt;new_name_path&gt; is a vector giving the identifier path for the object to
//                 be renamed to.</font>
class ResolvedRenameStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RENAME_STMT;

  const std::string&amp; object_type() const;

  const std::vector&lt;std::string&gt;&amp; old_name_path() const;
  int old_name_path_size() const;
  std::string old_name_path(int i) const;

  const std::vector&lt;std::string&gt;&amp; new_name_path() const;
  int new_name_path_size() const;
  std::string new_name_path(int i) const;
};
</code></pre></p>

### ResolvedCreateRowAccessPolicyStmt
<a id="ResolvedCreateRowAccessPolicyStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: CREATE [OR REPLACE] ROW ACCESS POLICY [IF NOT EXISTS]
//                 [&lt;name&gt;] ON &lt;target_name_path&gt;
//                 [GRANT TO (&lt;grantee_list&gt;)]
//                 FILTER USING (&lt;predicate&gt;);
//
// &lt;create_mode&gt; indicates if this was CREATE, CREATE OR REPLACE, or
//               CREATE IF NOT EXISTS.
// &lt;name&gt; is the name of the row access policy to be created or an empty
//        string.
// &lt;target_name_path&gt; is a vector giving the identifier path of the target
//                    table.
// &lt;table_scan&gt; is a TableScan for the target table, which is used during
//              resolving and validation. Consumers can use either the table
//              object inside it or target_name_path to reference the table.
// &lt;grantee_list&gt; (DEPRECATED) is the list of user principals the policy
//                should apply to.
// &lt;grantee_expr_list&gt; is the list of user principals the policy should
//                     apply to, and may include parameters.
// &lt;predicate&gt; is a boolean expression that selects the rows that are being
//             made visible.
// &lt;predicate_str&gt; is the string form of the predicate.
//
// Only one of &lt;grantee_list&gt; or &lt;grantee_expr_list&gt; will be populated,
// depending on whether or not the FEATURE_PARAMETERS_IN_GRANTEE_LIST
// is enabled.  The &lt;grantee_list&gt; is deprecated, and will be removed
// along with the corresponding FEATURE once all engines have migrated to
// use the &lt;grantee_expr_list&gt;.  Once &lt;grantee_expr_list&gt; is the only
// one, then it should be marked as NOT_IGNORABLE.</font>
class ResolvedCreateRowAccessPolicyStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_ROW_ACCESS_POLICY_STMT;

  typedef ResolvedCreateStatement::CreateMode CreateMode;

  CreateMode create_mode() const;

  const std::string&amp; name() const;

  const std::vector&lt;std::string&gt;&amp; target_name_path() const;
  int target_name_path_size() const;
  std::string target_name_path(int i) const;

  const std::vector&lt;std::string&gt;&amp; grantee_list() const;
  int grantee_list_size() const;
  std::string grantee_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; grantee_expr_list() const;
  int grantee_expr_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* grantee_expr_list(int i) const;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* predicate() const;

  const std::string&amp; predicate_str() const;
};
</code></pre></p>

### ResolvedDropRowAccessPolicyStmt
<a id="ResolvedDropRowAccessPolicyStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//     DROP ROW ACCESS POLICY &lt;name&gt; ON &lt;target_name_path&gt;; or
//     DROP ALL ROW [ACCESS] POLICIES ON &lt;target_name_path&gt;;
//
// &lt;is_drop_all&gt; indicates that all policies should be dropped.
// &lt;is_if_exists&gt; silently ignore the &#34;policy &lt;name&gt; does not exist&#34; error.
//                This is not allowed if is_drop_all is true.
// &lt;name&gt; is the name of the row policy to be dropped or an empty string.
// &lt;target_name_path&gt; is a vector giving the identifier path of the target
//                    table.</font>
class ResolvedDropRowAccessPolicyStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_ROW_ACCESS_POLICY_STMT;

  bool is_drop_all() const;

  bool is_if_exists() const;

  const std::string&amp; name() const;

  const std::vector&lt;std::string&gt;&amp; target_name_path() const;
  int target_name_path_size() const;
  std::string target_name_path(int i) const;
};
</code></pre></p>

### ResolvedDropSearchIndexStmt
<a id="ResolvedDropSearchIndexStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// DROP SEARCH INDEX [IF EXISTS] &lt;name&gt; [ON &lt;table_name_path&gt;];
//
// &lt;name&gt; is the name of the search index to be dropped.
// &lt;table_name_path&gt; is a vector giving the identifier path of the target
//                   table.</font>
class ResolvedDropSearchIndexStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_SEARCH_INDEX_STMT;

  bool is_if_exists() const;

  const std::string&amp; name() const;

  const std::vector&lt;std::string&gt;&amp; table_name_path() const;
  int table_name_path_size() const;
  std::string table_name_path(int i) const;
};
</code></pre></p>

### ResolvedGrantToAction
<a id="ResolvedGrantToAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// GRANT TO action for ALTER ROW ACCESS POLICY statement
//
// &lt;grantee_expr_list&gt; is the list of grantees, and may include parameters.</font>
class ResolvedGrantToAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRANT_TO_ACTION;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; grantee_expr_list() const;
  int grantee_expr_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* grantee_expr_list(int i) const;
};
</code></pre></p>

### ResolvedFilterUsingAction
<a id="ResolvedFilterUsingAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// FILTER USING action for ALTER ROW ACCESS POLICY statement
//
// &lt;predicate&gt; is a boolean expression that selects the rows that are being
//             made visible.
// &lt;predicate_str&gt; is the string form of the predicate.</font>
class ResolvedFilterUsingAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FILTER_USING_ACTION;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* predicate() const;

  const std::string&amp; predicate_str() const;
};
</code></pre></p>

### ResolvedRevokeFromAction
<a id="ResolvedRevokeFromAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// REVOKE FROM action for ALTER ROW ACCESS POLICY statement
//
// &lt;revokee_expr_list&gt; is the list of revokees, and may include parameters.
// &lt;is_revoke_from_all&gt; is a boolean indicating whether it was a REVOKE FROM
//                      ALL statement.</font>
class ResolvedRevokeFromAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_REVOKE_FROM_ACTION;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; revokee_expr_list() const;
  int revokee_expr_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* revokee_expr_list(int i) const;

  bool is_revoke_from_all() const;
};
</code></pre></p>

### ResolvedRenameToAction
<a id="ResolvedRenameToAction"></a>

<p><pre><code class="lang-c++">
<font color="brown">// RENAME TO action for ALTER ROW ACCESS POLICY statement
//         and ALTER TABLE statement
//
// &lt;new_path&gt; is the new name of the row access policy,
//         or the new path of the table.</font>
class ResolvedRenameToAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RENAME_TO_ACTION;

  const std::vector&lt;std::string&gt;&amp; new_path() const;
  int new_path_size() const;
  std::string new_path(int i) const;
};
</code></pre></p>

### ResolvedAlterRowAccessPolicyStmt
<a id="ResolvedAlterRowAccessPolicyStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//     ALTER ROW ACCESS POLICY [IF EXISTS]
//     &lt;name&gt; ON &lt;name_path&gt;
//     &lt;alter_action_list&gt;
//
// &lt;name&gt; is the name of the row access policy to be altered, scoped to the
//        table in the base &lt;name_path&gt;.
// &lt;table_scan&gt; is a TableScan for the target table, which is used during
//              resolving and validation. Consumers can use either the table
//              object inside it or base &lt;name_path&gt; to reference the table.</font>
class ResolvedAlterRowAccessPolicyStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_ROW_ACCESS_POLICY_STMT;

  const std::string&amp; name() const;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;
};
</code></pre></p>

### ResolvedAlterAllRowAccessPoliciesStmt
<a id="ResolvedAlterAllRowAccessPoliciesStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//     ALTER ALL ROW ACCESS POLICIES ON &lt;name_path&gt; &lt;alter_action_list&gt;
//
// &lt;name_path&gt; is a vector giving the identifier path in the table name.
// &lt;alter_action_list&gt; is a vector of actions to be done to the object. It
//                     must have exactly one REVOKE FROM action with either
//                     a non-empty grantee list or &#39;all&#39;.
// &lt;table_scan&gt; is a TableScan for the target table, which is used during
//              resolving and validation. Consumers can use either the table
//              object inside it or base &lt;name_path&gt; to reference the table.</font>
class ResolvedAlterAllRowAccessPoliciesStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_ALL_ROW_ACCESS_POLICIES_STMT;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;
};
</code></pre></p>

### ResolvedCreateConstantStmt
<a id="ResolvedCreateConstantStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement creates a user-defined named constant:
// CREATE [OR REPLACE] [TEMP | TEMPORARY | PUBLIC | PRIVATE] CONSTANT
//   [IF NOT EXISTS] &lt;name_path&gt; = &lt;expression&gt;
//
// &lt;name_path&gt; is the identifier path of the named constants.
// &lt;expr&gt; is the expression that determines the type and the value of the
//        named constant. Note that &lt;expr&gt; need not be constant. Its value
//        is bound to the named constant which is then treated as
//        immutable. &lt;expr&gt; can be evaluated at the time this statement is
//        processed or later (lazy evaluation during query execution).</font>
class ResolvedCreateConstantStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_CONSTANT_STMT;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;
};
</code></pre></p>

### ResolvedCreateFunctionStmt
<a id="ResolvedCreateFunctionStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement creates a user-defined function:
//   CREATE [TEMP] FUNCTION [IF NOT EXISTS] &lt;name_path&gt; (&lt;arg_list&gt;)
//     [RETURNS &lt;return_type&gt;] [&lt;determinism_level&gt;] [LANGUAGE &lt;language&gt;]
//     [AS &lt;code&gt; | AS ( &lt;function_expression&gt; )] [OPTIONS (&lt;option_list&gt;)]
//
//   &lt;name_path&gt; is the identifier path of the function.
//   &lt;has_explicit_return_type&gt; is true iff RETURNS clause is present.
//   &lt;return_type&gt; is the return type for the function, which can be any
//          valid ZetaSQL type, including ARRAY or STRUCT. It is inferred
//          from &lt;function_expression&gt; if not explicitly set.
//          TODO: Deprecate and remove this. The return type is
//          already specified by the &lt;signature&gt;.
//   &lt;argument_name_list&gt; The names of the function arguments.
//   &lt;signature&gt; is the FunctionSignature of the created function, with all
//          options.  This can be used to create a Function to load into a
//          Catalog for future queries.
//   &lt;is_aggregate&gt; is true if this is an aggregate function.  All arguments
//          are assumed to be aggregate input arguments that may vary for
//          every row.
//   &lt;language&gt; is the programming language used by the function. This field
//          is set to &#39;SQL&#39; for SQL functions and otherwise to the language
//          name specified in the LANGUAGE clause.
//   &lt;code&gt; is a string literal that contains the function definition.  Some
//          engines may allow this argument to be omitted for certain types
//          of external functions. This will always be set for SQL functions.
//   &lt;aggregate_expression_list&gt; is a list of SQL aggregate functions to
//          compute prior to computing the final &lt;function_expression&gt;.
//          See below.
//   &lt;function_expression&gt; is the resolved SQL expression invoked for the
//          function. This will be unset for external language functions. For
//          non-template SQL functions, this is a resolved representation of
//          the expression in &lt;code&gt;.
//   &lt;option_list&gt; has engine-specific directives for modifying functions.
//   &lt;sql_security&gt; is the declared security mode for the function. Values
//          include &#39;INVOKER&#39;, &#39;DEFINER&#39;.
//   &lt;determinism_level&gt; is the declared determinism level of the function.
//          Values are &#39;DETERMINISTIC&#39;, &#39;NOT DETERMINISTIC&#39;, &#39;IMMUTABLE&#39;,
//          &#39;STABLE&#39;, &#39;VOLATILE&#39;.
//
// Note that &lt;function_expression&gt; and &lt;code&gt; are both marked as IGNORABLE
// because an engine could look at either one (but might not look at both).
// An engine must look at one (and cannot ignore both) to be semantically
// valid, but there is currently no way to enforce that.
//
// For aggregate functions, &lt;is_aggregate&gt; will be true.
// Aggregate functions will only occur if LanguageOptions has
// FEATURE_CREATE_AGGREGATE_FUNCTION enabled.
//
// Arguments to aggregate functions must have
// &lt;FunctionSignatureArgumentTypeOptions::is_not_aggregate&gt; true or false.
// Non-aggregate arguments must be passed constant values only.
//
// For SQL aggregate functions, there will be both an
// &lt;aggregate_expression_list&gt;, with aggregate expressions to compute first,
// and then a final &lt;function_expression&gt; to compute on the results
// of the aggregates.  Each aggregate expression is a
// ResolvedAggregateFunctionCall, and may reference any input arguments.
// Each ResolvedComputedColumn in &lt;aggregate_expression_list&gt; gives the
// aggregate expression a column id.  The final &lt;function_expression&gt; can
// reference these created aggregate columns, and any input arguments
// with &lt;argument_kind&gt;=NOT_AGGREGATE.
//
// For example, with
//   CREATE TEMP FUNCTION my_avg(x) = (SUM(x) / COUNT(x));
// we would have an &lt;aggregate_expression_list&gt; with
//   agg1#1 := SUM(ResolvedArgumentRef(x))
//   agg2#2 := COUNT(ResolvedArgumentRef(x))
// and a &lt;function_expression&gt;
//   ResolvedColumnRef(agg1#1) / ResolvedColumnRef(agg2#2)
//
// For example, with
//   CREATE FUNCTION scaled_avg(x,y NOT AGGREGATE) = (SUM(x) / COUNT(x) * y);
// we would have an &lt;aggregate_expression_list&gt; with
//   agg1#1 := SUM(ResolvedArgumentRef(x))
//   agg2#2 := COUNT(ResolvedArgumentRef(x))
// and a &lt;function_expression&gt;
//   ResolvedColumnRef(agg1#1) / ResolvedColumnRef(agg2#2) * ResolvedArgumentRef(y)
//
// When resolving a query that calls an aggregate UDF, the query will
// have a ResolvedAggregateScan that invokes the UDF function.  The engine
// should remove the UDF aggregate function from the &lt;aggregate_list&gt;, and
// instead compute the additional aggregates from the
// UDF&#39;s &lt;aggregate_expression_list&gt;, and then add an additional Project
// to compute the final &lt;function_expression&gt;, which should produce the
// value for the original ResolvedAggregateScan&#39;s computed column for the
// UDF.  Some rewrites of the ResolvedColumn references inside the UDF will
// be required.  TODO If using ResolvedColumns makes this renaming
// too complicated, we could switch to use ResolvedArgumentRefs, or
// something new.</font>
class ResolvedCreateFunctionStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_FUNCTION_STMT;

  // Converts the function's determinism level into a volatility.
  // Functions with unspecified/non deterministic/volatile
  // specifiers are considered volatile, functions with deterministic
  // and immutable specifiers are considered immutable and functions
  // with the stable specifier are considered stable.
  FunctionEnums::Volatility volatility() const;

  bool has_explicit_return_type() const;

  const Type* return_type() const;

  const std::vector&lt;std::string&gt;&amp; argument_name_list() const;
  int argument_name_list_size() const;
  std::string argument_name_list(int i) const;

  const FunctionSignature&amp; signature() const;

  bool is_aggregate() const;

  const std::string&amp; language() const;

  const std::string&amp; code() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; aggregate_expression_list() const;
  int aggregate_expression_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* aggregate_expression_list(int i) const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* function_expression() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  SqlSecurity sql_security() const;

  DeterminismLevel determinism_level() const;
};
</code></pre></p>

### ResolvedArgumentDef
<a id="ResolvedArgumentDef"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents an argument definition, e.g. in a function&#39;s argument
// list.
//
// &lt;name&gt; is the name of the argument; optional for DROP FUNCTION statements.
// &lt;type&gt; is the type of the argument.
// &lt;argument_kind&gt; indicates what kind of argument this is, including scalar
//         vs aggregate.  NOT_AGGREGATE means this is a non-aggregate
//         argument in an aggregate function, which can only passed constant
//         values only.
//
// NOTE: Statements that create functions now include a FunctionSignature
// directly, and an argument_name_list if applicable.  These completely
// describe the function signature, so the ResolvedArgumentDef list can
// be considered unnecessary and deprecated.
// TODO We could remove this node in the future.</font>
class ResolvedArgumentDef : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ARGUMENT_DEF;

  typedef ResolvedArgumentDefEnums::ArgumentKind ArgumentKind;
  static const ArgumentKind SCALAR = ResolvedArgumentDefEnums::SCALAR;
  static const ArgumentKind AGGREGATE = ResolvedArgumentDefEnums::AGGREGATE;
  static const ArgumentKind NOT_AGGREGATE = ResolvedArgumentDefEnums::NOT_AGGREGATE;

  const std::string&amp; name() const;

  const Type* type() const;

  ArgumentKind argument_kind() const;
};
</code></pre></p>

### ResolvedArgumentRef
<a id="ResolvedArgumentRef"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents an argument reference, e.g. in a function&#39;s body.
// &lt;name&gt; is the name of the argument.
// &lt;argument_kind&gt; is the ArgumentKind from the ResolvedArgumentDef.
//         For scalar functions, this is always SCALAR.
//         For aggregate functions, it can be AGGREGATE or NOT_AGGREGATE.
//         If NOT_AGGREGATE, then this is a non-aggregate argument
//         to an aggregate function, which has one constant value
//         for the entire function call (over all rows in all groups).
//         (This is copied from the ResolvedArgumentDef for convenience.)</font>
class ResolvedArgumentRef : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ARGUMENT_REF;

  typedef ResolvedArgumentDefEnums::ArgumentKind ArgumentKind;
  static const ArgumentKind SCALAR = ResolvedArgumentDefEnums::SCALAR;
  static const ArgumentKind AGGREGATE = ResolvedArgumentDefEnums::AGGREGATE;
  static const ArgumentKind NOT_AGGREGATE = ResolvedArgumentDefEnums::NOT_AGGREGATE;

  const std::string&amp; name() const;

  ArgumentKind argument_kind() const;
};
</code></pre></p>

### ResolvedCreateTableFunctionStmt
<a id="ResolvedCreateTableFunctionStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement creates a user-defined table-valued function:
//   CREATE [TEMP] TABLE FUNCTION [IF NOT EXISTS]
//     &lt;name_path&gt; (&lt;argument_name_list&gt;)
//     [RETURNS &lt;return_type&gt;]
//     [OPTIONS (&lt;option_list&gt;)]
//     [LANGUAGE &lt;language&gt;]
//     [AS &lt;code&gt; | AS ( &lt;query&gt; )]
//
//   &lt;argument_name_list&gt; contains the names of the function arguments.
//   &lt;signature&gt; is the FunctionSignature of the created function, with all
//          options.  This can be used to create a Function to load into a
//          Catalog for future queries.
//   &lt;option_list&gt; has engine-specific directives for modifying functions.
//   &lt;language&gt; is the programming language used by the function. This field
//          is set to &#39;SQL&#39; for SQL functions, to the language name specified
//          in the LANGUAGE clause if present, and to &#39;UNDECLARED&#39; if both
//          the LANGUAGE clause and query are not present.
//   &lt;code&gt; is an optional string literal that contains the function
//          definition.  Some engines may allow this argument to be omitted
//          for certain types of external functions.  This will always be set
//          for SQL functions.
//   &lt;query&gt; is the SQL query invoked for the function.  This will be unset
//          for external language functions. For non-templated SQL functions,
//          this is a resolved representation of the query in &lt;code&gt;.
//   &lt;output_column_list&gt; is the list of resolved output
//          columns returned by the table-valued function.
//   &lt;is_value_table&gt; If true, this function returns a value table.
//          Rather than producing rows with named columns, it produces
//          rows with a single unnamed value type. &lt;output_column_list&gt; will
//          have exactly one anonymous column (with no name).
//          See (broken link).
//   &lt;sql_security&gt; is the declared security mode for the function. Values
//          include &#39;INVOKER&#39;, &#39;DEFINER&#39;.
//   &lt;has_explicit_return_schema&gt; is true iff RETURNS clause is present.
//
// ----------------------
// Table-Valued Functions
// ----------------------
//
// This is a statement to create a new table-valued function. Each
// table-valued function returns an entire table as output instead of a
// single scalar value. Table-valued functions can only be created if
// LanguageOptions has FEATURE_CREATE_TABLE_FUNCTION enabled.
//
// For SQL table-valued functions that include a defined SQL body, the
// &lt;query&gt; is non-NULL and contains the resolved SQL body.
// In this case, &lt;output_column_list&gt; contains a list of the
// output columns of the SQL body. The &lt;query&gt; uses
// ResolvedArgumentRefs to refer to scalar arguments and
// ResolvedRelationArgumentScans to refer to relation arguments.
//
// The table-valued function may include RETURNS TABLE&lt;...&gt; to explicitly
// specify a schema for the output table returned by the function. If the
// function declaration includes a SQL body, then the names and types of the
// output columns of the corresponding &lt;query&gt; will have been
// coerced to exactly match 1:1 with the names and types of the columns
// specified in the RETURNS TABLE&lt;...&gt; section.
//
// When resolving a query that calls a table-valued function, the query will
// have a ResolvedTVFScan that invokes the function.
//
// Value tables: If the function declaration includes a value-table
// parameter, this is written as an argument of type &#34;TABLE&#34; where the table
// contains a single anonymous column with a type but no name. In this case,
// calls to the function may pass a (regular or value) table with a single
// (named or unnamed) column for any of these parameters, and ZetaSQL
// accepts these arguments as long as the column type matches.
//
// Similarly, if the CREATE TABLE FUNCTION statement includes a &#34;RETURNS
// TABLE&#34; section with a single column with no name, then this defines a
// value-table return type. The function then returns a value table as long
// as the SQL body returns a single column whose type matches (independent of
// whether the SQL body result is a value table or not, and whether the
// returned column is named or unnamed).
//
// --------------------------------
// Templated Table-Valued Functions
// --------------------------------
//
// ZetaSQL supports table-valued function declarations with parameters of
// type ANY TABLE. This type indicates that any schema is valid for tables
// passed for this parameter. In this case:
//
// * the IsTemplated() method of the &lt;signature&gt; field returns true,
// * the &lt;output_column_list&gt; field is empty,
// * the &lt;is_value_table&gt; field is set to a default value of false (since
//   ZetaSQL cannot analyze the function body in the presence of templated
//   parameters, it is not possible to detect this property yet),
//
// TODO: Update this description once ZetaSQL supports more types
// of templated function parameters. Currently only ANY TABLE is supported.</font>
class ResolvedCreateTableFunctionStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_TABLE_FUNCTION_STMT;

  const std::vector&lt;std::string&gt;&amp; argument_name_list() const;
  int argument_name_list_size() const;
  std::string argument_name_list(int i) const;

  const FunctionSignature&amp; signature() const;

  bool has_explicit_return_schema() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::string&amp; language() const;

  const std::string&amp; code() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

  bool is_value_table() const;

  SqlSecurity sql_security() const;
};
</code></pre></p>

### ResolvedRelationArgumentScan
<a id="ResolvedRelationArgumentScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents a relation argument reference in a table-valued function&#39;s
// body. The &#39;column_list&#39; of this ResolvedScan includes column names from
// the relation argument in the table-valued function signature.</font>
class ResolvedRelationArgumentScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RELATION_ARGUMENT_SCAN;

<font color="brown">  // This is the name of the relation argument for the table-valued
  // function.  It is used to match this relation argument reference in
  // a TVF SQL function body with one of possibly several relation
  // arguments in the TVF call.</font>
  const std::string&amp; name() const;

<font color="brown">  // If true, the result of this query is a value table. Rather than
  // producing rows with named columns, it produces rows with a single
  // unnamed value type. See (broken link).</font>
  bool is_value_table() const;
};
</code></pre></p>

### ResolvedArgumentList
<a id="ResolvedArgumentList"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: [ (&lt;arg_list&gt;) ];
//
// &lt;arg_list&gt; is an optional list of parameters.  If given, each parameter
//            may consist of a type, or a name and a type.
//
// NOTE: This can be considered deprecated in favor of the FunctionSignature
//       stored directly in the statement.
//
// NOTE: ResolvedArgumentList is not related to the ResolvedArgument class,
//       which just exists to organize node classes.</font>
class ResolvedArgumentList : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ARGUMENT_LIST;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedArgumentDef">ResolvedArgumentDef</a>&gt;&gt;&amp; arg_list() const;
  int arg_list_size() const;
  const <a href="#ResolvedArgumentDef">ResolvedArgumentDef</a>* arg_list(int i) const;
};
</code></pre></p>

### ResolvedFunctionSignatureHolder
<a id="ResolvedFunctionSignatureHolder"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This wrapper is used for an optional FunctionSignature.</font>
class ResolvedFunctionSignatureHolder : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FUNCTION_SIGNATURE_HOLDER;

  const FunctionSignature&amp; signature() const;
};
</code></pre></p>

### ResolvedDropFunctionStmt
<a id="ResolvedDropFunctionStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: DROP FUNCTION [IF EXISTS] &lt;name_path&gt;
//   [ (&lt;arguments&gt;) ];
//
// &lt;is_if_exists&gt; silently ignore the &#34;name_path does not exist&#34; error.
// &lt;name_path&gt; is the identifier path of the function to be dropped.
// &lt;arguments&gt; is an optional list of parameters.  If given, each parameter
//            may consist of a type, or a name and a type.  The name is
//            disregarded, and is allowed to permit copy-paste from CREATE
//            FUNCTION statements.
// &lt;signature&gt; is the signature of the dropped function.  Argument names and
//            argument options are ignored because only the types matter
//            for matching signatures in DROP FUNCTION.  The return type
//            in this signature will always be &lt;void&gt;, since return type
//            is ignored when matching signatures for DROP.
//            TODO &lt;arguments&gt; could be deprecated in favor of this.</font>
class ResolvedDropFunctionStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_FUNCTION_STMT;

  bool is_if_exists() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

<font color="brown">  // NOTE: arguments for DROP FUNCTION statements are matched only on
  // type; names for any arguments in ResolvedArgumentList will be set
  // to the empty string irrespective of whether or not argument names
  // were given in the DROP FUNCTION statement.</font>
  const <a href="#ResolvedArgumentList">ResolvedArgumentList</a>* arguments() const;

<font color="brown">  // NOTE: arguments for DROP FUNCTION statements are matched only on
  // type; names are irrelevant, so no argument names are saved to use
  // with this signature.  Additionally, the return type will always be
  // &lt;void&gt;, since return types are ignored for DROP FUNCTION.</font>
  const <a href="#ResolvedFunctionSignatureHolder">ResolvedFunctionSignatureHolder</a>* signature() const;
};
</code></pre></p>

### ResolvedDropTableFunctionStmt
<a id="ResolvedDropTableFunctionStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: DROP TABLE FUNCTION [IF EXISTS] &lt;name_path&gt;;
//
// &lt;is_if_exists&gt; silently ignore the &#34;name_path does not exist&#34; error.
// &lt;name_path&gt; is the identifier path of the function to be dropped.</font>
class ResolvedDropTableFunctionStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_TABLE_FUNCTION_STMT;

  bool is_if_exists() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;
};
</code></pre></p>

### ResolvedCallStmt
<a id="ResolvedCallStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: CALL &lt;procedure&gt;;
//
// &lt;procedure&gt; Procedure to call.
// &lt;signature&gt; Resolved FunctionSignature for this procedure.
// &lt;argument_list&gt; Procedure arguments.</font>
class ResolvedCallStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CALL_STMT;

  const Procedure* procedure() const;

  const FunctionSignature&amp; signature() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; argument_list() const;
  int argument_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* argument_list(int i) const;
};
</code></pre></p>

### ResolvedImportStmt
<a id="ResolvedImportStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: IMPORT &lt;import_kind&gt;
//                              [&lt;name_path&gt; [AS|INTO &lt;alias_path&gt;]
//                              |&lt;file_path&gt;]
//                        [&lt;option_list&gt;];
//
// &lt;import_kind&gt; The type of the object, currently supports MODULE and PROTO.
// &lt;name_path&gt;   The identifier path of the object to import, e.g., foo.bar,
//               used in IMPORT MODULE statement.
// &lt;file_path&gt;   The file path of the object to import, e.g., &#34;file.proto&#34;,
//               used in IMPORT PROTO statement.
// &lt;alias_path&gt;  The AS alias path for the object.
// &lt;into_alias_path&gt;  The INTO alias path for the object.
// &lt;option_list&gt; Engine-specific directives for the import.
//
// Either &lt;name_path&gt; or &lt;file_path&gt; will be populated but not both.
//       &lt;name_path&gt; will be populated for IMPORT MODULE.
//       &lt;file_path&gt; will be populated for IMPORT PROTO.
//
// At most one of &lt;alias_path&gt; or &lt;into_alias_path&gt; will be populated.
//       &lt;alias_path&gt; may be populated for IMPORT MODULE.
//       &lt;into_alias_path&gt; may be populated for IMPORT PROTO.
//
// IMPORT MODULE and IMPORT PROTO both support options.
//
// See (broken link) for more detail on IMPORT MODULE.
// See (broken link) for more detail on IMPORT PROTO.</font>
class ResolvedImportStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_IMPORT_STMT;

  typedef ResolvedImportStmtEnums::ImportKind ImportKind;
  static const ImportKind MODULE = ResolvedImportStmtEnums::MODULE;
  static const ImportKind PROTO = ResolvedImportStmtEnums::PROTO;
  static const ImportKind __ImportKind__switch_must_have_a_default__ = ResolvedImportStmtEnums::__ImportKind__switch_must_have_a_default__;

  std::string GetImportKindString() const;
  static std::string ImportKindToString(ImportKind kind);

  ImportKind import_kind() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::string&amp; file_path() const;

  const std::vector&lt;std::string&gt;&amp; alias_path() const;
  int alias_path_size() const;
  std::string alias_path(int i) const;

  const std::vector&lt;std::string&gt;&amp; into_alias_path() const;
  int into_alias_path_size() const;
  std::string into_alias_path(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedModuleStmt
<a id="ResolvedModuleStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement: MODULE &lt;name_path&gt; [&lt;option_list&gt;];
//
// &lt;name_path&gt; is the identifier path of the module.
// &lt;option_list&gt; Engine-specific directives for the module statement.
//
// See (broken link) for more detail on MODULEs.</font>
class ResolvedModuleStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MODULE_STMT;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedAggregateHavingModifier
<a id="ResolvedAggregateHavingModifier"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents a HAVING MAX or HAVING MIN modifier in an aggregate
// expression. If an aggregate has arguments (x HAVING {MAX/MIN} y),
// the aggregate will be computed over only the x values in the rows with the
// maximal/minimal values of y.
//
// &lt;kind&gt; the MAX/MIN kind of this HAVING
// &lt;having_expr&gt; the HAVING expression (y in the above example)</font>
class ResolvedAggregateHavingModifier : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_AGGREGATE_HAVING_MODIFIER;

  typedef ResolvedAggregateHavingModifierEnums::HavingModifierKind HavingModifierKind;
  static const HavingModifierKind INVALID = ResolvedAggregateHavingModifierEnums::INVALID;
  static const HavingModifierKind MAX = ResolvedAggregateHavingModifierEnums::MAX;
  static const HavingModifierKind MIN = ResolvedAggregateHavingModifierEnums::MIN;

  std::string GetHavingModifierKindString() const;
  static std::string HavingModifierKindToString(HavingModifierKind kind);

  HavingModifierKind kind() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* having_expr() const;
};
</code></pre></p>

### ResolvedCreateMaterializedViewStmt
<a id="ResolvedCreateMaterializedViewStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement:
//   CREATE MATERIALIZED VIEW &lt;name&gt; [(...)] [PARTITION BY expr, ...]
//   [CLUSTER BY expr, ...] [OPTIONS (...)] AS SELECT ...
//
// &lt;column_definition_list&gt; matches 1:1 with the &lt;output_column_list&gt; in
// ResolvedCreateViewBase and provides explicit definition for each
// ResolvedColumn produced by &lt;query&gt;. Output column names and types must
// match column definition names and types. If the table is a value table,
// &lt;column_definition_list&gt; must have exactly one column, with a generated
// name such as &#34;$struct&#34;.
//
// Currently &lt;column_definition_list&gt; contains the same schema information
// (column names and types) as &lt;output_definition_list&gt;, but when/if we
// allow specifying column OPTIONS as part of CMV statement, this information
// will be available only in &lt;column_definition_list&gt;. Therefore, consumers
// are encouraged to read from &lt;column_definition_list&gt; rather than from
// &lt;output_column_list&gt; to determine the schema, if possible.
//
// &lt;partition_by_list&gt; specifies the partitioning expressions for the
//                     materialized view.
// &lt;cluster_by_list&gt; specifies the clustering expressions for the
//                   materialized view.</font>
class ResolvedCreateMaterializedViewStmt : public <a href="#ResolvedCreateViewBase">ResolvedCreateViewBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_MATERIALIZED_VIEW_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>&gt;&gt;&amp; column_definition_list() const;
  int column_definition_list_size() const;
  const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>* column_definition_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; partition_by_list() const;
  int partition_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* partition_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; cluster_by_list() const;
  int cluster_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* cluster_by_list(int i) const;
};
</code></pre></p>

### ResolvedCreateProcedureStmt
<a id="ResolvedCreateProcedureStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This statement creates a user-defined procedure:
// CREATE [OR REPLACE] [TEMP] PROCEDURE [IF NOT EXISTS] &lt;name_path&gt;
// (&lt;arg_list&gt;) [OPTIONS (&lt;option_list&gt;)]
// BEGIN
// &lt;procedure_body&gt;
// END;
//
// &lt;name_path&gt; is the identifier path of the procedure.
// &lt;argument_name_list&gt; The names of the function arguments.
// &lt;signature&gt; is the FunctionSignature of the created procedure, with all
//        options.  This can be used to create a procedure to load into a
//        Catalog for future queries.
// &lt;option_list&gt; has engine-specific directives for modifying procedures.
// &lt;procedure_body&gt; is a string literal that contains the procedure body.
//        It includes everything from the BEGIN keyword to the END keyword,
//        inclusive.
//
//        The resolver will perform some basic validation on the procedure
//        body, for example, verifying that DECLARE statements are in the
//        proper position, and that variables are not declared more than
//        once, but any validation that requires the catalog (including
//        generating resolved tree nodes for individual statements) is
//        deferred until the procedure is actually called.  This deferral
//        makes it possible to define a procedure which references a table
//        or routine that does not yet exist, so long as the entity is
//        created before the procedure is called.</font>
class ResolvedCreateProcedureStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_PROCEDURE_STMT;

  const std::vector&lt;std::string&gt;&amp; argument_name_list() const;
  int argument_name_list_size() const;
  std::string argument_name_list(int i) const;

  const FunctionSignature&amp; signature() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::string&amp; procedure_body() const;
};
</code></pre></p>

### ResolvedExecuteImmediateArgument
<a id="ResolvedExecuteImmediateArgument"></a>

<p><pre><code class="lang-c++">
<font color="brown">// An argument for an EXECUTE IMMEDIATE&#39;s USING clause.
//
// &lt;name&gt; an optional name for this expression
// &lt;expression&gt; the expression&#39;s value</font>
class ResolvedExecuteImmediateArgument : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXECUTE_IMMEDIATE_ARGUMENT;

  const std::string&amp; name() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expression() const;
};
</code></pre></p>

### ResolvedExecuteImmediateStmt
<a id="ResolvedExecuteImmediateStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// An EXECUTE IMMEDIATE statement
// EXECUTE IMMEDIATE &lt;sql&gt; [&lt;into_clause&gt;] [&lt;using_clause&gt;]
//
// &lt;sql&gt; a string expression indicating a SQL statement to be dynamically
//   executed
// &lt;into_identifier_list&gt; the identifiers whose values should be set.
//   Identifiers should not be repeated in the list.
// &lt;using_argument_list&gt; a list of arguments to supply for dynamic SQL.
//    The arguments should either be all named or all unnamed, and
//    arguments should not be repeated in the list.</font>
class ResolvedExecuteImmediateStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXECUTE_IMMEDIATE_STMT;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* sql() const;

  const std::vector&lt;std::string&gt;&amp; into_identifier_list() const;
  int into_identifier_list_size() const;
  std::string into_identifier_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExecuteImmediateArgument">ResolvedExecuteImmediateArgument</a>&gt;&gt;&amp; using_argument_list() const;
  int using_argument_list_size() const;
  const <a href="#ResolvedExecuteImmediateArgument">ResolvedExecuteImmediateArgument</a>* using_argument_list(int i) const;
};
</code></pre></p>

### ResolvedAssignmentStmt
<a id="ResolvedAssignmentStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// An assignment of a value to another value.</font>
class ResolvedAssignmentStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ASSIGNMENT_STMT;

<font color="brown">  // Target of the assignment.  Currently, this will be either ResolvedSystemVariable, or a chain of ResolveGetField operations around it.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* target() const;

<font color="brown">  // Value to assign into the target.  This will always be the same type as the target.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;
};
</code></pre></p>

### ResolvedCreateEntityStmt
<a id="ResolvedCreateEntityStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// (broken link)
// This statement:
// CREATE [OR REPLACE] &lt;entity_type&gt; [IF NOT EXISTS] &lt;path_expression&gt;
// [OPTIONS &lt;option_list&gt;]
// [AS &lt;entity_body_json&gt;];
//
// At most one of &lt;entity_body_json&gt;, &lt;entity_body_text&gt; can be non-empty.
//
// &lt;entity_type&gt; engine-specific entity type to be created.
// &lt;entity_body_json&gt; is a JSON literal to be interpreted by engine.
// &lt;entity_body_text&gt; is a text literal to be interpreted by engine.
// &lt;option_list&gt; has engine-specific directives for how to
//               create this entity.</font>
class ResolvedCreateEntityStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_ENTITY_STMT;

  const std::string&amp; entity_type() const;

  const std::string&amp; entity_body_json() const;

  const std::string&amp; entity_body_text() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedAlterEntityStmt
<a id="ResolvedAlterEntityStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// (broken link)
// This statement:
// ALTER &lt;entity_type&gt; [IF EXISTS]  &lt;path_expression&gt;
// &lt;generic_alter_action&gt;, ...
//
// &lt;entity_type&gt; engine-specific entity type to be altered.</font>
class ResolvedAlterEntityStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_ENTITY_STMT;

  const std::string&amp; entity_type() const;
};
</code></pre></p>

### ResolvedPivotColumn
<a id="ResolvedPivotColumn"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Represents a column produced by aggregating a particular pivot
// expression over a subset of the input for which the FOR expression
// matches a particular pivot value. This aggregation is further
// broken up by the enclosing ResolvedPivotScan&#39;s groupby columns,
// with each distinct value of the groupby columns producing a
// separate row in the output.
//
// In any pivot column, &#39;c&#39;,
// &#39;c&#39; is produced by aggregating pivot expression
//   &lt;pivot_expr_list[c.pivot_expr_index]&gt;
// over input rows such that
//   &lt;for_expr&gt; IS NOT DISTINCT FROM
//   &lt;pivot_value_list[c.pivot_value_index]&gt;</font>
class ResolvedPivotColumn : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PIVOT_COLUMN;

<font color="brown">  // The output column used to represent the result of the pivot.</font>
  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const;

<font color="brown">  // Specifies the index of the pivot expression
  // within the enclosing ResolvedPivotScan&#39;s &lt;pivot_expr_list&gt; used to
  // determine the result of the column.</font>
  int pivot_expr_index() const;

<font color="brown">  // Specifies the index of the pivot value within
  // the enclosing ResolvedPivotScan&#39;s &lt;pivot_value_list&gt; used to
  // determine the subset of input rows the pivot expression should be
  // evaluated over.</font>
  int pivot_value_index() const;
};
</code></pre></p>

### ResolvedPivotScan
<a id="ResolvedPivotScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A scan produced by the following SQL fragment:
//   &lt;input_scan&gt; PIVOT(... FOR ... IN (...))
//
// The column list of this scan consists of a subset of columns from
// &lt;group_by_column_list&gt; and &lt;pivot_column_list&gt;.
//
// Details: (broken link)</font>
class ResolvedPivotScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PIVOT_SCAN;

<font color="brown">  // Input to the PIVOT clause</font>
  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

<font color="brown">  // The columns from &lt;input_scan&gt; to group by.
  // The output will have one row for each distinct combination of
  // values for all grouping columns. (There will be one output row if
  // this list is empty.)
  //
  // Each element is a ResolvedComputedColumn. The expression is always
  // a ResolvedColumnRef that references a column from &lt;input_scan&gt;.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; group_by_list() const;
  int group_by_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* group_by_list(int i) const;

<font color="brown">  // Pivot expressions which aggregate over the subset of &lt;input_scan&gt;
  // where &lt;for_expr&gt; matches each value in &lt;pivot_value_list&gt;, plus
  // all columns in &lt;group_by_list&gt;.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; pivot_expr_list() const;
  int pivot_expr_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* pivot_expr_list(int i) const;

<font color="brown">  // Expression following the FOR keyword, to be evaluated over each row
  // in &lt;input_scan&gt;. This value is compared with each value in
  // &lt;pivot_value_list&gt; to determine which columns the aggregation
  // results of &lt;pivot_expr_list&gt; should go to.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* for_expr() const;

<font color="brown">  // A list of pivot values within the IN list, to be compared against
  // the result of &lt;for_expr&gt; for each row in the input table. Each
  // pivot value generates a distinct column in the output for each
  // pivot expression, representing the result of the corresponding
  // pivot expression over the subset of input where &lt;for_expr&gt; matches
  // this pivot value.
  //
  // All pivot values in this list must have the same type as
  // &lt;for_expr&gt; and must be constant.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; pivot_value_list() const;
  int pivot_value_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* pivot_value_list(int i) const;

<font color="brown">  // List of columns created to store the output pivot columns.
  // Each is computed using one of pivot_expr_list and one of
  // pivot_value_list.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedPivotColumn">ResolvedPivotColumn</a>&gt;&gt;&amp; pivot_column_list() const;
  int pivot_column_list_size() const;
  const <a href="#ResolvedPivotColumn">ResolvedPivotColumn</a>* pivot_column_list(int i) const;
};
</code></pre></p>

### ResolvedReturningClause
<a id="ResolvedReturningClause"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Represents the returning clause on a DML statement.</font>
class ResolvedReturningClause : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RETURNING_CLAUSE;

<font color="brown">  // Specifies the columns in the returned output row with column
  // names. It can reference columns from the target table scan
  // &lt;table_scan&gt; from INSERT/DELETE/UPDATE statements. Also this list
  // can have columns computed in the &lt;expr_list&gt; or an &lt;action_column&gt;
  // as the last column.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

<font color="brown">  // Represents the WITH ACTION column in &lt;output_column_list&gt; as a
  // string type column. There are four valid values for this action
  // column: &#34;INSERT&#34;, &#34;REPLACE&#34;, &#34;UPDATE&#34;, and &#34;DELETE&#34;.</font>
  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* action_column() const;

<font color="brown">  // Represents the computed expressions so they can be referenced in
  // &lt;output_column_list&gt;. Worth noting, it can&#39;t see &lt;action_column&gt;
  // and can only access columns from the DML statement target table.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; expr_list() const;
  int expr_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* expr_list(int i) const;
};
</code></pre></p>

### ResolvedUnpivotArg
<a id="ResolvedUnpivotArg"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A column group in the UNPIVOT IN clause.
//
// Example:
//   &#39;a&#39; in &#39;UNPIVOT(x FOR z IN (a , b , c))&#39;
//   or &#39;(a , b)&#39; in &#39;UNPIVOT((x , y) FOR z IN ((a , b), (c , d))&#39;</font>
class ResolvedUnpivotArg : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UNPIVOT_ARG;

<font color="brown">  // A list of columns referencing an output column of the &lt;input_scan&gt;
  // of ResolvedUnpivotScan. The size of this vector is
  // the same as &lt;value_column_list&gt;.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; column_list() const;
  int column_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* column_list(int i) const;
};
</code></pre></p>

### ResolvedUnpivotScan
<a id="ResolvedUnpivotScan"></a>

<p><pre><code class="lang-c++">
<font color="brown">// A scan produced by the following SQL fragment:
// &lt;input_scan&gt; UNPIVOT(&lt;value_column_list&gt;
//   FOR &lt;label_column&gt;
//   IN (&lt;unpivot_arg_list&gt;))
//
// size of (&lt;unpivot_arg_list&gt;[i], i.e. column groups inside
// &lt;unpivot_arg_list&gt;)
//   = size of (&lt;value_column_list&gt;)
//   = Let&#39;s say num_value_columns
//
// size of (&lt;unpivot_arg_list&gt;)
//   = size of (&lt;label_list&gt;)
//   = Let&#39;s say num_args
//
// Here is how output rows are generated --
// for each input row :
//   for arg_index = 0 .. (num_args - 1) :
//     output a row with the original columns from &lt;input_scan&gt;
//
//       plus
//     arg = &lt;unpivot_arg_list&gt;[arg_index]
//     for value_column_index = 0 .. (num_value_columns - 1) :
//       output_value_column = &lt;value_column_list&gt;[value_column_index]
//       input_arg_column = arg [value_column_index]
//       output_value_column = input_arg_column
//
//       plus
//     &lt;label_column&gt; = &lt;label_list&gt;[arg_index]
//
//
// Hence the total number of rows generated in the output =
//   input rows * size of &lt;unpivot_arg_list&gt;
//
// For all column groups inside &lt;unpivot_arg_list&gt;, datatype of
// columns at the same position in the vector must be equivalent, and
// also equivalent to the datatype of the column at the same position in
// &lt;value_column_list&gt;.
// I.e. in the above pseudocode, datatypes must be equivalent for
// output_value_column and input_arg_column.
// Datatype of &lt;label_column&gt; must be the same as datatype of
// &lt;label_list&gt; and can be string or int64.
//
// Details: (broken link)</font>
class ResolvedUnpivotScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UNPIVOT_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

<font color="brown">  // This is a list of one or more new columns added by UNPIVOT.
  // These new column(s) store the value of input columns that are in
  // the UNPIVOT IN clause.</font>
  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; value_column_list() const;
  int value_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> value_column_list(int i) const;

<font color="brown">  // This is a new column added in the output for storing labels for
  // input columns groups that are present in the IN clause. Its
  // values are taken from &lt;label_list&gt;.</font>
  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; label_column() const;

<font color="brown">  // String or integer literal for each column group in
  // &lt;unpivot_arg_list&gt;.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedLiteral">ResolvedLiteral</a>&gt;&gt;&amp; label_list() const;
  int label_list_size() const;
  const <a href="#ResolvedLiteral">ResolvedLiteral</a>* label_list(int i) const;

<font color="brown">  // The list of groups of columns in the UNPIVOT IN list. Each group
  // contains references to the output columns of &lt;input_scan&gt; of the
  // ResolvedUnpivotScan. The values of these columns are stored in the
  // new &lt;value_column_list&gt; and the column group labels/names
  // in the &lt;label_column&gt;.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUnpivotArg">ResolvedUnpivotArg</a>&gt;&gt;&amp; unpivot_arg_list() const;
  int unpivot_arg_list_size() const;
  const <a href="#ResolvedUnpivotArg">ResolvedUnpivotArg</a>* unpivot_arg_list(int i) const;

<font color="brown">  // Whether we need to include the rows from output where ALL columns
  // from &lt;value_column_list&gt; are null.</font>
  bool include_nulls() const;
};
</code></pre></p>

### ResolvedCloneDataStmt
<a id="ResolvedCloneDataStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// CLONE DATA INTO &lt;table_name&gt; FROM ...
//
// &lt;target_table&gt; the table to clone data into. Cannot be value table.
// &lt;clone_from&gt; The source table(s) to clone data from.
//              For a single table, the scan is TableScan, with an optional
//                  for_system_time_expr;
//              If WHERE clause is present, the Scan is wrapped inside
//                  ResolvedFilterScan;
//              When multiple sources are present, they are UNION&#39;ed together
//                  in a ResolvedSetOperationScan.
//
//              Constraints:
//                The target_table must not be the same as any source table,
//                and two sources cannot refer to the same table.
//                All source tables and target table must have equal number
//                of columns, with positionally identical column names and
//                types.
//                Cannot be value table.</font>
class ResolvedCloneDataStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CLONE_DATA_STMT;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* target_table() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* clone_from() const;
};
</code></pre></p>

### ResolvedTableAndColumnInfo
<a id="ResolvedTableAndColumnInfo"></a>

<p><pre><code class="lang-c++">
<font color="brown">// Identifies the &lt;table&gt; and &lt;column_index_list&gt; (which can be empty) that
// are targets of the ANALYZE statement.
//
// &lt;column_index_list&gt; This list identifies the ordinals of columns to be
// analyzed in the &lt;table&gt;&#39;s column list.</font>
class ResolvedTableAndColumnInfo : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_TABLE_AND_COLUMN_INFO;

  const Table* table() const;

  const std::vector&lt;int&gt;&amp; column_index_list() const;
  int column_index_list_size() const;
  int column_index_list(int i) const;
};
</code></pre></p>

### ResolvedAnalyzeStmt
<a id="ResolvedAnalyzeStmt"></a>

<p><pre><code class="lang-c++">
<font color="brown">// This represents the ANALYZE statement:
// ANALYZE [OPTIONS (&lt;option_list&gt;)] [&lt;table_and_column_index_list&gt; [, ...]];
//
// &lt;option_list&gt; is a list of options for ANALYZE.
//
// &lt;table_and_column_info_list&gt; identifies a list of tables along with their
// related columns that are the target of ANALYZE.</font>
class ResolvedAnalyzeStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ANALYZE_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedTableAndColumnInfo">ResolvedTableAndColumnInfo</a>&gt;&gt;&amp; table_and_column_index_list() const;
  int table_and_column_index_list_size() const;
  const <a href="#ResolvedTableAndColumnInfo">ResolvedTableAndColumnInfo</a>* table_and_column_index_list(int i) const;
};
</code></pre></p>

