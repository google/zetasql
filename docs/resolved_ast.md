<!--
  resolved_ast.md generated from template:
    https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/resolved_ast.md.template

  Generated by target:
    //zetasql/resolved_ast:run_gen_resolved_ast_md
-->

# ZetaSQL Resolved AST

The ZetaSQL analyzer produces an abstract syntax tree (AST). The nodes of this
AST (ResolveAST) are generated by
[https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/gen_resolved_ast.py] for both C++
and Java using bazel genrules. This document provides a summary of the nodes and
their hierarchy.

The C++ classes for the AST produced by the ZetaSQL parser are documented in
zetasql/docs/parse_ast.md.

### C++ {#ResolvedNode}

The base class `ResolvedNode` is defined in
[https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/resolved_node.h](https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/resolved_node.h)

The generated classes are specified in
[https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/gen_resolved_ast.py](https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/gen_resolved_ast.py)
See that file for comments on specific nodes and fields.

Additional non-generated classes that are documented separately:

- <a id="ResolvedColumn"></a>[ResolvedColumn](https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/resolved_column.h)
- <a id="ResolvedCollation"></a>[ResolvedCollation](https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/resolved_collation.h)

### Java

The base class `ResolvedNode` is defined in
[https://github.com/google/zetasql/blob/master/java/com/google/zetasql/resolvedast/ResolvedNode.java](https://github.com/google/zetasql/blob/master/java/com/google/zetasql/resolvedast/ResolvedNode.java)

The generated classes are specified in
[https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/gen_resolved_ast.py](https://github.com/google/zetasql/blob/master/zetasql/resolved_ast/gen_resolved_ast.py)
See that file for comments on specific nodes and fields.

Additional non-generated classes that are documented separately:

- [ResolvedColumn](https://github.com/google/zetasql/blob/master/java/com/google/zetasql/resolvedast/ResolvedColumn.java)

## Resolved AST Node Hierarchy

<p><pre><code><a href="#ResolvedNode">ResolvedNode</a>
  <a href="#ResolvedArgument">ResolvedArgument</a>
    <a href="#ResolvedAggregateHavingModifier">ResolvedAggregateHavingModifier</a>
    <a href="#ResolvedAlterAction">ResolvedAlterAction</a>
      <a href="#ResolvedAddColumnAction">ResolvedAddColumnAction</a>
      <a href="#ResolvedAddColumnIdentifierAction">ResolvedAddColumnIdentifierAction</a>
      <a href="#ResolvedAddConstraintAction">ResolvedAddConstraintAction</a>
      <a href="#ResolvedAddSubEntityAction">ResolvedAddSubEntityAction</a>
      <a href="#ResolvedAddToRestricteeListAction">ResolvedAddToRestricteeListAction</a>
      <a href="#ResolvedAlterColumnAction">ResolvedAlterColumnAction</a>
        <a href="#ResolvedAlterColumnDropDefaultAction">ResolvedAlterColumnDropDefaultAction</a>
        <a href="#ResolvedAlterColumnDropGeneratedAction">ResolvedAlterColumnDropGeneratedAction</a>
        <a href="#ResolvedAlterColumnDropNotNullAction">ResolvedAlterColumnDropNotNullAction</a>
        <a href="#ResolvedAlterColumnOptionsAction">ResolvedAlterColumnOptionsAction</a>
        <a href="#ResolvedAlterColumnSetDataTypeAction">ResolvedAlterColumnSetDataTypeAction</a>
        <a href="#ResolvedAlterColumnSetDefaultAction">ResolvedAlterColumnSetDefaultAction</a>
        <a href="#ResolvedAlterColumnSetGeneratedAction">ResolvedAlterColumnSetGeneratedAction</a>
      <a href="#ResolvedAlterSubEntityAction">ResolvedAlterSubEntityAction</a>
      <a href="#ResolvedDropColumnAction">ResolvedDropColumnAction</a>
      <a href="#ResolvedDropConstraintAction">ResolvedDropConstraintAction</a>
      <a href="#ResolvedDropPrimaryKeyAction">ResolvedDropPrimaryKeyAction</a>
      <a href="#ResolvedDropSubEntityAction">ResolvedDropSubEntityAction</a>
      <a href="#ResolvedFilterUsingAction">ResolvedFilterUsingAction</a>
      <a href="#ResolvedGrantToAction">ResolvedGrantToAction</a>
      <a href="#ResolvedRebuildAction">ResolvedRebuildAction</a>
      <a href="#ResolvedRemoveFromRestricteeListAction">ResolvedRemoveFromRestricteeListAction</a>
      <a href="#ResolvedRenameColumnAction">ResolvedRenameColumnAction</a>
      <a href="#ResolvedRenameToAction">ResolvedRenameToAction</a>
      <a href="#ResolvedRestrictToAction">ResolvedRestrictToAction</a>
      <a href="#ResolvedRevokeFromAction">ResolvedRevokeFromAction</a>
      <a href="#ResolvedSetAsAction">ResolvedSetAsAction</a>
      <a href="#ResolvedSetCollateClause">ResolvedSetCollateClause</a>
      <a href="#ResolvedSetOptionsAction">ResolvedSetOptionsAction</a>
    <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>
    <a href="#ResolvedArgumentDef">ResolvedArgumentDef</a>
    <a href="#ResolvedArgumentList">ResolvedArgumentList</a>
    <a href="#ResolvedAssertRowsModified">ResolvedAssertRowsModified</a>
    <a href="#ResolvedAuxLoadDataPartitionFilter">ResolvedAuxLoadDataPartitionFilter</a>
    <a href="#ResolvedColumnAnnotation">ResolvedColumnAnnotations</a>
    <a href="#ResolvedColumnDefaultValue">ResolvedColumnDefaultValue</a>
    <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>
    <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>
    <a href="#ResolvedComputedColumnBase">ResolvedComputedColumnBase</a>
      <a href="#ResolvedComputedColumnImpl">ResolvedComputedColumnImpl</a>
        <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>
        <a href="#ResolvedDeferredComputedColumn">ResolvedDeferredComputedColumn</a>
    <a href="#ResolvedConnection">ResolvedConnection</a>
    <a href="#ResolvedConstraint">ResolvedConstraint</a>
      <a href="#ResolvedCheckConstraint">ResolvedCheckConstraint</a>
      <a href="#ResolvedForeignKey">ResolvedForeignKey</a>
      <a href="#ResolvedPrimaryKey">ResolvedPrimaryKey</a>
    <a href="#ResolvedCreateModelAliasedQuery">ResolvedCreateModelAliasedQuery</a>
    <a href="#ResolvedDMLValue">ResolvedDMLValue</a>
    <a href="#ResolvedDescriptor">ResolvedDescriptor</a>
    <a href="#ResolvedExecuteImmediateArgument">ResolvedExecuteImmediateArgument</a>
    <a href="#ResolvedExtendedCast">ResolvedExtendedCast</a>
    <a href="#ResolvedExtendedCastElement">ResolvedExtendedCastElement</a>
    <a href="#ResolvedFilterFieldArg">ResolvedFilterFieldArg</a>
    <a href="#ResolvedFunctionArgument">ResolvedFunctionArgument</a>
    <a href="#ResolvedFunctionSignatureHolder">ResolvedFunctionSignatureHolder</a>
    <a href="#ResolvedGeneralizedQuerySubpipeline">ResolvedGeneralizedQuerySubpipeline</a>
    <a href="#ResolvedGeneratedColumnInfo">ResolvedGeneratedColumnInfo</a>
    <a href="#ResolvedGraphDynamicLabelSpecification">ResolvedGraphDynamicLabelSpecification</a>
    <a href="#ResolvedGraphDynamicPropertiesSpecification">ResolvedGraphDynamicPropertiesSpecification</a>
    <a href="#ResolvedGraphElementIdentifier">ResolvedGraphElementIdentifier</a>
    <a href="#ResolvedGraphElementLabel">ResolvedGraphElementLabel</a>
    <a href="#ResolvedGraphElementProperty">ResolvedGraphElementProperty</a>
    <a href="#ResolvedGraphElementTable">ResolvedGraphElementTable</a>
    <a href="#ResolvedGraphLabelExpr">ResolvedGraphLabelExpr</a>
      <a href="#ResolvedGraphLabel">ResolvedGraphLabel</a>
      <a href="#ResolvedGraphLabelNaryExpr">ResolvedGraphLabelNaryExpr</a>
      <a href="#ResolvedGraphWildCardLabel">ResolvedGraphWildCardLabel</a>
    <a href="#ResolvedGraphMakeArrayVariable">ResolvedGraphMakeArrayVariable</a>
    <a href="#ResolvedGraphNodeTableReference">ResolvedGraphNodeTableReference</a>
    <a href="#ResolvedGraphPathCost">ResolvedGraphPathCost</a>
    <a href="#ResolvedGraphPathMode">ResolvedGraphPathMode</a>
    <a href="#ResolvedGraphPathPatternQuantifier">ResolvedGraphPathPatternQuantifier</a>
    <a href="#ResolvedGraphPathSearchPrefix">ResolvedGraphPathSearchPrefix</a>
    <a href="#ResolvedGraphPropertyDeclaration">ResolvedGraphPropertyDeclaration</a>
    <a href="#ResolvedGraphPropertyDefinition">ResolvedGraphPropertyDefinition</a>
    <a href="#ResolvedGroupingCall">ResolvedGroupingCall</a>
    <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a>
      <a href="#ResolvedCube">ResolvedCube</a>
      <a href="#ResolvedGroupingSet">ResolvedGroupingSet</a>
      <a href="#ResolvedGroupingSetList">ResolvedGroupingSetList</a>
      <a href="#ResolvedGroupingSetProduct">ResolvedGroupingSetProduct</a>
      <a href="#ResolvedRollup">ResolvedRollup</a>
    <a href="#ResolvedGroupingSetMultiColumn">ResolvedGroupingSetMultiColumn</a>
    <a href="#ResolvedIdentityColumnInfo">ResolvedIdentityColumnInfo</a>
    <a href="#ResolvedIndexItem">ResolvedIndexItem</a>
    <a href="#ResolvedInlineLambda">ResolvedInlineLambda</a>
    <a href="#ResolvedInsertRow">ResolvedInsertRow</a>
    <a href="#ResolvedLockMode">ResolvedLockMode</a>
    <a href="#ResolvedMakeProtoField">ResolvedMakeProtoField</a>
    <a href="#ResolvedMatchRecognizePatternExpr">ResolvedMatchRecognizePatternExpr</a>
      <a href="#ResolvedMatchRecognizePatternAnchor">ResolvedMatchRecognizePatternAnchor</a>
      <a href="#ResolvedMatchRecognizePatternEmpty">ResolvedMatchRecognizePatternEmpty</a>
      <a href="#ResolvedMatchRecognizePatternOperation">ResolvedMatchRecognizePatternOperation</a>
      <a href="#ResolvedMatchRecognizePatternQuantification">ResolvedMatchRecognizePatternQuantification</a>
      <a href="#ResolvedMatchRecognizePatternVariableRef">ResolvedMatchRecognizePatternVariableRef</a>
    <a href="#ResolvedMatchRecognizeVariableDefinition">ResolvedMatchRecognizeVariableDefinition</a>
    <a href="#ResolvedMeasureGroup">ResolvedMeasureGroup</a>
    <a href="#ResolvedMergeWhen">ResolvedMergeWhen</a>
    <a href="#ResolvedModel">ResolvedModel</a>
    <a href="#ResolvedObjectUnit">ResolvedObjectUnit</a>
    <a href="#ResolvedOnConflictClause">ResolvedOnConflictClause</a>
    <a href="#ResolvedOption">ResolvedOption</a>
    <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>
    <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>
    <a href="#ResolvedOutputSchema">ResolvedOutputSchema</a>
    <a href="#ResolvedPipeIfCase">ResolvedPipeIfCase</a>
    <a href="#ResolvedPivotColumn">ResolvedPivotColumn</a>
    <a href="#ResolvedPrivilege">ResolvedPrivilege</a>
    <a href="#ResolvedRecursionDepthModifier">ResolvedRecursionDepthModifier</a>
    <a href="#ResolvedReplaceFieldItem">ResolvedReplaceFieldItem</a>
    <a href="#ResolvedReturningClause">ResolvedReturningClause</a>
    <a href="#ResolvedSequence">ResolvedSequence</a>
    <a href="#ResolvedSetOperationItem">ResolvedSetOperationItem</a>
    <a href="#ResolvedSubpipeline">ResolvedSubpipeline</a>
    <a href="#ResolvedTableAndColumnInfo">ResolvedTableAndColumnInfo</a>
    <a href="#ResolvedUnnestItem">ResolvedUnnestItem</a>
    <a href="#ResolvedUnpivotArg">ResolvedUnpivotArg</a>
    <a href="#ResolvedUpdateFieldItem">ResolvedUpdateFieldItem</a>
    <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>
    <a href="#ResolvedUpdateItemElement">ResolvedUpdateItemElement</a>
    <a href="#ResolvedWindowFrame">ResolvedWindowFrame</a>
    <a href="#ResolvedWindowFrameExpr">ResolvedWindowFrameExpr</a>
    <a href="#ResolvedWindowOrdering">ResolvedWindowOrdering</a>
    <a href="#ResolvedWindowPartitioning">ResolvedWindowPartitioning</a>
    <a href="#ResolvedWithEntry">ResolvedWithEntry</a>
    <a href="#ResolvedWithPartitionColumn">ResolvedWithPartitionColumns</a>
  <a href="#ResolvedExpr">ResolvedExpr</a>
    <a href="#ResolvedArgumentRef">ResolvedArgumentRef</a>
    <a href="#ResolvedArrayAggregate">ResolvedArrayAggregate</a>
    <a href="#ResolvedCast">ResolvedCast</a>
    <a href="#ResolvedCatalogColumnRef">ResolvedCatalogColumnRef</a>
    <a href="#ResolvedColumnRef">ResolvedColumnRef</a>
    <a href="#ResolvedConstant">ResolvedConstant</a>
    <a href="#ResolvedDMLDefault">ResolvedDMLDefault</a>
    <a href="#ResolvedExpressionColumn">ResolvedExpressionColumn</a>
    <a href="#ResolvedFilterField">ResolvedFilterField</a>
    <a href="#ResolvedFlatten">ResolvedFlatten</a>
    <a href="#ResolvedFlattenedArg">ResolvedFlattenedArg</a>
    <a href="#ResolvedFunctionCallBase">ResolvedFunctionCallBase</a>
      <a href="#ResolvedFunctionCall">ResolvedFunctionCall</a>
      <a href="#ResolvedNonScalarFunctionCallBase">ResolvedNonScalarFunctionCallBase</a>
        <a href="#ResolvedAggregateFunctionCall">ResolvedAggregateFunctionCall</a>
        <a href="#ResolvedAnalyticFunctionCall">ResolvedAnalyticFunctionCall</a>
    <a href="#ResolvedGetJsonField">ResolvedGetJsonField</a>
    <a href="#ResolvedGetProtoField">ResolvedGetProtoField</a>
    <a href="#ResolvedGetProtoOneof">ResolvedGetProtoOneof</a>
    <a href="#ResolvedGetRowField">ResolvedGetRowField</a>
    <a href="#ResolvedGetStructField">ResolvedGetStructField</a>
    <a href="#ResolvedGraphGetElementProperty">ResolvedGraphGetElementProperty</a>
    <a href="#ResolvedGraphIsLabeledPredicate">ResolvedGraphIsLabeledPredicate</a>
    <a href="#ResolvedGraphMakeElement">ResolvedGraphMakeElement</a>
    <a href="#ResolvedLiteral">ResolvedLiteral</a>
    <a href="#ResolvedMakeProto">ResolvedMakeProto</a>
    <a href="#ResolvedMakeStruct">ResolvedMakeStruct</a>
    <a href="#ResolvedParameter">ResolvedParameter</a>
    <a href="#ResolvedReplaceField">ResolvedReplaceField</a>
    <a href="#ResolvedSubqueryExpr">ResolvedSubqueryExpr</a>
    <a href="#ResolvedSystemVariable">ResolvedSystemVariable</a>
    <a href="#ResolvedUpdateConstructor">ResolvedUpdateConstructor</a>
    <a href="#ResolvedWithExpr">ResolvedWithExpr</a>
  <a href="#ResolvedScan">ResolvedScan</a>
    <a href="#ResolvedAggregateScanBase">ResolvedAggregateScanBase</a>
      <a href="#ResolvedAggregateScan">ResolvedAggregateScan</a>
      <a href="#ResolvedAggregationThresholdAggregateScan">ResolvedAggregationThresholdAggregateScan</a>
      <a href="#ResolvedAnonymizedAggregateScan">ResolvedAnonymizedAggregateScan</a>
      <a href="#ResolvedDifferentialPrivacyAggregateScan">ResolvedDifferentialPrivacyAggregateScan</a>
    <a href="#ResolvedAnalyticScan">ResolvedAnalyticScan</a>
    <a href="#ResolvedArrayScan">ResolvedArrayScan</a>
    <a href="#ResolvedAssertScan">ResolvedAssertScan</a>
    <a href="#ResolvedBarrierScan">ResolvedBarrierScan</a>
    <a href="#ResolvedDescribeScan">ResolvedDescribeScan</a>
    <a href="#ResolvedExecuteAsRoleScan">ResolvedExecuteAsRoleScan</a>
    <a href="#ResolvedFilterScan">ResolvedFilterScan</a>
    <a href="#ResolvedGraphCallScan">ResolvedGraphCallScan</a>
    <a href="#ResolvedGraphPathScanBase">ResolvedGraphPathScanBase</a>
      <a href="#ResolvedGraphElementScan">ResolvedGraphElementScan</a>
        <a href="#ResolvedGraphEdgeScan">ResolvedGraphEdgeScan</a>
        <a href="#ResolvedGraphNodeScan">ResolvedGraphNodeScan</a>
      <a href="#ResolvedGraphPathScan">ResolvedGraphPathScan</a>
    <a href="#ResolvedGraphRefScan">ResolvedGraphRefScan</a>
    <a href="#ResolvedGraphScanBase">ResolvedGraphScanBase</a>
      <a href="#ResolvedGraphLinearScan">ResolvedGraphLinearScan</a>
      <a href="#ResolvedGraphScan">ResolvedGraphScan</a>
    <a href="#ResolvedGraphTableScan">ResolvedGraphTableScan</a>
    <a href="#ResolvedGroupRowsScan">ResolvedGroupRowsScan</a>
    <a href="#ResolvedJoinScan">ResolvedJoinScan</a>
    <a href="#ResolvedLimitOffsetScan">ResolvedLimitOffsetScan</a>
    <a href="#ResolvedLogScan">ResolvedLogScan</a>
    <a href="#ResolvedMatchRecognizeScan">ResolvedMatchRecognizeScan</a>
    <a href="#ResolvedOrderByScan">ResolvedOrderByScan</a>
    <a href="#ResolvedPipeCreateTableScan">ResolvedPipeCreateTableScan</a>
    <a href="#ResolvedPipeExportDataScan">ResolvedPipeExportDataScan</a>
    <a href="#ResolvedPipeForkScan">ResolvedPipeForkScan</a>
    <a href="#ResolvedPipeIfScan">ResolvedPipeIfScan</a>
    <a href="#ResolvedPipeInsertScan">ResolvedPipeInsertScan</a>
    <a href="#ResolvedPipeTeeScan">ResolvedPipeTeeScan</a>
    <a href="#ResolvedPivotScan">ResolvedPivotScan</a>
    <a href="#ResolvedProjectScan">ResolvedProjectScan</a>
    <a href="#ResolvedRecursiveRefScan">ResolvedRecursiveRefScan</a>
    <a href="#ResolvedRecursiveScan">ResolvedRecursiveScan</a>
    <a href="#ResolvedRelationArgumentScan">ResolvedRelationArgumentScan</a>
    <a href="#ResolvedSampleScan">ResolvedSampleScan</a>
    <a href="#ResolvedSetOperationScan">ResolvedSetOperationScan</a>
    <a href="#ResolvedSingleRowScan">ResolvedSingleRowScan</a>
    <a href="#ResolvedStaticDescribeScan">ResolvedStaticDescribeScan</a>
    <a href="#ResolvedSubpipelineInputScan">ResolvedSubpipelineInputScan</a>
    <a href="#ResolvedTVFScan">ResolvedTVFScan</a>
    <a href="#ResolvedTableScan">ResolvedTableScan</a>
    <a href="#ResolvedUnpivotScan">ResolvedUnpivotScan</a>
    <a href="#ResolvedUnsetArgumentScan">ResolvedUnsetArgumentScan</a>
    <a href="#ResolvedWithRefScan">ResolvedWithRefScan</a>
    <a href="#ResolvedWithScan">ResolvedWithScan</a>
  <a href="#ResolvedStatement">ResolvedStatement</a>
    <a href="#ResolvedAbortBatchStmt">ResolvedAbortBatchStmt</a>
    <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a>
      <a href="#ResolvedAlterAllRowAccessPoliciesStmt">ResolvedAlterAllRowAccessPoliciesStmt</a>
      <a href="#ResolvedAlterApproxViewStmt">ResolvedAlterApproxViewStmt</a>
      <a href="#ResolvedAlterConnectionStmt">ResolvedAlterConnectionStmt</a>
      <a href="#ResolvedAlterDatabaseStmt">ResolvedAlterDatabaseStmt</a>
      <a href="#ResolvedAlterEntityStmt">ResolvedAlterEntityStmt</a>
      <a href="#ResolvedAlterExternalSchemaStmt">ResolvedAlterExternalSchemaStmt</a>
      <a href="#ResolvedAlterIndexStmt">ResolvedAlterIndexStmt</a>
      <a href="#ResolvedAlterMaterializedViewStmt">ResolvedAlterMaterializedViewStmt</a>
      <a href="#ResolvedAlterModelStmt">ResolvedAlterModelStmt</a>
      <a href="#ResolvedAlterPrivilegeRestrictionStmt">ResolvedAlterPrivilegeRestrictionStmt</a>
      <a href="#ResolvedAlterRowAccessPolicyStmt">ResolvedAlterRowAccessPolicyStmt</a>
      <a href="#ResolvedAlterSchemaStmt">ResolvedAlterSchemaStmt</a>
      <a href="#ResolvedAlterSequenceStmt">ResolvedAlterSequenceStmt</a>
      <a href="#ResolvedAlterTableStmt">ResolvedAlterTableStmt</a>
      <a href="#ResolvedAlterViewStmt">ResolvedAlterViewStmt</a>
    <a href="#ResolvedAlterTableSetOptionsStmt">ResolvedAlterTableSetOptionsStmt</a>
    <a href="#ResolvedAnalyzeStmt">ResolvedAnalyzeStmt</a>
    <a href="#ResolvedAssertStmt">ResolvedAssertStmt</a>
    <a href="#ResolvedAssignmentStmt">ResolvedAssignmentStmt</a>
    <a href="#ResolvedAuxLoadDataStmt">ResolvedAuxLoadDataStmt</a>
    <a href="#ResolvedBeginStmt">ResolvedBeginStmt</a>
    <a href="#ResolvedCallStmt">ResolvedCallStmt</a>
    <a href="#ResolvedCloneDataStmt">ResolvedCloneDataStmt</a>
    <a href="#ResolvedCommitStmt">ResolvedCommitStmt</a>
    <a href="#ResolvedCreateDatabaseStmt">ResolvedCreateDatabaseStmt</a>
    <a href="#ResolvedCreateRowAccessPolicyStmt">ResolvedCreateRowAccessPolicyStmt</a>
    <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a>
      <a href="#ResolvedCreateConnectionStmt">ResolvedCreateConnectionStmt</a>
      <a href="#ResolvedCreateConstantStmt">ResolvedCreateConstantStmt</a>
      <a href="#ResolvedCreateEntityStmt">ResolvedCreateEntityStmt</a>
      <a href="#ResolvedCreateFunctionStmt">ResolvedCreateFunctionStmt</a>
      <a href="#ResolvedCreateIndexStmt">ResolvedCreateIndexStmt</a>
      <a href="#ResolvedCreateModelStmt">ResolvedCreateModelStmt</a>
      <a href="#ResolvedCreatePrivilegeRestrictionStmt">ResolvedCreatePrivilegeRestrictionStmt</a>
      <a href="#ResolvedCreateProcedureStmt">ResolvedCreateProcedureStmt</a>
      <a href="#ResolvedCreatePropertyGraphStmt">ResolvedCreatePropertyGraphStmt</a>
      <a href="#ResolvedCreateSchemaStmtBase">ResolvedCreateSchemaStmtBase</a>
        <a href="#ResolvedCreateExternalSchemaStmt">ResolvedCreateExternalSchemaStmt</a>
        <a href="#ResolvedCreateSchemaStmt">ResolvedCreateSchemaStmt</a>
      <a href="#ResolvedCreateSequenceStmt">ResolvedCreateSequenceStmt</a>
      <a href="#ResolvedCreateSnapshotTableStmt">ResolvedCreateSnapshotTableStmt</a>
      <a href="#ResolvedCreateTableFunctionStmt">ResolvedCreateTableFunctionStmt</a>
      <a href="#ResolvedCreateTableStmtBase">ResolvedCreateTableStmtBase</a>
        <a href="#ResolvedCreateExternalTableStmt">ResolvedCreateExternalTableStmt</a>
        <a href="#ResolvedCreateTableAsSelectStmt">ResolvedCreateTableAsSelectStmt</a>
        <a href="#ResolvedCreateTableStmt">ResolvedCreateTableStmt</a>
      <a href="#ResolvedCreateViewBase">ResolvedCreateViewBase</a>
        <a href="#ResolvedCreateApproxViewStmt">ResolvedCreateApproxViewStmt</a>
        <a href="#ResolvedCreateMaterializedViewStmt">ResolvedCreateMaterializedViewStmt</a>
        <a href="#ResolvedCreateViewStmt">ResolvedCreateViewStmt</a>
    <a href="#ResolvedCreateWithEntryStmt">ResolvedCreateWithEntryStmt</a>
    <a href="#ResolvedDefineTableStmt">ResolvedDefineTableStmt</a>
    <a href="#ResolvedDeleteStmt">ResolvedDeleteStmt</a>
    <a href="#ResolvedDescribeStmt">ResolvedDescribeStmt</a>
    <a href="#ResolvedDropFunctionStmt">ResolvedDropFunctionStmt</a>
    <a href="#ResolvedDropIndexStmt">ResolvedDropIndexStmt</a>
    <a href="#ResolvedDropMaterializedViewStmt">ResolvedDropMaterializedViewStmt</a>
    <a href="#ResolvedDropPrivilegeRestrictionStmt">ResolvedDropPrivilegeRestrictionStmt</a>
    <a href="#ResolvedDropRowAccessPolicyStmt">ResolvedDropRowAccessPolicyStmt</a>
    <a href="#ResolvedDropSnapshotTableStmt">ResolvedDropSnapshotTableStmt</a>
    <a href="#ResolvedDropStmt">ResolvedDropStmt</a>
    <a href="#ResolvedDropTableFunctionStmt">ResolvedDropTableFunctionStmt</a>
    <a href="#ResolvedExecuteImmediateStmt">ResolvedExecuteImmediateStmt</a>
    <a href="#ResolvedExplainStmt">ResolvedExplainStmt</a>
    <a href="#ResolvedExportDataStmt">ResolvedExportDataStmt</a>
    <a href="#ResolvedExportMetadataStmt">ResolvedExportMetadataStmt</a>
    <a href="#ResolvedExportModelStmt">ResolvedExportModelStmt</a>
    <a href="#ResolvedGeneralizedQueryStmt">ResolvedGeneralizedQueryStmt</a>
    <a href="#ResolvedGrantOrRevokeStmt">ResolvedGrantOrRevokeStmt</a>
      <a href="#ResolvedGrantStmt">ResolvedGrantStmt</a>
      <a href="#ResolvedRevokeStmt">ResolvedRevokeStmt</a>
    <a href="#ResolvedImportStmt">ResolvedImportStmt</a>
    <a href="#ResolvedInsertStmt">ResolvedInsertStmt</a>
    <a href="#ResolvedMergeStmt">ResolvedMergeStmt</a>
    <a href="#ResolvedModuleStmt">ResolvedModuleStmt</a>
    <a href="#ResolvedMultiStmt">ResolvedMultiStmt</a>
    <a href="#ResolvedQueryStmt">ResolvedQueryStmt</a>
    <a href="#ResolvedRenameStmt">ResolvedRenameStmt</a>
    <a href="#ResolvedRollbackStmt">ResolvedRollbackStmt</a>
    <a href="#ResolvedRunBatchStmt">ResolvedRunBatchStmt</a>
    <a href="#ResolvedSetTransactionStmt">ResolvedSetTransactionStmt</a>
    <a href="#ResolvedShowStmt">ResolvedShowStmt</a>
    <a href="#ResolvedStartBatchStmt">ResolvedStartBatchStmt</a>
    <a href="#ResolvedStatementWithPipeOperatorsStmt">ResolvedStatementWithPipeOperatorsStmt</a>
    <a href="#ResolvedSubpipelineStmt">ResolvedSubpipelineStmt</a>
    <a href="#ResolvedTruncateStmt">ResolvedTruncateStmt</a>
    <a href="#ResolvedUndropStmt">ResolvedUndropStmt</a>
    <a href="#ResolvedUpdateStmt">ResolvedUpdateStmt</a>
</code></pre></p>

## Node Details

NOTE: This documentation includes only the public field accessors. It excludes
constructors, setters, and boilerplate implementation of virtual methods from
the base class.

### ResolvedArgument
<a id="ResolvedArgument"></a>

<p><pre><code class="lang-c++"><font color="brown">// Argument nodes are not self-contained nodes in the tree.  They exist
// only to describe parameters to another node (e.g. columns in an OrderBy).
// This node is here for organizational purposes only, to cluster these
// argument nodes.</font>
class ResolvedArgument : public <a href="#ResolvedNode">ResolvedNode</a> {
};
</code></pre></p>

### ResolvedExpr
<a id="ResolvedExpr"></a>

<p><pre><code class="lang-c++">class ResolvedExpr : public <a href="#ResolvedNode">ResolvedNode</a> {
  bool IsExpression() const final { return true; }

  AnnotatedType annotated_type() const {
    return {type(), type_annotation_map()};
  }

  const Type* type() const;

  const AnnotationMap* type_annotation_map() const;
};
</code></pre></p>

### ResolvedLiteral
<a id="ResolvedLiteral"></a>

<p><pre><code class="lang-c++"><font color="brown">// Any literal value, including NULL literals.
// There is a special-cased constructor here that gets the type from the
// Value.</font>
class ResolvedLiteral : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_LITERAL;

  const Value&amp; value() const;

<font color="brown">  // If true, then the literal is explicitly typed and cannot be used
  // for literal coercions.
  //
  // This exists mainly for resolver bookkeeping and should be ignored
  // by engines.</font>
  bool has_explicit_type() const;

<font color="brown">  // Distinct ID of the literal, if it is a floating point value,
  // within the resolved AST. When coercing from floating point
  // to NUMERIC, the resolver uses the float_literal_id to find the
  // original image of the literal to avoid precision loss. An ID of 0
  // represents a literal without a cached image.</font>
  int float_literal_id() const;

<font color="brown">  // Indicates whether ReplaceLiteralsByParameters() should leave
  // this literal value in place, rather than replace it with a query
  // parameter.</font>
  bool preserve_in_literal_remover() const;
};
</code></pre></p>

### ResolvedParameter
<a id="ResolvedParameter"></a>

<p><pre><code class="lang-c++">class ResolvedParameter : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PARAMETER;

<font color="brown">  // If non-empty, the name of the parameter.
  //
  // A <a href="#ResolvedParameter">ResolvedParameter</a> will have either a name or a position but not
  // both.</font>
  const std::string&amp; name() const;

<font color="brown">  // If non-zero, the 1-based position of the positional parameter.
  //
  // A <a href="#ResolvedParameter">ResolvedParameter</a> will have either a name or a position but not
  // both.</font>
  int position() const;

<font color="brown">  // If true, then the parameter has no specified type.
  //
  // This exists mainly for resolver bookkeeping and should be ignored
  // by engines.</font>
  bool is_untyped() const;
};
</code></pre></p>

### ResolvedExpressionColumn
<a id="ResolvedExpressionColumn"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a column when analyzing a standalone expression.
// This is only used when the analyzer was called using AnalyzeExpression.
// Expression column names and types come from
// AnalyzerOptions::AddExpressionColumn.
// &lt;name&gt; will always be in lowercase.</font>
class ResolvedExpressionColumn : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXPRESSION_COLUMN;

  const std::string&amp; name() const;
};
</code></pre></p>

### ResolvedCatalogColumnRef
<a id="ResolvedCatalogColumnRef"></a>

<p><pre><code class="lang-c++"><font color="brown">// An expression referencing a Column from the Catalog. This is used to
// represent a column reference in an expression inside a DDL statement.
// The DDL statement will normally define the Table context, and the
// referenced Column should be a Column of that Table.</font>
class ResolvedCatalogColumnRef : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CATALOG_COLUMN_REF;

  const Column* column() const;
};
</code></pre></p>

### ResolvedColumnRef
<a id="ResolvedColumnRef"></a>

<p><pre><code class="lang-c++"><font color="brown">// An expression referencing the value of some column visible in the
// current Scan node.
//
// If &lt;is_correlated&gt; is false, this must be a column visible in the Scan
// containing this expression, either because it was produced inside that
// Scan or it is on the &lt;column_list&gt; of some child of this Scan.
//
// If &lt;is_correlated&gt; is true, this references a column from outside a
// subquery that is visible as a correlated column inside.
// The column referenced here must show up on the parameters list for the
// subquery.  See <a href="#ResolvedSubqueryExpr">ResolvedSubqueryExpr</a>.</font>
class ResolvedColumnRef : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_COLUMN_REF;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const;

  bool is_correlated() const;
};
</code></pre></p>

### ResolvedGroupingSetMultiColumn
<a id="ResolvedGroupingSetMultiColumn"></a>

<p><pre><code class="lang-c++"><font color="brown">// A list of <a href="#ResolvedColumnRef">ResolvedColumnRef</a> expression references that will be batched
// together in rollup/cube when being expanded to grouping sets. For
// example, ROLLUP((a, b), c) will be expanded to 3 grouping sets [(a, b, c),
// (a, b), ()], (a, b) is a multi-column.
//
// Duplicated columns are not allowed in the <a href="#ResolvedGroupingSetMultiColumn">ResolvedGroupingSetMultiColumn</a>
// as they are equivalent to deduplicated columns. column_list must have
// at least one element inside.</font>
class ResolvedGroupingSetMultiColumn : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GROUPING_SET_MULTI_COLUMN;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; column_list() const;
  int column_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* column_list(int i) const;
};
</code></pre></p>

### ResolvedConstant
<a id="ResolvedConstant"></a>

<p><pre><code class="lang-c++"><font color="brown">// A reference to a named constant.</font>
class ResolvedConstant : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CONSTANT;

<font color="brown">  // The matching Constant from the Catalog.</font>
  const Constant* constant() const;
};
</code></pre></p>

### ResolvedSystemVariable
<a id="ResolvedSystemVariable"></a>

<p><pre><code class="lang-c++"><font color="brown">// A reference to a system variable.</font>
class ResolvedSystemVariable : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SYSTEM_VARIABLE;

<font color="brown">  // Path to system variable.</font>
  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;
};
</code></pre></p>

### ResolvedInlineLambda
<a id="ResolvedInlineLambda"></a>

<p><pre><code class="lang-c++"><font color="brown">// A lambda expression, used inline as a function argument.
// This represents both the definition of the lambda and the resolution of
// its templated signature and body for this function call.
// Currently can only be used as an argument of a function.
//
// &lt;argument_list&gt; defines the argument types and names for the lambda, and
// creates new <a href="#ResolvedColumn">ResolvedColumns</a> which can be used to reference the arguments
// inside &lt;body&gt;.
//
// The return type of the lambda function is the type of &lt;body&gt;.
//
// In addition to the &lt;argument_list&gt;, the body of a lambda expression can
// reference columns visible to the scope of the function call for which this
// lambda is provided as an argument. Columns in this scope accessed by the
// body are stored in &lt;parameter_list&gt;.
//
// For example, the following query
//   SELECT ARRAY_FILTER([1,2,3], e -&gt; e = key) FROM KeyValue;
// would have a lambda with &lt;parameter_list&gt; [&#39;key&#39;] and &lt;argument_list&gt;
// [&#39;e&#39;].
//
// &lt;body&gt; is the body expression of the lambda. The expression can only
// reference columns in &lt;parameter_list&gt; and &lt;argument_list&gt;.</font>
class ResolvedInlineLambda : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_INLINE_LAMBDA;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; argument_list() const;
  int argument_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> argument_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; parameter_list() const;
  int parameter_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* parameter_list(int i) const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* body() const;
};
</code></pre></p>

### ResolvedSequence
<a id="ResolvedSequence"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents a sequence as a function argument</font>
class ResolvedSequence : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SEQUENCE;

  const Sequence* sequence() const;
};
</code></pre></p>

### ResolvedFilterFieldArg
<a id="ResolvedFilterFieldArg"></a>

<p><pre><code class="lang-c++"><font color="brown">// An argument to the FILTER_FIELDS() function which specifies a sign to show
// inclusion/exclusion status and a field path to include or exclude.</font>
class ResolvedFilterFieldArg : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FILTER_FIELD_ARG;

<font color="brown">  // True if we want to include this proto path in the resulting proto
  // (though we may still remove paths below it).
  // If False, we will remove this path (but may still include paths
  // below it).</font>
  bool include() const;

<font color="brown">  // A vector of FieldDescriptors that denotes the path to a proto
  // field that will be include or exclude.</font>
  const std::vector&lt;const google::protobuf::FieldDescriptor*&gt;&amp; field_descriptor_path() const;
  int field_descriptor_path_size() const;
  const google::protobuf::FieldDescriptor* field_descriptor_path(int i) const;
};
</code></pre></p>

### ResolvedFilterField
<a id="ResolvedFilterField"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents a call to the FILTER_FIELDS() function. This function can be
// used to modify a proto, prune fields and output the resulting proto. The
// SQL syntax for this function is
//   FILTER_FIELDS(&lt;expr&gt;, &lt;filter_field_arg_list&gt;).
//
// &lt;expr&gt; must have proto type. &lt;filter_field_arg&gt; contains a sign (&#39;+&#39; or
// &#39;-&#39;) and a field path starting from the proto.
//
// For example:
//   FILTER_FIELDS(proto, +field1, -field1.field2)
// means the resulting proto only contains field1.* except field1.field2.*.
//
// Field paths are evaluated and processed in order,
// ```
//   IF filter_field_arg_list[0].include:
//     CLEAR all fields
//   FOR filter_field_arg IN filter_field_arg_list:
//     IF filter_field_arg.include:
//       UNCLEAR filter_field_arg.field_descriptor_path (and all children)
//     ELSE:
//       CLEAR filter_field_arg.field_descriptor_path (and all children)
// ```
//
// The order of field_field args have following constraints:
// 1. There must be at least one filter_field arg.
// 2. Args for ancestor fields must precede descendants.
// 3. Each arg must have opposite `include` compared to the last preceding
//    ancestor field.
//
// See (broken link) for more detail.</font>
class ResolvedFilterField : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FILTER_FIELD;

<font color="brown">  // The proto to modify.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // The list of field paths to include or exclude. The path starts
  // from the proto type of &lt;expr&gt;.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedFilterFieldArg">ResolvedFilterFieldArg</a>&gt;&gt;&amp; filter_field_arg_list() const;
  int filter_field_arg_list_size() const;
  const <a href="#ResolvedFilterFieldArg">ResolvedFilterFieldArg</a>* filter_field_arg_list(int i) const;

<font color="brown">  // If true, will reset cleared required fields into a
  // default value.</font>
  bool reset_cleared_required_fields() const;
};
</code></pre></p>

### ResolvedFunctionCallBase
<a id="ResolvedFunctionCallBase"></a>

<p><pre><code class="lang-c++"><font color="brown">// Common base class for scalar and aggregate function calls.
//
// &lt;argument_list&gt; contains a list of arguments of type <a href="#ResolvedExpr">ResolvedExpr</a>.
//
// &lt;generic_argument_list&gt; contains an alternative list of generic arguments.
// This is used for function calls that accept non-expression arguments (i.e.
// arguments that aren&#39;t part of the type system, like lambdas).
//
// If all arguments of this function call are <a href="#ResolvedExpr">ResolvedExprs</a>, &lt;argument_list&gt;
// is used. If any of the argument is not a <a href="#ResolvedExpr">ResolvedExpr</a>,
// &lt;generic_argument_list&gt; will be used. Only one of &lt;argument_list&gt; or
// &lt;generic_argument_list&gt; can be non-empty.
//
// &lt;collation_list&gt; (only set when FEATURE_COLLATION_SUPPORT is
// enabled) is the operation collation to use.
// (broken link) lists the functions affected by
// collation, where this can show up.
// &lt;collation_list&gt; is a vector for future extension. For now, functions
// could have at most one element in the &lt;collation_list&gt;.</font>
class ResolvedFunctionCallBase : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  typedef <a href="#ResolvedFunctionCallBaseEnum">ResolvedFunctionCallBaseEnums</a>::ErrorMode ErrorMode;
  static const ErrorMode DEFAULT_ERROR_MODE = <a href="#ResolvedFunctionCallBaseEnum">ResolvedFunctionCallBaseEnums</a>::DEFAULT_ERROR_MODE;
  static const ErrorMode SAFE_ERROR_MODE = <a href="#ResolvedFunctionCallBaseEnum">ResolvedFunctionCallBaseEnums</a>::SAFE_ERROR_MODE;

<font color="brown">  // The matching Function from the Catalog.</font>
  const Function* function() const;

<font color="brown">  // The concrete FunctionSignature reflecting the matching Function
  // signature and the function&#39;s resolved input &lt;argument_list&gt;.
  // The function has the mode AGGREGATE iff it is an aggregate
  // function, in which case this node must be either
  // <a href="#ResolvedAggregateFunctionCall">ResolvedAggregateFunctionCall</a> or <a href="#ResolvedAnalyticFunctionCall">ResolvedAnalyticFunctionCall</a>.</font>
  const FunctionSignature&amp; signature() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; argument_list() const;
  int argument_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* argument_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedFunctionArgument">ResolvedFunctionArgument</a>&gt;&gt;&amp; generic_argument_list() const;
  int generic_argument_list_size() const;
  const <a href="#ResolvedFunctionArgument">ResolvedFunctionArgument</a>* generic_argument_list(int i) const;

<font color="brown">  // If error_mode=SAFE_ERROR_MODE, and if this function call returns a
  // semantic error (based on input data, not transient server
  // problems), return NULL instead of an error. This is used for
  // functions called using SAFE, as in SAFE.FUNCTION(...).</font>
  <a href="#ResolvedFunctionCallBase">ResolvedFunctionCallBase</a>::ErrorMode error_mode() const;

<font color="brown">  // Function call hints.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; hint_list() const;
  int hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* hint_list(int i) const;

  const std::vector&lt;<a href="#ResolvedCollation">ResolvedCollation</a>&gt;&amp; collation_list() const;
  int collation_list_size() const;
  <a href="#ResolvedCollation">ResolvedCollation</a> collation_list(int i) const;
};
</code></pre></p>

### ResolvedFunctionCall
<a id="ResolvedFunctionCall"></a>

<p><pre><code class="lang-c++"><font color="brown">// A regular function call.  The signature will always have mode SCALAR.
// Most scalar expressions show up as FunctionCalls using builtin signatures.</font>
class ResolvedFunctionCall : public <a href="#ResolvedFunctionCallBase">ResolvedFunctionCallBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FUNCTION_CALL;

<font color="brown">  // This contains optional custom information about a particular
  // function call.
  //
  // If some Function subclass requires computing additional
  // information at resolving time, that extra information can be
  // stored as a subclass of <a href="#ResolvedFunctionCallInfo">ResolvedFunctionCallInfo</a> here.
  // For example, TemplatedSQLFunction stores the resolved template
  // body here as a TemplatedSQLFunctionCall.
  //
  // This field is ignorable because for most types of function calls,
  // there is no extra information to consider besides the arguments
  // and other fields from <a href="#ResolvedFunctionCallBase">ResolvedFunctionCallBase</a>.</font>
  const std::shared_ptr&lt;<a href="#ResolvedFunctionCallInfo">ResolvedFunctionCallInfo</a>&gt;&amp; function_call_info() const;
};
</code></pre></p>

### ResolvedNonScalarFunctionCallBase
<a id="ResolvedNonScalarFunctionCallBase"></a>

<p><pre><code class="lang-c++"><font color="brown">// Common base class for analytic and aggregate function calls.
//
// `where_expr` is a scalar filtering expression with standard column
// visibility rules (columns from the input scan are visible, as are
// correlated columns).</font>
class ResolvedNonScalarFunctionCallBase : public <a href="#ResolvedFunctionCallBase">ResolvedFunctionCallBase</a> {
  typedef <a href="#ResolvedNonScalarFunctionCallBaseEnum">ResolvedNonScalarFunctionCallBaseEnums</a>::NullHandlingModifier NullHandlingModifier;
  static const NullHandlingModifier DEFAULT_NULL_HANDLING = <a href="#ResolvedNonScalarFunctionCallBaseEnum">ResolvedNonScalarFunctionCallBaseEnums</a>::DEFAULT_NULL_HANDLING;
  static const NullHandlingModifier IGNORE_NULLS = <a href="#ResolvedNonScalarFunctionCallBaseEnum">ResolvedNonScalarFunctionCallBaseEnums</a>::IGNORE_NULLS;
  static const NullHandlingModifier RESPECT_NULLS = <a href="#ResolvedNonScalarFunctionCallBaseEnum">ResolvedNonScalarFunctionCallBaseEnums</a>::RESPECT_NULLS;

<font color="brown">  // Apply DISTINCT to the stream of input values before calling
  // function.</font>
  bool distinct() const;

<font color="brown">  // Apply IGNORE/RESPECT NULLS filtering to the stream of input
  // values.</font>
  <a href="#ResolvedNonScalarFunctionCallBase">ResolvedNonScalarFunctionCallBase</a>::NullHandlingModifier null_handling_modifier() const;

<font color="brown">  // Holds a table subquery defined in WITH GROUP ROWS(...) that is
  // evaluated over the input rows of a <a href="#ResolvedAggregateScan">ResolvedAggregateScan</a>
  // corresponding to the current group. The function itself is
  // evaluated over the rows returned from the subquery.
  //
  // The subquery should refer to a special TVF GROUP_ROWS(), which
  // resolves as <a href="#ResolvedGroupRowsScan">ResolvedGroupRowsScan</a>. The subquery will be run for
  // each group produced by <a href="#ResolvedAggregateScan">ResolvedAggregateScan</a>.
  //
  // GROUP_ROWS() produces a row for each source row in the
  // <a href="#ResolvedAggregateScan">ResolvedAggregateScan</a>&#39;s input that matches current group.
  //
  // The subquery cannot reference any <a href="#ResolvedColumn">ResolvedColumns</a> from the outer
  // query except what comes in via &lt;with_group_rows_parameter_list&gt;,
  // and GROUP_ROWS().
  //
  // The subquery can return more than one column, and these columns
  // can be referenced by the function.
  //
  // The subquery can be correlated. In this case the
  // &lt;with_group_rows_parameter_list&gt; gives the set of <a href="#ResolvedColumn">ResolvedColumns</a>
  // from outside the subquery that are used inside. The subuery cannot
  // refer to correlated columns that are used as aggregation input in
  // the immediate outer query. The same rules apply to
  // &lt;with_group_rows_parameter_list&gt; as in <a href="#ResolvedSubqueryExpr">ResolvedSubqueryExpr</a>.</font>
  const <a href="#ResolvedScan">ResolvedScan</a>* with_group_rows_subquery() const;

<font color="brown">  // Correlated parameters to &lt;with_group_rows_subquery&gt;</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; with_group_rows_parameter_list() const;
  int with_group_rows_parameter_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* with_group_rows_parameter_list(int i) const;

<font color="brown">  // A scalar filtering expression to apply before supplying rows to
  // the function. Allowed only when FEATURE_AGGREGATE_FILTERING
  // is enabled.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* where_expr() const;
};
</code></pre></p>

### ResolvedAggregateFunctionCall
<a id="ResolvedAggregateFunctionCall"></a>

<p><pre><code class="lang-c++"><font color="brown">// An aggregate function call.  The signature always has mode AGGREGATE.
//
// FEATURE_MULTILEVEL_AGGREGATION enables multi-level aggregate
// expressions (e.g. &#39;SUM(AVG(1 + X) GROUP BY key)&#39; ). The GROUP BY modifier
// within an aggregate function body indicates the presence of a multi-level
// aggregate expression.
//
// `group_by_aggregate_list` can only be present if `group_by_list` is
// present. `group_by_list` and `group_by_aggregate_list` are mutually
// exclusive with `having_modifier`.
//
// If `group_by_list` is empty, then standard column visibility rules apply
// (i.e. columns supplied by input scan to the enclosing AggregateScan are
// visible to argument expressions and aggregate function modifiers, as are
// correlated columns).
//
// If `group_by_list` is non-empty, the initial aggregation is applied first,
// computing the aggregate and grouping columns in `group_by_aggregate_list`
// `group_by_list`.  Only these computed columns (plus correlated columns)
// are visible to argument expressions and aggregate function modifiers
// (e.g. DISTINCT, IGNORE / RESPECT NULLS, LIMIT, ORDER BY). These
// modifiers are applied on the output rows from the initial aggregation,
// as input to the final aggregation.
//
// FEATURE_AGGREGATE_FILTERING enables aggregate filtering.
// `where_expr` is applied before other aggregate function modifiers
// (including any inner grouping specified by the `group_by_list`).
// `having_expr` can only be present if `group_by_list` is also present,
// and can only reference columns from the `group_by_list` and
// `group_by_aggregate_list` (plus any correlated columns).</font>
class ResolvedAggregateFunctionCall : public <a href="#ResolvedNonScalarFunctionCallBase">ResolvedNonScalarFunctionCallBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_AGGREGATE_FUNCTION_CALL;

<font color="brown">  // Apply HAVING MAX/MIN filtering to the stream of input values.</font>
  const <a href="#ResolvedAggregateHavingModifier">ResolvedAggregateHavingModifier</a>* having_modifier() const;

<font color="brown">  // Apply ordering to the stream of input values before calling
  // function.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>&gt;&gt;&amp; order_by_item_list() const;
  int order_by_item_list_size() const;
  const <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>* order_by_item_list(int i) const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* limit() const;

<font color="brown">  // This contains optional custom information about a particular
  // function call. Functions may introduce subclasses of this class to
  // add custom information as needed on a per-function basis.
  //
  // This field is ignorable because for most types of function calls,
  // there is no extra information to consider besides the arguments
  // and other fields from <a href="#ResolvedFunctionCallBase">ResolvedFunctionCallBase</a>. However, for
  // example, the TemplateSQLFunction in
  // zetasql/public/templated_sql_function.h defines the
  // TemplatedSQLFunctionCall subclass which includes the
  // fully-resolved function body in context of the actual concrete
  // types of the arguments provided to the function call.</font>
  const std::shared_ptr&lt;<a href="#ResolvedFunctionCallInfo">ResolvedFunctionCallInfo</a>&gt;&amp; function_call_info() const;

<font color="brown">  // Group the stream of input values by columns in this list, and
  // compute the aggregates defined in `group_by_aggregate_list`.
  // Used only for multi-level aggregation, when
  // FEATURE_MULTILEVEL_AGGREGATION is enabled.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; group_by_list() const;
  int group_by_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* group_by_list(int i) const;

<font color="brown">  // Hint for the group by list. Only applicable when
  // FEATURE_MULTILEVEL_AGGREGATION is enabled and `group_by_list`
  // is non-empty.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; group_by_hint_list() const;
  int group_by_hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* group_by_hint_list(int i) const;

<font color="brown">  // Aggregate columns to compute over the grouping keys defined in
  // `group_by_list`. Used only for multi-level aggregation, when
  // FEATURE_MULTILEVEL_AGGREGATION is enabled.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumnBase">ResolvedComputedColumnBase</a>&gt;&gt;&amp; group_by_aggregate_list() const;
  int group_by_aggregate_list_size() const;
  const <a href="#ResolvedComputedColumnBase">ResolvedComputedColumnBase</a>* group_by_aggregate_list(int i) const;

<font color="brown">  // A scalar filtering expression applied after computing columns in
  // the `group_by_list` and `group_by_aggregate_list`. Allowed only
  // when FEATURE_AGGREGATE_FILTERING is enabled.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* having_expr() const;
};
</code></pre></p>

### ResolvedAnalyticFunctionCall
<a id="ResolvedAnalyticFunctionCall"></a>

<p><pre><code class="lang-c++"><font color="brown">// An analytic function call. The mode of the function is either AGGREGATE
// or ANALYTIC. This node only ever shows up as a function call in a
// <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>::analytic_function_list. Its associated
// window is not under this node but as a sibling of its parent node.
//
// &lt;window_frame&gt; can be NULL.</font>
class ResolvedAnalyticFunctionCall : public <a href="#ResolvedNonScalarFunctionCallBase">ResolvedNonScalarFunctionCallBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ANALYTIC_FUNCTION_CALL;

  const <a href="#ResolvedWindowFrame">ResolvedWindowFrame</a>* window_frame() const;
};
</code></pre></p>

### ResolvedExtendedCastElement
<a id="ResolvedExtendedCastElement"></a>

<p><pre><code class="lang-c++"><font color="brown">// Describes a leaf extended cast of <a href="#ResolvedExtendedCast">ResolvedExtendedCast</a>. See the comment
// for element_list field of <a href="#ResolvedExtendedCast">ResolvedExtendedCast</a> for more details.</font>
class ResolvedExtendedCastElement : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXTENDED_CAST_ELEMENT;

  const Type* from_type() const;

  const Type* to_type() const;

  const Function* function() const;
};
</code></pre></p>

### ResolvedExtendedCast
<a id="ResolvedExtendedCast"></a>

<p><pre><code class="lang-c++"><font color="brown">// Describes overall cast operation between two values where at least one
// value&#39;s type is or contains an extended type (e.g. on a struct field).</font>
class ResolvedExtendedCast : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXTENDED_CAST;

<font color="brown">  // Stores the list of leaf extended casts required as elements of
  // this cast.  Each element is a cast where at least one of the input
  // or output is an extended type. For structs or arrays, the elements
  // will be casts for the field or element types. For structs, there
  // can be multiple cast elements (one for each distinct pair of field
  // types). For non-struct types, there will be just a single element.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExtendedCastElement">ResolvedExtendedCastElement</a>&gt;&gt;&amp; element_list() const;
  int element_list_size() const;
  const <a href="#ResolvedExtendedCastElement">ResolvedExtendedCastElement</a>* element_list(int i) const;
};
</code></pre></p>

### ResolvedCast
<a id="ResolvedCast"></a>

<p><pre><code class="lang-c++"><font color="brown">// A cast expression, casting the result of an input expression to the
// target Type.
//
// Valid casts are defined in the CastHashMap (see cast.cc), which identifies
// valid from-Type, to-Type pairs.  Consumers can access it through
// GetZetaSQLCasts().</font>
class ResolvedCast : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CAST;

  // Helper getter, setter of &lt;type_parameters&gt; field for backward
  // compatibility.
  // TODO: We could consider dropping this after we clean up
  // all references.
  ABSL_DEPRECATED(&#34;use type_modifiers().type_parameters() instead.&#34;)
  const TypeParameters&amp; type_parameters() const {
    return type_modifiers().type_parameters();
  }

  ABSL_DEPRECATED(&#34;use set_type_modifiers() instead.&#34;)
  void set_type_parameters(const TypeParameters&amp; v);

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // Whether to return NULL if the cast fails. This is set to true for
  // SAFE_CAST.</font>
  bool return_null_on_error() const;

<font color="brown">  // If at least one of types involved in this cast is or contains an
  // extended (TYPE_EXTENDED) type, this field contains information
  // necessary to execute this cast.</font>
  const <a href="#ResolvedExtendedCast">ResolvedExtendedCast</a>* extended_cast() const;

<font color="brown">  // The format string specified by the optional FORMAT clause. It is
  // nullptr when the clause does not exist.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* format() const;

<font color="brown">  // The time zone expression by the optional AT TIME ZONE clause. It
  // is nullptr when the clause does not exist.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* time_zone() const;

<font color="brown">  // Contains the TypeModifiers object which wraps all modifiers
  // following the type name in a type string (e.g. type parameters,
  // collation) in a cast. If there are no type modifiers specified,
  // this object will be empty.
  //
  // Type parameters can be specified inside parentheses following the
  // type name (e.g. STRING(2)). If specified, the result of the cast
  // should conform to the type parameters. Engines are expected to
  // enforce type parameter constraints by erroring out or truncating
  // the cast result, depending on the output type. See
  // (broken link) for more details.
  //
  // For example:
  //   CAST(&#34;ABC&#34; as STRING(2)) should error out
  //   CAST(1234 as NUMERIC(2)) should error out
  //   CAST(1.234 as NUMERIC(2,1)) should return a NumericValue of 1.2
  //
  // Collation can be specified with the COLLATE keyword on a string
  // type, e.g. STRING COLLATE &#39;und:ci&#39;. If specified, the
  // &lt;type_annotation_map&gt; of the <a href="#ResolvedCast">ResolvedCast</a> node will have equal
  // collation annotations. See
  // (broken link) for more details.
  //
  // For example:
  //   CAST(&#34;abc&#34; AS STRING COLLATE &#34;und:ci&#34;) should return value &#34;abc&#34;
  //     in STRING type with collation &#34;und:ci&#34;.
  //   CAST([&#34;abc&#34;] AS ARRAY&lt;STRING COLLATE &#34;und:ci&#34;&gt;) should return
  //     the array [&#34;abc&#34;] with collation &#34;und:ci&#34; at the element type.</font>
  const TypeModifiers&amp; type_modifiers() const;
};
</code></pre></p>

### ResolvedMakeStruct
<a id="ResolvedMakeStruct"></a>

<p><pre><code class="lang-c++"><font color="brown">// Construct a struct value.  &lt;type&gt; is always a StructType.
// &lt;field_list&gt; matches 1:1 with the fields in &lt;type&gt; position-wise.
// Each field&#39;s type will match the corresponding field in &lt;type&gt;.</font>
class ResolvedMakeStruct : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MAKE_STRUCT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; field_list() const;
  int field_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* field_list(int i) const;
};
</code></pre></p>

### ResolvedMakeProto
<a id="ResolvedMakeProto"></a>

<p><pre><code class="lang-c++"><font color="brown">// Construct a proto value.  &lt;type&gt; is always a ProtoType.
// &lt;field_list&gt; is a vector of (FieldDescriptor, expr) pairs to write.
// &lt;field_list&gt; will contain all required fields, and no duplicate fields.</font>
class ResolvedMakeProto : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MAKE_PROTO;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedMakeProtoField">ResolvedMakeProtoField</a>&gt;&gt;&amp; field_list() const;
  int field_list_size() const;
  const <a href="#ResolvedMakeProtoField">ResolvedMakeProtoField</a>* field_list(int i) const;
};
</code></pre></p>

### ResolvedMakeProtoField
<a id="ResolvedMakeProtoField"></a>

<p><pre><code class="lang-c++"><font color="brown">// One field assignment in a <a href="#ResolvedMakeProto">ResolvedMakeProto</a> expression.
// The type of expr will match with the zetasql type of the proto field.
// The type will be an array iff the field is repeated.
//
// For NULL values of &lt;expr&gt;, the proto field should be cleared.
//
// If any value of &lt;expr&gt; cannot be written into the field, this query
// should fail.</font>
class ResolvedMakeProtoField : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MAKE_PROTO_FIELD;

  const google::protobuf::FieldDescriptor* field_descriptor() const;

<font color="brown">  // Provides the Format annotation that should be used when building
  // this field.  The annotation specifies both the ZetaSQL type and
  // the encoding format for this field.</font>
  FieldFormat::Format format() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;
};
</code></pre></p>

### ResolvedGetStructField
<a id="ResolvedGetStructField"></a>

<p><pre><code class="lang-c++"><font color="brown">// Get the field in position &lt;field_idx&gt; (0-based) from &lt;expr&gt;, which has a
// STRUCT type.</font>
class ResolvedGetStructField : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GET_STRUCT_FIELD;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

  int field_idx() const;

<font color="brown">  // True if using s[OFFSET(0)] syntax rather than
  // specifying field name, Only for preserving user intent; no
  // semantic consequences</font>
  bool field_expr_is_positional() const;
};
</code></pre></p>

### ResolvedGetProtoField
<a id="ResolvedGetProtoField"></a>

<p><pre><code class="lang-c++">class ResolvedGetProtoField : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GET_PROTO_FIELD;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // The proto2 FieldDescriptor to extract.  This provides the tag
  // number and wire type.  Additional decoding may be necessary if any
  // of the other modifiers below are set.  Consumers should use those
  // ZetaSQL-computed modifiers rather than examining field
  // annotations directly.
  //
  // The field is an extension field iff
  // field_descriptor-&gt;is_extension() is true.  NOTE: The extended
  // descriptor&#39;s full_name must match the &lt;expr&gt;&#39;s type&#39;s full_name,
  // but may not be the same Descriptor. Extension FieldDescriptors may
  // come from a different DescriptorPool.
  //
  // The field is required if field_descriptor-&gt;is_required().  If the
  // field is required and not present, an error should result.</font>
  const google::protobuf::FieldDescriptor* field_descriptor() const;

<font color="brown">  // Default value to use when the proto field is not set. The default
  // may be NULL (e.g. for proto2 fields with a use_defaults=false
  // annotation).
  //
  // This will not be filled in (the Value will be uninitialized) if
  // get_has_bit is true, or the field is required.
  //
  // If field_descriptor-&gt;is_required() and the field is not present,
  // the engine should return an error.
  //
  // If the &lt;expr&gt; itself returns NULL, then extracting a field should
  // also return NULL, unless &lt;return_default_value_when_unset&gt; is
  // true. In that case, the default value is returned.
  //
  // TODO Make un-ignorable after clients migrate to start
  // using it.</font>
  const Value&amp; default_value() const;

<font color="brown">  // Indicates whether to return a bool indicating if a value was
  // present, rather than return the value (or NULL). Never set for
  // repeated fields. This field cannot be set if
  // &lt;return_default_value_when_unset&gt; is true, and vice versa.
  // Expression type will be BOOL.</font>
  bool get_has_bit() const;

<font color="brown">  // Provides the Format annotation that should be used when reading
  // this field.  The annotation specifies both the ZetaSQL type and
  // the encoding format for this field. This cannot be set when
  // get_has_bit is true.</font>
  FieldFormat::Format format() const;

<font color="brown">  // Indicates that the default value should be returned if &lt;expr&gt;
  // (the parent message) is NULL.  Note that this does *not* affect
  // the return value when the extracted field itself is unset, in
  // which case the return value depends on the extracted field&#39;s
  // annotations (e.g., use_field_defaults).
  //
  // This can only be set for non-message fields. If the field is a
  // proto2 field, then it must be annotated with
  // zetasql.use_defaults=true. This cannot be set when &lt;get_has_bit&gt;
  // is true or the field is required.</font>
  bool return_default_value_when_unset() const;
};
</code></pre></p>

### ResolvedGetJsonField
<a id="ResolvedGetJsonField"></a>

<p><pre><code class="lang-c++"><font color="brown">// Get the field &lt;field_name&gt; from &lt;expr&gt;, which has a JSON type.</font>
class ResolvedGetJsonField : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GET_JSON_FIELD;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

  const std::string&amp; field_name() const;
};
</code></pre></p>

### ResolvedGetRowField
<a id="ResolvedGetRowField"></a>

<p><pre><code class="lang-c++"><font color="brown">// Read a field from a ROW type.
// `expr` must have ROW&lt;T&gt; type, and `column` must be a Column of that Table.
// The output type is that Column&#39;s type.</font>
class ResolvedGetRowField : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GET_ROW_FIELD;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

  const Column* column() const;
};
</code></pre></p>

### ResolvedFlatten
<a id="ResolvedFlatten"></a>

<p><pre><code class="lang-c++"><font color="brown">// Constructs an initial input ARRAY&lt;T&gt; from expr. For each get_field_list
// expr, we evaluate the expression once with each array input element and
// use the output as a new array of inputs for the next get_field_list expr.
// If the result of a single expr is an array, we add each element from that
// array as input to the next step instead of adding the array itself.
//
// The array elements are evaluated and kept in order. For example, if only
// expr is an array, the result will be equivalent to that array having the
// get_field_list evaluated on each array element retaining order.</font>
class ResolvedFlatten : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FLATTEN;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // List of &#39;get&#39; fields to evaluate in order (0 or more struct get
  // fields followed by 0 or more proto or json get fields) starting
  // from expr. Each get is evaluated N times where N is the number of
  // array elements from the previous get (or expr for the first
  // expression) generated.
  //
  // The &#39;get&#39; fields may either be a <a href="#ResolvedGet">ResolvedGet</a>*Field or an array
  // offset function around a <a href="#ResolvedGet">ResolvedGet</a>*Field.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; get_field_list() const;
  int get_field_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* get_field_list(int i) const;
};
</code></pre></p>

### ResolvedFlattenedArg
<a id="ResolvedFlattenedArg"></a>

<p><pre><code class="lang-c++"><font color="brown">// Argument for a child of <a href="#ResolvedFlatten">ResolvedFlatten</a>. This is a placeholder to indicate
// that it will be invoked once for each array element from <a href="#ResolvedFlatten">ResolvedFlatten</a>&#39;s
// expr or previous get_field_list entry.</font>
class ResolvedFlattenedArg : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FLATTENED_ARG;

};
</code></pre></p>

### ResolvedReplaceFieldItem
<a id="ResolvedReplaceFieldItem"></a>

<p><pre><code class="lang-c++"><font color="brown">// An argument to the REPLACE_FIELDS() function which specifies a field path
// and a value that this field will be set to. The field path to be modified
// can be constructed through the &lt;struct_index_path&gt; and &lt;proto_field_path&gt;
// fields. These vectors correspond to field paths in a STRUCT and PROTO,
// respectively. At least one of these vectors must be non-empty.
//
// If only &lt;struct_index_path&gt; is non-empty, then the field path only
// references top-level and nested struct fields.
//
// If only &lt;proto_field_path&gt; is non-empty, then the field path only
// references top-level and nested message fields.
//
// If both &lt;struct_index_path&gt; and &lt;proto_field_path&gt; are non-empty, then the
// field path should be expanded starting with &lt;struct_index_path&gt;. The last
// field in &lt;struct_index_path&gt; will be the proto from which the first field
// in &lt;proto_field_path&gt; is extracted.
//
// &lt;expr&gt; and the field to be modified must be the same type.</font>
class ResolvedReplaceFieldItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_REPLACE_FIELD_ITEM;

<font color="brown">  // The value that the final field in &lt;proto_field_path&gt; will be set
  // to.
  //
  // If &lt;expr&gt; is NULL, the field will be unset. If &lt;proto_field_path&gt;
  // is a required field, the engine must return an error if it is set
  // to NULL.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // A vector of integers that denotes the path to a struct field that
  // will be modified. The integer values in this vector correspond to
  // field positions (0-based) in a STRUCT. If &lt;proto_field_path&gt;
  // is also non-empty, then the field corresponding to the last index
  // in this vector should be of proto type.</font>
  const std::vector&lt;int&gt;&amp; struct_index_path() const;
  int struct_index_path_size() const;
  int struct_index_path(int i) const;

<font color="brown">  // A vector of FieldDescriptors that denotes the path to a proto
  // field that will be modified. If &lt;struct_index_path&gt; is also
  // non-empty, then the first element in this vector should be a
  // subfield of the proto corresponding to the last element in
  // &lt;struct_index_path&gt;.</font>
  const std::vector&lt;const google::protobuf::FieldDescriptor*&gt;&amp; proto_field_path() const;
  int proto_field_path_size() const;
  const google::protobuf::FieldDescriptor* proto_field_path(int i) const;
};
</code></pre></p>

### ResolvedReplaceField
<a id="ResolvedReplaceField"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents a call to the REPLACE_FIELDS() function. This function
// can be used to copy a proto or struct, modify a few fields and
// output the resulting proto or struct. The SQL syntax for this
// function is REPLACE_FIELDS(&lt;expr&gt;, &lt;replace_field_item_list&gt;).
//
// See (broken link) for more detail.</font>
class ResolvedReplaceField : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_REPLACE_FIELD;

<font color="brown">  // The proto/struct to modify.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // The list of field paths to be modified along with their new
  // values.
  //
  // Engines must check at evaluation time that the modifications in
  // &lt;replace_field_item_list&gt; obey the following rules
  // regarding updating protos in ZetaSQL:
  // - Modifying a subfield of a NULL-valued proto-valued field is an
  //   error.
  // - Clearing a required field or subfield is an error.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedReplaceFieldItem">ResolvedReplaceFieldItem</a>&gt;&gt;&amp; replace_field_item_list() const;
  int replace_field_item_list_size() const;
  const <a href="#ResolvedReplaceFieldItem">ResolvedReplaceFieldItem</a>* replace_field_item_list(int i) const;
};
</code></pre></p>

### ResolvedGetProtoOneof
<a id="ResolvedGetProtoOneof"></a>

<p><pre><code class="lang-c++"><font color="brown">// Returns a string value indicating which field of &lt;oneof_descriptor&gt; is
// set in the containing proto &lt;expr&gt;. If none of the fields are set, an
// empty string is returned.
//
// See (broken link) for more detail.</font>
class ResolvedGetProtoOneof : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GET_PROTO_ONEOF;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // The google::protobuf::OneofDescriptor for a Oneof contained in &lt;expr&gt;.
  // This descriptor provides google::protobuf::FieldDescriptors for each of
  // the fields contained in the Oneof.</font>
  const google::protobuf::OneofDescriptor* oneof_descriptor() const;
};
</code></pre></p>

### ResolvedSubqueryExpr
<a id="ResolvedSubqueryExpr"></a>

<p><pre><code class="lang-c++"><font color="brown">// A subquery in an expression (not a FROM clause).  The subquery runs
// in the context of a single input row and produces a single output value.
//
// Correlated subqueries can be thought of like functions, with a parameter
// list.  The &lt;parameter_list&gt; gives the set of <a href="#ResolvedColumn">ResolvedColumns</a> from outside
// the subquery that are used inside.
//
// Inside the subquery, the only allowed references to values outside the
// subquery are to the named ColumnRefs listed in &lt;parameter_list&gt;.
// Any reference to one of these parameters will be represented as a
// <a href="#ResolvedColumnRef">ResolvedColumnRef</a> with &lt;is_correlated&gt; set to true.
//
// These parameters are only visible through one level of expression
// subquery.  An expression subquery inside an expression has to list
// parameters again if parameters from the outer query are passed down
// further.  (This does not apply for table subqueries inside an expression
// subquery.  Table subqueries are never indicated in the resolved AST, so
// Scan nodes inside an expression query may have come from a nested table
// subquery, and they can still reference the expression subquery&#39;s
// parameters.)
//
// An empty &lt;parameter_list&gt; means that the subquery is uncorrelated.  It is
// permissable to run an uncorrelated subquery only once and reuse the result.
// TODO Do we want to specify semantics more firmly here?
//
// The semantics vary based on SubqueryType:
//   SCALAR
//     Usage: ( &lt;subquery&gt; )
//     If the subquery produces zero rows, the output value is NULL.
//     If the subquery produces exactly one row, that row is the output value.
//     If the subquery produces more than one row, raise a runtime error.
//
//   ARRAY
//     Usage: ARRAY( &lt;subquery&gt; )
//     The subquery produces an array value with zero or more rows, with
//     one array element per subquery row produced.
//
//   EXISTS
//     Usage: EXISTS( &lt;subquery&gt; )
//     The output type is always bool.  The result is true if the subquery
//     produces at least one row, and false otherwise.
//
//   IN
//     Usage: &lt;in_expr&gt; [NOT] IN ( &lt;subquery&gt; )
//     The output type is always bool.  The result is true when &lt;in_expr&gt; is
//     equal to at least one row, and false otherwise.  The &lt;subquery&gt; row
//     contains only one column, and the types of &lt;in_expr&gt; and the
//     subquery column must exactly match a built-in signature for the
//     &#39;$equals&#39; comparison function (they must be the same type or one
//     must be INT64 and the other UINT64).  NOT will be expressed as a $not
//     FunctionCall wrapping this SubqueryExpr.
//
//  LIKE
//     Usage: &lt;in_expr&gt; [NOT] LIKE ANY|SOME|ALL ( &lt;subquery&gt; )
//     The output type is always bool. The result is true when &lt;in_expr&gt;
//     matches at least one row for LIKE ANY|SOME or matches all rows for
//     LIKE ALL, and false otherwise.  The &lt;subquery&gt; row contains only one
//     column, and the types of &lt;in_expr&gt; and the subquery column must
//     exactly match a built-in signature for the relevant &#39;$like_any&#39; or
//     &#39;$like_all&#39; comparison function (both must be the same type of either
//     STRING or BYTES).  NOT will be expressed as a $not FunctionCall
//     wrapping this SubqueryExpr.
//
// The subquery for a SCALAR, ARRAY, IN or LIKE subquery must have exactly
// one output column.
// The output type for a SCALAR or ARRAY subquery is that column&#39;s type or
// an array of that column&#39;s type.  (The subquery scan may include a Project
// with a MakeStruct or MakeProto expression to construct a single value
// from multiple columns.)</font>
class ResolvedSubqueryExpr : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SUBQUERY_EXPR;

  typedef <a href="#ResolvedSubqueryExprEnum">ResolvedSubqueryExprEnums</a>::SubqueryType SubqueryType;
  static const SubqueryType SCALAR = <a href="#ResolvedSubqueryExprEnum">ResolvedSubqueryExprEnums</a>::SCALAR;
  static const SubqueryType ARRAY = <a href="#ResolvedSubqueryExprEnum">ResolvedSubqueryExprEnums</a>::ARRAY;
  static const SubqueryType EXISTS = <a href="#ResolvedSubqueryExprEnum">ResolvedSubqueryExprEnums</a>::EXISTS;
  static const SubqueryType IN = <a href="#ResolvedSubqueryExprEnum">ResolvedSubqueryExprEnums</a>::IN;
  static const SubqueryType LIKE_ANY = <a href="#ResolvedSubqueryExprEnum">ResolvedSubqueryExprEnums</a>::LIKE_ANY;
  static const SubqueryType LIKE_ALL = <a href="#ResolvedSubqueryExprEnum">ResolvedSubqueryExprEnums</a>::LIKE_ALL;
  static const SubqueryType NOT_LIKE_ANY = <a href="#ResolvedSubqueryExprEnum">ResolvedSubqueryExprEnums</a>::NOT_LIKE_ANY;
  static const SubqueryType NOT_LIKE_ALL = <a href="#ResolvedSubqueryExprEnum">ResolvedSubqueryExprEnums</a>::NOT_LIKE_ALL;

  <a href="#ResolvedSubqueryExpr">ResolvedSubqueryExpr</a>::SubqueryType subquery_type() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; parameter_list() const;
  int parameter_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* parameter_list(int i) const;

<font color="brown">  // Field is only populated for subqueries of type IN or LIKE
  // ANY|SOME|ALL.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* in_expr() const;

<font color="brown">  // Field is only populated for subqueries of type IN to specify the
  // operation collation to use to compare &lt;in_expr&gt; with the rows from
  // &lt;subquery&gt;.</font>
  const <a href="#ResolvedCollation">ResolvedCollation</a>&amp; in_collation() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* subquery() const;

<font color="brown">  // Note: Hints currently happen only for EXISTS, IN, or a LIKE
  // expression subquery but not for ARRAY or SCALAR subquery.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; hint_list() const;
  int hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* hint_list(int i) const;
};
</code></pre></p>

### ResolvedWithExpr
<a id="ResolvedWithExpr"></a>

<p><pre><code class="lang-c++"><font color="brown">// <a href="#ResolvedWithExpr">ResolvedWithExpr</a> introduces one or more columns in &lt;assignment_list&gt; that
// can then be referenced inside &lt;expr&gt;. Each assigned expression is
// evaluated once, and each reference to that column in &lt;expr&gt; sees the same
// value even if the assigned expression is volatile. Multiple assignment
// expressions are independent and cannot reference other columns in the
// &lt;assignment_list&gt;.
//
// &lt;assignment_list&gt; One or more columns that are computed before evaluating
//                   &lt;expr&gt;, and which may be referenced by &lt;expr&gt;.
// &lt;expr&gt; Computes the result of the <a href="#ResolvedWithExpr">ResolvedWithExpr</a>. May reference columns
//        from &lt;assignment_list&gt;.</font>
class ResolvedWithExpr : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WITH_EXPR;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; assignment_list() const;
  int assignment_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* assignment_list(int i) const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;
};
</code></pre></p>

### ResolvedScan
<a id="ResolvedScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Common superclass for all Scans, which are nodes that produce rows
// (e.g. scans, joins, table subqueries).  A query&#39;s FROM clause is
// represented as a single Scan that composes all input sources into
// a single row stream.
//
// Each Scan has a `column_list` that says which <a href="#ResolvedColumn">ResolvedColumns</a> are returned.
// The Scan logically produces a stream of output rows, where each row
// has exactly these columns.
//
// By default, `column_list` references columns that come from input scans
// or are created by other fields in this node.
// If `column_list_is_created_columns`, then all `column_list` columns are
// created by this node.
//
// Each Scan may have an attached `hint_list`, storing each hint as
// a <a href="#ResolvedOption">ResolvedOption</a>.
//
// If `is_ordered` is true, this Scan produces an ordered output, either
// by generating order itself (OrderByScan) or by preserving the order
// of its single input scan (LimitOffsetScan, ProjectScan, or WithScan).
//
// Each Scan has a `node_source` field that, if populated, represents where
// the scan was from or why it was added. This is used in some cases by the
// resolver, rewriters or the random query generator to record why a node was
// added. The SQLBuilder may also use `node_source` to influence which query
// patterns to generate.</font>
class ResolvedScan : public <a href="#ResolvedNode">ResolvedNode</a> {
  bool IsScan() const final { return true; }

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; column_list() const;
  int column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> column_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; hint_list() const;
  int hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* hint_list(int i) const;

  bool is_ordered() const;

  const std::string&amp; node_source() const;
};
</code></pre></p>

### ResolvedExecuteAsRoleScan
<a id="ResolvedExecuteAsRoleScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This node provides the role context for its subtree. Currently, it only
// handles subtrees from inlined TVFs and VIEWs created with DEFINER rights.
// Due to the lack of a ROLE catalog object, we are using the original
// catalog object (VIEW or TVF) as a proxy. The engine is expected to extract
// the target role of these objects.
//
// In the future, when we have catalog objects for roles, this node should
// be updated to attach role object, rather than the original inlined object.
//
// The node&#39;s role context covers the whole subtree underneath it, except
// subtrees under other nested <a href="#ResolvedExecuteAsRoleScan">ResolvedExecuteAsRoleScan</a> nodes.
//
// Always creates new output columns in &lt;column_list&gt;, which map 1:1 with
// the &lt;input_scan&gt;&#39;s output columns. Most rewriters trace their columns all
// the way back to the scan that defined them so this makes this node a
// boundary, as desired.</font>
class ResolvedExecuteAsRoleScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXECUTE_AS_ROLE_SCAN;

<font color="brown">  // The input scan whose subtree is to be encompassed by the current
  // role context.</font>
  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

<font color="brown">  // The original view that was inlined. If set, then
  // &#39;original_inlined_tvf&#39; is null. The validator checks that this
  // table is indeed a SqlView, not some other subclass of Table.</font>
  const Table* original_inlined_view() const;

<font color="brown">  // The original TVF that was inlined. If set, then
  // &#39;original_inlined_view&#39; is null.</font>
  const TableValuedFunction* original_inlined_tvf() const;
};
</code></pre></p>

### ResolvedModel
<a id="ResolvedModel"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents a machine learning model as a TVF argument.
// &lt;model&gt; is the machine learning model object known to the resolver
// (usually through the catalog).</font>
class ResolvedModel : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MODEL;

  const Model* model() const;
};
</code></pre></p>

### ResolvedConnection
<a id="ResolvedConnection"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents a connection object, which encapsulates engine-specific
// metadata used to connect to an external data source.</font>
class ResolvedConnection : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CONNECTION;

  const Connection* connection() const;
};
</code></pre></p>

### ResolvedDescriptor
<a id="ResolvedDescriptor"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents a descriptor object as a TVF argument.
// A descriptor is basically a list of unresolved column names, written
//   DESCRIPTOR(column1, column2)
//
// &lt;descriptor_column_name_list&gt; contains the column names.
//
// If FunctionArgumentTypeOptions.get_resolve_descriptor_names_table_offset()
// is true, then &lt;descriptor_column_list&gt; contains resolved columns from
// the sibling <a href="#ResolvedFunctionArgument">ResolvedFunctionArgument</a> of scan type, and will match
// positionally with &lt;descriptor_column_name_list&gt;.</font>
class ResolvedDescriptor : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DESCRIPTOR;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; descriptor_column_list() const;
  int descriptor_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> descriptor_column_list(int i) const;

  const std::vector&lt;std::string&gt;&amp; descriptor_column_name_list() const;
  int descriptor_column_name_list_size() const;
  std::string descriptor_column_name_list(int i) const;
};
</code></pre></p>

### ResolvedSingleRowScan
<a id="ResolvedSingleRowScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Scan that produces a single row with no columns.  Used for queries without
// a FROM clause, where all output comes from the select list.</font>
class ResolvedSingleRowScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SINGLE_ROW_SCAN;

};
</code></pre></p>

### ResolvedUnsetArgumentScan
<a id="ResolvedUnsetArgumentScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents an optional TVF relation argument, where the relation is
// omitted. This node can only occur as an argument to a TVFScan. The
// column_list for this node is always empty.</font>
class ResolvedUnsetArgumentScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UNSET_ARGUMENT_SCAN;

};
</code></pre></p>

### ResolvedTableScan
<a id="ResolvedTableScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Scan a Table.
// The &lt;column_list&gt;[i] should be matched to a Table column by
// &lt;table&gt;.GetColumn(&lt;column_index_list&gt;[i]).
//
// If AnalyzerOptions::prune_unused_columns is true, the &lt;column_list&gt; and
// &lt;column_index_list&gt; will include only columns that were referenced
// in the user query. (SELECT * counts as referencing all columns.)
// This column_list can then be used for column-level ACL checking on tables.
// Pruning has no effect on value tables (the value is never pruned).
//
// for_system_time_expr when non NULL resolves to TIMESTAMP used in
// FOR SYSTEM_TIME AS OF clause. The expression is expected to be constant
// and no columns are visible to it.
//
// &lt;column_index_list&gt; This list matches 1-1 with the &lt;column_list&gt;, and
// identifies the ordinal of the corresponding column in the &lt;table&gt;&#39;s
// column list.
//
// If provided, &lt;alias&gt; refers to an explicit alias which was used to
// reference a Table in the user query. If the Table was given an implicitly
// generated alias, then defaults to &#34;&#34;.
//
// TODO: Enforce &lt;column_index_list&gt; in the constructor arg list. For
// historical reasons, some clients match &lt;column_list&gt; to Table columns by
// <a href="#ResolvedColumn">ResolvedColumn</a> name. This violates the <a href="#ResolvedColumn">ResolvedColumn</a> contract, which
// explicitly states that the <a href="#ResolvedColumn">ResolvedColumn</a> name has no semantic meaning.
// All code building a <a href="#ResolvedTableScan">ResolvedTableScan</a> should always
// set_column_index_list() immediately after construction.</font>
class ResolvedTableScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_TABLE_SCAN;

  const Table* table() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* for_system_time_expr() const;

  const std::vector&lt;int&gt;&amp; column_index_list() const;
  int column_index_list_size() const;
  int column_index_list(int i) const;

  const std::string&amp; alias() const;

  const <a href="#ResolvedLockMode">ResolvedLockMode</a>* lock_mode() const;

<font color="brown">  // If true, this table is being read as a ROW-typed value table.
  // `column_index_list` must be unset.
  // `column_list` can contain at most one column.  If present, the
  // column must have ROW&lt;T&gt; type, matching `table`.
  //
  // This is used when FEATURE_ROW_TYPE is enabled and the Table has a
  // non-default GetColumnListMode setting.
  //
  // See (broken link).</font>
  bool read_as_row_type() const;
};
</code></pre></p>

### ResolvedJoinScan
<a id="ResolvedJoinScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// A Scan that joins two input scans.
// The &lt;column_list&gt; will contain columns selected from the union
// of the input scan&#39;s &lt;column_lists&gt;.
// When the join is a LEFT/RIGHT/FULL join, <a href="#ResolvedColumn">ResolvedColumns</a> that came from
// the non-joined side get NULL values.</font>
class ResolvedJoinScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_JOIN_SCAN;

  typedef <a href="#ResolvedJoinScanEnum">ResolvedJoinScanEnums</a>::JoinType JoinType;
  static const JoinType INNER = <a href="#ResolvedJoinScanEnum">ResolvedJoinScanEnums</a>::INNER;
  static const JoinType LEFT = <a href="#ResolvedJoinScanEnum">ResolvedJoinScanEnums</a>::LEFT;
  static const JoinType RIGHT = <a href="#ResolvedJoinScanEnum">ResolvedJoinScanEnums</a>::RIGHT;
  static const JoinType FULL = <a href="#ResolvedJoinScanEnum">ResolvedJoinScanEnums</a>::FULL;

  <a href="#ResolvedJoinScan">ResolvedJoinScan</a>::JoinType join_type() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* left_scan() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* right_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* join_expr() const;

<font color="brown">  // This indicates this join was generated from syntax with USING.
  // The sql_builder will use this field only as a suggestion.
  // JOIN USING(...) syntax will be used if and only if
  // `has_using` is True and `join_expr` has the correct shape.
  // Otherwise the sql_builder will generate JOIN ON.</font>
  bool has_using() const;

<font color="brown">  // Indicates whether this join is lateral. In a lateral join,
  // `rhs_scan` is evaluated for every row in `lhs_scan`, and can see
  // columns from `lhs_scan`.</font>
  bool is_lateral() const;

<font color="brown">  // Used when `is_lateral` is true. The columns in this list are the
  // columns from `left_scan` and any outer columns that are referenced
  // in the derived `right_scan`. This list serves a similar function
  // to <a href="#ResolvedSubqueryExpr">ResolvedSubqueryExpr</a>::parameter_list. When not empty, any
  // references to further outside columns appear as correlated refs
  // on this list first.
  //
  // When `is_lateral` is false, this list must always be empty.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; parameter_list() const;
  int parameter_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* parameter_list(int i) const;
};
</code></pre></p>

### ResolvedArrayScan
<a id="ResolvedArrayScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Scan one or more (N) array values produced by evaluating N expressions,
// merging them positionally. Without FEATURE_MULTIWAY_UNNEST, it must
// be exactly one array (N=1).
//
// `array_expr_list` can have one or more expressions with ARRAY type
// or one expression with a join RowType (with `IsJoin()` true).
// When it&#39;s a RowType, `array_expr_list` can only have one item
// and `array_offset_column` is not allowed.
//
// If `input_scan` is NULL, this produces one row for each array offset.
// This can occur when using syntax:
//   UNNEST(expression [, expression [, ...]])
//
// If `input_scan` is non-NULL, for each row in the stream produced by
// `input_scan`, this evaluates the expressions in `array_expr_list` (each of
// which must return an array type), and then produces a stream with one row
// for each array offset.
//
// If `join_expr` is non-NULL, then this condition is evaluated as an ON
// clause for the array join. The named columns produced by any array in
// `array_expr_list` may be used inside `join_expr`.
//
// If the array is empty (after evaluating `join_expr`), then
// 1. If `is_outer` is false, the scan produces zero rows.
// 2. If `is_outer` is true, the scan produces one row with N NULL values.
//
// `element_column_list` are the new columns produced by this scan that store
// the array element values for each row. `element_column_list` and
// `array_expr_list` must have the same size N.
//
// If present, `array_offset_column` defines the column produced by this
// scan that stores the array offset (0-based) for the corresponding
// `element_column_list`.
//
// This node&#39;s `column_list` can have columns from `input_scan`,
// `element_column_list` and `array_offset_column`.
//
// `array_zip_mode` specifies the zipping behavior when there are multiple
// arrays in `array_expr_list` and they have different sizes. It must be NULL
// when there is only one given array.
//
// The getters and setters for legacy fields `array_expr` and
// `element_column` are added for backward compatibility purposes. If the
// corresponding vector field has more than 1 element and only legacy
// accessors are called, the field is not considered as accessed.</font>
class ResolvedArrayScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ARRAY_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; array_expr_list() const;
  int array_expr_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* array_expr_list(int i) const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; element_column_list() const;
  int element_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> element_column_list(int i) const;

  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* array_offset_column() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* join_expr() const;

  bool is_outer() const;

<font color="brown">  // Stores a builtin ENUM ARRAY_ZIP_MODE with three possible values:
  // PAD, TRUNCATE or STRICT.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* array_zip_mode() const;
};
</code></pre></p>

### ResolvedColumnHolder
<a id="ResolvedColumnHolder"></a>

<p><pre><code class="lang-c++"><font color="brown">// This wrapper is used for an optional <a href="#ResolvedColumn">ResolvedColumn</a> inside another node.
//
// Note: <a href="#ResolvedColumn">ResolvedColumn</a> does not track `column_is_created` itself.
// The `column_is_created` attribute is applied on fields of this type.</font>
class ResolvedColumnHolder : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_COLUMN_HOLDER;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const;
};
</code></pre></p>

### ResolvedFilterScan
<a id="ResolvedFilterScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Scan rows from input_scan, and emit all rows where filter_expr
// evaluates to true.  filter_expr is always of type bool.
// This node&#39;s column_list will be a subset of input_scan&#39;s column_list.</font>
class ResolvedFilterScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FILTER_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* filter_expr() const;
};
</code></pre></p>

### ResolvedGroupingCall
<a id="ResolvedGroupingCall"></a>

<p><pre><code class="lang-c++"><font color="brown">// A GROUPING function call. `group_by_column` must be a column from
// the `group_by_list` in `<a href="#ResolvedAggregateScan">ResolvedAggregateScan</a>`.
// `output_column` is a new column of type int64.
// Its output value is 0 if `group_by_column` is included in the current
// grouping set, or 1 if not.</font>
class ResolvedGroupingCall : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GROUPING_CALL;

  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* group_by_column() const;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; output_column() const;
};
</code></pre></p>

### ResolvedGroupingSetBase
<a id="ResolvedGroupingSetBase"></a>

<p><pre><code class="lang-c++"><font color="brown">// The parent node for grouping set, rollup and cube nodes.
//
// This node exists for organizational purposes only, to cluster
// grouping set, rollup and cube nodes. It doesn&#39;t have any actual fields.</font>
class ResolvedGroupingSetBase : public <a href="#ResolvedArgument">ResolvedArgument</a> {
};
</code></pre></p>

### ResolvedGroupingSetList
<a id="ResolvedGroupingSetList"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents the list of grouping sets corresponding to a GROUPING SETS.
// For example, `GROUPING SETS(a, CUBE(b, c), ROLLUP(d, e, f))` can be
// represented as:
//
// GroupingSetList
// +-elem_list=
//   +-GroupingSet
//   | +-group_by_column_list= ...
//   |   +-ColumnRef(...)
//   +-Cube
//   | +-cube_column_list=
//   |   +-GroupingSetMultiColumn ...
//   |   +-GroupingSetMultiColumn ...
//   +-Rollup
//     +-rollup_column_list=
//       +-GroupingSetMultiColumn ...
//       +-GroupingSetMultiColumn ...
//       +-GroupingSetMultiColumn ...
//
// Although elem_list contains elements of type <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a>,
// only <a href="#ResolvedGroupingSet">ResolvedGroupingSet</a>, <a href="#ResolvedRollup">ResolvedRollup</a>, and
// <a href="#ResolvedCube">ResolvedCube</a> are valid derivative types.
//
// Currently, the only use case is to represents the input set for grouping
// sets cartesian product (see <a href="#ResolvedGroupingSetProduct">ResolvedGroupingSetProduct</a>). In the future, this
// node can potentially be used for other use cases, e.g. nested grouping sets.</font>
class ResolvedGroupingSetList : public <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GROUPING_SET_LIST;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a>&gt;&gt;&amp; elem_list() const;
  int elem_list_size() const;
  const <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a>* elem_list(int i) const;
};
</code></pre></p>

### ResolvedGroupingSetProduct
<a id="ResolvedGroupingSetProduct"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents the cartesian product of the grouping sets stored in
// `input_list`. Each element in `input_list` should either be a
// <a href="#ResolvedGroupingSetList">ResolvedGroupingSetList</a>, <a href="#ResolvedGroupingSet">ResolvedGroupingSet</a>, <a href="#ResolvedRollup">ResolvedRollup</a> or
// <a href="#ResolvedCube">ResolvedCube</a>.
//
// For example, the expression
// `GROUP BY GROUPING SETS(a, ROLLUP(d)), ROLLUP(e, f)`
// can be represented as:
//
// GroupingSetProduct
// +-input_list=
//   +-GroupingSetList  # Represents GROUPING SETS(a, ROLLUP(d))
//   | +-elem_list=
//   |   +-GroupingSet
//   |   | +-group_by_column_list= ...
//   |   |   +-ColumnRef(...)
//   |   +-Rollup
//   |     +-rollup_column_list=
//   |       +-GroupingSetMultiColumn ...
//   +-Rollup . # Represents ROLLUP(e, f)
//     +-rollup_column_list=
//       +-GroupingSetMultiColumn ...
//       +-GroupingSetMultiColumn ...
//
// The GroupingSetList is then expanded to:
// [(a), (b, c), (b), (c), (), (d), ()]
// The Rollup is expanded to:
// [(e, f), (e), (f), ()].
// Then, a cartesian product will be performed on the two grouping sets,
// resulting in:
// [(a, e, f), (a, e), (a, f), (a),
//  (b, c, e, f), (b, c, e), (b, c, f), (b, c)
//  ...]
//
// At least two elements are required in the input_list.
// <a href="#ResolvedGroupingSetProduct">ResolvedGroupingSetProduct</a> cannot be used when there
// is only one non-composite <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a>.</font>
class ResolvedGroupingSetProduct : public <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GROUPING_SET_PRODUCT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a>&gt;&gt;&amp; input_list() const;
  int input_list_size() const;
  const <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a>* input_list(int i) const;
};
</code></pre></p>

### ResolvedGroupingSet
<a id="ResolvedGroupingSet"></a>

<p><pre><code class="lang-c++"><font color="brown">// List of group by columns that form a grouping set.
//
// Columns must come from group_by_list in <a href="#ResolvedAggregateScan">ResolvedAggregateScan</a>.
// group_by_column_list will not contain any duplicates. There may be more
// than one <a href="#ResolvedGroupingSet">ResolvedGroupingSet</a> in the <a href="#ResolvedAggregateScan">ResolvedAggregateScan</a> with the same
// columns, however.</font>
class ResolvedGroupingSet : public <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GROUPING_SET;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; group_by_column_list() const;
  int group_by_column_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* group_by_column_list(int i) const;
};
</code></pre></p>

### ResolvedRollup
<a id="ResolvedRollup"></a>

<p><pre><code class="lang-c++"><font color="brown">// List of <a href="#ResolvedGroupingSetMultiColumn">ResolvedGroupingSetMultiColumn</a> that forms a rollup.
//
// Each <a href="#ResolvedGroupingSetMultiColumn">ResolvedGroupingSetMultiColumn</a> is a list of column references that
// will be batched together when expanding to grouping sets. E.g.
// ROLLUP((a, b), c) is expanded to grouping sets [(a, b, c), (a, b), ()].
// Both (a, b) and c are store in <a href="#ResolvedGroupingSetMultiColumn">ResolvedGroupingSetMultiColumn</a> for
// convenience.
//
// Column references in each <a href="#ResolvedGroupingSetMultiColumn">ResolvedGroupingSetMultiColumn</a> must come from
// group_by_list in <a href="#ResolvedAggregateScan">ResolvedAggregateScan</a>. It is allowed to have
// duplicated <a href="#ResolvedGroupingSetMultiColumn">ResolvedGroupingSetMultiColumn</a> in rollup_column_list.</font>
class ResolvedRollup : public <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ROLLUP;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGroupingSetMultiColumn">ResolvedGroupingSetMultiColumn</a>&gt;&gt;&amp; rollup_column_list() const;
  int rollup_column_list_size() const;
  const <a href="#ResolvedGroupingSetMultiColumn">ResolvedGroupingSetMultiColumn</a>* rollup_column_list(int i) const;
};
</code></pre></p>

### ResolvedCube
<a id="ResolvedCube"></a>

<p><pre><code class="lang-c++"><font color="brown">// List of <a href="#ResolvedGroupingSetMultiColumn">ResolvedGroupingSetMultiColumn</a> that forms a cube in grouping sets.
//
// See comments in ResolvdRollup for explanation about
// <a href="#ResolvedGroupingSetMultiColumn">ResolvedGroupingSetMultiColumn</a>.</font>
class ResolvedCube : public <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CUBE;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGroupingSetMultiColumn">ResolvedGroupingSetMultiColumn</a>&gt;&gt;&amp; cube_column_list() const;
  int cube_column_list_size() const;
  const <a href="#ResolvedGroupingSetMultiColumn">ResolvedGroupingSetMultiColumn</a>* cube_column_list(int i) const;
};
</code></pre></p>

### ResolvedAggregateScanBase
<a id="ResolvedAggregateScanBase"></a>

<p><pre><code class="lang-c++"><font color="brown">// Base class for aggregation scans. Apply aggregation to rows produced from
// input_scan, and output aggregated rows.
//
// Group by keys in &lt;group_by_list&gt;.  If &lt;group_by_list&gt; is empty,
// aggregate all input rows into one output row.
//
// &lt;collation_list&gt; is either empty to indicate that all the elements in
// &lt;group_by_list&gt; have the default collation, or &lt;collation_list&gt; has the
// same number of elements as &lt;group_by_list&gt;.  Each element is the collation
// for the element in &lt;group_by_list&gt; with the same index, or can be empty to
// indicate default collation or when the type is not collatable.
// &lt;collation_list&gt; is only set when FEATURE_COLLATION_SUPPORT is
// enabled.
// See (broken link).
//
// Compute all aggregations in &lt;aggregate_list&gt;.  All expressions in
// &lt;aggregate_list&gt; have a <a href="#ResolvedAggregateFunctionCall">ResolvedAggregateFunctionCall</a> with mode
// Function::AGGREGATE as their outermost node.
//
// The output &lt;column_list&gt; contains only columns produced from
// &lt;group_by_list&gt; and &lt;aggregate_list&gt;.  No other columns are visible after
// aggregation.
//
// If &lt;grouping_set_list&gt; is empty, output rows grouped by the full
// &lt;group_by_list&gt;.
//
// If &lt;grouping_set_list&gt; is non-empty, then
// for each item in &lt;grouping_set_list&gt;, output rows computing the
// same &lt;aggregate_list&gt; over the input rows using a particular grouping set.
// Each item in &lt;grouping_set_list&gt; is either a <a href="#ResolvedGroupingSet">ResolvedGroupingSet</a>,
// <a href="#ResolvedRollup">ResolvedRollup</a>, or <a href="#ResolvedCube">ResolvedCube</a> before the grouping set rewriter expands
// the grouping set list. After rewriting, it will only contain
// <a href="#ResolvedGroupingSet">ResolvedGroupingSet</a> that are expanded from grouping set, rollup and cube.
//
// The aggregation input values, including &lt;input_scan&gt;, computed columns in
// &lt;group_by_list&gt;, and aggregate function arguments in &lt;aggregate_list&gt;,
// should be computed just once and then reused as aggregation input for each
// grouping set. (This ensures that ROLLUP rows have correct totals, even
// with non-stable functions in the input.) For each grouping set, the
// &lt;group_by_list&gt; elements not included in the &lt;group_by_column_list&gt; are
// replaced with NULL.
//
// &lt;rollup_column_list&gt; is the original list of columns from
// GROUP BY ROLLUP(...), if there was a ROLLUP clause, and is used only for
// rebuilding equivalent SQL for the resolved AST. Engines should refer to
// &lt;grouping_set_list&gt; rather than &lt;rollup_column_list&gt;.
//
// &lt;grouping_call_list&gt; is the list of resolved group-by columns referenced
// in GROUPING aggregate function calls. Each item in the grouping_call_list
// is associated with a unique GROUPING function call in the SELECT list.</font>
class ResolvedAggregateScanBase : public <a href="#ResolvedScan">ResolvedScan</a> {
  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; group_by_list() const;
  int group_by_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* group_by_list(int i) const;

  const std::vector&lt;<a href="#ResolvedCollation">ResolvedCollation</a>&gt;&amp; collation_list() const;
  int collation_list_size() const;
  <a href="#ResolvedCollation">ResolvedCollation</a> collation_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumnBase">ResolvedComputedColumnBase</a>&gt;&gt;&amp; aggregate_list() const;
  int aggregate_list_size() const;
  const <a href="#ResolvedComputedColumnBase">ResolvedComputedColumnBase</a>* aggregate_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a>&gt;&gt;&amp; grouping_set_list() const;
  int grouping_set_list_size() const;
  const <a href="#ResolvedGroupingSetBase">ResolvedGroupingSetBase</a>* grouping_set_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; rollup_column_list() const;
  int rollup_column_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* rollup_column_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGroupingCall">ResolvedGroupingCall</a>&gt;&gt;&amp; grouping_call_list() const;
  int grouping_call_list_size() const;
  const <a href="#ResolvedGroupingCall">ResolvedGroupingCall</a>* grouping_call_list(int i) const;
};
</code></pre></p>

### ResolvedAggregateScan
<a id="ResolvedAggregateScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Apply aggregation to rows produced from input_scan, and output aggregated
// rows.</font>
class ResolvedAggregateScan : public <a href="#ResolvedAggregateScanBase">ResolvedAggregateScanBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_AGGREGATE_SCAN;

};
</code></pre></p>

### ResolvedAnonymizedAggregateScan
<a id="ResolvedAnonymizedAggregateScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Apply differentially private aggregation (anonymization) to rows produced
// from input_scan, and output anonymized rows.
// Spec: (broken link)
//
// &lt;k_threshold_expr&gt; when non-null, is a function call that uses one or more
// items from the &lt;aggregate_list&gt; as arguments.
// The engine then adds a filter that acts like:
//   HAVING &lt;k_threshold_expr&gt; &gt;= &lt;implementation-defined k-threshold&gt;
// omitting any rows that would not pass this condition.
// TODO: Update this comment after splitting the rewriter out
// into a separate stage.
//
// &lt;anonymization_option_list&gt; provides user-specified options, and
// requires that option names are one of: delta, epsilon, kappa,
// max_groups_contributed, max_rows_contributed, or k_threshold.</font>
class ResolvedAnonymizedAggregateScan : public <a href="#ResolvedAggregateScanBase">ResolvedAggregateScanBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ANONYMIZED_AGGREGATE_SCAN;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* k_threshold_expr() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; anonymization_option_list() const;
  int anonymization_option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* anonymization_option_list(int i) const;
};
</code></pre></p>

### ResolvedDifferentialPrivacyAggregateScan
<a id="ResolvedDifferentialPrivacyAggregateScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Apply differentially private aggregation (anonymization) to rows produced
// from input_scan, and output anonymized rows.
// Spec: (broken link)
//
//
// &lt;group_selection_threshold_expr&gt; when non-null, is a function call that
// uses one or more items from the &lt;aggregate_list&gt; as arguments.
// The engine then adds a filter that acts like:
//   HAVING &lt;group_selection_threshold_expr&gt; &gt;=
//   &lt;implementation-defined group_selection_threshold&gt;
// omitting any rows that would not pass this condition.
// TODO: Update this comment after splitting the rewriter out
// into a separate stage.
//
// &lt;option_list&gt; provides user-specified options, and
// requires that option names are one of: delta, epsilon,
// max_groups_contributed or max_rows_contributed.</font>
class ResolvedDifferentialPrivacyAggregateScan : public <a href="#ResolvedAggregateScanBase">ResolvedAggregateScanBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DIFFERENTIAL_PRIVACY_AGGREGATE_SCAN;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* group_selection_threshold_expr() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedAggregationThresholdAggregateScan
<a id="ResolvedAggregationThresholdAggregateScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Apply aggregation to rows produced from input_scan and output rows to
// that pass aggregation thresholds. It adds:
// HAVING COUNT(DISTINCT `privacy_unit_column`) &gt;= `threshold`.
// Spec: (broken link)
//
// &lt;option_list&gt; provides user-specified options. Allowed options are defined
// in GetAllowedAggregationThresholdOptions function.</font>
class ResolvedAggregationThresholdAggregateScan : public <a href="#ResolvedAggregateScanBase">ResolvedAggregateScanBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_AGGREGATION_THRESHOLD_AGGREGATE_SCAN;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedSetOperationItem
<a id="ResolvedSetOperationItem"></a>

<p><pre><code class="lang-c++"><font color="brown">// This is one input item in a <a href="#ResolvedSetOperation">ResolvedSetOperation</a>.
// The &lt;output_column_list&gt; matches 1:1 with the <a href="#ResolvedSetOperation">ResolvedSetOperation</a>&#39;s
// &lt;column_list&gt; and specifies how columns from &lt;scan&gt; map to output columns.
// Each column from &lt;scan&gt; can map to zero or more output columns.</font>
class ResolvedSetOperationItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SET_OPERATION_ITEM;

  const <a href="#ResolvedScan">ResolvedScan</a>* scan() const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> output_column_list(int i) const;
};
</code></pre></p>

### ResolvedSetOperationScan
<a id="ResolvedSetOperationScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Apply a set operation (specified by &lt;op_type&gt;) on two or more input scans.
//
// &lt;input_item_list&gt; will have at least two elements.
//
// &lt;column_list&gt; is a set of new <a href="#ResolvedColumn">ResolvedColumns</a> created by this scan.
// Each input <a href="#ResolvedSetOperationItem">ResolvedSetOperationItem</a> has an &lt;output_column_list&gt; which
// matches 1:1 with &lt;column_list&gt; and specifies how the input item&#39;s
// columns map into the final &lt;column_list&gt;.
//
// - Results of {UNION, INTERSECT, EXCEPT} ALL can include duplicate rows.
//   More precisely, with two input scans, if a given row R appears exactly
//   m times in first input and n times in second input (m &gt;= 0, n &gt;= 0):
//   For UNION ALL, R will appear exactly m + n times in the result.
//   For INTERSECT ALL, R will appear exactly min(m, n) in the result.
//   For EXCEPT ALL, R will appear exactly max(m - n, 0) in the result.
//
// - Results of {UNION, INTERSECT, EXCEPT} DISTINCT cannot contain any
//   duplicate rows. For UNION and INTERSECT, the DISTINCT is computed
//   after the result above is computed.  For EXCEPT DISTINCT, row R will
//   appear once in the output if m &gt; 0 and n = 0.
//
// - For n (&gt;2) input scans, the above operations generalize so the output is
//   the same as if the inputs were combined incrementally from left to
//   right.
//
// &lt;column_match_mode&gt; represents how columns from different queries were
// matched, for example BY_POSITION or CORRESPONDING (by name). Engines can
// ignore this field; it is included for informational purposes.
//
// &lt;column_propagation_mode&gt; represents how non-matching columns were
// treated, for example INNER (non-matching columns are dropped) or STRICT
// (non-matching columns are not allowed). Engines can ignore this field;
// it is included for informational purposes.</font>
class ResolvedSetOperationScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SET_OPERATION_SCAN;

  typedef <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::SetOperationType SetOperationType;
  typedef <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::SetOperationColumnMatchMode SetOperationColumnMatchMode;
  typedef <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::SetOperationColumnPropagationMode SetOperationColumnPropagationMode;
  static const SetOperationType UNION_ALL = <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::UNION_ALL;
  static const SetOperationType UNION_DISTINCT = <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::UNION_DISTINCT;
  static const SetOperationType INTERSECT_ALL = <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::INTERSECT_ALL;
  static const SetOperationType INTERSECT_DISTINCT = <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::INTERSECT_DISTINCT;
  static const SetOperationType EXCEPT_ALL = <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::EXCEPT_ALL;
  static const SetOperationType EXCEPT_DISTINCT = <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::EXCEPT_DISTINCT;
  static const SetOperationColumnMatchMode BY_POSITION = <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::BY_POSITION;
  static const SetOperationColumnMatchMode CORRESPONDING = <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::CORRESPONDING;
  static const SetOperationColumnMatchMode CORRESPONDING_BY = <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::CORRESPONDING_BY;
  static const SetOperationColumnPropagationMode STRICT = <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::STRICT;
  static const SetOperationColumnPropagationMode INNER = <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::INNER;
  static const SetOperationColumnPropagationMode LEFT = <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::LEFT;
  static const SetOperationColumnPropagationMode FULL = <a href="#ResolvedSetOperationScanEnum">ResolvedSetOperationScanEnums</a>::FULL;

  <a href="#ResolvedSetOperationScan">ResolvedSetOperationScan</a>::SetOperationType op_type() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedSetOperationItem">ResolvedSetOperationItem</a>&gt;&gt;&amp; input_item_list() const;
  int input_item_list_size() const;
  const <a href="#ResolvedSetOperationItem">ResolvedSetOperationItem</a>* input_item_list(int i) const;

  <a href="#ResolvedSetOperationScan">ResolvedSetOperationScan</a>::SetOperationColumnMatchMode column_match_mode() const;

  <a href="#ResolvedSetOperationScan">ResolvedSetOperationScan</a>::SetOperationColumnPropagationMode column_propagation_mode() const;
};
</code></pre></p>

### ResolvedOrderByScan
<a id="ResolvedOrderByScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Apply ordering to rows produced from input_scan, and output ordered
// rows.
//
// The &lt;order_by_item_list&gt; must not be empty.  Each element identifies
// a sort column and indicates direction (ascending or descending).
//
// Order Preservation:
//   A <a href="#ResolvedScan">ResolvedScan</a> produces an ordered output if it has &lt;is_ordered&gt;=true.
//   If &lt;is_ordered&gt;=false, the scan may discard order.  This can happen
//   even for a <a href="#ResolvedOrderByScan">ResolvedOrderByScan</a>, if it is the top-level scan in a
//   subquery (which discards order).
//
// The following Scan nodes may have &lt;is_ordered&gt;=true, producing or
// propagating an ordering:
//   * <a href="#ResolvedOrderByScan">ResolvedOrderByScan</a>
//   * <a href="#ResolvedLimitOffsetScan">ResolvedLimitOffsetScan</a>
//   * <a href="#ResolvedProjectScan">ResolvedProjectScan</a>
//   * <a href="#ResolvedWithScan">ResolvedWithScan</a>
// Other Scan nodes will always discard ordering.</font>
class ResolvedOrderByScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ORDER_BY_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>&gt;&gt;&amp; order_by_item_list() const;
  int order_by_item_list_size() const;
  const <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>* order_by_item_list(int i) const;
};
</code></pre></p>

### ResolvedLimitOffsetScan
<a id="ResolvedLimitOffsetScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Apply an optional LIMIT and optional OFFSET to the rows from
// input_scan. Emit all rows after OFFSET rows have been scanned and up to
// LIMIT total rows emitted. The offset is the number of rows to skip. E.g.,
// OFFSET 1 means to skip one row, so the first row emitted will be the
// second ROW, provided the LIMIT is greater than zero.
//
// The arguments to LIMIT &lt;int64&gt; OFFSET &lt;int64&gt; must be constant expressions
// which return a type that coerces to INT64.
//
// OFFSET is optional and the absence of OFFSET implies OFFSET 0.
// When FEATURE_LIMIT_ALL is enabled, LIMIT is optional and the absence
// of LIMIT implies LIMIT ALL. Otherwise, LIMIT is required and should be
// non-null.</font>
class ResolvedLimitOffsetScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_LIMIT_OFFSET_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* limit() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* offset() const;
};
</code></pre></p>

### ResolvedWithRefScan
<a id="ResolvedWithRefScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Scan the subquery defined in a WITH statement.
// See <a href="#ResolvedWithScan">ResolvedWithScan</a> for more detail.
// The column_list produced here will match 1:1 with the column_list produced
// by the referenced subquery and will given a new unique id to each column
// produced for this scan.</font>
class ResolvedWithRefScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WITH_REF_SCAN;

  const std::string&amp; with_query_name() const;
};
</code></pre></p>

### ResolvedAnalyticScan
<a id="ResolvedAnalyticScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Apply analytic functions to rows produced from input_scan.
//
// The set of analytic functions are partitioned into a list of analytic
// function groups &lt;function_group_list&gt; by the window PARTITION BY and the
// window ORDER BY.
//
// The output &lt;column_list&gt; contains all columns from &lt;input_scan&gt;,
// one column per analytic function. It may also contain partitioning/ordering
// expression columns if they reference to select columns.
//
// Currently, the analyzer combines equivalent OVER clauses into the same
// <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a> only for OVER () or a named window.</font>
class ResolvedAnalyticScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ANALYTIC_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>&gt;&gt;&amp; function_group_list() const;
  int function_group_list_size() const;
  const <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>* function_group_list(int i) const;
};
</code></pre></p>

### ResolvedSampleScan
<a id="ResolvedSampleScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Samples rows from &lt;input_scan&gt;.
// Specs: (broken link)
// Specs for WITH WEIGHT and PARTITION BY: (broken link)
//
// &lt;method&gt; is the identifier for the sampling algorithm and will always be
// in lowercase.
// For example BERNOULLI, RESERVOIR, SYSTEM. Engines can also support their
// own implementation-specific set of sampling algorithms.
//
// &lt;size&gt; and &lt;unit&gt; specifies the sample size.
// If &lt;unit&gt; is &#34;ROWS&#34;, &lt;size&gt; must be an &lt;int64&gt; and non-negative.
// If &lt;unit&gt; is &#34;PERCENT&#34;, &lt;size&gt; must either be a &lt;double&gt; or an &lt;int64&gt; and
// in the range [0, 100].
// &lt;size&gt; can only be a literal value or a (possibly casted) parameter.
//
// &lt;repeatable_argument&gt; is present if we had a REPEATABLE(&lt;argument&gt;) in the
// TABLESAMPLE clause and can only be a literal value or a (possibly
// casted) parameter.
//
// If present, &lt;weight_column&gt; defines the column produced by this scan that
// stores the scaling weight for the corresponding sampled row.
//
// &lt;partition_by_list&gt; can be empty. If &lt;partition_by_list&gt; is not empty,
// &lt;unit&gt; must be ROWS and &lt;method&gt; must be RESERVOIR.</font>
class ResolvedSampleScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SAMPLE_SCAN;

  typedef <a href="#ResolvedSampleScanEnum">ResolvedSampleScanEnums</a>::SampleUnit SampleUnit;
  static const SampleUnit ROWS = <a href="#ResolvedSampleScanEnum">ResolvedSampleScanEnums</a>::ROWS;
  static const SampleUnit PERCENT = <a href="#ResolvedSampleScanEnum">ResolvedSampleScanEnums</a>::PERCENT;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::string&amp; method() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* size() const;

  <a href="#ResolvedSampleScan">ResolvedSampleScan</a>::SampleUnit unit() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* repeatable_argument() const;

  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* weight_column() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; partition_by_list() const;
  int partition_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* partition_by_list(int i) const;
};
</code></pre></p>

### ResolvedComputedColumnBase
<a id="ResolvedComputedColumnBase"></a>

<p><pre><code class="lang-c++"><font color="brown">// This is used when an expression is computed and given a name (a new
// <a href="#ResolvedColumn">ResolvedColumn</a>) that can be referenced elsewhere.  The new <a href="#ResolvedColumn">ResolvedColumn</a>
// can appear in a column_list or in <a href="#ResolvedColumnRef">ResolvedColumnRefs</a> in other expressions,
// when appropriate.  This node is not an expression itself - it is a
// container that holds an expression.
//
// There are 2 concrete subclasses: <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a> and
// <a href="#ResolvedDeferredComputedColumn">ResolvedDeferredComputedColumn</a>.
//
// <a href="#ResolvedDeferredComputedColumn">ResolvedDeferredComputedColumn</a> has extra information about deferring
// side effects like errors.  This can be used in cases like AggregateScans
// before conditional expressions like IF(), where errors from the aggregate
// function should only be exposed if the right IF branch is chosen.
//
// Nodes where deferred side effects are not possible (like GROUP BY
// expressions) are declared as <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a> directly.
//
// Nodes that might need to defer errors, such as AggregateScan&#39;s
// aggregate_list(), are declared as <a href="#ResolvedComputedColumnBase">ResolvedComputedColumnBase</a>.
// The runtime type will be either <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a> or
// <a href="#ResolvedDeferredComputedColumn">ResolvedDeferredComputedColumn</a>, depending on whether any side effects need
// to be captured.
//
// If FEATURE_ENFORCE_CONDITIONAL_EVALUATION is not set, the runtime
// type is always just <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>.
//
// See (broken link) for more details.</font>
class ResolvedComputedColumnBase : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  // Virtual getter to avoid changing <a href="#ResolvedComputedColumnProto">ResolvedComputedColumnProto</a>
  virtual const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const = 0;

  // Virtual getter to avoid changing <a href="#ResolvedComputedColumnProto">ResolvedComputedColumnProto</a>
  virtual const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const = 0;

};
</code></pre></p>

### ResolvedComputedColumnImpl
<a id="ResolvedComputedColumnImpl"></a>

<p><pre><code class="lang-c++"><font color="brown">// An intermediate abstract superclass that holds common getters for
// <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a> and <a href="#ResolvedDeferredComputedColumn">ResolvedDeferredComputedColumn</a>. This class
// exists to ensure that callers static_cast to the appropriate subclass,
// rather than processing <a href="#ResolvedComputedColumnBase">ResolvedComputedColumnBase</a> directly.</font>
class ResolvedComputedColumnImpl : public <a href="#ResolvedComputedColumnBase">ResolvedComputedColumnBase</a> {
};
</code></pre></p>

### ResolvedComputedColumn
<a id="ResolvedComputedColumn"></a>

<p><pre><code class="lang-c++"><font color="brown">// This is the usual <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a> without deferred side effects.
// See comments on <a href="#ResolvedComputedColumnBase">ResolvedComputedColumnBase</a>.</font>
class ResolvedComputedColumn : public <a href="#ResolvedComputedColumnImpl">ResolvedComputedColumnImpl</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_COMPUTED_COLUMN;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;
};
</code></pre></p>

### ResolvedDeferredComputedColumn
<a id="ResolvedDeferredComputedColumn"></a>

<p><pre><code class="lang-c++"><font color="brown">// This is a <a href="#ResolvedColumnColumn">ResolvedColumnColumn</a> variant that adds deferred side effect
// capture.
//
// This is used for computations that get separated into multiple scans,
// where side effects like errors in earlier scans need to be deferred
// util conditional expressions in later scans are evalauted.
// See (broken link) for details.
// For example:
//   SELECT IF(C, SUM(A/B), -1) FROM T
// The division A/B could produce an error when B is 0, but errors should not
// be exposed when C is false, due to IF&#39;s conditional evaluation semantics.
//
// `side_effect_column` is a new column (of type BYTES) created at the same
// time as `column`, storing side effects like errors from the computation.
// This column will store an implementation-specific representation of the
// side effect (e.g. util::StatusProto) and will get a NULL value if there
// are no captured side effects.
//
// Typically, this column will be passed to a call to the internal function
// $with_side_effect() later to expose the side effects. The validator checks
// that it is consumed downstream.</font>
class ResolvedDeferredComputedColumn : public <a href="#ResolvedComputedColumnImpl">ResolvedComputedColumnImpl</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DEFERRED_COMPUTED_COLUMN;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // Creates the companion side effects columns for this
  // computation, of type BYTES. Instead of immediately exposing the
  // side effect (e.g. an error), the side effect is captured in the
  // side_effects_column.</font>
  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; side_effect_column() const;
};
</code></pre></p>

### ResolvedOrderByItem
<a id="ResolvedOrderByItem"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents one column of an ORDER BY clause, with the requested
// ordering direction.
//
// &lt;collation_name&gt; is the ORDER BY COLLATE expression, and could be a string
// literal or query parameter.  &lt;collation_name&gt; can only be set when the
// FEATURE_ORDER_BY_COLLATE is enabled.
// See (broken link) for COLLATE clause.
// &lt;collation&gt; (only set when FEATURE_COLLATION_SUPPORT is enabled) is
// the derived collation to use.  It comes from the &lt;column_ref&gt; and COLLATE
// clause.  It is unset if COLLATE is present and set to a parameter.
// See (broken link) for general Collation Support.
// When both features are enabled, if &lt;collation_name&gt; is present and is
// - a parameter, then &lt;collation&gt; is empty
// - a non-parameter, then &lt;collation&gt; is set to the same collation
// An engine which supports both features could read the fields as:
//   If &lt;collation&gt; is set then use it, otherwise use &lt;collation_name&gt;, which
//   must be a query parameter if set.
//
// &lt;null_order&gt; indicates the ordering of NULL values relative to non-NULL
// values. NULLS_FIRST indicates that NULLS sort prior to non-NULL values,
// and NULLS_LAST indicates that NULLS sort after non-NULL values.</font>
class ResolvedOrderByItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ORDER_BY_ITEM;

  typedef <a href="#ResolvedOrderByItemEnum">ResolvedOrderByItemEnums</a>::NullOrderMode NullOrderMode;
  static const NullOrderMode ORDER_UNSPECIFIED = <a href="#ResolvedOrderByItemEnum">ResolvedOrderByItemEnums</a>::ORDER_UNSPECIFIED;
  static const NullOrderMode NULLS_FIRST = <a href="#ResolvedOrderByItemEnum">ResolvedOrderByItemEnums</a>::NULLS_FIRST;
  static const NullOrderMode NULLS_LAST = <a href="#ResolvedOrderByItemEnum">ResolvedOrderByItemEnums</a>::NULLS_LAST;

  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* column_ref() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* collation_name() const;

  bool is_descending() const;

  <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>::NullOrderMode null_order() const;

  const <a href="#ResolvedCollation">ResolvedCollation</a>&amp; collation() const;
};
</code></pre></p>

### ResolvedColumnAnnotations
<a id="ResolvedColumnAnnotation"></a>

<p><pre><code class="lang-c++"><font color="brown">// This is used in CREATE TABLE statements to provide column annotations
// such as collation, NOT NULL, type parameters, and OPTIONS().
//
// This class is recursive. It mirrors the structure of the column type
// except that child_list might be truncated.
//
// For ARRAY:
//   If the element or its subfield has annotations, then child_list.size()
//   is 1, and child_list(0) stores the element annotations.
//   Otherwise child_list is empty.
// For STRUCT:
//   If the i-th field has annotations then child_list(i) stores the
//   field annotations.
//   Otherwise either child_list.size() &lt;= i or child_list(i) is trivial.
//   If none of the fields and none of their subfields has annotations, then
//   child_list is empty.
// For other types, child_list is empty.</font>
class ResolvedColumnAnnotations : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_COLUMN_ANNOTATIONS;

  // Get the full TypeParameters object for these annotations given a
  // type, including parameters on nested fields.
  absl::StatusOr&lt;TypeParameters&gt; GetFullTypeParameters(
      const Type* type) const;

<font color="brown">  // &lt;collation_name&gt; can only be a string literal, and is only set
  // when FEATURE_COLLATION_SUPPORT is enabled. See
  // (broken link).</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* collation_name() const;

  bool not_null() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnAnnotation">ResolvedColumnAnnotations</a>&gt;&gt;&amp; child_list() const;
  int child_list_size() const;
  const <a href="#ResolvedColumnAnnotation">ResolvedColumnAnnotations</a>* child_list(int i) const;

<font color="brown">  // child_list in &lt;type_parameters&gt; is not used in here.
  // Instead we use child_list of this node (<a href="#ResolvedColumnAnnotation">ResolvedColumnAnnotations</a>)
  // to store type parameters of subfields of STRUCT or ARRAY. Users
  // can access the full type parameters with child_list by calling
  // <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>.getFullTypeParameters() function.</font>
  const TypeParameters&amp; type_parameters() const;
};
</code></pre></p>

### ResolvedGeneratedColumnInfo
<a id="ResolvedGeneratedColumnInfo"></a>

<p><pre><code class="lang-c++"><font color="brown">// &lt;expression&gt; indicates the expression that defines the column. The type of
// the expression will always match the type of the column.
//   - The &lt;expression&gt; can contain <a href="#ResolvedColumnRef">ResolvedColumnRefs</a> corresponding to
//   <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>.&lt;column&gt; for any of the
//   <a href="#ResolvedColumnDefinition">ResolvedColumnDefinitions</a> in the enclosing statement.
//   - The expression can never include a subquery.
//
// &lt;stored_mode&gt; is the mode of a generated column: Values are:
//   - &#39;NON_STORED&#39;: The &lt;expression&gt; must always be evaluated at read time.
//   - &#39;STORED&#39;: The &lt;expression&gt; should be pre-emptively computed at write
//        time (to save work at read time) and must not call any volatle
//        function (e.g. RAND).
//   - &#39;STORED_VOLATILE&#39;: The &lt;expression&gt; must be computed at write time and
//        may call volatile functions (e.g. RAND).
//
// `generated_mode` dictates how the generated column is populated. Values
// are:
//   - &#39;ALWAYS&#39; the generated value is always applied to the column,
//       meaning users cannot write to the column.
//   - &#39;BY_DEFAULT&#39;, the generated value is applied to to the column only if
//        the user does not write to the column.
//   This field is set to ALWAYS by default.
//
// `identity_column_info` contains the sequence attributes that dictate how
// values are generated for the column.
//   - Each table can have at most one identity column.
//
// Note: Exactly one of `expression` and `identity_column_info` must be
// populated.
//
// See (broken link) and
// (broken link).</font>
class ResolvedGeneratedColumnInfo : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GENERATED_COLUMN_INFO;

  typedef <a href="#ResolvedGeneratedColumnInfoEnum">ResolvedGeneratedColumnInfoEnums</a>::StoredMode StoredMode;
  typedef <a href="#ResolvedGeneratedColumnInfoEnum">ResolvedGeneratedColumnInfoEnums</a>::GeneratedMode GeneratedMode;
  static const StoredMode NON_STORED = <a href="#ResolvedGeneratedColumnInfoEnum">ResolvedGeneratedColumnInfoEnums</a>::NON_STORED;
  static const StoredMode STORED = <a href="#ResolvedGeneratedColumnInfoEnum">ResolvedGeneratedColumnInfoEnums</a>::STORED;
  static const StoredMode STORED_VOLATILE = <a href="#ResolvedGeneratedColumnInfoEnum">ResolvedGeneratedColumnInfoEnums</a>::STORED_VOLATILE;
  static const GeneratedMode ALWAYS = <a href="#ResolvedGeneratedColumnInfoEnum">ResolvedGeneratedColumnInfoEnums</a>::ALWAYS;
  static const GeneratedMode BY_DEFAULT = <a href="#ResolvedGeneratedColumnInfoEnum">ResolvedGeneratedColumnInfoEnums</a>::BY_DEFAULT;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expression() const;

  <a href="#ResolvedGeneratedColumnInfo">ResolvedGeneratedColumnInfo</a>::StoredMode stored_mode() const;

  <a href="#ResolvedGeneratedColumnInfo">ResolvedGeneratedColumnInfo</a>::GeneratedMode generated_mode() const;

  const <a href="#ResolvedIdentityColumnInfo">ResolvedIdentityColumnInfo</a>* identity_column_info() const;
};
</code></pre></p>

### ResolvedColumnDefaultValue
<a id="ResolvedColumnDefaultValue"></a>

<p><pre><code class="lang-c++"><font color="brown">// &lt;expression&gt; is the default value expression of the column. The type of
// the expression must be coercible to the column type.
//   - &lt;default_value&gt; cannot contain any references to another column.
//   - &lt;default_value&gt; cannot include a subquery, aggregation, or window
//     function.
//
// &lt;sql&gt; is the original SQL string for the default value expression.
//
// Since we can&#39;t enforce engines to access at least one of the fields, we
// leave both fields NOT_IGNORABLE to ensure engines access at least one of
// them.</font>
class ResolvedColumnDefaultValue : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_COLUMN_DEFAULT_VALUE;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expression() const;

  const std::string&amp; sql() const;
};
</code></pre></p>

### ResolvedColumnDefinition
<a id="ResolvedColumnDefinition"></a>

<p><pre><code class="lang-c++"><font color="brown">// This is used in CREATE TABLE statements to provide an explicit column
// definition.
//
// if &lt;is_hidden&gt; is TRUE, then the column won&#39;t show up in SELECT * queries.
//
// if &lt;generated_column_info&gt; is non-NULL, then this column is a generated
// column.
//
// if &lt;default_value&gt; is non-NULL, then this column has default value.
//
// &lt;generated_column_info&gt; and &lt;default_value&gt; cannot both be set at the
// same time.
//
// &lt;column&gt; defines an ID for the column, which may appear in expressions in
// the PARTITION BY, CLUSTER BY clause or &lt;generated_column_info&gt; if either
// is present.</font>
class ResolvedColumnDefinition : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_COLUMN_DEFINITION;

  // Get the full TypeParameters object for this column, including
  // parameters on nested fields. &lt;annotations.type_parameters&gt; includes
  // only parameters on the outermost type.
  absl::StatusOr&lt;TypeParameters&gt; GetFullTypeParameters() const;

  const std::string&amp; name() const;

  const Type* type() const;

  const <a href="#ResolvedColumnAnnotation">ResolvedColumnAnnotations</a>* annotations() const;

  bool is_hidden() const;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const;

  const <a href="#ResolvedGeneratedColumnInfo">ResolvedGeneratedColumnInfo</a>* generated_column_info() const;

  const <a href="#ResolvedColumnDefaultValue">ResolvedColumnDefaultValue</a>* default_value() const;
};
</code></pre></p>

### ResolvedConstraint
<a id="ResolvedConstraint"></a>

<p><pre><code class="lang-c++"><font color="brown">// Intermediate class for resolved constraints.</font>
class ResolvedConstraint : public <a href="#ResolvedArgument">ResolvedArgument</a> {
};
</code></pre></p>

### ResolvedPrimaryKey
<a id="ResolvedPrimaryKey"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the PRIMARY KEY constraint on a table.
// &lt;column_offset_list&gt; provides the offsets of the column definitions that
//                      comprise the primary key. This is empty when a
//                      0-element primary key is defined or when the altered
//                      table does not exist.
// &lt;unenforced&gt; specifies whether the constraint is unenforced.
// &lt;constraint_name&gt; specifies the constraint name, if present
// &lt;column_name_list&gt; provides the column names used in column definitions
//                    that comprise the primary key.</font>
class ResolvedPrimaryKey : public <a href="#ResolvedConstraint">ResolvedConstraint</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PRIMARY_KEY;

  const std::vector&lt;int&gt;&amp; column_offset_list() const;
  int column_offset_list_size() const;
  int column_offset_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  bool unenforced() const;

  const std::string&amp; constraint_name() const;

  const std::vector&lt;std::string&gt;&amp; column_name_list() const;
  int column_name_list_size() const;
  std::string column_name_list(int i) const;
};
</code></pre></p>

### ResolvedForeignKey
<a id="ResolvedForeignKey"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the FOREIGN KEY constraint on a table. It is of the form:
//
//   CONSTRAINT &lt;constraint_name&gt;
//   FOREIGN KEY &lt;referencing_column_offset_list&gt;
//   REFERENCES &lt;referenced_table&gt; &lt;referenced_column_offset_list&gt;
//   &lt;match_mode&gt;
//   &lt;update_action&gt;
//   &lt;delete_action&gt;
//   &lt;enforced&gt;
//   &lt;option_list&gt;
//
// &lt;constraint_name&gt; uniquely identifies the constraint.
//
// &lt;referencing_column_offset_list&gt; provides the offsets of the column
// definitions for the table defining the foreign key.
//
// &lt;referenced_table&gt; identifies the table this constraint references.
//
// &lt;referenced_column_offset_list&gt; provides the offsets of the column
// definitions for the table referenced by the foreign key.
//
// &lt;match_mode&gt; specifies how referencing keys with null values are handled.
//
// &lt;update_action&gt; specifies what action to take, if any, when a referenced
// value is updated.
//
// &lt;delete_action&gt; specifies what action to take, if any, when a row with a
// referenced values is deleted.
//
// &lt;enforced&gt; specifies whether or not the constraint is enforced.
//
// &lt;option_list&gt; for foreign key table constraints. Empty for foreign key
// column attributes (see instead <a href="#ResolvedColumnAnnotation">ResolvedColumnAnnotations</a>).
//
// &lt;referencing_column_list&gt; provides the names for the foreign key&#39;s
// referencing columns.</font>
class ResolvedForeignKey : public <a href="#ResolvedConstraint">ResolvedConstraint</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FOREIGN_KEY;

  typedef <a href="#ResolvedForeignKeyEnum">ResolvedForeignKeyEnums</a>::MatchMode MatchMode;
  typedef <a href="#ResolvedForeignKeyEnum">ResolvedForeignKeyEnums</a>::ActionOperation ActionOperation;
  static const MatchMode SIMPLE = <a href="#ResolvedForeignKeyEnum">ResolvedForeignKeyEnums</a>::SIMPLE;
  static const MatchMode FULL = <a href="#ResolvedForeignKeyEnum">ResolvedForeignKeyEnums</a>::FULL;
  static const MatchMode NOT_DISTINCT = <a href="#ResolvedForeignKeyEnum">ResolvedForeignKeyEnums</a>::NOT_DISTINCT;
  static const ActionOperation NO_ACTION = <a href="#ResolvedForeignKeyEnum">ResolvedForeignKeyEnums</a>::NO_ACTION;
  static const ActionOperation RESTRICT = <a href="#ResolvedForeignKeyEnum">ResolvedForeignKeyEnums</a>::RESTRICT;
  static const ActionOperation CASCADE = <a href="#ResolvedForeignKeyEnum">ResolvedForeignKeyEnums</a>::CASCADE;
  static const ActionOperation SET_NULL = <a href="#ResolvedForeignKeyEnum">ResolvedForeignKeyEnums</a>::SET_NULL;

  const std::string&amp; constraint_name() const;

  const std::vector&lt;int&gt;&amp; referencing_column_offset_list() const;
  int referencing_column_offset_list_size() const;
  int referencing_column_offset_list(int i) const;

  const Table* referenced_table() const;

  const std::vector&lt;int&gt;&amp; referenced_column_offset_list() const;
  int referenced_column_offset_list_size() const;
  int referenced_column_offset_list(int i) const;

  <a href="#ResolvedForeignKey">ResolvedForeignKey</a>::MatchMode match_mode() const;

  <a href="#ResolvedForeignKey">ResolvedForeignKey</a>::ActionOperation update_action() const;

  <a href="#ResolvedForeignKey">ResolvedForeignKey</a>::ActionOperation delete_action() const;

  bool enforced() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::string&gt;&amp; referencing_column_list() const;
  int referencing_column_list_size() const;
  std::string referencing_column_list(int i) const;
};
</code></pre></p>

### ResolvedCheckConstraint
<a id="ResolvedCheckConstraint"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the ABSL_CHECK constraint on a table. It is of the form:
//
//   CONSTRAINT &lt;constraint_name&gt;
//   ABSL_CHECK &lt;expression&gt;
//   &lt;enforced&gt;
//   &lt;option_list&gt;
//
// &lt;constraint_name&gt; uniquely identifies the constraint.
//
// &lt;expression&gt; defines a boolean expression to be evaluated when the row is
// updated. If the result is FALSE, update to the row is not allowed.
//
// &lt;enforced&gt; specifies whether or not the constraint is enforced.
//
// &lt;option_list&gt; list of options for check constraint.
//
// See (broken link).</font>
class ResolvedCheckConstraint : public <a href="#ResolvedConstraint">ResolvedConstraint</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CHECK_CONSTRAINT;

  const std::string&amp; constraint_name() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expression() const;

  bool enforced() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedOutputColumn
<a id="ResolvedOutputColumn"></a>

<p><pre><code class="lang-c++"><font color="brown">// This is used in <a href="#ResolvedQueryStmt">ResolvedQueryStmt</a> (and other places) to provide a
// user-visible name for each output column, and to map from
// physical <a href="#ResolvedColumn">ResolvedColumns</a> to user-visible output columns.</font>
class ResolvedOutputColumn : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_OUTPUT_COLUMN;

  const std::string&amp; name() const;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const;
};
</code></pre></p>

### ResolvedOutputSchema
<a id="ResolvedOutputSchema"></a>

<p><pre><code class="lang-c++"><font color="brown">// This describes the output schema for table, like what is produced for
// a query statement.
//
// &lt;output_column_list&gt; maps the physical <a href="#ResolvedColumn">ResolvedColumns</a> available to
// the user-visible column names that are returned, with their actual
// column names.  There may be duplicate names, and multiple output columns
// may reference the same physical <a href="#ResolvedColumn">ResolvedColumn</a>.
// The list must be non-empty, since all output tables must have at least
// one column.
//
// This node is used in some places, while many other older nodes just
// have these two fields inlined into a parent object.
// Ideally, all those cases could be migrated to use <a href="#ResolvedOutputSchema">ResolvedOutputSchema</a>.</font>
class ResolvedOutputSchema : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_OUTPUT_SCHEMA;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

<font color="brown">  // If true, the result of this query is a value table. Rather than
  // producing rows with named columns, it produces rows with a single
  // unnamed value type.  output_column_list will have exactly one
  // column, with an empty name. See (broken link).</font>
  bool is_value_table() const;
};
</code></pre></p>

### ResolvedProjectScan
<a id="ResolvedProjectScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// A Project node computes new expression values, and possibly drops
// columns from the input Scan&#39;s column_list.
//
// Each entry in &lt;expr_list&gt; is a new column computed from an expression.
//
// The column_list can include any columns from input_scan, plus these
// newly computed columns.
//
// NOTE: This scan will propagate the is_ordered property of &lt;input_scan&gt;
// by default.  To make this scan unordered, call set_is_ordered(false).</font>
class ResolvedProjectScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PROJECT_SCAN;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; expr_list() const;
  int expr_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* expr_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;
};
</code></pre></p>

### ResolvedTVFScan
<a id="ResolvedTVFScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This scan represents a call to a table-valued function (TVF). Each TVF
// returns an entire output relation instead of a single scalar value. The
// enclosing query may refer to the TVF as if it were a table subquery. The
// TVF may accept scalar arguments and/or other input relations.
//
// Scalar arguments work the same way as arguments for non-table-valued
// functions: in the resolved AST, their types are equal to the required
// argument types specified in the function signature.
//
// The function signature may also include relation arguments, and any such
// relation argument may specify a required schema. If such a required schema
// is present, then in the resolved AST, the <a href="#ResolvedScan">ResolvedScan</a> for each relational
// <a href="#ResolvedFunctionArgument">ResolvedFunctionArgument</a> is guaranteed to have the same number of columns
// as the required schema, and the provided columns match position-wise with
// the required columns. Each provided column has the same name and type as
// the corresponding required column.
//
// If AnalyzerOptions::prune_unused_columns is true, the &lt;column_list&gt; and
// &lt;column_index_list&gt; will include only columns that were referenced
// in the user query. (SELECT * counts as referencing all columns.)
// Pruning has no effect on value tables (the value is never pruned).
//
// &lt;column_list&gt; is a set of new <a href="#ResolvedColumn">ResolvedColumns</a> created by this scan.
// The &lt;column_list&gt;[i] should be matched to the related TVFScan&#39;s output
// relation column by
// &lt;signature&gt;.result_schema().column(&lt;column_index_list&gt;[i]).
//
// &lt;tvf&gt; The TableValuedFunction entry that the catalog returned for this TVF
//       scan. Contains non-concrete function signatures which may include
//       arguments with templated types.
// &lt;signature&gt; The concrete table function signature for this TVF call,
//             including the types of all scalar arguments and the
//             number and types of columns of all table-valued
//             arguments. An engine may also subclass this object to
//             provide extra custom information and return an instance
//             of the subclass from the TableValuedFunction::Resolve
//             method.
// &lt;argument_list&gt; The vector of resolved concrete arguments for this TVF
//                 call, including the default values or NULLs injected for
//                 the omitted arguments (Note the NULL injection is a
//                 temporary solution to handle omitted named arguments. This
//                 is subject to change by upcoming CLs).
//
// &lt;column_index_list&gt; This list matches 1-1 with the &lt;column_list&gt;, and
// identifies the index of the corresponding column in the &lt;signature&gt;&#39;s
// result relation column list.
//
// &lt;alias&gt; The AS alias for the scan, or empty if none.
// &lt;function_call_signature&gt; The FunctionSignature object from the
//                           &lt;tvf-&gt;signatures()&gt; list that matched the
//                           current call. The TVFScan&#39;s
//                           &lt;FunctionSignature::ConcreteArgument&gt; list
//                           matches 1:1 to &lt;argument_list&gt;, while its
//                           &lt;FunctionSignature::arguments&gt; list still has
//                           the full argument list.
//                           Engines may use this object to
//                           check for the argument names and omitted
//                           arguments. SQLBuilder may also need this object
//                           in cases when the named argument notation is
//                           required for this call.</font>
class ResolvedTVFScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_TVFSCAN;

  const TableValuedFunction* tvf() const;

  const std::shared_ptr&lt;TVFSignature&gt;&amp; signature() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedFunctionArgument">ResolvedFunctionArgument</a>&gt;&gt;&amp; argument_list() const;
  int argument_list_size() const;
  const <a href="#ResolvedFunctionArgument">ResolvedFunctionArgument</a>* argument_list(int i) const;

  const std::vector&lt;int&gt;&amp; column_index_list() const;
  int column_index_list_size() const;
  int column_index_list(int i) const;

  const std::string&amp; alias() const;

  const std::shared_ptr&lt;FunctionSignature&gt;&amp; function_call_signature() const;
};
</code></pre></p>

### ResolvedGroupRowsScan
<a id="ResolvedGroupRowsScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// <a href="#ResolvedGroupRowsScan">ResolvedGroupRowsScan</a> represents a call to a special TVF GROUP_ROWS().
// It can only show up inside WITH GROUP ROWS clause, which is resolved as
// the field with_group_rows_subquery in <a href="#ResolvedNonScalarFunctionCallBase">ResolvedNonScalarFunctionCallBase</a>
// <a href="#ResolvedGroupRowsScan">ResolvedGroupRowsScan</a>. This scan produces rows corresponding to the input
// of <a href="#ResolvedAggregateScan">ResolvedAggregateScan</a> that belong to the current group.
//
// &lt;input_column_list&gt; is a list of new columns created to store values
// coming from the input of the aggregate scan. <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a> can
// only hold <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&#39;s and can reference anything from the
// pre-aggregation scan.
//
// &lt;alias&gt; is the alias of the scan or empty if none.</font>
class ResolvedGroupRowsScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GROUP_ROWS_SCAN;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; input_column_list() const;
  int input_column_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* input_column_list(int i) const;

  const std::string&amp; alias() const;
};
</code></pre></p>

### ResolvedFunctionArgument
<a id="ResolvedFunctionArgument"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a generic argument to a function. The argument can be
// semantically an expression, relation, model, connection descriptor, or
// sequence.
//
// The following fields are mutally exclusive:
// * `expr` represents a scalar function argument.
// * `scan` represents a table-typed argument.
// * `model` represents a ML model function argument.
// * `connection` represents a connection object function argument.
// * `descriptor_arg` represents a descriptor object function argument.
// * `inline_lambda` represents a lambda function argument.
// * `sequence` represents a sequence object function argument.
// * `graph` represents a graph function argument.
//
// This node could be used in multiple places:
// * <a href="#ResolvedTVFScan">ResolvedTVFScan</a> supports all of these.
// * <a href="#ResolvedFunctionCall">ResolvedFunctionCall</a> supports `expr`, `inline_lambda`, and `sequence`.
// * <a href="#ResolvedCallStmt">ResolvedCallStmt</a> supports only `expr`.
//
// If the argument has type `scan`, `argument_column_list` maps columns from
// `scan` into specific columns of the argument&#39;s input schema, matching
// those columns positionally. i.e. `scan`&#39;s column_list may have fewer
// columns or out-of-order columns, and this vector maps those columns into
// specific input columns.
//
// Some arguments may also have an alias, stored in the `argument_alias`
// field, which is not mutally exclusive with the fields above.</font>
class ResolvedFunctionArgument : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FUNCTION_ARGUMENT;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* scan() const;

  const <a href="#ResolvedModel">ResolvedModel</a>* model() const;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;

  const <a href="#ResolvedDescriptor">ResolvedDescriptor</a>* descriptor_arg() const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; argument_column_list() const;
  int argument_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> argument_column_list(int i) const;

  const <a href="#ResolvedInlineLambda">ResolvedInlineLambda</a>* inline_lambda() const;

  const <a href="#ResolvedSequence">ResolvedSequence</a>* sequence() const;

  const PropertyGraph* graph() const;

<font color="brown">  // Stores the alias of the argument, either provided by the user or
  // generated by the resolver. This can only be populated if allowed
  // by `FunctionArgumentTypeOptions::argument_alias_kind`.
  //
  // An argument alias is an identifier associated with a function
  // argument in the form of F(&lt;arg&gt; AS &lt;alias&gt;), where &lt;alias&gt; is the
  // argument alias for the function argument &lt;arg&gt;.
  //
  // Examples include
  //   * STRUCT(1 AS x, 2 AS y)
  //   * ARRAY_ZIP(arr1 AS a, arr2 AS b)
  // where the argument alias is used as a field name in an output
  // STRUCT value. For dynamic types like JSON, these aliases may be
  // used at run-time.
  //
  // This field will be empty if the argument does not support aliases,
  // or an alias could not be inferred.
  //
  // The current implementation only allows an argument to have an
  // alias if its type is `expr`, but the support may be extended to
  // other types, e.g. `scan` or `model` in the future.</font>
  const std::string&amp; argument_alias() const;
};
</code></pre></p>

### ResolvedStatement
<a id="ResolvedStatement"></a>

<p><pre><code class="lang-c++"><font color="brown">// The superclass of all ZetaSQL statements.</font>
class ResolvedStatement : public <a href="#ResolvedNode">ResolvedNode</a> {
  typedef <a href="#ResolvedStatementEnum">ResolvedStatementEnums</a>::ObjectAccess ObjectAccess;
  static const ObjectAccess NONE = <a href="#ResolvedStatementEnum">ResolvedStatementEnums</a>::NONE;
  static const ObjectAccess READ = <a href="#ResolvedStatementEnum">ResolvedStatementEnums</a>::READ;
  static const ObjectAccess WRITE = <a href="#ResolvedStatementEnum">ResolvedStatementEnums</a>::WRITE;
  static const ObjectAccess READ_WRITE = <a href="#ResolvedStatementEnum">ResolvedStatementEnums</a>::READ_WRITE;

  bool IsStatement() const final { return true; }

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; hint_list() const;
  int hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* hint_list(int i) const;
};
</code></pre></p>

### ResolvedExplainStmt
<a id="ResolvedExplainStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// An Explain statement. This is always the root of a statement hierarchy.
// Its child may be any statement type except another <a href="#ResolvedExplainStmt">ResolvedExplainStmt</a>.
//
// It is implementation dependent what action a back end system takes for an
// ExplainStatement.</font>
class ResolvedExplainStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXPLAIN_STMT;

  const <a href="#ResolvedStatement">ResolvedStatement</a>* statement() const;
};
</code></pre></p>

### ResolvedStatementWithPipeOperatorsStmt
<a id="ResolvedStatementWithPipeOperatorsStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// A statement with an unanalyzed pipe operator suffix.
// See (broken link).
//
// The query engine needs to analyze or run the initial statement
// (which could have engine-defined output), and then analyze
// `suffix_subpipeline_sql` to determine if that suffix is valid for the
// returned table.
//
// If `statement` doesn&#39;t return exactly one table, the suffix is invalid.
//
// Only <a href="#ResolvedStatement">ResolvedStatement</a> kinds that could return a table are allowed.
// The currently supported list is in `zetasql.tm` and `validator.cc`.</font>
class ResolvedStatementWithPipeOperatorsStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_STATEMENT_WITH_PIPE_OPERATORS_STMT;

  const <a href="#ResolvedStatement">ResolvedStatement</a>* statement() const;

  const std::string&amp; suffix_subpipeline_sql() const;
};
</code></pre></p>

### ResolvedQueryStmt
<a id="ResolvedQueryStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// A SQL query statement.  This is the outermost query statement that runs
// and produces rows of output, like a SELECT.  (The contained query may be
// a Scan corresponding to a non-Select top-level operation like UNION ALL
// or WITH.)
//
// &lt;output_column_list&gt; gives the user-visible column names that should be
// returned in the API or query tools.  There may be duplicate names, and
// multiple output columns may reference the same column from &lt;query&gt;.</font>
class ResolvedQueryStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_QUERY_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

<font color="brown">  // If true, the result of this query is a value table. Rather than
  // producing rows with named columns, it produces rows with a single
  // unnamed value type.  output_column_list will have exactly one
  // column, with an empty name. See (broken link).</font>
  bool is_value_table() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;
};
</code></pre></p>

### ResolvedGeneralizedQueryStmt
<a id="ResolvedGeneralizedQueryStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This is a query statement variation that supports generalized queries
// using operators that might not produce exactly one query result.
// Queries using these operators can produce multiple output tables, or zero
// output tables, and can also have statement side-effects like DML actions.
//
// This is used for any query containing pipe syntax operators like FORK
// (that splits the query into multiple output tables) or terminal operators
// like CREATE TABLE (that consume the output without returning a table).
// See (broken link).
//
// This node can only occur if:
// * FEATURE_PIPES is enabled,
// * Some pipe operator that produces generalized output is enabled,
// * One of those operators occurs in the query, and
// * <a href="#ResolvedGeneralizedQueryStmt">ResolvedGeneralizedQueryStmt</a> is in SupportedStatementKinds in
//   LanguageOptions.
//
// If REWRITE_GENERALIZED_STMT is enabled, this node will always be replaced
// with either a single <a href="#ResolvedStatement">ResolvedStatement</a> (e.g. a <a href="#ResolvedQueryStmt">ResolvedQueryStmt</a>, a
// <a href="#ResolvedCreateTableStmt">ResolvedCreateTableStmt</a>, etc) or a <a href="#ResolvedMultiStmt">ResolvedMultiStmt</a> (if the generalized
// statement expands to multi-statement script, possibly using temp tables).
//
// `output_schema` is nullable, and will be null if the outer `query`
// doesn&#39;t return a table.
//
// Additional output tables or statement side-effects can be found
// while traversing `query`, looking at <a href="#ResolvedGeneralizedQuerySubpipeline">ResolvedGeneralizedQuerySubpipeline</a>
// nodes.</font>
class ResolvedGeneralizedQueryStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GENERALIZED_QUERY_STMT;

  const <a href="#ResolvedOutputSchema">ResolvedOutputSchema</a>* output_schema() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;
};
</code></pre></p>

### ResolvedMultiStmt
<a id="ResolvedMultiStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement contains a list of statements that execute like a script.
// This is never produced by the resolver directly.  This is only
// produced by the REWRITE_GENERALIZED_STMT rewrite which replaces
// <a href="#ResolvedGeneralizedQueryStmt">ResolvedGeneralizedQueryStmt</a> with multi-statement expansions.
//
// This is used because rewriters cannot directly rewrite one statement
// into multiple statements.  Instead, the rewriter generates this node,
// which has a list of sub-statements inside it.
//
// The statements can include <a href="#ResolvedCreateWithEntryStmt">ResolvedCreateWithEntryStmts</a>, which store the
// result of a sub-statement query as a CTE.  It can be referenced in later
// statements inside this <a href="#ResolvedMultiStmt">ResolvedMultiStmt</a> using <a href="#ResolvedWithRefScan">ResolvedWithRefScan</a>.
//
// Rules:
// * `statement_list` will contain at least two statements.
// * `statement_list` cannot contain a nested <a href="#ResolvedMultiStmt">ResolvedMultiStmt</a>.
//
// Additional semantics to note:
// * If contained inside a <a href="#ResolvedExplainStmt">ResolvedExplainStmt</a>, all contained statements
//   should be explained, either individually or together.</font>
class ResolvedMultiStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MULTI_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedStatement">ResolvedStatement</a>&gt;&gt;&amp; statement_list() const;
  int statement_list_size() const;
  const <a href="#ResolvedStatement">ResolvedStatement</a>* statement_list(int i) const;
};
</code></pre></p>

### ResolvedCreateWithEntryStmt
<a id="ResolvedCreateWithEntryStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement creates a CTE (a WITH query definition) inside a
// <a href="#ResolvedMultiStmt">ResolvedMultiStmt</a>.  This can only occur inside <a href="#ResolvedMultiStmt">ResolvedMultiStmt</a>.
//
// This executes like the definition part of a <a href="#ResolvedWithScan">ResolvedWithScan</a>, without a
// final query.
//
// The created CTE is visible in later statements in the <a href="#ResolvedMultiStmt">ResolvedMultiStmt</a>.
//
// The CTE can be recursive.  This is indicated by an outer scan of type
// <a href="#ResolvedRecursiveScan">ResolvedRecursiveScan</a> in the <a href="#ResolvedWithEntry">ResolvedWithEntry</a>.</font>
class ResolvedCreateWithEntryStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_WITH_ENTRY_STMT;

  const <a href="#ResolvedWithEntry">ResolvedWithEntry</a>* with_entry() const;
};
</code></pre></p>

### ResolvedCreateDatabaseStmt
<a id="ResolvedCreateDatabaseStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   CREATE DATABASE &lt;name&gt; [OPTIONS (...)]
// &lt;name_path&gt; is a vector giving the identifier path in the database name.
// &lt;option_list&gt; specifies the options of the database.</font>
class ResolvedCreateDatabaseStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_DATABASE_STMT;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedCreateStatement
<a id="ResolvedCreateStatement"></a>

<p><pre><code class="lang-c++"><font color="brown">// Common superclass for CREATE statements with standard modifiers like
//         CREATE [OR REPLACE] [TEMP|TEMPORARY|PUBLIC|PRIVATE] &lt;object type&gt;
//         [IF NOT EXISTS] &lt;name&gt; ...
//
// &lt;name_path&gt; is a vector giving the identifier path in the table name.
// &lt;create_scope&gt; is the relevant scope, i.e., DEFAULT, TEMP, PUBLIC,
//                or PRIVATE.  PUBLIC/PRIVATE are only valid in module
//                resolution context, see (broken link)
//                for details.
// &lt;create_mode&gt; indicates if this was CREATE, CREATE OR REPLACE, or
//               CREATE IF NOT EXISTS.</font>
class ResolvedCreateStatement : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  typedef <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::CreateScope CreateScope;
  typedef <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::CreateMode CreateMode;
  typedef <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::SqlSecurity SqlSecurity;
  typedef <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::DeterminismLevel DeterminismLevel;
  static const CreateScope CREATE_DEFAULT_SCOPE = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::CREATE_DEFAULT_SCOPE;
  static const CreateScope CREATE_PRIVATE = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::CREATE_PRIVATE;
  static const CreateScope CREATE_PUBLIC = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::CREATE_PUBLIC;
  static const CreateScope CREATE_TEMP = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::CREATE_TEMP;
  static const CreateMode CREATE_DEFAULT = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::CREATE_DEFAULT;
  static const CreateMode CREATE_OR_REPLACE = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::CREATE_OR_REPLACE;
  static const CreateMode CREATE_IF_NOT_EXISTS = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::CREATE_IF_NOT_EXISTS;
  static const SqlSecurity SQL_SECURITY_UNSPECIFIED = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::SQL_SECURITY_UNSPECIFIED;
  static const SqlSecurity SQL_SECURITY_DEFINER = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::SQL_SECURITY_DEFINER;
  static const SqlSecurity SQL_SECURITY_INVOKER = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::SQL_SECURITY_INVOKER;
  static const DeterminismLevel DETERMINISM_UNSPECIFIED = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::DETERMINISM_UNSPECIFIED;
  static const DeterminismLevel DETERMINISM_DETERMINISTIC = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::DETERMINISM_DETERMINISTIC;
  static const DeterminismLevel DETERMINISM_NOT_DETERMINISTIC = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::DETERMINISM_NOT_DETERMINISTIC;
  static const DeterminismLevel DETERMINISM_IMMUTABLE = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::DETERMINISM_IMMUTABLE;
  static const DeterminismLevel DETERMINISM_STABLE = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::DETERMINISM_STABLE;
  static const DeterminismLevel DETERMINISM_VOLATILE = <a href="#ResolvedCreateStatementEnum">ResolvedCreateStatementEnums</a>::DETERMINISM_VOLATILE;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a>::CreateScope create_scope() const;

  <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a>::CreateMode create_mode() const;
};
</code></pre></p>

### ResolvedIndexItem
<a id="ResolvedIndexItem"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents one of indexed items in CREATE INDEX statement, with the
// ordering direction specified.
//
// `option_list` represents the per item options for the index. This is
// used in both the case where ALL COLUMNS is used and the case where
// specific items are specified. The list of options for a specific item
// must not be empty in the case of ALL COLUMNS.</font>
class ResolvedIndexItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_INDEX_ITEM;

  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* column_ref() const;

  bool descending() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedUnnestItem
<a id="ResolvedUnnestItem"></a>

<p><pre><code class="lang-c++"><font color="brown">// This is used in CREATE INDEX STMT to represent the unnest operation
// performed on the base table. The produced element columns or array offset
// columns (optional) can appear in other <a href="#ResolvedUnnestItem">ResolvedUnnestItem</a> or index keys.
//
// &lt;array_expr&gt; is the expression of the array field, e.g., t.array_field.
// &lt;element_column&gt; is the new column produced by this unnest item that
//                  stores the array element value for each row.
// &lt;array_offset_column&gt; is optional. If present, it defines the column
//                       produced by this unnest item that stores the array
//                       offset (0-based) for the corresponding
//                       &lt;element_column&gt;.</font>
class ResolvedUnnestItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UNNEST_ITEM;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* array_expr() const;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; element_column() const;

  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* array_offset_column() const;
};
</code></pre></p>

### ResolvedCreateIndexStmt
<a id="ResolvedCreateIndexStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// CREATE [OR REPLACE] [UNIQUE] [SEARCH | VECTOR] INDEX [IF NOT EXISTS]
//  &lt;index_name_path&gt; ON &lt;table_name_path&gt;
// [UNNEST(path_expression) [[AS] alias] [WITH OFFSET [[AS] alias]], ...]
// (path_expression [ASC|DESC], ...)
// [STORING (Expression, ...)]
// [PARTITION BY partition_expression, ...]
// [OPTIONS (name=value, ...)];
//
// &lt;table_name_path&gt; is the name of table being indexed.
// &lt;table_scan&gt; is a TableScan on the table being indexed.
// &lt;is_unique&gt; specifies if the index has unique entries.
// &lt;is_search&gt; specifies if the index is for search. It is mutually exclusive
//             with is_vector.
// &lt;is_vector&gt; specifies if the index is for vector search. It is mutually
//             exclusive with is_search.
// &lt;index_all_columns&gt; specifies if indexing all the columns of the table.
//                     When this field is true, index_item_list must be
//                     empty and is_search must be true.
// &lt;index_item_list&gt; has the columns being indexed, specified as references
//                   to &#39;computed_columns_list&#39; entries or the columns of
//                   &#39;table_scan&#39;.
// &lt;storing_expression_list&gt; has the expressions in the storing clause.
// &lt;partition_by_list&gt; has the expressions in the partition by clause.
// &lt;option_list&gt; has engine-specific directives for how and where to
//               materialize this index.
// &lt;computed_columns_list&gt; has computed columns derived from the columns of
//                         &#39;table_scan&#39; or &#39;unnest_expressions_list&#39;. For
//                         example, the extracted field (e.g., x.y.z).
// &lt;unnest_expressions_list&gt; has unnest expressions derived from
//                           &#39;table_scan&#39; or previous unnest expressions in
//                           the list. So the list order is significant.</font>
class ResolvedCreateIndexStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_INDEX_STMT;

  const std::vector&lt;std::string&gt;&amp; table_name_path() const;
  int table_name_path_size() const;
  std::string table_name_path(int i) const;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

  bool is_unique() const;

  bool is_search() const;

  bool is_vector() const;

  bool index_all_columns() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedIndexItem">ResolvedIndexItem</a>&gt;&gt;&amp; index_item_list() const;
  int index_item_list_size() const;
  const <a href="#ResolvedIndexItem">ResolvedIndexItem</a>* index_item_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; storing_expression_list() const;
  int storing_expression_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* storing_expression_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; partition_by_list() const;
  int partition_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* partition_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; computed_columns_list() const;
  int computed_columns_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* computed_columns_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUnnestItem">ResolvedUnnestItem</a>&gt;&gt;&amp; unnest_expressions_list() const;
  int unnest_expressions_list_size() const;
  const <a href="#ResolvedUnnestItem">ResolvedUnnestItem</a>* unnest_expressions_list(int i) const;
};
</code></pre></p>

### ResolvedCreateSchemaStmtBase
<a id="ResolvedCreateSchemaStmtBase"></a>

<p><pre><code class="lang-c++"><font color="brown">// A base for statements that create schemas, such as:
//   CREATE [OR REPLACE] SCHEMA [IF NOT EXISTS] &lt;name&gt;
//   [DEFAULT COLLATE &lt;collation&gt;]
//   [OPTIONS (name=value, ...)]
//
//   CREATE [OR REPLACE] [TEMP|TEMPORARY|PUBLIC|PRIVATE] EXTERNAL SCHEMA
//   [IF NOT EXISTS] &lt;name&gt; [WITH CONNECTION] &lt;connection&gt;
//   OPTIONS (name=value, ...)
//
// &lt;option_list&gt; contains engine-specific options associated with the schema</font>
class ResolvedCreateSchemaStmtBase : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedCreateSchemaStmt
<a id="ResolvedCreateSchemaStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   CREATE [OR REPLACE] SCHEMA [IF NOT EXISTS] &lt;name&gt;
//   [DEFAULT COLLATE &lt;collation&gt;]
//   [OPTIONS (name=value, ...)]
// &lt;collation_name&gt; specifies the default collation specification for future
//   tables created in the dataset. If a table is created in this dataset
//   without specifying table-level default collation, it inherits the
//   dataset default collation. A change to this field affects only tables
//   created afterwards, not the existing tables. Only string literals
//   are allowed for this field.
//
//   Note: If a table being created in this schema does not specify table
//   default collation, the engine should copy the dataset default collation
//   to the table as the table default collation.</font>
class ResolvedCreateSchemaStmt : public <a href="#ResolvedCreateSchemaStmtBase">ResolvedCreateSchemaStmtBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_SCHEMA_STMT;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* collation_name() const;
};
</code></pre></p>

### ResolvedCreateExternalSchemaStmt
<a id="ResolvedCreateExternalSchemaStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// CREATE [OR REPLACE] [TEMP|TEMPORARY|PUBLIC|PRIVATE] EXTERNAL SCHEMA
// [IF NOT EXISTS] &lt;name&gt; [WITH CONNECTION] &lt;connection&gt;
// OPTIONS (name=value, ...)
//
// &lt;connection&gt; encapsulates engine-specific metadata used to connect
// to an external data source
//
// Note: external schemas are pointers to schemas defined in an external
// system. CREATE EXTERNAL SCHEMA does not actually build a new schema.</font>
class ResolvedCreateExternalSchemaStmt : public <a href="#ResolvedCreateSchemaStmtBase">ResolvedCreateSchemaStmtBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_EXTERNAL_SCHEMA_STMT;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;
};
</code></pre></p>

### ResolvedCreateTableStmtBase
<a id="ResolvedCreateTableStmtBase"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   CREATE [TEMP] TABLE &lt;name&gt; [(column type, ...) | LIKE &lt;name_path&gt;]
//   [DEFAULT COLLATE &lt;collation&gt;] [PARTITION BY expr, ...]
//   [CLUSTER BY expr, ...] [OPTIONS (...)]
//
// &lt;option_list&gt; has engine-specific directives for how and where to
//               materialize this table.
// &lt;column_definition_list&gt; has the names and types of the columns in the
//                          created table. If &lt;is_value_table&gt; is true, it
//                          must contain exactly one column, with a generated
//                          name such as &#34;$struct&#34;.
// &lt;pseudo_column_list&gt; is a list of some pseudo-columns expected to be
//                      present on the created table (provided by
//                      AnalyzerOptions::SetDdlPseudoColumns*).  These can be
//                      referenced in expressions in &lt;partition_by_list&gt; and
//                      &lt;cluster_by_list&gt;.
// &lt;primary_key&gt; specifies the PRIMARY KEY constraint on the table, it is
//               nullptr when no PRIMARY KEY is specified.
// &lt;foreign_key_list&gt; specifies the FOREIGN KEY constraints on the table.
// &lt;check_constraint_list&gt; specifies the ABSL_CHECK constraints on the table.
// &lt;partition_by_list&gt; specifies the partitioning expressions for the table.
// &lt;cluster_by_list&gt; specifies the clustering expressions for the table.
// TODO: Return error when the PARTITION BY / CLUSTER BY
// expression resolves to have collation specified.
// &lt;is_value_table&gt; specifies whether the table is a value table.
//                  See (broken link).
// &lt;like_table&gt; identifies the table in the LIKE &lt;name_path&gt;.
//              By default, all fields (column names, types, constraints,
//              keys, clustering etc.) will be inherited from the source
//              table. But if explicitly set, the explicit settings will
//              take precedence.
// &lt;collation_name&gt; specifies the default collation specification to apply to
//   newly added STRING fields in this table. A change of this field affects
//   only the STRING columns and the STRING fields in STRUCTs added
//   afterwards, not existing columns. Only string literals are allowed for
//   this field.
//
//   Note: During table creation or alteration, if a STRING field is added to
//   this table without explicit collation specified, the engine should copy
//   the table default collation to the STRING field.</font>
class ResolvedCreateTableStmtBase : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>&gt;&gt;&amp; column_definition_list() const;
  int column_definition_list_size() const;
  const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>* column_definition_list(int i) const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; pseudo_column_list() const;
  int pseudo_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> pseudo_column_list(int i) const;

  const <a href="#ResolvedPrimaryKey">ResolvedPrimaryKey</a>* primary_key() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedForeignKey">ResolvedForeignKey</a>&gt;&gt;&amp; foreign_key_list() const;
  int foreign_key_list_size() const;
  const <a href="#ResolvedForeignKey">ResolvedForeignKey</a>* foreign_key_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedCheckConstraint">ResolvedCheckConstraint</a>&gt;&gt;&amp; check_constraint_list() const;
  int check_constraint_list_size() const;
  const <a href="#ResolvedCheckConstraint">ResolvedCheckConstraint</a>* check_constraint_list(int i) const;

  bool is_value_table() const;

  const Table* like_table() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* collation_name() const;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;
};
</code></pre></p>

### ResolvedCreateTableStmt
<a id="ResolvedCreateTableStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   CREATE [TEMP] TABLE &lt;name&gt;
//   [(column schema, ...) | LIKE &lt;name_path&gt; |
//       {CLONE|COPY} &lt;name_path&gt;
//           [FOR SYSTEM_TIME AS OF &lt;time_expr&gt;]
//           [WHERE &lt;where_clause&gt;]]
//   [DEFAULT COLLATE &lt;collation_name&gt;]
//   [PARTITION BY expr, ...] [CLUSTER BY expr, ...]
//   [WITH CONNECTION connection_name]
//   [OPTIONS (...)]
//
// One of &lt;clone_from&gt; or &lt;copy_from&gt; can be present for CLONE or COPY.
//   &lt;clone_from&gt; specifies the data source to clone from (cheap, typically
//   O(1) operation); while &lt;copy_from&gt; is intended for a full copy.
//
//   <a href="#ResolvedTableScan">ResolvedTableScan</a> will represent the source table, with an optional
//   for_system_time_expr.
//
//   The <a href="#ResolvedTableScan">ResolvedTableScan</a> may be wrapped inside a <a href="#ResolvedFilterScan">ResolvedFilterScan</a> if the
//   source table has a where clause. No other Scan types are allowed here.
//
//   If the OPTIONS clause is explicitly specified, the option values are
//   intended to be used for the created or replaced table.
//   If any OPTION is unspecified, the corresponding option from the source
//   table will be used instead.
//
//   The &#39;clone_from.column_list&#39; field may be set, but should be ignored.
//
//   clone_from and copy_from cannot be value tables.</font>
class ResolvedCreateTableStmt : public <a href="#ResolvedCreateTableStmtBase">ResolvedCreateTableStmtBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_TABLE_STMT;

  const <a href="#ResolvedScan">ResolvedScan</a>* clone_from() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* copy_from() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; partition_by_list() const;
  int partition_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* partition_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; cluster_by_list() const;
  int cluster_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* cluster_by_list(int i) const;
};
</code></pre></p>

### ResolvedCreateTableAsSelectStmt
<a id="ResolvedCreateTableAsSelectStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   CREATE [TEMP] TABLE &lt;name&gt; [(column schema, ...) | LIKE &lt;name_path&gt;]
//   [DEFAULT COLLATE &lt;collation_name&gt;] [PARTITION BY expr, ...]
//   [CLUSTER BY expr, ...]
//   [WITH CONNECTION connection_name]
//   [OPTIONS (...)]
//   AS SELECT ...
//
// Also used for the pipe operator
//   |&gt; CREATE [TEMP] TABLE ...
// which also has the same optional modifiers, but no AS query.
// This occurs inside <a href="#ResolvedPipeCreateTableScan">ResolvedPipeCreateTableScan</a>, with the pipe
// input stored in `query`.  All other modifier fields are allowed.
//
// The &lt;output_column_list&gt; matches 1:1 with the &lt;column_definition_list&gt; in
// <a href="#ResolvedCreateTableStmtBase">ResolvedCreateTableStmtBase</a>, and maps <a href="#ResolvedColumn">ResolvedColumns</a> produced by &lt;query&gt;
// into specific columns of the created table.  The output column names and
// types must match the column definition names and types.  If the table is
// a value table, &lt;output_column_list&gt; must have exactly one column, with a
// generated name such as &#34;$struct&#34;.
//
// &lt;output_column_list&gt; does not contain all table schema information that
// &lt;column_definition_list&gt; does. For example, NOT NULL annotations, column
// OPTIONS, and primary keys are only available in &lt;column_definition_list&gt;.
// Consumers are encouraged to read from &lt;column_definition_list&gt; rather
// than than &lt;output_column_list&gt; to determine the table schema, if possible.
//
// &lt;query&gt; is the query to run.</font>
class ResolvedCreateTableAsSelectStmt : public <a href="#ResolvedCreateTableStmtBase">ResolvedCreateTableStmtBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_TABLE_AS_SELECT_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; partition_by_list() const;
  int partition_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* partition_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; cluster_by_list() const;
  int cluster_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* cluster_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;
};
</code></pre></p>

### ResolvedCreateModelAliasedQuery
<a id="ResolvedCreateModelAliasedQuery"></a>

<p><pre><code class="lang-c++"><font color="brown">// Resolves a create model aliased query:
// identifier AS &lt;query&gt;
//
// &lt;alias&gt; is the string representation of identifier.
// &lt;query&gt; is the <a href="#ResolvedScan">ResolvedScan</a> of the subquery.
// &lt;output_column_list&gt; matches 1:1 with the &lt;query&gt;&#39;s column_list and
// identifies the names and types of the columns output from the query.</font>
class ResolvedCreateModelAliasedQuery : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_MODEL_ALIASED_QUERY;

  const std::string&amp; alias() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;
};
</code></pre></p>

### ResolvedCreateModelStmt
<a id="ResolvedCreateModelStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   CREATE [TEMP] MODEL &lt;name&gt; [INPUT(...) OUTPUT(...)] [TRANSFORM(...)]
//   [REMOTE [WITH CONNECTION ...]] [OPTIONS (...)]
//   [AS &lt;query&gt; | (&lt;identifier&gt; AS (&lt;query&gt;) [, ...])]
//
// At most one of &lt;query&gt; and &lt;aliased_query_list&gt; can be set. &lt;query&gt; is
// used when there is a single query as input. &lt;aliased_query_list&gt; is used
// for the syntax with multiple queries with identifiers. For below, let
// &lt;has_query&gt; be true if either of these are present.
//
// Models can be evaluated either locally or remotely. Orthogonally, they can
// be either trained using SQL or come from external source. Depending on
// these properties, different clauses are expected to be present.
//
// * Local models &lt;is_remote&gt; = FALSE
//   * Trained: &lt;has_query&gt;
//   * External: !&lt;has_query&gt;
// * Remote models &lt;is_remote&gt; = TRUE
//   * Trained: &lt;has_query&gt;
//   * External: !&lt;has_query&gt;
//
// &lt;option_list&gt; has engine-specific directives for how to train this model.
// &lt;query&gt; is the AS SELECT statement. It can be only set when all of
//   &lt;input_column_definition_list&gt;, &lt;output_column_definition_list&gt; and
//   &lt;aliased_query_list&gt; are empty.
// TODO: consider rename to &lt;query_output_column_list&gt;.
// &lt;output_column_list&gt; matches 1:1 with the &lt;query&gt;&#39;s column_list and
//   identifies the names and types of the columns output from the select
//   statement. Set only when &lt;query&gt; is present.
// &lt;input_column_definition_list&gt; contains names and types of model&#39;s input
//   columns. Cannot be set if &lt;has_query&gt; is true. Might be absent when
//   &lt;is_remote&gt; is true, meaning schema is read from the remote model
//   itself.
// &lt;output_column_definition_list&gt; contains names and types of model&#39;s output
//   columns. Cannot be set if &lt;has_query&gt; is true. Might be absent when
//   &lt;is_remote&gt; is true, meaning schema is read from the remote model
//   itself.
// &lt;is_remote&gt; is true if this is a remote model.
// &lt;connection&gt; is the identifier path of the connection object. It can be
//   only set when &lt;is_remote&gt; is true.
// &lt;transform_list&gt; is the list of <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a> in TRANSFORM
//   clause. It can be only set when &lt;query&gt; is present.
// &lt;transform_input_column_list&gt; introduces new <a href="#ResolvedColumn">ResolvedColumns</a> that have the
//   same names and types of the columns in the &lt;output_column_list&gt;. The
//   transform expressions resolve against these <a href="#ResolvedColumn">ResolvedColumns</a>. It&#39;s only
//   set when &lt;transform_list&gt; is non-empty.
// &lt;transform_output_column_list&gt; matches 1:1 with &lt;transform_list&gt; output.
//   It records the names of the output columns from TRANSFORM clause.
// &lt;transform_analytic_function_group_list&gt; is the list of
//   AnalyticFunctionGroup for analytic functions inside TRANSFORM clause.
//   It records the input expression of the analytic functions. It can
//   see all the columns from &lt;transform_input_column_list&gt;. The only valid
//   group is for the full, unbounded window generated from empty OVER()
//   clause.
//   For example, CREATE MODEL statement
//   &#34;create model Z
//     transform (max(c) over() as d)
//     options ()
//     as select 1 c, 2 b;&#34;
//   will generate transform_analytic_function_group_list:
//   +-transform_analytic_function_group_list=
//     +-AnalyticFunctionGroup
//       +-analytic_function_list=
//         +-d#5 :=
//           +-AnalyticFunctionCall(ZetaSQL:max(INT64) -&gt; INT64)
//             +-ColumnRef(type=INT64, column=Z.c#3)
//             +-window_frame=
//               +-WindowFrame(frame_unit=ROWS)
//                 +-start_expr=
//                 | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
//                 +-end_expr=
//                   +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
// &lt;aliased_query_list&gt; is the aliased query list. It can only be set when
//   &lt;is_remote&gt; is false and &lt;query&gt; is null. It cannot coexist with any
//   transform related resolved nodes.</font>
class ResolvedCreateModelStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_MODEL_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedCreateModelAliasedQuery">ResolvedCreateModelAliasedQuery</a>&gt;&gt;&amp; aliased_query_list() const;
  int aliased_query_list_size() const;
  const <a href="#ResolvedCreateModelAliasedQuery">ResolvedCreateModelAliasedQuery</a>* aliased_query_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>&gt;&gt;&amp; transform_input_column_list() const;
  int transform_input_column_list_size() const;
  const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>* transform_input_column_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; transform_list() const;
  int transform_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* transform_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; transform_output_column_list() const;
  int transform_output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* transform_output_column_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>&gt;&gt;&amp; transform_analytic_function_group_list() const;
  int transform_analytic_function_group_list_size() const;
  const <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>* transform_analytic_function_group_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>&gt;&gt;&amp; input_column_definition_list() const;
  int input_column_definition_list_size() const;
  const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>* input_column_definition_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>&gt;&gt;&amp; output_column_definition_list() const;
  int output_column_definition_list_size() const;
  const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>* output_column_definition_list(int i) const;

  bool is_remote() const;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;
};
</code></pre></p>

### ResolvedCreateViewBase
<a id="ResolvedCreateViewBase"></a>

<p><pre><code class="lang-c++"><font color="brown">// Common superclass for CREATE view/materialized view:
//   CREATE [TEMP|MATERIALIZED] [RECURSIVE] VIEW &lt;name&gt; [(...)]
//     [OPTIONS (...)]
//     AS SELECT ...
//
// &lt;option_list&gt; has engine-specific directives for options attached to
//               this view.
// &lt;output_column_list&gt; has the names and types of the columns in the
//                      created view, and maps from &lt;query&gt;&#39;s column_list
//                      to these output columns. If &lt;has_explicit_columns&gt; is
//                      true, names will be explicitly provided.
// &lt;has_explicit_columns&gt; If this is set, the statement includes an explicit
//   column name list. These column names should still be applied even if the
//   query changes or is re-resolved in the future. The view becomes invalid
//   if the query produces a different number of columns.
// &lt;query&gt; is the query to run.
// &lt;sql&gt; is the view query text.
// &lt;sql_security&gt; is the declared security mode for the function. Values
//    include &#39;INVOKER&#39;, &#39;DEFINER&#39;.
// &lt;recursive&gt; specifies whether or not the view is created with the
//   RECURSIVE keyword.
// &lt;column_definition_list&gt; matches 1:1 with the &lt;output_column_list&gt; and
//   provides explicit definition for each output column. Output column names
//   and types must match column definition names and types. If the table is
//   a value table, &lt;column_definition_list&gt; must have exactly one column,
//   with a generated name such as &#34;$struct&#34;.
//
// Currently &lt;column_definition_list&gt; contains the same schema information
// (column names and types) as &lt;output_column_list&gt;, but also contains the
// column OPTIONS. Therefore, consumers are encouraged to read from
// &lt;column_definition_list&gt; rather than from &lt;output_column_list&gt; to
// determine the schema, if possible.
//
// Note that &lt;query&gt; and &lt;sql&gt; are both marked as IGNORABLE because
// an engine could look at either one (but might not look at both).
// An engine must look at one (and cannot ignore both) to be
// semantically valid, but there is currently no way to enforce that.
//
// The view must produce named columns with unique names.</font>
class ResolvedCreateViewBase : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

  bool has_explicit_columns() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;

  const std::string&amp; sql() const;

  <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a>::SqlSecurity sql_security() const;

<font color="brown">  // If true, this view produces a value table. Rather than producing
  // rows with named columns, it produces rows with a single unnamed
  // value type.  output_column_list will have exactly one column, with
  // an empty name. See (broken link).</font>
  bool is_value_table() const;

<font color="brown">  // True if the view uses the RECURSIVE keyword. &lt;query&gt;
  // can be a <a href="#ResolvedRecursiveScan">ResolvedRecursiveScan</a> only if this is true.</font>
  bool recursive() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>&gt;&gt;&amp; column_definition_list() const;
  int column_definition_list_size() const;
  const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>* column_definition_list(int i) const;
};
</code></pre></p>

### ResolvedCreateViewStmt
<a id="ResolvedCreateViewStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// CREATE [TEMP] VIEW &lt;name&gt; [(...)] [OPTIONS (...)] AS SELECT ...</font>
class ResolvedCreateViewStmt : public <a href="#ResolvedCreateViewBase">ResolvedCreateViewBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_VIEW_STMT;

};
</code></pre></p>

### ResolvedWithPartitionColumns
<a id="ResolvedWithPartitionColumn"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// WITH PARTITION COLUMNS [(column schema, ...)]</font>
class ResolvedWithPartitionColumns : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WITH_PARTITION_COLUMNS;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>&gt;&gt;&amp; column_definition_list() const;
  int column_definition_list_size() const;
  const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>* column_definition_list(int i) const;
};
</code></pre></p>

### ResolvedCreateSnapshotTableStmt
<a id="ResolvedCreateSnapshotTableStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   CREATE SNAPSHOT TABLE [IF NOT EXISTS] &lt;name&gt; [OPTIONS (...)]
//   CLONE &lt;name&gt;
//           [FOR SYSTEM_TIME AS OF &lt;time_expr&gt;]
//
// &lt;clone_from&gt; the source data to clone data from.
//              <a href="#ResolvedTableScan">ResolvedTableScan</a> will represent the source table, with an
//              optional for_system_time_expr.
//              The <a href="#ResolvedTableScan">ResolvedTableScan</a> may be wrapped inside a
//              <a href="#ResolvedFilterScan">ResolvedFilterScan</a> if the source table has a where clause.
//              No other Scan types are allowed here.
//              By default, all fields (column names, types, constraints,
//              partition, clustering, options etc.) will be inherited from
//              the source table. If table options are explicitly set, the
//              explicit options will take precedence.
//              The &#39;clone_from.column_list&#39; field may be set, but should be
//              ignored.</font>
class ResolvedCreateSnapshotTableStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_SNAPSHOT_TABLE_STMT;

  const <a href="#ResolvedScan">ResolvedScan</a>* clone_from() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedCreateExternalTableStmt
<a id="ResolvedCreateExternalTableStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// CREATE [TEMP] EXTERNAL TABLE &lt;name&gt; [(column type, ...)]
// [DEFAULT COLLATE &lt;collation_name&gt;]
// [WITH PARTITION COLUMN [(column type, ...)]]
// [WITH CONNECTION connection_name]
// OPTIONS (...)</font>
class ResolvedCreateExternalTableStmt : public <a href="#ResolvedCreateTableStmtBase">ResolvedCreateTableStmtBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_EXTERNAL_TABLE_STMT;

  const <a href="#ResolvedWithPartitionColumn">ResolvedWithPartitionColumns</a>* with_partition_columns() const;
};
</code></pre></p>

### ResolvedExportModelStmt
<a id="ResolvedExportModelStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   EXPORT MODEL &lt;model_name_path&gt; [WITH CONNECTION &lt;connection&gt;]
//   &lt;option_list&gt;
// which is used to export a model to a specific location.
// &lt;connection&gt; is the connection that the model is written to.
// &lt;option_list&gt; identifies user specified options to use when exporting the
//   model.</font>
class ResolvedExportModelStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXPORT_MODEL_STMT;

  const std::vector&lt;std::string&gt;&amp; model_name_path() const;
  int model_name_path_size() const;
  std::string model_name_path(int i) const;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedExportDataStmt
<a id="ResolvedExportDataStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   EXPORT DATA [WITH CONNECTION] &lt;connection&gt; (&lt;option_list&gt;) AS SELECT ...
//
// Also used for the pipe operator
//   |&gt; EXPORT DATA [WITH CONNECTION] &lt;connection&gt; (&lt;option_list&gt;)
// This occurs inside <a href="#ResolvedPipeExportDataScan">ResolvedPipeExportDataScan</a>, with the pipe
// input stored in `query`.  All other modifier fields are allowed.
//
// This is used to run export a query result somewhere without giving the
// result a table name.
//
// &lt;connection&gt; connection reference for accessing destination source.
// &lt;option_list&gt; has engine-specific directives for how and where to
//               materialize the query result.
// &lt;output_column_list&gt; has the names and types of the columns produced by
//                      the query, and maps from &lt;query&gt;&#39;s column_list
//                      to these output columns.  The engine may ignore
//                      the column names depending on the output format.
// &lt;query&gt; is the query to run (when this node is used as a statement).
//         When this node is used as part of <a href="#ResolvedPipeExportDataScan">ResolvedPipeExportDataScan</a>,
//         &lt;query&gt; is not present.  The input table is the pipe input table.
//
// The query must produce named columns with unique names.</font>
class ResolvedExportDataStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXPORT_DATA_STMT;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

<font color="brown">  // If true, the result of this query is a value table. Rather than
  // producing rows with named columns, it produces rows with a single
  // unnamed value type.  output_column_list will have exactly one
  // column, with an empty name. See (broken link).</font>
  bool is_value_table() const;

<font color="brown">  // `query` is present when this node is used as a statement.
  // `query` is not present when used in <a href="#ResolvedPipeExportDataScan">ResolvedPipeExportDataScan</a>.</font>
  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;
};
</code></pre></p>

### ResolvedExportMetadataStmt
<a id="ResolvedExportMetadataStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   EXPORT &lt;schema_object_kind&gt; METADATA FROM &lt;name_path&gt;
//   [WITH CONNECTION &lt;connection&gt;] [OPTIONS(&lt;option_list&gt;)]
//
// &lt;schema_object_kind&gt; is a string identifier for the object for which the
// metadata should be exported. Currently, only &#39;TABLE&#39; object is supported.
// &lt;name_path&gt; is a vector giving the identifier path for the object for
// which the metadata should be exported.
// &lt;connection&gt; connection reference for accessing destination source.
// &lt;option_list&gt; identifies user specified options to use when exporting
// object&#39;s metadata.</font>
class ResolvedExportMetadataStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXPORT_METADATA_STMT;

  const std::string&amp; schema_object_kind() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedDefineTableStmt
<a id="ResolvedDefineTableStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: DEFINE TABLE name (...);
//
// &lt;name_path&gt; is a vector giving the identifier path in the table name.
// &lt;option_list&gt; has engine-specific options of how the table is defined.
//
// DEFINE TABLE normally has the same effect as CREATE TEMP EXTERNAL TABLE.</font>
class ResolvedDefineTableStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DEFINE_TABLE_STMT;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedDescribeStmt
<a id="ResolvedDescribeStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: DESCRIBE [&lt;object_type&gt;] &lt;name&gt; [FROM &lt;from_name_path&gt;];
//
// &lt;object_type&gt; is an optional string identifier,
//               e.g., &#34;INDEX&#34;, &#34;FUNCTION&#34;, &#34;TYPE&#34;, etc.
// &lt;name_path&gt; is a vector giving the identifier path for the object to be
//             described.
// &lt;from_name_path&gt; is an optional vector giving the identifier path of a
//                    containing object, e.g. a table.</font>
class ResolvedDescribeStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DESCRIBE_STMT;

  const std::string&amp; object_type() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::string&gt;&amp; from_name_path() const;
  int from_name_path_size() const;
  std::string from_name_path(int i) const;
};
</code></pre></p>

### ResolvedShowStmt
<a id="ResolvedShowStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: SHOW &lt;identifier&gt; [FROM &lt;name_path&gt;] [LIKE &lt;like_expr&gt;];
//
// &lt;identifier&gt; is a string that determines the type of objects to be shown,
//              e.g., TABLES, COLUMNS, INDEXES, STATUS,
// &lt;name_path&gt; is an optional path to an object from which &lt;identifier&gt;
//             objects will be shown, e.g., if &lt;identifier&gt; = INDEXES and
//             &lt;name&gt; = table_name, the indexes of &#34;table_name&#34; will be
//             shown,
// &lt;like_expr&gt; is an optional <a href="#ResolvedLiteral">ResolvedLiteral</a> of type string that if present
//             restricts the objects shown to have a name like this string.</font>
class ResolvedShowStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SHOW_STMT;

  const std::string&amp; identifier() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const <a href="#ResolvedLiteral">ResolvedLiteral</a>* like_expr() const;
};
</code></pre></p>

### ResolvedBeginStmt
<a id="ResolvedBeginStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: BEGIN [TRANSACTION] [ &lt;transaction_mode&gt; [, ...] ]
//
// Where transaction_mode is one of:
//      READ ONLY
//      READ WRITE
//      &lt;isolation_level&gt;
//
// &lt;isolation_level&gt; is a string vector storing the identifiers after
//       ISOLATION LEVEL. The strings inside vector could be one of the
//       SQL standard isolation levels:
//
//                   READ UNCOMMITTED
//                   READ COMMITTED
//                   READ REPEATABLE
//                   SERIALIZABLE
//
//       or could be arbitrary strings. ZetaSQL does not validate that
//       the string is valid.</font>
class ResolvedBeginStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_BEGIN_STMT;

  typedef <a href="#ResolvedBeginStmtEnum">ResolvedBeginStmtEnums</a>::ReadWriteMode ReadWriteMode;
  static const ReadWriteMode MODE_UNSPECIFIED = <a href="#ResolvedBeginStmtEnum">ResolvedBeginStmtEnums</a>::MODE_UNSPECIFIED;
  static const ReadWriteMode MODE_READ_ONLY = <a href="#ResolvedBeginStmtEnum">ResolvedBeginStmtEnums</a>::MODE_READ_ONLY;
  static const ReadWriteMode MODE_READ_WRITE = <a href="#ResolvedBeginStmtEnum">ResolvedBeginStmtEnums</a>::MODE_READ_WRITE;

  <a href="#ResolvedBeginStmt">ResolvedBeginStmt</a>::ReadWriteMode read_write_mode() const;

  const std::vector&lt;std::string&gt;&amp; isolation_level_list() const;
  int isolation_level_list_size() const;
  std::string isolation_level_list(int i) const;
};
</code></pre></p>

### ResolvedSetTransactionStmt
<a id="ResolvedSetTransactionStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: SET TRANSACTION &lt;transaction_mode&gt; [, ...]
//
// Where transaction_mode is one of:
//      READ ONLY
//      READ WRITE
//      &lt;isolation_level&gt;
//
// &lt;isolation_level&gt; is a string vector storing the identifiers after
//       ISOLATION LEVEL. The strings inside vector could be one of the
//       SQL standard isolation levels:
//
//                   READ UNCOMMITTED
//                   READ COMMITTED
//                   READ REPEATABLE
//                   SERIALIZABLE
//
//       or could be arbitrary strings. ZetaSQL does not validate that
//       the string is valid.</font>
class ResolvedSetTransactionStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SET_TRANSACTION_STMT;

  typedef <a href="#ResolvedBeginStmt">ResolvedBeginStmt</a>::ReadWriteMode ReadWriteMode;

  <a href="#ResolvedBeginStmt">ResolvedBeginStmt</a>::ReadWriteMode read_write_mode() const;

  const std::vector&lt;std::string&gt;&amp; isolation_level_list() const;
  int isolation_level_list_size() const;
  std::string isolation_level_list(int i) const;
};
</code></pre></p>

### ResolvedCommitStmt
<a id="ResolvedCommitStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: COMMIT [TRANSACTION];</font>
class ResolvedCommitStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_COMMIT_STMT;

};
</code></pre></p>

### ResolvedRollbackStmt
<a id="ResolvedRollbackStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: ROLLBACK [TRANSACTION];</font>
class ResolvedRollbackStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ROLLBACK_STMT;

};
</code></pre></p>

### ResolvedStartBatchStmt
<a id="ResolvedStartBatchStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: START BATCH [&lt;batch_type&gt;];
//
// &lt;batch_type&gt; is an optional string identifier that identifies the type of
//              the batch. (e.g. &#34;DML&#34; or &#34;DDL)</font>
class ResolvedStartBatchStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_START_BATCH_STMT;

  const std::string&amp; batch_type() const;
};
</code></pre></p>

### ResolvedRunBatchStmt
<a id="ResolvedRunBatchStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: RUN BATCH;</font>
class ResolvedRunBatchStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RUN_BATCH_STMT;

};
</code></pre></p>

### ResolvedAbortBatchStmt
<a id="ResolvedAbortBatchStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: ABORT BATCH;</font>
class ResolvedAbortBatchStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ABORT_BATCH_STMT;

};
</code></pre></p>

### ResolvedDropStmt
<a id="ResolvedDropStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: DROP &lt;object_type&gt; [IF EXISTS] &lt;name_path&gt; [&lt;drop_mode&gt;];
//
// &lt;object_type&gt; is an string identifier,
//               e.g., &#34;TABLE&#34;, &#34;VIEW&#34;, &#34;INDEX&#34;, &#34;FUNCTION&#34;, &#34;TYPE&#34;, etc.
// &lt;name_path&gt; is a vector giving the identifier path for the object to be
//             dropped.
// &lt;is_if_exists&gt; silently ignore the &#34;name_path does not exist&#34; error.
// &lt;drop_mode&gt; specifies drop mode RESTRICT/CASCASE, if any.</font>
class ResolvedDropStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_STMT;

  typedef <a href="#ResolvedDropStmtEnum">ResolvedDropStmtEnums</a>::DropMode DropMode;
  static const DropMode DROP_MODE_UNSPECIFIED = <a href="#ResolvedDropStmtEnum">ResolvedDropStmtEnums</a>::DROP_MODE_UNSPECIFIED;
  static const DropMode RESTRICT = <a href="#ResolvedDropStmtEnum">ResolvedDropStmtEnums</a>::RESTRICT;
  static const DropMode CASCADE = <a href="#ResolvedDropStmtEnum">ResolvedDropStmtEnums</a>::CASCADE;

  const std::string&amp; object_type() const;

  bool is_if_exists() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  <a href="#ResolvedDropStmt">ResolvedDropStmt</a>::DropMode drop_mode() const;
};
</code></pre></p>

### ResolvedDropMaterializedViewStmt
<a id="ResolvedDropMaterializedViewStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: DROP MATERIALIZED VIEW [IF EXISTS] &lt;name_path&gt;;
//
// &lt;name_path&gt; is a vector giving the identifier path for the object to be
//             dropped.
// &lt;is_if_exists&gt; silently ignore the &#34;name_path does not exist&#34; error.</font>
class ResolvedDropMaterializedViewStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_MATERIALIZED_VIEW_STMT;

  bool is_if_exists() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;
};
</code></pre></p>

### ResolvedDropSnapshotTableStmt
<a id="ResolvedDropSnapshotTableStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: DROP SNAPSHOT TABLE [IF EXISTS] &lt;name_path&gt;;
//
// &lt;name_path&gt; is a vector giving the identifier path for the object to be
//             dropped.
// &lt;is_if_exists&gt; silently ignore the &#34;name_path does not exist&#34; error.</font>
class ResolvedDropSnapshotTableStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_SNAPSHOT_TABLE_STMT;

  bool is_if_exists() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;
};
</code></pre></p>

### ResolvedRecursiveRefScan
<a id="ResolvedRecursiveRefScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Scan the previous iteration of the recursive alias currently being
// defined, from inside the recursive subquery which defines it. For a
// <a href="#ResolvedRecursiveScan">ResolvedRecursiveScan</a> node, its corresponding <a href="#ResolvedRecursiveRefScan">ResolvedRecursiveRefScan</a>
// appears under its recursive term. The column_list produced here will match
// 1:1 with the column_list produced by the referenced subquery and will be
// given a new unique name to each column produced for this scan.</font>
class ResolvedRecursiveRefScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RECURSIVE_REF_SCAN;

};
</code></pre></p>

### ResolvedRecursionDepthModifier
<a id="ResolvedRecursionDepthModifier"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a recursion depth modifier to recursive CTE or a pipe
// RECURSIVE UNION:
//   WITH DEPTH [ AS &lt;recursion_depth_column&gt; ]
//              [ BETWEEN &lt;lower_bound&gt; AND &lt;upper_bound&gt; ]
//
// &lt;lower_bound&gt; and &lt;upper_bound&gt; represents the range of iterations (both
// side included) whose results are part of CTE&#39;s final output.
//
// lower_bound and upper_bound are two integer literals or
// query parameters. Query parameter values must be checked at run-time by
// ZetaSQL compliant backend systems.
// - both lower/upper_bound must be non-negative;
// - lower_bound is by default zero if unspecified;
// - upper_bound is by default infinity if unspecified;
// - lower_bound must be smaller or equal than upper_bound;
//
// &lt;recursion_depth_column&gt; is the column that represents the
// recursion depth semantics: the iteration number that outputs this row;
// it is part of <a href="#ResolvedRecursiveScan">ResolvedRecursiveScan</a>&#39;s column list when specified, but
// there is no corresponding column in the inputs of Recursive query.
//
// See (broken link):explicit-recursion-depth for details.</font>
class ResolvedRecursionDepthModifier : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RECURSION_DEPTH_MODIFIER;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* lower_bound() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* upper_bound() const;

  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* recursion_depth_column() const;
};
</code></pre></p>

### ResolvedRecursiveScan
<a id="ResolvedRecursiveScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// A recursive query inside a WITH RECURSIVE, RECURSIVE VIEW, or a pipe
// RECURSIVE UNION.
//
// Recursive queries must satisfy one of the following forms:
//   (1) &lt;non-recursive-term&gt; [|&gt; ]UNION [ALL|DISTINCT] &lt;recursive-term&gt;
//   (2) &lt;non-recursive-term&gt; |&gt; RECURSIVE UNION [ALL|DISTINCT]
//       &lt;recursive-term&gt;
//
// where self-references to table being defined are allowed only in the
// &lt;recursive-term&gt; section.
//
// &lt;column_list&gt; is a set of new <a href="#ResolvedColumn">ResolvedColumns</a> created by this scan.
// Each input <a href="#ResolvedSetOperationItem">ResolvedSetOperationItem</a> has an &lt;output_column_list&gt; which
// matches 1:1 with &lt;column_list&gt; and specifies how the input &lt;scan&gt;&#39;s
// columns map into the final &lt;column_list&gt;.
//
// At runtime, a recursive scan is evaluated using an iterative process:
//
// Step 1 (iteration 0): Evaluate the non-recursive term. If UNION DISTINCT
//   is specified, discard duplicates.
//
// Step 2 (iteration k):
//   Repeat until step 2 produces an empty result:
//     Evaluate the recursive term, binding the recursive table to the
//     new rows produced by previous step (iteration k-1).
//     If UNION DISTINCT is specified, discard duplicate rows, as well as any
//     rows which match any previously-produced result.
//
// Step 3:
//   The final content of the recursive table is the UNION ALL of all results
//   produced [lower_bound, upper_bound] iterations specified in the
//   recursion depth modifier. (which are already DISTINCT because of step 2,
//   if the query had UNION DISTINCT). The final content is augmented by the
//   column specified in the recursion depth modifier (if specified) which
//   represents the iteration number that the row is output.
//   If UNION DISTINCT is specified, the depth column represents the first
//   iteration that produces a given row.
//   The depth column will be part of the output column list.
//
// When recursion_depth_modifier is unspecified, the lower bound is
// effectively zero, the upper bound is infinite.
//
// <a href="#ResolvedRecursiveScan">ResolvedRecursiveScan</a> only supports a recursive WITH entry which
//   directly references itself; ZetaSQL does not support mutual recursion
//   between multiple with-clause elements.
//
// See (broken link) and (broken link) for
// details.</font>
class ResolvedRecursiveScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RECURSIVE_SCAN;

  typedef <a href="#ResolvedRecursiveScanEnum">ResolvedRecursiveScanEnums</a>::RecursiveSetOperationType RecursiveSetOperationType;
  static const RecursiveSetOperationType UNION_ALL = <a href="#ResolvedRecursiveScanEnum">ResolvedRecursiveScanEnums</a>::UNION_ALL;
  static const RecursiveSetOperationType UNION_DISTINCT = <a href="#ResolvedRecursiveScanEnum">ResolvedRecursiveScanEnums</a>::UNION_DISTINCT;

  <a href="#ResolvedRecursiveScan">ResolvedRecursiveScan</a>::RecursiveSetOperationType op_type() const;

  const <a href="#ResolvedSetOperationItem">ResolvedSetOperationItem</a>* non_recursive_term() const;

  const <a href="#ResolvedSetOperationItem">ResolvedSetOperationItem</a>* recursive_term() const;

  const <a href="#ResolvedRecursionDepthModifier">ResolvedRecursionDepthModifier</a>* recursion_depth_modifier() const;
};
</code></pre></p>

### ResolvedWithScan
<a id="ResolvedWithScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a SQL WITH query (or subquery) like
//   WITH [RECURSIVE] &lt;with_query_name1&gt; AS (&lt;with_subquery1&gt;),
//        &lt;with_query_name2&gt; AS (&lt;with_subquery2&gt;)
//   &lt;query&gt;;
//
// WITH entries are sorted in dependency order so that an entry can only
// reference entries earlier in &lt;with_entry_list&gt;, plus itself if the
// RECURSIVE keyword is used. If the RECURSIVE keyword is not used, this will
// be the same order as in the original query, since an entry which
// references itself or any entry later in the list is not allowed.
//
// If a WITH subquery is referenced multiple times, the full query should
// behave as if the subquery runs only once and its result is reused.
//
// There will be one <a href="#ResolvedWithEntry">ResolvedWithEntry</a> here for each subquery in the SQL
// WITH statement, in the same order as in the query.
//
// Inside the resolved &lt;query&gt;, or any &lt;with_entry_list&gt; occurring after
// its definition, a &lt;with_query_name&gt; used as a table scan will be
// represented using a <a href="#ResolvedWithRefScan">ResolvedWithRefScan</a>.
//
// The &lt;with_query_name&gt; aliases are always unique within a query, and should
// be used to connect the <a href="#ResolvedWithRefScan">ResolvedWithRefScan</a> to the original query
// definition.  The subqueries are not inlined and duplicated into the tree.
//
// In ZetaSQL 1.0, WITH is allowed only on the outermost query and not in
// subqueries, so the <a href="#ResolvedWithScan">ResolvedWithScan</a> node can only occur as the outermost
// scan in a statement (e.g. a QueryStmt or CreateTableAsSelectStmt).
//
// In ZetaSQL 1.1 (language option FEATURE_WITH_ON_SUBQUERY), WITH
// is allowed on subqueries.  Then, <a href="#ResolvedWithScan">ResolvedWithScan</a> can occur anywhere in
// the tree.  The alias introduced by a <a href="#ResolvedWithEntry">ResolvedWithEntry</a> is visible only
// in subsequent <a href="#ResolvedWithEntry">ResolvedWithEntry</a> queries and in &lt;query&gt;.  The aliases used
// must be globally unique in the resolved AST however, so consumers do not
// need to implement any scoping for these names.  Because the aliases are
// unique, it is legal to collect all <a href="#ResolvedWithEntry">ResolvedWithEntries</a> in the tree and
// treat them as if they were a single WITH clause at the outermost level.
//
// In ZetaSQL 1.3 (language option FEATURE_WITH_RECURSIVE), WITH
// RECURSIVE is supported, which allows any &lt;with_subquery&gt; to reference
// any &lt;with_query_name&gt;, regardless of order, including WITH entries which
// reference themself. Circular dependency chains of WITH entries are allowed
// only for direct self-references, and only when the corresponding
// &lt;with_subquery&gt; takes the form &#34;&lt;non-recursive-term&gt; UNION [ALL|DISTINCT]
// &lt;recursive-term&gt;&#34;, with all references to the current &lt;with_query_name&gt;
// confined to the recursive term.
//
// The subqueries inside <a href="#ResolvedWithEntry">ResolvedWithEntries</a> cannot be correlated.
//
// If a WITH subquery is defined but never referenced, it will still be
// resolved and still show up here.  Query engines may choose not to run it.</font>
class ResolvedWithScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WITH_SCAN;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedWithEntry">ResolvedWithEntry</a>&gt;&gt;&amp; with_entry_list() const;
  int with_entry_list_size() const;
  const <a href="#ResolvedWithEntry">ResolvedWithEntry</a>* with_entry_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;

<font color="brown">  // True if the WITH clause uses the recursive keyword.</font>
  bool recursive() const;
};
</code></pre></p>

### ResolvedWithEntry
<a id="ResolvedWithEntry"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents one aliased subquery introduced in a WITH clause.
//
// The &lt;with_query_name&gt;s must be globally unique in the full resolved AST.
// The &lt;with_subquery&gt; cannot be correlated and cannot reference any
// columns from outside.  It may reference other WITH subqueries.
//
// See <a href="#ResolvedWithScan">ResolvedWithScan</a> for full details.</font>
class ResolvedWithEntry : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WITH_ENTRY;

  const std::string&amp; with_query_name() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* with_subquery() const;
};
</code></pre></p>

### ResolvedOption
<a id="ResolvedOption"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents one SQL hint or option key/value pair.
// The SQL syntax @{ key1=value1, key2=value2, some_db.key3=value3 }
// will expand to three <a href="#ResolvedOption">ResolvedOptions</a>.  Keyword hints (e.g. LOOKUP JOIN)
// are interpreted as shorthand, and will be expanded to a <a href="#ResolvedOption">ResolvedOption</a>
// attached to the appropriate node before any explicit long-form hints.
//
// <a href="#ResolvedOption">ResolvedOptions</a> are attached to the <a href="#ResolvedScan">ResolvedScan</a> corresponding to the
// operator that the SQL hint was associated with.
// See (broken link) for more detail.
// Hint semantics are implementation defined.
//
// Each hint or option is resolved as a [&lt;qualifier&gt;.]&lt;name&gt;:=&lt;value&gt; pair.
//   &lt;qualifier&gt; will be empty if no qualifier was present.
//   &lt;name&gt; is always non-empty.
//   &lt;value&gt; can be a <a href="#ResolvedLiteral">ResolvedLiteral</a> or a <a href="#ResolvedParameter">ResolvedParameter</a>,
//           a cast of a <a href="#ResolvedParameter">ResolvedParameter</a> (for typed hints only),
//           or a general expression (on constant inputs).
//   &lt;assignment_op&gt; is an enum that indicates the assignment operation for
//                   array type options.
//
// If AllowedHintsAndOptions was set in AnalyzerOptions, and this hint or
// option was included there and had an expected type, the type of &lt;value&gt;
// will match that expected type. For assignment_op that&#39;s not the default
// value, also checks whether the expected type is Array and whether
// allow_alter_array is true. Unknown hints and options(not listed in
// AllowedHintsAndOptions) are not stripped and will still show up here.
//
// If non-empty, &lt;qualifier&gt; should be interpreted as a target system name,
// and a database system should ignore any hints targeted to different
// systems.
//
// &lt;qualifier&gt; is set only for hints, and will always be empty in options
// lists.
//
// &lt;assignment_op&gt; will always be DEFAULT_ASSIGN (i.e. &#34;=&#34;) for hints, and
//                 defaults to the same value for options. Can be set to
//                 ADD_ASSIGN (&#34;+=&#34;) and SUB_ASSIGN (&#34;-=&#34;) for options with
//                 Array type.
//
// The SQL syntax allows using an identifier as a hint value.
// Such values are stored here as <a href="#ResolvedLiteral">ResolvedLiterals</a> with string type.</font>
class ResolvedOption : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_OPTION;

  typedef <a href="#ResolvedOptionEnum">ResolvedOptionEnums</a>::AssignmentOp AssignmentOp;
  static const AssignmentOp DEFAULT_ASSIGN = <a href="#ResolvedOptionEnum">ResolvedOptionEnums</a>::DEFAULT_ASSIGN;
  static const AssignmentOp ADD_ASSIGN = <a href="#ResolvedOptionEnum">ResolvedOptionEnums</a>::ADD_ASSIGN;
  static const AssignmentOp SUB_ASSIGN = <a href="#ResolvedOptionEnum">ResolvedOptionEnums</a>::SUB_ASSIGN;

  const std::string&amp; qualifier() const;

  const std::string&amp; name() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* value() const;

  <a href="#ResolvedOption">ResolvedOption</a>::AssignmentOp assignment_op() const;
};
</code></pre></p>

### ResolvedWindowPartitioning
<a id="ResolvedWindowPartitioning"></a>

<p><pre><code class="lang-c++"><font color="brown">// Window partitioning specification for an analytic function call.
//
// PARTITION BY keys in &lt;partition_by_list&gt;.
//
// &lt;collation_list&gt; is either empty to indicate that all the elements in
// &lt;partition_by_list&gt; have the default collation, or &lt;collation_list&gt; has
// the same number of elements as &lt;partition_by_list&gt;.  Each element is the
// collation for the element in &lt;partition_by_list&gt; with the same index, or
// can be empty to indicate default collation or when the type is not
// collatable. &lt;collation_list&gt; is only set when
// FEATURE_COLLATION_SUPPORT is enabled.
// See (broken link).</font>
class ResolvedWindowPartitioning : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WINDOW_PARTITIONING;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; partition_by_list() const;
  int partition_by_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* partition_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; hint_list() const;
  int hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* hint_list(int i) const;

  const std::vector&lt;<a href="#ResolvedCollation">ResolvedCollation</a>&gt;&amp; collation_list() const;
  int collation_list_size() const;
  <a href="#ResolvedCollation">ResolvedCollation</a> collation_list(int i) const;
};
</code></pre></p>

### ResolvedWindowOrdering
<a id="ResolvedWindowOrdering"></a>

<p><pre><code class="lang-c++"><font color="brown">// Window ordering specification for an analytic function call.
//
// ORDER BY items in &lt;order_by_list&gt;. There should be exactly one ORDER
// BY item if this is a window ORDER BY for a RANGE-based window.</font>
class ResolvedWindowOrdering : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WINDOW_ORDERING;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>&gt;&gt;&amp; order_by_item_list() const;
  int order_by_item_list_size() const;
  const <a href="#ResolvedOrderByItem">ResolvedOrderByItem</a>* order_by_item_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; hint_list() const;
  int hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* hint_list(int i) const;
};
</code></pre></p>

### ResolvedWindowFrame
<a id="ResolvedWindowFrame"></a>

<p><pre><code class="lang-c++"><font color="brown">// Window framing specification for an analytic function call.
//
// ROW-based window frames compute the frame based on physical offsets
// from the current row.
// RANGE-based window frames compute the frame based on a logical
// range of rows around the current row based on the current row&#39;s
// ORDER BY key value.
//
// &lt;start_expr&gt; and &lt;end_expr&gt; cannot be NULL. If the window frame
// is one-sided in the input query, the resolver will generate an
// implicit ending boundary.</font>
class ResolvedWindowFrame : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WINDOW_FRAME;

  typedef <a href="#ResolvedWindowFrameEnum">ResolvedWindowFrameEnums</a>::FrameUnit FrameUnit;
  static const FrameUnit ROWS = <a href="#ResolvedWindowFrameEnum">ResolvedWindowFrameEnums</a>::ROWS;
  static const FrameUnit RANGE = <a href="#ResolvedWindowFrameEnum">ResolvedWindowFrameEnums</a>::RANGE;

  std::string GetFrameUnitString() const;
  static std::string FrameUnitToString(FrameUnit frame_unit);

  <a href="#ResolvedWindowFrame">ResolvedWindowFrame</a>::FrameUnit frame_unit() const;

  const <a href="#ResolvedWindowFrameExpr">ResolvedWindowFrameExpr</a>* start_expr() const;

  const <a href="#ResolvedWindowFrameExpr">ResolvedWindowFrameExpr</a>* end_expr() const;
};
</code></pre></p>

### ResolvedAnalyticFunctionGroup
<a id="ResolvedAnalyticFunctionGroup"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a group of analytic function calls that shares PARTITION
// BY and ORDER BY.
//
// &lt;partition_by&gt; can be NULL. &lt;order_by&gt; may be NULL depending on the
// functions in &lt;analytic_function_list&gt; and the window frame unit. See
// (broken link) for more details.
//
// All expressions in &lt;analytic_function_list&gt; have a
// <a href="#ResolvedAnalyticFunctionCall">ResolvedAnalyticFunctionCall</a> with a function in mode
// Function::AGGREGATE or Function::ANALYTIC.</font>
class ResolvedAnalyticFunctionGroup : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ANALYTIC_FUNCTION_GROUP;

  const <a href="#ResolvedWindowPartitioning">ResolvedWindowPartitioning</a>* partition_by() const;

  const <a href="#ResolvedWindowOrdering">ResolvedWindowOrdering</a>* order_by() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumnBase">ResolvedComputedColumnBase</a>&gt;&gt;&amp; analytic_function_list() const;
  int analytic_function_list_size() const;
  const <a href="#ResolvedComputedColumnBase">ResolvedComputedColumnBase</a>* analytic_function_list(int i) const;
};
</code></pre></p>

### ResolvedWindowFrameExpr
<a id="ResolvedWindowFrameExpr"></a>

<p><pre><code class="lang-c++"><font color="brown">// Window frame boundary expression that determines the first/last row of
// the moving window for each tuple.
//
// &lt;expression&gt; cannot be NULL if the type is OFFSET_PRECEDING
// or OFFSET_FOLLOWING. It must be a constant expression. If this is a
// boundary for a ROW-based window, it must be integer type. Otherwise,
// it must be numeric type and must match exactly the type of the window
// ordering expression.  See (broken link) for more
// details.</font>
class ResolvedWindowFrameExpr : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_WINDOW_FRAME_EXPR;

  typedef <a href="#ResolvedWindowFrameExprEnum">ResolvedWindowFrameExprEnums</a>::BoundaryType BoundaryType;
  static const BoundaryType UNBOUNDED_PRECEDING = <a href="#ResolvedWindowFrameExprEnum">ResolvedWindowFrameExprEnums</a>::UNBOUNDED_PRECEDING;
  static const BoundaryType OFFSET_PRECEDING = <a href="#ResolvedWindowFrameExprEnum">ResolvedWindowFrameExprEnums</a>::OFFSET_PRECEDING;
  static const BoundaryType CURRENT_ROW = <a href="#ResolvedWindowFrameExprEnum">ResolvedWindowFrameExprEnums</a>::CURRENT_ROW;
  static const BoundaryType OFFSET_FOLLOWING = <a href="#ResolvedWindowFrameExprEnum">ResolvedWindowFrameExprEnums</a>::OFFSET_FOLLOWING;
  static const BoundaryType UNBOUNDED_FOLLOWING = <a href="#ResolvedWindowFrameExprEnum">ResolvedWindowFrameExprEnums</a>::UNBOUNDED_FOLLOWING;

  std::string GetBoundaryTypeString() const;
  static std::string BoundaryTypeToString(BoundaryType boundary_type);

  <a href="#ResolvedWindowFrameExpr">ResolvedWindowFrameExpr</a>::BoundaryType boundary_type() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expression() const;
};
</code></pre></p>

### ResolvedDMLValue
<a id="ResolvedDMLValue"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a value inside an INSERT or UPDATE statement.
//
// The &lt;value&gt; is either an expression or a DMLDefault.
//
// For proto fields, NULL values mean the field should be cleared.</font>
class ResolvedDMLValue : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DMLVALUE;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* value() const;
};
</code></pre></p>

### ResolvedDMLDefault
<a id="ResolvedDMLDefault"></a>

<p><pre><code class="lang-c++"><font color="brown">// This is used to represent the value DEFAULT that shows up (in place of a
// value expression) in INSERT and UPDATE statements.
// For columns, engines should substitute the engine-defined default value
// for that column, or give an error.
// For proto fields, this always means to clear the field.
// This will never show up inside expressions other than <a href="#ResolvedDMLValue">ResolvedDMLValue</a>.</font>
class ResolvedDMLDefault : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DMLDEFAULT;

};
</code></pre></p>

### ResolvedAssertStmt
<a id="ResolvedAssertStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the ASSERT statement:
//   ASSERT &lt;expression&gt; [AS &lt;description&gt;];
//
// &lt;expression&gt; is any expression that returns a bool.
// &lt;description&gt; is an optional string literal used to give a more
// descriptive error message in case the ASSERT fails.</font>
class ResolvedAssertStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ASSERT_STMT;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expression() const;

  const std::string&amp; description() const;
};
</code></pre></p>

### ResolvedAssertRowsModified
<a id="ResolvedAssertRowsModified"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the ASSERT ROWS MODIFIED clause on a DML statement.
// The value must be a literal or (possibly casted) parameter int64.
//
// The statement should fail if the number of rows updated does not
// exactly match this number.</font>
class ResolvedAssertRowsModified : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ASSERT_ROWS_MODIFIED;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* rows() const;
};
</code></pre></p>

### ResolvedOnConflictClause
<a id="ResolvedOnConflictClause"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the ON CONFLICT clause on an INSERT statement. It
// specifies the alternate action to be taken if the insert row causes
// unique constraint violations.
//
// &lt;conflict_action&gt; is the action to take if the insert row causes unique
// constraint violations. Either NOTHING to ignore the insert row or UPDATE
// to update the original table row with the constraint values.
//
// &lt;conflict_target_column_list&gt; is the list of columns to infer a unique
// constraint - primary key or UNIQUE columns - for which the uniqueness
// should be arbitrated. ZetaSQL only resolves them into valid column
// references. It is the engine&#39;s responsibility to validate and infer
// a unique constraint. See &#34;Conflict target&#34; section in
// (broken link), http://shortn/_4GrUbFPEKm
//
// &lt;unique_constraint_name&gt; is the name of the UNIQUE constraint instead of
// specifying the columns in conflict target. ZetaSQL only resolves it as
// a valid identifier. It is the engine&#39;s responsibility to infer a UNIQUE
// constraint. See &#34;Conflict target&#34; section in
// (broken link). http://shortn/_4GrUbFPEKm
//
// &lt;insert_row_scan&gt; is a <a href="#ResolvedTableScan">ResolvedTableScan</a> on the target table. It returns
// the new rows that were constructed to be inserted where the insert failed
// with a conflict, using the underlying Table&#39;s columns.
// The included columns are the columns from insert row referenced
// in the update SET RHS expression and/or the update WHERE clause using
// the `excluded` alias. It can also include generated columns or columns not
// in the INSERT column list.
// This is applicable only for conflict action UPDATE. It&#39;s null if the
// conflict action is NOTHING.
//
// &lt;update_item_list&gt; is the list of update items if the conflict action is
// UPDATE. They are refer columns in both the insert row and original table
// row.
//
// &lt;update_where_expression&gt; is used to conditionally update the table row if
// the conflict action is UPDATE.</font>
class ResolvedOnConflictClause : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ON_CONFLICT_CLAUSE;

  typedef <a href="#ResolvedOnConflictClauseEnum">ResolvedOnConflictClauseEnums</a>::ConflictAction ConflictAction;
  static const ConflictAction NOTHING = <a href="#ResolvedOnConflictClauseEnum">ResolvedOnConflictClauseEnums</a>::NOTHING;
  static const ConflictAction UPDATE = <a href="#ResolvedOnConflictClauseEnum">ResolvedOnConflictClauseEnums</a>::UPDATE;

  std::string GetConflictActionString() const;
  static std::string ConflictActionToString(ConflictAction action);

  <a href="#ResolvedOnConflictClause">ResolvedOnConflictClause</a>::ConflictAction conflict_action() const;

<font color="brown">  // IGNORABLE_DEFAULT because this is an optional field for NOTHING
  // conflict action. It is also empty if unique constraint name
  // is specified.</font>
  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; conflict_target_column_list() const;
  int conflict_target_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> conflict_target_column_list(int i) const;

<font color="brown">  // IGNORABLE_DEFAULT because this is an optional field for NOTHING
  // conflict action. It is also empty if conflict target is specified.</font>
  const std::string&amp; unique_constraint_name() const;

<font color="brown">  // IGNORABLE_DEFAULT because this is set for UPDATE conflict action
  // only and if update_item_list and/or update_where_expression
  // reference columns from the insert row using `excluded` alias.</font>
  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* insert_row_scan() const;

<font color="brown">  // IGNORABLE_DEFAULT because this is set for UPDATE conflict action
  // only.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>&gt;&gt;&amp; update_item_list() const;
  int update_item_list_size() const;
  const <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>* update_item_list(int i) const;

<font color="brown">  // IGNORABLE_DEFAULT because this is set for UPDATE conflict action
  // only.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* update_where_expression() const;
};
</code></pre></p>

### ResolvedInsertRow
<a id="ResolvedInsertRow"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents one row in the VALUES clause of an INSERT.</font>
class ResolvedInsertRow : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_INSERT_ROW;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedDMLValue">ResolvedDMLValue</a>&gt;&gt;&amp; value_list() const;
  int value_list_size() const;
  const <a href="#ResolvedDMLValue">ResolvedDMLValue</a>* value_list(int i) const;
};
</code></pre></p>

### ResolvedInsertStmt
<a id="ResolvedInsertStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents an INSERT statement, or a nested INSERT inside an
// UPDATE statement.
//
// It&#39;s also used for the pipe operator
//   |&gt; INSERT INTO table ...
// which supports all the same optional modifier fields, but cannot include a
// query or VALUES.  This occurs inside <a href="#ResolvedPipeInsertScan">ResolvedPipeInsertScan</a>, with the
// pipe input stored in `query`.
//
// For top-level INSERT statements, &lt;table_scan&gt; gives the table to
// scan and creates <a href="#ResolvedColumn">ResolvedColumns</a> for its columns.  Those columns can be
// referenced in &lt;insert_column_list&gt;.
//
// For nested INSERTS, there is no &lt;table_scan&gt; or &lt;insert_column_list&gt;.
// There is implicitly a single column to insert, and its type is the
// element type of the array being updated in the <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>
// containing this statement.
//
// For nested INSERTs, alternate modes are not supported and &lt;insert_mode&gt;
// will always be set to OR_ERROR.
//
// The rows to insert come from &lt;row_list&gt; or the result of &lt;query&gt;.
// Exactly one of these must be present.
//
// If &lt;row_list&gt; is present, the columns in the row_list match
// positionally with &lt;insert_column_list&gt;.
//
// If &lt;query&gt; is present, &lt;query_output_column_list&gt; must also be present.
// &lt;query_output_column_list&gt; is the list of output columns produced by
// &lt;query&gt; that correspond positionally with the target &lt;insert_column_list&gt;
// on the output table.  For nested INSERTs with no &lt;insert_column_list&gt;,
// &lt;query_output_column_list&gt; must have exactly one column.
//
// &lt;query_parameter_list&gt; is set for nested INSERTs where &lt;query&gt; is set and
// references non-target values (columns or field values) from the table. It
// is only set when FEATURE_CORRELATED_REFS_IN_NESTED_DML is enabled.
//
// If &lt;returning&gt; is present, the INSERT statement will return newly inserted
// rows. &lt;returning&gt; can only occur on top-level statements.
//
// The returning clause has a &lt;output_column_list&gt; to represent the data
// sent back to clients. It can only access columns from the &lt;table_scan&gt;.
//
// &lt;topologically_sorted_generated_column_id_list&gt; is set for queries to
// tables having generated columns. It provides the resolved column ids of
// the generated columns in topological order, which the computed generated
// column expressions can be computed in.
//
// &lt;generated_expr_list&gt; has generated expressions for the corresponding
// generated column in the topologically_sorted_generated_column_id_list.
// Hence, these lists have the same size.
//
// &lt;column_access_list&gt; indicates for each column in &lt;table_scan.column_list&gt;
// whether it was read and/or written. The query engine may also require
// read or write permissions across all columns, including unreferenced
// columns, depending on the operation.
//
// &lt;on_conflict_clause&gt; specifies the alternate action if the insert row
// causes unique constraint violations. It handles violations in both primary
// key and UNIQUE constraints. Alternate actions are (1) to do nothing
// (ignore the insert row), or (2) update the original table row using the
// specified SET clauses and the optional WHERE clause.</font>
class ResolvedInsertStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_INSERT_STMT;

  typedef <a href="#ResolvedInsertStmtEnum">ResolvedInsertStmtEnums</a>::InsertMode InsertMode;
  static const InsertMode OR_ERROR = <a href="#ResolvedInsertStmtEnum">ResolvedInsertStmtEnums</a>::OR_ERROR;
  static const InsertMode OR_IGNORE = <a href="#ResolvedInsertStmtEnum">ResolvedInsertStmtEnums</a>::OR_IGNORE;
  static const InsertMode OR_REPLACE = <a href="#ResolvedInsertStmtEnum">ResolvedInsertStmtEnums</a>::OR_REPLACE;
  static const InsertMode OR_UPDATE = <a href="#ResolvedInsertStmtEnum">ResolvedInsertStmtEnums</a>::OR_UPDATE;

  std::string GetInsertModeString() const;
  static std::string InsertModeToString(InsertMode boundary_type);

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

<font color="brown">  // Behavior on duplicate rows (normally defined to mean duplicate
  // primary keys).</font>
  <a href="#ResolvedInsertStmt">ResolvedInsertStmt</a>::InsertMode insert_mode() const;

  const <a href="#ResolvedAssertRowsModified">ResolvedAssertRowsModified</a>* assert_rows_modified() const;

  const <a href="#ResolvedReturningClause">ResolvedReturningClause</a>* returning() const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; insert_column_list() const;
  int insert_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> insert_column_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; query_parameter_list() const;
  int query_parameter_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* query_parameter_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; query_output_column_list() const;
  int query_output_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> query_output_column_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedInsertRow">ResolvedInsertRow</a>&gt;&gt;&amp; row_list() const;
  int row_list_size() const;
  const <a href="#ResolvedInsertRow">ResolvedInsertRow</a>* row_list(int i) const;

  const std::vector&lt;<a href="#ResolvedStatement">ResolvedStatement</a>::ObjectAccess&gt;&amp; column_access_list() const;
  int column_access_list_size() const;
  <a href="#ResolvedStatement">ResolvedStatement</a>::ObjectAccess column_access_list(int i) const;

  const <a href="#ResolvedOnConflictClause">ResolvedOnConflictClause</a>* on_conflict_clause() const;

<font color="brown">  // This returns a topologically sorted list of generated columns
  //  resolved ids in the table accessed by insert statement.
  //  For example for below table
  //  CREATE TABLE T(
  //  k1 INT64 NOT NULL,
  //  data INT64,
  //  gen1 INT64 AS data+1,
  //  gen2 INT64 AS gen1*2,
  //  gen3 INT64 AS data*2 + gen1,
  //  ) PRIMARY KEY(k1);
  // data-------------------&gt;gen1---------------------&gt;gen2
  //   *                      *----------&gt; *
  //   *  -------------------------------&gt;gen3
  // the vector would have corresponding indexes of one of these values
  // gen1 gen2 gen3 OR gen1 gen3 gen2.</font>
  const std::vector&lt;int&gt;&amp; topologically_sorted_generated_column_id_list() const;
  int topologically_sorted_generated_column_id_list_size() const;
  int topologically_sorted_generated_column_id_list(int i) const;

<font color="brown">  // This field returns the vector of generated column expressions
  // corresponding to the column ids in
  // topologically_sorted_generated_column_id_list. Both the lists have
  // the same size and 1-to-1 mapping for the column id with its
  // corresponding expression. This field is not directly accessed
  // from the catalog since these expressions are rewritten to replace
  // the <a href="#ResolvedExpressionColumn">ResolvedExpressionColumn</a> for the referred columns in the
  // catalog to corresponding <a href="#ResolvedColumnRef">ResolvedColumnRef</a>.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; generated_column_expr_list() const;
  int generated_column_expr_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* generated_column_expr_list(int i) const;
};
</code></pre></p>

### ResolvedDeleteStmt
<a id="ResolvedDeleteStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a DELETE statement or a nested DELETE inside an
// UPDATE statement.
//
// For top-level DELETE statements, &lt;table_scan&gt; gives the table to
// scan and creates <a href="#ResolvedColumn">ResolvedColumns</a> for its columns.  Those columns can
// be referenced inside the &lt;where_expr&gt;.
//
// For nested DELETEs, there is no &lt;table_scan&gt;.  The &lt;where_expr&gt; can
// only reference:
//   (1) the element_column from the <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a> containing this
//       statement,
//   (2) columns from the outer statements, and
//   (3) (optionally) &lt;array_offset_column&gt;, which represents the 0-based
//       offset of the array element being modified.
//
// &lt;where_expr&gt; is required.
//
// If &lt;returning&gt; is present, the DELETE statement will return deleted rows
// back. It can only occur on top-level statements.
//
// This returning clause has a &lt;output_column_list&gt; to represent the data
// sent back to clients. It can only access columns from the &lt;table_scan&gt;.
//
// &lt;column_access_list&gt; indicates for each column in &lt;table_scan.column_list&gt;
// whether it was read and/or written. The query engine may also require
// read or write permissions across all columns, including unreferenced
// columns, depending on the operation.</font>
class ResolvedDeleteStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DELETE_STMT;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

  const <a href="#ResolvedAssertRowsModified">ResolvedAssertRowsModified</a>* assert_rows_modified() const;

  const <a href="#ResolvedReturningClause">ResolvedReturningClause</a>* returning() const;

  const std::vector&lt;<a href="#ResolvedStatement">ResolvedStatement</a>::ObjectAccess&gt;&amp; column_access_list() const;
  int column_access_list_size() const;
  <a href="#ResolvedStatement">ResolvedStatement</a>::ObjectAccess column_access_list(int i) const;

  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* array_offset_column() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* where_expr() const;
};
</code></pre></p>

### ResolvedUpdateItem
<a id="ResolvedUpdateItem"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents one item inside the SET clause of an UPDATE.
//
// The entity being updated is specified by &lt;target&gt;.
//
// For a regular
//   SET {target} = {expression} | DEFAULT
// clause (not including an array element update like SET a[OFFSET(0)] = 5),
// &lt;target&gt; and &lt;set_value&gt; will be present, and all other fields will be
// unset.
//
// For an update to a container element via a subscript expression (e.g.
// `SET a.b[&lt;expr&gt;].c = &lt;value&gt;`),
//   - &lt;target&gt; is set to the container itself (e.g. `a.b`),
//   - &lt;element_column&gt; is a new <a href="#ResolvedColumn">ResolvedColumn</a> referring to the element of
//     the container (e.g. the element at `a.b[&lt;expr&gt;]`). This is used inside
//     the update items to refer to the element.
//   - &lt;update_item_element_list&gt; will have an `UpdateItemElement` node
//     corresponding to the subscript expression and the modification to that
//     element.
// For example, for SET a.b[&lt;expr&gt;].c = &lt;value&gt;, we have
//    <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>
//    +-&lt;target&gt; = a.b
//    +-&lt;element_column&gt; = &lt;x&gt;
//    +-&lt;update_item_element_list&gt;
//      +-<a href="#ResolvedUpdateItemElement">ResolvedUpdateItemElement</a>
//        +-&lt;subscript&gt; = &lt;expr&gt;
//        +-&lt;update_item&gt; = <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>
//          +-&lt;target&gt; = &lt;x&gt;.c
//          +-&lt;set_value&gt; = &lt;value&gt;
//
// The engine is required to fail the update if there are two elements of
// &lt;update_item_element_list&gt; corresponding to subscript expressions that
// evaluate to the same value. These are considered to be conflicting
// updates.
//
// Multiple updates to the same container are always represented as multiple
// elements of &lt;update_item_element_list&gt; under a single <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>
// corresponding to that container. E.g., for
// `SET a[&lt;expr1&gt;].b[&lt;expr2&gt;] = 5, a[&lt;expr3&gt;].b[&lt;expr4&gt;] = 6`, we will have:
//     <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>
//     +-&lt;target&gt; = a
//     +-&lt;element_column&gt; = x
//     +-&lt;update_item_element_list&gt;
//       +-<a href="#ResolvedUpdateItemElement">ResolvedUpdateItemElement</a>
//         +-&lt;subscript&gt; = &lt;expr1&gt;
//         +-<a href="#ResolvedUpdateItem">ResolvedUpdateItem</a> for &lt;x&gt;.b[&lt;expr2&gt;] = 5
//       +-<a href="#ResolvedUpdateItemElement">ResolvedUpdateItemElement</a>
//         +-&lt;subscript&gt; = &lt;expr3&gt;
//         +-<a href="#ResolvedUpdateItem">ResolvedUpdateItem</a> for &lt;x&gt;.b[&lt;expr4&gt;] = 6
// The engine must give a runtime error if &lt;expr1&gt; and &lt;expr3&gt; evaluate to
// the same thing. Notably, it does not have to determine whether the
// two <a href="#ResolvedUpdateItem">ResolvedUpdateItems</a> corresponding to &#34;b&#34; refer to the same location
// iff &lt;expr1&gt; and &lt;expr3&gt; evaluate to the same thing.
//
// TODO: Consider allowing the engine to execute an update like
// SET a[&lt;expr1&gt;].b = 1, a[&lt;expr2&gt;].c = 2 even if &lt;expr1&gt; == &lt;expr2&gt; since
// &#34;b&#34; and &#34;c&#34; do not overlap. Also consider allowing a more complex example
// like SET a[&lt;expr1&gt;].b[&lt;expr2&gt;] = ...,
// a[&lt;expr3&gt;].b[&lt;expr4&gt;].c[&lt;expr5&gt;] = ... even if &lt;expr1&gt; == &lt;expr3&gt;, as long
// as &lt;expr2&gt; != &lt;expr4&gt; in that case.
//
// For nested DML, &lt;target&gt; and &lt;element_column&gt; will both be set, and one or
// more of the nested statement lists will be non-empty. &lt;target&gt; must be a
// subscriptable type, and &lt;element_column&gt; introduces a <a href="#ResolvedColumn">ResolvedColumn</a>
// representing the subscripted elements. The list nodes referring to nested
// DML statements will always be empty in a <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a> child of a
// <a href="#ResolvedUpdateItemElement">ResolvedUpdateItemElement</a> node.
//
// See (broken link) for more detail.</font>
class ResolvedUpdateItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UPDATE_ITEM;

<font color="brown">  // The target entity to be updated.
  //
  // This is an expression evaluated using the <a href="#ResolvedColumn">ResolvedColumns</a> visible
  // inside this statement.  This expression can contain only
  // <a href="#ResolvedColumnRef">ResolvedColumnRefs</a>, <a href="#ResolvedGetProtoField">ResolvedGetProtoField</a> and
  // <a href="#ResolvedGetStructField">ResolvedGetStructField</a> nodes.
  //
  // In a top-level UPDATE, the expression always starts with a
  // <a href="#ResolvedColumnRef">ResolvedColumnRef</a> referencing a column from the statement&#39;s
  // TableScan.
  //
  // In a nested UPDATE, the expression always starts with a
  // <a href="#ResolvedColumnRef">ResolvedColumnRef</a> referencing the element_column from the
  // <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a> containing this scan.
  //
  // This node is also used to represent a modification of a single
  // container element (when it occurs as a child of a
  // <a href="#ResolvedUpdateItemElement">ResolvedUpdateItemElement</a> node).  In that case, the expression
  // starts with a <a href="#ResolvedColumnRef">ResolvedColumnRef</a> referencing the &lt;element_column&gt;
  // from its grandparent <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>. (E.g., for &#34;SET a[&lt;expr&gt;]
  // = 5&#34;, the grandparent <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a> has &lt;target&gt; &#34;a&#34;, the
  // parent <a href="#ResolvedUpdateItemElement">ResolvedUpdateItemElement</a> has subscript &lt;expr&gt;, and this
  // node has &lt;set_value&gt; 5 and target corresponding to the
  // grandparent&#39;s &lt;element_column&gt; field.)
  //
  // For either a nested UPDATE or a subscript element modification,
  // there may be a path of field accesses after the initial
  // <a href="#ResolvedColumnRef">ResolvedColumnRef</a>, represented by a chain of GetField nodes.
  //
  // NOTE: We use the same GetField nodes as we do for queries, but
  // they are not treated the same.  Here, they express a path inside
  // an object that is being mutated, so they have reference semantics.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* target() const;

<font color="brown">  // Set the target entity to this value.  The types must match.
  // This can contain the same columns that can appear in the
  // &lt;where_expr&gt; of the enclosing <a href="#ResolvedUpdateStmt">ResolvedUpdateStmt</a>.
  //
  // This is mutually exclusive with all fields below, which are used
  // for nested updates only.</font>
  const <a href="#ResolvedDMLValue">ResolvedDMLValue</a>* set_value() const;

<font color="brown">  // The <a href="#ResolvedColumn">ResolvedColumn</a> introduced to represent the elements of the
  // container type being updated.
  //
  // &lt;target&gt; must be a subscriptable container type, and this column
  // has the type of the subscripted container element.
  //
  // This column can be referenced inside the nested statements below.</font>
  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* element_column() const;

<font color="brown">  // Subscript element modifications to apply. Each item applies to the
  // value of the &lt;element_column&gt; specified by
  // <a href="#ResolvedUpdateItemElement">ResolvedUpdateItemElement</a>.subscript.
  //
  // The engine must fail if two elements in this list have subscript
  // expressions that evaluate to the same value.
  // TODO: Consider generalizing this to allow
  // SET a[&lt;expr1&gt;].b = ..., a[&lt;expr2&gt;].c = ...</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUpdateItemElement">ResolvedUpdateItemElement</a>&gt;&gt;&amp; update_item_element_list() const;
  int update_item_element_list_size() const;
  const <a href="#ResolvedUpdateItemElement">ResolvedUpdateItemElement</a>* update_item_element_list(int i) const;

<font color="brown">  // Nested DELETE statements to apply.  Each delete runs on one value
  // of &lt;element_column&gt; and may choose to delete that array element.
  //
  // DELETEs are applied before INSERTs or UPDATEs.
  //
  // It is legal for the same input element to match multiple DELETEs.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedDeleteStmt">ResolvedDeleteStmt</a>&gt;&gt;&amp; delete_list() const;
  int delete_list_size() const;
  const <a href="#ResolvedDeleteStmt">ResolvedDeleteStmt</a>* delete_list(int i) const;

<font color="brown">  // Nested UPDATE statements to apply.  Each update runs on one value
  // of &lt;element_column&gt; and may choose to update that array element.
  //
  // UPDATEs are applied after DELETEs and before INSERTs.
  //
  // It is an error if any element is matched by multiple UPDATEs.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUpdateStmt">ResolvedUpdateStmt</a>&gt;&gt;&amp; update_list() const;
  int update_list_size() const;
  const <a href="#ResolvedUpdateStmt">ResolvedUpdateStmt</a>* update_list(int i) const;

<font color="brown">  // Nested INSERT statements to apply.  Each insert will produce zero
  // or more values for &lt;element_column&gt;.
  //
  // INSERTs are applied after DELETEs and UPDATEs.
  //
  // For nested UPDATEs, insert_mode will always be the default, and
  // has no effect.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedInsertStmt">ResolvedInsertStmt</a>&gt;&gt;&amp; insert_list() const;
  int insert_list_size() const;
  const <a href="#ResolvedInsertStmt">ResolvedInsertStmt</a>* insert_list(int i) const;
};
</code></pre></p>

### ResolvedUpdateItemElement
<a id="ResolvedUpdateItemElement"></a>

<p><pre><code class="lang-c++"><font color="brown">// This node represents the element modification of a container, but does not
// include the container itself. E.g., for `SET container_col[&lt;expr&gt;] = 5`,
// this node represents a modification of &#34;= 5&#34; on the element at subscript
// &lt;expr&gt;. The container `container_col` is defined by the parent node.</font>
class ResolvedUpdateItemElement : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UPDATE_ITEM_ELEMENT;

<font color="brown">  // The subscript expression to be used.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* subscript() const;

<font color="brown">  // The modification to perform to the container object, at the
  // given subscript expression. E.g. (= 5) in the example above.</font>
  const <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>* update_item() const;
};
</code></pre></p>

### ResolvedUpdateStmt
<a id="ResolvedUpdateStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents an UPDATE statement, or a nested UPDATE inside an
// UPDATE statement.
//
// For top-level UPDATE statements, &lt;table_scan&gt; gives the table to
// scan and creates <a href="#ResolvedColumn">ResolvedColumns</a> for its columns.  Those columns can be
// referenced in the &lt;update_item_list&gt;. The top-level UPDATE statement may
// also have &lt;from_scan&gt;, the output of which is joined with
// the &lt;table_scan&gt; using expressions in the &lt;where_expr&gt;. The columns
// exposed in the &lt;from_scan&gt; are visible in the right side of the
// expressions in the &lt;update_item_list&gt; and in the &lt;where_expr&gt;.
// &lt;array_offset_column&gt; is never set for top-level UPDATE statements.
//
// Top-level UPDATE statements will also have &lt;column_access_list&gt; populated.
// For each column, this vector indicates if the column was read and/or
// written. The columns in this vector match those of
// &lt;table_scan.column_list&gt;. If a column was not encountered when producing
// the resolved AST, then the value at that index will be
// <a href="#ResolvedStatement">ResolvedStatement</a>::NONE.
//
// For nested UPDATEs, there is no &lt;table_scan&gt;.  The &lt;where_expr&gt; can
// only reference:
//   (1) the element_column from the <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a> containing this
//       statement,
//   (2) columns from the outer statements, and
//   (3) (optionally) &lt;array_offset_column&gt;, which represents the 0-based
//       offset of the array element being modified.
// The left hand sides of the expressions in &lt;update_item_list&gt; can only
// reference (1). The right hand sides of those expressions can reference
// (1), (2), and (3).
//
// The updates in &lt;update_item_list&gt; will be non-overlapping.
// If there are multiple nested statements updating the same entity,
// they will be combined into one <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>.
//
// See (broken link) for more detail on nested DML.
//
// If &lt;returning&gt; is present, the UPDATE statement will return updated rows.
// &lt;returning&gt; can only occur on top-level statements.
//
// This returning clause has a &lt;output_column_list&gt; to represent the data
// sent back to clients. It can only access columns from the &lt;table_scan&gt;.
// The columns in &lt;from_scan&gt; are not allowed.
// TODO: allow columns in &lt;from_scan&gt; to be referenced.
//
// &lt;topologically_sorted_generated_column_id_list&gt; is set for queries to
// tables having generated columns. This field is similar to the INSERT case,
// more details can be found in <a href="#ResolvedInsertStmt">ResolvedInsertStmt</a>.
//
// &lt;generated_expr_list&gt; has generated expressions for the corresponding
// generated column in the topologically_sorted_generated_column_id_list.
// Hence, these lists have the same size. This field is similar to the
// INSERT case, more details can be found in <a href="#ResolvedInsertStmt">ResolvedInsertStmt</a>.</font>
class ResolvedUpdateStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UPDATE_STMT;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

  const std::vector&lt;<a href="#ResolvedStatement">ResolvedStatement</a>::ObjectAccess&gt;&amp; column_access_list() const;
  int column_access_list_size() const;
  <a href="#ResolvedStatement">ResolvedStatement</a>::ObjectAccess column_access_list(int i) const;

  const <a href="#ResolvedAssertRowsModified">ResolvedAssertRowsModified</a>* assert_rows_modified() const;

  const <a href="#ResolvedReturningClause">ResolvedReturningClause</a>* returning() const;

  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* array_offset_column() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* where_expr() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>&gt;&gt;&amp; update_item_list() const;
  int update_item_list_size() const;
  const <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>* update_item_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* from_scan() const;

<font color="brown">  // TODO: refactor it with INSERT case.</font>
  const std::vector&lt;int&gt;&amp; topologically_sorted_generated_column_id_list() const;
  int topologically_sorted_generated_column_id_list_size() const;
  int topologically_sorted_generated_column_id_list(int i) const;

<font color="brown">  // TODO: refactor it with INSERT case.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; generated_column_expr_list() const;
  int generated_column_expr_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* generated_column_expr_list(int i) const;
};
</code></pre></p>

### ResolvedMergeWhen
<a id="ResolvedMergeWhen"></a>

<p><pre><code class="lang-c++"><font color="brown">// This is used by <a href="#ResolvedMergeStmt">ResolvedMergeStmt</a> to represent one WHEN ... THEN clause
// within MERGE statement.
//
// There are three types of clauses, which are MATCHED, NOT_MATCHED_BY_SOURCE
// and NOT_MATCHED_BY_TARGET. The &lt;match_type&gt; must have one of these values.
//
// The &lt;match_expr&gt; defines an optional expression to apply to the join
// result of &lt;table_scan&gt; and &lt;from_scan&gt; of the parent <a href="#ResolvedMergeStmt">ResolvedMergeStmt</a>.
//
// Each <a href="#ResolvedMergeWhen">ResolvedMergeWhen</a> must define exactly one of three operations,
//   -- INSERT: &lt;action_type&gt; is <a href="#ResolvedMergeWhen">ResolvedMergeWhen</a>::INSERT.
//              Both &lt;insert_column_list&gt; and &lt;insert_row&gt; are non-empty.
//              The size of &lt;insert_column_list&gt; must be the same with the
//              value_list size of &lt;insert_row&gt;, and, the column data type
//              must match.
//   -- UPDATE: &lt;action_type&gt; is <a href="#ResolvedMergeWhen">ResolvedMergeWhen</a>::UPDATE.
//              &lt;update_item_list&gt; is non-empty.
//   -- DELETE: &lt;action_type&gt; is <a href="#ResolvedMergeWhen">ResolvedMergeWhen</a>::DELETE.
// The INSERT, UPDATE and DELETE operations are mutually exclusive.
//
// When &lt;match_type&gt; is MATCHED, &lt;action_type&gt; must be UPDATE or DELETE.
// When &lt;match_type&gt; is NOT_MATCHED_BY_TARGET, &lt;action_type&gt; must be INSERT.
// When &lt;match_type&gt; is NOT_MATCHED_BY_SOURCE, &lt;action_type&gt; must be UPDATE
// or DELETE.
//
// The column visibility within a <a href="#ResolvedMergeWhen">ResolvedMergeWhen</a> clause is defined as
// following,
//   -- When &lt;match_type&gt; is MATCHED,
//      -- All columns from &lt;table_scan&gt; and &lt;from_scan&gt; are allowed in
//         &lt;match_expr&gt;.
//      -- If &lt;action_type&gt; is UPDATE, only columns from &lt;table_scan&gt; are
//         allowed on left side of expressions in &lt;update_item_list&gt;.
//         All columns from &lt;table_scan&gt; and &lt;from_scan&gt; are allowed on right
//         side of expressions in &lt;update_item_list&gt;.
//   -- When &lt;match_type&gt; is NOT_MATCHED_BY_TARGET,
//      -- Only columns from &lt;from_scan&gt; are allowed in &lt;match_expr&gt;.
//      -- Only columns from &lt;table_scan&gt; are allowed in
//         &lt;insert_column_list&gt;.
//      -- Only columns from &lt;from_scan&gt; are allowed in &lt;insert_row&gt;.
//   -- When &lt;match_type&gt; is NOT_MATCHED_BY_SOURCE,
//      -- Only columns from &lt;table_scan&gt; are allowed in &lt;match_expr&gt;.
//      -- If &lt;action_type&gt; is UPDATE, only columns from &lt;table_scan&gt; are
//         allowed in &lt;update_item_list&gt;.</font>
class ResolvedMergeWhen : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MERGE_WHEN;

  typedef <a href="#ResolvedMergeWhenEnum">ResolvedMergeWhenEnums</a>::MatchType MatchType;
  typedef <a href="#ResolvedMergeWhenEnum">ResolvedMergeWhenEnums</a>::ActionType ActionType;
  static const MatchType MATCHED = <a href="#ResolvedMergeWhenEnum">ResolvedMergeWhenEnums</a>::MATCHED;
  static const MatchType NOT_MATCHED_BY_SOURCE = <a href="#ResolvedMergeWhenEnum">ResolvedMergeWhenEnums</a>::NOT_MATCHED_BY_SOURCE;
  static const MatchType NOT_MATCHED_BY_TARGET = <a href="#ResolvedMergeWhenEnum">ResolvedMergeWhenEnums</a>::NOT_MATCHED_BY_TARGET;
  static const ActionType INSERT = <a href="#ResolvedMergeWhenEnum">ResolvedMergeWhenEnums</a>::INSERT;
  static const ActionType UPDATE = <a href="#ResolvedMergeWhenEnum">ResolvedMergeWhenEnums</a>::UPDATE;
  static const ActionType DELETE = <a href="#ResolvedMergeWhenEnum">ResolvedMergeWhenEnums</a>::DELETE;

  <a href="#ResolvedMergeWhen">ResolvedMergeWhen</a>::MatchType match_type() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* match_expr() const;

  <a href="#ResolvedMergeWhen">ResolvedMergeWhen</a>::ActionType action_type() const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; insert_column_list() const;
  int insert_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> insert_column_list(int i) const;

  const <a href="#ResolvedInsertRow">ResolvedInsertRow</a>* insert_row() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>&gt;&gt;&amp; update_item_list() const;
  int update_item_list_size() const;
  const <a href="#ResolvedUpdateItem">ResolvedUpdateItem</a>* update_item_list(int i) const;
};
</code></pre></p>

### ResolvedMergeStmt
<a id="ResolvedMergeStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a MERGE statement.
//
// &lt;table_scan&gt; gives the target table to scan and creates <a href="#ResolvedColumn">ResolvedColumns</a>
// for its columns.
//
// &lt;column_access_list&gt; indicates for each column, whether it was read and/or
// written. The columns in this vector match those of
// &lt;table_scan.column_list&gt;. If a column was not encountered when producing
// the resolved AST, then the value at that index will be
// <a href="#ResolvedStatement">ResolvedStatement</a>::NONE(0).
//
// The output of &lt;from_scan&gt; is joined with &lt;table_scan&gt; using the join
// expression &lt;merge_expr&gt;.
//
// The order of elements in &lt;when_clause_list&gt; matters, as they are executed
// sequentially. At most one of the &lt;when_clause_list&gt; clause will be applied
// to each row from &lt;table_scan&gt;.
//
// &lt;table_scan&gt;, &lt;from_scan&gt;, &lt;merge_expr&gt; and &lt;when_clause_list&gt; are
// required. &lt;when_clause_list&gt; must be non-empty.
//
// See (broken link) for more detail on MERGE statement.</font>
class ResolvedMergeStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MERGE_STMT;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

  const std::vector&lt;<a href="#ResolvedStatement">ResolvedStatement</a>::ObjectAccess&gt;&amp; column_access_list() const;
  int column_access_list_size() const;
  <a href="#ResolvedStatement">ResolvedStatement</a>::ObjectAccess column_access_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* from_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* merge_expr() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedMergeWhen">ResolvedMergeWhen</a>&gt;&gt;&amp; when_clause_list() const;
  int when_clause_list_size() const;
  const <a href="#ResolvedMergeWhen">ResolvedMergeWhen</a>* when_clause_list(int i) const;
};
</code></pre></p>

### ResolvedTruncateStmt
<a id="ResolvedTruncateStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a TRUNCATE TABLE statement.
//
// Statement:
//   TRUNCATE TABLE &lt;table_name&gt; [WHERE &lt;boolean_expression&gt;]
//
// &lt;table_scan&gt; is a TableScan for the target table, which is used during
//              resolving and validation. Consumers can use either the table
//              object inside it or name_path to reference the table.
// &lt;where_expr&gt; boolean expression that can reference columns in
//              <a href="#ResolvedColumn">ResolvedColumns</a> (which the TableScan creates); the
//              &lt;where_expr&gt; should always correspond to entire partitions,
//              and is optional.</font>
class ResolvedTruncateStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_TRUNCATE_STMT;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* where_expr() const;
};
</code></pre></p>

### ResolvedObjectUnit
<a id="ResolvedObjectUnit"></a>

<p><pre><code class="lang-c++"><font color="brown">// A reference to a unit of an object (e.g. a column or field of a table).
//
// &lt;name_path&gt; is a vector giving the identifier path of the object unit.</font>
class ResolvedObjectUnit : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_OBJECT_UNIT;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;
};
</code></pre></p>

### ResolvedPrivilege
<a id="ResolvedPrivilege"></a>

<p><pre><code class="lang-c++"><font color="brown">// A grantable privilege.
//
// &lt;action_type&gt; is the type of privilege action, e.g. SELECT, INSERT, UPDATE
// or DELETE.
// &lt;unit_list&gt; is an optional list of units of the object (e.g. columns of a
// table, fields in a value table) that the privilege is scoped to. The
// privilege is on the whole object if the list is empty.</font>
class ResolvedPrivilege : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PRIVILEGE;

  const std::string&amp; action_type() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedObjectUnit">ResolvedObjectUnit</a>&gt;&gt;&amp; unit_list() const;
  int unit_list_size() const;
  const <a href="#ResolvedObjectUnit">ResolvedObjectUnit</a>* unit_list(int i) const;
};
</code></pre></p>

### ResolvedGrantOrRevokeStmt
<a id="ResolvedGrantOrRevokeStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// Common superclass of GRANT/REVOKE statements.
//
// &lt;privilege_list&gt; is the list of privileges to be granted/revoked. ALL
// PRIVILEGES should be granted/revoked if it is empty.
// &lt;object_type_list&gt; is an optional list of string identifiers, e.g., TABLE,
// VIEW, MATERIALIZED VIEW.
// &lt;name_path&gt; is a vector of segments of the object identifier&#39;s pathname.
// &lt;grantee_list&gt; (DEPRECATED) is the list of grantees (strings).
// &lt;grantee_expr_list&gt; is the list of grantees, and may include parameters.
//
// Only one of &lt;grantee_list&gt; or &lt;grantee_expr_list&gt; will be populated,
// depending on whether or not the FEATURE_PARAMETERS_IN_GRANTEE_LIST
// is enabled.  The &lt;grantee_list&gt; is deprecated, and will be removed
// along with the corresponding FEATURE once all engines have migrated to
// use the &lt;grantee_expr_list&gt;.  Once &lt;grantee_expr_list&gt; is the only
// one, then it should be marked as NOT_IGNORABLE.</font>
class ResolvedGrantOrRevokeStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  ABSL_DEPRECATED(&#34;Use `object_type_list()` instead&#34;)
  inline const std::string&amp; object_type() const {
      return object_type_list()[0];
  }

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedPrivilege">ResolvedPrivilege</a>&gt;&gt;&amp; privilege_list() const;
  int privilege_list_size() const;
  const <a href="#ResolvedPrivilege">ResolvedPrivilege</a>* privilege_list(int i) const;

  const std::vector&lt;std::string&gt;&amp; object_type_list() const;
  int object_type_list_size() const;
  std::string object_type_list(int i) const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::string&gt;&amp; grantee_list() const;
  int grantee_list_size() const;
  std::string grantee_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; grantee_expr_list() const;
  int grantee_expr_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* grantee_expr_list(int i) const;
};
</code></pre></p>

### ResolvedGrantStmt
<a id="ResolvedGrantStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// A GRANT statement. It represents the action to grant a list of privileges
// on a specific object to/from list of grantees.</font>
class ResolvedGrantStmt : public <a href="#ResolvedGrantOrRevokeStmt">ResolvedGrantOrRevokeStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRANT_STMT;

};
</code></pre></p>

### ResolvedRevokeStmt
<a id="ResolvedRevokeStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// A REVOKE statement. It represents the action to revoke a list of
// privileges on a specific object to/from list of grantees.</font>
class ResolvedRevokeStmt : public <a href="#ResolvedGrantOrRevokeStmt">ResolvedGrantOrRevokeStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_REVOKE_STMT;

};
</code></pre></p>

### ResolvedAlterObjectStmt
<a id="ResolvedAlterObjectStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// Common super class for statements:
//   ALTER &lt;object&gt; [IF EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;
//
// &lt;name_path&gt; is a vector giving the identifier path in the table &lt;name&gt;. It
//             is optional if
//             FEATURE_ALLOW_MISSING_PATH_EXPRESSION_IN_ALTER_DDL is enabled.
// &lt;alter_action_list&gt; is a vector of actions to be done to the object.
// &lt;is_if_exists&gt; silently ignores the &#34;name_path does not exist&#34; error.</font>
class ResolvedAlterObjectStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedAlterAction">ResolvedAlterAction</a>&gt;&gt;&amp; alter_action_list() const;
  int alter_action_list_size() const;
  const <a href="#ResolvedAlterAction">ResolvedAlterAction</a>* alter_action_list(int i) const;

  bool is_if_exists() const;
};
</code></pre></p>

### ResolvedAlterDatabaseStmt
<a id="ResolvedAlterDatabaseStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   ALTER DATABASE [IF EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;
//
// This statement could be used to change the database level options.</font>
class ResolvedAlterDatabaseStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_DATABASE_STMT;

};
</code></pre></p>

### ResolvedAlterIndexStmt
<a id="ResolvedAlterIndexStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   ALTER [SEARCH|VECTOR] INDEX [IF EXISTS] &lt;name_path&gt; [ON &lt;table_name_path&gt;] &lt;alter_action_list&gt;
// (broken link)
//
// &lt;table_name_path&gt; is the name of table being indexed.
// &lt;index_type&gt; is the type of index being altered.
// &lt;table_scan&gt; is a TableScan on the table being indexed.
//
// Note: ALTER INDEX without SEARCH or VECTOR curerently is not resolved to this node.</font>
class ResolvedAlterIndexStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_INDEX_STMT;

  typedef <a href="#ResolvedAlterIndexStmtEnum">ResolvedAlterIndexStmtEnums</a>::AlterIndexType AlterIndexType;
  static const AlterIndexType INDEX_DEFAULT = <a href="#ResolvedAlterIndexStmtEnum">ResolvedAlterIndexStmtEnums</a>::INDEX_DEFAULT;
  static const AlterIndexType INDEX_SEARCH = <a href="#ResolvedAlterIndexStmtEnum">ResolvedAlterIndexStmtEnums</a>::INDEX_SEARCH;
  static const AlterIndexType INDEX_VECTOR = <a href="#ResolvedAlterIndexStmtEnum">ResolvedAlterIndexStmtEnums</a>::INDEX_VECTOR;

  std::string GetAlterIndexTypeString() const;
  static std::string AlterIndexTypeToString(AlterIndexType index_type);

  const std::vector&lt;std::string&gt;&amp; table_name_path() const;
  int table_name_path_size() const;
  std::string table_name_path(int i) const;

  <a href="#ResolvedAlterIndexStmt">ResolvedAlterIndexStmt</a>::AlterIndexType index_type() const;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;
};
</code></pre></p>

### ResolvedAlterMaterializedViewStmt
<a id="ResolvedAlterMaterializedViewStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// ALTER MATERIALIZED VIEW [IF EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;</font>
class ResolvedAlterMaterializedViewStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_MATERIALIZED_VIEW_STMT;

};
</code></pre></p>

### ResolvedAlterApproxViewStmt
<a id="ResolvedAlterApproxViewStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// ALTER APPROX VIEW [IF EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;</font>
class ResolvedAlterApproxViewStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_APPROX_VIEW_STMT;

};
</code></pre></p>

### ResolvedAlterSchemaStmt
<a id="ResolvedAlterSchemaStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// ALTER SCHEMA [IF NOT EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;;</font>
class ResolvedAlterSchemaStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_SCHEMA_STMT;

};
</code></pre></p>

### ResolvedAlterExternalSchemaStmt
<a id="ResolvedAlterExternalSchemaStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// ALTER EXTERNAL SCHEMA [IF EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;;</font>
class ResolvedAlterExternalSchemaStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_EXTERNAL_SCHEMA_STMT;

};
</code></pre></p>

### ResolvedAlterModelStmt
<a id="ResolvedAlterModelStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// ALTER MODEL [IF EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;</font>
class ResolvedAlterModelStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_MODEL_STMT;

};
</code></pre></p>

### ResolvedAlterTableStmt
<a id="ResolvedAlterTableStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// ALTER TABLE [IF EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;</font>
class ResolvedAlterTableStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_TABLE_STMT;

};
</code></pre></p>

### ResolvedAlterViewStmt
<a id="ResolvedAlterViewStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// ALTER VIEW [IF EXISTS] &lt;name_path&gt; &lt;alter_action_list&gt;</font>
class ResolvedAlterViewStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_VIEW_STMT;

};
</code></pre></p>

### ResolvedAlterAction
<a id="ResolvedAlterAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// A common super class for all actions in statement ALTER &lt;object&gt;</font>
class ResolvedAlterAction : public <a href="#ResolvedArgument">ResolvedArgument</a> {
};
</code></pre></p>

### ResolvedAlterColumnAction
<a id="ResolvedAlterColumnAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// A super class for all ALTER COLUMN actions in the ALTER TABLE statement:
//   ALTER TABLE &lt;table_name&gt; ALTER COLUMN [IF EXISTS] &lt;column&gt;
//
// &lt;is_if_exists&gt; silently ignores the &#34;column does not exist&#34; error.
// &lt;column&gt; is the name of the column.</font>
class ResolvedAlterColumnAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  bool is_if_exists() const;

  const std::string&amp; column() const;
};
</code></pre></p>

### ResolvedSetOptionsAction
<a id="ResolvedSetOptionsAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// SET OPTIONS action for ALTER &lt;object&gt; statement
//
// &lt;option_list&gt; has engine-specific directives that specify how to
//               alter the metadata for this object.</font>
class ResolvedSetOptionsAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SET_OPTIONS_ACTION;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedAlterSubEntityAction
<a id="ResolvedAlterSubEntityAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// Alter sub-entity action for ALTER &lt;object&gt; statement.
// (broken link)
//
// ALTER &lt;entity_type&gt; [IF EXISTS] &lt;name&gt; &lt;alter_action&gt;
//
// &lt;entity_type&gt; engine-specific sub-entity type to be altered.
// &lt;name&gt; the identifier for the sub-entity resource being altered.
// &lt;alter_action&gt; action for the sub-entity resource, such as
//     SET OPTIONS or a further nested ALTER sub-entity action.
// &lt;is_if_exists&gt; if set, skip the alter action if the resource does
//     not exist.</font>
class ResolvedAlterSubEntityAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_SUB_ENTITY_ACTION;

  const std::string&amp; entity_type() const;

  const std::string&amp; name() const;

  const <a href="#ResolvedAlterAction">ResolvedAlterAction</a>* alter_action() const;

  bool is_if_exists() const;
};
</code></pre></p>

### ResolvedAddSubEntityAction
<a id="ResolvedAddSubEntityAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// Add sub-entity action for ALTER &lt;object&gt; statement.
// (broken link)
//
// ADD &lt;entity_type&gt; [IF NOT EXISTS] &lt;name&gt; [OPTIONS(...)]
//
// &lt;entity_type&gt; engine-specific sub-entity type to be added.
// &lt;name&gt; the identifier for the sub-entity resource being added.
// &lt;options_list&gt; engine specific options_list for the sub-entity resource.
// &lt;is_if_not_exists&gt; if set, skip the add action if the resource
//     already exists.</font>
class ResolvedAddSubEntityAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ADD_SUB_ENTITY_ACTION;

  const std::string&amp; entity_type() const;

  const std::string&amp; name() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; options_list() const;
  int options_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* options_list(int i) const;

  bool is_if_not_exists() const;
};
</code></pre></p>

### ResolvedDropSubEntityAction
<a id="ResolvedDropSubEntityAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// Drop sub-entity action for ALTER &lt;object&gt; statement.
// (broken link)
//
// DROP &lt;entity_type&gt; [IF EXISTS] &lt;name&gt;
//
// &lt;entity_type&gt; engine-specific sub-entity type to be dropped.
// &lt;name&gt; the identifier for the sub-entity resource being dropped.
// &lt;is_if_exists&gt; if set, skip the drop action if the resource does
//     not exist.</font>
class ResolvedDropSubEntityAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_SUB_ENTITY_ACTION;

  const std::string&amp; entity_type() const;

  const std::string&amp; name() const;

  bool is_if_exists() const;
};
</code></pre></p>

### ResolvedAddColumnAction
<a id="ResolvedAddColumnAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// ADD COLUMN action for ALTER TABLE statement</font>
class ResolvedAddColumnAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ADD_COLUMN_ACTION;

  bool is_if_not_exists() const;

  const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>* column_definition() const;
};
</code></pre></p>

### ResolvedAddColumnIdentifierAction
<a id="ResolvedAddColumnIdentifierAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// ADD COLUMN action for ALTER VECTOR|SEARCH INDEX statement
// (broken link)
//
// Note: Different from <a href="#ResolvedAddColumnAction">ResolvedAddColumnAction</a>, this action is used for
// adding an existing column in table to an index, so it doesn&#39;t need column
// definition or other fields in ASTAddColumnAction.</font>
class ResolvedAddColumnIdentifierAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ADD_COLUMN_IDENTIFIER_ACTION;

  const std::string&amp; name() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; options_list() const;
  int options_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* options_list(int i) const;

  bool is_if_not_exists() const;
};
</code></pre></p>

### ResolvedRebuildAction
<a id="ResolvedRebuildAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// REBUILD action for ALTER VECTOR|SEARCH INDEX statement.
// (broken link)
//
// This action has to be the last action in the alter action list.</font>
class ResolvedRebuildAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_REBUILD_ACTION;

};
</code></pre></p>

### ResolvedAddConstraintAction
<a id="ResolvedAddConstraintAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// ADD CONSTRAINT for ALTER TABLE statement</font>
class ResolvedAddConstraintAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ADD_CONSTRAINT_ACTION;

  bool is_if_not_exists() const;

  const <a href="#ResolvedConstraint">ResolvedConstraint</a>* constraint() const;

  const Table* table() const;
};
</code></pre></p>

### ResolvedDropConstraintAction
<a id="ResolvedDropConstraintAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// DROP CONSTRAINT for ALTER TABLE statement</font>
class ResolvedDropConstraintAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_CONSTRAINT_ACTION;

  bool is_if_exists() const;

  const std::string&amp; name() const;
};
</code></pre></p>

### ResolvedDropPrimaryKeyAction
<a id="ResolvedDropPrimaryKeyAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// DROP PRIMARY KEY [IF EXISTS] for ALTER TABLE statement</font>
class ResolvedDropPrimaryKeyAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_PRIMARY_KEY_ACTION;

  bool is_if_exists() const;
};
</code></pre></p>

### ResolvedAlterColumnOptionsAction
<a id="ResolvedAlterColumnOptionsAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// This ALTER action:
//   ALTER COLUMN [IF EXISTS] &lt;column&gt; SET OPTIONS &lt;options_list&gt;
//
// &lt;options_list&gt; has engine-specific directives that specify how to
//                alter the metadata for a column.</font>
class ResolvedAlterColumnOptionsAction : public <a href="#ResolvedAlterColumnAction">ResolvedAlterColumnAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_COLUMN_OPTIONS_ACTION;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedAlterColumnDropNotNullAction
<a id="ResolvedAlterColumnDropNotNullAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// This ALTER action:
//   ALTER COLUMN [IF EXISTS] &lt;column&gt; DROP NOT NULL
//
// Removes the NOT NULL constraint from the given column.</font>
class ResolvedAlterColumnDropNotNullAction : public <a href="#ResolvedAlterColumnAction">ResolvedAlterColumnAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_COLUMN_DROP_NOT_NULL_ACTION;

};
</code></pre></p>

### ResolvedAlterColumnDropGeneratedAction
<a id="ResolvedAlterColumnDropGeneratedAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// This ALTER action:
//   ALTER COLUMN [IF EXISTS] &lt;column&gt; DROP GENERATED
//
// Removes the generated value (either an expression or identity column)
// from the given column.</font>
class ResolvedAlterColumnDropGeneratedAction : public <a href="#ResolvedAlterColumnAction">ResolvedAlterColumnAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_COLUMN_DROP_GENERATED_ACTION;

};
</code></pre></p>

### ResolvedAlterColumnSetGeneratedAction
<a id="ResolvedAlterColumnSetGeneratedAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// Alter column set generated action:
//   ALTER COLUMN [IF EXISTS] &lt;column&gt; SET GENERATED AS &lt;generation_clause&gt;
//
// &lt;generation_clause&gt; sets how the generated value is computed. Currently
// only altering a column to be an identity column is supported.
// It only impacts future inserted rows, and has no impact on existing rows.
// This is a metadata only operation.
//
// Resolver validates that the identity column attributes can be coerced to
// the column type when &lt;column&gt; exists. If &lt;column&gt; is not found and
// &lt;is_if_exists&gt; is true, Resolver skips the type match check.
//
// Note: This action is only used for setting a non-generated column to be a
// generated column; existing generated columns cannot be updated with this
// action. At most one column can be set to be an identity column in a table.</font>
class ResolvedAlterColumnSetGeneratedAction : public <a href="#ResolvedAlterColumnAction">ResolvedAlterColumnAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_COLUMN_SET_GENERATED_ACTION;

  const <a href="#ResolvedGeneratedColumnInfo">ResolvedGeneratedColumnInfo</a>* generated_column_info() const;
};
</code></pre></p>

### ResolvedAlterColumnSetDataTypeAction
<a id="ResolvedAlterColumnSetDataTypeAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// ALTER COLUMN &lt;column&gt; SET DATA TYPE action for ALTER TABLE
// statement. It supports updating the data type of the column as
// well as updating type parameters and collation specifications of
// the column (and on struct fields and array elements).</font>
class ResolvedAlterColumnSetDataTypeAction : public <a href="#ResolvedAlterColumnAction">ResolvedAlterColumnAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_COLUMN_SET_DATA_TYPE_ACTION;

<font color="brown">  // The new type for the column.</font>
  const Type* updated_type() const;

<font color="brown">  // The new type parameters for the column, if the new type has
  // parameters. Note that unlike with CREATE TABLE, the child_list is
  // populated for ARRAY and STRUCT types.
  // TODO Use updated_annotations to pass type parameters.</font>
  const TypeParameters&amp; updated_type_parameters() const;

<font color="brown">  // The new annotations for the column including the new collation
  // specifications. Changing options using SET DATA TYPE action is not
  // allowed.</font>
  const <a href="#ResolvedColumnAnnotation">ResolvedColumnAnnotations</a>* updated_annotations() const;
};
</code></pre></p>

### ResolvedAlterColumnSetDefaultAction
<a id="ResolvedAlterColumnSetDefaultAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// Alter column set default action:
//   ALTER COLUMN [IF EXISTS] &lt;column&gt; SET DEFAULT &lt;default_value&gt;
//
// &lt;default_value&gt; sets the new default value expression. It only impacts
// future inserted rows, and has no impact on existing rows with the current
// default value. This is a metadata only operation.
//
// Resolver validates that &lt;default_value&gt; expression can be coerced to the
// column type when &lt;column&gt; exists. If &lt;column&gt; is not found and
// &lt;is_if_exists&gt; is true, Resolver skips type match check.</font>
class ResolvedAlterColumnSetDefaultAction : public <a href="#ResolvedAlterColumnAction">ResolvedAlterColumnAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_COLUMN_SET_DEFAULT_ACTION;

  const <a href="#ResolvedColumnDefaultValue">ResolvedColumnDefaultValue</a>* default_value() const;
};
</code></pre></p>

### ResolvedAlterColumnDropDefaultAction
<a id="ResolvedAlterColumnDropDefaultAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// This ALTER action:
//   ALTER COLUMN [IF EXISTS] &lt;column&gt; DROP DEFAULT
//
// Removes the DEFAULT constraint from the given column.</font>
class ResolvedAlterColumnDropDefaultAction : public <a href="#ResolvedAlterColumnAction">ResolvedAlterColumnAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_COLUMN_DROP_DEFAULT_ACTION;

};
</code></pre></p>

### ResolvedDropColumnAction
<a id="ResolvedDropColumnAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// DROP COLUMN action for ALTER TABLE statement
//
// &lt;name&gt; is the name of the column to drop.</font>
class ResolvedDropColumnAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_COLUMN_ACTION;

  bool is_if_exists() const;

  const std::string&amp; name() const;
};
</code></pre></p>

### ResolvedRenameColumnAction
<a id="ResolvedRenameColumnAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// RENAME COLUMN action for ALTER TABLE statement.
//
// &lt;name&gt; is the name of the column to rename.
// &lt;new_name&gt; is the new name of the column.
//
// RENAME COLUMN actions cannot be part of the same alter_action_list as any
// other type of action.
// Chains of RENAME COLUMN will be interpreted as a sequence of mutations.
// The order of actions matters. Each &lt;name&gt; refers to a column name that
// exists after all preceding renames have been applied.</font>
class ResolvedRenameColumnAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RENAME_COLUMN_ACTION;

  bool is_if_exists() const;

  const std::string&amp; name() const;

  const std::string&amp; new_name() const;
};
</code></pre></p>

### ResolvedSetAsAction
<a id="ResolvedSetAsAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// SET AS action for generic ALTER &lt;entity_type&gt; statement.
// Exactly one of &lt;entity_body_json&gt;, &lt;entity_body_text&gt; should be non-empty.
//
// &lt;entity_body_json&gt; is a JSON literal to be interpreted by engine.
// &lt;entity_body_text&gt; is a text literal to be interpreted by engine.</font>
class ResolvedSetAsAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SET_AS_ACTION;

  const std::string&amp; entity_body_json() const;

  const std::string&amp; entity_body_text() const;
};
</code></pre></p>

### ResolvedSetCollateClause
<a id="ResolvedSetCollateClause"></a>

<p><pre><code class="lang-c++"><font color="brown">// SET DEFAULT COLLATE clause for generic ALTER &lt;entity_type&gt; statement.
//
// &lt;collation_name&gt; specifies the new default collation specification for a
//   table or schema. Modifying the default collation for a table or schema
//   does not affect any existing columns or tables - the new default
//   collation only affects new tables and/or columns if applicable. Only
//   string literals are allowed for this field.</font>
class ResolvedSetCollateClause : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SET_COLLATE_CLAUSE;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* collation_name() const;
};
</code></pre></p>

### ResolvedAlterTableSetOptionsStmt
<a id="ResolvedAlterTableSetOptionsStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   ALTER TABLE [IF EXISTS] &lt;name&gt; SET OPTIONS (...)
//
// NOTE: This is deprecated in favor of <a href="#ResolvedAlterTableStmt">ResolvedAlterTableStmt</a>.
//
// &lt;name_path&gt; is a vector giving the identifier path in the table &lt;name&gt;.
// &lt;option_list&gt; has engine-specific directives that specify how to
//               alter the metadata for this table.
// &lt;is_if_exists&gt; silently ignore the &#34;name_path does not exist&#34; error.</font>
class ResolvedAlterTableSetOptionsStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_TABLE_SET_OPTIONS_STMT;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  bool is_if_exists() const;
};
</code></pre></p>

### ResolvedRenameStmt
<a id="ResolvedRenameStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: RENAME &lt;object_type&gt; &lt;old_name_path&gt; TO &lt;new_name_path&gt;;
//
// &lt;object_type&gt; is an string identifier,
//               e.g., &#34;TABLE&#34;, &#34;VIEW&#34;, &#34;INDEX&#34;, &#34;FUNCTION&#34;, &#34;TYPE&#34;, etc.
// &lt;old_name_path&gt; is a vector giving the identifier path for the object to
//                 be renamed.
// &lt;new_name_path&gt; is a vector giving the identifier path for the object to
//                 be renamed to.</font>
class ResolvedRenameStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RENAME_STMT;

  const std::string&amp; object_type() const;

  const std::vector&lt;std::string&gt;&amp; old_name_path() const;
  int old_name_path_size() const;
  std::string old_name_path(int i) const;

  const std::vector&lt;std::string&gt;&amp; new_name_path() const;
  int new_name_path_size() const;
  std::string new_name_path(int i) const;
};
</code></pre></p>

### ResolvedCreatePrivilegeRestrictionStmt
<a id="ResolvedCreatePrivilegeRestrictionStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//     CREATE [OR REPLACE] PRIVILEGE RESTRICTION [IF NOT EXISTS]
//     ON &lt;column_privilege_list&gt; ON &lt;object_type&gt; &lt;name_path&gt;
//     [RESTRICT TO (&lt;restrictee_list&gt;)]
//
// &lt;column_privilege_list&gt; is the name of the column privileges on which
//                         to apply the restrictions.
// &lt;object_type&gt; is a string identifier, which is currently either TABLE or
//               VIEW, which tells the engine how to look up the name.
// &lt;restrictee_list&gt; is a list of users and groups the privilege restrictions
//                   should apply to. Each restrictee is either a string
//                   literal or a parameter.</font>
class ResolvedCreatePrivilegeRestrictionStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_PRIVILEGE_RESTRICTION_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedPrivilege">ResolvedPrivilege</a>&gt;&gt;&amp; column_privilege_list() const;
  int column_privilege_list_size() const;
  const <a href="#ResolvedPrivilege">ResolvedPrivilege</a>* column_privilege_list(int i) const;

  const std::string&amp; object_type() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; restrictee_list() const;
  int restrictee_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* restrictee_list(int i) const;
};
</code></pre></p>

### ResolvedCreateRowAccessPolicyStmt
<a id="ResolvedCreateRowAccessPolicyStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: CREATE [OR REPLACE] ROW ACCESS POLICY [IF NOT EXISTS]
//                 [&lt;name&gt;] ON &lt;target_name_path&gt;
//                 [GRANT TO (&lt;grantee_list&gt;)]
//                 FILTER USING (&lt;predicate&gt;);
//
// &lt;create_mode&gt; indicates if this was CREATE, CREATE OR REPLACE, or
//               CREATE IF NOT EXISTS.
// &lt;name&gt; is the name of the row access policy to be created or an empty
//        string.
// &lt;target_name_path&gt; is a vector giving the identifier path of the target
//                    table.
// &lt;table_scan&gt; is a TableScan for the target table, which is used during
//              resolving and validation. Consumers can use either the table
//              object inside it or target_name_path to reference the table.
// &lt;grantee_list&gt; (DEPRECATED) is the list of user principals the policy
//                should apply to.
// &lt;grantee_expr_list&gt; is the list of user principals the policy should
//                     apply to, and may include parameters.
// &lt;predicate&gt; is a boolean expression that selects the rows that are being
//             made visible.
// &lt;predicate_str&gt; is the string form of the predicate.
//
// Only one of &lt;grantee_list&gt; or &lt;grantee_expr_list&gt; will be populated,
// depending on whether or not the FEATURE_PARAMETERS_IN_GRANTEE_LIST
// is enabled.  The &lt;grantee_list&gt; is deprecated, and will be removed
// along with the corresponding FEATURE once all engines have migrated to
// use the &lt;grantee_expr_list&gt;.  Once &lt;grantee_expr_list&gt; is the only
// one, then it should be marked as NOT_IGNORABLE.</font>
class ResolvedCreateRowAccessPolicyStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_ROW_ACCESS_POLICY_STMT;

  typedef <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a>::CreateMode CreateMode;

  <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a>::CreateMode create_mode() const;

  const std::string&amp; name() const;

  const std::vector&lt;std::string&gt;&amp; target_name_path() const;
  int target_name_path_size() const;
  std::string target_name_path(int i) const;

  const std::vector&lt;std::string&gt;&amp; grantee_list() const;
  int grantee_list_size() const;
  std::string grantee_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; grantee_expr_list() const;
  int grantee_expr_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* grantee_expr_list(int i) const;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* predicate() const;

  const std::string&amp; predicate_str() const;
};
</code></pre></p>

### ResolvedDropPrivilegeRestrictionStmt
<a id="ResolvedDropPrivilegeRestrictionStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//     DROP PRIVILEGE RESTRICTION [IF EXISTS]
//     ON &lt;column_privilege_list&gt; ON &lt;object_type&gt; &lt;name_path&gt;
//
// &lt;column_privilege_list&gt; is the name of the column privileges on which
//                         the restrictions have been applied.
// &lt;object_type&gt; is a string identifier, which is currently either TABLE or
//               VIEW, which tells the engine how to look up the name.
// &lt;name_path&gt; is the name of the table the restrictions are scoped to.</font>
class ResolvedDropPrivilegeRestrictionStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_PRIVILEGE_RESTRICTION_STMT;

  const std::string&amp; object_type() const;

  bool is_if_exists() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedPrivilege">ResolvedPrivilege</a>&gt;&gt;&amp; column_privilege_list() const;
  int column_privilege_list_size() const;
  const <a href="#ResolvedPrivilege">ResolvedPrivilege</a>* column_privilege_list(int i) const;
};
</code></pre></p>

### ResolvedDropRowAccessPolicyStmt
<a id="ResolvedDropRowAccessPolicyStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//     DROP ROW ACCESS POLICY &lt;name&gt; ON &lt;target_name_path&gt;; or
//     DROP ALL ROW [ACCESS] POLICIES ON &lt;target_name_path&gt;;
//
// &lt;is_drop_all&gt; indicates that all policies should be dropped.
// &lt;is_if_exists&gt; silently ignore the &#34;policy &lt;name&gt; does not exist&#34; error.
//                This is not allowed if is_drop_all is true.
// &lt;name&gt; is the name of the row policy to be dropped or an empty string.
// &lt;target_name_path&gt; is a vector giving the identifier path of the target
//                    table.</font>
class ResolvedDropRowAccessPolicyStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_ROW_ACCESS_POLICY_STMT;

  bool is_drop_all() const;

  bool is_if_exists() const;

  const std::string&amp; name() const;

  const std::vector&lt;std::string&gt;&amp; target_name_path() const;
  int target_name_path_size() const;
  std::string target_name_path(int i) const;
};
</code></pre></p>

### ResolvedDropIndexStmt
<a id="ResolvedDropIndexStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// DROP SEARCH|VECTOR INDEX [IF EXISTS] &lt;name&gt; [ON &lt;table_name_path&gt;];
// Note: DROP INDEX without SEARCH or VECTOR is currently resolved to a
// generic <a href="#ResolvedDropStmt">ResolvedDropStmt</a>. The index_type currently would never be
// INDEX_DEFAULT.
//
// &lt;name&gt; is the name of the search index to be dropped.
// &lt;table_name_path&gt; is a vector giving the identifier path of the target
//                   table.</font>
class ResolvedDropIndexStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_INDEX_STMT;

  typedef <a href="#ResolvedDropIndexStmtEnum">ResolvedDropIndexStmtEnums</a>::IndexType IndexType;
  static const IndexType INDEX_DEFAULT = <a href="#ResolvedDropIndexStmtEnum">ResolvedDropIndexStmtEnums</a>::INDEX_DEFAULT;
  static const IndexType INDEX_SEARCH = <a href="#ResolvedDropIndexStmtEnum">ResolvedDropIndexStmtEnums</a>::INDEX_SEARCH;
  static const IndexType INDEX_VECTOR = <a href="#ResolvedDropIndexStmtEnum">ResolvedDropIndexStmtEnums</a>::INDEX_VECTOR;

  std::string GetIndexTypeString() const;
  static std::string IndexTypeToString(IndexType index_type);

  bool is_if_exists() const;

  const std::string&amp; name() const;

  const std::vector&lt;std::string&gt;&amp; table_name_path() const;
  int table_name_path_size() const;
  std::string table_name_path(int i) const;

  <a href="#ResolvedDropIndexStmt">ResolvedDropIndexStmt</a>::IndexType index_type() const;
};
</code></pre></p>

### ResolvedGrantToAction
<a id="ResolvedGrantToAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// GRANT TO action for ALTER ROW ACCESS POLICY statement
//
// &lt;grantee_expr_list&gt; is the list of grantees, and may include parameters.</font>
class ResolvedGrantToAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRANT_TO_ACTION;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; grantee_expr_list() const;
  int grantee_expr_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* grantee_expr_list(int i) const;
};
</code></pre></p>

### ResolvedRestrictToAction
<a id="ResolvedRestrictToAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// This action for ALTER PRIVILEGE RESTRICTION statement:
//     RESTRICT TO &lt;restrictee_list&gt;
//
// &lt;restrictee_list&gt; is a list of users and groups the privilege restrictions
//                   should apply to. Each restrictee is either a string
//                   literal or a parameter.</font>
class ResolvedRestrictToAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RESTRICT_TO_ACTION;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; restrictee_list() const;
  int restrictee_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* restrictee_list(int i) const;
};
</code></pre></p>

### ResolvedAddToRestricteeListAction
<a id="ResolvedAddToRestricteeListAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// This action for ALTER PRIVILEGE RESTRICTION statement:
//     ADD [IF NOT EXISTS] &lt;restrictee_list&gt;
//
// &lt;restrictee_list&gt; is a list of users and groups the privilege restrictions
//                   should apply to. Each restrictee is either a string
//                   literal or a parameter.</font>
class ResolvedAddToRestricteeListAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ADD_TO_RESTRICTEE_LIST_ACTION;

  bool is_if_not_exists() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; restrictee_list() const;
  int restrictee_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* restrictee_list(int i) const;
};
</code></pre></p>

### ResolvedRemoveFromRestricteeListAction
<a id="ResolvedRemoveFromRestricteeListAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// This action for ALTER PRIVILEGE RESTRICTION statement:
//     REMOVE [IF EXISTS] &lt;restrictee_list&gt;
//
// &lt;restrictee_list&gt; is a list of users and groups the privilege restrictions
//                   should apply to. Each restrictee is either a string
//                   literal or a parameter.</font>
class ResolvedRemoveFromRestricteeListAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_REMOVE_FROM_RESTRICTEE_LIST_ACTION;

  bool is_if_exists() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; restrictee_list() const;
  int restrictee_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* restrictee_list(int i) const;
};
</code></pre></p>

### ResolvedFilterUsingAction
<a id="ResolvedFilterUsingAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// FILTER USING action for ALTER ROW ACCESS POLICY statement
//
// &lt;predicate&gt; is a boolean expression that selects the rows that are being
//             made visible.
// &lt;predicate_str&gt; is the string form of the predicate.</font>
class ResolvedFilterUsingAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FILTER_USING_ACTION;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* predicate() const;

  const std::string&amp; predicate_str() const;
};
</code></pre></p>

### ResolvedRevokeFromAction
<a id="ResolvedRevokeFromAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// REVOKE FROM action for ALTER ROW ACCESS POLICY statement
//
// &lt;revokee_expr_list&gt; is the list of revokees, and may include parameters.
// &lt;is_revoke_from_all&gt; is a boolean indicating whether it was a REVOKE FROM
//                      ALL statement.</font>
class ResolvedRevokeFromAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_REVOKE_FROM_ACTION;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; revokee_expr_list() const;
  int revokee_expr_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* revokee_expr_list(int i) const;

  bool is_revoke_from_all() const;
};
</code></pre></p>

### ResolvedRenameToAction
<a id="ResolvedRenameToAction"></a>

<p><pre><code class="lang-c++"><font color="brown">// RENAME TO action for ALTER ROW ACCESS POLICY statement
//         and ALTER TABLE statement
//
// &lt;new_path&gt; is the new name of the row access policy,
//         or the new path of the table.</font>
class ResolvedRenameToAction : public <a href="#ResolvedAlterAction">ResolvedAlterAction</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RENAME_TO_ACTION;

  const std::vector&lt;std::string&gt;&amp; new_path() const;
  int new_path_size() const;
  std::string new_path(int i) const;
};
</code></pre></p>

### ResolvedAlterPrivilegeRestrictionStmt
<a id="ResolvedAlterPrivilegeRestrictionStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//     ALTER PRIVILEGE RESTRICTION [IF EXISTS]
//     ON &lt;column_privilege_list&gt; ON &lt;object_type&gt; &lt;name_path&gt;
//     &lt;alter_action_list&gt;
//
// &lt;column_privilege_list&gt; is the name of the column privileges on which
//                         the restrictions have been applied.
// &lt;object_type&gt; is a string identifier, which is currently either TABLE or
//               VIEW, which tells the engine how to look up the name.</font>
class ResolvedAlterPrivilegeRestrictionStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_PRIVILEGE_RESTRICTION_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedPrivilege">ResolvedPrivilege</a>&gt;&gt;&amp; column_privilege_list() const;
  int column_privilege_list_size() const;
  const <a href="#ResolvedPrivilege">ResolvedPrivilege</a>* column_privilege_list(int i) const;

  const std::string&amp; object_type() const;
};
</code></pre></p>

### ResolvedAlterRowAccessPolicyStmt
<a id="ResolvedAlterRowAccessPolicyStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//     ALTER ROW ACCESS POLICY [IF EXISTS]
//     &lt;name&gt; ON &lt;name_path&gt;
//     &lt;alter_action_list&gt;
//
// &lt;name&gt; is the name of the row access policy to be altered, scoped to the
//        table in the base &lt;name_path&gt;.
// &lt;table_scan&gt; is a TableScan for the target table, which is used during
//              resolving and validation. Consumers can use either the table
//              object inside it or base &lt;name_path&gt; to reference the table.</font>
class ResolvedAlterRowAccessPolicyStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_ROW_ACCESS_POLICY_STMT;

  const std::string&amp; name() const;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;
};
</code></pre></p>

### ResolvedAlterAllRowAccessPoliciesStmt
<a id="ResolvedAlterAllRowAccessPoliciesStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//     ALTER ALL ROW ACCESS POLICIES ON &lt;name_path&gt; &lt;alter_action_list&gt;
//
// &lt;name_path&gt; is a vector giving the identifier path in the table name.
// &lt;alter_action_list&gt; is a vector of actions to be done to the object. It
//                     must have exactly one REVOKE FROM action with either
//                     a non-empty grantee list or &#39;all&#39;.
// &lt;table_scan&gt; is a TableScan for the target table, which is used during
//              resolving and validation. Consumers can use either the table
//              object inside it or base &lt;name_path&gt; to reference the table.</font>
class ResolvedAlterAllRowAccessPoliciesStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_ALL_ROW_ACCESS_POLICIES_STMT;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;
};
</code></pre></p>

### ResolvedCreateConstantStmt
<a id="ResolvedCreateConstantStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement creates a user-defined named constant:
// CREATE [OR REPLACE] [TEMP | TEMPORARY | PUBLIC | PRIVATE] CONSTANT
//   [IF NOT EXISTS] &lt;name_path&gt; = &lt;expression&gt;
//
// &lt;name_path&gt; is the identifier path of the named constants.
// &lt;expr&gt; is the expression that determines the type and the value of the
//        named constant. Note that &lt;expr&gt; need not be constant. Its value
//        is bound to the named constant which is then treated as
//        immutable. &lt;expr&gt; can be evaluated at the time this statement is
//        processed or later (lazy evaluation during query execution).</font>
class ResolvedCreateConstantStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_CONSTANT_STMT;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;
};
</code></pre></p>

### ResolvedCreateFunctionStmt
<a id="ResolvedCreateFunctionStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement creates a user-defined function:
//   CREATE [TEMP] FUNCTION [IF NOT EXISTS] &lt;name_path&gt; (&lt;arg_list&gt;)
//     [RETURNS &lt;return_type&gt;] [SQL SECURITY &lt;sql_security&gt;]
//     [&lt;determinism_level&gt;]
//     [[LANGUAGE &lt;language&gt;] [AS &lt;code&gt; | AS ( &lt;function_expression&gt; )]
//      | REMOTE [WITH CONNECTION &lt;connection&gt;]]
//     [OPTIONS (&lt;option_list&gt;)]
//
//   &lt;name_path&gt; is the identifier path of the function.
//   &lt;has_explicit_return_type&gt; is true iff RETURNS clause is present.
//   &lt;return_type&gt; is the return type for the function, which can be any
//          valid ZetaSQL type, including ARRAY or STRUCT. It is inferred
//          from &lt;function_expression&gt; if not explicitly set.
//          TODO: Deprecate and remove this. The return type is
//          already specified by the &lt;signature&gt;.
//   &lt;argument_name_list&gt; The names of the function arguments.
//   &lt;signature&gt; is the FunctionSignature of the created function, with all
//          options.  This can be used to create a Function to load into a
//          Catalog for future queries.
//   &lt;is_aggregate&gt; is true if this is an aggregate function.  All arguments
//          are assumed to be aggregate input arguments that may vary for
//          every row.
//   &lt;language&gt; is the programming language used by the function. This field
//          is set to &#39;SQL&#39; for SQL functions and &#39;REMOTE&#39; for remote
//          functions and otherwise to the language name specified in the
//          LANGUAGE clause. This field is set to &#39;REMOTE&#39; iff &lt;is_remote&gt; is
//          set to true.
//   &lt;code&gt; is a string literal that contains the function definition.  Some
//          engines may allow this argument to be omitted for certain types
//          of external functions. This will always be set for SQL functions.
//   &lt;aggregate_expression_list&gt; is a list of SQL aggregate functions to
//          compute prior to computing the final &lt;function_expression&gt;.
//          See below.
//   &lt;function_expression&gt; is the resolved SQL expression invoked for the
//          function. This will be unset for external language functions. For
//          non-template SQL functions, this is a resolved representation of
//          the expression in &lt;code&gt;.
//   &lt;option_list&gt; has engine-specific directives for modifying functions.
//   &lt;sql_security&gt; is the declared security mode for the function. Values
//          include &#39;INVOKER&#39;, &#39;DEFINER&#39;.
//   &lt;determinism_level&gt; is the declared determinism level of the function.
//          Values are &#39;DETERMINISTIC&#39;, &#39;NOT DETERMINISTIC&#39;, &#39;IMMUTABLE&#39;,
//          &#39;STABLE&#39;, &#39;VOLATILE&#39;.
//   &lt;is_remote&gt; is true if this is an remote function. It is true iff its
//          &lt;language&gt; is set to &#39;REMOTE&#39;.
//   &lt;connection&gt; is the identifier path of the connection object. It can be
//          only set when &lt;is_remote&gt; is true.
//
// Note that &lt;function_expression&gt; and &lt;code&gt; are both marked as IGNORABLE
// because an engine could look at either one (but might not look at both).
// An engine must look at one (and cannot ignore both, unless the function is
// remote) to be semantically valid, but there is currently no way to enforce
// that.
//
// For aggregate functions, &lt;is_aggregate&gt; will be true.
// Aggregate functions will only occur if LanguageOptions has
// FEATURE_CREATE_AGGREGATE_FUNCTION enabled.
//
// Arguments to aggregate functions must have
// &lt;FunctionSignatureArgumentTypeOptions::is_not_aggregate&gt; true or false.
// Non-aggregate arguments must be passed constant values only.
//
// For SQL aggregate functions, there will be both an
// &lt;aggregate_expression_list&gt;, with aggregate expressions to compute first,
// and then a final &lt;function_expression&gt; to compute on the results
// of the aggregates.  Each aggregate expression is a
// <a href="#ResolvedAggregateFunctionCall">ResolvedAggregateFunctionCall</a>, and may reference any input arguments.
// Each <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a> in &lt;aggregate_expression_list&gt; gives the
// aggregate expression a column id.  The final &lt;function_expression&gt; can
// reference these created aggregate columns, and any input arguments
// with &lt;argument_kind&gt;=NOT_AGGREGATE.
//
// For example, with
//   CREATE TEMP FUNCTION my_avg(x) = (SUM(x) / COUNT(x));
// we would have an &lt;aggregate_expression_list&gt; with
//   agg1#1 := SUM(<a href="#ResolvedArgumentRef">ResolvedArgumentRef</a>(x))
//   agg2#2 := COUNT(<a href="#ResolvedArgumentRef">ResolvedArgumentRef</a>(x))
// and a &lt;function_expression&gt;
//   <a href="#ResolvedColumnRef">ResolvedColumnRef</a>(agg1#1) / <a href="#ResolvedColumnRef">ResolvedColumnRef</a>(agg2#2)
//
// For example, with
//   CREATE FUNCTION scaled_avg(x,y NOT AGGREGATE) = (SUM(x) / COUNT(x) * y);
// we would have an &lt;aggregate_expression_list&gt; with
//   agg1#1 := SUM(<a href="#ResolvedArgumentRef">ResolvedArgumentRef</a>(x))
//   agg2#2 := COUNT(<a href="#ResolvedArgumentRef">ResolvedArgumentRef</a>(x))
// and a &lt;function_expression&gt;
//   <a href="#ResolvedColumnRef">ResolvedColumnRef</a>(agg1#1) / <a href="#ResolvedColumnRef">ResolvedColumnRef</a>(agg2#2) * <a href="#ResolvedArgumentRef">ResolvedArgumentRef</a>(y)
//
// When resolving a query that calls an aggregate UDF, the query will
// have a <a href="#ResolvedAggregateScan">ResolvedAggregateScan</a> that invokes the UDF function.  The engine
// should remove the UDF aggregate function from the &lt;aggregate_list&gt;, and
// instead compute the additional aggregates from the
// UDF&#39;s &lt;aggregate_expression_list&gt;, and then add an additional Project
// to compute the final &lt;function_expression&gt;, which should produce the
// value for the original <a href="#ResolvedAggregateScan">ResolvedAggregateScan</a>&#39;s computed column for the
// UDF.  Some rewrites of the <a href="#ResolvedColumn">ResolvedColumn</a> references inside the UDF will
// be required.  TODO If using <a href="#ResolvedColumn">ResolvedColumns</a> makes this renaming
// too complicated, we could switch to use <a href="#ResolvedArgumentRef">ResolvedArgumentRefs</a>, or
// something new.</font>
class ResolvedCreateFunctionStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_FUNCTION_STMT;

  // Converts the function&#39;s determinism level into a volatility.
  // Functions with unspecified/non deterministic/volatile
  // specifiers are considered volatile, functions with deterministic
  // and immutable specifiers are considered immutable and functions
  // with the stable specifier are considered stable.
  FunctionEnums::Volatility volatility() const;

  bool has_explicit_return_type() const;

  const Type* return_type() const;

  const std::vector&lt;std::string&gt;&amp; argument_name_list() const;
  int argument_name_list_size() const;
  std::string argument_name_list(int i) const;

  const FunctionSignature&amp; signature() const;

  bool is_aggregate() const;

  const std::string&amp; language() const;

  const std::string&amp; code() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; aggregate_expression_list() const;
  int aggregate_expression_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* aggregate_expression_list(int i) const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* function_expression() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a>::SqlSecurity sql_security() const;

  <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a>::DeterminismLevel determinism_level() const;

  bool is_remote() const;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;
};
</code></pre></p>

### ResolvedArgumentDef
<a id="ResolvedArgumentDef"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents an argument definition, e.g. in a function&#39;s argument
// list.
//
// &lt;name&gt; is the name of the argument; optional for DROP FUNCTION statements.
// &lt;type&gt; is the type of the argument.
// &lt;argument_kind&gt; indicates what kind of argument this is, including scalar
//         vs aggregate.  NOT_AGGREGATE means this is a non-aggregate
//         argument in an aggregate function, which can only passed constant
//         values only.
//
// NOTE: Statements that create functions now include a FunctionSignature
// directly, and an argument_name_list if applicable.  These completely
// describe the function signature, so the <a href="#ResolvedArgumentDef">ResolvedArgumentDef</a> list can
// be considered unnecessary and deprecated.
// TODO We could remove this node in the future.</font>
class ResolvedArgumentDef : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ARGUMENT_DEF;

  typedef <a href="#ResolvedArgumentDefEnum">ResolvedArgumentDefEnums</a>::ArgumentKind ArgumentKind;
  static const ArgumentKind SCALAR = <a href="#ResolvedArgumentDefEnum">ResolvedArgumentDefEnums</a>::SCALAR;
  static const ArgumentKind AGGREGATE = <a href="#ResolvedArgumentDefEnum">ResolvedArgumentDefEnums</a>::AGGREGATE;
  static const ArgumentKind NOT_AGGREGATE = <a href="#ResolvedArgumentDefEnum">ResolvedArgumentDefEnums</a>::NOT_AGGREGATE;

  const std::string&amp; name() const;

  const Type* type() const;

  <a href="#ResolvedArgumentDef">ResolvedArgumentDef</a>::ArgumentKind argument_kind() const;
};
</code></pre></p>

### ResolvedArgumentRef
<a id="ResolvedArgumentRef"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents an argument reference, e.g. in a function&#39;s body.
// &lt;name&gt; is the name of the argument.
// &lt;argument_kind&gt; is the ArgumentKind from the <a href="#ResolvedArgumentDef">ResolvedArgumentDef</a>.
//         For scalar functions, this is always SCALAR.
//         For aggregate functions, it can be AGGREGATE or NOT_AGGREGATE.
//         If NOT_AGGREGATE, then this is a non-aggregate argument
//         to an aggregate function, which has one constant value
//         for the entire function call (over all rows in all groups).
//         (This is copied from the <a href="#ResolvedArgumentDef">ResolvedArgumentDef</a> for convenience.)</font>
class ResolvedArgumentRef : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ARGUMENT_REF;

  typedef <a href="#ResolvedArgumentDefEnum">ResolvedArgumentDefEnums</a>::ArgumentKind ArgumentKind;
  static const ArgumentKind SCALAR = <a href="#ResolvedArgumentDefEnum">ResolvedArgumentDefEnums</a>::SCALAR;
  static const ArgumentKind AGGREGATE = <a href="#ResolvedArgumentDefEnum">ResolvedArgumentDefEnums</a>::AGGREGATE;
  static const ArgumentKind NOT_AGGREGATE = <a href="#ResolvedArgumentDefEnum">ResolvedArgumentDefEnums</a>::NOT_AGGREGATE;

  const std::string&amp; name() const;

  <a href="#ResolvedArgumentDef">ResolvedArgumentDef</a>::ArgumentKind argument_kind() const;
};
</code></pre></p>

### ResolvedCreateTableFunctionStmt
<a id="ResolvedCreateTableFunctionStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement creates a user-defined table-valued function:
//   CREATE [TEMP] TABLE FUNCTION [IF NOT EXISTS]
//     &lt;name_path&gt; (&lt;argument_name_list&gt;)
//     [RETURNS &lt;return_type&gt;]
//     [OPTIONS (&lt;option_list&gt;)]
//     [LANGUAGE &lt;language&gt;]
//     [AS &lt;code&gt; | AS ( &lt;query&gt; )]
//
//   &lt;argument_name_list&gt; contains the names of the function arguments.
//   &lt;signature&gt; is the FunctionSignature of the created function, with all
//          options.  This can be used to create a Function to load into a
//          Catalog for future queries.
//   &lt;option_list&gt; has engine-specific directives for modifying functions.
//   &lt;language&gt; is the programming language used by the function. This field
//          is set to &#39;SQL&#39; for SQL functions, to the language name specified
//          in the LANGUAGE clause if present, and to &#39;UNDECLARED&#39; if both
//          the LANGUAGE clause and query are not present.
//   &lt;code&gt; is an optional string literal that contains the function
//          definition.  Some engines may allow this argument to be omitted
//          for certain types of external functions.  This will always be set
//          for SQL functions.
//   &lt;query&gt; is the SQL query invoked for the function.  This will be unset
//          for external language functions. For non-templated SQL functions,
//          this is a resolved representation of the query in &lt;code&gt;.
//   &lt;output_column_list&gt; is the list of resolved output
//          columns returned by the table-valued function.
//   &lt;is_value_table&gt; If true, this function returns a value table.
//          Rather than producing rows with named columns, it produces
//          rows with a single unnamed value type. &lt;output_column_list&gt; will
//          have exactly one anonymous column (with no name).
//          See (broken link).
//   &lt;sql_security&gt; is the declared security mode for the function. Values
//          include &#39;INVOKER&#39;, &#39;DEFINER&#39;.
//   &lt;has_explicit_return_schema&gt; is true iff RETURNS clause is present.
//
// ----------------------
// Table-Valued Functions
// ----------------------
//
// This is a statement to create a new table-valued function. Each
// table-valued function returns an entire table as output instead of a
// single scalar value. Table-valued functions can only be created if
// LanguageOptions has FEATURE_CREATE_TABLE_FUNCTION enabled.
//
// For SQL table-valued functions that include a defined SQL body, the
// &lt;query&gt; is non-NULL and contains the resolved SQL body.
// In this case, &lt;output_column_list&gt; contains a list of the
// output columns of the SQL body. The &lt;query&gt; uses
// <a href="#ResolvedArgumentRef">ResolvedArgumentRefs</a> to refer to scalar arguments and
// <a href="#ResolvedRelationArgumentScan">ResolvedRelationArgumentScans</a> to refer to relation arguments.
//
// The table-valued function may include RETURNS TABLE&lt;...&gt; to explicitly
// specify a schema for the output table returned by the function. If the
// function declaration includes a SQL body, then the names and types of the
// output columns of the corresponding &lt;query&gt; will have been
// coerced to exactly match 1:1 with the names and types of the columns
// specified in the RETURNS TABLE&lt;...&gt; section.
//
// When resolving a query that calls a table-valued function, the query will
// have a <a href="#ResolvedTVFScan">ResolvedTVFScan</a> that invokes the function.
//
// Value tables: If the function declaration includes a value-table
// parameter, this is written as an argument of type &#34;TABLE&#34; where the table
// contains a single anonymous column with a type but no name. In this case,
// calls to the function may pass a (regular or value) table with a single
// (named or unnamed) column for any of these parameters, and ZetaSQL
// accepts these arguments as long as the column type matches.
//
// Similarly, if the CREATE TABLE FUNCTION statement includes a &#34;RETURNS
// TABLE&#34; section with a single column with no name, then this defines a
// value-table return type. The function then returns a value table as long
// as the SQL body returns a single column whose type matches (independent of
// whether the SQL body result is a value table or not, and whether the
// returned column is named or unnamed).
//
// --------------------------------
// Templated Table-Valued Functions
// --------------------------------
//
// ZetaSQL supports table-valued function declarations with parameters of
// type ANY TABLE. This type indicates that any schema is valid for tables
// passed for this parameter. In this case:
//
// * the IsTemplated() method of the &lt;signature&gt; field returns true,
// * the &lt;output_column_list&gt; field is empty,
// * the &lt;is_value_table&gt; field is set to a default value of false (since
//   ZetaSQL cannot analyze the function body in the presence of templated
//   parameters, it is not possible to detect this property yet),
//
// TODO: Update this description once ZetaSQL supports more types
// of templated function parameters. Currently only ANY TABLE is supported.</font>
class ResolvedCreateTableFunctionStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_TABLE_FUNCTION_STMT;

  const std::vector&lt;std::string&gt;&amp; argument_name_list() const;
  int argument_name_list_size() const;
  std::string argument_name_list(int i) const;

  const FunctionSignature&amp; signature() const;

  bool has_explicit_return_schema() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::string&amp; language() const;

  const std::string&amp; code() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* query() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

  bool is_value_table() const;

  <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a>::SqlSecurity sql_security() const;
};
</code></pre></p>

### ResolvedRelationArgumentScan
<a id="ResolvedRelationArgumentScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a relation argument reference in a table-valued function&#39;s
// body. The &#39;column_list&#39; of this <a href="#ResolvedScan">ResolvedScan</a> includes column names from
// the relation argument in the table-valued function signature.</font>
class ResolvedRelationArgumentScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RELATION_ARGUMENT_SCAN;

<font color="brown">  // This is the name of the relation argument for the table-valued
  // function.  It is used to match this relation argument reference in
  // a TVF SQL function body with one of possibly several relation
  // arguments in the TVF call.</font>
  const std::string&amp; name() const;

<font color="brown">  // If true, the result of this query is a value table. Rather than
  // producing rows with named columns, it produces rows with a single
  // unnamed value type. See (broken link).</font>
  bool is_value_table() const;
};
</code></pre></p>

### ResolvedArgumentList
<a id="ResolvedArgumentList"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: [ (&lt;arg_list&gt;) ];
//
// &lt;arg_list&gt; is an optional list of parameters.  If given, each parameter
//            may consist of a type, or a name and a type.
//
// NOTE: This can be considered deprecated in favor of the FunctionSignature
//       stored directly in the statement.
//
// NOTE: <a href="#ResolvedArgumentList">ResolvedArgumentList</a> is not related to the <a href="#ResolvedArgument">ResolvedArgument</a> class,
//       which just exists to organize node classes.</font>
class ResolvedArgumentList : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ARGUMENT_LIST;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedArgumentDef">ResolvedArgumentDef</a>&gt;&gt;&amp; arg_list() const;
  int arg_list_size() const;
  const <a href="#ResolvedArgumentDef">ResolvedArgumentDef</a>* arg_list(int i) const;
};
</code></pre></p>

### ResolvedFunctionSignatureHolder
<a id="ResolvedFunctionSignatureHolder"></a>

<p><pre><code class="lang-c++"><font color="brown">// This wrapper is used for an optional FunctionSignature.</font>
class ResolvedFunctionSignatureHolder : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_FUNCTION_SIGNATURE_HOLDER;

  const FunctionSignature&amp; signature() const;
};
</code></pre></p>

### ResolvedDropFunctionStmt
<a id="ResolvedDropFunctionStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: DROP FUNCTION [IF EXISTS] &lt;name_path&gt;
//   [ (&lt;arguments&gt;) ];
//
// &lt;is_if_exists&gt; silently ignore the &#34;name_path does not exist&#34; error.
// &lt;name_path&gt; is the identifier path of the function to be dropped.
// &lt;arguments&gt; is an optional list of parameters.  If given, each parameter
//            may consist of a type, or a name and a type.  The name is
//            disregarded, and is allowed to permit copy-paste from CREATE
//            FUNCTION statements.
// &lt;signature&gt; is the signature of the dropped function.  Argument names and
//            argument options are ignored because only the types matter
//            for matching signatures in DROP FUNCTION.  The return type
//            in this signature will always be &lt;void&gt;, since return type
//            is ignored when matching signatures for DROP.
//            TODO &lt;arguments&gt; could be deprecated in favor of this.</font>
class ResolvedDropFunctionStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_FUNCTION_STMT;

  bool is_if_exists() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

<font color="brown">  // NOTE: arguments for DROP FUNCTION statements are matched only on
  // type; names for any arguments in <a href="#ResolvedArgumentList">ResolvedArgumentList</a> will be set
  // to the empty string irrespective of whether or not argument names
  // were given in the DROP FUNCTION statement.</font>
  const <a href="#ResolvedArgumentList">ResolvedArgumentList</a>* arguments() const;

<font color="brown">  // NOTE: arguments for DROP FUNCTION statements are matched only on
  // type; names are irrelevant, so no argument names are saved to use
  // with this signature.  Additionally, the return type will always be
  // &lt;void&gt;, since return types are ignored for DROP FUNCTION.</font>
  const <a href="#ResolvedFunctionSignatureHolder">ResolvedFunctionSignatureHolder</a>* signature() const;
};
</code></pre></p>

### ResolvedDropTableFunctionStmt
<a id="ResolvedDropTableFunctionStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: DROP TABLE FUNCTION [IF EXISTS] &lt;name_path&gt;;
//
// &lt;is_if_exists&gt; silently ignore the &#34;name_path does not exist&#34; error.
// &lt;name_path&gt; is the identifier path of the function to be dropped.</font>
class ResolvedDropTableFunctionStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DROP_TABLE_FUNCTION_STMT;

  bool is_if_exists() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;
};
</code></pre></p>

### ResolvedCallStmt
<a id="ResolvedCallStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: CALL &lt;procedure&gt;;
//
// &lt;procedure&gt; Procedure to call.
// &lt;signature&gt; <a href="#Resolved">Resolved</a> FunctionSignature for this procedure.
// &lt;argument_list&gt; Procedure arguments.</font>
class ResolvedCallStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CALL_STMT;

  const Procedure* procedure() const;

  const FunctionSignature&amp; signature() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; argument_list() const;
  int argument_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* argument_list(int i) const;
};
</code></pre></p>

### ResolvedImportStmt
<a id="ResolvedImportStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: IMPORT &lt;import_kind&gt;
//                              [&lt;name_path&gt; [AS|INTO &lt;alias_path&gt;]
//                              |&lt;file_path&gt;]
//                        [&lt;option_list&gt;];
//
// &lt;import_kind&gt; The type of the object, currently supports MODULE and PROTO.
// &lt;name_path&gt;   The identifier path of the object to import, e.g., foo.bar,
//               used in IMPORT MODULE statement.
// &lt;file_path&gt;   The file path of the object to import, e.g., &#34;file.proto&#34;,
//               used in IMPORT PROTO statement.
// &lt;alias_path&gt;  The AS alias path for the object.
// &lt;into_alias_path&gt;  The INTO alias path for the object.
// &lt;option_list&gt; Engine-specific directives for the import.
//
// Either &lt;name_path&gt; or &lt;file_path&gt; will be populated but not both.
//       &lt;name_path&gt; will be populated for IMPORT MODULE.
//       &lt;file_path&gt; will be populated for IMPORT PROTO.
//
// At most one of &lt;alias_path&gt; or &lt;into_alias_path&gt; will be populated.
//       &lt;alias_path&gt; may be populated for IMPORT MODULE.
//       &lt;into_alias_path&gt; may be populated for IMPORT PROTO.
//
// IMPORT MODULE and IMPORT PROTO both support options.
//
// See (broken link) for more detail on IMPORT MODULE.
// See (broken link) for more detail on IMPORT PROTO.</font>
class ResolvedImportStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_IMPORT_STMT;

  typedef <a href="#ResolvedImportStmtEnum">ResolvedImportStmtEnums</a>::ImportKind ImportKind;
  static const ImportKind MODULE = <a href="#ResolvedImportStmtEnum">ResolvedImportStmtEnums</a>::MODULE;
  static const ImportKind PROTO = <a href="#ResolvedImportStmtEnum">ResolvedImportStmtEnums</a>::PROTO;
  static const ImportKind __ImportKind__switch_must_have_a_default__ = <a href="#ResolvedImportStmtEnum">ResolvedImportStmtEnums</a>::__ImportKind__switch_must_have_a_default__;

  std::string GetImportKindString() const;
  static std::string ImportKindToString(ImportKind kind);

  <a href="#ResolvedImportStmt">ResolvedImportStmt</a>::ImportKind import_kind() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::string&amp; file_path() const;

  const std::vector&lt;std::string&gt;&amp; alias_path() const;
  int alias_path_size() const;
  std::string alias_path(int i) const;

  const std::vector&lt;std::string&gt;&amp; into_alias_path() const;
  int into_alias_path_size() const;
  std::string into_alias_path(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedModuleStmt
<a id="ResolvedModuleStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement: MODULE &lt;name_path&gt; [&lt;option_list&gt;];
//
// &lt;name_path&gt; is the identifier path of the module.
// &lt;option_list&gt; Engine-specific directives for the module statement.
//
// See (broken link) for more detail on MODULEs.</font>
class ResolvedModuleStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MODULE_STMT;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedAggregateHavingModifier
<a id="ResolvedAggregateHavingModifier"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a HAVING MAX or HAVING MIN modifier in an aggregate
// expression. If an aggregate has arguments (x HAVING {MAX/MIN} y),
// the aggregate will be computed over only the x values in the rows with the
// maximal/minimal values of y.
//
// &lt;kind&gt; the MAX/MIN kind of this HAVING
// &lt;having_expr&gt; the HAVING expression (y in the above example)</font>
class ResolvedAggregateHavingModifier : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_AGGREGATE_HAVING_MODIFIER;

  typedef <a href="#ResolvedAggregateHavingModifierEnum">ResolvedAggregateHavingModifierEnums</a>::HavingModifierKind HavingModifierKind;
  static const HavingModifierKind INVALID = <a href="#ResolvedAggregateHavingModifierEnum">ResolvedAggregateHavingModifierEnums</a>::INVALID;
  static const HavingModifierKind MAX = <a href="#ResolvedAggregateHavingModifierEnum">ResolvedAggregateHavingModifierEnums</a>::MAX;
  static const HavingModifierKind MIN = <a href="#ResolvedAggregateHavingModifierEnum">ResolvedAggregateHavingModifierEnums</a>::MIN;

  std::string GetHavingModifierKindString() const;
  static std::string HavingModifierKindToString(HavingModifierKind kind);

  <a href="#ResolvedAggregateHavingModifier">ResolvedAggregateHavingModifier</a>::HavingModifierKind kind() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* having_expr() const;
};
</code></pre></p>

### ResolvedCreateMaterializedViewStmt
<a id="ResolvedCreateMaterializedViewStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   CREATE MATERIALIZED VIEW &lt;name&gt; [(...)] [PARTITION BY expr, ...]
//   [CLUSTER BY expr, ...] [OPTIONS (...)]
//   {AS SELECT ... | AS REPLICA OF ...}
//
// &lt;partition_by_list&gt; specifies the partitioning expressions for the
//                     materialized view.
// &lt;cluster_by_list&gt; specifies the clustering expressions for the
//                   materialized view.</font>
class ResolvedCreateMaterializedViewStmt : public <a href="#ResolvedCreateViewBase">ResolvedCreateViewBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_MATERIALIZED_VIEW_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; partition_by_list() const;
  int partition_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* partition_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; cluster_by_list() const;
  int cluster_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* cluster_by_list(int i) const;

  const <a href="#ResolvedScan">ResolvedScan</a>* replica_source() const;
};
</code></pre></p>

### ResolvedCreateApproxViewStmt
<a id="ResolvedCreateApproxViewStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement creates an APPROX VIEW:
//   CREATE APPROX VIEW &lt;name&gt; [(...)] [OPTIONS (...)] AS SELECT ...
//
// An APPROX VIEW provides approximate results from the view query, as
// opposed to a regular view which returns exact results from its view query.
// APPROX VIEW is a generic operator whose behavior is implementation-defined
// based on the OPTIONS and query engines.
//
// See (broken link) for more details on APPROX VIEW.</font>
class ResolvedCreateApproxViewStmt : public <a href="#ResolvedCreateViewBase">ResolvedCreateViewBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_APPROX_VIEW_STMT;

};
</code></pre></p>

### ResolvedCreateProcedureStmt
<a id="ResolvedCreateProcedureStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement creates a user-defined procedure:
// CREATE [OR REPLACE] [TEMP] PROCEDURE [IF NOT EXISTS] &lt;name_path&gt;
// (&lt;arg_list&gt;) [EXTERNAL SECURITY &lt;external_security&gt;]
// [WITH CONNECTION &lt;connection&gt;] [OPTIONS (&lt;option_list&gt;)]
// [BEGIN &lt;procedure_body&gt; END | LANGUAGE &lt;language&gt; [AS &lt;code&gt;]];
//
// &lt;name_path&gt; is the identifier path of the procedure.
// &lt;argument_name_list&gt; The names of the function arguments.
// &lt;signature&gt; is the FunctionSignature of the created procedure, with all
//        options.  This can be used to create a procedure to load into a
//        Catalog for future queries.
// &lt;external_security&gt; is the external security mode for the created
//        procedure. Values include &#39;INVOKER&#39;, &#39;DEFINER&#39;.
// &lt;connection&gt; is the identifier path of the connection object.
// &lt;option_list&gt; has engine-specific directives for modifying procedures.
// &lt;procedure_body&gt; is a string literal that contains the SQL procedure
//        body. It includes everything from the BEGIN keyword to the END
//        keyword, inclusive. This will always be set for SQL procedures
//        and unset for external language procedures.
//
//        The resolver will perform some basic validation on the procedure
//        body, for example, verifying that DECLARE statements are in the
//        proper position, and that variables are not declared more than
//        once, but any validation that requires the catalog (including
//        generating resolved tree nodes for individual statements) is
//        deferred until the procedure is actually called.  This deferral
//        makes it possible to define a procedure which references a table
//        or routine that does not yet exist, so long as the entity is
//        created before the procedure is called.
// &lt;language&gt; is the programming language used by the procedure. This field
//        is set to the language name specified in the LANGUAGE clause.
//        Exactly one of &lt;procedure_body&gt; and &lt;language&gt; must be set.
// &lt;code&gt; is a string literal that contains the external language procedure
//        definition. It is allowed only if &lt;language&gt; is set.</font>
class ResolvedCreateProcedureStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_PROCEDURE_STMT;

  const std::vector&lt;std::string&gt;&amp; argument_name_list() const;
  int argument_name_list_size() const;
  std::string argument_name_list(int i) const;

  const FunctionSignature&amp; signature() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::string&amp; procedure_body() const;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;

  const std::string&amp; language() const;

  const std::string&amp; code() const;

  <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a>::SqlSecurity external_security() const;
};
</code></pre></p>

### ResolvedExecuteImmediateArgument
<a id="ResolvedExecuteImmediateArgument"></a>

<p><pre><code class="lang-c++"><font color="brown">// An argument for an EXECUTE IMMEDIATE&#39;s USING clause.
//
// &lt;name&gt; an optional name for this expression
// &lt;expression&gt; the expression&#39;s value</font>
class ResolvedExecuteImmediateArgument : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXECUTE_IMMEDIATE_ARGUMENT;

  const std::string&amp; name() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expression() const;
};
</code></pre></p>

### ResolvedExecuteImmediateStmt
<a id="ResolvedExecuteImmediateStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// An EXECUTE IMMEDIATE statement
// EXECUTE IMMEDIATE &lt;sql&gt; [&lt;into_clause&gt;] [&lt;using_clause&gt;]
//
// &lt;sql&gt; a string expression indicating a SQL statement to be dynamically
//   executed
// &lt;into_identifier_list&gt; the identifiers whose values should be set.
//   Identifiers should not be repeated in the list.
// &lt;using_argument_list&gt; a list of arguments to supply for dynamic SQL.
//    The arguments should either be all named or all unnamed, and
//    arguments should not be repeated in the list.</font>
class ResolvedExecuteImmediateStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_EXECUTE_IMMEDIATE_STMT;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* sql() const;

  const std::vector&lt;std::string&gt;&amp; into_identifier_list() const;
  int into_identifier_list_size() const;
  std::string into_identifier_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExecuteImmediateArgument">ResolvedExecuteImmediateArgument</a>&gt;&gt;&amp; using_argument_list() const;
  int using_argument_list_size() const;
  const <a href="#ResolvedExecuteImmediateArgument">ResolvedExecuteImmediateArgument</a>* using_argument_list(int i) const;
};
</code></pre></p>

### ResolvedAssignmentStmt
<a id="ResolvedAssignmentStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// An assignment of a value to another value.</font>
class ResolvedAssignmentStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ASSIGNMENT_STMT;

<font color="brown">  // Target of the assignment.  Currently, this will be
  // either <a href="#ResolvedSystemVariable">ResolvedSystemVariable</a>, or a chain of ResolveGetField
  // operations around it.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* target() const;

<font color="brown">  // Value to assign into the target.  This will always be
  // the same type as the target.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;
};
</code></pre></p>

### ResolvedCreateEntityStmt
<a id="ResolvedCreateEntityStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// (broken link)
// This statement:
// CREATE [OR REPLACE] &lt;entity_type&gt; [IF NOT EXISTS] &lt;path_expression&gt;
// [OPTIONS &lt;option_list&gt;]
// [AS &lt;entity_body_json&gt;];
//
// At most one of &lt;entity_body_json&gt;, &lt;entity_body_text&gt; can be non-empty.
//
// &lt;entity_type&gt; engine-specific entity type to be created.
// &lt;entity_body_json&gt; is a JSON literal to be interpreted by engine.
// &lt;entity_body_text&gt; is a text literal to be interpreted by engine.
// &lt;option_list&gt; has engine-specific directives for how to
//               create this entity.</font>
class ResolvedCreateEntityStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_ENTITY_STMT;

  const std::string&amp; entity_type() const;

  const std::string&amp; entity_body_json() const;

  const std::string&amp; entity_body_text() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedAlterEntityStmt
<a id="ResolvedAlterEntityStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// (broken link)
// This statement:
// ALTER &lt;entity_type&gt; [IF EXISTS]  &lt;path_expression&gt;
// &lt;generic_alter_action&gt;, ...
//
// &lt;entity_type&gt; engine-specific entity type to be altered.</font>
class ResolvedAlterEntityStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_ENTITY_STMT;

  const std::string&amp; entity_type() const;
};
</code></pre></p>

### ResolvedPivotColumn
<a id="ResolvedPivotColumn"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents a column produced by aggregating a particular pivot
// expression over a subset of the input for which the FOR expression
// matches a particular pivot value. This aggregation is further
// broken up by the enclosing <a href="#ResolvedPivotScan">ResolvedPivotScan</a>&#39;s groupby columns,
// with each distinct value of the groupby columns producing a
// separate row in the output.
//
// In any pivot column, &#39;c&#39;,
// &#39;c&#39; is produced by aggregating pivot expression
//   &lt;pivot_expr_list[c.pivot_expr_index]&gt;
// over input rows such that
//   &lt;for_expr&gt; IS NOT DISTINCT FROM
//   &lt;pivot_value_list[c.pivot_value_index]&gt;</font>
class ResolvedPivotColumn : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PIVOT_COLUMN;

<font color="brown">  // The output column used to represent the result of the pivot.</font>
  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; column() const;

<font color="brown">  // Specifies the index of the pivot expression
  // within the enclosing <a href="#ResolvedPivotScan">ResolvedPivotScan</a>&#39;s &lt;pivot_expr_list&gt; used to
  // determine the result of the column.</font>
  int pivot_expr_index() const;

<font color="brown">  // Specifies the index of the pivot value within
  // the enclosing <a href="#ResolvedPivotScan">ResolvedPivotScan</a>&#39;s &lt;pivot_value_list&gt; used to
  // determine the subset of input rows the pivot expression should be
  // evaluated over.</font>
  int pivot_value_index() const;
};
</code></pre></p>

### ResolvedPivotScan
<a id="ResolvedPivotScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// A scan produced by the following SQL fragment:
//   &lt;input_scan&gt; PIVOT(... FOR ... IN (...))
//
// The column list of this scan consists of a subset of columns from
// &lt;group_by_column_list&gt; and &lt;pivot_column_list&gt;.
//
// Details: (broken link)</font>
class ResolvedPivotScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PIVOT_SCAN;

<font color="brown">  // Input to the PIVOT clause</font>
  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

<font color="brown">  // The columns from &lt;input_scan&gt; to group by.
  // The output will have one row for each distinct combination of
  // values for all grouping columns. (There will be one output row if
  // this list is empty.)
  //
  // Each element is a <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>. The expression is always
  // a <a href="#ResolvedColumnRef">ResolvedColumnRef</a> that references a column from &lt;input_scan&gt;.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; group_by_list() const;
  int group_by_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* group_by_list(int i) const;

<font color="brown">  // Pivot expressions which aggregate over the subset of &lt;input_scan&gt;
  // where &lt;for_expr&gt; matches each value in &lt;pivot_value_list&gt;, plus
  // all columns in &lt;group_by_list&gt;.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; pivot_expr_list() const;
  int pivot_expr_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* pivot_expr_list(int i) const;

<font color="brown">  // Expression following the FOR keyword, to be evaluated over each row
  // in &lt;input_scan&gt;. This value is compared with each value in
  // &lt;pivot_value_list&gt; to determine which columns the aggregation
  // results of &lt;pivot_expr_list&gt; should go to.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* for_expr() const;

<font color="brown">  // A list of pivot values within the IN list, to be compared against
  // the result of &lt;for_expr&gt; for each row in the input table. Each
  // pivot value generates a distinct column in the output for each
  // pivot expression, representing the result of the corresponding
  // pivot expression over the subset of input where &lt;for_expr&gt; matches
  // this pivot value.
  //
  // All pivot values in this list must have the same type as
  // &lt;for_expr&gt; and must be constant.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; pivot_value_list() const;
  int pivot_value_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* pivot_value_list(int i) const;

<font color="brown">  // List of columns created to store the output pivot columns.
  // Each is computed using one of pivot_expr_list and one of
  // pivot_value_list.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedPivotColumn">ResolvedPivotColumn</a>&gt;&gt;&amp; pivot_column_list() const;
  int pivot_column_list_size() const;
  const <a href="#ResolvedPivotColumn">ResolvedPivotColumn</a>* pivot_column_list(int i) const;
};
</code></pre></p>

### ResolvedReturningClause
<a id="ResolvedReturningClause"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents the returning clause on a DML statement.</font>
class ResolvedReturningClause : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_RETURNING_CLAUSE;

<font color="brown">  // Specifies the columns in the returned output row with column
  // names. It can reference columns from the target table scan
  // &lt;table_scan&gt; from INSERT/DELETE/UPDATE statements. Also this list
  // can have columns computed in the &lt;expr_list&gt; or an &lt;action_column&gt;
  // as the last column.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

<font color="brown">  // Represents the WITH ACTION column in &lt;output_column_list&gt; as a
  // string type column. There are four valid values for this action
  // column: &#34;INSERT&#34;, &#34;REPLACE&#34;, &#34;UPDATE&#34;, and &#34;DELETE&#34;.</font>
  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* action_column() const;

<font color="brown">  // Represents the computed expressions so they can be referenced in
  // &lt;output_column_list&gt;. Worth noting, it can&#39;t see &lt;action_column&gt;
  // and can only access columns from the DML statement target table.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; expr_list() const;
  int expr_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* expr_list(int i) const;
};
</code></pre></p>

### ResolvedUnpivotArg
<a id="ResolvedUnpivotArg"></a>

<p><pre><code class="lang-c++"><font color="brown">// A column group in the UNPIVOT IN clause.
//
// Example:
//   &#39;a&#39; in &#39;UNPIVOT(x FOR z IN (a , b , c))&#39;
//   or &#39;(a , b)&#39; in &#39;UNPIVOT((x , y) FOR z IN ((a , b), (c , d))&#39;</font>
class ResolvedUnpivotArg : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UNPIVOT_ARG;

<font color="brown">  // A list of columns referencing an output column of the &lt;input_scan&gt;
  // of <a href="#ResolvedUnpivotScan">ResolvedUnpivotScan</a>. The size of this vector is
  // the same as &lt;value_column_list&gt;.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; column_list() const;
  int column_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* column_list(int i) const;
};
</code></pre></p>

### ResolvedUnpivotScan
<a id="ResolvedUnpivotScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// A scan produced by the following SQL fragment:
// &lt;input_scan&gt; UNPIVOT(&lt;value_column_list&gt;
//   FOR &lt;label_column&gt;
//   IN (&lt;unpivot_arg_list&gt;))
//
// size of (&lt;unpivot_arg_list&gt;[i], i.e. column groups inside
// &lt;unpivot_arg_list&gt;)
//   = size of (&lt;value_column_list&gt;)
//   = Let&#39;s say num_value_columns
//
// size of (&lt;unpivot_arg_list&gt;)
//   = size of (&lt;label_list&gt;)
//   = Let&#39;s say num_args
//
// Here is how output rows are generated --
// for each input row :
//   for arg_index = 0 .. (num_args - 1) :
//     output a row with the original columns from &lt;input_scan&gt;
//
//       plus
//     arg = &lt;unpivot_arg_list&gt;[arg_index]
//     for value_column_index = 0 .. (num_value_columns - 1) :
//       output_value_column = &lt;value_column_list&gt;[value_column_index]
//       input_arg_column = arg [value_column_index]
//       output_value_column = input_arg_column
//
//       plus
//     &lt;label_column&gt; = &lt;label_list&gt;[arg_index]
//
//
// Hence the total number of rows generated in the output =
//   input rows * size of &lt;unpivot_arg_list&gt;
//
// For all column groups inside &lt;unpivot_arg_list&gt;, datatype of
// columns at the same position in the vector must be equivalent, and
// also equivalent to the datatype of the column at the same position in
// &lt;value_column_list&gt;.
// I.e. in the above pseudocode, datatypes must be equivalent for
// output_value_column and input_arg_column.
// Datatype of &lt;label_column&gt; must be the same as datatype of
// &lt;label_list&gt; and can be string or int64.
//
// Details: (broken link)</font>
class ResolvedUnpivotScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UNPIVOT_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

<font color="brown">  // This is a list of one or more new columns added by UNPIVOT.
  // These new column(s) store the value of input columns that are in
  // the UNPIVOT IN clause.</font>
  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; value_column_list() const;
  int value_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> value_column_list(int i) const;

<font color="brown">  // This is a new column added in the output for storing labels for
  // input columns groups that are present in the IN clause. Its
  // values are taken from &lt;label_list&gt;.</font>
  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; label_column() const;

<font color="brown">  // String or integer literal for each column group in
  // &lt;unpivot_arg_list&gt;.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedLiteral">ResolvedLiteral</a>&gt;&gt;&amp; label_list() const;
  int label_list_size() const;
  const <a href="#ResolvedLiteral">ResolvedLiteral</a>* label_list(int i) const;

<font color="brown">  // The list of groups of columns in the UNPIVOT IN list. Each group
  // contains references to the output columns of &lt;input_scan&gt; of the
  // <a href="#ResolvedUnpivotScan">ResolvedUnpivotScan</a>. The values of these columns are stored in the
  // new &lt;value_column_list&gt; and the column group labels/names
  // in the &lt;label_column&gt;.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUnpivotArg">ResolvedUnpivotArg</a>&gt;&gt;&amp; unpivot_arg_list() const;
  int unpivot_arg_list_size() const;
  const <a href="#ResolvedUnpivotArg">ResolvedUnpivotArg</a>* unpivot_arg_list(int i) const;

<font color="brown">  // The columns from &lt;input_scan&gt; that are not unpivoted in UNPIVOT
  // IN clause. Columns in &lt;projected_input_column_list&gt; and
  // &lt;unpivot_arg_list&gt; are mutually exclusive and their union is the
  // complete set of columns in the unpivot input-source.
  //
  // The expression of each <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a> is a
  // <a href="#ResolvedColumnRef">ResolvedColumnRef</a> that references a column from &lt;input_scan&gt;.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; projected_input_column_list() const;
  int projected_input_column_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* projected_input_column_list(int i) const;

<font color="brown">  // Whether we need to include the rows from output where ALL columns
  // from &lt;value_column_list&gt; are null.</font>
  bool include_nulls() const;
};
</code></pre></p>

### ResolvedMatchRecognizeScan
<a id="ResolvedMatchRecognizeScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// A scan for row pattern recognition (the MATCH_RECOGNIZE clause).
// See (broken link) for details.</font>
class ResolvedMatchRecognizeScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MATCH_RECOGNIZE_SCAN;

  typedef <a href="#ResolvedMatchRecognizeScanEnum">ResolvedMatchRecognizeScanEnums</a>::AfterMatchSkipMode AfterMatchSkipMode;
  static const AfterMatchSkipMode AFTER_MATCH_SKIP_MODE_UNSPECIFIED = <a href="#ResolvedMatchRecognizeScanEnum">ResolvedMatchRecognizeScanEnums</a>::AFTER_MATCH_SKIP_MODE_UNSPECIFIED;
  static const AfterMatchSkipMode END_OF_MATCH = <a href="#ResolvedMatchRecognizeScanEnum">ResolvedMatchRecognizeScanEnums</a>::END_OF_MATCH;
  static const AfterMatchSkipMode NEXT_ROW = <a href="#ResolvedMatchRecognizeScanEnum">ResolvedMatchRecognizeScanEnums</a>::NEXT_ROW;

  // TODO: Remove this once callers are migrated.
  const <a href="#ResolvedWindowPartitioning">ResolvedWindowPartitioning</a>* partition_by() const {
    return analytic_function_group_list(0)-&gt;partition_by();
  }
  // TODO: Remove this once callers are migrated.
  const <a href="#ResolvedWindowOrdering">ResolvedWindowOrdering</a>* order_by() const {
    return analytic_function_group_list(0)-&gt;order_by();
  }

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

<font color="brown">  // Currently, there is always exactly one group, which holds the
  // PARTITION BY and ORDER BY for this MATCH_RECOGNIZE clause. It is
  // a list to avoid a breaking change in the future, if we decide to
  // support other windows on the DEFINE clause, e.g. FIRST_VALUE().
  //
  // If the main group&#39;s `partition_by` is null, the whole input table
  // is a single partition.
  //
  // Partitioning columns are always part of the scan&#39;s output columns,
  // along with the measures.
  //
  // ORDER BY does not allow ordinals, same as with window functions.
  //
  // The single analytic group defines the partitioning and ordering
  // for this MATCH_RECOGNIZE operation:
  // 1. Pattern matching occurs on individual partitions, just like
  //    windowing functions. If it has no partitioning columns, the
  //    whole input table is a single partition.
  //
  // 2. Its ordering similarly defines the row order for this pattern
  //    matching operation.
  //    The ordering list can never be empty.
  //    Collation and hints are supported, just like in window
  //    specification.
  //
  // When there are calls to the navigation operations PREV() and
  // NEXT() in the DEFINE clause, they are represented by
  // <a href="#ResolvedAnalyticFunctionCall">ResolvedAnalyticFunctionCalls</a> to LAG() and LEAD() (respectively).
  // The group remains empty if there are no such calls.
  //
  // These analytic calls are placed in the group to indicate that they
  // all see the exact same row order of the matching operation, even
  // when the ordering is partial (e.g. ties or non-determinism).
  //
  // See (broken link) for details.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>&gt;&gt;&amp; analytic_function_group_list() const;
  int analytic_function_group_list_size() const;
  const <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>* analytic_function_group_list(int i) const;

<font color="brown">  // The pattern variable definitions. This list is never empty, and
  // variable names must be unique (ignoring case).</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedMatchRecognizeVariableDefinition">ResolvedMatchRecognizeVariableDefinition</a>&gt;&gt;&amp; pattern_variable_definition_list() const;
  int pattern_variable_definition_list_size() const;
  const <a href="#ResolvedMatchRecognizeVariableDefinition">ResolvedMatchRecognizeVariableDefinition</a>* pattern_variable_definition_list(int i) const;

<font color="brown">  // The pattern expression to use when matching rows. All row pattern
  // variables referenced in this expression must be defined in
  // pattern_variable_definition_list.</font>
  const <a href="#ResolvedMatchRecognizePatternExpr">ResolvedMatchRecognizePatternExpr</a>* pattern() const;

<font color="brown">  // Represents the AFTER MATCH SKIP clause. Can never be
  // &#39;UNSPECIFIED&#39;.
  // See (broken link) for details.</font>
  <a href="#ResolvedMatchRecognizeScan">ResolvedMatchRecognizeScan</a>::AfterMatchSkipMode after_match_skip_mode() const;

<font color="brown">  // The outputs as defined in the MEASURES clause.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedMeasureGroup">ResolvedMeasureGroup</a>&gt;&gt;&amp; measure_group_list() const;
  int measure_group_list_size() const;
  const <a href="#ResolvedMeasureGroup">ResolvedMeasureGroup</a>* measure_group_list(int i) const;

<font color="brown">  // The assigned column for the match number. Always typed as INT64.
  // Visible to the MEASURES clause.</font>
  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; match_number_column() const;

<font color="brown">  // The assigned column for the row&#39;s number within the current match.
  // Always typed as INT64.
  // Visible to the MEASURES clause.</font>
  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; match_row_number_column() const;

<font color="brown">  // The assigned column for the variable assigned to the current row
  // in the match. Always typed as STRING.
  // Visible to the MEASURES clause.</font>
  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; classifier_column() const;
};
</code></pre></p>

### ResolvedMeasureGroup
<a id="ResolvedMeasureGroup"></a>

<p><pre><code class="lang-c++"><font color="brown">// Must be contained directly in a <a href="#ResolvedMatchRecognizeScan">ResolvedMatchRecognizeScan</a>. Groups all
// aggregations ranging over the same pattern variable in the MEASURES clause
// a MATCH_RECOGNIZE. This is a similar concept to
// <a href="#ResolvedAnalyticFunctionGroup">ResolvedAnalyticFunctionGroup</a>.
//
// For example, for this MEASURES clause:
//   MEASURES max(A.x) - min(b.x - b.y), sum(c.x) - avg(x) - min(A.z)
// There will be 4 groups:
//   1. (A, [max(A.x), min(A.z)])
//   2. (b, [min(b.x - b.y)])
//   3. (c, sum(c.x))
//   4. [avg(x)] universal group.
//
// The last group is the universal group. It ranges over all rows in the
// match. There can only be one such group in the <a href="#ResolvedMatchRecognizeScan">ResolvedMatchRecognizeScan</a>.</font>
class ResolvedMeasureGroup : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MEASURE_GROUP;

<font color="brown">  // Nullptr for the universal group, or name of the referenced pattern
  // variable, in which case this must match the name exactly as listed
  // in the `pattern_variable_definition_list` of the enclosing
  // <a href="#ResolvedMatchRecognizeScan">ResolvedMatchRecognizeScan</a>.</font>
  const <a href="#ResolvedMatchRecognizePatternVariableRef">ResolvedMatchRecognizePatternVariableRef</a>* pattern_variable_ref() const;

<font color="brown">  // Aggregations that are part of this group, all ranging over rows
  // assigned to the designated pattern variable. If this is the
  // universal group, the aggregations range over all rows in the
  // match.
  // This list is never empty.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumnBase">ResolvedComputedColumnBase</a>&gt;&gt;&amp; aggregate_list() const;
  int aggregate_list_size() const;
  const <a href="#ResolvedComputedColumnBase">ResolvedComputedColumnBase</a>* aggregate_list(int i) const;
};
</code></pre></p>

### ResolvedMatchRecognizeVariableDefinition
<a id="ResolvedMatchRecognizeVariableDefinition"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents a row pattern variable definition.
// This node can only be used under <a href="#ResolvedMatchRecognizeScan">ResolvedMatchRecognizeScan</a>.</font>
class ResolvedMatchRecognizeVariableDefinition : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MATCH_RECOGNIZE_VARIABLE_DEFINITION;

<font color="brown">  // The name of the pattern variable. The name cannot be
  // empty and must be unique (case-insensitively) within this
  // <a href="#ResolvedMatchRecognizeScan">ResolvedMatchRecognizeScan</a>, but every place this name is
  // referenced elsewhere (e.g. variable ref), it will be identical,
  // including case.</font>
  const std::string&amp; name() const;

<font color="brown">  // Predicate for this pattern variable. This is a BOOL expression to
  // compute whether or not a given row can be qualified for this
  // pattern variable.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* predicate() const;
};
</code></pre></p>

### ResolvedMatchRecognizePatternExpr
<a id="ResolvedMatchRecognizePatternExpr"></a>

<p><pre><code class="lang-c++"><font color="brown">// Abstract class for row pattern expression.</font>
class ResolvedMatchRecognizePatternExpr : public <a href="#ResolvedArgument">ResolvedArgument</a> {
};
</code></pre></p>

### ResolvedMatchRecognizePatternEmpty
<a id="ResolvedMatchRecognizePatternEmpty"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents an empty pattern.
// * An empty pattern consumes zero rows and always matches successfully.
// * An empty pattern on zero input rows will not produce a match, since
//   matches are just searched for at each distinct start row.</font>
class ResolvedMatchRecognizePatternEmpty : public <a href="#ResolvedMatchRecognizePatternExpr">ResolvedMatchRecognizePatternExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MATCH_RECOGNIZE_PATTERN_EMPTY;

};
</code></pre></p>

### ResolvedMatchRecognizePatternAnchor
<a id="ResolvedMatchRecognizePatternAnchor"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents a start or end anchor (^ or $, respectively.)
// * A START anchor requires the match to be at the start of the partition.
// * An END anchor requires the match to be at the end of the partition.
// * Just like the empty pattern, anchors consume zero rows and do not
//   produce matches on zero input rows.</font>
class ResolvedMatchRecognizePatternAnchor : public <a href="#ResolvedMatchRecognizePatternExpr">ResolvedMatchRecognizePatternExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MATCH_RECOGNIZE_PATTERN_ANCHOR;

  typedef <a href="#ResolvedMatchRecognizePatternAnchorEnum">ResolvedMatchRecognizePatternAnchorEnums</a>::Mode Mode;
  static const Mode MODE_UNSPECIFIED = <a href="#ResolvedMatchRecognizePatternAnchorEnum">ResolvedMatchRecognizePatternAnchorEnums</a>::MODE_UNSPECIFIED;
  static const Mode START = <a href="#ResolvedMatchRecognizePatternAnchorEnum">ResolvedMatchRecognizePatternAnchorEnums</a>::START;
  static const Mode END = <a href="#ResolvedMatchRecognizePatternAnchorEnum">ResolvedMatchRecognizePatternAnchorEnums</a>::END;

  <a href="#ResolvedMatchRecognizePatternAnchor">ResolvedMatchRecognizePatternAnchor</a>::Mode mode() const;
};
</code></pre></p>

### ResolvedMatchRecognizePatternVariableRef
<a id="ResolvedMatchRecognizePatternVariableRef"></a>

<p><pre><code class="lang-c++"><font color="brown">// A reference to a row pattern variable.</font>
class ResolvedMatchRecognizePatternVariableRef : public <a href="#ResolvedMatchRecognizePatternExpr">ResolvedMatchRecognizePatternExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MATCH_RECOGNIZE_PATTERN_VARIABLE_REF;

<font color="brown">  // Name of the referenced pattern variable. This must match the
  // the name exactly as listed in the
  // `pattern_variable_definition_list` of the enclosing
  // <a href="#ResolvedMatchRecognizeScan">ResolvedMatchRecognizeScan</a>.</font>
  const std::string&amp; name() const;
};
</code></pre></p>

### ResolvedMatchRecognizePatternOperation
<a id="ResolvedMatchRecognizePatternOperation"></a>

<p><pre><code class="lang-c++"><font color="brown">// An N-ary operation over row pattern sub-expressions.</font>
class ResolvedMatchRecognizePatternOperation : public <a href="#ResolvedMatchRecognizePatternExpr">ResolvedMatchRecognizePatternExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MATCH_RECOGNIZE_PATTERN_OPERATION;

  typedef <a href="#ResolvedMatchRecognizePatternOperationEnum">ResolvedMatchRecognizePatternOperationEnums</a>::MatchRecognizePatternOperationType MatchRecognizePatternOperationType;
  static const MatchRecognizePatternOperationType OPERATION_TYPE_UNSPECIFIED = <a href="#ResolvedMatchRecognizePatternOperationEnum">ResolvedMatchRecognizePatternOperationEnums</a>::OPERATION_TYPE_UNSPECIFIED;
  static const MatchRecognizePatternOperationType CONCAT = <a href="#ResolvedMatchRecognizePatternOperationEnum">ResolvedMatchRecognizePatternOperationEnums</a>::CONCAT;
  static const MatchRecognizePatternOperationType ALTERNATE = <a href="#ResolvedMatchRecognizePatternOperationEnum">ResolvedMatchRecognizePatternOperationEnums</a>::ALTERNATE;

  <a href="#ResolvedMatchRecognizePatternOperation">ResolvedMatchRecognizePatternOperation</a>::MatchRecognizePatternOperationType op_type() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedMatchRecognizePatternExpr">ResolvedMatchRecognizePatternExpr</a>&gt;&gt;&amp; operand_list() const;
  int operand_list_size() const;
  const <a href="#ResolvedMatchRecognizePatternExpr">ResolvedMatchRecognizePatternExpr</a>* operand_list(int i) const;
};
</code></pre></p>

### ResolvedMatchRecognizePatternQuantification
<a id="ResolvedMatchRecognizePatternQuantification"></a>

<p><pre><code class="lang-c++"><font color="brown">// Quantification on a row pattern expression, e.g. A+, A?, A{n, m}, ..etc.
// Regardless of the original syntax used, e.g. a symbol or fixed- or custom-
// bounded, e.g. A+, A{3} or A{1,2}?, the quantifier is represented by the
// lower and upper bounds, and a boolean indicating whether the quantifier is
// reluctant or not.
//
// The upper and lower bounds are represented as <a href="#ResolvedExpr">ResolvedExprs</a>, but currently
// must be literals or parameters. Their type is INT64.
//
// It is a runtime error if the upper bound is present and is smaller than
// the lower bound.
// Any pattern expression can be quantified, including already-quantified
// pattern expressions, For example, the pattern expression
//   ( (A|B){2} ) {2,4}
// specifies either 2, 3 or 4 *pairs* of rows, each matches A or B.</font>
class ResolvedMatchRecognizePatternQuantification : public <a href="#ResolvedMatchRecognizePatternExpr">ResolvedMatchRecognizePatternExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_MATCH_RECOGNIZE_PATTERN_QUANTIFICATION;

<font color="brown">  // The sub-pattern to be repeated according to this quantifier.
  // Cannot be nullptr.</font>
  const <a href="#ResolvedMatchRecognizePatternExpr">ResolvedMatchRecognizePatternExpr</a>* operand() const;

<font color="brown">  // Lower bound of the quantification. Cannot be nullptr.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* lower_bound() const;

<font color="brown">  // The upper bound of the quantification. Can be nullptr, in which
  // case it means there is no upper bound (i.e., unlimited).</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* upper_bound() const;

<font color="brown">  // If true, this quantifier is reluctant. If false, it is greedy.</font>
  bool is_reluctant() const;
};
</code></pre></p>

### ResolvedCloneDataStmt
<a id="ResolvedCloneDataStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// CLONE DATA INTO &lt;table_name&gt; FROM ...
//
// &lt;target_table&gt; the table to clone data into. Cannot be value table.
// &lt;clone_from&gt; The source table(s) to clone data from.
//              For a single table, the scan is TableScan, with an optional
//                  for_system_time_expr;
//              If WHERE clause is present, the Scan is wrapped inside
//                  <a href="#ResolvedFilterScan">ResolvedFilterScan</a>;
//              When multiple sources are present, they are UNION&#39;ed together
//                  in a <a href="#ResolvedSetOperationScan">ResolvedSetOperationScan</a>.
//
//              Constraints:
//                The target_table must not be the same as any source table,
//                and two sources cannot refer to the same table.
//                All source tables and target table must have equal number
//                of columns, with positionally identical column names and
//                types.
//                Cannot be value table.</font>
class ResolvedCloneDataStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CLONE_DATA_STMT;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* target_table() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* clone_from() const;
};
</code></pre></p>

### ResolvedTableAndColumnInfo
<a id="ResolvedTableAndColumnInfo"></a>

<p><pre><code class="lang-c++"><font color="brown">// Identifies the &lt;table&gt; and &lt;column_index_list&gt; (which can be empty) that
// are targets of the ANALYZE statement.
//
// &lt;column_index_list&gt; This list identifies the ordinals of columns to be
// analyzed in the &lt;table&gt;&#39;s column list.</font>
class ResolvedTableAndColumnInfo : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_TABLE_AND_COLUMN_INFO;

  const Table* table() const;

  const std::vector&lt;int&gt;&amp; column_index_list() const;
  int column_index_list_size() const;
  int column_index_list(int i) const;
};
</code></pre></p>

### ResolvedAnalyzeStmt
<a id="ResolvedAnalyzeStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the ANALYZE statement:
// ANALYZE [OPTIONS (&lt;option_list&gt;)] [&lt;table_and_column_index_list&gt; [, ...]];
//
// &lt;option_list&gt; is a list of options for ANALYZE.
//
// &lt;table_and_column_info_list&gt; identifies a list of tables along with their
// related columns that are the target of ANALYZE.</font>
class ResolvedAnalyzeStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ANALYZE_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedTableAndColumnInfo">ResolvedTableAndColumnInfo</a>&gt;&gt;&amp; table_and_column_index_list() const;
  int table_and_column_index_list_size() const;
  const <a href="#ResolvedTableAndColumnInfo">ResolvedTableAndColumnInfo</a>* table_and_column_index_list(int i) const;
};
</code></pre></p>

### ResolvedAuxLoadDataPartitionFilter
<a id="ResolvedAuxLoadDataPartitionFilter"></a>

<p><pre><code class="lang-c++"><font color="brown">// Indicates that the LOAD DATA statement will load to or overwrite the
// selected partitions:
//   [OVERWRITE] PARTITIONS (&lt;filter&gt;)</font>
class ResolvedAuxLoadDataPartitionFilter : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_AUX_LOAD_DATA_PARTITION_FILTER;

<font color="brown">  // Expression to find the partitions to load.
  // Scan rows from source file, and fail the query if filter
  // evaluates some rows to false.
  // &lt;filter&gt; is always of type bool.
  // When this expression produces NULL, the query should fail.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* filter() const;

<font color="brown">  // Indicates whether the load data will append to or overwrite the
  // selected partition.</font>
  bool is_overwrite() const;
};
</code></pre></p>

### ResolvedAuxLoadDataStmt
<a id="ResolvedAuxLoadDataStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// LOAD DATA {OVERWRITE|INTO} [{TEMP|TEMPORARY} TABLE] &lt;table_name&gt;
// [[OVERWRITE] PARTITIONS(...)] ...
// FROM FILES ...
//   This statement loads an external file to a new or existing table.
//   See (broken link).
//
// &lt;insertion_mode&gt; either OVERWRITE or APPEND (INTO) the destination table.
// &lt;is_temp_table&gt; True if the destination table should be a temporary table.
//   Otherwise, the destination table should be a persistent table.
// &lt;name_path&gt; the table to load data into.
// &lt;output_column_list&gt; the list of visible columns of the destination table.
//   If &lt;column_definition_list&gt; is explicitly specified:
//     &lt;output_column_list&gt; =
//         &lt;column_definition_list&gt; + &lt;with_partition_columns&gt;
//   Or if the table already exists:
//     &lt;output_column_list&gt; = &lt;name_path&gt;.columns
//   Last, if the table doesn&#39;t exist and &lt;column_definition_list&gt; isn&#39;t
//   explicitly specified:
//     &lt;output_column_list&gt; = detected-columns + &lt;with_partition_columns&gt;
// &lt;column_definition_list&gt; If not empty, the explicit columns of the
//     destination table. Must be coerciable from the source file&#39;s fields.
//
//     When the destination table doesn&#39;t already exist, it will be created
//     with these columns (plus the additional columns from WITH PARTITION
//     COLUMNS subclause); otherwise, the destination table&#39;s schema must
//     match the explicit columns by both name and type.
// &lt;pseudo_column_list&gt; is a list of pseudo-columns expected to be present on
//     the created table (provided by AnalyzerOptions::SetDdlPseudoColumns*).
//     These can be referenced in expressions in &lt;partition_by_list&gt; and
//     &lt;cluster_by_list&gt;.
// &lt;primary_key&gt; specifies the PRIMARY KEY constraint on the table. It is
//     nullptr when no PRIMARY KEY is specified.
//     If specified, and the table already exists, the primary_key is
//     required to be the same as that of the existing.
// &lt;foreign_key_list&gt; specifies the FOREIGN KEY constraints on the table.
//     If specified, and the table already exists, the foreign keys are
//     required to be the same as that of the existing.
// &lt;check_constraint_list&gt; specifies the ABSL_CHECK constraints on the table.
//     If specified, and the table already exists, the constraints are
//     required to be the same as that of the existing.
// &lt;partition_by_list&gt; The list of columns to partition the destination
//     table. Similar to &lt;column_definition_list&gt;, it must match the
//     destination table&#39;s partitioning spec if it already exists.
// &lt;cluster_by_list&gt; The list of columns to cluster the destination
//     table. Similar to &lt;column_definition_list&gt;, it must match the
//     destination table&#39;s partitioning spec if it already exists.
// &lt;partition_filter&gt; specifies the destination partition selections and
//     whether load to or overwrite the selected partitions.
// &lt;option_list&gt; the options list describing the destination table.
//     If the destination doesn&#39;t already exist, it will be created with
//     these options; otherwise it must match the existing destination
//     table&#39;s options.
// &lt;with_partition_columns&gt; The columns decoded from partitioned source
//     files. If the destination table doesn&#39;t already exist, these columns
//     will be implicitly added to the destination table&#39;s schema; otherwise
//     the destination table must already have these columns
//     (matching by both names and types).
//
//     The hive partition columns from the source file do not automatically
//     partition the destination table. To apply the partition, the
//     &lt;partition_by_list&gt; must be specified.
// &lt;connection&gt; optional connection reference for accessing files.
// &lt;from_files_option_list&gt; the options list describing the source file(s).
//
// Special-case column creation logic in this node:
// If `column_definition_list` is present, it gives all created columns.
// Otherwise, `with_partition_columns` gives some created columns, and
// the `output_column_list` can include those, and also create more.</font>
class ResolvedAuxLoadDataStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_AUX_LOAD_DATA_STMT;

  typedef <a href="#ResolvedAuxLoadDataStmtEnum">ResolvedAuxLoadDataStmtEnums</a>::InsertionMode InsertionMode;
  static const InsertionMode NONE = <a href="#ResolvedAuxLoadDataStmtEnum">ResolvedAuxLoadDataStmtEnums</a>::NONE;
  static const InsertionMode APPEND = <a href="#ResolvedAuxLoadDataStmtEnum">ResolvedAuxLoadDataStmtEnums</a>::APPEND;
  static const InsertionMode OVERWRITE = <a href="#ResolvedAuxLoadDataStmtEnum">ResolvedAuxLoadDataStmtEnums</a>::OVERWRITE;

  <a href="#ResolvedAuxLoadDataStmt">ResolvedAuxLoadDataStmt</a>::InsertionMode insertion_mode() const;

  bool is_temp_table() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const <a href="#ResolvedAuxLoadDataPartitionFilter">ResolvedAuxLoadDataPartitionFilter</a>* partition_filter() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>&gt;&gt;&amp; output_column_list() const;
  int output_column_list_size() const;
  const <a href="#ResolvedOutputColumn">ResolvedOutputColumn</a>* output_column_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>&gt;&gt;&amp; column_definition_list() const;
  int column_definition_list_size() const;
  const <a href="#ResolvedColumnDefinition">ResolvedColumnDefinition</a>* column_definition_list(int i) const;

  const std::vector&lt;<a href="#ResolvedColumn">ResolvedColumn</a>&gt;&amp; pseudo_column_list() const;
  int pseudo_column_list_size() const;
  <a href="#ResolvedColumn">ResolvedColumn</a> pseudo_column_list(int i) const;

  const <a href="#ResolvedPrimaryKey">ResolvedPrimaryKey</a>* primary_key() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedForeignKey">ResolvedForeignKey</a>&gt;&gt;&amp; foreign_key_list() const;
  int foreign_key_list_size() const;
  const <a href="#ResolvedForeignKey">ResolvedForeignKey</a>* foreign_key_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedCheckConstraint">ResolvedCheckConstraint</a>&gt;&gt;&amp; check_constraint_list() const;
  int check_constraint_list_size() const;
  const <a href="#ResolvedCheckConstraint">ResolvedCheckConstraint</a>* check_constraint_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; partition_by_list() const;
  int partition_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* partition_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; cluster_by_list() const;
  int cluster_by_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* cluster_by_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;

  const <a href="#ResolvedWithPartitionColumn">ResolvedWithPartitionColumns</a>* with_partition_columns() const;

  const <a href="#ResolvedConnection">ResolvedConnection</a>* connection() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; from_files_option_list() const;
  int from_files_option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* from_files_option_list(int i) const;
};
</code></pre></p>

### ResolvedCreatePropertyGraphStmt
<a id="ResolvedCreatePropertyGraphStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   CREATE [OR REPLACE] PROPERTY GRAPH [IF NOT EXISTS] &lt;name_path&gt;
//   [OPTIONS (&lt;option_list&gt;)]
//   NODE TABLES(&lt;node_table_list&gt;)
//   [EDGE TABLES(&lt;edge_table_list&gt;)]
//
// &lt;option_list&gt; is a placeholder for engine-specific directives.
// &lt;node_table_list&gt; has the list of node table definitions.
// &lt;edge_table_list&gt; has the list of edge table definitions.</font>
class ResolvedCreatePropertyGraphStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_PROPERTY_GRAPH_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGraphElementTable">ResolvedGraphElementTable</a>&gt;&gt;&amp; node_table_list() const;
  int node_table_list_size() const;
  const <a href="#ResolvedGraphElementTable">ResolvedGraphElementTable</a>* node_table_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGraphElementTable">ResolvedGraphElementTable</a>&gt;&gt;&amp; edge_table_list() const;
  int edge_table_list_size() const;
  const <a href="#ResolvedGraphElementTable">ResolvedGraphElementTable</a>* edge_table_list(int i) const;

<font color="brown">  // All labels defined in this property graph.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGraphElementLabel">ResolvedGraphElementLabel</a>&gt;&gt;&amp; label_list() const;
  int label_list_size() const;
  const <a href="#ResolvedGraphElementLabel">ResolvedGraphElementLabel</a>* label_list(int i) const;

<font color="brown">  // All property declarations exposed by labels in this property
  // graph.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGraphPropertyDeclaration">ResolvedGraphPropertyDeclaration</a>&gt;&gt;&amp; property_declaration_list() const;
  int property_declaration_list_size() const;
  const <a href="#ResolvedGraphPropertyDeclaration">ResolvedGraphPropertyDeclaration</a>* property_declaration_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedGraphElementTable
<a id="ResolvedGraphElementTable"></a>

<p><pre><code class="lang-c++"><font color="brown">// GraphElementTable definition:
//   &lt;name&gt; [AS &lt;alias&gt;]
//   [KEY(&lt;key_list&gt;)]
//   [&lt;source_node_reference&gt;]
//   [&lt;dest_node_reference&gt;]
//   [&lt;label_name_list&gt;]
//   [&lt;property_definition_list]
//   [&lt;dynamic_label&gt;]
//   [&lt;dynamic_properties&gt;]
//
// &lt;alias&gt; identifier of the element table in the property graph.
// &lt;key_list&gt; has a set of references to <a href="#ResolvedColumn">ResolvedColumn</a> from input_scan that
// can uniquely identify rows in the element table.
// &lt;source_node_reference&gt; describes how rows in edge table connect to
// rows in the referenced source node table.
// &lt;dest_node_reference&gt; describes how rows in edge table connect to
// rows in the referenced destination node table by same value columns.
// &lt;label_name_list&gt; is a list of label names.
// &lt;property_definition_list&gt; is a list of property definitions exposed by
// labels.
// &lt;dynamic_label&gt; is the optional dynamic label definition, pointing to
// the dynamic label STRING column.
// &lt;dynamic_properties&gt; is the optional dynamic property definition, pointing
// to the dynamic property JSON column.</font>
class ResolvedGraphElementTable : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_ELEMENT_TABLE;

  const std::string&amp; alias() const;

<font color="brown">  // <a href="#ResolvedScan">ResolvedScan</a> of the underlying table, view etc for column
  // references in key_list and source/dest_node_reference.</font>
  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; key_list() const;
  int key_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* key_list(int i) const;

  const <a href="#ResolvedGraphNodeTableReference">ResolvedGraphNodeTableReference</a>* source_node_reference() const;

  const <a href="#ResolvedGraphNodeTableReference">ResolvedGraphNodeTableReference</a>* dest_node_reference() const;

  const std::vector&lt;std::string&gt;&amp; label_name_list() const;
  int label_name_list_size() const;
  std::string label_name_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGraphPropertyDefinition">ResolvedGraphPropertyDefinition</a>&gt;&gt;&amp; property_definition_list() const;
  int property_definition_list_size() const;
  const <a href="#ResolvedGraphPropertyDefinition">ResolvedGraphPropertyDefinition</a>* property_definition_list(int i) const;

  const <a href="#ResolvedGraphDynamicLabelSpecification">ResolvedGraphDynamicLabelSpecification</a>* dynamic_label() const;

  const <a href="#ResolvedGraphDynamicPropertiesSpecification">ResolvedGraphDynamicPropertiesSpecification</a>* dynamic_properties() const;
};
</code></pre></p>

### ResolvedGraphNodeTableReference
<a id="ResolvedGraphNodeTableReference"></a>

<p><pre><code class="lang-c++"><font color="brown">// GraphNodeTableReference definition:
//   SOURCE|DESTINATION KEY(&lt;edge_table_column_list&gt;) REFERENCES
//   &lt;node_table_identifier&gt;(&lt;node_table_column_list&gt;)
//
// &lt;node_table_identifier&gt; must be a defined node table&#39;s alias.
// &lt;edge_table_column_list&gt; contains columns from the edge table referencing
// corresponding node table columns at the same ordinal position in
// &lt;node_table_column_list&gt;.</font>
class ResolvedGraphNodeTableReference : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_NODE_TABLE_REFERENCE;

  const std::string&amp; node_table_identifier() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; edge_table_column_list() const;
  int edge_table_column_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* edge_table_column_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; node_table_column_list() const;
  int node_table_column_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* node_table_column_list(int i) const;
};
</code></pre></p>

### ResolvedGraphElementLabel
<a id="ResolvedGraphElementLabel"></a>

<p><pre><code class="lang-c++"><font color="brown">// &lt;name&gt; is the name of the label.
// &lt;property_declaration_name_list&gt; is a list of property declarations
// exposed by the label.</font>
class ResolvedGraphElementLabel : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_ELEMENT_LABEL;

  const std::string&amp; name() const;

  const std::vector&lt;std::string&gt;&amp; property_declaration_name_list() const;
  int property_declaration_name_list_size() const;
  std::string property_declaration_name_list(int i) const;
};
</code></pre></p>

### ResolvedGraphPropertyDeclaration
<a id="ResolvedGraphPropertyDeclaration"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents a property name and type exposed by a GraphElementLabel.</font>
class ResolvedGraphPropertyDeclaration : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_PROPERTY_DECLARATION;

  const std::string&amp; name() const;

  const Type* type() const;
};
</code></pre></p>

### ResolvedGraphPropertyDefinition
<a id="ResolvedGraphPropertyDefinition"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents a property exposed by a GraphElementLabel on a specific
// GraphElementTable.
// &lt;expr&gt; [ AS &lt;property_declaration_name&gt; ]
//
// &lt;expr&gt; is the property definition, a <a href="#ResolvedExpression">ResolvedExpression</a> to identify a
// column.
// &lt;sql&gt; is the original sql string of the property definition.
// &lt;property_declaration_name&gt; refers to a property declaration.</font>
class ResolvedGraphPropertyDefinition : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_PROPERTY_DEFINITION;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

  const std::string&amp; sql() const;

  const std::string&amp; property_declaration_name() const;
};
</code></pre></p>

### ResolvedGraphDynamicLabelSpecification
<a id="ResolvedGraphDynamicLabelSpecification"></a>

<p><pre><code class="lang-c++"><font color="brown">// <a href="#ResolvedGraphDynamicLabelSpecification">ResolvedGraphDynamicLabelSpecification</a> is a schema entity that defines
// the dynamic label specification.
// The dynamic label specification is a column reference, and the column
// type needs to be of STRING or ARRAY&lt;STRING&gt;. The `label_expr` field is a
// <a href="#ResolvedColumnRef">ResolvedColumnRef</a> type.</font>
class ResolvedGraphDynamicLabelSpecification : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_DYNAMIC_LABEL_SPECIFICATION;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* label_expr() const;
};
</code></pre></p>

### ResolvedGraphDynamicPropertiesSpecification
<a id="ResolvedGraphDynamicPropertiesSpecification"></a>

<p><pre><code class="lang-c++"><font color="brown">// <a href="#ResolvedGraphDynamicPropertiesSpecification">ResolvedGraphDynamicPropertiesSpecification</a> is a schema entity that defines
// the dynamic property specification.
// The dynamic property specification is a column reference, and the column
// type needs to be of JSON. `property_expr` is of <a href="#ResolvedColumnRef">ResolvedColumnRef</a> type.</font>
class ResolvedGraphDynamicPropertiesSpecification : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_DYNAMIC_PROPERTIES_SPECIFICATION;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* property_expr() const;
};
</code></pre></p>

### ResolvedGraphScanBase
<a id="ResolvedGraphScanBase"></a>

<p><pre><code class="lang-c++"><font color="brown">// Base scan class for graph scans</font>
class ResolvedGraphScanBase : public <a href="#ResolvedScan">ResolvedScan</a> {
};
</code></pre></p>

### ResolvedGraphRefScan
<a id="ResolvedGraphRefScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// A reference scan that can be used as input by a scan op
// to its previous scan op within the same parent GraphLinearScan.</font>
class ResolvedGraphRefScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_REF_SCAN;

};
</code></pre></p>

### ResolvedGraphLinearScan
<a id="ResolvedGraphLinearScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// GraphLinearScan consists of multiple child scans executed in
// order and outputs the last scan</font>
class ResolvedGraphLinearScan : public <a href="#ResolvedGraphScanBase">ResolvedGraphScanBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_LINEAR_SCAN;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedScan">ResolvedScan</a>&gt;&gt;&amp; scan_list() const;
  int scan_list_size() const;
  const <a href="#ResolvedScan">ResolvedScan</a>* scan_list(int i) const;
};
</code></pre></p>

### ResolvedGraphTableScan
<a id="ResolvedGraphTableScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// A scan produced by &lt;graph table&gt; as described in
// (broken link):graph-table-syntax, or gql enabled &lt;graph table&gt;,
// as described in (broken link):gql-graph-table.
//
// It produces columns of non-graph SQL type, either defined by
// &lt;shape_expr_list&gt; or from &lt;input_scan&gt; directly.
// When FEATURE_SQL_GRAPH_EXPOSE_GRAPH_ELEMENT is enabled it may
// produce columns of graph element type.
//
// If &lt;shape_expr_list&gt; is not empty, it defines the output columns of
// <a href="#ResolvedGraphTableScan">ResolvedGraphTableScan</a>, it can only access columns produced from
// &lt;input_scan&gt;.</font>
class ResolvedGraphTableScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_TABLE_SCAN;

  const PropertyGraph* property_graph() const;

  const <a href="#ResolvedGraphScanBase">ResolvedGraphScanBase</a>* input_scan() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; shape_expr_list() const;
  int shape_expr_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* shape_expr_list(int i) const;
};
</code></pre></p>

### ResolvedGraphCallScan
<a id="ResolvedGraphCallScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents a GQL CALL operation, which with a subquery is equivalent to a
// LATERAL JOIN.
// * This operator must a direct child of a <a href="#ResolvedGraphLinearScan">ResolvedGraphLinearScan</a>.
// * &#39;input_scan&#39; is never nullptr, and must be a <a href="#ResolvedSingleRowScan">ResolvedSingleRowScan</a> if it
//   is the first operator in the parent linear scan, or <a href="#ResolvedGraphRefScan">ResolvedGraphRefScan</a>
//   otherwise.
// * &#39;subquery&#39; is never nullptr and must either be:
//    1. a <a href="#ResolvedTVFScan">ResolvedTVFScan</a>, or
//    2. a <a href="#ResolvedGraphTableScan">ResolvedGraphTableScan</a> whose &#39;input_scan&#39; is a
//       <a href="#ResolvedGraphLinearScan">ResolvedGraphLinearScan</a> (since it&#39;s always a GQL linear query)
//       Its graph reference must be the same as the parent&#39;s.
// * If &#39;optional&#39; is true, this operator cannot be the first one in the
//   parent linear scan, and `input_scan` must be a <a href="#ResolvedGraphRefScan">ResolvedGraphRefScan</a>.</font>
class ResolvedGraphCallScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_CALL_SCAN;

  bool optional() const;

<font color="brown">  // The subquery or the TVF to apply.</font>
  const <a href="#ResolvedScan">ResolvedScan</a>* subquery() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

<font color="brown">  // The columns from the `input_scan` which are visible to the inline
  // subquery. Equivalent to JoinScan::lateral_column_list. The columns
  // in this list are the columns from `input_scan` that are referenced
  // in the derived `subquery`. All correlated references in the subquery
  // must be listed here.
  //
  // Note: In the general syntax, this will be the same columns from
  // the partitioning list, equivalent to FOR EACH PARTITION BY.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>&gt;&gt;&amp; parameter_list() const;
  int parameter_list_size() const;
  const <a href="#ResolvedColumnRef">ResolvedColumnRef</a>* parameter_list(int i) const;
};
</code></pre></p>

### ResolvedGraphScan
<a id="ResolvedGraphScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// A scan produced by a &lt;graph pattern&gt; in &lt;graph table&gt;. It represents the
// cross product of input <a href="#ResolvedGraphPathScan">ResolvedGraphPathScans</a>, each represents a matching
// sequences of graph elements (i.e. paths) in the property graph.
//
// The &lt;column_list&gt; will contain columns from the &lt;column_list&gt;s of the
// input path scans.
//
// &lt;filter_expr&gt; contains expressions resolved from
// graph pattern where clause, and possible equalities for joining path scans
// on multiply-declared variables. It further filters the set of matched
// paths.
//
// When &lt;input_scan&gt; exists, the natural join semantics mentioned in
// (broken link):gql-linear-comp would be applied to the &lt;graph pattern&gt; scan and
// this &lt;input_scan&gt;.
//
// When &lt;optional&gt; is true and &lt;input_scan&gt; exists, LEFT OUTER JOIN semantics
// mentioned in (broken link):optional-match would be applied to &lt;input_scan&gt; and
// scan produced from &lt;graph pattern&gt;.</font>
class ResolvedGraphScan : public <a href="#ResolvedGraphScanBase">ResolvedGraphScanBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_SCAN;

<font color="brown">  // path pattern list contained in the graph pattern</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGraphPathScan">ResolvedGraphPathScan</a>&gt;&gt;&amp; input_scan_list() const;
  int input_scan_list_size() const;
  const <a href="#ResolvedGraphPathScan">ResolvedGraphPathScan</a>* input_scan_list(int i) const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* filter_expr() const;

<font color="brown">  // current tabular result in the graph query to be joined with.
  // See (broken link):gql-linear-comp for more details. This can only be a
  // <a href="#ResolvedGraphRefScan">ResolvedGraphRefScan</a> after resolution, and would become a
  // ProjectScan / other GraphScan when linear query is rewritten into
  // a nested tree structure.</font>
  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

<font color="brown">  // this is the result of an OPTIONAL MATCH. See
  // (broken link):optional-match for more details. Corresponds to a left
  // outer join.</font>
  bool optional() const;
};
</code></pre></p>

### ResolvedGraphPathPatternQuantifier
<a id="ResolvedGraphPathPatternQuantifier"></a>

<p><pre><code class="lang-c++"><font color="brown">// A graph path pattern quantifier is used to represent the repetition of
// a path pattern.</font>
class ResolvedGraphPathPatternQuantifier : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_PATH_PATTERN_QUANTIFIER;

<font color="brown">  // The lower bound of a bounded or unbounded quantification.
  // Can not be omitted.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* lower_bound() const;

<font color="brown">  // The upper bound of a bounded or unbounded quantification. When
  // omitted, this is an unbounded quantification.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* upper_bound() const;
};
</code></pre></p>

### ResolvedGraphPathSearchPrefix
<a id="ResolvedGraphPathSearchPrefix"></a>

<p><pre><code class="lang-c++"><font color="brown">// A graph path pattern search prefix, which restricts the result from a
// graph pattern match by grouping the resulting paths by their
// endpoints (the first and last vertices) and makes a selection of
// paths from each group.
// &lt;path_count&gt; is the number of paths to select from each group. It must
// be a non-negative integer literal or parameter of type INT64. If not
// specified, only one path is selected from each group.</font>
class ResolvedGraphPathSearchPrefix : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_PATH_SEARCH_PREFIX;

  typedef <a href="#ResolvedGraphPathSearchPrefixEnum">ResolvedGraphPathSearchPrefixEnums</a>::PathSearchPrefixType PathSearchPrefixType;
  static const PathSearchPrefixType PATH_SEARCH_PREFIX_TYPE_UNSPECIFIED = <a href="#ResolvedGraphPathSearchPrefixEnum">ResolvedGraphPathSearchPrefixEnums</a>::PATH_SEARCH_PREFIX_TYPE_UNSPECIFIED;
  static const PathSearchPrefixType ANY = <a href="#ResolvedGraphPathSearchPrefixEnum">ResolvedGraphPathSearchPrefixEnums</a>::ANY;
  static const PathSearchPrefixType SHORTEST = <a href="#ResolvedGraphPathSearchPrefixEnum">ResolvedGraphPathSearchPrefixEnums</a>::SHORTEST;
  static const PathSearchPrefixType CHEAPEST = <a href="#ResolvedGraphPathSearchPrefixEnum">ResolvedGraphPathSearchPrefixEnums</a>::CHEAPEST;

  <a href="#ResolvedGraphPathSearchPrefix">ResolvedGraphPathSearchPrefix</a>::PathSearchPrefixType type() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* path_count() const;
};
</code></pre></p>

### ResolvedGraphPathScanBase
<a id="ResolvedGraphPathScanBase"></a>

<p><pre><code class="lang-c++"><font color="brown">// Common base class for path scan and element scan.
// This is needed to support parenthesized path pattern.</font>
class ResolvedGraphPathScanBase : public <a href="#ResolvedScan">ResolvedScan</a> {
};
</code></pre></p>

### ResolvedGraphElementScan
<a id="ResolvedGraphElementScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// A base scan produced by a &lt;element pattern&gt;.
// Outputs a stream of single-columned rows where &lt;filter_expr&gt; evaluates
// to true and &lt;label_expr&gt; is satisfied. Column is of
// GraphElementType(kind=Node|Edge).
// Element tables matching the label expression and the element kind
// are accessible in &lt;target_element_table_list&gt;.</font>
class ResolvedGraphElementScan : public <a href="#ResolvedGraphPathScanBase">ResolvedGraphPathScanBase</a> {
  const <a href="#ResolvedExpr">ResolvedExpr</a>* filter_expr() const;

<font color="brown">  // This is a logical combination of individual labels belonging
  // to a property graph using conjunctions (&amp;), disjunctions (|),
  // negations (!), and grouping parentheses. During query evaluation,
  // relevant graph element tables are retrieved that satisfy
  // &lt;label_expr&gt;.</font>
  const <a href="#ResolvedGraphLabelExpr">ResolvedGraphLabelExpr</a>* label_expr() const;

<font color="brown">  // This is a vector of element tables of kind Node or Edge that
  // were found to satisfy &lt;labelexpr&gt; during resolution.</font>
  const std::vector&lt;const GraphElementTable*&gt;&amp; target_element_table_list() const;
  int target_element_table_list_size() const;
  const GraphElementTable* target_element_table_list(int i) const;
};
</code></pre></p>

### ResolvedGraphNodeScan
<a id="ResolvedGraphNodeScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// A <a href="#ResolvedGraphElementScan">ResolvedGraphElementScan</a> produced by &lt;node pattern&gt;, whose the single
// output column is of GraphElementType(kind=Node).</font>
class ResolvedGraphNodeScan : public <a href="#ResolvedGraphElementScan">ResolvedGraphElementScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_NODE_SCAN;

};
</code></pre></p>

### ResolvedGraphEdgeScan
<a id="ResolvedGraphEdgeScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// A <a href="#ResolvedGraphElementScan">ResolvedGraphElementScan</a> produced by &lt;edge pattern&gt;, whose the single
// output column is of GraphElementType(kind=Edge).
//
// The edge scan also specifies the orientation requirement: only edges
// matches the orientation should be returned.</font>
class ResolvedGraphEdgeScan : public <a href="#ResolvedGraphElementScan">ResolvedGraphElementScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_EDGE_SCAN;

  typedef <a href="#ResolvedGraphEdgeScanEnum">ResolvedGraphEdgeScanEnums</a>::EdgeOrientation EdgeOrientation;
  static const EdgeOrientation ANY = <a href="#ResolvedGraphEdgeScanEnum">ResolvedGraphEdgeScanEnums</a>::ANY;
  static const EdgeOrientation LEFT = <a href="#ResolvedGraphEdgeScanEnum">ResolvedGraphEdgeScanEnums</a>::LEFT;
  static const EdgeOrientation RIGHT = <a href="#ResolvedGraphEdgeScanEnum">ResolvedGraphEdgeScanEnums</a>::RIGHT;

  <a href="#ResolvedGraphEdgeScan">ResolvedGraphEdgeScan</a>::EdgeOrientation orientation() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; lhs_hint_list() const;
  int lhs_hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* lhs_hint_list(int i) const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; rhs_hint_list() const;
  int rhs_hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* rhs_hint_list(int i) const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* cost_expr() const;
};
</code></pre></p>

### ResolvedGraphGetElementProperty
<a id="ResolvedGraphGetElementProperty"></a>

<p><pre><code class="lang-c++"><font color="brown">// Get a property from the graph element in `expr`. `expr` must be of
// GraphElementType.
// `property_name` must be evaluated to a STRING typed expression.
// If `property` is populated, its name matches the value of `property_name`.</font>
class ResolvedGraphGetElementProperty : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_GET_ELEMENT_PROPERTY;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

  const GraphPropertyDeclaration* property() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* property_name() const;
};
</code></pre></p>

### ResolvedGraphLabelExpr
<a id="ResolvedGraphLabelExpr"></a>

<p><pre><code class="lang-c++"><font color="brown">// A label is an element of a graph that declares what properties
// are exposed by some node/edge table.
// A label expression is an arbitrarily complex expression of labels with the
// operators &amp;, |, and ! as well as grouping parentheses.</font>
class ResolvedGraphLabelExpr : public <a href="#ResolvedArgument">ResolvedArgument</a> {
};
</code></pre></p>

### ResolvedGraphLabelNaryExpr
<a id="ResolvedGraphLabelNaryExpr"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a logical operation performed on a set of individual
// labels, where &lt;op&gt; specifies the type of operation (&amp;, |, !) and
// &lt;operand_list&gt; contains the operands of type <a href="#ResolvedGraphLabelExpr">ResolvedGraphLabelExpr</a>. Note
// that &amp; and | are N-ary instead of binary to flatten the expressions
// and avoid deep stacks. Note that ! is unary and therefore expects
// that &lt;operand_list&gt; has 1 element.</font>
class ResolvedGraphLabelNaryExpr : public <a href="#ResolvedGraphLabelExpr">ResolvedGraphLabelExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_LABEL_NARY_EXPR;

  typedef <a href="#ResolvedGraphLabelNaryExprEnum">ResolvedGraphLabelNaryExprEnums</a>::GraphLogicalOpType GraphLogicalOpType;
  static const GraphLogicalOpType OPERATION_TYPE_UNSPECIFIED = <a href="#ResolvedGraphLabelNaryExprEnum">ResolvedGraphLabelNaryExprEnums</a>::OPERATION_TYPE_UNSPECIFIED;
  static const GraphLogicalOpType NOT = <a href="#ResolvedGraphLabelNaryExprEnum">ResolvedGraphLabelNaryExprEnums</a>::NOT;
  static const GraphLogicalOpType AND = <a href="#ResolvedGraphLabelNaryExprEnum">ResolvedGraphLabelNaryExprEnums</a>::AND;
  static const GraphLogicalOpType OR = <a href="#ResolvedGraphLabelNaryExprEnum">ResolvedGraphLabelNaryExprEnums</a>::OR;

  std::string GetGraphLogicalOpTypeString() const;
  static std::string
  GraphLogicalOpTypeToString(GraphLogicalOpType logical_op_type);

  <a href="#ResolvedGraphLabelNaryExpr">ResolvedGraphLabelNaryExpr</a>::GraphLogicalOpType op() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGraphLabelExpr">ResolvedGraphLabelExpr</a>&gt;&gt;&amp; operand_list() const;
  int operand_list_size() const;
  const <a href="#ResolvedGraphLabelExpr">ResolvedGraphLabelExpr</a>* operand_list(int i) const;
};
</code></pre></p>

### ResolvedGraphLabel
<a id="ResolvedGraphLabel"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a single resolved graph label.
//
// A label is an element belonging to a property graph that has a unique
// name identifier.
// A static label exposes all the properties declared by
// that label, whereas a dynamic label has no association with the properties
// and acts as an element filter.
// `label_name` must be evaluated to a STRING typed expression. If `label` is
// populated, its name matches the value of `label_name`.</font>
class ResolvedGraphLabel : public <a href="#ResolvedGraphLabelExpr">ResolvedGraphLabelExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_LABEL;

<font color="brown">  // Points to a label in the catalog</font>
  const GraphElementLabel* label() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* label_name() const;
};
</code></pre></p>

### ResolvedGraphWildCardLabel
<a id="ResolvedGraphWildCardLabel"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the wildcard label % that matches any label in the graph.</font>
class ResolvedGraphWildCardLabel : public <a href="#ResolvedGraphLabelExpr">ResolvedGraphLabelExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_WILD_CARD_LABEL;

};
</code></pre></p>

### ResolvedGraphElementIdentifier
<a id="ResolvedGraphElementIdentifier"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents the identifier of a graph element within a graph.
// See (broken link):graph-element-identifiers for more details.
//
// &lt;element_table&gt;: the ElementTable that produced this graph element;
// &lt;key_list&gt;: references to the key columns of the &lt;element_table&gt;;
// &lt;source/dest_node_identifier&gt;: identifiers of source/destination node
//    of an edge: must be set if the element is an edge; must be null if
//    the element is a node.</font>
class ResolvedGraphElementIdentifier : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_ELEMENT_IDENTIFIER;

  const GraphElementTable* element_table() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedExpr">ResolvedExpr</a>&gt;&gt;&amp; key_list() const;
  int key_list_size() const;
  const <a href="#ResolvedExpr">ResolvedExpr</a>* key_list(int i) const;

  const <a href="#ResolvedGraphElementIdentifier">ResolvedGraphElementIdentifier</a>* source_node_identifier() const;

  const <a href="#ResolvedGraphElementIdentifier">ResolvedGraphElementIdentifier</a>* dest_node_identifier() const;
};
</code></pre></p>

### ResolvedGraphElementProperty
<a id="ResolvedGraphElementProperty"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents a graph element property of a graph element.
//
// &lt;declaration&gt; refers to the property declaration catalog object;
// &lt;expr&gt; is the value expression for the &lt;declaration&gt;.</font>
class ResolvedGraphElementProperty : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_ELEMENT_PROPERTY;

  const GraphPropertyDeclaration* declaration() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;
};
</code></pre></p>

### ResolvedGraphMakeElement
<a id="ResolvedGraphMakeElement"></a>

<p><pre><code class="lang-c++"><font color="brown">// Constructs a graph element.
//
// `type` is always a GraphElementType.
// `identifier` uniquely identify a graph element in the graph.
// `label_list` contains all static labels.
// `property_list` contains all static properties and their definitions.
// `dynamic_labels` is an expression that can be evaluated to a STRING or
// ARRAY&lt;STRING&gt; typed value representing one or a list of dynamic labels.
// `dynamic_properties` is an expression that can be evaluated to a JSON
// typed value. Its top-level key/value pairs make up the dynamic properties
// of the graph element.</font>
class ResolvedGraphMakeElement : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_MAKE_ELEMENT;

  const <a href="#ResolvedGraphElementIdentifier">ResolvedGraphElementIdentifier</a>* identifier() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGraphElementProperty">ResolvedGraphElementProperty</a>&gt;&gt;&amp; property_list() const;
  int property_list_size() const;
  const <a href="#ResolvedGraphElementProperty">ResolvedGraphElementProperty</a>* property_list(int i) const;

  const std::vector&lt;const GraphElementLabel*&gt;&amp; label_list() const;
  int label_list_size() const;
  const GraphElementLabel* label_list(int i) const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* dynamic_labels() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* dynamic_properties() const;
};
</code></pre></p>

### ResolvedArrayAggregate
<a id="ResolvedArrayAggregate"></a>

<p><pre><code class="lang-c++"><font color="brown">// Computes an aggregate over the elements of an array.
//
// For each element in &lt;array&gt;, produce an input row for the aggregate
// as follows:
//  - Let &lt;element_column&gt; be the array element.
//  - Compute the expressions in &lt;pre_aggregate_computed_column_list&gt;,
//    which may refer to &lt;element_column&gt; and &lt;array&gt;.
// Then evaluate &lt;aggregate&gt; over these rows.  It may reference these
// new columns, or any other columns in scope for this node.
//
// The aggregate input rows use the original &lt;array&gt;&#39;s order unless
// &lt;aggregate&gt; has an ORDER BY modifier.
//
// &lt;element_column&gt; and the columns in
// &lt;pre_aggregate_computed_column_list&gt; are not visible outside this node.
//
// &lt;array&gt; can be any <a href="#ResolvedExpr">ResolvedExpr</a>. Today it&#39;s always a <a href="#ResolvedColumnRef">ResolvedColumnRef</a>
// because the only user is graph&#39;s horizontal aggregation and that is
// baked into the SQLBuilder implementation.</font>
class ResolvedArrayAggregate : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ARRAY_AGGREGATE;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* array() const;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; element_column() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>&gt;&gt;&amp; pre_aggregate_computed_column_list() const;
  int pre_aggregate_computed_column_list_size() const;
  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* pre_aggregate_computed_column_list(int i) const;

  const <a href="#ResolvedAggregateFunctionCall">ResolvedAggregateFunctionCall</a>* aggregate() const;
};
</code></pre></p>

### ResolvedGraphMakeArrayVariable
<a id="ResolvedGraphMakeArrayVariable"></a>

<p><pre><code class="lang-c++"><font color="brown">// <a href="#ResolvedGraphMakeArrayVariable">ResolvedGraphMakeArrayVariable</a> populates the newly created &lt;array&gt;
// column with the values that &lt;element&gt; takes across iterations of the
// quantified path. For example, the resolved path `((a) - (b)){3}` will
// contain two <a href="#ResolvedGraphMakeArrayVariable">ResolvedGraphMakeArrayVariables</a>, one creating the
// array-typed column with the three values that `a` takes along the
// quantified path; same for `b`.
//
// The type of &lt;array&gt; must be an array with element type &lt;scalar&gt;.</font>
class ResolvedGraphMakeArrayVariable : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_MAKE_ARRAY_VARIABLE;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; element() const;

  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; array() const;
};
</code></pre></p>

### ResolvedGraphPathMode
<a id="ResolvedGraphPathMode"></a>

<p><pre><code class="lang-c++"><font color="brown">// Path mode specifies ways to restrict the nodes and edges on a particular
// path. It currently provides the ability to prevent duplicate edges with
// TRAIL, duplicate nodes with ACYCLIC, and duplicate nodes except possibly
// the head and the tail of the path with SIMPLE.</font>
class ResolvedGraphPathMode : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_PATH_MODE;

  typedef <a href="#ResolvedGraphPathModeEnum">ResolvedGraphPathModeEnums</a>::PathMode PathMode;
  static const PathMode PATH_MODE_UNSPECIFIED = <a href="#ResolvedGraphPathModeEnum">ResolvedGraphPathModeEnums</a>::PATH_MODE_UNSPECIFIED;
  static const PathMode WALK = <a href="#ResolvedGraphPathModeEnum">ResolvedGraphPathModeEnums</a>::WALK;
  static const PathMode TRAIL = <a href="#ResolvedGraphPathModeEnum">ResolvedGraphPathModeEnums</a>::TRAIL;
  static const PathMode SIMPLE = <a href="#ResolvedGraphPathModeEnum">ResolvedGraphPathModeEnums</a>::SIMPLE;
  static const PathMode ACYCLIC = <a href="#ResolvedGraphPathModeEnum">ResolvedGraphPathModeEnums</a>::ACYCLIC;

  <a href="#ResolvedGraphPathMode">ResolvedGraphPathMode</a>::PathMode path_mode() const;
};
</code></pre></p>

### ResolvedGraphPathCost
<a id="ResolvedGraphPathCost"></a>

<p><pre><code class="lang-c++"><font color="brown">// This node defines the cost for a graph path. Currently it only defines the
// value type of the cost. Value expressions are not yet supported at this
// level. The actual cost for a path is the sum of the costs defined on graph
// edge elements within the path.</font>
class ResolvedGraphPathCost : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_PATH_COST;

  const Type* cost_supertype() const;
};
</code></pre></p>

### ResolvedGraphPathScan
<a id="ResolvedGraphPathScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// <a href="#ResolvedGraphPathScan">ResolvedGraphPathScan</a> represents a scan of matching sequences of
// sub-paths or graph elements (i.e. paths) from the graph.
//
// <a href="#ResolvedGraphPathScan">ResolvedGraphPathScan</a> matches paths that: for the sequence of elements
// along the path:
//   1) node/edge output from successive node pattern and edge pattern
//      satisfy edge pattern&#39;s orientation constraint:
//      the matching node must be the source or the destination of the
//      matching edge;
//   2) &lt;filter_expr&gt; evaluates true for the matching graph elements.
//   3) &lt;path_hint_list&gt; denotes a hint on a traversal between the
//      previous path to this path, so the first path in a graph pattern
//      will not contain a &#39;path hint&#39;. Note that this is different from
//      the parent <a href="#ResolvedScan">ResolvedScan</a> node&#39;s &#39;hint_list&#39; which belongs to the
//      scan itself.
//
//
// &lt;head&gt; and &lt;tail&gt; are the first and last graph node of the path
// respectively.
//
// Consecutive paths match when the &lt;tail&gt; of the first path is the same
// as the &lt;head&gt; of the second path.
//
// A path is either quantified or not. If quantified:
//   1) &lt;quantifier&gt; and &lt;group_variable_list&gt; must be present.
//   2) &lt;group_variable_list&gt; is a list of (&lt;element&gt;, &lt;array&gt;) columns.
//      For each &lt;element&gt; column, this scan will populate the
//      corresponding &lt;array&gt; column with an array of all the values
//      that &lt;scalar&gt; column took across the iterations of the
//      quantified path in iteration order. Every &lt;element&gt; column comes
//      from &lt;input_scan_list&gt;. &lt;column_list&gt; contains the &lt;head&gt;,
//      &lt;tail&gt;, and all of the &lt;array&gt; columns from &lt;group_variable_list&gt;
//
//
// If the path is not quantified:
//   1) &lt;quantifier&gt; and &lt;group_variable_list&gt; must not be present.
//   2) The &lt;column_list&gt; will contain columns from the &lt;column_list&gt;s of
//      the input scans, which represents elements in the path.
//
// If &lt;path&gt; is present, it must be a path-typed column that can be
// constructed from the paths and graph elements in &lt;input_scan_list&gt;.
// This scan will populate &lt;path&gt; with the nodes and edges that are
// matched along the path. If &lt;path&gt; is set on a <a href="#ResolvedGraphPathScan">ResolvedGraphPathScan</a> it
// must be set on all descendant <a href="#ResolvedGraphPathScan">ResolvedGraphPathScans</a>. &lt;path&gt; must be a
// new column.</font>
class ResolvedGraphPathScan : public <a href="#ResolvedGraphPathScanBase">ResolvedGraphPathScanBase</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_PATH_SCAN;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGraphPathScanBase">ResolvedGraphPathScanBase</a>&gt;&gt;&amp; input_scan_list() const;
  int input_scan_list_size() const;
  const <a href="#ResolvedGraphPathScanBase">ResolvedGraphPathScanBase</a>* input_scan_list(int i) const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* filter_expr() const;

  const <a href="#ResolvedColumnHolder">ResolvedColumnHolder</a>* path() const;

<font color="brown">  // Note unusual logic: `head` is created if `quantifier` is present,
  // but otherwise, already exists and is referenced.</font>
  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; head() const;

<font color="brown">  // Note unusual logic: `tail` is created if `quantifier` is present,
  // but otherwise, already exists and is referenced.</font>
  const <a href="#ResolvedColumn">ResolvedColumn</a>&amp; tail() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; path_hint_list() const;
  int path_hint_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* path_hint_list(int i) const;

  const <a href="#ResolvedGraphPathPatternQuantifier">ResolvedGraphPathPatternQuantifier</a>* quantifier() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGraphMakeArrayVariable">ResolvedGraphMakeArrayVariable</a>&gt;&gt;&amp; group_variable_list() const;
  int group_variable_list_size() const;
  const <a href="#ResolvedGraphMakeArrayVariable">ResolvedGraphMakeArrayVariable</a>* group_variable_list(int i) const;

  const <a href="#ResolvedGraphPathMode">ResolvedGraphPathMode</a>* path_mode() const;

  const <a href="#ResolvedGraphPathSearchPrefix">ResolvedGraphPathSearchPrefix</a>* search_prefix() const;

  const <a href="#ResolvedGraphPathCost">ResolvedGraphPathCost</a>* path_cost() const;
};
</code></pre></p>

### ResolvedGraphIsLabeledPredicate
<a id="ResolvedGraphIsLabeledPredicate"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents IS LABELED predicate for graph elements, a boolean expression
// that evaluates to true if the graph element satisfies the given
// label expression.
// &lt;expr&gt; represents the LHS which should always be a column reference of
// GraphElementType.
// &lt;label_expr&gt; represents the RHS which should always be a
// <a href="#ResolvedGraphLabelExpr">ResolvedGraphLabelExpr</a>.
// &lt;is_not&gt; is true if the predicate is negated.</font>
class ResolvedGraphIsLabeledPredicate : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GRAPH_IS_LABELED_PREDICATE;

  bool is_not() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

  const <a href="#ResolvedGraphLabelExpr">ResolvedGraphLabelExpr</a>* label_expr() const;
};
</code></pre></p>

### ResolvedUndropStmt
<a id="ResolvedUndropStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
//   UNDROP &lt;schema_object_kind&gt; [IF NOT EXISTS] &lt;name_path&gt;
//   FOR SYSTEM_TIME AS OF [&lt;for_system_time_expr&gt;]
//   [OPTIONS (name=value, ...)];
//
// &lt;schema_object_kind&gt; is a string identifier for the entity to be
// undroped. Currently, only &#39;SCHEMA&#39; object is supported.
//
// &lt;name_path&gt; is a vector giving the identifier path for the object to
// be undropped.
//
// &lt;is_if_not_exists&gt; if set, skip the undrop if the resource already
// exists.
//
// &lt;for_system_time_expr&gt; specifies point in time from which entity is to
// be undropped.
//
// &lt;option_list&gt; contains engine-specific options associated with the schema.</font>
class ResolvedUndropStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UNDROP_STMT;

  const std::string&amp; schema_object_kind() const;

  bool is_if_not_exists() const;

  const std::vector&lt;std::string&gt;&amp; name_path() const;
  int name_path_size() const;
  std::string name_path(int i) const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* for_system_time_expr() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedIdentityColumnInfo
<a id="ResolvedIdentityColumnInfo"></a>

<p><pre><code class="lang-c++"><font color="brown">// This argument represents the identity column clause for a generated
// column:
//     GENERATED AS IDENTITY (
//                    [ START WITH &lt;signed_numeric_literal&gt; ]
//                    [ INCREMENT BY &lt;signed_numeric_literal&gt; ]
//                    [ MAXVALUE &lt;signed_numeric_literal&gt;]
//                    [ MINVALUE &lt;signed_numeric_literal&gt;]
//                    [ CYCLE | NO CYCLE]
//                  )
// If attributes are not specified, the resolver fills in the fields using
// default values.
// Note: Only integer-typed columns can be identity columns.
//
// `start_with_value` is the start/first value generated for the column.
//
// `increment_by_value` is the minimum difference between two successive
// generated values.
//   - Can be negative or positive but not 0.
//
// `max_value` is the maximum value that can be generated in the column.
//
// `min_value` is the minimum value that can be generated in the column.
//
// `cycling_enabled`: If true, the generated identity value will cycle around
// after overflow, when `min_value` or `max_value` is exceeded.
//
// See (broken link).</font>
class ResolvedIdentityColumnInfo : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_IDENTITY_COLUMN_INFO;

  const Value&amp; start_with_value() const;

  const Value&amp; increment_by_value() const;

  const Value&amp; max_value() const;

  const Value&amp; min_value() const;

  bool cycling_enabled() const;
};
</code></pre></p>

### ResolvedDescribeScan
<a id="ResolvedDescribeScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the pipe DESCRIBE operator, which is controlled by
// FEATURE_PIPE_DESCRIBE.
//
// This scan always returns a one-row result table with one STRING column,
// containing a textual description of the input table&#39;s schema.
//
// The `input_scan` is included so it isn&#39;t lost.  It isn&#39;t necessary to
// execute that scan since the output row doesn&#39;t depend on it, but engines
// may need to process it for ACL checks or other validation.
//
// `describe_expr` is the single column to project.  It&#39;s expression is
// a literal value and cannot reference columns from `input_scan`.
//
// The output `column_list` can only contain that new column.</font>
class ResolvedDescribeScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_DESCRIBE_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const <a href="#ResolvedComputedColumn">ResolvedComputedColumn</a>* describe_expr() const;
};
</code></pre></p>

### ResolvedStaticDescribeScan
<a id="ResolvedStaticDescribeScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the pipe STATIC_DESCRIBE operator, which is controlled by
// FEATURE_PIPE_STATIC_DESCRIBE.
//
// This scan is a no-op, that just stores the describe_text produced to show
// the intermediate schema where this operator occurred.
//
// This describe_text is displayed in resolved AST DebugStrings (which is
// used internally in analyzer tests), and is also meant to be displayed
// through some engine-specific side-channel at query prepare time.</font>
class ResolvedStaticDescribeScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_STATIC_DESCRIBE_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::string&amp; describe_text() const;
};
</code></pre></p>

### ResolvedAssertScan
<a id="ResolvedAssertScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the pipe ASSERT operator, which is controlled by
// FEATURE_PIPE_ASSERT.
//
// `condition` is a boolean expression.
// `message` is a string expression.
//
// `condition` is computed for each row.  If it does not return true,
// the assertion fails.  Then `message` is evaluated and used as part
// of the error message, following something like &#34;Assert failed: &#34;.</font>
class ResolvedAssertScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ASSERT_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* condition() const;

  const <a href="#ResolvedExpr">ResolvedExpr</a>* message() const;
};
</code></pre></p>

### ResolvedLogScan
<a id="ResolvedLogScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the pipe ABSL_LOG operator, which is controlled by
// FEATURE_PIPE_LOG.
//
// Execute `subpipeline` over `input_scan` and send its output to an
// implementation-defined log.
//
// `output_schema` describes the visible schema of the output to send to
// the log. (This is not the output of the <a href="#ResolvedLogScan">ResolvedLogScan</a> in the query.)
//
// In the main query flow, <a href="#ResolvedLogScan">ResolvedLogScan</a> is a no-op and just returns
// the result from `input_scan` unchanged.</font>
class ResolvedLogScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_LOG_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const <a href="#ResolvedSubpipeline">ResolvedSubpipeline</a>* subpipeline() const;

  const <a href="#ResolvedOutputSchema">ResolvedOutputSchema</a>* output_schema() const;
};
</code></pre></p>

### ResolvedPipeIfScan
<a id="ResolvedPipeIfScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the pipe IF operator, which is controlled by
// FEATURE_PIPE_IF.  See (broken link).
//
// `if_case_list` must have at least one element with a `condition`.
// If there&#39;s an ELSE case, if will be last and will have no `condition`.
//
// `selected_case` indicates the chosen case and must be a valid index into
// `if_case_list`.  `selected_case` is -1 if no case is selected and there&#39;s
// no ELSE case.
//
// The constant `condition` for `selected_case` must evaluate to true unless
// it&#39;s the ELSE case.  All preceding `condition` expressions must evaluate
// to non-true values.  (Later `condition` expressions could return errors.)
//
// The selected case includes a valid resolved `subpipeline` that takes
// `input_scan` as its input table.
//
// Execution semantics:
// Only the selected case runs.  The condition expressions have already been
// evaluated statically at analysis time so are not evaluated at runtime.
// If `selected_case` is -1, this scan is a no-op.
//
// The subpipeline for the selected case runs over `input_scan`.
// Its output is this node&#39;s output.
// This node&#39;s `column_list` must be a subset of the subpipeline&#39;s final
// column list.
//
// `if_case_list` is ignorable because if `selected_case` is -1, it&#39;s
// not necessary to look at any cases.</font>
class ResolvedPipeIfScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PIPE_IF_SCAN;

  // Get the <a href="#ResolvedScan">ResolvedScan</a> for the case that was selected.
  // When no case is selected (and there&#39;s no ELSE), this will be `input_scan`.
  const <a href="#ResolvedScan">ResolvedScan</a>* GetSelectedCaseScan() const;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  int selected_case() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedPipeIfCase">ResolvedPipeIfCase</a>&gt;&gt;&amp; if_case_list() const;
  int if_case_list_size() const;
  const <a href="#ResolvedPipeIfCase">ResolvedPipeIfCase</a>* if_case_list(int i) const;
};
</code></pre></p>

### ResolvedPipeIfCase
<a id="ResolvedPipeIfCase"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents one case in a <a href="#ResolvedPipeIf">ResolvedPipeIf</a>.
//
// `condition` and `subpipeline_sql` must be present for all cases except
// the last case (if it&#39;s an ELSE case).
// `condition` must be present except on the ELSE case.
// `subpipeline_sql` must be present for all cases.
//
// Where `condition` is present, it must be a valid boolean constant
// expression.
//
// `subpipeline_sql` gives the SQL for the subpipeline, including the
// wrapping parentheses.  This is required even for the selected case
// because the SQLBuilder currently relies on it.
//
// `subpipeline_sql` for non-selected cases doesn&#39;t have to be resolvable
// but should be parsable.
//
// `subpipeline` must be present for the selected case, and can optionally
// be present for other cases (only when the SQL is valid).
//
// `condition` is ignorable because conditions are evaluated at analysis time
// and the case to run has already been chosen.
//
// `subpipeline` is ignorable because it doesn&#39;t need to be consumed in the
// non-selected cases.</font>
class ResolvedPipeIfCase : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PIPE_IF_CASE;

  bool IsElse() const { return condition() == nullptr; }

  const <a href="#ResolvedExpr">ResolvedExpr</a>* condition() const;

  const std::string&amp; subpipeline_sql() const;

  const <a href="#ResolvedSubpipeline">ResolvedSubpipeline</a>* subpipeline() const;
};
</code></pre></p>

### ResolvedPipeForkScan
<a id="ResolvedPipeForkScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the pipe FORK operator, which is controlled by
// FEATURE_PIPE_FORK.  See (broken link).
//
// This only occurs inside <a href="#ResolvedGeneralizedQueryStmt">ResolvedGeneralizedQueryStmts</a>, so that statement
// must be enabled in SupportedStatementKinds.
//
// This terminates the main pipeline.
// Each subpipeline runs over the result of `input_scan`.
//
// `subpipeline_list` must have at least one entry.</font>
class ResolvedPipeForkScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PIPE_FORK_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGeneralizedQuerySubpipeline">ResolvedGeneralizedQuerySubpipeline</a>&gt;&gt;&amp; subpipeline_list() const;
  int subpipeline_list_size() const;
  const <a href="#ResolvedGeneralizedQuerySubpipeline">ResolvedGeneralizedQuerySubpipeline</a>* subpipeline_list(int i) const;
};
</code></pre></p>

### ResolvedPipeTeeScan
<a id="ResolvedPipeTeeScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the pipe TEE operator, which is controlled by
// FEATURE_PIPE_TEE.  See (broken link).
//
// This only occurs inside <a href="#ResolvedGeneralizedQueryStmt">ResolvedGeneralizedQueryStmts</a>, so that statement
// must be enabled in SupportedStatementKinds.
//
// Each subpipeline runs over the result of `input_scan`.
// Then this scan returns its input table and the main pipeline continues.
//
// `subpipeline_list` must have at least one entry.</font>
class ResolvedPipeTeeScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PIPE_TEE_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedGeneralizedQuerySubpipeline">ResolvedGeneralizedQuerySubpipeline</a>&gt;&gt;&amp; subpipeline_list() const;
  int subpipeline_list_size() const;
  const <a href="#ResolvedGeneralizedQuerySubpipeline">ResolvedGeneralizedQuerySubpipeline</a>* subpipeline_list(int i) const;
};
</code></pre></p>

### ResolvedPipeExportDataScan
<a id="ResolvedPipeExportDataScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the pipe EXPORT DATA operator, which is controlled by
// FEATURE_PIPE_EXPORT_DATA.  See (broken link).
//
// This only occurs inside <a href="#ResolvedGeneralizedQueryStmt">ResolvedGeneralizedQueryStmts</a>, so that statement
// must be enabled in SupportedStatementKinds.
//
// The pipe input is in `export_data_stmt-&gt;query`, which must be present.</font>
class ResolvedPipeExportDataScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PIPE_EXPORT_DATA_SCAN;

  const <a href="#ResolvedExportDataStmt">ResolvedExportDataStmt</a>* export_data_stmt() const;
};
</code></pre></p>

### ResolvedPipeCreateTableScan
<a id="ResolvedPipeCreateTableScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the pipe CREATE TABLE operator, which is controlled by
// FEATURE_PIPE_CREATE_TABLE.
//
// This only occurs inside <a href="#ResolvedGeneralizedQueryStmt">ResolvedGeneralizedQueryStmts</a>, so that statement
// must be enabled in SupportedStatementKinds.
//
// The pipe input is in `create_table_as_select_stmt-&gt;query`, which must be
// present.</font>
class ResolvedPipeCreateTableScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PIPE_CREATE_TABLE_SCAN;

<font color="brown">  // This uses <a href="#ResolvedCreateTableAsSelectStmt">ResolvedCreateTableAsSelectStmt</a> rather than
  // <a href="#ResolvedCreateTableStmt">ResolvedCreateTableStmt</a> even though the SQL doesn&#39;t include a
  // query.
  //
  // <a href="#ResolvedCreateTableAsSelectStmt">ResolvedCreateTableAsSelectStmt</a> is a more accurate description of
  // what this actually does, and what this Scan can be rewritten into.
  // The node&#39;s `query` stores the pipe input query.
  //
  // <a href="#ResolvedCreateTableStmt">ResolvedCreateTableStmt</a> includes features like COPY and CLONE that
  // don&#39;t make senes when there&#39;s an input table, including a pipe
  // input table.</font>
  const <a href="#ResolvedCreateTableAsSelectStmt">ResolvedCreateTableAsSelectStmt</a>* create_table_as_select_stmt() const;
};
</code></pre></p>

### ResolvedPipeInsertScan
<a id="ResolvedPipeInsertScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents the pipe INSERT operator, which is controlled by
// FEATURE_PIPE_INSERT.  See (broken link).
//
// This only occurs inside <a href="#ResolvedGeneralizedQueryStmt">ResolvedGeneralizedQueryStmts</a>, so that statement
// must be enabled in SupportedStatementKinds.
//
// The pipe input is in `insert_stmt-&gt;query`, which must be present.</font>
class ResolvedPipeInsertScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_PIPE_INSERT_SCAN;

  const <a href="#ResolvedInsertStmt">ResolvedInsertStmt</a>* insert_stmt() const;
};
</code></pre></p>

### ResolvedSubpipeline
<a id="ResolvedSubpipeline"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a subpipeline.
// These occur inside various pipe operators, expressing a subpipeline of
// pipe operators to apply on some input table.
// See (broken link).
//
// The operator that contains this <a href="#ResolvedSubpipeline">ResolvedSubpipeline</a> defines how it&#39;s
// being used and what table is passed in.  Most commonly, this is used
// inside pipe operator scans, and is passed the `input_scan` of the
// containing <a href="#ResolvedScan">ResolvedScan</a>.  When some other intermediate table is passed to
// the subpipeline, that will be documented in the containing node.
//
// Inside `scan`, there must be exactly one instance of
// <a href="#ResolvedSubpipelineInputScan">ResolvedSubpipelineInputScan</a> as a leaf scan receiving the subpipeline&#39;s
// input table.  That scan&#39;s column_list includes a subset of columns
// available from the input table provided to this <a href="#ResolvedSubpipeline">ResolvedSubpipeline</a>.
//
// <a href="#ResolvedSubpipeline">ResolvedSubpipeline</a> is like the final subquery in a <a href="#ResolvedWithScan">ResolvedWithScan</a>.
// The <a href="#ResolvedSubpipelineInputScan">ResolvedSubpipelineInputScan</a> is like the <a href="#ResolvedWithRefScan">ResolvedWithRefScan</a>.
// The node containing this <a href="#ResolvedSubpipeline">ResolvedSubpipeline</a> is like the <a href="#ResolvedWithScan">ResolvedWithScan</a>
// and has to define the CTE-like table that will be referenced.</font>
class ResolvedSubpipeline : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SUBPIPELINE;

  const <a href="#ResolvedScan">ResolvedScan</a>* scan() const;
};
</code></pre></p>

### ResolvedSubpipelineInputScan
<a id="ResolvedSubpipelineInputScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// This is the scan inside a <a href="#ResolvedSubpipeline">ResolvedSubpipeline</a> representing the initial
// input table passed into the subpipeline.  This works like a CTE in WITH.
//
// The node containing the <a href="#ResolvedSubpipeline">ResolvedSubpipeline</a> (which is like a
// <a href="#ResolvedWithScan">ResolvedWithScan</a>) specifies what table this is. Often it&#39;s a table that
// just gets a copy of the node&#39;s `input_scan`, to pass through to the
// subpipeline.
//
// The <a href="#ResolvedSubpipelineInputScan">ResolvedSubpipelineInputScan</a> is like a <a href="#ResolvedWithRefScan">ResolvedWithRefScan</a>, doing the
// scan of that specified table inside the subpupline query.
//
// The `column_list` columns are a subset of columns available on that
// input table.</font>
class ResolvedSubpipelineInputScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SUBPIPELINE_INPUT_SCAN;

};
</code></pre></p>

### ResolvedSubpipelineStmt
<a id="ResolvedSubpipelineStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a standalone subpipeline resolved as a statement.
// See (broken link) and (broken link).
//
// The analyzer will only generate this if it&#39;s included in SupportedStatements
// and `default_table_for_subpipeline_stmt` is set in AnalyzerOptions.
//
// The default rewriters will replace this with a <a href="#ResolvedStatement">ResolvedStatement</a> that
// inlines the <a href="#ResolvedTableScan">ResolvedTableScan</a>.  It&#39;ll be <a href="#ResolvedQueryStmt">ResolvedQueryStmt</a> for most queries.
// Other statement types are possible if <a href="#ResolvedGeneralizedQueryStmt">ResolvedGeneralizedQueryStmt</a>
// features are enabled.
//
// `table_scan` is a <a href="#ResolvedTableScan">ResolvedTableScan</a> representing the input table for
// the subpipeline (which comes from `default_table_for_subpipeline_stmt`).
// This assigns <a href="#ResolvedColumn">ResolvedColumns</a> for the input.
//
// `subpipeline` is the subpipeline running over that table.
//
// `output_schema` is the final output schema for the subpipeline.
// This can be null if the subpipeline ends with a terminal operator
// that doesn&#39;t return a table.
//
// SQLBuilder output does not include `table_scan` since it&#39;s mainly
// a placeholder representing the input table from the Analyze options.</font>
class ResolvedSubpipelineStmt : public <a href="#ResolvedStatement">ResolvedStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_SUBPIPELINE_STMT;

  const <a href="#ResolvedTableScan">ResolvedTableScan</a>* table_scan() const;

  const <a href="#ResolvedSubpipeline">ResolvedSubpipeline</a>* subpipeline() const;

  const <a href="#ResolvedOutputSchema">ResolvedOutputSchema</a>* output_schema() const;
};
</code></pre></p>

### ResolvedGeneralizedQuerySubpipeline
<a id="ResolvedGeneralizedQuerySubpipeline"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a subpipeline that is part of a
// <a href="#ResolvedGeneralizedQueryStmt">ResolvedGeneralizedQueryStmt</a> and could produce an output table or a
// statement side-effect.
// This node can only occur inside a <a href="#ResolvedGeneralizedQueryStmt">ResolvedGeneralizedQueryStmt</a>.
//
// These subpipelines occur inside operators like FORK that create
// generalized query shapes.  See (broken link).
//
// `output_schema` is present if this subpipeline produces a final output
// table to be returned as part of the <a href="#ResolvedGeneralizedQueryStmt">ResolvedGeneralizedQueryStmt</a>, and
// provides the schema of that table.</font>
class ResolvedGeneralizedQuerySubpipeline : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_GENERALIZED_QUERY_SUBPIPELINE;

  const <a href="#ResolvedSubpipeline">ResolvedSubpipeline</a>* subpipeline() const;

  const <a href="#ResolvedOutputSchema">ResolvedOutputSchema</a>* output_schema() const;
};
</code></pre></p>

### ResolvedBarrierScan
<a id="ResolvedBarrierScan"></a>

<p><pre><code class="lang-c++"><font color="brown">// <a href="#ResolvedBarrierScan">ResolvedBarrierScan</a> marks an optimization barrier during query planning.
// It wraps an `input_scan` and ensures `input_scan` is evaluated as if
// `input_scan` stands alone; plan transformations that may cause
// different observable side effects may not cross the optimization barrier.
//
// The output rows of a <a href="#ResolvedBarrierScan">ResolvedBarrierScan</a> are the same as those of the
// `input_scan`, propagating the `is_ordered` property of `input_scan`.
//
// The following optimizations are allowed:
// * Prune an unused column of a <a href="#ResolvedBarrierScan">ResolvedBarrierScan</a>.
// * Prune the whole <a href="#ResolvedBarrierScan">ResolvedBarrierScan</a>.
//
// This node does not have a corresponding syntax.</font>
class ResolvedBarrierScan : public <a href="#ResolvedScan">ResolvedScan</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_BARRIER_SCAN;

  const <a href="#ResolvedScan">ResolvedScan</a>* input_scan() const;
};
</code></pre></p>

### ResolvedCreateConnectionStmt
<a id="ResolvedCreateConnectionStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// CREATE [OR REPLACE] [TEMP] CONNECTION
// [IF NOT EXISTS] &lt;name&gt; [OPTIONS (name=value, ...)]
//
// builds a new connection based on the inputs provided via the
// the OPTIONS field.
//
// &lt;name&gt; is the name of the fully qualified connection.
// &lt;option_list&gt; is the list of options for the connection.</font>
class ResolvedCreateConnectionStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_CONNECTION_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedAlterConnectionStmt
<a id="ResolvedAlterConnectionStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This statement:
// ALTER CONNECTION [IF EXISTS] &lt;name_path&gt; SET OPTIONS(...)</font>
class ResolvedAlterConnectionStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_CONNECTION_STMT;

};
</code></pre></p>

### ResolvedLockMode
<a id="ResolvedLockMode"></a>

<p><pre><code class="lang-c++"><font color="brown">// <a href="#ResolvedLockMode">ResolvedLockMode</a> optionally indicates whether locks should be
// acquired on the data accessed during a <a href="#ResolvedTableScan">ResolvedTableScan</a>.
//
// `strength` specifies the strength of the locks to be acquired.</font>
class ResolvedLockMode : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_LOCK_MODE;

  typedef <a href="#ResolvedLockModeEnum">ResolvedLockModeEnums</a>::LockStrengthType LockStrengthType;
  static const LockStrengthType UPDATE = <a href="#ResolvedLockModeEnum">ResolvedLockModeEnums</a>::UPDATE;

  <a href="#ResolvedLockMode">ResolvedLockMode</a>::LockStrengthType strength() const;
};
</code></pre></p>

### ResolvedUpdateFieldItem
<a id="ResolvedUpdateFieldItem"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents the state for a single update operation for an UPDATE
// constructor.</font>
class ResolvedUpdateFieldItem : public <a href="#ResolvedArgument">ResolvedArgument</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UPDATE_FIELD_ITEM;

  typedef <a href="#ResolvedUpdateFieldItemEnum">ResolvedUpdateFieldItemEnums</a>::Operation Operation;
  static const Operation UPDATE_SINGLE = <a href="#ResolvedUpdateFieldItemEnum">ResolvedUpdateFieldItemEnums</a>::UPDATE_SINGLE;
  static const Operation UPDATE_MANY = <a href="#ResolvedUpdateFieldItemEnum">ResolvedUpdateFieldItemEnums</a>::UPDATE_MANY;
  static const Operation UPDATE_SINGLE_NO_CREATION = <a href="#ResolvedUpdateFieldItemEnum">ResolvedUpdateFieldItemEnums</a>::UPDATE_SINGLE_NO_CREATION;

<font color="brown">  // The value that the final field in &lt;proto_field_path&gt; will be set
  // to.
  //
  // If &lt;expr&gt; is NULL, the field will be unset. If &lt;proto_field_path&gt;
  // is a required field, the engine must return an error if it is set
  // to NULL.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

<font color="brown">  // A vector of FieldDescriptors that denotes the path to a proto
  // field that will be modified. Detailed semantics of how these work:
  // http://shortn/_54wG2DOuZg.</font>
  const std::vector&lt;const google::protobuf::FieldDescriptor*&gt;&amp; proto_field_path() const;
  int proto_field_path_size() const;
  const google::protobuf::FieldDescriptor* proto_field_path(int i) const;

<font color="brown">  // The operation that should be used to apply &lt;expr&gt; to
  // &lt;proto_field_path&gt;.</font>
  <a href="#ResolvedUpdateFieldItem">ResolvedUpdateFieldItem</a>::Operation operation() const;
};
</code></pre></p>

### ResolvedUpdateConstructor
<a id="ResolvedUpdateConstructor"></a>

<p><pre><code class="lang-c++"><font color="brown">// Represents an UPDATE constructor node. Details:
// (broken link).</font>
class ResolvedUpdateConstructor : public <a href="#ResolvedExpr">ResolvedExpr</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_UPDATE_CONSTRUCTOR;

<font color="brown">  // The protocol buffer to modify.</font>
  const <a href="#ResolvedExpr">ResolvedExpr</a>* expr() const;

  const std::string&amp; alias() const;

<font color="brown">  // A vector of field updates that should be applied to the protocol
  // buffer that is being modified.</font>
  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedUpdateFieldItem">ResolvedUpdateFieldItem</a>&gt;&gt;&amp; update_field_item_list() const;
  int update_field_item_list_size() const;
  const <a href="#ResolvedUpdateFieldItem">ResolvedUpdateFieldItem</a>* update_field_item_list(int i) const;
};
</code></pre></p>

### ResolvedCreateSequenceStmt
<a id="ResolvedCreateSequenceStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a CREATE SEQUENCE statement, i.e.,
// CREATE [OR REPLACE] SEQUENCE
//   [IF NOT EXISTS] &lt;name_path&gt; [OPTIONS &lt;option_list&gt;];
//
// &lt;name&gt; is the name of the fully qualified sequence.
// &lt;option_list&gt; is the list of options for the sequence.</font>
class ResolvedCreateSequenceStmt : public <a href="#ResolvedCreateStatement">ResolvedCreateStatement</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_CREATE_SEQUENCE_STMT;

  const std::vector&lt;std::unique_ptr&lt;const <a href="#ResolvedOption">ResolvedOption</a>&gt;&gt;&amp; option_list() const;
  int option_list_size() const;
  const <a href="#ResolvedOption">ResolvedOption</a>* option_list(int i) const;
};
</code></pre></p>

### ResolvedAlterSequenceStmt
<a id="ResolvedAlterSequenceStmt"></a>

<p><pre><code class="lang-c++"><font color="brown">// This represents a ALTER SEQUENCE statement, i.e.,
// ALTER SEQUENCE [IF EXISTS] &lt;name_path&gt; SET OPTIONS(option_list)
//
// &lt;name&gt; is the name of the fully qualified sequence.
// &lt;option_list&gt; is the list of options for the sequence.</font>
class ResolvedAlterSequenceStmt : public <a href="#ResolvedAlterObjectStmt">ResolvedAlterObjectStmt</a> {
  static const ResolvedNodeKind TYPE = RESOLVED_ALTER_SEQUENCE_STMT;

};
</code></pre></p>

